import { StoreFactory as _DatasetFactory } from "n3";

const datasetFactory = new _DatasetFactory();

import type * as rdfjs from "@rdfjs/types";
import { sha256 } from "js-sha256";
import { DataFactory as dataFactory } from "n3";
import * as purify from "purify-ts";
import * as rdfjsResource from "rdfjs-resource";
import * as sparqljs from "sparqljs";
import * as uuid from "uuid";
import { z as zod } from "zod";
import { ExternClass } from "./ExternClass.js";

/**
 * Compare two arrays element-wise with the provided elementEquals function.
 */
function $arrayEquals<T>(
  leftArray: readonly T[],
  rightArray: readonly T[],
  elementEquals: (left: T, right: T) => boolean | $EqualsResult,
): $EqualsResult {
  if (leftArray.length !== rightArray.length) {
    return purify.Left({
      left: leftArray,
      right: rightArray,
      type: "ArrayLength",
    });
  }

  for (
    let leftElementIndex = 0;
    leftElementIndex < leftArray.length;
    leftElementIndex++
  ) {
    const leftElement = leftArray[leftElementIndex];

    const rightUnequals: $EqualsResult.Unequal[] = [];
    for (
      let rightElementIndex = 0;
      rightElementIndex < rightArray.length;
      rightElementIndex++
    ) {
      const rightElement = rightArray[rightElementIndex];

      const leftElementEqualsRightElement =
        $EqualsResult.fromBooleanEqualsResult(
          leftElement,
          rightElement,
          elementEquals(leftElement, rightElement),
        );
      if (leftElementEqualsRightElement.isRight()) {
        break; // left element === right element, break out of the right iteration
      }
      rightUnequals.push(
        leftElementEqualsRightElement.extract() as $EqualsResult.Unequal,
      );
    }

    if (rightUnequals.length === rightArray.length) {
      // All right elements were unequal to the left element
      return purify.Left({
        left: {
          array: leftArray,
          element: leftElement,
          elementIndex: leftElementIndex,
        },
        right: {
          array: rightArray,
          unequals: rightUnequals,
        },
        type: "ArrayElement",
      });
    }
    // Else there was a right element equal to the left element, continue to the next left element
  }

  return $EqualsResult.Equal;
}

function $arrayIntersection<T>(
  left: readonly T[],
  right: readonly T[],
): readonly T[] {
  if (left.length === 0) {
    return right;
  }
  if (right.length === 0) {
    return left;
  }

  const intersection = new Set<T>();
  if (left.length <= right.length) {
    const rightSet = new Set(right);
    for (const leftElement of left) {
      if (rightSet.has(leftElement)) {
        intersection.add(leftElement);
      }
    }
  } else {
    const leftSet = new Set(left);
    for (const rightElement of right) {
      if (leftSet.has(rightElement)) {
        intersection.add(rightElement);
      }
    }
  }
  return [...intersection];
}

interface $BlankNodeFilter {}

namespace $BlankNodeFilter {
  export function $sparqlWherePatterns(
    _filter: $BlankNodeFilter | undefined,
    _value: rdfjs.Variable,
  ) {
    return [];
  }
}

/**
 * Compare two objects with equals(other: T): boolean methods and return an $EqualsResult.
 */
function $booleanEquals<T extends { equals: (other: T) => boolean }>(
  left: T,
  right: T,
): $EqualsResult {
  return $EqualsResult.fromBooleanEqualsResult(left, right, left.equals(right));
}

interface $BooleanFilter {
  readonly value?: boolean;
}

namespace $BooleanFilter {
  export function $sparqlWherePatterns(
    filter: $BooleanFilter | undefined,
    value: rdfjs.Variable,
  ) {
    const patterns: sparqljs.Pattern[] = [];

    if (!filter) {
      return patterns;
    }

    if (typeof filter.value !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "=",
          args: [value, $toLiteral(filter.value)],
        },
      });
    }

    return patterns;
  }
}

type $CollectionFilter<ItemFilterT> = ItemFilterT & {
  readonly $maxCount?: number;
  readonly $minCount?: number;
};
/**
 * Compare two Dates and return an $EqualsResult.
 */
function $dateEquals(left: Date, right: Date): $EqualsResult {
  return $EqualsResult.fromBooleanEqualsResult(
    left,
    right,
    left.getTime() === right.getTime(),
  );
}

interface $DateFilter {
  readonly in?: readonly Date[];
  readonly maxExclusive?: Date;
  readonly maxInclusive?: Date;
  readonly minExclusive?: Date;
  readonly minInclusive?: Date;
}

namespace $DateFilter {
  export function $sparqlWherePatterns(
    filter: $DateFilter | undefined,
    value: rdfjs.Variable,
  ): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];

    if (!filter) {
      return patterns;
    }

    if (typeof filter.in !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "in",
          args: [value, filter.in.map((inValue) => $toLiteral(inValue))],
        },
      });
    }

    if (typeof filter.maxExclusive !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "<",
          args: [value, $toLiteral(filter.maxExclusive)],
        },
      });
    }

    if (typeof filter.maxInclusive !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "<=",
          args: [value, $toLiteral(filter.maxInclusive)],
        },
      });
    }

    if (typeof filter.minExclusive !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: ">",
          args: [value, $toLiteral(filter.minExclusive)],
        },
      });
    }

    if (typeof filter.minInclusive !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: ">=",
          args: [value, $toLiteral(filter.minInclusive)],
        },
      });
    }

    return patterns;
  }
}

function $deduplicateSparqlWherePatterns(
  patterns: readonly sparqljs.Pattern[],
): readonly sparqljs.Pattern[] {
  const deduplicatedPatterns: sparqljs.Pattern[] = [];
  const deduplicatePatternStrings = new Set<string>();
  for (const pattern of patterns) {
    const patternString = JSON.stringify(pattern);
    if (!deduplicatePatternStrings.has(patternString)) {
      deduplicatePatternStrings.add(patternString);
      deduplicatedPatterns.push(pattern);
    }
  }
  return deduplicatedPatterns;
}

export type $EqualsResult = purify.Either<$EqualsResult.Unequal, true>;

export namespace $EqualsResult {
  export const Equal: $EqualsResult = purify.Either.of<Unequal, true>(true);

  export function fromBooleanEqualsResult(
    left: any,
    right: any,
    equalsResult: boolean | $EqualsResult,
  ): $EqualsResult {
    if (typeof equalsResult !== "boolean") {
      return equalsResult;
    }

    if (equalsResult) {
      return Equal;
    }

    return purify.Left({ left, right, type: "BooleanEquals" });
  }

  export type Unequal =
    | {
        readonly left: {
          readonly array: readonly any[];
          readonly element: any;
          readonly elementIndex: number;
        };
        readonly right: {
          readonly array: readonly any[];
          readonly unequals: readonly Unequal[];
        };
        readonly type: "ArrayElement";
      }
    | {
        readonly left: readonly any[];
        readonly right: readonly any[];
        readonly type: "ArrayLength";
      }
    | {
        readonly left: any;
        readonly right: any;
        readonly type: "BooleanEquals";
      }
    | {
        readonly left: any;
        readonly right: any;
        readonly type: "LeftError";
      }
    | {
        readonly right: any;
        readonly type: "LeftNull";
      }
    | {
        readonly left: bigint | boolean | number | string;
        readonly right: bigint | boolean | number | string;
        readonly type: "Primitive";
      }
    | {
        readonly left: any;
        readonly right: any;
        readonly propertyName: string;
        readonly propertyValuesUnequal: Unequal;
        readonly type: "Property";
      }
    | {
        readonly left: any;
        readonly right: any;
        readonly type: "RightError";
      }
    | {
        readonly left: any;
        readonly type: "RightNull";
      };
}

function $filterArray<ItemT, ItemFilterT>(
  filterItem: (itemFilter: ItemFilterT, item: ItemT) => boolean,
) {
  return (
    filter: $CollectionFilter<ItemFilterT>,
    values: readonly ItemT[],
  ): boolean => {
    for (const value of values) {
      if (!filterItem(filter, value)) {
        return false;
      }
    }

    if (
      typeof filter.$maxCount !== "undefined" &&
      values.length > filter.$maxCount
    ) {
      return false;
    }

    if (
      typeof filter.$minCount !== "undefined" &&
      values.length < filter.$minCount
    ) {
      return false;
    }

    return true;
  };
}

function $filterBlankNode(_filter: $BlankNodeFilter, _value: rdfjs.BlankNode) {
  return true;
}

function $filterBoolean(filter: $BooleanFilter, value: boolean) {
  if (typeof filter.value !== "undefined" && value !== filter.value) {
    return false;
  }

  return true;
}

function $filterDate(filter: $DateFilter, value: Date) {
  if (
    typeof filter.in !== "undefined" &&
    !filter.in.some((inValue) => inValue.getTime() === value.getTime())
  ) {
    return false;
  }

  if (
    typeof filter.maxExclusive !== "undefined" &&
    value.getTime() >= filter.maxExclusive.getTime()
  ) {
    return false;
  }

  if (
    typeof filter.maxInclusive !== "undefined" &&
    value.getTime() > filter.maxInclusive.getTime()
  ) {
    return false;
  }

  if (
    typeof filter.minExclusive !== "undefined" &&
    value.getTime() <= filter.minExclusive.getTime()
  ) {
    return false;
  }

  if (
    typeof filter.minInclusive !== "undefined" &&
    value.getTime() < filter.minInclusive.getTime()
  ) {
    return false;
  }

  return true;
}

function $filterIdentifier(
  filter: $IdentifierFilter,
  value: rdfjs.BlankNode | rdfjs.NamedNode,
) {
  if (
    typeof filter.in !== "undefined" &&
    !filter.in.some((inValue) => inValue.equals(value))
  ) {
    return false;
  }

  if (typeof filter.type !== "undefined" && value.termType !== filter.type) {
    return false;
  }

  return true;
}

function $filterLiteral(filter: $LiteralFilter, value: rdfjs.Literal): boolean {
  return $filterTerm(filter, value);
}

function $filterMaybe<ItemT, ItemFilterT>(
  filterItem: (itemFilter: ItemFilterT, item: ItemT) => boolean,
) {
  return (
    filter: $MaybeFilter<ItemFilterT>,
    value: purify.Maybe<ItemT>,
  ): boolean => {
    if (filter !== null) {
      if (value.isNothing()) {
        return false;
      }

      if (!filterItem(filter, value.extract()!)) {
        return false;
      }
    } else {
      if (value.isJust()) {
        return false;
      }
    }

    return true;
  };
}

function $filterNamedNode(filter: $NamedNodeFilter, value: rdfjs.NamedNode) {
  if (
    typeof filter.in !== "undefined" &&
    !filter.in.some((inValue) => inValue.equals(value))
  ) {
    return false;
  }

  return true;
}

function $filterNumber(filter: $NumberFilter, value: number) {
  if (
    typeof filter.in !== "undefined" &&
    !filter.in.some((inValue) => inValue === value)
  ) {
    return false;
  }

  if (
    typeof filter.maxExclusive !== "undefined" &&
    value >= filter.maxExclusive
  ) {
    return false;
  }

  if (
    typeof filter.maxInclusive !== "undefined" &&
    value > filter.maxInclusive
  ) {
    return false;
  }

  if (
    typeof filter.minExclusive !== "undefined" &&
    value <= filter.minExclusive
  ) {
    return false;
  }

  if (
    typeof filter.minInclusive !== "undefined" &&
    value < filter.minInclusive
  ) {
    return false;
  }

  return true;
}

function $filterString(filter: $StringFilter, value: string) {
  if (
    typeof filter.in !== "undefined" &&
    !filter.in.some((inValue) => inValue === value)
  ) {
    return false;
  }

  if (
    typeof filter.maxLength !== "undefined" &&
    value.length > filter.maxLength
  ) {
    return false;
  }

  if (
    typeof filter.minLength !== "undefined" &&
    value.length < filter.minLength
  ) {
    return false;
  }

  return true;
}

function $filterTerm(
  filter: $TermFilter,
  value: rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode,
): boolean {
  if (
    typeof filter.datatypeIn !== "undefined" &&
    (value.termType !== "Literal" ||
      !filter.datatypeIn.some((inDatatype) =>
        inDatatype.equals(value.datatype),
      ))
  ) {
    return false;
  }

  if (
    typeof filter.in !== "undefined" &&
    !filter.in.some((inTerm) => inTerm.equals(value))
  ) {
    return false;
  }

  if (
    typeof filter.languageIn !== "undefined" &&
    (value.termType !== "Literal" ||
      !filter.languageIn.some((inLanguage) => inLanguage === value.language))
  ) {
    return false;
  }

  if (
    typeof filter.typeIn !== "undefined" &&
    !filter.typeIn.some((inType) => inType === value.termType)
  ) {
    return false;
  }

  return true;
}

function $fromRdfPreferredLanguages({
  focusResource,
  predicate,
  preferredLanguages,
  values,
}: {
  focusResource: rdfjsResource.Resource;
  predicate: rdfjs.NamedNode;
  preferredLanguages?: readonly string[];
  values: rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>;
}): purify.Either<
  Error,
  rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
> {
  if (!preferredLanguages || preferredLanguages.length === 0) {
    return purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(values);
  }

  return values
    .chainMap((value) => value.toLiteral())
    .map((literalValues) => {
      // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
      // Within a preferredLanguage the literals may be in any order.
      let filteredLiteralValues:
        | rdfjsResource.Resource.Values<rdfjs.Literal>
        | undefined;
      for (const preferredLanguage of preferredLanguages) {
        if (!filteredLiteralValues) {
          filteredLiteralValues = literalValues.filter(
            (value) => value.language === preferredLanguage,
          );
        } else {
          filteredLiteralValues = filteredLiteralValues.concat(
            ...literalValues
              .filter((value) => value.language === preferredLanguage)
              .toArray(),
          );
        }
      }

      return filteredLiteralValues!.map(
        (literalValue) =>
          new rdfjsResource.Resource.TermValue({
            focusResource,
            predicate,
            term: literalValue,
          }),
      );
    });
}

interface $IdentifierFilter {
  readonly in?: readonly (rdfjs.BlankNode | rdfjs.NamedNode)[];
  readonly type?: "BlankNode" | "NamedNode";
}

namespace $IdentifierFilter {
  export function $sparqlWherePatterns(
    filter: $IdentifierFilter | undefined,
    value: rdfjs.Variable,
  ) {
    const patterns: sparqljs.Pattern[] = [];

    if (!filter) {
      return patterns;
    }

    if (typeof filter.in !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "in",
          args: [
            value,
            filter.in.filter(
              (identifier) => identifier.termType === "NamedNode",
            ),
          ],
        },
      });
    }

    if (typeof filter.type !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: filter.type === "BlankNode" ? "isBlank" : "isIRI",
          args: [value],
        },
      });
    }

    return patterns;
  }
}

class $IdentifierSet {
  private readonly blankNodeValues = new Set<string>();
  private readonly namedNodeValues = new Set<string>();

  add(identifier: rdfjs.BlankNode | rdfjs.NamedNode): this {
    switch (identifier.termType) {
      case "BlankNode":
        this.blankNodeValues.add(identifier.value);
        return this;
      case "NamedNode":
        this.namedNodeValues.add(identifier.value);
        return this;
    }
  }

  has(identifier: rdfjs.BlankNode | rdfjs.NamedNode): boolean {
    switch (identifier.termType) {
      case "BlankNode":
        return this.blankNodeValues.has(identifier.value);
      case "NamedNode":
        return this.namedNodeValues.has(identifier.value);
    }
  }
}

/**
 * Insert a seed SPARQL where pattern if necessary.
 *
 * A SPARQL WHERE block that solely consists of OPTIONAL blocks won't match anything. OPTIONAL is a left join.
 * In that situation the solution is to insert a VALUES () { () } seed as the first pattern in order to match the entire store.
 */
function $insertSeedSparqlWherePattern(
  patterns: readonly sparqljs.Pattern[],
): readonly sparqljs.Pattern[] {
  if (patterns.every((pattern) => pattern.type === "optional")) {
    return [{ values: [{}], type: "values" }, ...patterns];
  }
  return patterns;
}

function $isReadonlyBooleanArray(x: unknown): x is readonly boolean[] {
  return Array.isArray(x) && x.every((z) => typeof z === "boolean");
}

function $isReadonlyNumberArray(x: unknown): x is readonly number[] {
  return Array.isArray(x) && x.every((z) => typeof z === "number");
}

function $isReadonlyObjectArray(x: unknown): x is readonly object[] {
  return Array.isArray(x) && x.every((z) => typeof z === "object");
}

function $isReadonlyStringArray(x: unknown): x is readonly string[] {
  return Array.isArray(x) && x.every((z) => typeof z === "string");
}

/**
 * Type of lazy properties that return a single required object. This is a class instead of an interface so it can be instanceof'd elsewhere.
 */
export class $LazyObject<
  ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  PartialObjectT extends { $identifier: ObjectIdentifierT },
  ResolvedObjectT extends { $identifier: ObjectIdentifierT },
> {
  readonly partial: PartialObjectT;
  private readonly resolver: (
    identifier: ObjectIdentifierT,
  ) => Promise<purify.Either<Error, ResolvedObjectT>>;

  constructor({
    partial,
    resolver,
  }: {
    partial: PartialObjectT;
    resolver: (
      identifier: ObjectIdentifierT,
    ) => Promise<purify.Either<Error, ResolvedObjectT>>;
  }) {
    this.partial = partial;
    this.resolver = resolver;
  }

  resolve(): Promise<purify.Either<Error, ResolvedObjectT>> {
    return this.resolver(this.partial.$identifier);
  }
}

/**
 * Type of lazy properties that return a single optional object. This is a class instead of an interface so it can be instanceof'd elsewhere.
 */
export class $LazyObjectOption<
  ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  PartialObjectT extends { $identifier: ObjectIdentifierT },
  ResolvedObjectT extends { $identifier: ObjectIdentifierT },
> {
  readonly partial: purify.Maybe<PartialObjectT>;
  private readonly resolver: (
    identifier: ObjectIdentifierT,
  ) => Promise<purify.Either<Error, ResolvedObjectT>>;

  constructor({
    partial,
    resolver,
  }: {
    partial: purify.Maybe<PartialObjectT>;
    resolver: (
      identifier: ObjectIdentifierT,
    ) => Promise<purify.Either<Error, ResolvedObjectT>>;
  }) {
    this.partial = partial;
    this.resolver = resolver;
  }

  async resolve(): Promise<
    purify.Either<Error, purify.Maybe<ResolvedObjectT>>
  > {
    if (this.partial.isNothing()) {
      return purify.Either.of(purify.Maybe.empty());
    }
    return (await this.resolver(this.partial.unsafeCoerce().$identifier)).map(
      purify.Maybe.of,
    );
  }
}

/**
 * Type of lazy properties that return a set of objects. This is a class instead of an interface so it can be instanceof'd elsewhere.
 */
export class $LazyObjectSet<
  ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  PartialObjectT extends { $identifier: ObjectIdentifierT },
  ResolvedObjectT extends { $identifier: ObjectIdentifierT },
> {
  readonly partials: readonly PartialObjectT[];
  private readonly resolver: (
    identifiers: readonly ObjectIdentifierT[],
  ) => Promise<purify.Either<Error, readonly ResolvedObjectT[]>>;

  constructor({
    partials,
    resolver,
  }: {
    partials: readonly PartialObjectT[];
    resolver: (
      identifiers: readonly ObjectIdentifierT[],
    ) => Promise<purify.Either<Error, readonly ResolvedObjectT[]>>;
  }) {
    this.partials = partials;
    this.resolver = resolver;
  }

  get length(): number {
    return this.partials.length;
  }

  async resolve(options?: {
    limit?: number;
    offset?: number;
  }): Promise<purify.Either<Error, readonly ResolvedObjectT[]>> {
    if (this.partials.length === 0) {
      return purify.Either.of([]);
    }

    const limit = options?.limit ?? Number.MAX_SAFE_INTEGER;
    if (limit <= 0) {
      return purify.Either.of([]);
    }

    let offset = options?.offset ?? 0;
    if (offset < 0) {
      offset = 0;
    }

    return await this.resolver(
      this.partials
        .slice(offset, offset + limit)
        .map((partial) => partial.$identifier),
    );
  }
}

interface $LiteralFilter extends Omit<$TermFilter, "in" | "type"> {
  readonly in?: readonly rdfjs.Literal[];
}

namespace $LiteralFilter {
  export function $sparqlWherePatterns(
    filter: $LiteralFilter | undefined,
    value: rdfjs.Variable,
  ) {
    return $TermFilter.$sparqlWherePatterns(filter, value);
  }
}

function $maybeEquals<T>(
  leftMaybe: purify.Maybe<T>,
  rightMaybe: purify.Maybe<T>,
  valueEquals: (left: T, right: T) => boolean | $EqualsResult,
): $EqualsResult {
  if (leftMaybe.isJust()) {
    if (rightMaybe.isJust()) {
      return $EqualsResult.fromBooleanEqualsResult(
        leftMaybe,
        rightMaybe,
        valueEquals(leftMaybe.unsafeCoerce(), rightMaybe.unsafeCoerce()),
      );
    }
    return purify.Left({
      left: leftMaybe.unsafeCoerce(),
      type: "RightNull",
    });
  }

  if (rightMaybe.isJust()) {
    return purify.Left({
      right: rightMaybe.unsafeCoerce(),
      type: "LeftNull",
    });
  }

  return $EqualsResult.Equal;
}

type $MaybeFilter<ItemFilterT> = ItemFilterT | null;
namespace $MaybeFilter {
  export function $sparqlWherePatterns<ItemFilterT>(
    filter: $MaybeFilter<ItemFilterT> | undefined,
    itemSparqlWherePatterns: (
      itemFilter: ItemFilterT | undefined,
    ) => readonly sparqljs.Pattern[],
  ): readonly sparqljs.Pattern[] {
    if (filter === null) {
      return [
        {
          expression: {
            args: itemSparqlWherePatterns(undefined).concat(),
            operator: "notexists",
            type: "operation",
          },
          type: "filter",
        },
      ];
    }

    return [
      { patterns: itemSparqlWherePatterns(filter).concat(), type: "optional" },
    ];
  }
}

interface $NamedNodeFilter {
  readonly in?: readonly rdfjs.NamedNode[];
}

namespace $NamedNodeFilter {
  export function $sparqlWherePatterns(
    filter: $NamedNodeFilter | undefined,
    value: rdfjs.Variable,
  ) {
    const patterns: sparqljs.Pattern[] = [];

    if (!filter) {
      return patterns;
    }

    if (typeof filter.in !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "in",
          args: [value, filter.in.concat()],
        },
      });
    }

    return patterns;
  }
}

interface $NumberFilter {
  readonly in?: readonly number[];
  readonly maxExclusive?: number;
  readonly maxInclusive?: number;
  readonly minExclusive?: number;
  readonly minInclusive?: number;
}

namespace $NumberFilter {
  export function $sparqlWherePatterns(
    filter: $NumberFilter | undefined,
    value: rdfjs.Variable,
  ): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];

    if (!filter) {
      return patterns;
    }

    if (typeof filter.in !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "in",
          args: [value, filter.in.map((inValue) => $toLiteral(inValue))],
        },
      });
    }

    if (typeof filter.maxExclusive !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "<",
          args: [value, $toLiteral(filter.maxExclusive)],
        },
      });
    }

    if (typeof filter.maxInclusive !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "<=",
          args: [value, $toLiteral(filter.maxInclusive)],
        },
      });
    }

    if (typeof filter.minExclusive !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: ">",
          args: [value, $toLiteral(filter.minExclusive)],
        },
      });
    }

    if (typeof filter.minInclusive !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: ">=",
          args: [value, $toLiteral(filter.minInclusive)],
        },
      });
    }

    return patterns;
  }
}

function $optimizeSparqlWherePatterns(
  patterns: readonly sparqljs.Pattern[],
): readonly sparqljs.Pattern[] {
  if (patterns.length === 0) {
    return patterns;
  }

  const filterPatterns: sparqljs.Pattern[] = [];
  const valuesPatterns: sparqljs.Pattern[] = [];
  const otherPatterns: sparqljs.Pattern[] = [];

  for (const pattern of patterns) {
    switch (pattern.type) {
      case "bgp": {
        if (pattern.triples.length === 0) {
          continue;
        }
        const lastPattern = otherPatterns.at(-1);
        if (lastPattern && lastPattern.type === "bgp") {
          // Coalesce adjacent BGP patterns
          lastPattern.triples.push(...pattern.triples);
        } else {
          otherPatterns.push(pattern);
        }
        break;
      }
      case "bind":
      case "query":
        otherPatterns.push(pattern);
        break;
      case "filter":
        filterPatterns.push(pattern);
        break;
      case "group":
        // Flatten groups outside unions
        otherPatterns.push(...$optimizeSparqlWherePatterns(pattern.patterns));
        break;
      case "values":
        valuesPatterns.push(pattern);
        break;
      case "graph":
      case "minus":
      case "optional":
      case "service": {
        const optimizedPatterns = $optimizeSparqlWherePatterns(
          pattern.patterns,
        );
        if (optimizedPatterns.length > 0) {
          otherPatterns.push({
            ...pattern,
            patterns: optimizedPatterns.concat(),
          });
        }
        break;
      }
      case "union": {
        const unionPatterns = $deduplicateSparqlWherePatterns(
          pattern.patterns.flatMap((pattern) => {
            switch (pattern.type) {
              case "group":
              // Don't flatten the groups in a union
              case "graph":
              case "minus":
              case "optional":
              case "service": {
                const optimizedPatterns = $optimizeSparqlWherePatterns(
                  pattern.patterns,
                );
                if (optimizedPatterns.length > 0) {
                  return [{ ...pattern, patterns: optimizedPatterns.concat() }];
                }
                return [] as sparqljs.Pattern[];
              }
              default:
                return [pattern];
            }
          }),
        );

        switch (unionPatterns.length) {
          case 0:
            break;
          case 1:
            otherPatterns.push(
              ...$optimizeSparqlWherePatterns([unionPatterns[0]]),
            );
            break;
          default:
            otherPatterns.push({
              ...pattern,
              patterns: unionPatterns.concat(),
            });
            break;
        }
        break;
      }
      default:
        pattern satisfies never;
    }
  }

  return $deduplicateSparqlWherePatterns(
    valuesPatterns.concat(otherPatterns).concat(filterPatterns),
  );
}

namespace $RdfVocabularies {
  export namespace rdf {
    export const first = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
    );
    export const nil = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil",
    );
    export const rest = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
    );
    export const subject = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#subject",
    );
    export const type = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    );
  }

  export namespace rdfs {
    export const subClassOf = dataFactory.namedNode(
      "http://www.w3.org/2000/01/rdf-schema#subClassOf",
    );
  }

  export namespace xsd {
    export const boolean = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#boolean",
    );
    export const date = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#date",
    );
    export const dateTime = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#dateTime",
    );
    export const decimal = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#decimal",
    );
    export const double = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#double",
    );
    export const integer = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#integer",
    );
  }
}

/**
 * A sparqljs.Pattern that's the equivalent of ?subject rdf:type/rdfs:subClassOf* ?rdfType .
 */
function $sparqlInstancesOfPattern({
  rdfType,
  subject,
}: {
  rdfType: rdfjs.NamedNode | rdfjs.Variable;
  subject: sparqljs.Triple["subject"];
}): sparqljs.Pattern {
  return {
    triples: [
      {
        subject,
        predicate: {
          items: [
            $RdfVocabularies.rdf.type,
            {
              items: [$RdfVocabularies.rdfs.subClassOf],
              pathType: "*",
              type: "path",
            },
          ],
          pathType: "/",
          type: "path",
        },
        object: rdfType,
      },
    ],
    type: "bgp",
  };
}

/**
 * Compare two values for strict equality (===), returning an $EqualsResult rather than a boolean.
 */
function $strictEquals<T extends bigint | boolean | number | string>(
  left: T,
  right: T,
): $EqualsResult {
  return $EqualsResult.fromBooleanEqualsResult(left, right, left === right);
}

interface $StringFilter {
  readonly in?: readonly string[];
  readonly maxLength?: number;
  readonly minLength?: number;
}

namespace $StringFilter {
  export function $sparqlWherePatterns(
    filter: $StringFilter | undefined,
    value: rdfjs.Variable,
  ) {
    const patterns: sparqljs.Pattern[] = [];

    if (!filter) {
      return patterns;
    }

    if (typeof filter.in !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "in",
          args: [value, filter.in.map((inValue) => $toLiteral(inValue))],
        },
      });
    }

    if (typeof filter.maxLength !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "<=",
          args: [
            { args: [value], operator: "strlen", type: "operation" },
            $toLiteral(filter.maxLength),
          ],
        },
      });
    }

    if (typeof filter.minLength !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: ">=",
          args: [
            { args: [value], operator: "strlen", type: "operation" },
            $toLiteral(filter.minLength),
          ],
        },
      });
    }

    return patterns;
  }
}

interface $TermFilter {
  readonly datatypeIn?: readonly rdfjs.NamedNode[];
  readonly in?: readonly (rdfjs.Literal | rdfjs.NamedNode)[];
  readonly languageIn?: readonly string[];
  readonly typeIn?: readonly ("BlankNode" | "Literal" | "NamedNode")[];
}

namespace $TermFilter {
  export function $sparqlWherePatterns(
    filter: $TermFilter | undefined,
    value: rdfjs.Variable,
  ): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];

    if (!filter) {
      return patterns;
    }

    if (typeof filter.datatypeIn !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "in",
          args: [
            { args: [value], operator: "datatype", type: "operation" },
            filter.datatypeIn.concat(),
          ],
        },
      });
    }

    if (typeof filter.in !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "in",
          args: [value, filter.in.concat()],
        },
      });
    }

    if (typeof filter.languageIn !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "in",
          args: [
            { args: [value], operator: "lang", type: "operation" },
            filter.languageIn.map((value) => dataFactory.literal(value)),
          ],
        },
      });
    }

    if (typeof filter.typeIn !== "undefined") {
      const typeInExpressions = filter.typeIn
        .map((inType) => {
          switch (inType) {
            case "BlankNode":
              return "isBlank";
            case "Literal":
              return "isLiteral";
            case "NamedNode":
              return "isIRI";
            default:
              inType satisfies never;
              throw new RangeError(inType);
          }
        })
        .map((operator) => ({
          type: "operation" as const,
          operator,
          args: [value],
        }));

      switch (typeInExpressions.length) {
        case 0:
          break;
        case 1:
          patterns.push({ type: "filter", expression: typeInExpressions[0] });
          break;
        default:
          patterns.push({
            type: "filter",
            expression: {
              type: "operation",
              operator: "||",
              args: typeInExpressions,
            },
          });
      }
    }

    return patterns;
  }
}

function $toLiteral(
  value: boolean | Date | number | string,
  datatype?: rdfjs.NamedNode,
): rdfjs.Literal {
  switch (typeof value) {
    case "boolean":
      return dataFactory.literal(
        value.toString(),
        $RdfVocabularies.xsd.boolean,
      );
    case "object": {
      if (value instanceof Date) {
        if (datatype) {
          if (datatype.equals($RdfVocabularies.xsd.date)) {
            return dataFactory.literal(
              value.toISOString().replace(/T.*$/, ""),
              datatype,
            );
          } else if (datatype.equals($RdfVocabularies.xsd.dateTime)) {
            return dataFactory.literal(value.toISOString(), datatype);
          } else {
            throw new RangeError(datatype.value);
          }
        }

        return dataFactory.literal(
          value.toISOString(),
          $RdfVocabularies.xsd.dateTime,
        );
      }
      value satisfies never;
      throw new Error("should never happen");
    }
    case "number": {
      if (datatype) {
        return dataFactory.literal(value.toString(10), datatype);
      }

      // Convert the number to a literal following SPARQL rules = tests on the lexical form
      const valueString = value.toString(10);
      if (/^[+-]?[0-9]+$/.test(valueString)) {
        // No decimal point, no exponent: xsd:integer
        return dataFactory.literal(valueString, $RdfVocabularies.xsd.integer);
      }
      if (
        /^[+-]?([0-9]+(\.[0-9]*)?|\.[0-9]+)[eE][+-]?[0-9]+$/.test(valueString)
      ) {
        // Has exponent: xsd:double
        return dataFactory.literal(valueString, $RdfVocabularies.xsd.double);
      }
      // Default: xsd:decimal
      return dataFactory.literal(valueString, $RdfVocabularies.xsd.decimal);
    }
    case "string":
      return dataFactory.literal(value, datatype);
  }
}

type $UnwrapR<T> = T extends purify.Either<any, infer R> ? R : never;
export class $NamedDefaultPartial {
  readonly $identifier: $NamedDefaultPartial.$Identifier;
  readonly $type = "$NamedDefaultPartial";

  constructor(parameters: { readonly $identifier: rdfjs.NamedNode | string }) {
    if (typeof parameters.$identifier === "object") {
      this.$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this.$identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      this.$identifier = parameters.$identifier satisfies never;
    }
  }

  $equals(other: $NamedDefaultPartial): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    return _hasher;
  }

  $toJson(): $NamedDefaultPartial.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
      } satisfies $NamedDefaultPartial.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(this.$identifier, {
      mutateGraph,
    });
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace $NamedDefaultPartial {
  export function $filter(
    filter: $NamedDefaultPartial.$Filter,
    value: $NamedDefaultPartial,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = { readonly $identifier?: $NamedNodeFilter };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, $NamedDefaultPartial> {
    return $propertiesFromJson(json).map(
      (properties) => new $NamedDefaultPartial(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, $NamedDefaultPartial> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return $NamedDefaultPartial
      .$propertiesFromRdf({
        context,
        ignoreRdfType,
        objectSet,
        preferredLanguages,
        resource,
      })
      .map((properties) => new $NamedDefaultPartial(properties));
  }

  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "$NamedDefaultPartial";
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "$NamedDefaultPartial" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "$NamedDefaultPartial",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("$NamedDefaultPartial"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {};

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<zod.ZodError, { $identifier: rdfjs.NamedNode }> {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    return purify.Either.of({ $identifier });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<Error, { $identifier: rdfjs.NamedNode }> {
    return (
      $parameters.resource.identifier.termType === "NamedNode"
        ? purify.Either.of<Error, $NamedDefaultPartial.$Identifier>(
            $parameters.resource.identifier,
          )
        : purify.Left(
            new rdfjsResource.Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "(rdfjs.NamedNode)",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
    ).map(($identifier) => ({ $identifier }));
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: $NamedDefaultPartial.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        $NamedDefaultPartial.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            $NamedDefaultPartial.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: $NamedDefaultPartial.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      $NamedDefaultPartial.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: $NamedDefaultPartial.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("namedDefaultPartial");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }

  export function is$NamedDefaultPartial(
    object: $Object,
  ): object is $NamedDefaultPartial {
    switch (object.$type) {
      case "$NamedDefaultPartial":
        return true;
      default:
        return false;
    }
  }
}
export class $DefaultPartial {
  readonly $identifier: $DefaultPartial.$Identifier;
  readonly $type = "$DefaultPartial";

  constructor(parameters: {
    readonly $identifier: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this.$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this.$identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      this.$identifier = parameters.$identifier satisfies never;
    }
  }

  $equals(other: $DefaultPartial): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    return _hasher;
  }

  $toJson(): $DefaultPartial.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
      } satisfies $DefaultPartial.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace $DefaultPartial {
  export function $filter(
    filter: $DefaultPartial.$Filter,
    value: $DefaultPartial,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = { readonly $identifier?: $IdentifierFilter };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, $DefaultPartial> {
    return $propertiesFromJson(json).map(
      (properties) => new $DefaultPartial(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, $DefaultPartial> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return $DefaultPartial
      .$propertiesFromRdf({
        context,
        ignoreRdfType,
        objectSet,
        preferredLanguages,
        resource,
      })
      .map((properties) => new $DefaultPartial(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "$DefaultPartial";
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "$DefaultPartial" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "$DefaultPartial",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("$DefaultPartial"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {};

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    return purify.Either.of({ $identifier });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<Error, { $identifier: rdfjs.BlankNode | rdfjs.NamedNode }> {
    return purify.Either.of<Error, $DefaultPartial.$Identifier>(
      $parameters.resource.identifier as $DefaultPartial.$Identifier,
    ).map(($identifier) => ({ $identifier }));
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: $DefaultPartial.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        $DefaultPartial.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            $DefaultPartial.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: $DefaultPartial.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      $DefaultPartial.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: $DefaultPartial.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("defaultPartial");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }

  export function is$DefaultPartial(
    object: $Object,
  ): object is $DefaultPartial {
    switch (object.$type) {
      case "$DefaultPartial":
        return true;
      default:
        return false;
    }
  }
}
/**
 * A node shape that mints its identifier by generating a v4 UUID, if no identifier is supplied.
 */
export interface UuidV4IriIdentifierInterface {
  readonly $identifier: UuidV4IriIdentifierInterface.$Identifier;
  readonly $type: "UuidV4IriIdentifierInterface";
  readonly uuidV4IriProperty: string;
}

export namespace UuidV4IriIdentifierInterface {
  export function $create(parameters: {
    readonly $identifier?: rdfjs.NamedNode | string;
    readonly $identifierPrefix?: string;
    readonly uuidV4IriProperty: string;
  }): Omit<UuidV4IriIdentifierInterface, "$identifierPrefix"> {
    let $identifier: UuidV4IriIdentifierInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.namedNode(
        `${parameters.$identifierPrefix ?? "urn:shaclmate:UuidV4IriIdentifierInterface:"}${uuid.v4()}`,
      );
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "UuidV4IriIdentifierInterface" as const;
    const uuidV4IriProperty = parameters.uuidV4IriProperty;
    return { $identifier, $type, uuidV4IriProperty };
  }

  export function $equals(
    left: UuidV4IriIdentifierInterface,
    right: UuidV4IriIdentifierInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(left.uuidV4IriProperty, right.uuidV4IriProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "uuidV4IriProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  export function $filter(
    filter: UuidV4IriIdentifierInterface.$Filter,
    value: UuidV4IriIdentifierInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.uuidV4IriProperty !== "undefined" &&
      !$filterString(filter.uuidV4IriProperty, value.uuidV4IriProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
    readonly uuidV4IriProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, UuidV4IriIdentifierInterface> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, UuidV4IriIdentifierInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return UuidV4IriIdentifierInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _uuidV4IriIdentifierInterface: UuidV4IriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_uuidV4IriIdentifierInterface.$identifier.value);
    _hasher.update(_uuidV4IriIdentifierInterface.$type);
    UuidV4IriIdentifierInterface.$hashShaclProperties(
      _uuidV4IriIdentifierInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _uuidV4IriIdentifierInterface: UuidV4IriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_uuidV4IriIdentifierInterface.uuidV4IriProperty);
    return _hasher;
  }

  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "UuidV4IriIdentifierInterface";
    readonly uuidV4IriProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "UuidV4IriIdentifierInterface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/uuidV4IriProperty`,
          type: "Control",
        },
      ],
      label: "UuidV4IriIdentifierInterface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("UuidV4IriIdentifierInterface"),
      uuidV4IriProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    uuidV4IriProperty: {
      identifier: dataFactory.namedNode("http://example.com/uuidV4IriProperty"),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.NamedNode;
      $type: "UuidV4IriIdentifierInterface";
      uuidV4IriProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const $type = "UuidV4IriIdentifierInterface" as const;
    const uuidV4IriProperty = $jsonObject["uuidV4IriProperty"];
    return purify.Either.of({ $identifier, $type, uuidV4IriProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.NamedNode;
      $type: "UuidV4IriIdentifierInterface";
      uuidV4IriProperty: string;
    }
  > {
    return (
      $parameters.resource.identifier.termType === "NamedNode"
        ? purify.Either.of<Error, UuidV4IriIdentifierInterface.$Identifier>(
            $parameters.resource.identifier,
          )
        : purify.Left(
            new rdfjsResource.Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "(rdfjs.NamedNode)",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
    ).chain(($identifier) =>
      purify.Either.of<Error, "UuidV4IriIdentifierInterface">(
        "UuidV4IriIdentifierInterface",
      ).chain(($type) =>
        purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
        >(
          $parameters.resource.values(
            $properties.uuidV4IriProperty["identifier"],
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                UuidV4IriIdentifierInterface.$properties.uuidV4IriProperty[
                  "identifier"
                ],
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((uuidV4IriProperty) => ({
            $identifier,
            $type,
            uuidV4IriProperty,
          })),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: UuidV4IriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        UuidV4IriIdentifierInterface.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            UuidV4IriIdentifierInterface.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: UuidV4IriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      UuidV4IriIdentifierInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("uuidV4IriIdentifierInterface");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "uuidV4IriIdentifierInterface")}UuidV4IriProperty`,
      ),
      predicate:
        UuidV4IriIdentifierInterface.$properties.uuidV4IriProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: UuidV4IriIdentifierInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("uuidV4IriIdentifierInterface");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "uuidV4IriIdentifierInterface")}UuidV4IriProperty`,
            ),
            predicate:
              UuidV4IriIdentifierInterface.$properties.uuidV4IriProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "uuidV4IriIdentifierInterface")}UuidV4IriProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.uuidV4IriProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "uuidV4IriIdentifierInterface")}UuidV4IriProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _uuidV4IriIdentifierInterface: UuidV4IriIdentifierInterface,
  ): UuidV4IriIdentifierInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": _uuidV4IriIdentifierInterface.$identifier.value,
        $type: _uuidV4IriIdentifierInterface.$type,
        uuidV4IriProperty: _uuidV4IriIdentifierInterface.uuidV4IriProperty,
      } satisfies UuidV4IriIdentifierInterface.$Json),
    );
  }

  export function $toRdf(
    _uuidV4IriIdentifierInterface: UuidV4IriIdentifierInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(
      _uuidV4IriIdentifierInterface.$identifier,
      { mutateGraph },
    );
    resource.add(
      UuidV4IriIdentifierInterface.$properties.uuidV4IriProperty["identifier"],
      ...[_uuidV4IriIdentifierInterface.uuidV4IriProperty],
    );
    return resource;
  }

  export function isUuidV4IriIdentifierInterface(
    object: $Object,
  ): object is UuidV4IriIdentifierInterface {
    switch (object.$type) {
      case "UuidV4IriIdentifierInterface":
        return true;
      default:
        return false;
    }
  }
}
/**
 * A node shape that mints its identifier by generating a v4 UUID, if no identifier is supplied.
 */
export class UuidV4IriIdentifierClass {
  private _$identifier?: UuidV4IriIdentifierClass.$Identifier;
  protected readonly _$identifierPrefix?: string;
  readonly $type = "UuidV4IriIdentifierClass";
  readonly uuidV4IriProperty: string;

  constructor(parameters: {
    readonly $identifier?: rdfjs.NamedNode | string;
    readonly $identifierPrefix?: string;
    readonly uuidV4IriProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this._$identifierPrefix = parameters.$identifierPrefix;
    this.uuidV4IriProperty = parameters.uuidV4IriProperty;
  }

  get $identifier(): UuidV4IriIdentifierClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${uuid.v4()}`,
      );
    }

    if (this._$identifier.termType !== "NamedNode") {
      throw new Error(
        `expected identifier to be NamedNode, not ${this._$identifier.termType}`,
      );
    }

    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  $equals(other: UuidV4IriIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$identifierPrefix, other.$identifierPrefix).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$identifierPrefix",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.uuidV4IriProperty, other.uuidV4IriProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "uuidV4IriProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.uuidV4IriProperty);
    return _hasher;
  }

  $toJson(): UuidV4IriIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
        uuidV4IriProperty: this.uuidV4IriProperty,
      } satisfies UuidV4IriIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      UuidV4IriIdentifierClass.$properties.uuidV4IriProperty["identifier"],
      ...[this.uuidV4IriProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace UuidV4IriIdentifierClass {
  export function $filter(
    filter: UuidV4IriIdentifierClass.$Filter,
    value: UuidV4IriIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.uuidV4IriProperty !== "undefined" &&
      !$filterString(filter.uuidV4IriProperty, value.uuidV4IriProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
    readonly uuidV4IriProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, UuidV4IriIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new UuidV4IriIdentifierClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, UuidV4IriIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return UuidV4IriIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new UuidV4IriIdentifierClass(properties));
  }

  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "UuidV4IriIdentifierClass";
    readonly uuidV4IriProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "UuidV4IriIdentifierClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/uuidV4IriProperty`,
          type: "Control",
        },
      ],
      label: "UuidV4IriIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("UuidV4IriIdentifierClass"),
      uuidV4IriProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    uuidV4IriProperty: {
      identifier: dataFactory.namedNode("http://example.com/uuidV4IriProperty"),
    },
  };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.NamedNode; uuidV4IriProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const uuidV4IriProperty = $jsonObject["uuidV4IriProperty"];
    return purify.Either.of({ $identifier, uuidV4IriProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.NamedNode; uuidV4IriProperty: string }
  > {
    return (
      $parameters.resource.identifier.termType === "NamedNode"
        ? purify.Either.of<Error, UuidV4IriIdentifierClass.$Identifier>(
            $parameters.resource.identifier,
          )
        : purify.Left(
            new rdfjsResource.Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "(rdfjs.NamedNode)",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.uuidV4IriProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              UuidV4IriIdentifierClass.$properties.uuidV4IriProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((uuidV4IriProperty) => ({ $identifier, uuidV4IriProperty })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: UuidV4IriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        UuidV4IriIdentifierClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            UuidV4IriIdentifierClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: UuidV4IriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      UuidV4IriIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("uuidV4IriIdentifierClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "uuidV4IriIdentifierClass")}UuidV4IriProperty`,
      ),
      predicate:
        UuidV4IriIdentifierClass.$properties.uuidV4IriProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: UuidV4IriIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("uuidV4IriIdentifierClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "uuidV4IriIdentifierClass")}UuidV4IriProperty`,
            ),
            predicate:
              UuidV4IriIdentifierClass.$properties.uuidV4IriProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "uuidV4IriIdentifierClass")}UuidV4IriProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.uuidV4IriProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "uuidV4IriIdentifierClass")}UuidV4IriProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isUuidV4IriIdentifierClass(
    object: $Object,
  ): object is UuidV4IriIdentifierClass {
    switch (object.$type) {
      case "UuidV4IriIdentifierClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Shape with sh:xone (union) properties with different discriminant types (envelope, typeof, property) x cardinality.
 */
export class UnionDiscriminantsClass {
  private _$identifier?: UnionDiscriminantsClass.$Identifier;
  readonly $type = "UnionDiscriminantsClass";
  /**
   * Union with an envelope discriminant (multiple+duplicate typeofs, no inline discriminant property).
   */
  readonly optionalClassOrClassOrStringProperty: purify.Maybe<
    | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
    | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
    | { type: "2-string"; value: string }
  >;
  /**
   * Union that can be discriminated by an inline discriminant property (termType).
   */
  readonly optionalIriOrLiteralProperty: purify.Maybe<
    rdfjs.NamedNode | rdfjs.Literal
  >;
  /**
   * Union that can be discriminated by typeof.
   */
  readonly optionalIriOrStringProperty: purify.Maybe<rdfjs.NamedNode | string>;
  /**
   * Union with an envelope discriminant (multiple typeofs, no inline discriminant property).
   */
  readonly requiredClassOrClassOrStringProperty:
    | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
    | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
    | { type: "2-string"; value: string };
  /**
   * Union that can be discriminated by an inline discriminant property (termType).
   */
  readonly requiredIriOrLiteralProperty: rdfjs.NamedNode | rdfjs.Literal;
  /**
   * Union that can be discriminated by typeof.
   */
  readonly requiredIriOrStringProperty: rdfjs.NamedNode | string;
  /**
   * Union with an envelope discriminant (multiple typeofs, no inline discriminant property).
   */
  readonly setClassOrClassOrStringProperty: readonly (
    | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
    | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
    | { type: "2-string"; value: string }
  )[];
  /**
   * Union that can be discriminated by an inline discriminant property (termType).
   */
  readonly setIriOrLiteralProperty: readonly (
    | rdfjs.NamedNode
    | rdfjs.Literal
  )[];
  /**
   * Union that can be discriminated by typeof.
   */
  readonly setIriOrStringProperty: readonly (rdfjs.NamedNode | string)[];

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly optionalClassOrClassOrStringProperty?:
      | (
          | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
          | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
          | { type: "2-string"; value: string }
        )
      | purify.Maybe<
          | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
          | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
          | { type: "2-string"; value: string }
        >;
    readonly optionalIriOrLiteralProperty?:
      | (rdfjs.NamedNode | rdfjs.Literal)
      | purify.Maybe<rdfjs.NamedNode | rdfjs.Literal>;
    readonly optionalIriOrStringProperty?:
      | rdfjs.NamedNode
      | purify.Maybe<rdfjs.NamedNode | string>
      | string;
    readonly requiredClassOrClassOrStringProperty:
      | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
      | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
      | { type: "2-string"; value: string };
    readonly requiredIriOrLiteralProperty: rdfjs.NamedNode | rdfjs.Literal;
    readonly requiredIriOrStringProperty: rdfjs.NamedNode | string;
    readonly setClassOrClassOrStringProperty?: readonly (
      | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
      | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
      | { type: "2-string"; value: string }
    )[];
    readonly setIriOrLiteralProperty?: readonly (
      | rdfjs.NamedNode
      | rdfjs.Literal
    )[];
    readonly setIriOrStringProperty?: readonly (rdfjs.NamedNode | string)[];
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.optionalClassOrClassOrStringProperty)) {
      this.optionalClassOrClassOrStringProperty =
        parameters.optionalClassOrClassOrStringProperty;
    } else if (
      typeof parameters.optionalClassOrClassOrStringProperty === "object"
    ) {
      this.optionalClassOrClassOrStringProperty = purify.Maybe.of(
        parameters.optionalClassOrClassOrStringProperty,
      );
    } else if (
      typeof parameters.optionalClassOrClassOrStringProperty === "undefined"
    ) {
      this.optionalClassOrClassOrStringProperty = purify.Maybe.empty();
    } else {
      this.optionalClassOrClassOrStringProperty =
        parameters.optionalClassOrClassOrStringProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.optionalIriOrLiteralProperty)) {
      this.optionalIriOrLiteralProperty =
        parameters.optionalIriOrLiteralProperty;
    } else if (typeof parameters.optionalIriOrLiteralProperty === "object") {
      this.optionalIriOrLiteralProperty = purify.Maybe.of(
        parameters.optionalIriOrLiteralProperty,
      );
    } else if (typeof parameters.optionalIriOrLiteralProperty === "undefined") {
      this.optionalIriOrLiteralProperty = purify.Maybe.empty();
    } else {
      this.optionalIriOrLiteralProperty =
        parameters.optionalIriOrLiteralProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.optionalIriOrStringProperty)) {
      this.optionalIriOrStringProperty = parameters.optionalIriOrStringProperty;
    } else if (typeof parameters.optionalIriOrStringProperty === "object") {
      this.optionalIriOrStringProperty = purify.Maybe.of(
        parameters.optionalIriOrStringProperty,
      );
    } else if (typeof parameters.optionalIriOrStringProperty === "string") {
      this.optionalIriOrStringProperty = purify.Maybe.of(
        parameters.optionalIriOrStringProperty,
      );
    } else if (typeof parameters.optionalIriOrStringProperty === "undefined") {
      this.optionalIriOrStringProperty = purify.Maybe.empty();
    } else {
      this.optionalIriOrStringProperty =
        parameters.optionalIriOrStringProperty satisfies never;
    }

    this.requiredClassOrClassOrStringProperty =
      parameters.requiredClassOrClassOrStringProperty;
    this.requiredIriOrLiteralProperty = parameters.requiredIriOrLiteralProperty;
    if (typeof parameters.requiredIriOrStringProperty === "object") {
      this.requiredIriOrStringProperty = parameters.requiredIriOrStringProperty;
    } else if (typeof parameters.requiredIriOrStringProperty === "string") {
      this.requiredIriOrStringProperty = parameters.requiredIriOrStringProperty;
    } else {
      this.requiredIriOrStringProperty =
        parameters.requiredIriOrStringProperty satisfies never;
    }

    if (typeof parameters.setClassOrClassOrStringProperty === "undefined") {
      this.setClassOrClassOrStringProperty = [];
    } else if (typeof parameters.setClassOrClassOrStringProperty === "object") {
      this.setClassOrClassOrStringProperty =
        parameters.setClassOrClassOrStringProperty;
    } else {
      this.setClassOrClassOrStringProperty =
        parameters.setClassOrClassOrStringProperty satisfies never;
    }

    if (typeof parameters.setIriOrLiteralProperty === "undefined") {
      this.setIriOrLiteralProperty = [];
    } else if (typeof parameters.setIriOrLiteralProperty === "object") {
      this.setIriOrLiteralProperty = parameters.setIriOrLiteralProperty;
    } else {
      this.setIriOrLiteralProperty =
        parameters.setIriOrLiteralProperty satisfies never;
    }

    if (typeof parameters.setIriOrStringProperty === "undefined") {
      this.setIriOrStringProperty = [];
    } else if (typeof parameters.setIriOrStringProperty === "object") {
      this.setIriOrStringProperty = parameters.setIriOrStringProperty;
    } else {
      this.setIriOrStringProperty =
        parameters.setIriOrStringProperty satisfies never;
    }
  }

  get $identifier(): UnionDiscriminantsClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: UnionDiscriminantsClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (
              left:
                | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
                | { type: "2-string"; value: string },
              right:
                | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
                | { type: "2-string"; value: string },
            ) => {
              if (
                left.type === "0-ClassUnionMember1" &&
                right.type === "0-ClassUnionMember1"
              ) {
                return ((left, right) => left.$equals(right))(
                  left.value,
                  right.value,
                );
              }
              if (
                left.type === "1-ClassUnionMember2" &&
                right.type === "1-ClassUnionMember2"
              ) {
                return ((left, right) => left.$equals(right))(
                  left.value,
                  right.value,
                );
              }
              if (left.type === "2-string" && right.type === "2-string") {
                return $strictEquals(left.value, right.value);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(
          this.optionalClassOrClassOrStringProperty,
          other.optionalClassOrClassOrStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalClassOrClassOrStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (
              left: rdfjs.NamedNode | rdfjs.Literal,
              right: rdfjs.NamedNode | rdfjs.Literal,
            ) => {
              if (
                left.termType === "NamedNode" &&
                right.termType === "NamedNode"
              ) {
                return $booleanEquals(left, right);
              }
              if (left.termType === "Literal" && right.termType === "Literal") {
                return $booleanEquals(left, right);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(
          this.optionalIriOrLiteralProperty,
          other.optionalIriOrLiteralProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalIriOrLiteralProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (
              left: rdfjs.NamedNode | string,
              right: rdfjs.NamedNode | string,
            ) => {
              if (typeof left === "object" && typeof right === "object") {
                return $booleanEquals(left, right);
              }
              if (typeof left === "string" && typeof right === "string") {
                return $strictEquals(left, right);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(
          this.optionalIriOrStringProperty,
          other.optionalIriOrStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalIriOrStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((
          left:
            | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
            | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
            | { type: "2-string"; value: string },
          right:
            | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
            | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
            | { type: "2-string"; value: string },
        ) => {
          if (
            left.type === "0-ClassUnionMember1" &&
            right.type === "0-ClassUnionMember1"
          ) {
            return ((left, right) => left.$equals(right))(
              left.value,
              right.value,
            );
          }
          if (
            left.type === "1-ClassUnionMember2" &&
            right.type === "1-ClassUnionMember2"
          ) {
            return ((left, right) => left.$equals(right))(
              left.value,
              right.value,
            );
          }
          if (left.type === "2-string" && right.type === "2-string") {
            return $strictEquals(left.value, right.value);
          }

          return purify.Left({
            left,
            right,
            propertyName: "type",
            propertyValuesUnequal: {
              left: typeof left,
              right: typeof right,
              type: "BooleanEquals" as const,
            },
            type: "Property" as const,
          });
        })(
          this.requiredClassOrClassOrStringProperty,
          other.requiredClassOrClassOrStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "requiredClassOrClassOrStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((
          left: rdfjs.NamedNode | rdfjs.Literal,
          right: rdfjs.NamedNode | rdfjs.Literal,
        ) => {
          if (left.termType === "NamedNode" && right.termType === "NamedNode") {
            return $booleanEquals(left, right);
          }
          if (left.termType === "Literal" && right.termType === "Literal") {
            return $booleanEquals(left, right);
          }

          return purify.Left({
            left,
            right,
            propertyName: "type",
            propertyValuesUnequal: {
              left: typeof left,
              right: typeof right,
              type: "BooleanEquals" as const,
            },
            type: "Property" as const,
          });
        })(
          this.requiredIriOrLiteralProperty,
          other.requiredIriOrLiteralProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "requiredIriOrLiteralProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left: rdfjs.NamedNode | string, right: rdfjs.NamedNode | string) => {
          if (typeof left === "object" && typeof right === "object") {
            return $booleanEquals(left, right);
          }
          if (typeof left === "string" && typeof right === "string") {
            return $strictEquals(left, right);
          }

          return purify.Left({
            left,
            right,
            propertyName: "type",
            propertyValuesUnequal: {
              left: typeof left,
              right: typeof right,
              type: "BooleanEquals" as const,
            },
            type: "Property" as const,
          });
        })(
          this.requiredIriOrStringProperty,
          other.requiredIriOrStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "requiredIriOrStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(
            left,
            right,
            (
              left:
                | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
                | { type: "2-string"; value: string },
              right:
                | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
                | { type: "2-string"; value: string },
            ) => {
              if (
                left.type === "0-ClassUnionMember1" &&
                right.type === "0-ClassUnionMember1"
              ) {
                return ((left, right) => left.$equals(right))(
                  left.value,
                  right.value,
                );
              }
              if (
                left.type === "1-ClassUnionMember2" &&
                right.type === "1-ClassUnionMember2"
              ) {
                return ((left, right) => left.$equals(right))(
                  left.value,
                  right.value,
                );
              }
              if (left.type === "2-string" && right.type === "2-string") {
                return $strictEquals(left.value, right.value);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(
          this.setClassOrClassOrStringProperty,
          other.setClassOrClassOrStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "setClassOrClassOrStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(
            left,
            right,
            (
              left: rdfjs.NamedNode | rdfjs.Literal,
              right: rdfjs.NamedNode | rdfjs.Literal,
            ) => {
              if (
                left.termType === "NamedNode" &&
                right.termType === "NamedNode"
              ) {
                return $booleanEquals(left, right);
              }
              if (left.termType === "Literal" && right.termType === "Literal") {
                return $booleanEquals(left, right);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(
          this.setIriOrLiteralProperty,
          other.setIriOrLiteralProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "setIriOrLiteralProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(
            left,
            right,
            (
              left: rdfjs.NamedNode | string,
              right: rdfjs.NamedNode | string,
            ) => {
              if (typeof left === "object" && typeof right === "object") {
                return $booleanEquals(left, right);
              }
              if (typeof left === "string" && typeof right === "string") {
                return $strictEquals(left, right);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(this.setIriOrStringProperty, other.setIriOrStringProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "setIriOrStringProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.optionalClassOrClassOrStringProperty.ifJust((value0) => {
      switch (value0.type) {
        case "0-ClassUnionMember1": {
          value0.value.$hash(_hasher);
          break;
        }
        case "1-ClassUnionMember2": {
          value0.value.$hash(_hasher);
          break;
        }
        case "2-string": {
          _hasher.update(value0.value);
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    this.optionalIriOrLiteralProperty.ifJust((value0) => {
      switch (value0.termType) {
        case "NamedNode": {
          _hasher.update(value0.termType);
          _hasher.update(value0.value);
          break;
        }
        case "Literal": {
          _hasher.update(value0.datatype.value);
          _hasher.update(value0.language);
          _hasher.update(value0.termType);
          _hasher.update(value0.value);
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    this.optionalIriOrStringProperty.ifJust((value0) => {
      switch (typeof value0) {
        case "object": {
          _hasher.update(value0.termType);
          _hasher.update(value0.value);
          break;
        }
        case "string": {
          _hasher.update(value0);
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    switch (this.requiredClassOrClassOrStringProperty.type) {
      case "0-ClassUnionMember1": {
        this.requiredClassOrClassOrStringProperty.value.$hash(_hasher);
        break;
      }
      case "1-ClassUnionMember2": {
        this.requiredClassOrClassOrStringProperty.value.$hash(_hasher);
        break;
      }
      case "2-string": {
        _hasher.update(this.requiredClassOrClassOrStringProperty.value);
        break;
      }
      default:
        this.requiredClassOrClassOrStringProperty satisfies never;
        throw new Error("unrecognized type");
    }

    switch (this.requiredIriOrLiteralProperty.termType) {
      case "NamedNode": {
        _hasher.update(this.requiredIriOrLiteralProperty.termType);
        _hasher.update(this.requiredIriOrLiteralProperty.value);
        break;
      }
      case "Literal": {
        _hasher.update(this.requiredIriOrLiteralProperty.datatype.value);
        _hasher.update(this.requiredIriOrLiteralProperty.language);
        _hasher.update(this.requiredIriOrLiteralProperty.termType);
        _hasher.update(this.requiredIriOrLiteralProperty.value);
        break;
      }
      default:
        this.requiredIriOrLiteralProperty satisfies never;
        throw new Error("unrecognized type");
    }

    switch (typeof this.requiredIriOrStringProperty) {
      case "object": {
        _hasher.update(this.requiredIriOrStringProperty.termType);
        _hasher.update(this.requiredIriOrStringProperty.value);
        break;
      }
      case "string": {
        _hasher.update(this.requiredIriOrStringProperty);
        break;
      }
      default:
        this.requiredIriOrStringProperty satisfies never;
        throw new Error("unrecognized type");
    }

    for (const item0 of this.setClassOrClassOrStringProperty) {
      switch (item0.type) {
        case "0-ClassUnionMember1": {
          item0.value.$hash(_hasher);
          break;
        }
        case "1-ClassUnionMember2": {
          item0.value.$hash(_hasher);
          break;
        }
        case "2-string": {
          _hasher.update(item0.value);
          break;
        }
        default:
          item0 satisfies never;
          throw new Error("unrecognized type");
      }
    }

    for (const item0 of this.setIriOrLiteralProperty) {
      switch (item0.termType) {
        case "NamedNode": {
          _hasher.update(item0.termType);
          _hasher.update(item0.value);
          break;
        }
        case "Literal": {
          _hasher.update(item0.datatype.value);
          _hasher.update(item0.language);
          _hasher.update(item0.termType);
          _hasher.update(item0.value);
          break;
        }
        default:
          item0 satisfies never;
          throw new Error("unrecognized type");
      }
    }

    for (const item0 of this.setIriOrStringProperty) {
      switch (typeof item0) {
        case "object": {
          _hasher.update(item0.termType);
          _hasher.update(item0.value);
          break;
        }
        case "string": {
          _hasher.update(item0);
          break;
        }
        default:
          item0 satisfies never;
          throw new Error("unrecognized type");
      }
    }

    return _hasher;
  }

  $toJson(): UnionDiscriminantsClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        optionalClassOrClassOrStringProperty:
          this.optionalClassOrClassOrStringProperty
            .map((item) =>
              item.type === "2-string"
                ? { type: "2-string" as const, value: item.value }
                : item.type === "1-ClassUnionMember2"
                  ? {
                      type: "1-ClassUnionMember2" as const,
                      value: item.value.$toJson(),
                    }
                  : {
                      type: "0-ClassUnionMember1" as const,
                      value: item.value.$toJson(),
                    },
            )
            .extract(),
        optionalIriOrLiteralProperty: this.optionalIriOrLiteralProperty
          .map((item) =>
            item.termType === "Literal"
              ? {
                  "@language":
                    item.language.length > 0 ? item.language : undefined,
                  termType: "Literal" as const,
                  "@type":
                    item.datatype.value !==
                    "http://www.w3.org/2001/XMLSchema#string"
                      ? item.datatype.value
                      : undefined,
                  "@value": item.value,
                }
              : { "@id": item.value, termType: item.termType as "NamedNode" },
          )
          .extract(),
        optionalIriOrStringProperty: this.optionalIriOrStringProperty
          .map((item) =>
            typeof item === "string" ? item : { "@id": item.value },
          )
          .extract(),
        requiredClassOrClassOrStringProperty:
          this.requiredClassOrClassOrStringProperty.type === "2-string"
            ? {
                type: "2-string" as const,
                value: this.requiredClassOrClassOrStringProperty.value,
              }
            : this.requiredClassOrClassOrStringProperty.type ===
                "1-ClassUnionMember2"
              ? {
                  type: "1-ClassUnionMember2" as const,
                  value:
                    this.requiredClassOrClassOrStringProperty.value.$toJson(),
                }
              : {
                  type: "0-ClassUnionMember1" as const,
                  value:
                    this.requiredClassOrClassOrStringProperty.value.$toJson(),
                },
        requiredIriOrLiteralProperty:
          this.requiredIriOrLiteralProperty.termType === "Literal"
            ? {
                "@language":
                  this.requiredIriOrLiteralProperty.language.length > 0
                    ? this.requiredIriOrLiteralProperty.language
                    : undefined,
                termType: "Literal" as const,
                "@type":
                  this.requiredIriOrLiteralProperty.datatype.value !==
                  "http://www.w3.org/2001/XMLSchema#string"
                    ? this.requiredIriOrLiteralProperty.datatype.value
                    : undefined,
                "@value": this.requiredIriOrLiteralProperty.value,
              }
            : {
                "@id": this.requiredIriOrLiteralProperty.value,
                termType: this.requiredIriOrLiteralProperty
                  .termType as "NamedNode",
              },
        requiredIriOrStringProperty:
          typeof this.requiredIriOrStringProperty === "string"
            ? this.requiredIriOrStringProperty
            : { "@id": this.requiredIriOrStringProperty.value },
        setClassOrClassOrStringProperty:
          this.setClassOrClassOrStringProperty.map((item) =>
            item.type === "2-string"
              ? { type: "2-string" as const, value: item.value }
              : item.type === "1-ClassUnionMember2"
                ? {
                    type: "1-ClassUnionMember2" as const,
                    value: item.value.$toJson(),
                  }
                : {
                    type: "0-ClassUnionMember1" as const,
                    value: item.value.$toJson(),
                  },
          ),
        setIriOrLiteralProperty: this.setIriOrLiteralProperty.map((item) =>
          item.termType === "Literal"
            ? {
                "@language":
                  item.language.length > 0 ? item.language : undefined,
                termType: "Literal" as const,
                "@type":
                  item.datatype.value !==
                  "http://www.w3.org/2001/XMLSchema#string"
                    ? item.datatype.value
                    : undefined,
                "@value": item.value,
              }
            : { "@id": item.value, termType: item.termType as "NamedNode" },
        ),
        setIriOrStringProperty: this.setIriOrStringProperty.map((item) =>
          typeof item === "string" ? item : { "@id": item.value },
        ),
      } satisfies UnionDiscriminantsClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      UnionDiscriminantsClass.$properties.optionalClassOrClassOrStringProperty[
        "identifier"
      ],
      ...this.optionalClassOrClassOrStringProperty.toList().flatMap((value) =>
        value.type === "2-string"
          ? ([value.value] as readonly Parameters<
              rdfjsResource.MutableResource["add"]
            >[1][])
          : ([
              value.value.$toRdf({
                mutateGraph: mutateGraph,
                resourceSet: resourceSet,
              }).identifier,
            ] as readonly Parameters<
              rdfjsResource.MutableResource["add"]
            >[1][]),
      ),
    );
    resource.add(
      UnionDiscriminantsClass.$properties.optionalIriOrLiteralProperty[
        "identifier"
      ],
      ...this.optionalIriOrLiteralProperty
        .toList()
        .flatMap(
          (value) =>
            [value] as readonly Parameters<
              rdfjsResource.MutableResource["add"]
            >[1][],
        ),
    );
    resource.add(
      UnionDiscriminantsClass.$properties.optionalIriOrStringProperty[
        "identifier"
      ],
      ...this.optionalIriOrStringProperty
        .toList()
        .flatMap(
          (value) =>
            [value] as readonly Parameters<
              rdfjsResource.MutableResource["add"]
            >[1][],
        ),
    );
    resource.add(
      UnionDiscriminantsClass.$properties.requiredClassOrClassOrStringProperty[
        "identifier"
      ],
      ...(this.requiredClassOrClassOrStringProperty.type === "2-string"
        ? ([
            this.requiredClassOrClassOrStringProperty.value,
          ] as readonly Parameters<rdfjsResource.MutableResource["add"]>[1][])
        : ([
            this.requiredClassOrClassOrStringProperty.value.$toRdf({
              mutateGraph: mutateGraph,
              resourceSet: resourceSet,
            }).identifier,
          ] as readonly Parameters<rdfjsResource.MutableResource["add"]>[1][])),
    );
    resource.add(
      UnionDiscriminantsClass.$properties.requiredIriOrLiteralProperty[
        "identifier"
      ],
      ...([this.requiredIriOrLiteralProperty] as readonly Parameters<
        rdfjsResource.MutableResource["add"]
      >[1][]),
    );
    resource.add(
      UnionDiscriminantsClass.$properties.requiredIriOrStringProperty[
        "identifier"
      ],
      ...([this.requiredIriOrStringProperty] as readonly Parameters<
        rdfjsResource.MutableResource["add"]
      >[1][]),
    );
    resource.add(
      UnionDiscriminantsClass.$properties.setClassOrClassOrStringProperty[
        "identifier"
      ],
      ...this.setClassOrClassOrStringProperty.flatMap((item) =>
        item.type === "2-string"
          ? ([item.value] as readonly Parameters<
              rdfjsResource.MutableResource["add"]
            >[1][])
          : ([
              item.value.$toRdf({
                mutateGraph: mutateGraph,
                resourceSet: resourceSet,
              }).identifier,
            ] as readonly Parameters<
              rdfjsResource.MutableResource["add"]
            >[1][]),
      ),
    );
    resource.add(
      UnionDiscriminantsClass.$properties.setIriOrLiteralProperty["identifier"],
      ...this.setIriOrLiteralProperty.flatMap(
        (item) =>
          [item] as readonly Parameters<
            rdfjsResource.MutableResource["add"]
          >[1][],
      ),
    );
    resource.add(
      UnionDiscriminantsClass.$properties.setIriOrStringProperty["identifier"],
      ...this.setIriOrStringProperty.flatMap(
        (item) =>
          [item] as readonly Parameters<
            rdfjsResource.MutableResource["add"]
          >[1][],
      ),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace UnionDiscriminantsClass {
  export function $filter(
    filter: UnionDiscriminantsClass.$Filter,
    value: UnionDiscriminantsClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.optionalClassOrClassOrStringProperty !== "undefined" &&
      !$filterMaybe<
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
        | { type: "2-string"; value: string },
        {
          readonly on?: {
            readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
            readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
            readonly "2-string"?: $StringFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
              readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
              readonly "2-string"?: $StringFilter;
            };
          },
          value:
            | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
            | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
            | { type: "2-string"; value: string },
        ) => {
          if (typeof filter.on?.["0-ClassUnionMember1"] !== "undefined") {
            switch (value.type) {
              case "0-ClassUnionMember1":
                if (
                  !ClassUnionMember1.$filter(
                    filter.on["0-ClassUnionMember1"],
                    value.value,
                  )
                ) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["1-ClassUnionMember2"] !== "undefined") {
            switch (value.type) {
              case "1-ClassUnionMember2":
                if (
                  !ClassUnionMember2.$filter(
                    filter.on["1-ClassUnionMember2"],
                    value.value,
                  )
                ) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["2-string"] !== "undefined") {
            switch (value.type) {
              case "2-string":
                if (!$filterString(filter.on["2-string"], value.value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(
        filter.optionalClassOrClassOrStringProperty,
        value.optionalClassOrClassOrStringProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalIriOrLiteralProperty !== "undefined" &&
      !$filterMaybe<
        rdfjs.NamedNode | rdfjs.Literal,
        {
          readonly on?: {
            readonly NamedNode?: $NamedNodeFilter;
            readonly Literal?: $LiteralFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly NamedNode?: $NamedNodeFilter;
              readonly Literal?: $LiteralFilter;
            };
          },
          value: rdfjs.NamedNode | rdfjs.Literal,
        ) => {
          if (typeof filter.on?.["NamedNode"] !== "undefined") {
            switch (value.termType) {
              case "NamedNode":
                if (!$filterNamedNode(filter.on["NamedNode"], value)) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["Literal"] !== "undefined") {
            switch (value.termType) {
              case "Literal":
                if (!$filterLiteral(filter.on["Literal"], value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.optionalIriOrLiteralProperty, value.optionalIriOrLiteralProperty)
    ) {
      return false;
    }

    if (
      typeof filter.optionalIriOrStringProperty !== "undefined" &&
      !$filterMaybe<
        rdfjs.NamedNode | string,
        {
          readonly on?: {
            readonly object?: $NamedNodeFilter;
            readonly string?: $StringFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly object?: $NamedNodeFilter;
              readonly string?: $StringFilter;
            };
          },
          value: rdfjs.NamedNode | string,
        ) => {
          if (typeof filter.on?.["object"] !== "undefined") {
            switch (typeof value) {
              case "object":
                if (!$filterNamedNode(filter.on["object"], value)) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["string"] !== "undefined") {
            switch (typeof value) {
              case "string":
                if (!$filterString(filter.on["string"], value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.optionalIriOrStringProperty, value.optionalIriOrStringProperty)
    ) {
      return false;
    }

    if (
      typeof filter.requiredClassOrClassOrStringProperty !== "undefined" &&
      !((
        filter: {
          readonly on?: {
            readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
            readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
            readonly "2-string"?: $StringFilter;
          };
        },
        value:
          | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
          | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
          | { type: "2-string"; value: string },
      ) => {
        if (typeof filter.on?.["0-ClassUnionMember1"] !== "undefined") {
          switch (value.type) {
            case "0-ClassUnionMember1":
              if (
                !ClassUnionMember1.$filter(
                  filter.on["0-ClassUnionMember1"],
                  value.value,
                )
              ) {
                return false;
              }
              break;
          }
        }

        if (typeof filter.on?.["1-ClassUnionMember2"] !== "undefined") {
          switch (value.type) {
            case "1-ClassUnionMember2":
              if (
                !ClassUnionMember2.$filter(
                  filter.on["1-ClassUnionMember2"],
                  value.value,
                )
              ) {
                return false;
              }
              break;
          }
        }

        if (typeof filter.on?.["2-string"] !== "undefined") {
          switch (value.type) {
            case "2-string":
              if (!$filterString(filter.on["2-string"], value.value)) {
                return false;
              }
              break;
          }
        }

        return true;
      })(
        filter.requiredClassOrClassOrStringProperty,
        value.requiredClassOrClassOrStringProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.requiredIriOrLiteralProperty !== "undefined" &&
      !((
        filter: {
          readonly on?: {
            readonly NamedNode?: $NamedNodeFilter;
            readonly Literal?: $LiteralFilter;
          };
        },
        value: rdfjs.NamedNode | rdfjs.Literal,
      ) => {
        if (typeof filter.on?.["NamedNode"] !== "undefined") {
          switch (value.termType) {
            case "NamedNode":
              if (!$filterNamedNode(filter.on["NamedNode"], value)) {
                return false;
              }
              break;
          }
        }

        if (typeof filter.on?.["Literal"] !== "undefined") {
          switch (value.termType) {
            case "Literal":
              if (!$filterLiteral(filter.on["Literal"], value)) {
                return false;
              }
              break;
          }
        }

        return true;
      })(
        filter.requiredIriOrLiteralProperty,
        value.requiredIriOrLiteralProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.requiredIriOrStringProperty !== "undefined" &&
      !((
        filter: {
          readonly on?: {
            readonly object?: $NamedNodeFilter;
            readonly string?: $StringFilter;
          };
        },
        value: rdfjs.NamedNode | string,
      ) => {
        if (typeof filter.on?.["object"] !== "undefined") {
          switch (typeof value) {
            case "object":
              if (!$filterNamedNode(filter.on["object"], value)) {
                return false;
              }
              break;
          }
        }

        if (typeof filter.on?.["string"] !== "undefined") {
          switch (typeof value) {
            case "string":
              if (!$filterString(filter.on["string"], value)) {
                return false;
              }
              break;
          }
        }

        return true;
      })(filter.requiredIriOrStringProperty, value.requiredIriOrStringProperty)
    ) {
      return false;
    }

    if (
      typeof filter.setClassOrClassOrStringProperty !== "undefined" &&
      !$filterArray<
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
        | { type: "2-string"; value: string },
        {
          readonly on?: {
            readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
            readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
            readonly "2-string"?: $StringFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
              readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
              readonly "2-string"?: $StringFilter;
            };
          },
          value:
            | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
            | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
            | { type: "2-string"; value: string },
        ) => {
          if (typeof filter.on?.["0-ClassUnionMember1"] !== "undefined") {
            switch (value.type) {
              case "0-ClassUnionMember1":
                if (
                  !ClassUnionMember1.$filter(
                    filter.on["0-ClassUnionMember1"],
                    value.value,
                  )
                ) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["1-ClassUnionMember2"] !== "undefined") {
            switch (value.type) {
              case "1-ClassUnionMember2":
                if (
                  !ClassUnionMember2.$filter(
                    filter.on["1-ClassUnionMember2"],
                    value.value,
                  )
                ) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["2-string"] !== "undefined") {
            switch (value.type) {
              case "2-string":
                if (!$filterString(filter.on["2-string"], value.value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(
        filter.setClassOrClassOrStringProperty,
        value.setClassOrClassOrStringProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.setIriOrLiteralProperty !== "undefined" &&
      !$filterArray<
        rdfjs.NamedNode | rdfjs.Literal,
        {
          readonly on?: {
            readonly NamedNode?: $NamedNodeFilter;
            readonly Literal?: $LiteralFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly NamedNode?: $NamedNodeFilter;
              readonly Literal?: $LiteralFilter;
            };
          },
          value: rdfjs.NamedNode | rdfjs.Literal,
        ) => {
          if (typeof filter.on?.["NamedNode"] !== "undefined") {
            switch (value.termType) {
              case "NamedNode":
                if (!$filterNamedNode(filter.on["NamedNode"], value)) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["Literal"] !== "undefined") {
            switch (value.termType) {
              case "Literal":
                if (!$filterLiteral(filter.on["Literal"], value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.setIriOrLiteralProperty, value.setIriOrLiteralProperty)
    ) {
      return false;
    }

    if (
      typeof filter.setIriOrStringProperty !== "undefined" &&
      !$filterArray<
        rdfjs.NamedNode | string,
        {
          readonly on?: {
            readonly object?: $NamedNodeFilter;
            readonly string?: $StringFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly object?: $NamedNodeFilter;
              readonly string?: $StringFilter;
            };
          },
          value: rdfjs.NamedNode | string,
        ) => {
          if (typeof filter.on?.["object"] !== "undefined") {
            switch (typeof value) {
              case "object":
                if (!$filterNamedNode(filter.on["object"], value)) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["string"] !== "undefined") {
            switch (typeof value) {
              case "string":
                if (!$filterString(filter.on["string"], value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.setIriOrStringProperty, value.setIriOrStringProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly optionalClassOrClassOrStringProperty?: $MaybeFilter<{
      readonly on?: {
        readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
        readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
        readonly "2-string"?: $StringFilter;
      };
    }>;
    readonly optionalIriOrLiteralProperty?: $MaybeFilter<{
      readonly on?: {
        readonly NamedNode?: $NamedNodeFilter;
        readonly Literal?: $LiteralFilter;
      };
    }>;
    readonly optionalIriOrStringProperty?: $MaybeFilter<{
      readonly on?: {
        readonly object?: $NamedNodeFilter;
        readonly string?: $StringFilter;
      };
    }>;
    readonly requiredClassOrClassOrStringProperty?: {
      readonly on?: {
        readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
        readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
        readonly "2-string"?: $StringFilter;
      };
    };
    readonly requiredIriOrLiteralProperty?: {
      readonly on?: {
        readonly NamedNode?: $NamedNodeFilter;
        readonly Literal?: $LiteralFilter;
      };
    };
    readonly requiredIriOrStringProperty?: {
      readonly on?: {
        readonly object?: $NamedNodeFilter;
        readonly string?: $StringFilter;
      };
    };
    readonly setClassOrClassOrStringProperty?: $CollectionFilter<{
      readonly on?: {
        readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
        readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
        readonly "2-string"?: $StringFilter;
      };
    }>;
    readonly setIriOrLiteralProperty?: $CollectionFilter<{
      readonly on?: {
        readonly NamedNode?: $NamedNodeFilter;
        readonly Literal?: $LiteralFilter;
      };
    }>;
    readonly setIriOrStringProperty?: $CollectionFilter<{
      readonly on?: {
        readonly object?: $NamedNodeFilter;
        readonly string?: $StringFilter;
      };
    }>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, UnionDiscriminantsClass> {
    return $propertiesFromJson(json).map(
      (properties) => new UnionDiscriminantsClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, UnionDiscriminantsClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return UnionDiscriminantsClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new UnionDiscriminantsClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "UnionDiscriminantsClass";
    readonly optionalClassOrClassOrStringProperty?:
      | { type: "0-ClassUnionMember1"; value: ClassUnionMember1.$Json }
      | { type: "1-ClassUnionMember2"; value: ClassUnionMember2.$Json }
      | { type: "2-string"; value: string };
    readonly optionalIriOrLiteralProperty?:
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly termType: "Literal";
          readonly "@type"?: string;
          readonly "@value": string;
        };
    readonly optionalIriOrStringProperty?: { readonly "@id": string } | string;
    readonly requiredClassOrClassOrStringProperty:
      | { type: "0-ClassUnionMember1"; value: ClassUnionMember1.$Json }
      | { type: "1-ClassUnionMember2"; value: ClassUnionMember2.$Json }
      | { type: "2-string"; value: string };
    readonly requiredIriOrLiteralProperty:
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly termType: "Literal";
          readonly "@type"?: string;
          readonly "@value": string;
        };
    readonly requiredIriOrStringProperty: { readonly "@id": string } | string;
    readonly setClassOrClassOrStringProperty?: readonly (
      | { type: "0-ClassUnionMember1"; value: ClassUnionMember1.$Json }
      | { type: "1-ClassUnionMember2"; value: ClassUnionMember2.$Json }
      | { type: "2-string"; value: string }
    )[];
    readonly setIriOrLiteralProperty?: readonly (
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly termType: "Literal";
          readonly "@type"?: string;
          readonly "@value": string;
        }
    )[];
    readonly setIriOrStringProperty?: readonly (
      | { readonly "@id": string }
      | string
    )[];
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "UnionDiscriminantsClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/optionalClassOrClassOrStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/optionalIriOrLiteralProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/optionalIriOrStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/requiredClassOrClassOrStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/requiredIriOrLiteralProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/requiredIriOrStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/setClassOrClassOrStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/setIriOrLiteralProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/setIriOrStringProperty`,
          type: "Control",
        },
      ],
      label: "UnionDiscriminantsClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("UnionDiscriminantsClass"),
      optionalClassOrClassOrStringProperty: zod
        .discriminatedUnion("type", [
          zod.object({
            type: zod.literal("0-ClassUnionMember1"),
            value: ClassUnionMember1.$jsonZodSchema(),
          }),
          zod.object({
            type: zod.literal("1-ClassUnionMember2"),
            value: ClassUnionMember2.$jsonZodSchema(),
          }),
          zod.object({ type: zod.literal("2-string"), value: zod.string() }),
        ])
        .optional()
        .describe(
          "Union with an envelope discriminant (multiple+duplicate typeofs, no inline discriminant property).",
        ),
      optionalIriOrLiteralProperty: zod
        .discriminatedUnion("termType", [
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("NamedNode"),
          }),
          zod.object({
            "@language": zod.string().optional(),
            termType: zod.literal("Literal"),
            "@type": zod.string().optional(),
            "@value": zod.string(),
          }),
        ])
        .optional()
        .describe(
          "Union that can be discriminated by an inline discriminant property (termType).",
        ),
      optionalIriOrStringProperty: zod
        .union([zod.object({ "@id": zod.string().min(1) }), zod.string()])
        .optional()
        .describe("Union that can be discriminated by typeof."),
      requiredClassOrClassOrStringProperty: zod
        .discriminatedUnion("type", [
          zod.object({
            type: zod.literal("0-ClassUnionMember1"),
            value: ClassUnionMember1.$jsonZodSchema(),
          }),
          zod.object({
            type: zod.literal("1-ClassUnionMember2"),
            value: ClassUnionMember2.$jsonZodSchema(),
          }),
          zod.object({ type: zod.literal("2-string"), value: zod.string() }),
        ])
        .describe(
          "Union with an envelope discriminant (multiple typeofs, no inline discriminant property).",
        ),
      requiredIriOrLiteralProperty: zod
        .discriminatedUnion("termType", [
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("NamedNode"),
          }),
          zod.object({
            "@language": zod.string().optional(),
            termType: zod.literal("Literal"),
            "@type": zod.string().optional(),
            "@value": zod.string(),
          }),
        ])
        .describe(
          "Union that can be discriminated by an inline discriminant property (termType).",
        ),
      requiredIriOrStringProperty: zod
        .union([zod.object({ "@id": zod.string().min(1) }), zod.string()])
        .describe("Union that can be discriminated by typeof."),
      setClassOrClassOrStringProperty: zod
        .discriminatedUnion("type", [
          zod.object({
            type: zod.literal("0-ClassUnionMember1"),
            value: ClassUnionMember1.$jsonZodSchema(),
          }),
          zod.object({
            type: zod.literal("1-ClassUnionMember2"),
            value: ClassUnionMember2.$jsonZodSchema(),
          }),
          zod.object({ type: zod.literal("2-string"), value: zod.string() }),
        ])
        .array()
        .default(() => [])
        .describe(
          "Union with an envelope discriminant (multiple typeofs, no inline discriminant property).",
        ),
      setIriOrLiteralProperty: zod
        .discriminatedUnion("termType", [
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("NamedNode"),
          }),
          zod.object({
            "@language": zod.string().optional(),
            termType: zod.literal("Literal"),
            "@type": zod.string().optional(),
            "@value": zod.string(),
          }),
        ])
        .array()
        .default(() => [])
        .describe(
          "Union that can be discriminated by an inline discriminant property (termType).",
        ),
      setIriOrStringProperty: zod
        .union([zod.object({ "@id": zod.string().min(1) }), zod.string()])
        .array()
        .default(() => [])
        .describe("Union that can be discriminated by typeof."),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    optionalClassOrClassOrStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalClassOrClassOrStringProperty",
      ),
    },
    optionalIriOrLiteralProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalIriOrLiteralProperty",
      ),
    },
    optionalIriOrStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalIriOrStringProperty",
      ),
    },
    requiredClassOrClassOrStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/requiredClassOrClassOrStringProperty",
      ),
    },
    requiredIriOrLiteralProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/requiredIriOrLiteralProperty",
      ),
    },
    requiredIriOrStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/requiredIriOrStringProperty",
      ),
    },
    setClassOrClassOrStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/setClassOrClassOrStringProperty",
      ),
    },
    setIriOrLiteralProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/setIriOrLiteralProperty",
      ),
    },
    setIriOrStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/setIriOrStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      optionalClassOrClassOrStringProperty: purify.Maybe<
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
        | { type: "2-string"; value: string }
      >;
      optionalIriOrLiteralProperty: purify.Maybe<
        rdfjs.NamedNode | rdfjs.Literal
      >;
      optionalIriOrStringProperty: purify.Maybe<rdfjs.NamedNode | string>;
      requiredClassOrClassOrStringProperty:
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
        | { type: "2-string"; value: string };
      requiredIriOrLiteralProperty: rdfjs.NamedNode | rdfjs.Literal;
      requiredIriOrStringProperty: rdfjs.NamedNode | string;
      setClassOrClassOrStringProperty: readonly (
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
        | { type: "2-string"; value: string }
      )[];
      setIriOrLiteralProperty: readonly (rdfjs.NamedNode | rdfjs.Literal)[];
      setIriOrStringProperty: readonly (rdfjs.NamedNode | string)[];
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const optionalClassOrClassOrStringProperty = purify.Maybe.fromNullable(
      $jsonObject["optionalClassOrClassOrStringProperty"],
    ).map((item) =>
      item.type === "2-string"
        ? { type: "2-string" as const, value: item.value }
        : item.type === "1-ClassUnionMember2"
          ? {
              type: "1-ClassUnionMember2" as const,
              value: ClassUnionMember2.$fromJson(item.value).unsafeCoerce(),
            }
          : {
              type: "0-ClassUnionMember1" as const,
              value: ClassUnionMember1.$fromJson(item.value).unsafeCoerce(),
            },
    );
    const optionalIriOrLiteralProperty = purify.Maybe.fromNullable(
      $jsonObject["optionalIriOrLiteralProperty"],
    ).map((item) =>
      item.termType === "Literal"
        ? dataFactory.literal(
            item["@value"],
            typeof item["@language"] !== "undefined"
              ? item["@language"]
              : typeof item["@type"] !== "undefined"
                ? dataFactory.namedNode(item["@type"])
                : undefined,
          )
        : dataFactory.namedNode(item["@id"]),
    );
    const optionalIriOrStringProperty = purify.Maybe.fromNullable(
      $jsonObject["optionalIriOrStringProperty"],
    ).map((item) =>
      typeof item === "string" ? item : dataFactory.namedNode(item["@id"]),
    );
    const requiredClassOrClassOrStringProperty =
      $jsonObject["requiredClassOrClassOrStringProperty"].type === "2-string"
        ? {
            type: "2-string" as const,
            value: $jsonObject["requiredClassOrClassOrStringProperty"].value,
          }
        : $jsonObject["requiredClassOrClassOrStringProperty"].type ===
            "1-ClassUnionMember2"
          ? {
              type: "1-ClassUnionMember2" as const,
              value: ClassUnionMember2.$fromJson(
                $jsonObject["requiredClassOrClassOrStringProperty"].value,
              ).unsafeCoerce(),
            }
          : {
              type: "0-ClassUnionMember1" as const,
              value: ClassUnionMember1.$fromJson(
                $jsonObject["requiredClassOrClassOrStringProperty"].value,
              ).unsafeCoerce(),
            };
    const requiredIriOrLiteralProperty =
      $jsonObject["requiredIriOrLiteralProperty"].termType === "Literal"
        ? dataFactory.literal(
            $jsonObject["requiredIriOrLiteralProperty"]["@value"],
            typeof $jsonObject["requiredIriOrLiteralProperty"]["@language"] !==
              "undefined"
              ? $jsonObject["requiredIriOrLiteralProperty"]["@language"]
              : typeof $jsonObject["requiredIriOrLiteralProperty"]["@type"] !==
                  "undefined"
                ? dataFactory.namedNode(
                    $jsonObject["requiredIriOrLiteralProperty"]["@type"],
                  )
                : undefined,
          )
        : dataFactory.namedNode(
            $jsonObject["requiredIriOrLiteralProperty"]["@id"],
          );
    const requiredIriOrStringProperty =
      typeof $jsonObject["requiredIriOrStringProperty"] === "string"
        ? $jsonObject["requiredIriOrStringProperty"]
        : dataFactory.namedNode(
            $jsonObject["requiredIriOrStringProperty"]["@id"],
          );
    const setClassOrClassOrStringProperty = $jsonObject[
      "setClassOrClassOrStringProperty"
    ].map((item) =>
      item.type === "2-string"
        ? { type: "2-string" as const, value: item.value }
        : item.type === "1-ClassUnionMember2"
          ? {
              type: "1-ClassUnionMember2" as const,
              value: ClassUnionMember2.$fromJson(item.value).unsafeCoerce(),
            }
          : {
              type: "0-ClassUnionMember1" as const,
              value: ClassUnionMember1.$fromJson(item.value).unsafeCoerce(),
            },
    );
    const setIriOrLiteralProperty = $jsonObject["setIriOrLiteralProperty"].map(
      (item) =>
        item.termType === "Literal"
          ? dataFactory.literal(
              item["@value"],
              typeof item["@language"] !== "undefined"
                ? item["@language"]
                : typeof item["@type"] !== "undefined"
                  ? dataFactory.namedNode(item["@type"])
                  : undefined,
            )
          : dataFactory.namedNode(item["@id"]),
    );
    const setIriOrStringProperty = $jsonObject["setIriOrStringProperty"].map(
      (item) =>
        typeof item === "string" ? item : dataFactory.namedNode(item["@id"]),
    );
    return purify.Either.of({
      $identifier,
      optionalClassOrClassOrStringProperty,
      optionalIriOrLiteralProperty,
      optionalIriOrStringProperty,
      requiredClassOrClassOrStringProperty,
      requiredIriOrLiteralProperty,
      requiredIriOrStringProperty,
      setClassOrClassOrStringProperty,
      setIriOrLiteralProperty,
      setIriOrStringProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      optionalClassOrClassOrStringProperty: purify.Maybe<
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
        | { type: "2-string"; value: string }
      >;
      optionalIriOrLiteralProperty: purify.Maybe<
        rdfjs.NamedNode | rdfjs.Literal
      >;
      optionalIriOrStringProperty: purify.Maybe<rdfjs.NamedNode | string>;
      requiredClassOrClassOrStringProperty:
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
        | { type: "2-string"; value: string };
      requiredIriOrLiteralProperty: rdfjs.NamedNode | rdfjs.Literal;
      requiredIriOrStringProperty: rdfjs.NamedNode | string;
      setClassOrClassOrStringProperty: readonly (
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
        | { type: "2-string"; value: string }
      )[];
      setIriOrLiteralProperty: readonly (rdfjs.NamedNode | rdfjs.Literal)[];
      setIriOrStringProperty: readonly (rdfjs.NamedNode | string)[];
    }
  > {
    return purify.Either.of<Error, UnionDiscriminantsClass.$Identifier>(
      $parameters.resource.identifier as UnionDiscriminantsClass.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.optionalClassOrClassOrStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          values.chainMap((value) => {
            const valueAsValues = purify.Either.of(value.toValues());
            return (
              valueAsValues
                .chain((values) =>
                  values.chainMap((value) =>
                    value.toResource().chain((resource) =>
                      ClassUnionMember1.$fromRdf(resource, {
                        context: $parameters.context,
                        objectSet: $parameters.objectSet,
                        preferredLanguages: $parameters.preferredLanguages,
                      }),
                    ),
                  ),
                )
                .map((values) =>
                  values.map(
                    (value) =>
                      ({ type: "0-ClassUnionMember1" as const, value }) as
                        | {
                            type: "0-ClassUnionMember1";
                            value: ClassUnionMember1;
                          }
                        | {
                            type: "1-ClassUnionMember2";
                            value: ClassUnionMember2;
                          }
                        | { type: "2-string"; value: string },
                  ),
                ) as purify.Either<
                Error,
                rdfjsResource.Resource.Values<
                  | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                  | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
                  | { type: "2-string"; value: string }
                >
              >
            )
              .altLazy(
                () =>
                  valueAsValues
                    .chain((values) =>
                      values.chainMap((value) =>
                        value.toResource().chain((resource) =>
                          ClassUnionMember2.$fromRdf(resource, {
                            context: $parameters.context,
                            objectSet: $parameters.objectSet,
                            preferredLanguages: $parameters.preferredLanguages,
                          }),
                        ),
                      ),
                    )
                    .map((values) =>
                      values.map(
                        (value) =>
                          ({ type: "1-ClassUnionMember2" as const, value }) as
                            | {
                                type: "0-ClassUnionMember1";
                                value: ClassUnionMember1;
                              }
                            | {
                                type: "1-ClassUnionMember2";
                                value: ClassUnionMember2;
                              }
                            | { type: "2-string"; value: string },
                      ),
                    ) as purify.Either<
                    Error,
                    rdfjsResource.Resource.Values<
                      | {
                          type: "0-ClassUnionMember1";
                          value: ClassUnionMember1;
                        }
                      | {
                          type: "1-ClassUnionMember2";
                          value: ClassUnionMember2;
                        }
                      | { type: "2-string"; value: string }
                    >
                  >,
              )
              .altLazy(
                () =>
                  valueAsValues
                    .chain((values) =>
                      $fromRdfPreferredLanguages({
                        focusResource: $parameters.resource,
                        predicate:
                          UnionDiscriminantsClass.$properties
                            .optionalClassOrClassOrStringProperty["identifier"],
                        preferredLanguages: $parameters.preferredLanguages,
                        values,
                      }),
                    )
                    .chain((values) =>
                      values.chainMap((value) => value.toString()),
                    )
                    .map((values) =>
                      values.map(
                        (value) =>
                          ({ type: "2-string" as const, value }) as
                            | {
                                type: "0-ClassUnionMember1";
                                value: ClassUnionMember1;
                              }
                            | {
                                type: "1-ClassUnionMember2";
                                value: ClassUnionMember2;
                              }
                            | { type: "2-string"; value: string },
                      ),
                    ) as purify.Either<
                    Error,
                    rdfjsResource.Resource.Values<
                      | {
                          type: "0-ClassUnionMember1";
                          value: ClassUnionMember1;
                        }
                      | {
                          type: "1-ClassUnionMember2";
                          value: ClassUnionMember2;
                        }
                      | { type: "2-string"; value: string }
                    >
                  >,
              )
              .chain((values) => values.head());
          }),
        )
        .map((values) =>
          values.length > 0
            ? values.map((value) => purify.Maybe.of(value))
            : rdfjsResource.Resource.Values.fromValue<
                purify.Maybe<
                  | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                  | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
                  | { type: "2-string"; value: string }
                >
              >({
                focusResource: $parameters.resource,
                predicate:
                  UnionDiscriminantsClass.$properties
                    .optionalClassOrClassOrStringProperty["identifier"],
                value: purify.Maybe.empty(),
              }),
        )
        .chain((values) => values.head())
        .chain((optionalClassOrClassOrStringProperty) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.optionalIriOrLiteralProperty["identifier"],
              { unique: true },
            ),
          )
            .chain((values) =>
              values.chainMap((value) => {
                const valueAsValues = purify.Either.of(value.toValues());
                return (
                  valueAsValues.chain((values) =>
                    values.chainMap((value) => value.toIri()),
                  ) as purify.Either<
                    Error,
                    rdfjsResource.Resource.Values<
                      rdfjs.NamedNode | rdfjs.Literal
                    >
                  >
                )
                  .altLazy(
                    () =>
                      valueAsValues
                        .chain((values) =>
                          $fromRdfPreferredLanguages({
                            focusResource: $parameters.resource,
                            predicate:
                              UnionDiscriminantsClass.$properties
                                .optionalIriOrLiteralProperty["identifier"],
                            preferredLanguages: $parameters.preferredLanguages,
                            values,
                          }),
                        )
                        .chain((values) =>
                          values.chainMap((value) => value.toLiteral()),
                        ) as purify.Either<
                        Error,
                        rdfjsResource.Resource.Values<
                          rdfjs.NamedNode | rdfjs.Literal
                        >
                      >,
                  )
                  .chain((values) => values.head());
              }),
            )
            .map((values) =>
              values.length > 0
                ? values.map((value) => purify.Maybe.of(value))
                : rdfjsResource.Resource.Values.fromValue<
                    purify.Maybe<rdfjs.NamedNode | rdfjs.Literal>
                  >({
                    focusResource: $parameters.resource,
                    predicate:
                      UnionDiscriminantsClass.$properties
                        .optionalIriOrLiteralProperty["identifier"],
                    value: purify.Maybe.empty(),
                  }),
            )
            .chain((values) => values.head())
            .chain((optionalIriOrLiteralProperty) =>
              purify.Either.of<
                Error,
                rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
              >(
                $parameters.resource.values(
                  $properties.optionalIriOrStringProperty["identifier"],
                  { unique: true },
                ),
              )
                .chain((values) =>
                  values.chainMap((value) => {
                    const valueAsValues = purify.Either.of(value.toValues());
                    return (
                      valueAsValues.chain((values) =>
                        values.chainMap((value) => value.toIri()),
                      ) as purify.Either<
                        Error,
                        rdfjsResource.Resource.Values<rdfjs.NamedNode | string>
                      >
                    )
                      .altLazy(
                        () =>
                          valueAsValues
                            .chain((values) =>
                              $fromRdfPreferredLanguages({
                                focusResource: $parameters.resource,
                                predicate:
                                  UnionDiscriminantsClass.$properties
                                    .optionalIriOrStringProperty["identifier"],
                                preferredLanguages:
                                  $parameters.preferredLanguages,
                                values,
                              }),
                            )
                            .chain((values) =>
                              values.chainMap((value) => value.toString()),
                            ) as purify.Either<
                            Error,
                            rdfjsResource.Resource.Values<
                              rdfjs.NamedNode | string
                            >
                          >,
                      )
                      .chain((values) => values.head());
                  }),
                )
                .map((values) =>
                  values.length > 0
                    ? values.map((value) => purify.Maybe.of(value))
                    : rdfjsResource.Resource.Values.fromValue<
                        purify.Maybe<rdfjs.NamedNode | string>
                      >({
                        focusResource: $parameters.resource,
                        predicate:
                          UnionDiscriminantsClass.$properties
                            .optionalIriOrStringProperty["identifier"],
                        value: purify.Maybe.empty(),
                      }),
                )
                .chain((values) => values.head())
                .chain((optionalIriOrStringProperty) =>
                  purify.Either.of<
                    Error,
                    rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                  >(
                    $parameters.resource.values(
                      $properties.requiredClassOrClassOrStringProperty[
                        "identifier"
                      ],
                      { unique: true },
                    ),
                  )
                    .chain((values) =>
                      values.chainMap((value) => {
                        const valueAsValues = purify.Either.of(
                          value.toValues(),
                        );
                        return (
                          valueAsValues
                            .chain((values) =>
                              values.chainMap((value) =>
                                value.toResource().chain((resource) =>
                                  ClassUnionMember1.$fromRdf(resource, {
                                    context: $parameters.context,
                                    objectSet: $parameters.objectSet,
                                    preferredLanguages:
                                      $parameters.preferredLanguages,
                                  }),
                                ),
                              ),
                            )
                            .map((values) =>
                              values.map(
                                (value) =>
                                  ({
                                    type: "0-ClassUnionMember1" as const,
                                    value,
                                  }) as
                                    | {
                                        type: "0-ClassUnionMember1";
                                        value: ClassUnionMember1;
                                      }
                                    | {
                                        type: "1-ClassUnionMember2";
                                        value: ClassUnionMember2;
                                      }
                                    | { type: "2-string"; value: string },
                              ),
                            ) as purify.Either<
                            Error,
                            rdfjsResource.Resource.Values<
                              | {
                                  type: "0-ClassUnionMember1";
                                  value: ClassUnionMember1;
                                }
                              | {
                                  type: "1-ClassUnionMember2";
                                  value: ClassUnionMember2;
                                }
                              | { type: "2-string"; value: string }
                            >
                          >
                        )
                          .altLazy(
                            () =>
                              valueAsValues
                                .chain((values) =>
                                  values.chainMap((value) =>
                                    value.toResource().chain((resource) =>
                                      ClassUnionMember2.$fromRdf(resource, {
                                        context: $parameters.context,
                                        objectSet: $parameters.objectSet,
                                        preferredLanguages:
                                          $parameters.preferredLanguages,
                                      }),
                                    ),
                                  ),
                                )
                                .map((values) =>
                                  values.map(
                                    (value) =>
                                      ({
                                        type: "1-ClassUnionMember2" as const,
                                        value,
                                      }) as
                                        | {
                                            type: "0-ClassUnionMember1";
                                            value: ClassUnionMember1;
                                          }
                                        | {
                                            type: "1-ClassUnionMember2";
                                            value: ClassUnionMember2;
                                          }
                                        | { type: "2-string"; value: string },
                                  ),
                                ) as purify.Either<
                                Error,
                                rdfjsResource.Resource.Values<
                                  | {
                                      type: "0-ClassUnionMember1";
                                      value: ClassUnionMember1;
                                    }
                                  | {
                                      type: "1-ClassUnionMember2";
                                      value: ClassUnionMember2;
                                    }
                                  | { type: "2-string"; value: string }
                                >
                              >,
                          )
                          .altLazy(
                            () =>
                              valueAsValues
                                .chain((values) =>
                                  $fromRdfPreferredLanguages({
                                    focusResource: $parameters.resource,
                                    predicate:
                                      UnionDiscriminantsClass.$properties
                                        .requiredClassOrClassOrStringProperty[
                                        "identifier"
                                      ],
                                    preferredLanguages:
                                      $parameters.preferredLanguages,
                                    values,
                                  }),
                                )
                                .chain((values) =>
                                  values.chainMap((value) => value.toString()),
                                )
                                .map((values) =>
                                  values.map(
                                    (value) =>
                                      ({ type: "2-string" as const, value }) as
                                        | {
                                            type: "0-ClassUnionMember1";
                                            value: ClassUnionMember1;
                                          }
                                        | {
                                            type: "1-ClassUnionMember2";
                                            value: ClassUnionMember2;
                                          }
                                        | { type: "2-string"; value: string },
                                  ),
                                ) as purify.Either<
                                Error,
                                rdfjsResource.Resource.Values<
                                  | {
                                      type: "0-ClassUnionMember1";
                                      value: ClassUnionMember1;
                                    }
                                  | {
                                      type: "1-ClassUnionMember2";
                                      value: ClassUnionMember2;
                                    }
                                  | { type: "2-string"; value: string }
                                >
                              >,
                          )
                          .chain((values) => values.head());
                      }),
                    )
                    .chain((values) => values.head())
                    .chain((requiredClassOrClassOrStringProperty) =>
                      purify.Either.of<
                        Error,
                        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                      >(
                        $parameters.resource.values(
                          $properties.requiredIriOrLiteralProperty[
                            "identifier"
                          ],
                          { unique: true },
                        ),
                      )
                        .chain((values) =>
                          values.chainMap((value) => {
                            const valueAsValues = purify.Either.of(
                              value.toValues(),
                            );
                            return (
                              valueAsValues.chain((values) =>
                                values.chainMap((value) => value.toIri()),
                              ) as purify.Either<
                                Error,
                                rdfjsResource.Resource.Values<
                                  rdfjs.NamedNode | rdfjs.Literal
                                >
                              >
                            )
                              .altLazy(
                                () =>
                                  valueAsValues
                                    .chain((values) =>
                                      $fromRdfPreferredLanguages({
                                        focusResource: $parameters.resource,
                                        predicate:
                                          UnionDiscriminantsClass.$properties
                                            .requiredIriOrLiteralProperty[
                                            "identifier"
                                          ],
                                        preferredLanguages:
                                          $parameters.preferredLanguages,
                                        values,
                                      }),
                                    )
                                    .chain((values) =>
                                      values.chainMap((value) =>
                                        value.toLiteral(),
                                      ),
                                    ) as purify.Either<
                                    Error,
                                    rdfjsResource.Resource.Values<
                                      rdfjs.NamedNode | rdfjs.Literal
                                    >
                                  >,
                              )
                              .chain((values) => values.head());
                          }),
                        )
                        .chain((values) => values.head())
                        .chain((requiredIriOrLiteralProperty) =>
                          purify.Either.of<
                            Error,
                            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                          >(
                            $parameters.resource.values(
                              $properties.requiredIriOrStringProperty[
                                "identifier"
                              ],
                              { unique: true },
                            ),
                          )
                            .chain((values) =>
                              values.chainMap((value) => {
                                const valueAsValues = purify.Either.of(
                                  value.toValues(),
                                );
                                return (
                                  valueAsValues.chain((values) =>
                                    values.chainMap((value) => value.toIri()),
                                  ) as purify.Either<
                                    Error,
                                    rdfjsResource.Resource.Values<
                                      rdfjs.NamedNode | string
                                    >
                                  >
                                )
                                  .altLazy(
                                    () =>
                                      valueAsValues
                                        .chain((values) =>
                                          $fromRdfPreferredLanguages({
                                            focusResource: $parameters.resource,
                                            predicate:
                                              UnionDiscriminantsClass
                                                .$properties
                                                .requiredIriOrStringProperty[
                                                "identifier"
                                              ],
                                            preferredLanguages:
                                              $parameters.preferredLanguages,
                                            values,
                                          }),
                                        )
                                        .chain((values) =>
                                          values.chainMap((value) =>
                                            value.toString(),
                                          ),
                                        ) as purify.Either<
                                        Error,
                                        rdfjsResource.Resource.Values<
                                          rdfjs.NamedNode | string
                                        >
                                      >,
                                  )
                                  .chain((values) => values.head());
                              }),
                            )
                            .chain((values) => values.head())
                            .chain((requiredIriOrStringProperty) =>
                              purify.Either.of<
                                Error,
                                rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                              >(
                                $parameters.resource.values(
                                  $properties.setClassOrClassOrStringProperty[
                                    "identifier"
                                  ],
                                  { unique: true },
                                ),
                              )
                                .chain((values) =>
                                  values.chainMap((value) => {
                                    const valueAsValues = purify.Either.of(
                                      value.toValues(),
                                    );
                                    return (
                                      valueAsValues
                                        .chain((values) =>
                                          values.chainMap((value) =>
                                            value
                                              .toResource()
                                              .chain((resource) =>
                                                ClassUnionMember1.$fromRdf(
                                                  resource,
                                                  {
                                                    context:
                                                      $parameters.context,
                                                    objectSet:
                                                      $parameters.objectSet,
                                                    preferredLanguages:
                                                      $parameters.preferredLanguages,
                                                  },
                                                ),
                                              ),
                                          ),
                                        )
                                        .map((values) =>
                                          values.map(
                                            (value) =>
                                              ({
                                                type: "0-ClassUnionMember1" as const,
                                                value,
                                              }) as
                                                | {
                                                    type: "0-ClassUnionMember1";
                                                    value: ClassUnionMember1;
                                                  }
                                                | {
                                                    type: "1-ClassUnionMember2";
                                                    value: ClassUnionMember2;
                                                  }
                                                | {
                                                    type: "2-string";
                                                    value: string;
                                                  },
                                          ),
                                        ) as purify.Either<
                                        Error,
                                        rdfjsResource.Resource.Values<
                                          | {
                                              type: "0-ClassUnionMember1";
                                              value: ClassUnionMember1;
                                            }
                                          | {
                                              type: "1-ClassUnionMember2";
                                              value: ClassUnionMember2;
                                            }
                                          | { type: "2-string"; value: string }
                                        >
                                      >
                                    )
                                      .altLazy(
                                        () =>
                                          valueAsValues
                                            .chain((values) =>
                                              values.chainMap((value) =>
                                                value
                                                  .toResource()
                                                  .chain((resource) =>
                                                    ClassUnionMember2.$fromRdf(
                                                      resource,
                                                      {
                                                        context:
                                                          $parameters.context,
                                                        objectSet:
                                                          $parameters.objectSet,
                                                        preferredLanguages:
                                                          $parameters.preferredLanguages,
                                                      },
                                                    ),
                                                  ),
                                              ),
                                            )
                                            .map((values) =>
                                              values.map(
                                                (value) =>
                                                  ({
                                                    type: "1-ClassUnionMember2" as const,
                                                    value,
                                                  }) as
                                                    | {
                                                        type: "0-ClassUnionMember1";
                                                        value: ClassUnionMember1;
                                                      }
                                                    | {
                                                        type: "1-ClassUnionMember2";
                                                        value: ClassUnionMember2;
                                                      }
                                                    | {
                                                        type: "2-string";
                                                        value: string;
                                                      },
                                              ),
                                            ) as purify.Either<
                                            Error,
                                            rdfjsResource.Resource.Values<
                                              | {
                                                  type: "0-ClassUnionMember1";
                                                  value: ClassUnionMember1;
                                                }
                                              | {
                                                  type: "1-ClassUnionMember2";
                                                  value: ClassUnionMember2;
                                                }
                                              | {
                                                  type: "2-string";
                                                  value: string;
                                                }
                                            >
                                          >,
                                      )
                                      .altLazy(
                                        () =>
                                          valueAsValues
                                            .chain((values) =>
                                              $fromRdfPreferredLanguages({
                                                focusResource:
                                                  $parameters.resource,
                                                predicate:
                                                  UnionDiscriminantsClass
                                                    .$properties
                                                    .setClassOrClassOrStringProperty[
                                                    "identifier"
                                                  ],
                                                preferredLanguages:
                                                  $parameters.preferredLanguages,
                                                values,
                                              }),
                                            )
                                            .chain((values) =>
                                              values.chainMap((value) =>
                                                value.toString(),
                                              ),
                                            )
                                            .map((values) =>
                                              values.map(
                                                (value) =>
                                                  ({
                                                    type: "2-string" as const,
                                                    value,
                                                  }) as
                                                    | {
                                                        type: "0-ClassUnionMember1";
                                                        value: ClassUnionMember1;
                                                      }
                                                    | {
                                                        type: "1-ClassUnionMember2";
                                                        value: ClassUnionMember2;
                                                      }
                                                    | {
                                                        type: "2-string";
                                                        value: string;
                                                      },
                                              ),
                                            ) as purify.Either<
                                            Error,
                                            rdfjsResource.Resource.Values<
                                              | {
                                                  type: "0-ClassUnionMember1";
                                                  value: ClassUnionMember1;
                                                }
                                              | {
                                                  type: "1-ClassUnionMember2";
                                                  value: ClassUnionMember2;
                                                }
                                              | {
                                                  type: "2-string";
                                                  value: string;
                                                }
                                            >
                                          >,
                                      )
                                      .chain((values) => values.head());
                                  }),
                                )
                                .map((values) => values.toArray())
                                .map((valuesArray) =>
                                  rdfjsResource.Resource.Values.fromValue({
                                    focusResource: $parameters.resource,
                                    predicate:
                                      UnionDiscriminantsClass.$properties
                                        .setClassOrClassOrStringProperty[
                                        "identifier"
                                      ],
                                    value: valuesArray,
                                  }),
                                )
                                .chain((values) => values.head())
                                .chain((setClassOrClassOrStringProperty) =>
                                  purify.Either.of<
                                    Error,
                                    rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                                  >(
                                    $parameters.resource.values(
                                      $properties.setIriOrLiteralProperty[
                                        "identifier"
                                      ],
                                      { unique: true },
                                    ),
                                  )
                                    .chain((values) =>
                                      values.chainMap((value) => {
                                        const valueAsValues = purify.Either.of(
                                          value.toValues(),
                                        );
                                        return (
                                          valueAsValues.chain((values) =>
                                            values.chainMap((value) =>
                                              value.toIri(),
                                            ),
                                          ) as purify.Either<
                                            Error,
                                            rdfjsResource.Resource.Values<
                                              rdfjs.NamedNode | rdfjs.Literal
                                            >
                                          >
                                        )
                                          .altLazy(
                                            () =>
                                              valueAsValues
                                                .chain((values) =>
                                                  $fromRdfPreferredLanguages({
                                                    focusResource:
                                                      $parameters.resource,
                                                    predicate:
                                                      UnionDiscriminantsClass
                                                        .$properties
                                                        .setIriOrLiteralProperty[
                                                        "identifier"
                                                      ],
                                                    preferredLanguages:
                                                      $parameters.preferredLanguages,
                                                    values,
                                                  }),
                                                )
                                                .chain((values) =>
                                                  values.chainMap((value) =>
                                                    value.toLiteral(),
                                                  ),
                                                ) as purify.Either<
                                                Error,
                                                rdfjsResource.Resource.Values<
                                                  | rdfjs.NamedNode
                                                  | rdfjs.Literal
                                                >
                                              >,
                                          )
                                          .chain((values) => values.head());
                                      }),
                                    )
                                    .map((values) => values.toArray())
                                    .map((valuesArray) =>
                                      rdfjsResource.Resource.Values.fromValue({
                                        focusResource: $parameters.resource,
                                        predicate:
                                          UnionDiscriminantsClass.$properties
                                            .setIriOrLiteralProperty[
                                            "identifier"
                                          ],
                                        value: valuesArray,
                                      }),
                                    )
                                    .chain((values) => values.head())
                                    .chain((setIriOrLiteralProperty) =>
                                      purify.Either.of<
                                        Error,
                                        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                                      >(
                                        $parameters.resource.values(
                                          $properties.setIriOrStringProperty[
                                            "identifier"
                                          ],
                                          { unique: true },
                                        ),
                                      )
                                        .chain((values) =>
                                          values.chainMap((value) => {
                                            const valueAsValues =
                                              purify.Either.of(
                                                value.toValues(),
                                              );
                                            return (
                                              valueAsValues.chain((values) =>
                                                values.chainMap((value) =>
                                                  value.toIri(),
                                                ),
                                              ) as purify.Either<
                                                Error,
                                                rdfjsResource.Resource.Values<
                                                  rdfjs.NamedNode | string
                                                >
                                              >
                                            )
                                              .altLazy(
                                                () =>
                                                  valueAsValues
                                                    .chain((values) =>
                                                      $fromRdfPreferredLanguages(
                                                        {
                                                          focusResource:
                                                            $parameters.resource,
                                                          predicate:
                                                            UnionDiscriminantsClass
                                                              .$properties
                                                              .setIriOrStringProperty[
                                                              "identifier"
                                                            ],
                                                          preferredLanguages:
                                                            $parameters.preferredLanguages,
                                                          values,
                                                        },
                                                      ),
                                                    )
                                                    .chain((values) =>
                                                      values.chainMap((value) =>
                                                        value.toString(),
                                                      ),
                                                    ) as purify.Either<
                                                    Error,
                                                    rdfjsResource.Resource.Values<
                                                      rdfjs.NamedNode | string
                                                    >
                                                  >,
                                              )
                                              .chain((values) => values.head());
                                          }),
                                        )
                                        .map((values) => values.toArray())
                                        .map((valuesArray) =>
                                          rdfjsResource.Resource.Values.fromValue(
                                            {
                                              focusResource:
                                                $parameters.resource,
                                              predicate:
                                                UnionDiscriminantsClass
                                                  .$properties
                                                  .setIriOrStringProperty[
                                                  "identifier"
                                                ],
                                              value: valuesArray,
                                            },
                                          ),
                                        )
                                        .chain((values) => values.head())
                                        .map((setIriOrStringProperty) => ({
                                          $identifier,
                                          optionalClassOrClassOrStringProperty,
                                          optionalIriOrLiteralProperty,
                                          optionalIriOrStringProperty,
                                          requiredClassOrClassOrStringProperty,
                                          requiredIriOrLiteralProperty,
                                          requiredIriOrStringProperty,
                                          setClassOrClassOrStringProperty,
                                          setIriOrLiteralProperty,
                                          setIriOrStringProperty,
                                        })),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: UnionDiscriminantsClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        UnionDiscriminantsClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            UnionDiscriminantsClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: UnionDiscriminantsClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      UnionDiscriminantsClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("unionDiscriminantsClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
      ),
      predicate:
        UnionDiscriminantsClass.$properties
          .optionalClassOrClassOrStringProperty["identifier"],
      subject,
    });
    triples.push(
      ...ClassUnionMember1.$sparqlConstructTriples({
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
      }),
    );
    triples.push(
      ...ClassUnionMember2.$sparqlConstructTriples({
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrLiteralProperty`,
      ),
      predicate:
        UnionDiscriminantsClass.$properties.optionalIriOrLiteralProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrStringProperty`,
      ),
      predicate:
        UnionDiscriminantsClass.$properties.optionalIriOrStringProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
      ),
      predicate:
        UnionDiscriminantsClass.$properties
          .requiredClassOrClassOrStringProperty["identifier"],
      subject,
    });
    triples.push(
      ...ClassUnionMember1.$sparqlConstructTriples({
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
      }),
    );
    triples.push(
      ...ClassUnionMember2.$sparqlConstructTriples({
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrLiteralProperty`,
      ),
      predicate:
        UnionDiscriminantsClass.$properties.requiredIriOrLiteralProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrStringProperty`,
      ),
      predicate:
        UnionDiscriminantsClass.$properties.requiredIriOrStringProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
      ),
      predicate:
        UnionDiscriminantsClass.$properties.setClassOrClassOrStringProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...ClassUnionMember1.$sparqlConstructTriples({
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
      }),
    );
    triples.push(
      ...ClassUnionMember2.$sparqlConstructTriples({
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrLiteralProperty`,
      ),
      predicate:
        UnionDiscriminantsClass.$properties.setIriOrLiteralProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrStringProperty`,
      ),
      predicate:
        UnionDiscriminantsClass.$properties.setIriOrStringProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: UnionDiscriminantsClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("unionDiscriminantsClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalClassOrClassOrStringProperty,
          (itemFilter) => [
            {
              patterns: [
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
                          ),
                          predicate:
                            UnionDiscriminantsClass.$properties
                              .optionalClassOrClassOrStringProperty[
                              "identifier"
                            ],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: ClassUnionMember1.$sparqlWherePatterns({
                        filter: itemFilter?.on?.["0-ClassUnionMember1"],
                        preferredLanguages: parameters?.preferredLanguages,
                        subject: dataFactory.variable!(
                          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
                        ),
                        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
                      }).concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
                          ),
                          predicate:
                            UnionDiscriminantsClass.$properties
                              .optionalClassOrClassOrStringProperty[
                              "identifier"
                            ],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: ClassUnionMember2.$sparqlWherePatterns({
                        filter: itemFilter?.on?.["1-ClassUnionMember2"],
                        preferredLanguages: parameters?.preferredLanguages,
                        subject: dataFactory.variable!(
                          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
                        ),
                        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
                      }).concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
                          ),
                          predicate:
                            UnionDiscriminantsClass.$properties
                              .optionalClassOrClassOrStringProperty[
                              "identifier"
                            ],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: [parameters?.preferredLanguages ?? []]
                        .filter((languages) => languages.length > 0)
                        .map((languages) =>
                          languages.map((language) => ({
                            type: "operation" as const,
                            operator: "=",
                            args: [
                              {
                                type: "operation" as const,
                                operator: "lang",
                                args: [
                                  dataFactory.variable!(
                                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
                                  ),
                                ],
                              },
                              dataFactory.literal(language),
                            ],
                          })),
                        )
                        .map((langEqualsExpressions) => ({
                          type: "filter" as const,
                          expression: langEqualsExpressions.reduce(
                            (reducedExpression, langEqualsExpression) => {
                              if (reducedExpression === null) {
                                return langEqualsExpression;
                              }
                              return {
                                type: "operation" as const,
                                operator: "||",
                                args: [reducedExpression, langEqualsExpression],
                              };
                            },
                            null as sparqljs.Expression | null,
                          ) as sparqljs.Expression,
                        }))
                        .concat(),
                      type: "group",
                    },
                    {
                      patterns: $StringFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["2-string"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
              ],
              type: "union",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalIriOrLiteralProperty,
          (itemFilter) => [
            {
              patterns: [
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrLiteralProperty`,
                          ),
                          predicate:
                            UnionDiscriminantsClass.$properties
                              .optionalIriOrLiteralProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: $NamedNodeFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["NamedNode"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrLiteralProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrLiteralProperty`,
                          ),
                          predicate:
                            UnionDiscriminantsClass.$properties
                              .optionalIriOrLiteralProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: [parameters?.preferredLanguages ?? []]
                        .filter((languages) => languages.length > 0)
                        .map((languages) =>
                          languages.map((language) => ({
                            type: "operation" as const,
                            operator: "=",
                            args: [
                              {
                                type: "operation" as const,
                                operator: "lang",
                                args: [
                                  dataFactory.variable!(
                                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrLiteralProperty`,
                                  ),
                                ],
                              },
                              dataFactory.literal(language),
                            ],
                          })),
                        )
                        .map((langEqualsExpressions) => ({
                          type: "filter" as const,
                          expression: langEqualsExpressions.reduce(
                            (reducedExpression, langEqualsExpression) => {
                              if (reducedExpression === null) {
                                return langEqualsExpression;
                              }
                              return {
                                type: "operation" as const,
                                operator: "||",
                                args: [reducedExpression, langEqualsExpression],
                              };
                            },
                            null as sparqljs.Expression | null,
                          ) as sparqljs.Expression,
                        }))
                        .concat(),
                      type: "group",
                    },
                    {
                      patterns: $LiteralFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["Literal"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrLiteralProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
              ],
              type: "union",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalIriOrStringProperty,
          (itemFilter) => [
            {
              patterns: [
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrStringProperty`,
                          ),
                          predicate:
                            UnionDiscriminantsClass.$properties
                              .optionalIriOrStringProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: $NamedNodeFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["object"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrStringProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrStringProperty`,
                          ),
                          predicate:
                            UnionDiscriminantsClass.$properties
                              .optionalIriOrStringProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: [parameters?.preferredLanguages ?? []]
                        .filter((languages) => languages.length > 0)
                        .map((languages) =>
                          languages.map((language) => ({
                            type: "operation" as const,
                            operator: "=",
                            args: [
                              {
                                type: "operation" as const,
                                operator: "lang",
                                args: [
                                  dataFactory.variable!(
                                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrStringProperty`,
                                  ),
                                ],
                              },
                              dataFactory.literal(language),
                            ],
                          })),
                        )
                        .map((langEqualsExpressions) => ({
                          type: "filter" as const,
                          expression: langEqualsExpressions.reduce(
                            (reducedExpression, langEqualsExpression) => {
                              if (reducedExpression === null) {
                                return langEqualsExpression;
                              }
                              return {
                                type: "operation" as const,
                                operator: "||",
                                args: [reducedExpression, langEqualsExpression],
                              };
                            },
                            null as sparqljs.Expression | null,
                          ) as sparqljs.Expression,
                        }))
                        .concat(),
                      type: "group",
                    },
                    {
                      patterns: $StringFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["string"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrStringProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
              ],
              type: "union",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: [
        {
          patterns: [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
                  ),
                  predicate:
                    UnionDiscriminantsClass.$properties
                      .requiredClassOrClassOrStringProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: ClassUnionMember1.$sparqlWherePatterns({
                filter:
                  parameters?.filter?.requiredClassOrClassOrStringProperty
                    ?.on?.["0-ClassUnionMember1"],
                preferredLanguages: parameters?.preferredLanguages,
                subject: dataFactory.variable!(
                  `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
                ),
                variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
              }).concat(),
              type: "group",
            },
          ],
          type: "group",
        },
        {
          patterns: [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
                  ),
                  predicate:
                    UnionDiscriminantsClass.$properties
                      .requiredClassOrClassOrStringProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: ClassUnionMember2.$sparqlWherePatterns({
                filter:
                  parameters?.filter?.requiredClassOrClassOrStringProperty
                    ?.on?.["1-ClassUnionMember2"],
                preferredLanguages: parameters?.preferredLanguages,
                subject: dataFactory.variable!(
                  `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
                ),
                variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
              }).concat(),
              type: "group",
            },
          ],
          type: "group",
        },
        {
          patterns: [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
                  ),
                  predicate:
                    UnionDiscriminantsClass.$properties
                      .requiredClassOrClassOrStringProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [parameters?.preferredLanguages ?? []]
                .filter((languages) => languages.length > 0)
                .map((languages) =>
                  languages.map((language) => ({
                    type: "operation" as const,
                    operator: "=",
                    args: [
                      {
                        type: "operation" as const,
                        operator: "lang",
                        args: [
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
                          ),
                        ],
                      },
                      dataFactory.literal(language),
                    ],
                  })),
                )
                .map((langEqualsExpressions) => ({
                  type: "filter" as const,
                  expression: langEqualsExpressions.reduce(
                    (reducedExpression, langEqualsExpression) => {
                      if (reducedExpression === null) {
                        return langEqualsExpression;
                      }
                      return {
                        type: "operation" as const,
                        operator: "||",
                        args: [reducedExpression, langEqualsExpression],
                      };
                    },
                    null as sparqljs.Expression | null,
                  ) as sparqljs.Expression,
                }))
                .concat(),
              type: "group",
            },
            {
              patterns: $StringFilter
                .$sparqlWherePatterns(
                  parameters?.filter?.requiredClassOrClassOrStringProperty
                    ?.on?.["2-string"],
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
          type: "group",
        },
      ],
      type: "union",
    });
    patterns.push({
      patterns: [
        {
          patterns: [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrLiteralProperty`,
                  ),
                  predicate:
                    UnionDiscriminantsClass.$properties
                      .requiredIriOrLiteralProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $NamedNodeFilter
                .$sparqlWherePatterns(
                  parameters?.filter?.requiredIriOrLiteralProperty?.on?.[
                    "NamedNode"
                  ],
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrLiteralProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
          type: "group",
        },
        {
          patterns: [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrLiteralProperty`,
                  ),
                  predicate:
                    UnionDiscriminantsClass.$properties
                      .requiredIriOrLiteralProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [parameters?.preferredLanguages ?? []]
                .filter((languages) => languages.length > 0)
                .map((languages) =>
                  languages.map((language) => ({
                    type: "operation" as const,
                    operator: "=",
                    args: [
                      {
                        type: "operation" as const,
                        operator: "lang",
                        args: [
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrLiteralProperty`,
                          ),
                        ],
                      },
                      dataFactory.literal(language),
                    ],
                  })),
                )
                .map((langEqualsExpressions) => ({
                  type: "filter" as const,
                  expression: langEqualsExpressions.reduce(
                    (reducedExpression, langEqualsExpression) => {
                      if (reducedExpression === null) {
                        return langEqualsExpression;
                      }
                      return {
                        type: "operation" as const,
                        operator: "||",
                        args: [reducedExpression, langEqualsExpression],
                      };
                    },
                    null as sparqljs.Expression | null,
                  ) as sparqljs.Expression,
                }))
                .concat(),
              type: "group",
            },
            {
              patterns: $LiteralFilter
                .$sparqlWherePatterns(
                  parameters?.filter?.requiredIriOrLiteralProperty?.on?.[
                    "Literal"
                  ],
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrLiteralProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
          type: "group",
        },
      ],
      type: "union",
    });
    patterns.push({
      patterns: [
        {
          patterns: [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrStringProperty`,
                  ),
                  predicate:
                    UnionDiscriminantsClass.$properties
                      .requiredIriOrStringProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $NamedNodeFilter
                .$sparqlWherePatterns(
                  parameters?.filter?.requiredIriOrStringProperty?.on?.[
                    "object"
                  ],
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrStringProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
          type: "group",
        },
        {
          patterns: [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrStringProperty`,
                  ),
                  predicate:
                    UnionDiscriminantsClass.$properties
                      .requiredIriOrStringProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [parameters?.preferredLanguages ?? []]
                .filter((languages) => languages.length > 0)
                .map((languages) =>
                  languages.map((language) => ({
                    type: "operation" as const,
                    operator: "=",
                    args: [
                      {
                        type: "operation" as const,
                        operator: "lang",
                        args: [
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrStringProperty`,
                          ),
                        ],
                      },
                      dataFactory.literal(language),
                    ],
                  })),
                )
                .map((langEqualsExpressions) => ({
                  type: "filter" as const,
                  expression: langEqualsExpressions.reduce(
                    (reducedExpression, langEqualsExpression) => {
                      if (reducedExpression === null) {
                        return langEqualsExpression;
                      }
                      return {
                        type: "operation" as const,
                        operator: "||",
                        args: [reducedExpression, langEqualsExpression],
                      };
                    },
                    null as sparqljs.Expression | null,
                  ) as sparqljs.Expression,
                }))
                .concat(),
              type: "group",
            },
            {
              patterns: $StringFilter
                .$sparqlWherePatterns(
                  parameters?.filter?.requiredIriOrStringProperty?.on?.[
                    "string"
                  ],
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrStringProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
          type: "group",
        },
      ],
      type: "union",
    });
    patterns.push({
      patterns: [
        {
          patterns: [
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
                      ),
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .setClassOrClassOrStringProperty["identifier"],
                      subject: subject,
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: ClassUnionMember1.$sparqlWherePatterns({
                    filter:
                      parameters?.filter?.setClassOrClassOrStringProperty?.on?.[
                        "0-ClassUnionMember1"
                      ],
                    preferredLanguages: parameters?.preferredLanguages,
                    subject: dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
                    ),
                    variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
                  }).concat(),
                  type: "group",
                },
              ],
              type: "group",
            },
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
                      ),
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .setClassOrClassOrStringProperty["identifier"],
                      subject: subject,
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: ClassUnionMember2.$sparqlWherePatterns({
                    filter:
                      parameters?.filter?.setClassOrClassOrStringProperty?.on?.[
                        "1-ClassUnionMember2"
                      ],
                    preferredLanguages: parameters?.preferredLanguages,
                    subject: dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
                    ),
                    variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
                  }).concat(),
                  type: "group",
                },
              ],
              type: "group",
            },
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
                      ),
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .setClassOrClassOrStringProperty["identifier"],
                      subject: subject,
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: [parameters?.preferredLanguages ?? []]
                    .filter((languages) => languages.length > 0)
                    .map((languages) =>
                      languages.map((language) => ({
                        type: "operation" as const,
                        operator: "=",
                        args: [
                          {
                            type: "operation" as const,
                            operator: "lang",
                            args: [
                              dataFactory.variable!(
                                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
                              ),
                            ],
                          },
                          dataFactory.literal(language),
                        ],
                      })),
                    )
                    .map((langEqualsExpressions) => ({
                      type: "filter" as const,
                      expression: langEqualsExpressions.reduce(
                        (reducedExpression, langEqualsExpression) => {
                          if (reducedExpression === null) {
                            return langEqualsExpression;
                          }
                          return {
                            type: "operation" as const,
                            operator: "||",
                            args: [reducedExpression, langEqualsExpression],
                          };
                        },
                        null as sparqljs.Expression | null,
                      ) as sparqljs.Expression,
                    }))
                    .concat(),
                  type: "group",
                },
                {
                  patterns: $StringFilter
                    .$sparqlWherePatterns(
                      parameters?.filter?.setClassOrClassOrStringProperty?.on?.[
                        "2-string"
                      ],
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
              ],
              type: "group",
            },
          ],
          type: "union",
        },
      ],
      type: "optional",
    });
    patterns.push({
      patterns: [
        {
          patterns: [
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrLiteralProperty`,
                      ),
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .setIriOrLiteralProperty["identifier"],
                      subject: subject,
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: $NamedNodeFilter
                    .$sparqlWherePatterns(
                      parameters?.filter?.setIriOrLiteralProperty?.on?.[
                        "NamedNode"
                      ],
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrLiteralProperty`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
              ],
              type: "group",
            },
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrLiteralProperty`,
                      ),
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .setIriOrLiteralProperty["identifier"],
                      subject: subject,
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: [parameters?.preferredLanguages ?? []]
                    .filter((languages) => languages.length > 0)
                    .map((languages) =>
                      languages.map((language) => ({
                        type: "operation" as const,
                        operator: "=",
                        args: [
                          {
                            type: "operation" as const,
                            operator: "lang",
                            args: [
                              dataFactory.variable!(
                                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrLiteralProperty`,
                              ),
                            ],
                          },
                          dataFactory.literal(language),
                        ],
                      })),
                    )
                    .map((langEqualsExpressions) => ({
                      type: "filter" as const,
                      expression: langEqualsExpressions.reduce(
                        (reducedExpression, langEqualsExpression) => {
                          if (reducedExpression === null) {
                            return langEqualsExpression;
                          }
                          return {
                            type: "operation" as const,
                            operator: "||",
                            args: [reducedExpression, langEqualsExpression],
                          };
                        },
                        null as sparqljs.Expression | null,
                      ) as sparqljs.Expression,
                    }))
                    .concat(),
                  type: "group",
                },
                {
                  patterns: $LiteralFilter
                    .$sparqlWherePatterns(
                      parameters?.filter?.setIriOrLiteralProperty?.on?.[
                        "Literal"
                      ],
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrLiteralProperty`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
              ],
              type: "group",
            },
          ],
          type: "union",
        },
      ],
      type: "optional",
    });
    patterns.push({
      patterns: [
        {
          patterns: [
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrStringProperty`,
                      ),
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .setIriOrStringProperty["identifier"],
                      subject: subject,
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: $NamedNodeFilter
                    .$sparqlWherePatterns(
                      parameters?.filter?.setIriOrStringProperty?.on?.[
                        "object"
                      ],
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrStringProperty`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
              ],
              type: "group",
            },
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrStringProperty`,
                      ),
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .setIriOrStringProperty["identifier"],
                      subject: subject,
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: [parameters?.preferredLanguages ?? []]
                    .filter((languages) => languages.length > 0)
                    .map((languages) =>
                      languages.map((language) => ({
                        type: "operation" as const,
                        operator: "=",
                        args: [
                          {
                            type: "operation" as const,
                            operator: "lang",
                            args: [
                              dataFactory.variable!(
                                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrStringProperty`,
                              ),
                            ],
                          },
                          dataFactory.literal(language),
                        ],
                      })),
                    )
                    .map((langEqualsExpressions) => ({
                      type: "filter" as const,
                      expression: langEqualsExpressions.reduce(
                        (reducedExpression, langEqualsExpression) => {
                          if (reducedExpression === null) {
                            return langEqualsExpression;
                          }
                          return {
                            type: "operation" as const,
                            operator: "||",
                            args: [reducedExpression, langEqualsExpression],
                          };
                        },
                        null as sparqljs.Expression | null,
                      ) as sparqljs.Expression,
                    }))
                    .concat(),
                  type: "group",
                },
                {
                  patterns: $StringFilter
                    .$sparqlWherePatterns(
                      parameters?.filter?.setIriOrStringProperty?.on?.[
                        "string"
                      ],
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrStringProperty`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
              ],
              type: "group",
            },
          ],
          type: "union",
        },
      ],
      type: "optional",
    });
    return patterns;
  }

  export function isUnionDiscriminantsClass(
    object: $Object,
  ): object is UnionDiscriminantsClass {
    switch (object.$type) {
      case "UnionDiscriminantsClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Shape with properties that are not nested objects
 */
export class TermPropertiesClass {
  private _$identifier?: TermPropertiesClass.$Identifier;
  readonly $type = "TermPropertiesClass";
  readonly blankNodeTermProperty: purify.Maybe<rdfjs.BlankNode>;
  readonly booleanTermProperty: purify.Maybe<boolean>;
  readonly dateTermProperty: purify.Maybe<Date>;
  readonly dateTimeTermProperty: purify.Maybe<Date>;
  readonly iriTermProperty: purify.Maybe<rdfjs.NamedNode>;
  readonly literalTermProperty: purify.Maybe<rdfjs.Literal>;
  readonly numberTermProperty: purify.Maybe<number>;
  readonly stringTermProperty: purify.Maybe<string>;
  readonly termProperty: purify.Maybe<
    rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
  >;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly blankNodeTermProperty?:
      | rdfjs.BlankNode
      | purify.Maybe<rdfjs.BlankNode>;
    readonly booleanTermProperty?: boolean | purify.Maybe<boolean>;
    readonly dateTermProperty?: Date | purify.Maybe<Date>;
    readonly dateTimeTermProperty?: Date | purify.Maybe<Date>;
    readonly iriTermProperty?:
      | rdfjs.NamedNode
      | purify.Maybe<rdfjs.NamedNode>
      | string;
    readonly literalTermProperty?:
      | rdfjs.Literal
      | Date
      | boolean
      | number
      | purify.Maybe<rdfjs.Literal>
      | string;
    readonly numberTermProperty?: number | purify.Maybe<number>;
    readonly stringTermProperty?: purify.Maybe<string> | string;
    readonly termProperty?:
      | (rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode)
      | Date
      | boolean
      | number
      | purify.Maybe<rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode>
      | string;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.blankNodeTermProperty)) {
      this.blankNodeTermProperty = parameters?.blankNodeTermProperty;
    } else if (typeof parameters?.blankNodeTermProperty === "object") {
      this.blankNodeTermProperty = purify.Maybe.of(
        parameters?.blankNodeTermProperty,
      );
    } else if (typeof parameters?.blankNodeTermProperty === "undefined") {
      this.blankNodeTermProperty = purify.Maybe.empty();
    } else {
      this.blankNodeTermProperty =
        parameters?.blankNodeTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.booleanTermProperty)) {
      this.booleanTermProperty = parameters?.booleanTermProperty;
    } else if (typeof parameters?.booleanTermProperty === "boolean") {
      this.booleanTermProperty = purify.Maybe.of(
        parameters?.booleanTermProperty,
      );
    } else if (typeof parameters?.booleanTermProperty === "undefined") {
      this.booleanTermProperty = purify.Maybe.empty();
    } else {
      this.booleanTermProperty =
        parameters?.booleanTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.dateTermProperty)) {
      this.dateTermProperty = parameters?.dateTermProperty;
    } else if (
      typeof parameters?.dateTermProperty === "object" &&
      parameters?.dateTermProperty instanceof Date
    ) {
      this.dateTermProperty = purify.Maybe.of(parameters?.dateTermProperty);
    } else if (typeof parameters?.dateTermProperty === "undefined") {
      this.dateTermProperty = purify.Maybe.empty();
    } else {
      this.dateTermProperty = parameters?.dateTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.dateTimeTermProperty)) {
      this.dateTimeTermProperty = parameters?.dateTimeTermProperty;
    } else if (
      typeof parameters?.dateTimeTermProperty === "object" &&
      parameters?.dateTimeTermProperty instanceof Date
    ) {
      this.dateTimeTermProperty = purify.Maybe.of(
        parameters?.dateTimeTermProperty,
      );
    } else if (typeof parameters?.dateTimeTermProperty === "undefined") {
      this.dateTimeTermProperty = purify.Maybe.empty();
    } else {
      this.dateTimeTermProperty =
        parameters?.dateTimeTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.iriTermProperty)) {
      this.iriTermProperty = parameters?.iriTermProperty;
    } else if (typeof parameters?.iriTermProperty === "object") {
      this.iriTermProperty = purify.Maybe.of(parameters?.iriTermProperty);
    } else if (typeof parameters?.iriTermProperty === "string") {
      this.iriTermProperty = purify.Maybe.of(
        dataFactory.namedNode(parameters?.iriTermProperty),
      );
    } else if (typeof parameters?.iriTermProperty === "undefined") {
      this.iriTermProperty = purify.Maybe.empty();
    } else {
      this.iriTermProperty = parameters?.iriTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.literalTermProperty)) {
      this.literalTermProperty = parameters?.literalTermProperty;
    } else if (typeof parameters?.literalTermProperty === "boolean") {
      this.literalTermProperty = purify.Maybe.of(
        $toLiteral(parameters?.literalTermProperty),
      );
    } else if (
      typeof parameters?.literalTermProperty === "object" &&
      parameters?.literalTermProperty instanceof Date
    ) {
      this.literalTermProperty = purify.Maybe.of(
        $toLiteral(parameters?.literalTermProperty),
      );
    } else if (typeof parameters?.literalTermProperty === "number") {
      this.literalTermProperty = purify.Maybe.of(
        $toLiteral(parameters?.literalTermProperty),
      );
    } else if (typeof parameters?.literalTermProperty === "string") {
      this.literalTermProperty = purify.Maybe.of(
        $toLiteral(parameters?.literalTermProperty),
      );
    } else if (typeof parameters?.literalTermProperty === "object") {
      this.literalTermProperty = purify.Maybe.of(
        parameters?.literalTermProperty,
      );
    } else if (typeof parameters?.literalTermProperty === "undefined") {
      this.literalTermProperty = purify.Maybe.empty();
    } else {
      this.literalTermProperty =
        parameters?.literalTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.numberTermProperty)) {
      this.numberTermProperty = parameters?.numberTermProperty;
    } else if (typeof parameters?.numberTermProperty === "number") {
      this.numberTermProperty = purify.Maybe.of(parameters?.numberTermProperty);
    } else if (typeof parameters?.numberTermProperty === "undefined") {
      this.numberTermProperty = purify.Maybe.empty();
    } else {
      this.numberTermProperty = parameters?.numberTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.stringTermProperty)) {
      this.stringTermProperty = parameters?.stringTermProperty;
    } else if (typeof parameters?.stringTermProperty === "string") {
      this.stringTermProperty = purify.Maybe.of(parameters?.stringTermProperty);
    } else if (typeof parameters?.stringTermProperty === "undefined") {
      this.stringTermProperty = purify.Maybe.empty();
    } else {
      this.stringTermProperty = parameters?.stringTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.termProperty)) {
      this.termProperty = parameters?.termProperty;
    } else if (typeof parameters?.termProperty === "boolean") {
      this.termProperty = purify.Maybe.of($toLiteral(parameters?.termProperty));
    } else if (
      typeof parameters?.termProperty === "object" &&
      parameters?.termProperty instanceof Date
    ) {
      this.termProperty = purify.Maybe.of($toLiteral(parameters?.termProperty));
    } else if (typeof parameters?.termProperty === "number") {
      this.termProperty = purify.Maybe.of($toLiteral(parameters?.termProperty));
    } else if (typeof parameters?.termProperty === "string") {
      this.termProperty = purify.Maybe.of($toLiteral(parameters?.termProperty));
    } else if (typeof parameters?.termProperty === "object") {
      this.termProperty = purify.Maybe.of(parameters?.termProperty);
    } else if (typeof parameters?.termProperty === "undefined") {
      this.termProperty = purify.Maybe.empty();
    } else {
      this.termProperty = parameters?.termProperty satisfies never;
    }
  }

  get $identifier(): TermPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: TermPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.blankNodeTermProperty,
          other.blankNodeTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "blankNodeTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.booleanTermProperty,
          other.booleanTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "booleanTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.dateTermProperty,
          other.dateTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "dateTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.dateTimeTermProperty,
          other.dateTimeTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "dateTimeTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.iriTermProperty,
          other.iriTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "iriTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.literalTermProperty,
          other.literalTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "literalTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.numberTermProperty,
          other.numberTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "numberTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.stringTermProperty,
          other.stringTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "stringTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.termProperty,
          other.termProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "termProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.blankNodeTermProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    this.booleanTermProperty.ifJust((value0) => {
      _hasher.update(value0.toString());
    });
    this.dateTermProperty.ifJust((value0) => {
      _hasher.update(value0.toISOString());
    });
    this.dateTimeTermProperty.ifJust((value0) => {
      _hasher.update(value0.toISOString());
    });
    this.iriTermProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    this.literalTermProperty.ifJust((value0) => {
      _hasher.update(value0.datatype.value);
      _hasher.update(value0.language);
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    this.numberTermProperty.ifJust((value0) => {
      _hasher.update(value0.toString());
    });
    this.stringTermProperty.ifJust((value0) => {
      _hasher.update(value0);
    });
    this.termProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    return _hasher;
  }

  $toJson(): TermPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        blankNodeTermProperty: this.blankNodeTermProperty
          .map((item) => ({ "@id": `_:${item.value}` }))
          .extract(),
        booleanTermProperty: this.booleanTermProperty
          .map((item) => item)
          .extract(),
        dateTermProperty: this.dateTermProperty
          .map((item) => item.toISOString().replace(/T.*$/, ""))
          .extract(),
        dateTimeTermProperty: this.dateTimeTermProperty
          .map((item) => item.toISOString())
          .extract(),
        iriTermProperty: this.iriTermProperty
          .map((item) => ({ "@id": item.value }))
          .extract(),
        literalTermProperty: this.literalTermProperty
          .map((item) => ({
            "@language": item.language.length > 0 ? item.language : undefined,
            "@type":
              item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? item.datatype.value
                : undefined,
            "@value": item.value,
          }))
          .extract(),
        numberTermProperty: this.numberTermProperty
          .map((item) => item)
          .extract(),
        stringTermProperty: this.stringTermProperty
          .map((item) => item)
          .extract(),
        termProperty: this.termProperty
          .map((item) =>
            item.termType === "NamedNode"
              ? { "@id": item.value, termType: "NamedNode" as const }
              : item.termType === "Literal"
                ? {
                    "@language":
                      item.language.length > 0 ? item.language : undefined,
                    "@type":
                      item.datatype.value !==
                      "http://www.w3.org/2001/XMLSchema#string"
                        ? item.datatype.value
                        : undefined,
                    "@value": item.value,
                    termType: "Literal" as const,
                  }
                : { "@id": `_:${item.value}`, termType: "BlankNode" as const },
          )
          .extract(),
      } satisfies TermPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      TermPropertiesClass.$properties.blankNodeTermProperty["identifier"],
      ...this.blankNodeTermProperty.toList(),
    );
    resource.add(
      TermPropertiesClass.$properties.booleanTermProperty["identifier"],
      ...this.booleanTermProperty.toList(),
    );
    resource.add(
      TermPropertiesClass.$properties.dateTermProperty["identifier"],
      ...this.dateTermProperty
        .toList()
        .flatMap((value) => [
          dataFactory.literal(
            value.toISOString().replace(/T.*$/, ""),
            $RdfVocabularies.xsd.date,
          ),
        ]),
    );
    resource.add(
      TermPropertiesClass.$properties.dateTimeTermProperty["identifier"],
      ...this.dateTimeTermProperty
        .toList()
        .flatMap((value) => [
          dataFactory.literal(
            value.toISOString(),
            $RdfVocabularies.xsd.dateTime,
          ),
        ]),
    );
    resource.add(
      TermPropertiesClass.$properties.iriTermProperty["identifier"],
      ...this.iriTermProperty.toList(),
    );
    resource.add(
      TermPropertiesClass.$properties.literalTermProperty["identifier"],
      ...this.literalTermProperty.toList(),
    );
    resource.add(
      TermPropertiesClass.$properties.numberTermProperty["identifier"],
      ...this.numberTermProperty
        .toList()
        .flatMap((value) => [
          dataFactory.literal(value.toString(10), $RdfVocabularies.xsd.decimal),
        ]),
    );
    resource.add(
      TermPropertiesClass.$properties.stringTermProperty["identifier"],
      ...this.stringTermProperty.toList(),
    );
    resource.add(
      TermPropertiesClass.$properties.termProperty["identifier"],
      ...this.termProperty.toList(),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace TermPropertiesClass {
  export function $filter(
    filter: TermPropertiesClass.$Filter,
    value: TermPropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.blankNodeTermProperty !== "undefined" &&
      !$filterMaybe<rdfjs.BlankNode, $BlankNodeFilter>($filterBlankNode)(
        filter.blankNodeTermProperty,
        value.blankNodeTermProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.booleanTermProperty !== "undefined" &&
      !$filterMaybe<boolean, $BooleanFilter>($filterBoolean)(
        filter.booleanTermProperty,
        value.booleanTermProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.dateTermProperty !== "undefined" &&
      !$filterMaybe<Date, $DateFilter>($filterDate)(
        filter.dateTermProperty,
        value.dateTermProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.dateTimeTermProperty !== "undefined" &&
      !$filterMaybe<Date, $DateFilter>($filterDate)(
        filter.dateTimeTermProperty,
        value.dateTimeTermProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.iriTermProperty !== "undefined" &&
      !$filterMaybe<rdfjs.NamedNode, $NamedNodeFilter>($filterNamedNode)(
        filter.iriTermProperty,
        value.iriTermProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.literalTermProperty !== "undefined" &&
      !$filterMaybe<rdfjs.Literal, $LiteralFilter>($filterLiteral)(
        filter.literalTermProperty,
        value.literalTermProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.numberTermProperty !== "undefined" &&
      !$filterMaybe<number, $NumberFilter>($filterNumber)(
        filter.numberTermProperty,
        value.numberTermProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.stringTermProperty !== "undefined" &&
      !$filterMaybe<string, $StringFilter>($filterString)(
        filter.stringTermProperty,
        value.stringTermProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.termProperty !== "undefined" &&
      !$filterMaybe<
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode,
        $TermFilter
      >($filterTerm)(filter.termProperty, value.termProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly blankNodeTermProperty?: $MaybeFilter<$BlankNodeFilter>;
    readonly booleanTermProperty?: $MaybeFilter<$BooleanFilter>;
    readonly dateTermProperty?: $MaybeFilter<$DateFilter>;
    readonly dateTimeTermProperty?: $MaybeFilter<$DateFilter>;
    readonly iriTermProperty?: $MaybeFilter<$NamedNodeFilter>;
    readonly literalTermProperty?: $MaybeFilter<$LiteralFilter>;
    readonly numberTermProperty?: $MaybeFilter<$NumberFilter>;
    readonly stringTermProperty?: $MaybeFilter<$StringFilter>;
    readonly termProperty?: $MaybeFilter<$TermFilter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, TermPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new TermPropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, TermPropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return TermPropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new TermPropertiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "TermPropertiesClass";
    readonly blankNodeTermProperty?: { readonly "@id": string };
    readonly booleanTermProperty?: boolean;
    readonly dateTermProperty?: string;
    readonly dateTimeTermProperty?: string;
    readonly iriTermProperty?: { readonly "@id": string };
    readonly literalTermProperty?: {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    };
    readonly numberTermProperty?: number;
    readonly stringTermProperty?: string;
    readonly termProperty?:
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly "@type"?: string;
          readonly "@value": string;
          readonly termType: "Literal";
        };
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "TermPropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/blankNodeTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/booleanTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateTimeTermProperty`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/iriTermProperty`, type: "Control" },
        {
          scope: `${scopePrefix}/properties/literalTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/numberTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/stringTermProperty`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/termProperty`, type: "Control" },
      ],
      label: "TermPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("TermPropertiesClass"),
      blankNodeTermProperty: zod
        .object({ "@id": zod.string().min(1) })
        .optional(),
      booleanTermProperty: zod.boolean().optional(),
      dateTermProperty: zod.iso.date().optional(),
      dateTimeTermProperty: zod.iso.datetime().optional(),
      iriTermProperty: zod.object({ "@id": zod.string().min(1) }).optional(),
      literalTermProperty: zod
        .object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
        })
        .optional(),
      numberTermProperty: zod.number().optional(),
      stringTermProperty: zod.string().optional(),
      termProperty: zod
        .discriminatedUnion("termType", [
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("BlankNode"),
          }),
          zod.object({
            "@language": zod.string().optional(),
            "@type": zod.string().optional(),
            "@value": zod.string(),
            termType: zod.literal("Literal"),
          }),
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("NamedNode"),
          }),
        ])
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    blankNodeTermProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/blankNodeTermProperty",
      ),
    },
    booleanTermProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/booleanTermProperty",
      ),
    },
    dateTermProperty: {
      identifier: dataFactory.namedNode("http://example.com/dateTermProperty"),
    },
    dateTimeTermProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/dateTimeTermProperty",
      ),
    },
    iriTermProperty: {
      identifier: dataFactory.namedNode("http://example.com/iriTermProperty"),
    },
    literalTermProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/literalTermProperty",
      ),
    },
    numberTermProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/numberTermProperty",
      ),
    },
    stringTermProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/stringTermProperty",
      ),
    },
    termProperty: {
      identifier: dataFactory.namedNode("http://example.com/termProperty"),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      blankNodeTermProperty: purify.Maybe<rdfjs.BlankNode>;
      booleanTermProperty: purify.Maybe<boolean>;
      dateTermProperty: purify.Maybe<Date>;
      dateTimeTermProperty: purify.Maybe<Date>;
      iriTermProperty: purify.Maybe<rdfjs.NamedNode>;
      literalTermProperty: purify.Maybe<rdfjs.Literal>;
      numberTermProperty: purify.Maybe<number>;
      stringTermProperty: purify.Maybe<string>;
      termProperty: purify.Maybe<
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
      >;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const blankNodeTermProperty = purify.Maybe.fromNullable(
      $jsonObject["blankNodeTermProperty"],
    ).map((item) => dataFactory.blankNode(item["@id"].substring(2)));
    const booleanTermProperty = purify.Maybe.fromNullable(
      $jsonObject["booleanTermProperty"],
    );
    const dateTermProperty = purify.Maybe.fromNullable(
      $jsonObject["dateTermProperty"],
    ).map((item) => new Date(item));
    const dateTimeTermProperty = purify.Maybe.fromNullable(
      $jsonObject["dateTimeTermProperty"],
    ).map((item) => new Date(item));
    const iriTermProperty = purify.Maybe.fromNullable(
      $jsonObject["iriTermProperty"],
    ).map((item) => dataFactory.namedNode(item["@id"]));
    const literalTermProperty = purify.Maybe.fromNullable(
      $jsonObject["literalTermProperty"],
    ).map((item) =>
      dataFactory.literal(
        item["@value"],
        typeof item["@language"] !== "undefined"
          ? item["@language"]
          : typeof item["@type"] !== "undefined"
            ? dataFactory.namedNode(item["@type"])
            : undefined,
      ),
    );
    const numberTermProperty = purify.Maybe.fromNullable(
      $jsonObject["numberTermProperty"],
    );
    const stringTermProperty = purify.Maybe.fromNullable(
      $jsonObject["stringTermProperty"],
    );
    const termProperty = purify.Maybe.fromNullable(
      $jsonObject["termProperty"],
    ).map((item) =>
      item.termType === "NamedNode"
        ? dataFactory.namedNode(item["@id"])
        : item.termType === "Literal"
          ? dataFactory.literal(
              item["@value"],
              typeof item["@language"] !== "undefined"
                ? item["@language"]
                : typeof item["@type"] !== "undefined"
                  ? dataFactory.namedNode(item["@type"])
                  : undefined,
            )
          : dataFactory.blankNode(item["@id"].substring(2)),
    );
    return purify.Either.of({
      $identifier,
      blankNodeTermProperty,
      booleanTermProperty,
      dateTermProperty,
      dateTimeTermProperty,
      iriTermProperty,
      literalTermProperty,
      numberTermProperty,
      stringTermProperty,
      termProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      blankNodeTermProperty: purify.Maybe<rdfjs.BlankNode>;
      booleanTermProperty: purify.Maybe<boolean>;
      dateTermProperty: purify.Maybe<Date>;
      dateTimeTermProperty: purify.Maybe<Date>;
      iriTermProperty: purify.Maybe<rdfjs.NamedNode>;
      literalTermProperty: purify.Maybe<rdfjs.Literal>;
      numberTermProperty: purify.Maybe<number>;
      stringTermProperty: purify.Maybe<string>;
      termProperty: purify.Maybe<
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
      >;
    }
  > {
    return purify.Either.of<Error, TermPropertiesClass.$Identifier>(
      $parameters.resource.identifier as TermPropertiesClass.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.blankNodeTermProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => values.chainMap((value) => value.toBlankNode()))
        .map((values) =>
          values.length > 0
            ? values.map((value) => purify.Maybe.of(value))
            : rdfjsResource.Resource.Values.fromValue<
                purify.Maybe<rdfjs.BlankNode>
              >({
                focusResource: $parameters.resource,
                predicate:
                  TermPropertiesClass.$properties.blankNodeTermProperty[
                    "identifier"
                  ],
                value: purify.Maybe.empty(),
              }),
        )
        .chain((values) => values.head())
        .chain((blankNodeTermProperty) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.booleanTermProperty["identifier"],
              { unique: true },
            ),
          )
            .chain((values) => values.chainMap((value) => value.toBoolean()))
            .map((values) =>
              values.length > 0
                ? values.map((value) => purify.Maybe.of(value))
                : rdfjsResource.Resource.Values.fromValue<
                    purify.Maybe<boolean>
                  >({
                    focusResource: $parameters.resource,
                    predicate:
                      TermPropertiesClass.$properties.booleanTermProperty[
                        "identifier"
                      ],
                    value: purify.Maybe.empty(),
                  }),
            )
            .chain((values) => values.head())
            .chain((booleanTermProperty) =>
              purify.Either.of<
                Error,
                rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
              >(
                $parameters.resource.values(
                  $properties.dateTermProperty["identifier"],
                  { unique: true },
                ),
              )
                .chain((values) => values.chainMap((value) => value.toDate()))
                .map((values) =>
                  values.length > 0
                    ? values.map((value) => purify.Maybe.of(value))
                    : rdfjsResource.Resource.Values.fromValue<
                        purify.Maybe<Date>
                      >({
                        focusResource: $parameters.resource,
                        predicate:
                          TermPropertiesClass.$properties.dateTermProperty[
                            "identifier"
                          ],
                        value: purify.Maybe.empty(),
                      }),
                )
                .chain((values) => values.head())
                .chain((dateTermProperty) =>
                  purify.Either.of<
                    Error,
                    rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                  >(
                    $parameters.resource.values(
                      $properties.dateTimeTermProperty["identifier"],
                      { unique: true },
                    ),
                  )
                    .chain((values) =>
                      values.chainMap((value) => value.toDate()),
                    )
                    .map((values) =>
                      values.length > 0
                        ? values.map((value) => purify.Maybe.of(value))
                        : rdfjsResource.Resource.Values.fromValue<
                            purify.Maybe<Date>
                          >({
                            focusResource: $parameters.resource,
                            predicate:
                              TermPropertiesClass.$properties
                                .dateTimeTermProperty["identifier"],
                            value: purify.Maybe.empty(),
                          }),
                    )
                    .chain((values) => values.head())
                    .chain((dateTimeTermProperty) =>
                      purify.Either.of<
                        Error,
                        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                      >(
                        $parameters.resource.values(
                          $properties.iriTermProperty["identifier"],
                          { unique: true },
                        ),
                      )
                        .chain((values) =>
                          values.chainMap((value) => value.toIri()),
                        )
                        .map((values) =>
                          values.length > 0
                            ? values.map((value) => purify.Maybe.of(value))
                            : rdfjsResource.Resource.Values.fromValue<
                                purify.Maybe<rdfjs.NamedNode>
                              >({
                                focusResource: $parameters.resource,
                                predicate:
                                  TermPropertiesClass.$properties
                                    .iriTermProperty["identifier"],
                                value: purify.Maybe.empty(),
                              }),
                        )
                        .chain((values) => values.head())
                        .chain((iriTermProperty) =>
                          purify.Either.of<
                            Error,
                            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                          >(
                            $parameters.resource.values(
                              $properties.literalTermProperty["identifier"],
                              { unique: true },
                            ),
                          )
                            .chain((values) =>
                              $fromRdfPreferredLanguages({
                                focusResource: $parameters.resource,
                                predicate:
                                  TermPropertiesClass.$properties
                                    .literalTermProperty["identifier"],
                                preferredLanguages:
                                  $parameters.preferredLanguages,
                                values,
                              }),
                            )
                            .chain((values) =>
                              values.chainMap((value) => value.toLiteral()),
                            )
                            .map((values) =>
                              values.length > 0
                                ? values.map((value) => purify.Maybe.of(value))
                                : rdfjsResource.Resource.Values.fromValue<
                                    purify.Maybe<rdfjs.Literal>
                                  >({
                                    focusResource: $parameters.resource,
                                    predicate:
                                      TermPropertiesClass.$properties
                                        .literalTermProperty["identifier"],
                                    value: purify.Maybe.empty(),
                                  }),
                            )
                            .chain((values) => values.head())
                            .chain((literalTermProperty) =>
                              purify.Either.of<
                                Error,
                                rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                              >(
                                $parameters.resource.values(
                                  $properties.numberTermProperty["identifier"],
                                  { unique: true },
                                ),
                              )
                                .chain((values) =>
                                  values.chainMap((value) => value.toNumber()),
                                )
                                .map((values) =>
                                  values.length > 0
                                    ? values.map((value) =>
                                        purify.Maybe.of(value),
                                      )
                                    : rdfjsResource.Resource.Values.fromValue<
                                        purify.Maybe<number>
                                      >({
                                        focusResource: $parameters.resource,
                                        predicate:
                                          TermPropertiesClass.$properties
                                            .numberTermProperty["identifier"],
                                        value: purify.Maybe.empty(),
                                      }),
                                )
                                .chain((values) => values.head())
                                .chain((numberTermProperty) =>
                                  purify.Either.of<
                                    Error,
                                    rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                                  >(
                                    $parameters.resource.values(
                                      $properties.stringTermProperty[
                                        "identifier"
                                      ],
                                      { unique: true },
                                    ),
                                  )
                                    .chain((values) =>
                                      $fromRdfPreferredLanguages({
                                        focusResource: $parameters.resource,
                                        predicate:
                                          TermPropertiesClass.$properties
                                            .stringTermProperty["identifier"],
                                        preferredLanguages:
                                          $parameters.preferredLanguages,
                                        values,
                                      }),
                                    )
                                    .chain((values) =>
                                      values.chainMap((value) =>
                                        value.toString(),
                                      ),
                                    )
                                    .map((values) =>
                                      values.length > 0
                                        ? values.map((value) =>
                                            purify.Maybe.of(value),
                                          )
                                        : rdfjsResource.Resource.Values.fromValue<
                                            purify.Maybe<string>
                                          >({
                                            focusResource: $parameters.resource,
                                            predicate:
                                              TermPropertiesClass.$properties
                                                .stringTermProperty[
                                                "identifier"
                                              ],
                                            value: purify.Maybe.empty(),
                                          }),
                                    )
                                    .chain((values) => values.head())
                                    .chain((stringTermProperty) =>
                                      purify.Either.of<
                                        Error,
                                        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                                      >(
                                        $parameters.resource.values(
                                          $properties.termProperty[
                                            "identifier"
                                          ],
                                          { unique: true },
                                        ),
                                      )
                                        .chain((values) =>
                                          values.chainMap((value) =>
                                            purify.Either.of<
                                              Error,
                                              | rdfjs.BlankNode
                                              | rdfjs.Literal
                                              | rdfjs.NamedNode
                                            >(value.toTerm()),
                                          ),
                                        )
                                        .map((values) =>
                                          values.length > 0
                                            ? values.map((value) =>
                                                purify.Maybe.of(value),
                                              )
                                            : rdfjsResource.Resource.Values.fromValue<
                                                purify.Maybe<
                                                  | rdfjs.BlankNode
                                                  | rdfjs.Literal
                                                  | rdfjs.NamedNode
                                                >
                                              >({
                                                focusResource:
                                                  $parameters.resource,
                                                predicate:
                                                  TermPropertiesClass
                                                    .$properties.termProperty[
                                                    "identifier"
                                                  ],
                                                value: purify.Maybe.empty(),
                                              }),
                                        )
                                        .chain((values) => values.head())
                                        .map((termProperty) => ({
                                          $identifier,
                                          blankNodeTermProperty,
                                          booleanTermProperty,
                                          dateTermProperty,
                                          dateTimeTermProperty,
                                          iriTermProperty,
                                          literalTermProperty,
                                          numberTermProperty,
                                          stringTermProperty,
                                          termProperty,
                                        })),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: TermPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        TermPropertiesClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            TermPropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: TermPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      TermPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("termPropertiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}BlankNodeTermProperty`,
      ),
      predicate:
        TermPropertiesClass.$properties.blankNodeTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}BooleanTermProperty`,
      ),
      predicate:
        TermPropertiesClass.$properties.booleanTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}DateTermProperty`,
      ),
      predicate: TermPropertiesClass.$properties.dateTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}DateTimeTermProperty`,
      ),
      predicate:
        TermPropertiesClass.$properties.dateTimeTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}IriTermProperty`,
      ),
      predicate: TermPropertiesClass.$properties.iriTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}LiteralTermProperty`,
      ),
      predicate:
        TermPropertiesClass.$properties.literalTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}NumberTermProperty`,
      ),
      predicate:
        TermPropertiesClass.$properties.numberTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}StringTermProperty`,
      ),
      predicate:
        TermPropertiesClass.$properties.stringTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}TermProperty`,
      ),
      predicate: TermPropertiesClass.$properties.termProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: TermPropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("termPropertiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.blankNodeTermProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}BlankNodeTermProperty`,
                  ),
                  predicate:
                    TermPropertiesClass.$properties.blankNodeTermProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $BlankNodeFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}BlankNodeTermProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.booleanTermProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}BooleanTermProperty`,
                  ),
                  predicate:
                    TermPropertiesClass.$properties.booleanTermProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $BooleanFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}BooleanTermProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.dateTermProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}DateTermProperty`,
                  ),
                  predicate:
                    TermPropertiesClass.$properties.dateTermProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $DateFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}DateTermProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.dateTimeTermProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}DateTimeTermProperty`,
                  ),
                  predicate:
                    TermPropertiesClass.$properties.dateTimeTermProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $DateFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}DateTimeTermProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.iriTermProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}IriTermProperty`,
                  ),
                  predicate:
                    TermPropertiesClass.$properties.iriTermProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $NamedNodeFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}IriTermProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.literalTermProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}LiteralTermProperty`,
                  ),
                  predicate:
                    TermPropertiesClass.$properties.literalTermProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [parameters?.preferredLanguages ?? []]
                .filter((languages) => languages.length > 0)
                .map((languages) =>
                  languages.map((language) => ({
                    type: "operation" as const,
                    operator: "=",
                    args: [
                      {
                        type: "operation" as const,
                        operator: "lang",
                        args: [
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}LiteralTermProperty`,
                          ),
                        ],
                      },
                      dataFactory.literal(language),
                    ],
                  })),
                )
                .map((langEqualsExpressions) => ({
                  type: "filter" as const,
                  expression: langEqualsExpressions.reduce(
                    (reducedExpression, langEqualsExpression) => {
                      if (reducedExpression === null) {
                        return langEqualsExpression;
                      }
                      return {
                        type: "operation" as const,
                        operator: "||",
                        args: [reducedExpression, langEqualsExpression],
                      };
                    },
                    null as sparqljs.Expression | null,
                  ) as sparqljs.Expression,
                }))
                .concat(),
              type: "group",
            },
            {
              patterns: $LiteralFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}LiteralTermProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.numberTermProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}NumberTermProperty`,
                  ),
                  predicate:
                    TermPropertiesClass.$properties.numberTermProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $NumberFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}NumberTermProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.stringTermProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}StringTermProperty`,
                  ),
                  predicate:
                    TermPropertiesClass.$properties.stringTermProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [parameters?.preferredLanguages ?? []]
                .filter((languages) => languages.length > 0)
                .map((languages) =>
                  languages.map((language) => ({
                    type: "operation" as const,
                    operator: "=",
                    args: [
                      {
                        type: "operation" as const,
                        operator: "lang",
                        args: [
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}StringTermProperty`,
                          ),
                        ],
                      },
                      dataFactory.literal(language),
                    ],
                  })),
                )
                .map((langEqualsExpressions) => ({
                  type: "filter" as const,
                  expression: langEqualsExpressions.reduce(
                    (reducedExpression, langEqualsExpression) => {
                      if (reducedExpression === null) {
                        return langEqualsExpression;
                      }
                      return {
                        type: "operation" as const,
                        operator: "||",
                        args: [reducedExpression, langEqualsExpression],
                      };
                    },
                    null as sparqljs.Expression | null,
                  ) as sparqljs.Expression,
                }))
                .concat(),
              type: "group",
            },
            {
              patterns: $StringFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}StringTermProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.termProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}TermProperty`,
                  ),
                  predicate:
                    TermPropertiesClass.$properties.termProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $TermFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}TermProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    return patterns;
  }

  export function isTermPropertiesClass(
    object: $Object,
  ): object is TermPropertiesClass {
    switch (object.$type) {
      case "TermPropertiesClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * A node shape that mints its identifier by hashing (other) contents, if no identifier is supplied.
 */
export class Sha256IriIdentifierClass {
  private _$identifier?: Sha256IriIdentifierClass.$Identifier;
  protected readonly _$identifierPrefix?: string;
  readonly $type = "Sha256IriIdentifierClass";
  readonly sha256IriProperty: string;

  constructor(parameters: {
    readonly $identifier?: rdfjs.NamedNode | string;
    readonly $identifierPrefix?: string;
    readonly sha256IriProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this._$identifierPrefix = parameters.$identifierPrefix;
    this.sha256IriProperty = parameters.sha256IriProperty;
  }

  get $identifier(): Sha256IriIdentifierClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }

    if (this._$identifier.termType !== "NamedNode") {
      throw new Error(
        `expected identifier to be NamedNode, not ${this._$identifier.termType}`,
      );
    }

    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  $equals(other: Sha256IriIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$identifierPrefix, other.$identifierPrefix).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$identifierPrefix",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.sha256IriProperty, other.sha256IriProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "sha256IriProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.sha256IriProperty);
    return _hasher;
  }

  $toJson(): Sha256IriIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
        sha256IriProperty: this.sha256IriProperty,
      } satisfies Sha256IriIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      Sha256IriIdentifierClass.$properties.sha256IriProperty["identifier"],
      ...[this.sha256IriProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace Sha256IriIdentifierClass {
  export function $filter(
    filter: Sha256IriIdentifierClass.$Filter,
    value: Sha256IriIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.sha256IriProperty !== "undefined" &&
      !$filterString(filter.sha256IriProperty, value.sha256IriProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
    readonly sha256IriProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Sha256IriIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new Sha256IriIdentifierClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, Sha256IriIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return Sha256IriIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new Sha256IriIdentifierClass(properties));
  }

  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "Sha256IriIdentifierClass";
    readonly sha256IriProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "Sha256IriIdentifierClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/sha256IriProperty`,
          type: "Control",
        },
      ],
      label: "Sha256IriIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("Sha256IriIdentifierClass"),
      sha256IriProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    sha256IriProperty: {
      identifier: dataFactory.namedNode("http://example.com/sha256IriProperty"),
    },
  };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.NamedNode; sha256IriProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const sha256IriProperty = $jsonObject["sha256IriProperty"];
    return purify.Either.of({ $identifier, sha256IriProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.NamedNode; sha256IriProperty: string }
  > {
    return (
      $parameters.resource.identifier.termType === "NamedNode"
        ? purify.Either.of<Error, Sha256IriIdentifierClass.$Identifier>(
            $parameters.resource.identifier,
          )
        : purify.Left(
            new rdfjsResource.Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "(rdfjs.NamedNode)",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.sha256IriProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              Sha256IriIdentifierClass.$properties.sha256IriProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((sha256IriProperty) => ({ $identifier, sha256IriProperty })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: Sha256IriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Sha256IriIdentifierClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            Sha256IriIdentifierClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: Sha256IriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Sha256IriIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("sha256IriIdentifierClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "sha256IriIdentifierClass")}Sha256IriProperty`,
      ),
      predicate:
        Sha256IriIdentifierClass.$properties.sha256IriProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: Sha256IriIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("sha256IriIdentifierClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "sha256IriIdentifierClass")}Sha256IriProperty`,
            ),
            predicate:
              Sha256IriIdentifierClass.$properties.sha256IriProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "sha256IriIdentifierClass")}Sha256IriProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.sha256IriProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "sha256IriIdentifierClass")}Sha256IriProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isSha256IriIdentifierClass(
    object: $Object,
  ): object is Sha256IriIdentifierClass {
    switch (object.$type) {
      case "Sha256IriIdentifierClass":
        return true;
      default:
        return false;
    }
  }
}
export class RecursiveClassUnionMember2 {
  private _$identifier?: RecursiveClassUnionMember2.$Identifier;
  readonly $type = "RecursiveClassUnionMember2";
  readonly recursiveClassUnionMember2Property: purify.Maybe<RecursiveClassUnion>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly recursiveClassUnionMember2Property?:
      | RecursiveClassUnion
      | purify.Maybe<RecursiveClassUnion>;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.recursiveClassUnionMember2Property)) {
      this.recursiveClassUnionMember2Property =
        parameters?.recursiveClassUnionMember2Property;
    } else if (
      typeof parameters?.recursiveClassUnionMember2Property === "object"
    ) {
      this.recursiveClassUnionMember2Property = purify.Maybe.of(
        parameters?.recursiveClassUnionMember2Property,
      );
    } else if (
      typeof parameters?.recursiveClassUnionMember2Property === "undefined"
    ) {
      this.recursiveClassUnionMember2Property = purify.Maybe.empty();
    } else {
      this.recursiveClassUnionMember2Property =
        parameters?.recursiveClassUnionMember2Property satisfies never;
    }
  }

  get $identifier(): RecursiveClassUnionMember2.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: RecursiveClassUnionMember2): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, RecursiveClassUnion.$equals))(
          this.recursiveClassUnionMember2Property,
          other.recursiveClassUnionMember2Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "recursiveClassUnionMember2Property",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.recursiveClassUnionMember2Property.ifJust((value0) => {
      RecursiveClassUnion.$hash(value0, _hasher);
    });
    return _hasher;
  }

  $toJson(): RecursiveClassUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        recursiveClassUnionMember2Property:
          this.recursiveClassUnionMember2Property
            .map((item) => RecursiveClassUnion.$toJson(item))
            .extract(),
      } satisfies RecursiveClassUnionMember2.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      RecursiveClassUnionMember2.$properties.recursiveClassUnionMember2Property[
        "identifier"
      ],
      ...this.recursiveClassUnionMember2Property
        .toList()
        .flatMap((value) => [
          RecursiveClassUnion.$toRdf(value, { mutateGraph, resourceSet })
            .identifier,
        ]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace RecursiveClassUnionMember2 {
  export function $filter(
    filter: RecursiveClassUnionMember2.$Filter,
    value: RecursiveClassUnionMember2,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.recursiveClassUnionMember2Property !== "undefined" &&
      !$filterMaybe<RecursiveClassUnion, RecursiveClassUnion.$Filter>(
        RecursiveClassUnion.$filter,
      )(
        filter.recursiveClassUnionMember2Property,
        value.recursiveClassUnionMember2Property,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly recursiveClassUnionMember2Property?: $MaybeFilter<RecursiveClassUnion.$Filter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, RecursiveClassUnionMember2> {
    return $propertiesFromJson(json).map(
      (properties) => new RecursiveClassUnionMember2(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, RecursiveClassUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return RecursiveClassUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new RecursiveClassUnionMember2(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "RecursiveClassUnionMember2";
    readonly recursiveClassUnionMember2Property?:
      | RecursiveClassUnionMember1.$Json
      | RecursiveClassUnionMember2.$Json;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "RecursiveClassUnionMember2" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/recursiveClassUnionMember2Property`,
          type: "Control",
        },
      ],
      label: "RecursiveClassUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("RecursiveClassUnionMember2"),
      recursiveClassUnionMember2Property: zod
        .lazy(
          (): zod.ZodType<RecursiveClassUnion.$Json> =>
            RecursiveClassUnion.$jsonZodSchema(),
        )
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    recursiveClassUnionMember2Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/recursiveClassUnionMember2Property",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      recursiveClassUnionMember2Property: purify.Maybe<RecursiveClassUnion>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const recursiveClassUnionMember2Property = purify.Maybe.fromNullable(
      $jsonObject["recursiveClassUnionMember2Property"],
    ).map((item) => RecursiveClassUnion.$fromJson(item).unsafeCoerce());
    return purify.Either.of({
      $identifier,
      recursiveClassUnionMember2Property,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      recursiveClassUnionMember2Property: purify.Maybe<RecursiveClassUnion>;
    }
  > {
    return purify.Either.of<Error, RecursiveClassUnionMember2.$Identifier>(
      $parameters.resource.identifier as RecursiveClassUnionMember2.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.recursiveClassUnionMember2Property["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          values.chainMap((value) =>
            value.toResource().chain((resource) =>
              RecursiveClassUnion.$fromRdf(resource, {
                context: $parameters.context,
                ignoreRdfType: false,
                objectSet: $parameters.objectSet,
                preferredLanguages: $parameters.preferredLanguages,
              }),
            ),
          ),
        )
        .map((values) =>
          values.length > 0
            ? values.map((value) => purify.Maybe.of(value))
            : rdfjsResource.Resource.Values.fromValue<
                purify.Maybe<RecursiveClassUnion>
              >({
                focusResource: $parameters.resource,
                predicate:
                  RecursiveClassUnionMember2.$properties
                    .recursiveClassUnionMember2Property["identifier"],
                value: purify.Maybe.empty(),
              }),
        )
        .chain((values) => values.head())
        .map((recursiveClassUnionMember2Property) => ({
          $identifier,
          recursiveClassUnionMember2Property,
        })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: RecursiveClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        RecursiveClassUnionMember2.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            RecursiveClassUnionMember2.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: RecursiveClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      RecursiveClassUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: RecursiveClassUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("recursiveClassUnionMember2");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }

  export function isRecursiveClassUnionMember2(
    object: $Object,
  ): object is RecursiveClassUnionMember2 {
    switch (object.$type) {
      case "RecursiveClassUnionMember2":
        return true;
      default:
        return false;
    }
  }
}
export class RecursiveClassUnionMember1 {
  private _$identifier?: RecursiveClassUnionMember1.$Identifier;
  readonly $type = "RecursiveClassUnionMember1";
  readonly recursiveClassUnionMember1Property: purify.Maybe<RecursiveClassUnion>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly recursiveClassUnionMember1Property?:
      | RecursiveClassUnion
      | purify.Maybe<RecursiveClassUnion>;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.recursiveClassUnionMember1Property)) {
      this.recursiveClassUnionMember1Property =
        parameters?.recursiveClassUnionMember1Property;
    } else if (
      typeof parameters?.recursiveClassUnionMember1Property === "object"
    ) {
      this.recursiveClassUnionMember1Property = purify.Maybe.of(
        parameters?.recursiveClassUnionMember1Property,
      );
    } else if (
      typeof parameters?.recursiveClassUnionMember1Property === "undefined"
    ) {
      this.recursiveClassUnionMember1Property = purify.Maybe.empty();
    } else {
      this.recursiveClassUnionMember1Property =
        parameters?.recursiveClassUnionMember1Property satisfies never;
    }
  }

  get $identifier(): RecursiveClassUnionMember1.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: RecursiveClassUnionMember1): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, RecursiveClassUnion.$equals))(
          this.recursiveClassUnionMember1Property,
          other.recursiveClassUnionMember1Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "recursiveClassUnionMember1Property",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.recursiveClassUnionMember1Property.ifJust((value0) => {
      RecursiveClassUnion.$hash(value0, _hasher);
    });
    return _hasher;
  }

  $toJson(): RecursiveClassUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        recursiveClassUnionMember1Property:
          this.recursiveClassUnionMember1Property
            .map((item) => RecursiveClassUnion.$toJson(item))
            .extract(),
      } satisfies RecursiveClassUnionMember1.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      RecursiveClassUnionMember1.$properties.recursiveClassUnionMember1Property[
        "identifier"
      ],
      ...this.recursiveClassUnionMember1Property
        .toList()
        .flatMap((value) => [
          RecursiveClassUnion.$toRdf(value, { mutateGraph, resourceSet })
            .identifier,
        ]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace RecursiveClassUnionMember1 {
  export function $filter(
    filter: RecursiveClassUnionMember1.$Filter,
    value: RecursiveClassUnionMember1,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.recursiveClassUnionMember1Property !== "undefined" &&
      !$filterMaybe<RecursiveClassUnion, RecursiveClassUnion.$Filter>(
        RecursiveClassUnion.$filter,
      )(
        filter.recursiveClassUnionMember1Property,
        value.recursiveClassUnionMember1Property,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly recursiveClassUnionMember1Property?: $MaybeFilter<RecursiveClassUnion.$Filter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, RecursiveClassUnionMember1> {
    return $propertiesFromJson(json).map(
      (properties) => new RecursiveClassUnionMember1(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, RecursiveClassUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return RecursiveClassUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new RecursiveClassUnionMember1(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "RecursiveClassUnionMember1";
    readonly recursiveClassUnionMember1Property?:
      | RecursiveClassUnionMember1.$Json
      | RecursiveClassUnionMember2.$Json;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "RecursiveClassUnionMember1" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/recursiveClassUnionMember1Property`,
          type: "Control",
        },
      ],
      label: "RecursiveClassUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("RecursiveClassUnionMember1"),
      recursiveClassUnionMember1Property: zod
        .lazy(
          (): zod.ZodType<RecursiveClassUnion.$Json> =>
            RecursiveClassUnion.$jsonZodSchema(),
        )
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    recursiveClassUnionMember1Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/recursiveClassUnionMember1Property",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      recursiveClassUnionMember1Property: purify.Maybe<RecursiveClassUnion>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const recursiveClassUnionMember1Property = purify.Maybe.fromNullable(
      $jsonObject["recursiveClassUnionMember1Property"],
    ).map((item) => RecursiveClassUnion.$fromJson(item).unsafeCoerce());
    return purify.Either.of({
      $identifier,
      recursiveClassUnionMember1Property,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      recursiveClassUnionMember1Property: purify.Maybe<RecursiveClassUnion>;
    }
  > {
    return purify.Either.of<Error, RecursiveClassUnionMember1.$Identifier>(
      $parameters.resource.identifier as RecursiveClassUnionMember1.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.recursiveClassUnionMember1Property["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          values.chainMap((value) =>
            value.toResource().chain((resource) =>
              RecursiveClassUnion.$fromRdf(resource, {
                context: $parameters.context,
                ignoreRdfType: false,
                objectSet: $parameters.objectSet,
                preferredLanguages: $parameters.preferredLanguages,
              }),
            ),
          ),
        )
        .map((values) =>
          values.length > 0
            ? values.map((value) => purify.Maybe.of(value))
            : rdfjsResource.Resource.Values.fromValue<
                purify.Maybe<RecursiveClassUnion>
              >({
                focusResource: $parameters.resource,
                predicate:
                  RecursiveClassUnionMember1.$properties
                    .recursiveClassUnionMember1Property["identifier"],
                value: purify.Maybe.empty(),
              }),
        )
        .chain((values) => values.head())
        .map((recursiveClassUnionMember1Property) => ({
          $identifier,
          recursiveClassUnionMember1Property,
        })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: RecursiveClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        RecursiveClassUnionMember1.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            RecursiveClassUnionMember1.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: RecursiveClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      RecursiveClassUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: RecursiveClassUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("recursiveClassUnionMember1");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }

  export function isRecursiveClassUnionMember1(
    object: $Object,
  ): object is RecursiveClassUnionMember1 {
    switch (object.$type) {
      case "RecursiveClassUnionMember1":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Shape with properties that have visibility modifiers (private, protected, public)
 */
export class PropertyVisibilitiesClass {
  private _$identifier?: PropertyVisibilitiesClass.$Identifier;
  readonly $type = "PropertyVisibilitiesClass";
  private readonly privateProperty: string;
  protected readonly protectedProperty: string;
  readonly publicProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly privateProperty: string;
    readonly protectedProperty: string;
    readonly publicProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.privateProperty = parameters.privateProperty;
    this.protectedProperty = parameters.protectedProperty;
    this.publicProperty = parameters.publicProperty;
  }

  get $identifier(): PropertyVisibilitiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: PropertyVisibilitiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.privateProperty, other.privateProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "privateProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.protectedProperty, other.protectedProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "protectedProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.publicProperty, other.publicProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "publicProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.privateProperty);
    _hasher.update(this.protectedProperty);
    _hasher.update(this.publicProperty);
    return _hasher;
  }

  $toJson(): PropertyVisibilitiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        privateProperty: this.privateProperty,
        protectedProperty: this.protectedProperty,
        publicProperty: this.publicProperty,
      } satisfies PropertyVisibilitiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      PropertyVisibilitiesClass.$properties.privateProperty["identifier"],
      ...[this.privateProperty],
    );
    resource.add(
      PropertyVisibilitiesClass.$properties.protectedProperty["identifier"],
      ...[this.protectedProperty],
    );
    resource.add(
      PropertyVisibilitiesClass.$properties.publicProperty["identifier"],
      ...[this.publicProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PropertyVisibilitiesClass {
  export function $filter(
    filter: PropertyVisibilitiesClass.$Filter,
    value: PropertyVisibilitiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.publicProperty !== "undefined" &&
      !$filterString(filter.publicProperty, value.publicProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly publicProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PropertyVisibilitiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new PropertyVisibilitiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PropertyVisibilitiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PropertyVisibilitiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new PropertyVisibilitiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PropertyVisibilitiesClass";
    readonly privateProperty: string;
    readonly protectedProperty: string;
    readonly publicProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PropertyVisibilitiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/privateProperty`, type: "Control" },
        {
          scope: `${scopePrefix}/properties/protectedProperty`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/publicProperty`, type: "Control" },
      ],
      label: "PropertyVisibilitiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PropertyVisibilitiesClass"),
      privateProperty: zod.string(),
      protectedProperty: zod.string(),
      publicProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    privateProperty: {
      identifier: dataFactory.namedNode("http://example.com/privateProperty"),
    },
    protectedProperty: {
      identifier: dataFactory.namedNode("http://example.com/protectedProperty"),
    },
    publicProperty: {
      identifier: dataFactory.namedNode("http://example.com/publicProperty"),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      privateProperty: string;
      protectedProperty: string;
      publicProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const privateProperty = $jsonObject["privateProperty"];
    const protectedProperty = $jsonObject["protectedProperty"];
    const publicProperty = $jsonObject["publicProperty"];
    return purify.Either.of({
      $identifier,
      privateProperty,
      protectedProperty,
      publicProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      privateProperty: string;
      protectedProperty: string;
      publicProperty: string;
    }
  > {
    return purify.Either.of<Error, PropertyVisibilitiesClass.$Identifier>(
      $parameters.resource.identifier as PropertyVisibilitiesClass.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values($properties.privateProperty["identifier"], {
          unique: true,
        }),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              PropertyVisibilitiesClass.$properties.privateProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .chain((privateProperty) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.protectedProperty["identifier"],
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  PropertyVisibilitiesClass.$properties.protectedProperty[
                    "identifier"
                  ],
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .chain((protectedProperty) =>
              purify.Either.of<
                Error,
                rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
              >(
                $parameters.resource.values(
                  $properties.publicProperty["identifier"],
                  { unique: true },
                ),
              )
                .chain((values) =>
                  $fromRdfPreferredLanguages({
                    focusResource: $parameters.resource,
                    predicate:
                      PropertyVisibilitiesClass.$properties.publicProperty[
                        "identifier"
                      ],
                    preferredLanguages: $parameters.preferredLanguages,
                    values,
                  }),
                )
                .chain((values) => values.chainMap((value) => value.toString()))
                .chain((values) => values.head())
                .map((publicProperty) => ({
                  $identifier,
                  privateProperty,
                  protectedProperty,
                  publicProperty,
                })),
            ),
        ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PropertyVisibilitiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PropertyVisibilitiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            PropertyVisibilitiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PropertyVisibilitiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PropertyVisibilitiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("propertyVisibilitiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyVisibilitiesClass")}PrivateProperty`,
      ),
      predicate:
        PropertyVisibilitiesClass.$properties.privateProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyVisibilitiesClass")}ProtectedProperty`,
      ),
      predicate:
        PropertyVisibilitiesClass.$properties.protectedProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyVisibilitiesClass")}PublicProperty`,
      ),
      predicate:
        PropertyVisibilitiesClass.$properties.publicProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PropertyVisibilitiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("propertyVisibilitiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      triples: [
        {
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyVisibilitiesClass")}PrivateProperty`,
          ),
          predicate:
            PropertyVisibilitiesClass.$properties.privateProperty["identifier"],
          subject: subject,
        },
      ],
      type: "bgp",
    });
    patterns.push({
      triples: [
        {
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyVisibilitiesClass")}ProtectedProperty`,
          ),
          predicate:
            PropertyVisibilitiesClass.$properties.protectedProperty[
              "identifier"
            ],
          subject: subject,
        },
      ],
      type: "bgp",
    });
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyVisibilitiesClass")}PublicProperty`,
            ),
            predicate:
              PropertyVisibilitiesClass.$properties.publicProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyVisibilitiesClass")}PublicProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.publicProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyVisibilitiesClass")}PublicProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isPropertyVisibilitiesClass(
    object: $Object,
  ): object is PropertyVisibilitiesClass {
    switch (object.$type) {
      case "PropertyVisibilitiesClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Shape that has properties with different cardinalities
 */
export class PropertyCardinalitiesClass {
  private _$identifier?: PropertyCardinalitiesClass.$Identifier;
  readonly $type = "PropertyCardinalitiesClass";
  /**
   * Set: minCount implicitly=0, no maxCount
   */
  readonly emptyStringSetProperty: readonly string[];
  /**
   * Set: minCount=1, no maxCount
   */
  readonly nonEmptyStringSetProperty: purify.NonEmptyList<string>;
  /**
   * Option: maxCount=1, minCount=0
   */
  readonly optionalStringProperty: purify.Maybe<string>;
  /**
   * Required: maxCount=minCount=1
   */
  readonly requiredStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly emptyStringSetProperty?: readonly string[];
    readonly nonEmptyStringSetProperty: purify.NonEmptyList<string>;
    readonly optionalStringProperty?: purify.Maybe<string> | string;
    readonly requiredStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    if (typeof parameters.emptyStringSetProperty === "undefined") {
      this.emptyStringSetProperty = [];
    } else if (typeof parameters.emptyStringSetProperty === "object") {
      this.emptyStringSetProperty = parameters.emptyStringSetProperty;
    } else {
      this.emptyStringSetProperty =
        parameters.emptyStringSetProperty satisfies never;
    }

    this.nonEmptyStringSetProperty = parameters.nonEmptyStringSetProperty;
    if (purify.Maybe.isMaybe(parameters.optionalStringProperty)) {
      this.optionalStringProperty = parameters.optionalStringProperty;
    } else if (typeof parameters.optionalStringProperty === "string") {
      this.optionalStringProperty = purify.Maybe.of(
        parameters.optionalStringProperty,
      );
    } else if (typeof parameters.optionalStringProperty === "undefined") {
      this.optionalStringProperty = purify.Maybe.empty();
    } else {
      this.optionalStringProperty =
        parameters.optionalStringProperty satisfies never;
    }

    this.requiredStringProperty = parameters.requiredStringProperty;
  }

  get $identifier(): PropertyCardinalitiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: PropertyCardinalitiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $strictEquals))(
          this.emptyStringSetProperty,
          other.emptyStringSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "emptyStringSetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $strictEquals))(
          this.nonEmptyStringSetProperty,
          other.nonEmptyStringSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "nonEmptyStringSetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.optionalStringProperty,
          other.optionalStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.requiredStringProperty,
          other.requiredStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "requiredStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    for (const item0 of this.emptyStringSetProperty) {
      _hasher.update(item0);
    }

    for (const item0 of this.nonEmptyStringSetProperty) {
      _hasher.update(item0);
    }

    this.optionalStringProperty.ifJust((value0) => {
      _hasher.update(value0);
    });
    _hasher.update(this.requiredStringProperty);
    return _hasher;
  }

  $toJson(): PropertyCardinalitiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        emptyStringSetProperty: this.emptyStringSetProperty.map((item) => item),
        nonEmptyStringSetProperty: this.nonEmptyStringSetProperty.map(
          (item) => item,
        ),
        optionalStringProperty: this.optionalStringProperty
          .map((item) => item)
          .extract(),
        requiredStringProperty: this.requiredStringProperty,
      } satisfies PropertyCardinalitiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      PropertyCardinalitiesClass.$properties.emptyStringSetProperty[
        "identifier"
      ],
      ...this.emptyStringSetProperty.flatMap((item) => [item]),
    );
    resource.add(
      PropertyCardinalitiesClass.$properties.nonEmptyStringSetProperty[
        "identifier"
      ],
      ...this.nonEmptyStringSetProperty.flatMap((item) => [item]),
    );
    resource.add(
      PropertyCardinalitiesClass.$properties.optionalStringProperty[
        "identifier"
      ],
      ...this.optionalStringProperty.toList(),
    );
    resource.add(
      PropertyCardinalitiesClass.$properties.requiredStringProperty[
        "identifier"
      ],
      ...[this.requiredStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PropertyCardinalitiesClass {
  export function $filter(
    filter: PropertyCardinalitiesClass.$Filter,
    value: PropertyCardinalitiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.emptyStringSetProperty !== "undefined" &&
      !$filterArray<string, $StringFilter>($filterString)(
        filter.emptyStringSetProperty,
        value.emptyStringSetProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.nonEmptyStringSetProperty !== "undefined" &&
      !$filterArray<string, $StringFilter>($filterString)(
        filter.nonEmptyStringSetProperty,
        value.nonEmptyStringSetProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalStringProperty !== "undefined" &&
      !$filterMaybe<string, $StringFilter>($filterString)(
        filter.optionalStringProperty,
        value.optionalStringProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.requiredStringProperty !== "undefined" &&
      !$filterString(
        filter.requiredStringProperty,
        value.requiredStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly emptyStringSetProperty?: $CollectionFilter<$StringFilter>;
    readonly nonEmptyStringSetProperty?: $CollectionFilter<$StringFilter>;
    readonly optionalStringProperty?: $MaybeFilter<$StringFilter>;
    readonly requiredStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PropertyCardinalitiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new PropertyCardinalitiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PropertyCardinalitiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PropertyCardinalitiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new PropertyCardinalitiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PropertyCardinalitiesClass";
    readonly emptyStringSetProperty?: readonly string[];
    readonly nonEmptyStringSetProperty: readonly string[];
    readonly optionalStringProperty?: string;
    readonly requiredStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PropertyCardinalitiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/emptyStringSetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/nonEmptyStringSetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/optionalStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/requiredStringProperty`,
          type: "Control",
        },
      ],
      label: "PropertyCardinalitiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PropertyCardinalitiesClass"),
      emptyStringSetProperty: zod
        .string()
        .array()
        .default(() => [])
        .describe("Set: minCount implicitly=0, no maxCount"),
      nonEmptyStringSetProperty: zod
        .string()
        .array()
        .nonempty()
        .min(1)
        .describe("Set: minCount=1, no maxCount"),
      optionalStringProperty: zod
        .string()
        .optional()
        .describe("Option: maxCount=1, minCount=0"),
      requiredStringProperty: zod
        .string()
        .describe("Required: maxCount=minCount=1"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    emptyStringSetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/emptyStringSetProperty",
      ),
    },
    nonEmptyStringSetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/nonEmptyStringSetProperty",
      ),
    },
    optionalStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalStringProperty",
      ),
    },
    requiredStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/requiredStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      emptyStringSetProperty: readonly string[];
      nonEmptyStringSetProperty: purify.NonEmptyList<string>;
      optionalStringProperty: purify.Maybe<string>;
      requiredStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const emptyStringSetProperty = $jsonObject["emptyStringSetProperty"];
    const nonEmptyStringSetProperty = purify.NonEmptyList.fromArray(
      $jsonObject["nonEmptyStringSetProperty"],
    ).unsafeCoerce();
    const optionalStringProperty = purify.Maybe.fromNullable(
      $jsonObject["optionalStringProperty"],
    );
    const requiredStringProperty = $jsonObject["requiredStringProperty"];
    return purify.Either.of({
      $identifier,
      emptyStringSetProperty,
      nonEmptyStringSetProperty,
      optionalStringProperty,
      requiredStringProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      emptyStringSetProperty: readonly string[];
      nonEmptyStringSetProperty: purify.NonEmptyList<string>;
      optionalStringProperty: purify.Maybe<string>;
      requiredStringProperty: string;
    }
  > {
    return purify.Either.of<Error, PropertyCardinalitiesClass.$Identifier>(
      $parameters.resource.identifier as PropertyCardinalitiesClass.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.emptyStringSetProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              PropertyCardinalitiesClass.$properties.emptyStringSetProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .map((values) => values.toArray())
        .map((valuesArray) =>
          rdfjsResource.Resource.Values.fromValue({
            focusResource: $parameters.resource,
            predicate:
              PropertyCardinalitiesClass.$properties.emptyStringSetProperty[
                "identifier"
              ],
            value: valuesArray,
          }),
        )
        .chain((values) => values.head())
        .chain((emptyStringSetProperty) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.nonEmptyStringSetProperty["identifier"],
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  PropertyCardinalitiesClass.$properties
                    .nonEmptyStringSetProperty["identifier"],
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) =>
              purify.NonEmptyList.fromArray(values.toArray()).toEither(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} is an empty set`,
                ),
              ),
            )
            .map((valuesArray) =>
              rdfjsResource.Resource.Values.fromValue({
                focusResource: $parameters.resource,
                predicate:
                  PropertyCardinalitiesClass.$properties
                    .nonEmptyStringSetProperty["identifier"],
                value: valuesArray,
              }),
            )
            .chain((values) => values.head())
            .chain((nonEmptyStringSetProperty) =>
              purify.Either.of<
                Error,
                rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
              >(
                $parameters.resource.values(
                  $properties.optionalStringProperty["identifier"],
                  { unique: true },
                ),
              )
                .chain((values) =>
                  $fromRdfPreferredLanguages({
                    focusResource: $parameters.resource,
                    predicate:
                      PropertyCardinalitiesClass.$properties
                        .optionalStringProperty["identifier"],
                    preferredLanguages: $parameters.preferredLanguages,
                    values,
                  }),
                )
                .chain((values) => values.chainMap((value) => value.toString()))
                .map((values) =>
                  values.length > 0
                    ? values.map((value) => purify.Maybe.of(value))
                    : rdfjsResource.Resource.Values.fromValue<
                        purify.Maybe<string>
                      >({
                        focusResource: $parameters.resource,
                        predicate:
                          PropertyCardinalitiesClass.$properties
                            .optionalStringProperty["identifier"],
                        value: purify.Maybe.empty(),
                      }),
                )
                .chain((values) => values.head())
                .chain((optionalStringProperty) =>
                  purify.Either.of<
                    Error,
                    rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                  >(
                    $parameters.resource.values(
                      $properties.requiredStringProperty["identifier"],
                      { unique: true },
                    ),
                  )
                    .chain((values) =>
                      $fromRdfPreferredLanguages({
                        focusResource: $parameters.resource,
                        predicate:
                          PropertyCardinalitiesClass.$properties
                            .requiredStringProperty["identifier"],
                        preferredLanguages: $parameters.preferredLanguages,
                        values,
                      }),
                    )
                    .chain((values) =>
                      values.chainMap((value) => value.toString()),
                    )
                    .chain((values) => values.head())
                    .map((requiredStringProperty) => ({
                      $identifier,
                      emptyStringSetProperty,
                      nonEmptyStringSetProperty,
                      optionalStringProperty,
                      requiredStringProperty,
                    })),
                ),
            ),
        ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PropertyCardinalitiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PropertyCardinalitiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            PropertyCardinalitiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PropertyCardinalitiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PropertyCardinalitiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("propertyCardinalitiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}EmptyStringSetProperty`,
      ),
      predicate:
        PropertyCardinalitiesClass.$properties.emptyStringSetProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}NonEmptyStringSetProperty`,
      ),
      predicate:
        PropertyCardinalitiesClass.$properties.nonEmptyStringSetProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}OptionalStringProperty`,
      ),
      predicate:
        PropertyCardinalitiesClass.$properties.optionalStringProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}RequiredStringProperty`,
      ),
      predicate:
        PropertyCardinalitiesClass.$properties.requiredStringProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PropertyCardinalitiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("propertyCardinalitiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}EmptyStringSetProperty`,
              ),
              predicate:
                PropertyCardinalitiesClass.$properties.emptyStringSetProperty[
                  "identifier"
                ],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: [parameters?.preferredLanguages ?? []]
            .filter((languages) => languages.length > 0)
            .map((languages) =>
              languages.map((language) => ({
                type: "operation" as const,
                operator: "=",
                args: [
                  {
                    type: "operation" as const,
                    operator: "lang",
                    args: [
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}EmptyStringSetProperty`,
                      ),
                    ],
                  },
                  dataFactory.literal(language),
                ],
              })),
            )
            .map((langEqualsExpressions) => ({
              type: "filter" as const,
              expression: langEqualsExpressions.reduce(
                (reducedExpression, langEqualsExpression) => {
                  if (reducedExpression === null) {
                    return langEqualsExpression;
                  }
                  return {
                    type: "operation" as const,
                    operator: "||",
                    args: [reducedExpression, langEqualsExpression],
                  };
                },
                null as sparqljs.Expression | null,
              ) as sparqljs.Expression,
            }))
            .concat(),
          type: "group",
        },
        {
          patterns: $StringFilter
            .$sparqlWherePatterns(
              parameters?.filter?.emptyStringSetProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}EmptyStringSetProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}NonEmptyStringSetProperty`,
            ),
            predicate:
              PropertyCardinalitiesClass.$properties.nonEmptyStringSetProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}NonEmptyStringSetProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.nonEmptyStringSetProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}NonEmptyStringSetProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalStringProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}OptionalStringProperty`,
                  ),
                  predicate:
                    PropertyCardinalitiesClass.$properties
                      .optionalStringProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [parameters?.preferredLanguages ?? []]
                .filter((languages) => languages.length > 0)
                .map((languages) =>
                  languages.map((language) => ({
                    type: "operation" as const,
                    operator: "=",
                    args: [
                      {
                        type: "operation" as const,
                        operator: "lang",
                        args: [
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}OptionalStringProperty`,
                          ),
                        ],
                      },
                      dataFactory.literal(language),
                    ],
                  })),
                )
                .map((langEqualsExpressions) => ({
                  type: "filter" as const,
                  expression: langEqualsExpressions.reduce(
                    (reducedExpression, langEqualsExpression) => {
                      if (reducedExpression === null) {
                        return langEqualsExpression;
                      }
                      return {
                        type: "operation" as const,
                        operator: "||",
                        args: [reducedExpression, langEqualsExpression],
                      };
                    },
                    null as sparqljs.Expression | null,
                  ) as sparqljs.Expression,
                }))
                .concat(),
              type: "group",
            },
            {
              patterns: $StringFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}OptionalStringProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}RequiredStringProperty`,
            ),
            predicate:
              PropertyCardinalitiesClass.$properties.requiredStringProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}RequiredStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.requiredStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}RequiredStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isPropertyCardinalitiesClass(
    object: $Object,
  ): object is PropertyCardinalitiesClass {
    switch (object.$type) {
      case "PropertyCardinalitiesClass":
        return true;
      default:
        return false;
    }
  }
}
export interface PartialInterfaceUnionMember2 {
  readonly $identifier: PartialInterfaceUnionMember2.$Identifier;
  readonly $type: "PartialInterfaceUnionMember2";
  readonly lazilyResolvedStringProperty: string;
}

export namespace PartialInterfaceUnionMember2 {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): PartialInterfaceUnionMember2 {
    let $identifier: PartialInterfaceUnionMember2.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "PartialInterfaceUnionMember2" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: PartialInterfaceUnionMember2,
    right: PartialInterfaceUnionMember2,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export function $filter(
    filter: PartialInterfaceUnionMember2.$Filter,
    value: PartialInterfaceUnionMember2,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialInterfaceUnionMember2> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialInterfaceUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PartialInterfaceUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/PartialInterfaceUnionMember2",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _partialInterfaceUnionMember2: PartialInterfaceUnionMember2,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_partialInterfaceUnionMember2.$identifier.value);
    _hasher.update(_partialInterfaceUnionMember2.$type);
    PartialInterfaceUnionMember2.$hashShaclProperties(
      _partialInterfaceUnionMember2,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _partialInterfaceUnionMember2: PartialInterfaceUnionMember2,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_partialInterfaceUnionMember2.lazilyResolvedStringProperty);
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialInterfaceUnionMember2";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialInterfaceUnionMember2" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialInterfaceUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PartialInterfaceUnionMember2"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "PartialInterfaceUnionMember2";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "PartialInterfaceUnionMember2" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "PartialInterfaceUnionMember2";
      lazilyResolvedStringProperty: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/PartialInterfaceUnionMember2":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  PartialInterfaceUnionMember2.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/PartialInterfaceUnionMember2)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      purify.Either.of<Error, PartialInterfaceUnionMember2.$Identifier>(
        $parameters.resource
          .identifier as PartialInterfaceUnionMember2.$Identifier,
      ).chain(($identifier) =>
        purify.Either.of<Error, "PartialInterfaceUnionMember2">(
          "PartialInterfaceUnionMember2",
        ).chain(($type) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.lazilyResolvedStringProperty["identifier"],
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  PartialInterfaceUnionMember2.$properties
                    .lazilyResolvedStringProperty["identifier"],
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((lazilyResolvedStringProperty) => ({
              $identifier,
              $type,
              lazilyResolvedStringProperty,
            })),
        ),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialInterfaceUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialInterfaceUnionMember2.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            PartialInterfaceUnionMember2.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialInterfaceUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialInterfaceUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("partialInterfaceUnionMember2");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember2")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember2")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember2")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember2")}LazilyResolvedStringProperty`,
      ),
      predicate:
        PartialInterfaceUnionMember2.$properties.lazilyResolvedStringProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialInterfaceUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("partialInterfaceUnionMember2");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember2")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: PartialInterfaceUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember2")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember2")}LazilyResolvedStringProperty`,
            ),
            predicate:
              PartialInterfaceUnionMember2.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember2")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember2")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _partialInterfaceUnionMember2: PartialInterfaceUnionMember2,
  ): PartialInterfaceUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _partialInterfaceUnionMember2.$identifier.termType === "BlankNode"
            ? `_:${_partialInterfaceUnionMember2.$identifier.value}`
            : _partialInterfaceUnionMember2.$identifier.value,
        $type: _partialInterfaceUnionMember2.$type,
        lazilyResolvedStringProperty:
          _partialInterfaceUnionMember2.lazilyResolvedStringProperty,
      } satisfies PartialInterfaceUnionMember2.$Json),
    );
  }

  export function $toRdf(
    _partialInterfaceUnionMember2: PartialInterfaceUnionMember2,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _partialInterfaceUnionMember2.$identifier,
      { mutateGraph },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/PartialInterfaceUnionMember2",
        ),
      );
    }

    resource.add(
      PartialInterfaceUnionMember2.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[_partialInterfaceUnionMember2.lazilyResolvedStringProperty],
    );
    return resource;
  }

  export function isPartialInterfaceUnionMember2(
    object: $Object,
  ): object is PartialInterfaceUnionMember2 {
    switch (object.$type) {
      case "PartialInterfaceUnionMember2":
        return true;
      default:
        return false;
    }
  }
}
export interface PartialInterfaceUnionMember1 {
  readonly $identifier: PartialInterfaceUnionMember1.$Identifier;
  readonly $type: "PartialInterfaceUnionMember1";
  readonly lazilyResolvedStringProperty: string;
}

export namespace PartialInterfaceUnionMember1 {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): PartialInterfaceUnionMember1 {
    let $identifier: PartialInterfaceUnionMember1.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "PartialInterfaceUnionMember1" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: PartialInterfaceUnionMember1,
    right: PartialInterfaceUnionMember1,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export function $filter(
    filter: PartialInterfaceUnionMember1.$Filter,
    value: PartialInterfaceUnionMember1,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialInterfaceUnionMember1> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialInterfaceUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PartialInterfaceUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/PartialInterfaceUnionMember1",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _partialInterfaceUnionMember1: PartialInterfaceUnionMember1,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_partialInterfaceUnionMember1.$identifier.value);
    _hasher.update(_partialInterfaceUnionMember1.$type);
    PartialInterfaceUnionMember1.$hashShaclProperties(
      _partialInterfaceUnionMember1,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _partialInterfaceUnionMember1: PartialInterfaceUnionMember1,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_partialInterfaceUnionMember1.lazilyResolvedStringProperty);
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialInterfaceUnionMember1";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialInterfaceUnionMember1" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialInterfaceUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PartialInterfaceUnionMember1"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "PartialInterfaceUnionMember1";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "PartialInterfaceUnionMember1" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "PartialInterfaceUnionMember1";
      lazilyResolvedStringProperty: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/PartialInterfaceUnionMember1":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  PartialInterfaceUnionMember1.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/PartialInterfaceUnionMember1)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      purify.Either.of<Error, PartialInterfaceUnionMember1.$Identifier>(
        $parameters.resource
          .identifier as PartialInterfaceUnionMember1.$Identifier,
      ).chain(($identifier) =>
        purify.Either.of<Error, "PartialInterfaceUnionMember1">(
          "PartialInterfaceUnionMember1",
        ).chain(($type) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.lazilyResolvedStringProperty["identifier"],
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  PartialInterfaceUnionMember1.$properties
                    .lazilyResolvedStringProperty["identifier"],
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((lazilyResolvedStringProperty) => ({
              $identifier,
              $type,
              lazilyResolvedStringProperty,
            })),
        ),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialInterfaceUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialInterfaceUnionMember1.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            PartialInterfaceUnionMember1.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialInterfaceUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialInterfaceUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("partialInterfaceUnionMember1");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember1")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember1")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember1")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember1")}LazilyResolvedStringProperty`,
      ),
      predicate:
        PartialInterfaceUnionMember1.$properties.lazilyResolvedStringProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialInterfaceUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("partialInterfaceUnionMember1");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember1")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: PartialInterfaceUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember1")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember1")}LazilyResolvedStringProperty`,
            ),
            predicate:
              PartialInterfaceUnionMember1.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember1")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember1")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _partialInterfaceUnionMember1: PartialInterfaceUnionMember1,
  ): PartialInterfaceUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _partialInterfaceUnionMember1.$identifier.termType === "BlankNode"
            ? `_:${_partialInterfaceUnionMember1.$identifier.value}`
            : _partialInterfaceUnionMember1.$identifier.value,
        $type: _partialInterfaceUnionMember1.$type,
        lazilyResolvedStringProperty:
          _partialInterfaceUnionMember1.lazilyResolvedStringProperty,
      } satisfies PartialInterfaceUnionMember1.$Json),
    );
  }

  export function $toRdf(
    _partialInterfaceUnionMember1: PartialInterfaceUnionMember1,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _partialInterfaceUnionMember1.$identifier,
      { mutateGraph },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/PartialInterfaceUnionMember1",
        ),
      );
    }

    resource.add(
      PartialInterfaceUnionMember1.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[_partialInterfaceUnionMember1.lazilyResolvedStringProperty],
    );
    return resource;
  }

  export function isPartialInterfaceUnionMember1(
    object: $Object,
  ): object is PartialInterfaceUnionMember1 {
    switch (object.$type) {
      case "PartialInterfaceUnionMember1":
        return true;
      default:
        return false;
    }
  }
}
export class PartialClassUnionMember2 {
  private _$identifier?: PartialClassUnionMember2.$Identifier;
  readonly $type = "PartialClassUnionMember2";
  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): PartialClassUnionMember2.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: PartialClassUnionMember2): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): PartialClassUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies PartialClassUnionMember2.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/PartialClassUnionMember2",
        ),
      );
    }

    resource.add(
      PartialClassUnionMember2.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[this.lazilyResolvedStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PartialClassUnionMember2 {
  export function $filter(
    filter: PartialClassUnionMember2.$Filter,
    value: PartialClassUnionMember2,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialClassUnionMember2> {
    return $propertiesFromJson(json).map(
      (properties) => new PartialClassUnionMember2(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialClassUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PartialClassUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new PartialClassUnionMember2(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/PartialClassUnionMember2",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialClassUnionMember2";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialClassUnionMember2" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialClassUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PartialClassUnionMember2"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/PartialClassUnionMember2":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  PartialClassUnionMember2.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/PartialClassUnionMember2)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      purify.Either.of<Error, PartialClassUnionMember2.$Identifier>(
        $parameters.resource.identifier as PartialClassUnionMember2.$Identifier,
      ).chain(($identifier) =>
        purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
        >(
          $parameters.resource.values(
            $properties.lazilyResolvedStringProperty["identifier"],
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                PartialClassUnionMember2.$properties
                  .lazilyResolvedStringProperty["identifier"],
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((lazilyResolvedStringProperty) => ({
            $identifier,
            lazilyResolvedStringProperty,
          })),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialClassUnionMember2.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            PartialClassUnionMember2.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialClassUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClassUnionMember2");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember2")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember2")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember2")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember2")}LazilyResolvedStringProperty`,
      ),
      predicate:
        PartialClassUnionMember2.$properties.lazilyResolvedStringProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialClassUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClassUnionMember2");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember2")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: PartialClassUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember2")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember2")}LazilyResolvedStringProperty`,
            ),
            predicate:
              PartialClassUnionMember2.$properties.lazilyResolvedStringProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember2")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember2")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isPartialClassUnionMember2(
    object: $Object,
  ): object is PartialClassUnionMember2 {
    switch (object.$type) {
      case "PartialClassUnionMember2":
        return true;
      default:
        return false;
    }
  }
}
export class PartialClassUnionMember1 {
  private _$identifier?: PartialClassUnionMember1.$Identifier;
  readonly $type = "PartialClassUnionMember1";
  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): PartialClassUnionMember1.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: PartialClassUnionMember1): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): PartialClassUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies PartialClassUnionMember1.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/PartialClassUnionMember1",
        ),
      );
    }

    resource.add(
      PartialClassUnionMember1.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[this.lazilyResolvedStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PartialClassUnionMember1 {
  export function $filter(
    filter: PartialClassUnionMember1.$Filter,
    value: PartialClassUnionMember1,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialClassUnionMember1> {
    return $propertiesFromJson(json).map(
      (properties) => new PartialClassUnionMember1(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialClassUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PartialClassUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new PartialClassUnionMember1(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/PartialClassUnionMember1",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialClassUnionMember1";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialClassUnionMember1" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialClassUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PartialClassUnionMember1"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/PartialClassUnionMember1":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  PartialClassUnionMember1.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/PartialClassUnionMember1)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      purify.Either.of<Error, PartialClassUnionMember1.$Identifier>(
        $parameters.resource.identifier as PartialClassUnionMember1.$Identifier,
      ).chain(($identifier) =>
        purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
        >(
          $parameters.resource.values(
            $properties.lazilyResolvedStringProperty["identifier"],
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                PartialClassUnionMember1.$properties
                  .lazilyResolvedStringProperty["identifier"],
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((lazilyResolvedStringProperty) => ({
            $identifier,
            lazilyResolvedStringProperty,
          })),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialClassUnionMember1.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            PartialClassUnionMember1.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialClassUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClassUnionMember1");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember1")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember1")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember1")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember1")}LazilyResolvedStringProperty`,
      ),
      predicate:
        PartialClassUnionMember1.$properties.lazilyResolvedStringProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialClassUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClassUnionMember1");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember1")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: PartialClassUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember1")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember1")}LazilyResolvedStringProperty`,
            ),
            predicate:
              PartialClassUnionMember1.$properties.lazilyResolvedStringProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember1")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember1")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isPartialClassUnionMember1(
    object: $Object,
  ): object is PartialClassUnionMember1 {
    switch (object.$type) {
      case "PartialClassUnionMember1":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Shape whose sh:properties have sh:order's. The compiler should order them C, A, B based on sh:order instead of on the declaration or lexicographic orders.
 */
export class OrderedPropertiesClass {
  private _$identifier?: OrderedPropertiesClass.$Identifier;
  readonly $type = "OrderedPropertiesClass";
  readonly orderedPropertyC: string;
  readonly orderedPropertyB: string;
  readonly orderedPropertyA: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly orderedPropertyC: string;
    readonly orderedPropertyB: string;
    readonly orderedPropertyA: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.orderedPropertyC = parameters.orderedPropertyC;
    this.orderedPropertyB = parameters.orderedPropertyB;
    this.orderedPropertyA = parameters.orderedPropertyA;
  }

  get $identifier(): OrderedPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: OrderedPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.orderedPropertyC, other.orderedPropertyC).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "orderedPropertyC",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.orderedPropertyB, other.orderedPropertyB).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "orderedPropertyB",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.orderedPropertyA, other.orderedPropertyA).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "orderedPropertyA",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.orderedPropertyC);
    _hasher.update(this.orderedPropertyB);
    _hasher.update(this.orderedPropertyA);
    return _hasher;
  }

  $toJson(): OrderedPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        orderedPropertyC: this.orderedPropertyC,
        orderedPropertyB: this.orderedPropertyB,
        orderedPropertyA: this.orderedPropertyA,
      } satisfies OrderedPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      OrderedPropertiesClass.$properties.orderedPropertyC["identifier"],
      ...[this.orderedPropertyC],
    );
    resource.add(
      OrderedPropertiesClass.$properties.orderedPropertyB["identifier"],
      ...[this.orderedPropertyB],
    );
    resource.add(
      OrderedPropertiesClass.$properties.orderedPropertyA["identifier"],
      ...[this.orderedPropertyA],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace OrderedPropertiesClass {
  export function $filter(
    filter: OrderedPropertiesClass.$Filter,
    value: OrderedPropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.orderedPropertyC !== "undefined" &&
      !$filterString(filter.orderedPropertyC, value.orderedPropertyC)
    ) {
      return false;
    }

    if (
      typeof filter.orderedPropertyB !== "undefined" &&
      !$filterString(filter.orderedPropertyB, value.orderedPropertyB)
    ) {
      return false;
    }

    if (
      typeof filter.orderedPropertyA !== "undefined" &&
      !$filterString(filter.orderedPropertyA, value.orderedPropertyA)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly orderedPropertyC?: $StringFilter;
    readonly orderedPropertyB?: $StringFilter;
    readonly orderedPropertyA?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, OrderedPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new OrderedPropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, OrderedPropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return OrderedPropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new OrderedPropertiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "OrderedPropertiesClass";
    readonly orderedPropertyC: string;
    readonly orderedPropertyB: string;
    readonly orderedPropertyA: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "OrderedPropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/orderedPropertyC`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/orderedPropertyB`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/orderedPropertyA`,
          type: "Control",
        },
      ],
      label: "OrderedPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("OrderedPropertiesClass"),
      orderedPropertyC: zod.string(),
      orderedPropertyB: zod.string(),
      orderedPropertyA: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    orderedPropertyC: {
      identifier: dataFactory.namedNode("http://example.com/orderedPropertyC"),
    },
    orderedPropertyB: {
      identifier: dataFactory.namedNode("http://example.com/orderedPropertyB"),
    },
    orderedPropertyA: {
      identifier: dataFactory.namedNode("http://example.com/orderedPropertyA"),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      orderedPropertyC: string;
      orderedPropertyB: string;
      orderedPropertyA: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const orderedPropertyC = $jsonObject["orderedPropertyC"];
    const orderedPropertyB = $jsonObject["orderedPropertyB"];
    const orderedPropertyA = $jsonObject["orderedPropertyA"];
    return purify.Either.of({
      $identifier,
      orderedPropertyC,
      orderedPropertyB,
      orderedPropertyA,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      orderedPropertyC: string;
      orderedPropertyB: string;
      orderedPropertyA: string;
    }
  > {
    return purify.Either.of<Error, OrderedPropertiesClass.$Identifier>(
      $parameters.resource.identifier as OrderedPropertiesClass.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.orderedPropertyC["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              OrderedPropertiesClass.$properties.orderedPropertyC["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .chain((orderedPropertyC) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.orderedPropertyB["identifier"],
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  OrderedPropertiesClass.$properties.orderedPropertyB[
                    "identifier"
                  ],
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .chain((orderedPropertyB) =>
              purify.Either.of<
                Error,
                rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
              >(
                $parameters.resource.values(
                  $properties.orderedPropertyA["identifier"],
                  { unique: true },
                ),
              )
                .chain((values) =>
                  $fromRdfPreferredLanguages({
                    focusResource: $parameters.resource,
                    predicate:
                      OrderedPropertiesClass.$properties.orderedPropertyA[
                        "identifier"
                      ],
                    preferredLanguages: $parameters.preferredLanguages,
                    values,
                  }),
                )
                .chain((values) => values.chainMap((value) => value.toString()))
                .chain((values) => values.head())
                .map((orderedPropertyA) => ({
                  $identifier,
                  orderedPropertyC,
                  orderedPropertyB,
                  orderedPropertyA,
                })),
            ),
        ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: OrderedPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        OrderedPropertiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            OrderedPropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: OrderedPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      OrderedPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("orderedPropertiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyC`,
      ),
      predicate:
        OrderedPropertiesClass.$properties.orderedPropertyC["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyB`,
      ),
      predicate:
        OrderedPropertiesClass.$properties.orderedPropertyB["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyA`,
      ),
      predicate:
        OrderedPropertiesClass.$properties.orderedPropertyA["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: OrderedPropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("orderedPropertiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyC`,
            ),
            predicate:
              OrderedPropertiesClass.$properties.orderedPropertyC["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyC`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.orderedPropertyC,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyC`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyB`,
            ),
            predicate:
              OrderedPropertiesClass.$properties.orderedPropertyB["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyB`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.orderedPropertyB,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyB`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyA`,
            ),
            predicate:
              OrderedPropertiesClass.$properties.orderedPropertyA["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyA`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.orderedPropertyA,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyA`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isOrderedPropertiesClass(
    object: $Object,
  ): object is OrderedPropertiesClass {
    switch (object.$type) {
      case "OrderedPropertiesClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape that isn't an rdfs:Class.
 */
export class NonClass {
  private _$identifier?: NonClass.$Identifier;
  readonly $type = "NonClass";
  readonly nonClassProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly nonClassProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.nonClassProperty = parameters.nonClassProperty;
  }

  get $identifier(): NonClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: NonClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.nonClassProperty, other.nonClassProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "nonClassProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.nonClassProperty);
    return _hasher;
  }

  $toJson(): NonClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        nonClassProperty: this.nonClassProperty,
      } satisfies NonClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      NonClass.$properties.nonClassProperty["identifier"],
      ...[this.nonClassProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace NonClass {
  export function $filter(filter: NonClass.$Filter, value: NonClass): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.nonClassProperty !== "undefined" &&
      !$filterString(filter.nonClassProperty, value.nonClassProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly nonClassProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, NonClass> {
    return $propertiesFromJson(json).map(
      (properties) => new NonClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, NonClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return NonClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new NonClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "NonClass";
    readonly nonClassProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "NonClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/nonClassProperty`,
          type: "Control",
        },
      ],
      label: "NonClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("NonClass"),
      nonClassProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    nonClassProperty: {
      identifier: dataFactory.namedNode("http://example.com/nonClassProperty"),
    },
  };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode; nonClassProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const nonClassProperty = $jsonObject["nonClassProperty"];
    return purify.Either.of({ $identifier, nonClassProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode; nonClassProperty: string }
  > {
    return purify.Either.of<Error, NonClass.$Identifier>(
      $parameters.resource.identifier as NonClass.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.nonClassProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate: NonClass.$properties.nonClassProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((nonClassProperty) => ({ $identifier, nonClassProperty })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: NonClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        NonClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            NonClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: NonClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      NonClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("nonClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "nonClass")}NonClassProperty`,
      ),
      predicate: NonClass.$properties.nonClassProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: NonClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("nonClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "nonClass")}NonClassProperty`,
            ),
            predicate: NonClass.$properties.nonClassProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "nonClass")}NonClassProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.nonClassProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "nonClass")}NonClassProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isNonClass(object: $Object): object is NonClass {
    switch (object.$type) {
      case "NonClass":
        return true;
      default:
        return false;
    }
  }
}
export class NoRdfTypeClassUnionMember2 {
  private _$identifier?: NoRdfTypeClassUnionMember2.$Identifier;
  readonly $type = "NoRdfTypeClassUnionMember2";
  readonly noRdfTypeClassUnionMember2Property: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly noRdfTypeClassUnionMember2Property: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.noRdfTypeClassUnionMember2Property =
      parameters.noRdfTypeClassUnionMember2Property;
  }

  get $identifier(): NoRdfTypeClassUnionMember2.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: NoRdfTypeClassUnionMember2): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.noRdfTypeClassUnionMember2Property,
          other.noRdfTypeClassUnionMember2Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "noRdfTypeClassUnionMember2Property",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.noRdfTypeClassUnionMember2Property);
    return _hasher;
  }

  $toJson(): NoRdfTypeClassUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        noRdfTypeClassUnionMember2Property:
          this.noRdfTypeClassUnionMember2Property,
      } satisfies NoRdfTypeClassUnionMember2.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      NoRdfTypeClassUnionMember2.$properties.noRdfTypeClassUnionMember2Property[
        "identifier"
      ],
      ...[this.noRdfTypeClassUnionMember2Property],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace NoRdfTypeClassUnionMember2 {
  export function $filter(
    filter: NoRdfTypeClassUnionMember2.$Filter,
    value: NoRdfTypeClassUnionMember2,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.noRdfTypeClassUnionMember2Property !== "undefined" &&
      !$filterString(
        filter.noRdfTypeClassUnionMember2Property,
        value.noRdfTypeClassUnionMember2Property,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly noRdfTypeClassUnionMember2Property?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, NoRdfTypeClassUnionMember2> {
    return $propertiesFromJson(json).map(
      (properties) => new NoRdfTypeClassUnionMember2(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, NoRdfTypeClassUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return NoRdfTypeClassUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new NoRdfTypeClassUnionMember2(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "NoRdfTypeClassUnionMember2";
    readonly noRdfTypeClassUnionMember2Property: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "NoRdfTypeClassUnionMember2" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/noRdfTypeClassUnionMember2Property`,
          type: "Control",
        },
      ],
      label: "NoRdfTypeClassUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("NoRdfTypeClassUnionMember2"),
      noRdfTypeClassUnionMember2Property: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    noRdfTypeClassUnionMember2Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/noRdfTypeClassUnionMember2Property",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      noRdfTypeClassUnionMember2Property: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const noRdfTypeClassUnionMember2Property =
      $jsonObject["noRdfTypeClassUnionMember2Property"];
    return purify.Either.of({
      $identifier,
      noRdfTypeClassUnionMember2Property,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      noRdfTypeClassUnionMember2Property: string;
    }
  > {
    return purify.Either.of<Error, NoRdfTypeClassUnionMember2.$Identifier>(
      $parameters.resource.identifier as NoRdfTypeClassUnionMember2.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.noRdfTypeClassUnionMember2Property["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              NoRdfTypeClassUnionMember2.$properties
                .noRdfTypeClassUnionMember2Property["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((noRdfTypeClassUnionMember2Property) => ({
          $identifier,
          noRdfTypeClassUnionMember2Property,
        })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: NoRdfTypeClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        NoRdfTypeClassUnionMember2.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            NoRdfTypeClassUnionMember2.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: NoRdfTypeClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      NoRdfTypeClassUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("noRdfTypeClassUnionMember2");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "noRdfTypeClassUnionMember2")}NoRdfTypeClassUnionMember2Property`,
      ),
      predicate:
        NoRdfTypeClassUnionMember2.$properties
          .noRdfTypeClassUnionMember2Property["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: NoRdfTypeClassUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("noRdfTypeClassUnionMember2");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "noRdfTypeClassUnionMember2")}NoRdfTypeClassUnionMember2Property`,
            ),
            predicate:
              NoRdfTypeClassUnionMember2.$properties
                .noRdfTypeClassUnionMember2Property["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "noRdfTypeClassUnionMember2")}NoRdfTypeClassUnionMember2Property`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.noRdfTypeClassUnionMember2Property,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "noRdfTypeClassUnionMember2")}NoRdfTypeClassUnionMember2Property`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isNoRdfTypeClassUnionMember2(
    object: $Object,
  ): object is NoRdfTypeClassUnionMember2 {
    switch (object.$type) {
      case "NoRdfTypeClassUnionMember2":
        return true;
      default:
        return false;
    }
  }
}
export class NoRdfTypeClassUnionMember1 {
  private _$identifier?: NoRdfTypeClassUnionMember1.$Identifier;
  readonly $type = "NoRdfTypeClassUnionMember1";
  readonly noRdfTypeClassUnionMember1Property: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly noRdfTypeClassUnionMember1Property: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.noRdfTypeClassUnionMember1Property =
      parameters.noRdfTypeClassUnionMember1Property;
  }

  get $identifier(): NoRdfTypeClassUnionMember1.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: NoRdfTypeClassUnionMember1): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.noRdfTypeClassUnionMember1Property,
          other.noRdfTypeClassUnionMember1Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "noRdfTypeClassUnionMember1Property",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.noRdfTypeClassUnionMember1Property);
    return _hasher;
  }

  $toJson(): NoRdfTypeClassUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        noRdfTypeClassUnionMember1Property:
          this.noRdfTypeClassUnionMember1Property,
      } satisfies NoRdfTypeClassUnionMember1.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      NoRdfTypeClassUnionMember1.$properties.noRdfTypeClassUnionMember1Property[
        "identifier"
      ],
      ...[this.noRdfTypeClassUnionMember1Property],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace NoRdfTypeClassUnionMember1 {
  export function $filter(
    filter: NoRdfTypeClassUnionMember1.$Filter,
    value: NoRdfTypeClassUnionMember1,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.noRdfTypeClassUnionMember1Property !== "undefined" &&
      !$filterString(
        filter.noRdfTypeClassUnionMember1Property,
        value.noRdfTypeClassUnionMember1Property,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly noRdfTypeClassUnionMember1Property?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, NoRdfTypeClassUnionMember1> {
    return $propertiesFromJson(json).map(
      (properties) => new NoRdfTypeClassUnionMember1(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, NoRdfTypeClassUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return NoRdfTypeClassUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new NoRdfTypeClassUnionMember1(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "NoRdfTypeClassUnionMember1";
    readonly noRdfTypeClassUnionMember1Property: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "NoRdfTypeClassUnionMember1" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/noRdfTypeClassUnionMember1Property`,
          type: "Control",
        },
      ],
      label: "NoRdfTypeClassUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("NoRdfTypeClassUnionMember1"),
      noRdfTypeClassUnionMember1Property: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    noRdfTypeClassUnionMember1Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/noRdfTypeClassUnionMember1Property",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      noRdfTypeClassUnionMember1Property: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const noRdfTypeClassUnionMember1Property =
      $jsonObject["noRdfTypeClassUnionMember1Property"];
    return purify.Either.of({
      $identifier,
      noRdfTypeClassUnionMember1Property,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      noRdfTypeClassUnionMember1Property: string;
    }
  > {
    return purify.Either.of<Error, NoRdfTypeClassUnionMember1.$Identifier>(
      $parameters.resource.identifier as NoRdfTypeClassUnionMember1.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.noRdfTypeClassUnionMember1Property["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              NoRdfTypeClassUnionMember1.$properties
                .noRdfTypeClassUnionMember1Property["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((noRdfTypeClassUnionMember1Property) => ({
          $identifier,
          noRdfTypeClassUnionMember1Property,
        })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: NoRdfTypeClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        NoRdfTypeClassUnionMember1.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            NoRdfTypeClassUnionMember1.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: NoRdfTypeClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      NoRdfTypeClassUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("noRdfTypeClassUnionMember1");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "noRdfTypeClassUnionMember1")}NoRdfTypeClassUnionMember1Property`,
      ),
      predicate:
        NoRdfTypeClassUnionMember1.$properties
          .noRdfTypeClassUnionMember1Property["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: NoRdfTypeClassUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("noRdfTypeClassUnionMember1");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "noRdfTypeClassUnionMember1")}NoRdfTypeClassUnionMember1Property`,
            ),
            predicate:
              NoRdfTypeClassUnionMember1.$properties
                .noRdfTypeClassUnionMember1Property["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "noRdfTypeClassUnionMember1")}NoRdfTypeClassUnionMember1Property`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.noRdfTypeClassUnionMember1Property,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "noRdfTypeClassUnionMember1")}NoRdfTypeClassUnionMember1Property`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isNoRdfTypeClassUnionMember1(
    object: $Object,
  ): object is NoRdfTypeClassUnionMember1 {
    switch (object.$type) {
      case "NoRdfTypeClassUnionMember1":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Shape with shaclmate:mutable properties.
 */
export class MutablePropertiesClass {
  private _$identifier?: MutablePropertiesClass.$Identifier;
  protected readonly _$identifierPrefix?: string;
  readonly $type = "MutablePropertiesClass";
  /**
   * List-valued property that can't be reassigned but whose value can be mutated
   */
  readonly mutableListProperty: purify.Maybe<string[]>;
  /**
   * Set-valued property that can't be reassigned but whose value can be mutated
   */
  mutableSetProperty: string[];
  /**
   * String-valued property that can be re-assigned
   */
  mutableStringProperty: purify.Maybe<string>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly $identifierPrefix?: string;
    readonly mutableListProperty?: purify.Maybe<string[]> | readonly string[];
    readonly mutableSetProperty?: readonly string[];
    readonly mutableStringProperty?: purify.Maybe<string> | string;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    this._$identifierPrefix = parameters?.$identifierPrefix;
    if (purify.Maybe.isMaybe(parameters?.mutableListProperty)) {
      this.mutableListProperty = parameters?.mutableListProperty;
    } else if (typeof parameters?.mutableListProperty === "undefined") {
      this.mutableListProperty = purify.Maybe.of([]);
    } else if (typeof parameters?.mutableListProperty === "object") {
      this.mutableListProperty = purify.Maybe.of(
        parameters?.mutableListProperty.concat(),
      );
    } else {
      this.mutableListProperty =
        parameters?.mutableListProperty satisfies never;
    }

    if (typeof parameters?.mutableSetProperty === "undefined") {
      this.mutableSetProperty = [];
    } else if (typeof parameters?.mutableSetProperty === "object") {
      this.mutableSetProperty = parameters?.mutableSetProperty.concat();
    } else {
      this.mutableSetProperty = parameters?.mutableSetProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.mutableStringProperty)) {
      this.mutableStringProperty = parameters?.mutableStringProperty;
    } else if (typeof parameters?.mutableStringProperty === "string") {
      this.mutableStringProperty = purify.Maybe.of(
        parameters?.mutableStringProperty,
      );
    } else if (typeof parameters?.mutableStringProperty === "undefined") {
      this.mutableStringProperty = purify.Maybe.empty();
    } else {
      this.mutableStringProperty =
        parameters?.mutableStringProperty satisfies never;
    }
  }

  get $identifier(): MutablePropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      return dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }

    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  $equals(other: MutablePropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$identifierPrefix, other.$identifierPrefix).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$identifierPrefix",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) =>
            $arrayEquals(left, right, $strictEquals),
          ))(this.mutableListProperty, other.mutableListProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "mutableListProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $strictEquals))(
          this.mutableSetProperty,
          other.mutableSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "mutableSetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.mutableStringProperty,
          other.mutableStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "mutableStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.mutableListProperty.ifJust((value0) => {
      for (const item1 of value0) {
        _hasher.update(item1);
      }
    });
    for (const item0 of this.mutableSetProperty) {
      _hasher.update(item0);
    }

    this.mutableStringProperty.ifJust((value0) => {
      _hasher.update(value0);
    });
    return _hasher;
  }

  $toJson(): MutablePropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        mutableListProperty: this.mutableListProperty
          .map((item) => item.map((item) => item))
          .extract(),
        mutableSetProperty: this.mutableSetProperty.map((item) => item),
        mutableStringProperty: this.mutableStringProperty
          .map((item) => item)
          .extract(),
      } satisfies MutablePropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      MutablePropertiesClass.$properties.mutableListProperty["identifier"],
      ...this.mutableListProperty.toList().flatMap((value) => [
        value.length > 0
          ? value.reduce(
              (
                { currentSubListResource, listResource },
                item,
                itemIndex,
                list,
              ) => {
                if (itemIndex === 0) {
                  currentSubListResource = listResource;
                } else {
                  const newSubListResource = resourceSet.mutableResource(
                    dataFactory.blankNode(),
                    { mutateGraph },
                  );
                  currentSubListResource!.add(
                    $RdfVocabularies.rdf.rest,
                    newSubListResource.identifier,
                  );
                  currentSubListResource = newSubListResource;
                }

                currentSubListResource.add(
                  $RdfVocabularies.rdf.first,
                  ...[item],
                );

                if (itemIndex + 1 === list.length) {
                  currentSubListResource.add(
                    $RdfVocabularies.rdf.rest,
                    $RdfVocabularies.rdf.nil,
                  );
                }

                return { currentSubListResource, listResource };
              },
              {
                currentSubListResource: null,
                listResource: resourceSet.mutableResource(
                  dataFactory.blankNode(),
                  { mutateGraph },
                ),
              } as {
                currentSubListResource: rdfjsResource.MutableResource | null;
                listResource: rdfjsResource.MutableResource;
              },
            ).listResource.identifier
          : $RdfVocabularies.rdf.nil,
      ]),
    );
    resource.add(
      MutablePropertiesClass.$properties.mutableSetProperty["identifier"],
      ...this.mutableSetProperty.flatMap((item) => [item]),
    );
    resource.add(
      MutablePropertiesClass.$properties.mutableStringProperty["identifier"],
      ...this.mutableStringProperty.toList(),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace MutablePropertiesClass {
  export function $filter(
    filter: MutablePropertiesClass.$Filter,
    value: MutablePropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.mutableListProperty !== "undefined" &&
      !$filterMaybe<string[], $CollectionFilter<$StringFilter>>(
        $filterArray<string, $StringFilter>($filterString),
      )(filter.mutableListProperty, value.mutableListProperty)
    ) {
      return false;
    }

    if (
      typeof filter.mutableSetProperty !== "undefined" &&
      !$filterArray<string, $StringFilter>($filterString)(
        filter.mutableSetProperty,
        value.mutableSetProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.mutableStringProperty !== "undefined" &&
      !$filterMaybe<string, $StringFilter>($filterString)(
        filter.mutableStringProperty,
        value.mutableStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly mutableListProperty?: $MaybeFilter<
      $CollectionFilter<$StringFilter>
    >;
    readonly mutableSetProperty?: $CollectionFilter<$StringFilter>;
    readonly mutableStringProperty?: $MaybeFilter<$StringFilter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, MutablePropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new MutablePropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, MutablePropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return MutablePropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new MutablePropertiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "MutablePropertiesClass";
    readonly mutableListProperty?: readonly string[];
    readonly mutableSetProperty?: readonly string[];
    readonly mutableStringProperty?: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "MutablePropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/mutableListProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/mutableSetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/mutableStringProperty`,
          type: "Control",
        },
      ],
      label: "MutablePropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("MutablePropertiesClass"),
      mutableListProperty: zod
        .string()
        .array()
        .default(() => [])
        .optional()
        .describe(
          "List-valued property that can't be reassigned but whose value can be mutated",
        ),
      mutableSetProperty: zod
        .string()
        .array()
        .default(() => [])
        .describe(
          "Set-valued property that can't be reassigned but whose value can be mutated",
        ),
      mutableStringProperty: zod
        .string()
        .optional()
        .describe("String-valued property that can be re-assigned"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    mutableListProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/mutableListProperty",
      ),
    },
    mutableSetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/mutableSetProperty",
      ),
    },
    mutableStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/mutableStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      mutableListProperty: purify.Maybe<string[]>;
      mutableSetProperty: string[];
      mutableStringProperty: purify.Maybe<string>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const mutableListProperty = purify.Maybe.fromNullable(
      $jsonObject["mutableListProperty"],
    );
    const mutableSetProperty = $jsonObject["mutableSetProperty"];
    const mutableStringProperty = purify.Maybe.fromNullable(
      $jsonObject["mutableStringProperty"],
    );
    return purify.Either.of({
      $identifier,
      mutableListProperty,
      mutableSetProperty,
      mutableStringProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      mutableListProperty: purify.Maybe<string[]>;
      mutableSetProperty: string[];
      mutableStringProperty: purify.Maybe<string>;
    }
  > {
    return purify.Either.of<Error, MutablePropertiesClass.$Identifier>(
      $parameters.resource.identifier as MutablePropertiesClass.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.mutableListProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => values.chainMap((value) => value.toList()))
        .chain((valueLists) =>
          valueLists.chainMap((valueList) =>
            purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
            >(
              rdfjsResource.Resource.Values.fromArray({
                focusResource: $parameters.resource,
                predicate:
                  MutablePropertiesClass.$properties.mutableListProperty[
                    "identifier"
                  ],
                values: valueList,
              }),
            )
              .chain((values) =>
                $fromRdfPreferredLanguages({
                  focusResource: $parameters.resource,
                  predicate:
                    MutablePropertiesClass.$properties.mutableListProperty[
                      "identifier"
                    ],
                  preferredLanguages: $parameters.preferredLanguages,
                  values,
                }),
              )
              .chain((values) => values.chainMap((value) => value.toString())),
          ),
        )
        .map((valueLists) =>
          valueLists.map((valueList) => valueList.toArray().concat()),
        )
        .map((values) =>
          values.length > 0
            ? values.map((value) => purify.Maybe.of(value))
            : rdfjsResource.Resource.Values.fromValue<purify.Maybe<string[]>>({
                focusResource: $parameters.resource,
                predicate:
                  MutablePropertiesClass.$properties.mutableListProperty[
                    "identifier"
                  ],
                value: purify.Maybe.empty(),
              }),
        )
        .chain((values) => values.head())
        .chain((mutableListProperty) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.mutableSetProperty["identifier"],
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  MutablePropertiesClass.$properties.mutableSetProperty[
                    "identifier"
                  ],
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .map((values) => values.toArray().concat())
            .map((valuesArray) =>
              rdfjsResource.Resource.Values.fromValue({
                focusResource: $parameters.resource,
                predicate:
                  MutablePropertiesClass.$properties.mutableSetProperty[
                    "identifier"
                  ],
                value: valuesArray,
              }),
            )
            .chain((values) => values.head())
            .chain((mutableSetProperty) =>
              purify.Either.of<
                Error,
                rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
              >(
                $parameters.resource.values(
                  $properties.mutableStringProperty["identifier"],
                  { unique: true },
                ),
              )
                .chain((values) =>
                  $fromRdfPreferredLanguages({
                    focusResource: $parameters.resource,
                    predicate:
                      MutablePropertiesClass.$properties.mutableStringProperty[
                        "identifier"
                      ],
                    preferredLanguages: $parameters.preferredLanguages,
                    values,
                  }),
                )
                .chain((values) => values.chainMap((value) => value.toString()))
                .map((values) =>
                  values.length > 0
                    ? values.map((value) => purify.Maybe.of(value))
                    : rdfjsResource.Resource.Values.fromValue<
                        purify.Maybe<string>
                      >({
                        focusResource: $parameters.resource,
                        predicate:
                          MutablePropertiesClass.$properties
                            .mutableStringProperty["identifier"],
                        value: purify.Maybe.empty(),
                      }),
                )
                .chain((values) => values.head())
                .map((mutableStringProperty) => ({
                  $identifier,
                  mutableListProperty,
                  mutableSetProperty,
                  mutableStringProperty,
                })),
            ),
        ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: MutablePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        MutablePropertiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            MutablePropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: MutablePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      MutablePropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("mutablePropertiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`,
      ),
      predicate:
        MutablePropertiesClass.$properties.mutableListProperty["identifier"],
      subject,
    });
    triples.push({
      subject: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`,
      ),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}Item0`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`,
      ),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}Rest0`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}ItemN`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}RestNBasic`,
      ),
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableSetProperty`,
      ),
      predicate:
        MutablePropertiesClass.$properties.mutableSetProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableStringProperty`,
      ),
      predicate:
        MutablePropertiesClass.$properties.mutableStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: MutablePropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("mutablePropertiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.mutableListProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`,
                  ),
                  predicate:
                    MutablePropertiesClass.$properties.mutableListProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}Item0`,
                      ),
                      predicate: $RdfVocabularies.rdf.first,
                      subject: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`,
                      ),
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: [parameters?.preferredLanguages ?? []]
                    .filter((languages) => languages.length > 0)
                    .map((languages) =>
                      languages.map((language) => ({
                        type: "operation" as const,
                        operator: "=",
                        args: [
                          {
                            type: "operation" as const,
                            operator: "lang",
                            args: [
                              dataFactory.variable!(
                                `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}Item0`,
                              ),
                            ],
                          },
                          dataFactory.literal(language),
                        ],
                      })),
                    )
                    .map((langEqualsExpressions) => ({
                      type: "filter" as const,
                      expression: langEqualsExpressions.reduce(
                        (reducedExpression, langEqualsExpression) => {
                          if (reducedExpression === null) {
                            return langEqualsExpression;
                          }
                          return {
                            type: "operation" as const,
                            operator: "||",
                            args: [reducedExpression, langEqualsExpression],
                          };
                        },
                        null as sparqljs.Expression | null,
                      ) as sparqljs.Expression,
                    }))
                    .concat(),
                  type: "group",
                },
                {
                  patterns: $StringFilter
                    .$sparqlWherePatterns(
                      itemFilter,
                      dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}Item0`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}Rest0`,
                      ),
                      predicate: $RdfVocabularies.rdf.rest,
                      subject: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`,
                      ),
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}RestN`,
                          ),
                          predicate: {
                            type: "path",
                            pathType: "*",
                            items: [$RdfVocabularies.rdf.rest],
                          },
                          subject: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}ItemN`,
                          ),
                          predicate: $RdfVocabularies.rdf.first,
                          subject: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}RestN`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: [parameters?.preferredLanguages ?? []]
                        .filter((languages) => languages.length > 0)
                        .map((languages) =>
                          languages.map((language) => ({
                            type: "operation" as const,
                            operator: "=",
                            args: [
                              {
                                type: "operation" as const,
                                operator: "lang",
                                args: [
                                  dataFactory.variable!(
                                    `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}ItemN`,
                                  ),
                                ],
                              },
                              dataFactory.literal(language),
                            ],
                          })),
                        )
                        .map((langEqualsExpressions) => ({
                          type: "filter" as const,
                          expression: langEqualsExpressions.reduce(
                            (reducedExpression, langEqualsExpression) => {
                              if (reducedExpression === null) {
                                return langEqualsExpression;
                              }
                              return {
                                type: "operation" as const,
                                operator: "||",
                                args: [reducedExpression, langEqualsExpression],
                              };
                            },
                            null as sparqljs.Expression | null,
                          ) as sparqljs.Expression,
                        }))
                        .concat(),
                      type: "group",
                    },
                    {
                      patterns: $StringFilter
                        .$sparqlWherePatterns(
                          itemFilter,
                          dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}ItemN`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}RestNBasic`,
                          ),
                          predicate: $RdfVocabularies.rdf.rest,
                          subject: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}RestN`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                  ],
                  type: "optional",
                },
              ],
              type: "optional",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableSetProperty`,
              ),
              predicate:
                MutablePropertiesClass.$properties.mutableSetProperty[
                  "identifier"
                ],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: [parameters?.preferredLanguages ?? []]
            .filter((languages) => languages.length > 0)
            .map((languages) =>
              languages.map((language) => ({
                type: "operation" as const,
                operator: "=",
                args: [
                  {
                    type: "operation" as const,
                    operator: "lang",
                    args: [
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableSetProperty`,
                      ),
                    ],
                  },
                  dataFactory.literal(language),
                ],
              })),
            )
            .map((langEqualsExpressions) => ({
              type: "filter" as const,
              expression: langEqualsExpressions.reduce(
                (reducedExpression, langEqualsExpression) => {
                  if (reducedExpression === null) {
                    return langEqualsExpression;
                  }
                  return {
                    type: "operation" as const,
                    operator: "||",
                    args: [reducedExpression, langEqualsExpression],
                  };
                },
                null as sparqljs.Expression | null,
              ) as sparqljs.Expression,
            }))
            .concat(),
          type: "group",
        },
        {
          patterns: $StringFilter
            .$sparqlWherePatterns(
              parameters?.filter?.mutableSetProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableSetProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.mutableStringProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableStringProperty`,
                  ),
                  predicate:
                    MutablePropertiesClass.$properties.mutableStringProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [parameters?.preferredLanguages ?? []]
                .filter((languages) => languages.length > 0)
                .map((languages) =>
                  languages.map((language) => ({
                    type: "operation" as const,
                    operator: "=",
                    args: [
                      {
                        type: "operation" as const,
                        operator: "lang",
                        args: [
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableStringProperty`,
                          ),
                        ],
                      },
                      dataFactory.literal(language),
                    ],
                  })),
                )
                .map((langEqualsExpressions) => ({
                  type: "filter" as const,
                  expression: langEqualsExpressions.reduce(
                    (reducedExpression, langEqualsExpression) => {
                      if (reducedExpression === null) {
                        return langEqualsExpression;
                      }
                      return {
                        type: "operation" as const,
                        operator: "||",
                        args: [reducedExpression, langEqualsExpression],
                      };
                    },
                    null as sparqljs.Expression | null,
                  ) as sparqljs.Expression,
                }))
                .concat(),
              type: "group",
            },
            {
              patterns: $StringFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableStringProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    return patterns;
  }

  export function isMutablePropertiesClass(
    object: $Object,
  ): object is MutablePropertiesClass {
    switch (object.$type) {
      case "MutablePropertiesClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Shape that uses the list shapes in properties.
 */
export class ListPropertiesClass {
  private _$identifier?: ListPropertiesClass.$Identifier;
  readonly $type = "ListPropertiesClass";
  readonly iriListProperty: purify.Maybe<readonly rdfjs.NamedNode[]>;
  readonly objectListProperty: purify.Maybe<readonly NonClass[]>;
  readonly stringListProperty: purify.Maybe<readonly string[]>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly iriListProperty?:
      | purify.Maybe<readonly rdfjs.NamedNode[]>
      | readonly rdfjs.NamedNode[]
      | readonly string[];
    readonly objectListProperty?:
      | purify.Maybe<readonly NonClass[]>
      | readonly NonClass[];
    readonly stringListProperty?:
      | purify.Maybe<readonly string[]>
      | readonly string[];
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.iriListProperty)) {
      this.iriListProperty = parameters?.iriListProperty;
    } else if (typeof parameters?.iriListProperty === "undefined") {
      this.iriListProperty = purify.Maybe.of([]);
    } else if ($isReadonlyObjectArray(parameters?.iriListProperty)) {
      this.iriListProperty = purify.Maybe.of(parameters?.iriListProperty);
    } else if ($isReadonlyStringArray(parameters?.iriListProperty)) {
      this.iriListProperty = purify.Maybe.of(
        parameters?.iriListProperty.map((item) => dataFactory.namedNode(item)),
      );
    } else {
      this.iriListProperty = parameters?.iriListProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.objectListProperty)) {
      this.objectListProperty = parameters?.objectListProperty;
    } else if (typeof parameters?.objectListProperty === "undefined") {
      this.objectListProperty = purify.Maybe.of([]);
    } else if (typeof parameters?.objectListProperty === "object") {
      this.objectListProperty = purify.Maybe.of(parameters?.objectListProperty);
    } else {
      this.objectListProperty = parameters?.objectListProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.stringListProperty)) {
      this.stringListProperty = parameters?.stringListProperty;
    } else if (typeof parameters?.stringListProperty === "undefined") {
      this.stringListProperty = purify.Maybe.of([]);
    } else if (typeof parameters?.stringListProperty === "object") {
      this.stringListProperty = purify.Maybe.of(parameters?.stringListProperty);
    } else {
      this.stringListProperty = parameters?.stringListProperty satisfies never;
    }
  }

  get $identifier(): ListPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: ListPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) =>
            $arrayEquals(left, right, $booleanEquals),
          ))(this.iriListProperty, other.iriListProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "iriListProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) =>
            $arrayEquals(left, right, (left, right) => left.$equals(right)),
          ))(this.objectListProperty, other.objectListProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "objectListProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) =>
            $arrayEquals(left, right, $strictEquals),
          ))(this.stringListProperty, other.stringListProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "stringListProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.iriListProperty.ifJust((value0) => {
      for (const item1 of value0) {
        _hasher.update(item1.termType);
        _hasher.update(item1.value);
      }
    });
    this.objectListProperty.ifJust((value0) => {
      for (const item1 of value0) {
        item1.$hash(_hasher);
      }
    });
    this.stringListProperty.ifJust((value0) => {
      for (const item1 of value0) {
        _hasher.update(item1);
      }
    });
    return _hasher;
  }

  $toJson(): ListPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        iriListProperty: this.iriListProperty
          .map((item) => item.map((item) => ({ "@id": item.value })))
          .extract(),
        objectListProperty: this.objectListProperty
          .map((item) => item.map((item) => item.$toJson()))
          .extract(),
        stringListProperty: this.stringListProperty
          .map((item) => item.map((item) => item))
          .extract(),
      } satisfies ListPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      ListPropertiesClass.$properties.iriListProperty["identifier"],
      ...this.iriListProperty.toList().flatMap((value) => [
        value.length > 0
          ? value.reduce(
              (
                { currentSubListResource, listResource },
                item,
                itemIndex,
                list,
              ) => {
                if (itemIndex === 0) {
                  currentSubListResource = listResource;
                } else {
                  const newSubListResource = resourceSet.mutableResource(
                    dataFactory.blankNode(),
                    { mutateGraph },
                  );
                  currentSubListResource!.add(
                    $RdfVocabularies.rdf.rest,
                    newSubListResource.identifier,
                  );
                  currentSubListResource = newSubListResource;
                }

                currentSubListResource.add(
                  $RdfVocabularies.rdf.first,
                  ...[item],
                );

                if (itemIndex + 1 === list.length) {
                  currentSubListResource.add(
                    $RdfVocabularies.rdf.rest,
                    $RdfVocabularies.rdf.nil,
                  );
                }

                return { currentSubListResource, listResource };
              },
              {
                currentSubListResource: null,
                listResource: resourceSet.mutableResource(
                  dataFactory.blankNode(),
                  { mutateGraph },
                ),
              } as {
                currentSubListResource: rdfjsResource.MutableResource | null;
                listResource: rdfjsResource.MutableResource;
              },
            ).listResource.identifier
          : $RdfVocabularies.rdf.nil,
      ]),
    );
    resource.add(
      ListPropertiesClass.$properties.objectListProperty["identifier"],
      ...this.objectListProperty.toList().flatMap((value) => [
        value.length > 0
          ? value.reduce(
              (
                { currentSubListResource, listResource },
                item,
                itemIndex,
                list,
              ) => {
                if (itemIndex === 0) {
                  currentSubListResource = listResource;
                } else {
                  const newSubListResource = resourceSet.mutableResource(
                    dataFactory.blankNode(),
                    { mutateGraph },
                  );
                  currentSubListResource!.add(
                    $RdfVocabularies.rdf.rest,
                    newSubListResource.identifier,
                  );
                  currentSubListResource = newSubListResource;
                }

                currentSubListResource.add(
                  $RdfVocabularies.rdf.first,
                  ...[
                    item.$toRdf({
                      mutateGraph: mutateGraph,
                      resourceSet: resourceSet,
                    }).identifier,
                  ],
                );

                if (itemIndex + 1 === list.length) {
                  currentSubListResource.add(
                    $RdfVocabularies.rdf.rest,
                    $RdfVocabularies.rdf.nil,
                  );
                }

                return { currentSubListResource, listResource };
              },
              {
                currentSubListResource: null,
                listResource: resourceSet.mutableResource(
                  dataFactory.blankNode(),
                  { mutateGraph },
                ),
              } as {
                currentSubListResource: rdfjsResource.MutableResource | null;
                listResource: rdfjsResource.MutableResource;
              },
            ).listResource.identifier
          : $RdfVocabularies.rdf.nil,
      ]),
    );
    resource.add(
      ListPropertiesClass.$properties.stringListProperty["identifier"],
      ...this.stringListProperty.toList().flatMap((value) => [
        value.length > 0
          ? value.reduce(
              (
                { currentSubListResource, listResource },
                item,
                itemIndex,
                list,
              ) => {
                if (itemIndex === 0) {
                  currentSubListResource = listResource;
                } else {
                  const newSubListResource = resourceSet.mutableResource(
                    dataFactory.blankNode(),
                    { mutateGraph },
                  );
                  currentSubListResource!.add(
                    $RdfVocabularies.rdf.rest,
                    newSubListResource.identifier,
                  );
                  currentSubListResource = newSubListResource;
                }

                currentSubListResource.add(
                  $RdfVocabularies.rdf.first,
                  ...[item],
                );

                if (itemIndex + 1 === list.length) {
                  currentSubListResource.add(
                    $RdfVocabularies.rdf.rest,
                    $RdfVocabularies.rdf.nil,
                  );
                }

                return { currentSubListResource, listResource };
              },
              {
                currentSubListResource: null,
                listResource: resourceSet.mutableResource(
                  dataFactory.blankNode(),
                  { mutateGraph },
                ),
              } as {
                currentSubListResource: rdfjsResource.MutableResource | null;
                listResource: rdfjsResource.MutableResource;
              },
            ).listResource.identifier
          : $RdfVocabularies.rdf.nil,
      ]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ListPropertiesClass {
  export function $filter(
    filter: ListPropertiesClass.$Filter,
    value: ListPropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.iriListProperty !== "undefined" &&
      !$filterMaybe<
        readonly rdfjs.NamedNode[],
        $CollectionFilter<$NamedNodeFilter>
      >($filterArray<rdfjs.NamedNode, $NamedNodeFilter>($filterNamedNode))(
        filter.iriListProperty,
        value.iriListProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.objectListProperty !== "undefined" &&
      !$filterMaybe<readonly NonClass[], $CollectionFilter<NonClass.$Filter>>(
        $filterArray<NonClass, NonClass.$Filter>(NonClass.$filter),
      )(filter.objectListProperty, value.objectListProperty)
    ) {
      return false;
    }

    if (
      typeof filter.stringListProperty !== "undefined" &&
      !$filterMaybe<readonly string[], $CollectionFilter<$StringFilter>>(
        $filterArray<string, $StringFilter>($filterString),
      )(filter.stringListProperty, value.stringListProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly iriListProperty?: $MaybeFilter<
      $CollectionFilter<$NamedNodeFilter>
    >;
    readonly objectListProperty?: $MaybeFilter<
      $CollectionFilter<NonClass.$Filter>
    >;
    readonly stringListProperty?: $MaybeFilter<
      $CollectionFilter<$StringFilter>
    >;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ListPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ListPropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ListPropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ListPropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ListPropertiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ListPropertiesClass";
    readonly iriListProperty?: readonly { readonly "@id": string }[];
    readonly objectListProperty?: readonly NonClass.$Json[];
    readonly stringListProperty?: readonly string[];
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ListPropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/iriListProperty`, type: "Control" },
        NonClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/objectListProperty`,
        }),
        {
          scope: `${scopePrefix}/properties/stringListProperty`,
          type: "Control",
        },
      ],
      label: "ListPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("ListPropertiesClass"),
      iriListProperty: zod
        .object({ "@id": zod.string().min(1) })
        .array()
        .default(() => [])
        .optional(),
      objectListProperty: NonClass.$jsonZodSchema()
        .array()
        .default(() => [])
        .optional(),
      stringListProperty: zod
        .string()
        .array()
        .default(() => [])
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    iriListProperty: {
      identifier: dataFactory.namedNode("http://example.com/iriListProperty"),
    },
    objectListProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/objectListProperty",
      ),
    },
    stringListProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/stringListProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      iriListProperty: purify.Maybe<readonly rdfjs.NamedNode[]>;
      objectListProperty: purify.Maybe<readonly NonClass[]>;
      stringListProperty: purify.Maybe<readonly string[]>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const iriListProperty = purify.Maybe.fromNullable(
      $jsonObject["iriListProperty"],
    ).map((item) => item.map((item) => dataFactory.namedNode(item["@id"])));
    const objectListProperty = purify.Maybe.fromNullable(
      $jsonObject["objectListProperty"],
    ).map((item) =>
      item.map((item) => NonClass.$fromJson(item).unsafeCoerce()),
    );
    const stringListProperty = purify.Maybe.fromNullable(
      $jsonObject["stringListProperty"],
    );
    return purify.Either.of({
      $identifier,
      iriListProperty,
      objectListProperty,
      stringListProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      iriListProperty: purify.Maybe<readonly rdfjs.NamedNode[]>;
      objectListProperty: purify.Maybe<readonly NonClass[]>;
      stringListProperty: purify.Maybe<readonly string[]>;
    }
  > {
    return purify.Either.of<Error, ListPropertiesClass.$Identifier>(
      $parameters.resource.identifier as ListPropertiesClass.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values($properties.iriListProperty["identifier"], {
          unique: true,
        }),
      )
        .chain((values) => values.chainMap((value) => value.toList()))
        .chain((valueLists) =>
          valueLists.chainMap((valueList) =>
            purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
            >(
              rdfjsResource.Resource.Values.fromArray({
                focusResource: $parameters.resource,
                predicate:
                  ListPropertiesClass.$properties.iriListProperty["identifier"],
                values: valueList,
              }),
            ).chain((values) => values.chainMap((value) => value.toIri())),
          ),
        )
        .map((valueLists) => valueLists.map((valueList) => valueList.toArray()))
        .map((values) =>
          values.length > 0
            ? values.map((value) => purify.Maybe.of(value))
            : rdfjsResource.Resource.Values.fromValue<
                purify.Maybe<readonly rdfjs.NamedNode[]>
              >({
                focusResource: $parameters.resource,
                predicate:
                  ListPropertiesClass.$properties.iriListProperty["identifier"],
                value: purify.Maybe.empty(),
              }),
        )
        .chain((values) => values.head())
        .chain((iriListProperty) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.objectListProperty["identifier"],
              { unique: true },
            ),
          )
            .chain((values) => values.chainMap((value) => value.toList()))
            .chain((valueLists) =>
              valueLists.chainMap((valueList) =>
                purify.Either.of<
                  Error,
                  rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                >(
                  rdfjsResource.Resource.Values.fromArray({
                    focusResource: $parameters.resource,
                    predicate:
                      ListPropertiesClass.$properties.objectListProperty[
                        "identifier"
                      ],
                    values: valueList,
                  }),
                ).chain((values) =>
                  values.chainMap((value) =>
                    value.toResource().chain((resource) =>
                      NonClass.$fromRdf(resource, {
                        context: $parameters.context,
                        ignoreRdfType: true,
                        objectSet: $parameters.objectSet,
                        preferredLanguages: $parameters.preferredLanguages,
                      }),
                    ),
                  ),
                ),
              ),
            )
            .map((valueLists) =>
              valueLists.map((valueList) => valueList.toArray()),
            )
            .map((values) =>
              values.length > 0
                ? values.map((value) => purify.Maybe.of(value))
                : rdfjsResource.Resource.Values.fromValue<
                    purify.Maybe<readonly NonClass[]>
                  >({
                    focusResource: $parameters.resource,
                    predicate:
                      ListPropertiesClass.$properties.objectListProperty[
                        "identifier"
                      ],
                    value: purify.Maybe.empty(),
                  }),
            )
            .chain((values) => values.head())
            .chain((objectListProperty) =>
              purify.Either.of<
                Error,
                rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
              >(
                $parameters.resource.values(
                  $properties.stringListProperty["identifier"],
                  { unique: true },
                ),
              )
                .chain((values) => values.chainMap((value) => value.toList()))
                .chain((valueLists) =>
                  valueLists.chainMap((valueList) =>
                    purify.Either.of<
                      Error,
                      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                    >(
                      rdfjsResource.Resource.Values.fromArray({
                        focusResource: $parameters.resource,
                        predicate:
                          ListPropertiesClass.$properties.stringListProperty[
                            "identifier"
                          ],
                        values: valueList,
                      }),
                    )
                      .chain((values) =>
                        $fromRdfPreferredLanguages({
                          focusResource: $parameters.resource,
                          predicate:
                            ListPropertiesClass.$properties.stringListProperty[
                              "identifier"
                            ],
                          preferredLanguages: $parameters.preferredLanguages,
                          values,
                        }),
                      )
                      .chain((values) =>
                        values.chainMap((value) => value.toString()),
                      ),
                  ),
                )
                .map((valueLists) =>
                  valueLists.map((valueList) => valueList.toArray()),
                )
                .map((values) =>
                  values.length > 0
                    ? values.map((value) => purify.Maybe.of(value))
                    : rdfjsResource.Resource.Values.fromValue<
                        purify.Maybe<readonly string[]>
                      >({
                        focusResource: $parameters.resource,
                        predicate:
                          ListPropertiesClass.$properties.stringListProperty[
                            "identifier"
                          ],
                        value: purify.Maybe.empty(),
                      }),
                )
                .chain((values) => values.head())
                .map((stringListProperty) => ({
                  $identifier,
                  iriListProperty,
                  objectListProperty,
                  stringListProperty,
                })),
            ),
        ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ListPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ListPropertiesClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ListPropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ListPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ListPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("listPropertiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`,
      ),
      predicate: ListPropertiesClass.$properties.iriListProperty["identifier"],
      subject,
    });
    triples.push({
      subject: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`,
      ),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}Item0`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`,
      ),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}Rest0`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}ItemN`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}RestNBasic`,
      ),
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`,
      ),
      predicate:
        ListPropertiesClass.$properties.objectListProperty["identifier"],
      subject,
    });
    triples.push({
      subject: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`,
      ),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}Item0`,
      ),
    });
    triples.push(
      ...NonClass.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}Item0`,
        ),
        variablePrefix: `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}Item0`,
      }),
    );
    triples.push({
      subject: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`,
      ),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}Rest0`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}ItemN`,
      ),
    });
    triples.push(
      ...NonClass.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}ItemN`,
        ),
        variablePrefix: `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}ItemN`,
      }),
    );
    triples.push({
      subject: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}RestNBasic`,
      ),
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`,
      ),
      predicate:
        ListPropertiesClass.$properties.stringListProperty["identifier"],
      subject,
    });
    triples.push({
      subject: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`,
      ),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}Item0`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`,
      ),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}Rest0`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}ItemN`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}RestNBasic`,
      ),
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ListPropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("listPropertiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.iriListProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`,
                  ),
                  predicate:
                    ListPropertiesClass.$properties.iriListProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}Item0`,
                      ),
                      predicate: $RdfVocabularies.rdf.first,
                      subject: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`,
                      ),
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: $NamedNodeFilter
                    .$sparqlWherePatterns(
                      itemFilter,
                      dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}Item0`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}Rest0`,
                      ),
                      predicate: $RdfVocabularies.rdf.rest,
                      subject: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`,
                      ),
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}RestN`,
                          ),
                          predicate: {
                            type: "path",
                            pathType: "*",
                            items: [$RdfVocabularies.rdf.rest],
                          },
                          subject: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}ItemN`,
                          ),
                          predicate: $RdfVocabularies.rdf.first,
                          subject: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}RestN`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: $NamedNodeFilter
                        .$sparqlWherePatterns(
                          itemFilter,
                          dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}ItemN`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}RestNBasic`,
                          ),
                          predicate: $RdfVocabularies.rdf.rest,
                          subject: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}RestN`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                  ],
                  type: "optional",
                },
              ],
              type: "optional",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.objectListProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`,
                  ),
                  predicate:
                    ListPropertiesClass.$properties.objectListProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}Item0`,
                      ),
                      predicate: $RdfVocabularies.rdf.first,
                      subject: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`,
                      ),
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: NonClass.$sparqlWherePatterns({
                    filter: itemFilter,
                    ignoreRdfType: true,
                    preferredLanguages: parameters?.preferredLanguages,
                    subject: dataFactory.variable!(
                      `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}Item0`,
                    ),
                    variablePrefix: `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}Item0`,
                  }).concat(),
                  type: "group",
                },
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}Rest0`,
                      ),
                      predicate: $RdfVocabularies.rdf.rest,
                      subject: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`,
                      ),
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}RestN`,
                          ),
                          predicate: {
                            type: "path",
                            pathType: "*",
                            items: [$RdfVocabularies.rdf.rest],
                          },
                          subject: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}ItemN`,
                          ),
                          predicate: $RdfVocabularies.rdf.first,
                          subject: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}RestN`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: NonClass.$sparqlWherePatterns({
                        filter: itemFilter,
                        ignoreRdfType: true,
                        preferredLanguages: parameters?.preferredLanguages,
                        subject: dataFactory.variable!(
                          `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}ItemN`,
                        ),
                        variablePrefix: `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}ItemN`,
                      }).concat(),
                      type: "group",
                    },
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}RestNBasic`,
                          ),
                          predicate: $RdfVocabularies.rdf.rest,
                          subject: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}RestN`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                  ],
                  type: "optional",
                },
              ],
              type: "optional",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.stringListProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`,
                  ),
                  predicate:
                    ListPropertiesClass.$properties.stringListProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}Item0`,
                      ),
                      predicate: $RdfVocabularies.rdf.first,
                      subject: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`,
                      ),
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: [parameters?.preferredLanguages ?? []]
                    .filter((languages) => languages.length > 0)
                    .map((languages) =>
                      languages.map((language) => ({
                        type: "operation" as const,
                        operator: "=",
                        args: [
                          {
                            type: "operation" as const,
                            operator: "lang",
                            args: [
                              dataFactory.variable!(
                                `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}Item0`,
                              ),
                            ],
                          },
                          dataFactory.literal(language),
                        ],
                      })),
                    )
                    .map((langEqualsExpressions) => ({
                      type: "filter" as const,
                      expression: langEqualsExpressions.reduce(
                        (reducedExpression, langEqualsExpression) => {
                          if (reducedExpression === null) {
                            return langEqualsExpression;
                          }
                          return {
                            type: "operation" as const,
                            operator: "||",
                            args: [reducedExpression, langEqualsExpression],
                          };
                        },
                        null as sparqljs.Expression | null,
                      ) as sparqljs.Expression,
                    }))
                    .concat(),
                  type: "group",
                },
                {
                  patterns: $StringFilter
                    .$sparqlWherePatterns(
                      itemFilter,
                      dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}Item0`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}Rest0`,
                      ),
                      predicate: $RdfVocabularies.rdf.rest,
                      subject: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`,
                      ),
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}RestN`,
                          ),
                          predicate: {
                            type: "path",
                            pathType: "*",
                            items: [$RdfVocabularies.rdf.rest],
                          },
                          subject: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}ItemN`,
                          ),
                          predicate: $RdfVocabularies.rdf.first,
                          subject: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}RestN`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: [parameters?.preferredLanguages ?? []]
                        .filter((languages) => languages.length > 0)
                        .map((languages) =>
                          languages.map((language) => ({
                            type: "operation" as const,
                            operator: "=",
                            args: [
                              {
                                type: "operation" as const,
                                operator: "lang",
                                args: [
                                  dataFactory.variable!(
                                    `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}ItemN`,
                                  ),
                                ],
                              },
                              dataFactory.literal(language),
                            ],
                          })),
                        )
                        .map((langEqualsExpressions) => ({
                          type: "filter" as const,
                          expression: langEqualsExpressions.reduce(
                            (reducedExpression, langEqualsExpression) => {
                              if (reducedExpression === null) {
                                return langEqualsExpression;
                              }
                              return {
                                type: "operation" as const,
                                operator: "||",
                                args: [reducedExpression, langEqualsExpression],
                              };
                            },
                            null as sparqljs.Expression | null,
                          ) as sparqljs.Expression,
                        }))
                        .concat(),
                      type: "group",
                    },
                    {
                      patterns: $StringFilter
                        .$sparqlWherePatterns(
                          itemFilter,
                          dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}ItemN`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}RestNBasic`,
                          ),
                          predicate: $RdfVocabularies.rdf.rest,
                          subject: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}RestN`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                  ],
                  type: "optional",
                },
              ],
              type: "optional",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    return patterns;
  }

  export function isListPropertiesClass(
    object: $Object,
  ): object is ListPropertiesClass {
    switch (object.$type) {
      case "ListPropertiesClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape used as a partial by LazyPropertiesInterface
 */
export interface PartialInterface {
  readonly $identifier: PartialInterface.$Identifier;
  readonly $type: "PartialInterface";
  readonly lazilyResolvedStringProperty: string;
}

export namespace PartialInterface {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): PartialInterface {
    let $identifier: PartialInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "PartialInterface" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: PartialInterface,
    right: PartialInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export function $filter(
    filter: PartialInterface.$Filter,
    value: PartialInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialInterface> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PartialInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_partialInterface: PartialInterface, _hasher: HasherT): HasherT {
    _hasher.update(_partialInterface.$identifier.value);
    _hasher.update(_partialInterface.$type);
    PartialInterface.$hashShaclProperties(_partialInterface, _hasher);
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_partialInterface: PartialInterface, _hasher: HasherT): HasherT {
    _hasher.update(_partialInterface.lazilyResolvedStringProperty);
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialInterface";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialInterface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialInterface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PartialInterface"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "PartialInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "PartialInterface" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "PartialInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    return purify.Either.of<Error, PartialInterface.$Identifier>(
      $parameters.resource.identifier as PartialInterface.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<Error, "PartialInterface">("PartialInterface").chain(
        ($type) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.lazilyResolvedStringProperty["identifier"],
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  PartialInterface.$properties.lazilyResolvedStringProperty[
                    "identifier"
                  ],
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((lazilyResolvedStringProperty) => ({
              $identifier,
              $type,
              lazilyResolvedStringProperty,
            })),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialInterface.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            PartialInterface.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialInterface");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterface")}LazilyResolvedStringProperty`,
      ),
      predicate:
        PartialInterface.$properties.lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialInterface");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterface")}LazilyResolvedStringProperty`,
            ),
            predicate:
              PartialInterface.$properties.lazilyResolvedStringProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterface")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterface")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _partialInterface: PartialInterface,
  ): PartialInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _partialInterface.$identifier.termType === "BlankNode"
            ? `_:${_partialInterface.$identifier.value}`
            : _partialInterface.$identifier.value,
        $type: _partialInterface.$type,
        lazilyResolvedStringProperty:
          _partialInterface.lazilyResolvedStringProperty,
      } satisfies PartialInterface.$Json),
    );
  }

  export function $toRdf(
    _partialInterface: PartialInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _partialInterface.$identifier,
      { mutateGraph },
    );
    resource.add(
      PartialInterface.$properties.lazilyResolvedStringProperty["identifier"],
      ...[_partialInterface.lazilyResolvedStringProperty],
    );
    return resource;
  }

  export function isPartialInterface(
    object: $Object,
  ): object is PartialInterface {
    switch (object.$type) {
      case "PartialInterface":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape that has lazy properties.
 */
export interface LazyPropertiesInterface {
  readonly $identifier: LazyPropertiesInterface.$Identifier;
  readonly $type: "LazyPropertiesInterface";
  readonly optionalLazyToResolvedInterfaceProperty: $LazyObjectOption<
    LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriIdentifierInterface
  >;
  readonly optionalLazyToResolvedInterfaceUnionProperty: $LazyObjectOption<
    LazilyResolvedInterfaceUnion.$Identifier,
    $DefaultPartial,
    LazilyResolvedInterfaceUnion
  >;
  readonly optionalLazyToResolvedIriIdentifierInterfaceProperty: $LazyObjectOption<
    LazilyResolvedIriIdentifierInterface.$Identifier,
    $NamedDefaultPartial,
    LazilyResolvedIriIdentifierInterface
  >;
  readonly optionalPartialInterfaceToResolvedInterfaceProperty: $LazyObjectOption<
    LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
    PartialInterface,
    LazilyResolvedBlankNodeOrIriIdentifierInterface
  >;
  readonly optionalPartialInterfaceToResolvedInterfaceUnionProperty: $LazyObjectOption<
    LazilyResolvedInterfaceUnion.$Identifier,
    PartialInterface,
    LazilyResolvedInterfaceUnion
  >;
  readonly optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty: $LazyObjectOption<
    LazilyResolvedInterfaceUnion.$Identifier,
    PartialInterfaceUnion,
    LazilyResolvedInterfaceUnion
  >;
  readonly requiredLazyToResolvedInterfaceProperty: $LazyObject<
    LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriIdentifierInterface
  >;
  readonly requiredPartialInterfaceToResolvedInterfaceProperty: $LazyObject<
    LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
    PartialInterface,
    LazilyResolvedBlankNodeOrIriIdentifierInterface
  >;
  readonly setLazyToResolvedInterfaceProperty: $LazyObjectSet<
    LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriIdentifierInterface
  >;
  readonly setPartialInterfaceToResolvedInterfaceProperty: $LazyObjectSet<
    LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
    PartialInterface,
    LazilyResolvedBlankNodeOrIriIdentifierInterface
  >;
}

export namespace LazyPropertiesInterface {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly optionalLazyToResolvedInterfaceProperty?:
      | $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >
      | LazilyResolvedBlankNodeOrIriIdentifierInterface
      | purify.Maybe<LazilyResolvedBlankNodeOrIriIdentifierInterface>;
    readonly optionalLazyToResolvedInterfaceUnionProperty?:
      | $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          $DefaultPartial,
          LazilyResolvedInterfaceUnion
        >
      | LazilyResolvedInterfaceUnion
      | purify.Maybe<LazilyResolvedInterfaceUnion>;
    readonly optionalLazyToResolvedIriIdentifierInterfaceProperty?:
      | $LazyObjectOption<
          LazilyResolvedIriIdentifierInterface.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierInterface
        >
      | LazilyResolvedIriIdentifierInterface
      | purify.Maybe<LazilyResolvedIriIdentifierInterface>;
    readonly optionalPartialInterfaceToResolvedInterfaceProperty?:
      | $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >
      | LazilyResolvedBlankNodeOrIriIdentifierInterface
      | purify.Maybe<LazilyResolvedBlankNodeOrIriIdentifierInterface>;
    readonly optionalPartialInterfaceToResolvedInterfaceUnionProperty?:
      | $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterface,
          LazilyResolvedInterfaceUnion
        >
      | LazilyResolvedInterfaceUnion
      | purify.Maybe<LazilyResolvedInterfaceUnion>;
    readonly optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty?:
      | $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterfaceUnion,
          LazilyResolvedInterfaceUnion
        >
      | LazilyResolvedInterfaceUnion
      | purify.Maybe<LazilyResolvedInterfaceUnion>;
    readonly requiredLazyToResolvedInterfaceProperty:
      | $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >
      | LazilyResolvedBlankNodeOrIriIdentifierInterface;
    readonly requiredPartialInterfaceToResolvedInterfaceProperty:
      | $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >
      | LazilyResolvedBlankNodeOrIriIdentifierInterface;
    readonly setLazyToResolvedInterfaceProperty?:
      | $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >
      | readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[];
    readonly setPartialInterfaceToResolvedInterfaceProperty?:
      | $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >
      | readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[];
  }): LazyPropertiesInterface {
    let $identifier: LazyPropertiesInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "LazyPropertiesInterface" as const;
    let optionalLazyToResolvedInterfaceProperty: $LazyObjectOption<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >;
    if (
      typeof parameters.optionalLazyToResolvedInterfaceProperty === "object" &&
      parameters.optionalLazyToResolvedInterfaceProperty instanceof
        $LazyObjectOption
    ) {
      optionalLazyToResolvedInterfaceProperty =
        parameters.optionalLazyToResolvedInterfaceProperty;
    } else if (
      purify.Maybe.isMaybe(parameters.optionalLazyToResolvedInterfaceProperty)
    ) {
      optionalLazyToResolvedInterfaceProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partial: parameters.optionalLazyToResolvedInterfaceProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          purify.Either.of(
            (
              parameters.optionalLazyToResolvedInterfaceProperty as purify.Maybe<LazilyResolvedBlankNodeOrIriIdentifierInterface>
            ).unsafeCoerce(),
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedInterfaceProperty === "object"
    ) {
      optionalLazyToResolvedInterfaceProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partial: purify.Maybe.of(
          new $DefaultPartial(
            parameters.optionalLazyToResolvedInterfaceProperty,
          ),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.optionalLazyToResolvedInterfaceProperty as LazilyResolvedBlankNodeOrIriIdentifierInterface,
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedInterfaceProperty === "undefined"
    ) {
      optionalLazyToResolvedInterfaceProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partial: purify.Maybe.empty(),
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      optionalLazyToResolvedInterfaceProperty =
        parameters.optionalLazyToResolvedInterfaceProperty satisfies never;
    }

    let optionalLazyToResolvedInterfaceUnionProperty: $LazyObjectOption<
      LazilyResolvedInterfaceUnion.$Identifier,
      $DefaultPartial,
      LazilyResolvedInterfaceUnion
    >;
    if (
      typeof parameters.optionalLazyToResolvedInterfaceUnionProperty ===
        "object" &&
      parameters.optionalLazyToResolvedInterfaceUnionProperty instanceof
        $LazyObjectOption
    ) {
      optionalLazyToResolvedInterfaceUnionProperty =
        parameters.optionalLazyToResolvedInterfaceUnionProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalLazyToResolvedInterfaceUnionProperty,
      )
    ) {
      optionalLazyToResolvedInterfaceUnionProperty = new $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >({
        partial: parameters.optionalLazyToResolvedInterfaceUnionProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          purify.Either.of(
            (
              parameters.optionalLazyToResolvedInterfaceUnionProperty as purify.Maybe<LazilyResolvedInterfaceUnion>
            ).unsafeCoerce(),
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedInterfaceUnionProperty ===
      "object"
    ) {
      optionalLazyToResolvedInterfaceUnionProperty = new $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >({
        partial: purify.Maybe.of(
          new $DefaultPartial(
            parameters.optionalLazyToResolvedInterfaceUnionProperty,
          ),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.optionalLazyToResolvedInterfaceUnionProperty as LazilyResolvedInterfaceUnion,
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedInterfaceUnionProperty ===
      "undefined"
    ) {
      optionalLazyToResolvedInterfaceUnionProperty = new $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >({
        partial: purify.Maybe.empty(),
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      optionalLazyToResolvedInterfaceUnionProperty =
        parameters.optionalLazyToResolvedInterfaceUnionProperty satisfies never;
    }

    let optionalLazyToResolvedIriIdentifierInterfaceProperty: $LazyObjectOption<
      LazilyResolvedIriIdentifierInterface.$Identifier,
      $NamedDefaultPartial,
      LazilyResolvedIriIdentifierInterface
    >;
    if (
      typeof parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty ===
        "object" &&
      parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty instanceof
        $LazyObjectOption
    ) {
      optionalLazyToResolvedIriIdentifierInterfaceProperty =
        parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty,
      )
    ) {
      optionalLazyToResolvedIriIdentifierInterfaceProperty =
        new $LazyObjectOption<
          LazilyResolvedIriIdentifierInterface.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierInterface
        >({
          partial:
            parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty.map(
              (object) => new $NamedDefaultPartial(object),
            ),
          resolver: async () =>
            purify.Either.of(
              (
                parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty as purify.Maybe<LazilyResolvedIriIdentifierInterface>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty ===
      "object"
    ) {
      optionalLazyToResolvedIriIdentifierInterfaceProperty =
        new $LazyObjectOption<
          LazilyResolvedIriIdentifierInterface.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierInterface
        >({
          partial: purify.Maybe.of(
            new $NamedDefaultPartial(
              parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty,
            ),
          ),
          resolver: async () =>
            purify.Either.of(
              parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty as LazilyResolvedIriIdentifierInterface,
            ),
        });
    } else if (
      typeof parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty ===
      "undefined"
    ) {
      optionalLazyToResolvedIriIdentifierInterfaceProperty =
        new $LazyObjectOption<
          LazilyResolvedIriIdentifierInterface.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierInterface
        >({
          partial: purify.Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      optionalLazyToResolvedIriIdentifierInterfaceProperty =
        parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty satisfies never;
    }

    let optionalPartialInterfaceToResolvedInterfaceProperty: $LazyObjectOption<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      PartialInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >;
    if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceProperty ===
        "object" &&
      parameters.optionalPartialInterfaceToResolvedInterfaceProperty instanceof
        $LazyObjectOption
    ) {
      optionalPartialInterfaceToResolvedInterfaceProperty =
        parameters.optionalPartialInterfaceToResolvedInterfaceProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalPartialInterfaceToResolvedInterfaceProperty,
      )
    ) {
      optionalPartialInterfaceToResolvedInterfaceProperty =
        new $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >({
          partial:
            parameters.optionalPartialInterfaceToResolvedInterfaceProperty.map(
              (object) => PartialInterface.$create(object),
            ),
          resolver: async () =>
            purify.Either.of(
              (
                parameters.optionalPartialInterfaceToResolvedInterfaceProperty as purify.Maybe<LazilyResolvedBlankNodeOrIriIdentifierInterface>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceProperty ===
      "object"
    ) {
      optionalPartialInterfaceToResolvedInterfaceProperty =
        new $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >({
          partial: purify.Maybe.of(
            PartialInterface.$create(
              parameters.optionalPartialInterfaceToResolvedInterfaceProperty,
            ),
          ),
          resolver: async () =>
            purify.Either.of(
              parameters.optionalPartialInterfaceToResolvedInterfaceProperty as LazilyResolvedBlankNodeOrIriIdentifierInterface,
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceProperty ===
      "undefined"
    ) {
      optionalPartialInterfaceToResolvedInterfaceProperty =
        new $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >({
          partial: purify.Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      optionalPartialInterfaceToResolvedInterfaceProperty =
        parameters.optionalPartialInterfaceToResolvedInterfaceProperty satisfies never;
    }

    let optionalPartialInterfaceToResolvedInterfaceUnionProperty: $LazyObjectOption<
      LazilyResolvedInterfaceUnion.$Identifier,
      PartialInterface,
      LazilyResolvedInterfaceUnion
    >;
    if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty ===
        "object" &&
      parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty instanceof
        $LazyObjectOption
    ) {
      optionalPartialInterfaceToResolvedInterfaceUnionProperty =
        parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
      )
    ) {
      optionalPartialInterfaceToResolvedInterfaceUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterface,
          LazilyResolvedInterfaceUnion
        >({
          partial:
            parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty.map(
              (object) => PartialInterface.$create(object),
            ),
          resolver: async () =>
            purify.Either.of(
              (
                parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty as purify.Maybe<LazilyResolvedInterfaceUnion>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty ===
      "object"
    ) {
      optionalPartialInterfaceToResolvedInterfaceUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterface,
          LazilyResolvedInterfaceUnion
        >({
          partial: purify.Maybe.of(
            PartialInterface.$create(
              parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
            ),
          ),
          resolver: async () =>
            purify.Either.of(
              parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty as LazilyResolvedInterfaceUnion,
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty ===
      "undefined"
    ) {
      optionalPartialInterfaceToResolvedInterfaceUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterface,
          LazilyResolvedInterfaceUnion
        >({
          partial: purify.Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      optionalPartialInterfaceToResolvedInterfaceUnionProperty =
        parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty satisfies never;
    }

    let optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty: $LazyObjectOption<
      LazilyResolvedInterfaceUnion.$Identifier,
      PartialInterfaceUnion,
      LazilyResolvedInterfaceUnion
    >;
    if (
      typeof parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty ===
        "object" &&
      parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty instanceof
        $LazyObjectOption
    ) {
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
        parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
      )
    ) {
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterfaceUnion,
          LazilyResolvedInterfaceUnion
        >({
          partial:
            parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty.map(
              (object) => {
                switch (object.$type) {
                  case "LazilyResolvedInterfaceUnionMember1":
                    return PartialInterfaceUnionMember1.$create(object);
                  case "LazilyResolvedInterfaceUnionMember2":
                    return PartialInterfaceUnionMember2.$create(object);
                  default:
                    object satisfies never;
                    throw new Error("unrecognized type");
                }
              },
            ),
          resolver: async () =>
            purify.Either.of(
              (
                parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty as purify.Maybe<LazilyResolvedInterfaceUnion>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty ===
      "object"
    ) {
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterfaceUnion,
          LazilyResolvedInterfaceUnion
        >({
          partial: purify.Maybe.of(
            parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
          ).map((object) => {
            switch (object.$type) {
              case "LazilyResolvedInterfaceUnionMember1":
                return PartialInterfaceUnionMember1.$create(object);
              case "LazilyResolvedInterfaceUnionMember2":
                return PartialInterfaceUnionMember2.$create(object);
              default:
                object satisfies never;
                throw new Error("unrecognized type");
            }
          }),
          resolver: async () =>
            purify.Either.of(
              parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty as LazilyResolvedInterfaceUnion,
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty ===
      "undefined"
    ) {
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterfaceUnion,
          LazilyResolvedInterfaceUnion
        >({
          partial: purify.Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
        parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty satisfies never;
    }

    let requiredLazyToResolvedInterfaceProperty: $LazyObject<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >;
    if (
      typeof parameters.requiredLazyToResolvedInterfaceProperty === "object" &&
      parameters.requiredLazyToResolvedInterfaceProperty instanceof $LazyObject
    ) {
      requiredLazyToResolvedInterfaceProperty =
        parameters.requiredLazyToResolvedInterfaceProperty;
    } else if (
      typeof parameters.requiredLazyToResolvedInterfaceProperty === "object"
    ) {
      requiredLazyToResolvedInterfaceProperty = new $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partial: new $DefaultPartial(
          parameters.requiredLazyToResolvedInterfaceProperty,
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.requiredLazyToResolvedInterfaceProperty as LazilyResolvedBlankNodeOrIriIdentifierInterface,
          ),
      });
    } else {
      requiredLazyToResolvedInterfaceProperty =
        parameters.requiredLazyToResolvedInterfaceProperty satisfies never;
    }

    let requiredPartialInterfaceToResolvedInterfaceProperty: $LazyObject<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      PartialInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >;
    if (
      typeof parameters.requiredPartialInterfaceToResolvedInterfaceProperty ===
        "object" &&
      parameters.requiredPartialInterfaceToResolvedInterfaceProperty instanceof
        $LazyObject
    ) {
      requiredPartialInterfaceToResolvedInterfaceProperty =
        parameters.requiredPartialInterfaceToResolvedInterfaceProperty;
    } else if (
      typeof parameters.requiredPartialInterfaceToResolvedInterfaceProperty ===
      "object"
    ) {
      requiredPartialInterfaceToResolvedInterfaceProperty = new $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partial: PartialInterface.$create(
          parameters.requiredPartialInterfaceToResolvedInterfaceProperty,
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.requiredPartialInterfaceToResolvedInterfaceProperty as LazilyResolvedBlankNodeOrIriIdentifierInterface,
          ),
      });
    } else {
      requiredPartialInterfaceToResolvedInterfaceProperty =
        parameters.requiredPartialInterfaceToResolvedInterfaceProperty satisfies never;
    }

    let setLazyToResolvedInterfaceProperty: $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >;
    if (
      typeof parameters.setLazyToResolvedInterfaceProperty === "object" &&
      parameters.setLazyToResolvedInterfaceProperty instanceof $LazyObjectSet
    ) {
      setLazyToResolvedInterfaceProperty =
        parameters.setLazyToResolvedInterfaceProperty;
    } else if (
      typeof parameters.setLazyToResolvedInterfaceProperty === "object"
    ) {
      setLazyToResolvedInterfaceProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partials: parameters.setLazyToResolvedInterfaceProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.setLazyToResolvedInterfaceProperty as readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[],
          ),
      });
    } else if (
      typeof parameters.setLazyToResolvedInterfaceProperty === "undefined"
    ) {
      setLazyToResolvedInterfaceProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partials: [],
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      setLazyToResolvedInterfaceProperty =
        parameters.setLazyToResolvedInterfaceProperty satisfies never;
    }

    let setPartialInterfaceToResolvedInterfaceProperty: $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      PartialInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >;
    if (
      typeof parameters.setPartialInterfaceToResolvedInterfaceProperty ===
        "object" &&
      parameters.setPartialInterfaceToResolvedInterfaceProperty instanceof
        $LazyObjectSet
    ) {
      setPartialInterfaceToResolvedInterfaceProperty =
        parameters.setPartialInterfaceToResolvedInterfaceProperty;
    } else if (
      typeof parameters.setPartialInterfaceToResolvedInterfaceProperty ===
      "object"
    ) {
      setPartialInterfaceToResolvedInterfaceProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partials: parameters.setPartialInterfaceToResolvedInterfaceProperty.map(
          (object) => PartialInterface.$create(object),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.setPartialInterfaceToResolvedInterfaceProperty as readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[],
          ),
      });
    } else if (
      typeof parameters.setPartialInterfaceToResolvedInterfaceProperty ===
      "undefined"
    ) {
      setPartialInterfaceToResolvedInterfaceProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partials: [],
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      setPartialInterfaceToResolvedInterfaceProperty =
        parameters.setPartialInterfaceToResolvedInterfaceProperty satisfies never;
    }

    return {
      $identifier,
      $type,
      optionalLazyToResolvedInterfaceProperty,
      optionalLazyToResolvedInterfaceUnionProperty,
      optionalLazyToResolvedIriIdentifierInterfaceProperty,
      optionalPartialInterfaceToResolvedInterfaceProperty,
      optionalPartialInterfaceToResolvedInterfaceUnionProperty,
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
      requiredLazyToResolvedInterfaceProperty,
      requiredPartialInterfaceToResolvedInterfaceProperty,
      setLazyToResolvedInterfaceProperty,
      setPartialInterfaceToResolvedInterfaceProperty,
    };
  }

  export function $equals(
    left: LazyPropertiesInterface,
    right: LazyPropertiesInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          left.optionalLazyToResolvedInterfaceProperty,
          right.optionalLazyToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "optionalLazyToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          left.optionalLazyToResolvedInterfaceUnionProperty,
          right.optionalLazyToResolvedInterfaceUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "optionalLazyToResolvedInterfaceUnionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          left.optionalLazyToResolvedIriIdentifierInterfaceProperty,
          right.optionalLazyToResolvedIriIdentifierInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "optionalLazyToResolvedIriIdentifierInterfaceProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, PartialInterface.$equals))(
            left.partial,
            right.partial,
          ))(
          left.optionalPartialInterfaceToResolvedInterfaceProperty,
          right.optionalPartialInterfaceToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "optionalPartialInterfaceToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, PartialInterface.$equals))(
            left.partial,
            right.partial,
          ))(
          left.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
          right.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName:
            "optionalPartialInterfaceToResolvedInterfaceUnionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, PartialInterfaceUnion.$equals))(
            left.partial,
            right.partial,
          ))(
          left.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
          right.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName:
            "optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) => left.$equals(right))(left.partial, right.partial))(
          left.requiredLazyToResolvedInterfaceProperty,
          right.requiredLazyToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "requiredLazyToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          PartialInterface.$equals(left.partial, right.partial))(
          left.requiredPartialInterfaceToResolvedInterfaceProperty,
          right.requiredPartialInterfaceToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "requiredPartialInterfaceToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $arrayEquals(left, right, (left, right) => left.$equals(right)))(
            left.partials,
            right.partials,
          ))(
          left.setLazyToResolvedInterfaceProperty,
          right.setLazyToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "setLazyToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $arrayEquals(left, right, PartialInterface.$equals))(
            left.partials,
            right.partials,
          ))(
          left.setPartialInterfaceToResolvedInterfaceProperty,
          right.setPartialInterfaceToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "setPartialInterfaceToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export function $filter(
    filter: LazyPropertiesInterface.$Filter,
    value: LazyPropertiesInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.optionalLazyToResolvedInterfaceProperty !== "undefined" &&
      !((
        filter: $MaybeFilter<$DefaultPartial.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >,
      ) =>
        $filterMaybe<$DefaultPartial, $DefaultPartial.$Filter>(
          $DefaultPartial.$filter,
        )(filter, value.partial))(
        filter.optionalLazyToResolvedInterfaceProperty,
        value.optionalLazyToResolvedInterfaceProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalLazyToResolvedInterfaceUnionProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<$DefaultPartial.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          $DefaultPartial,
          LazilyResolvedInterfaceUnion
        >,
      ) =>
        $filterMaybe<$DefaultPartial, $DefaultPartial.$Filter>(
          $DefaultPartial.$filter,
        )(filter, value.partial))(
        filter.optionalLazyToResolvedInterfaceUnionProperty,
        value.optionalLazyToResolvedInterfaceUnionProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalLazyToResolvedIriIdentifierInterfaceProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<$NamedDefaultPartial.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedIriIdentifierInterface.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierInterface
        >,
      ) =>
        $filterMaybe<$NamedDefaultPartial, $NamedDefaultPartial.$Filter>(
          $NamedDefaultPartial.$filter,
        )(filter, value.partial))(
        filter.optionalLazyToResolvedIriIdentifierInterfaceProperty,
        value.optionalLazyToResolvedIriIdentifierInterfaceProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalPartialInterfaceToResolvedInterfaceProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<PartialInterface.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >,
      ) =>
        $filterMaybe<PartialInterface, PartialInterface.$Filter>(
          PartialInterface.$filter,
        )(filter, value.partial))(
        filter.optionalPartialInterfaceToResolvedInterfaceProperty,
        value.optionalPartialInterfaceToResolvedInterfaceProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalPartialInterfaceToResolvedInterfaceUnionProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<PartialInterface.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterface,
          LazilyResolvedInterfaceUnion
        >,
      ) =>
        $filterMaybe<PartialInterface, PartialInterface.$Filter>(
          PartialInterface.$filter,
        )(filter, value.partial))(
        filter.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
        value.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<PartialInterfaceUnion.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterfaceUnion,
          LazilyResolvedInterfaceUnion
        >,
      ) =>
        $filterMaybe<PartialInterfaceUnion, PartialInterfaceUnion.$Filter>(
          PartialInterfaceUnion.$filter,
        )(filter, value.partial))(
        filter.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
        value.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.requiredLazyToResolvedInterfaceProperty !== "undefined" &&
      !((
        filter: $DefaultPartial.$Filter,
        value: $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >,
      ) => $DefaultPartial.$filter(filter, value.partial))(
        filter.requiredLazyToResolvedInterfaceProperty,
        value.requiredLazyToResolvedInterfaceProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.requiredPartialInterfaceToResolvedInterfaceProperty !==
        "undefined" &&
      !((
        filter: PartialInterface.$Filter,
        value: $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >,
      ) => PartialInterface.$filter(filter, value.partial))(
        filter.requiredPartialInterfaceToResolvedInterfaceProperty,
        value.requiredPartialInterfaceToResolvedInterfaceProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.setLazyToResolvedInterfaceProperty !== "undefined" &&
      !((
        filter: $CollectionFilter<$DefaultPartial.$Filter>,
        value: $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >,
      ) =>
        $filterArray<$DefaultPartial, $DefaultPartial.$Filter>(
          $DefaultPartial.$filter,
        )(filter, value.partials))(
        filter.setLazyToResolvedInterfaceProperty,
        value.setLazyToResolvedInterfaceProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.setPartialInterfaceToResolvedInterfaceProperty !==
        "undefined" &&
      !((
        filter: $CollectionFilter<PartialInterface.$Filter>,
        value: $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >,
      ) =>
        $filterArray<PartialInterface, PartialInterface.$Filter>(
          PartialInterface.$filter,
        )(filter, value.partials))(
        filter.setPartialInterfaceToResolvedInterfaceProperty,
        value.setPartialInterfaceToResolvedInterfaceProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly optionalLazyToResolvedInterfaceProperty?: $MaybeFilter<$DefaultPartial.$Filter>;
    readonly optionalLazyToResolvedInterfaceUnionProperty?: $MaybeFilter<$DefaultPartial.$Filter>;
    readonly optionalLazyToResolvedIriIdentifierInterfaceProperty?: $MaybeFilter<$NamedDefaultPartial.$Filter>;
    readonly optionalPartialInterfaceToResolvedInterfaceProperty?: $MaybeFilter<PartialInterface.$Filter>;
    readonly optionalPartialInterfaceToResolvedInterfaceUnionProperty?: $MaybeFilter<PartialInterface.$Filter>;
    readonly optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty?: $MaybeFilter<PartialInterfaceUnion.$Filter>;
    readonly requiredLazyToResolvedInterfaceProperty?: $DefaultPartial.$Filter;
    readonly requiredPartialInterfaceToResolvedInterfaceProperty?: PartialInterface.$Filter;
    readonly setLazyToResolvedInterfaceProperty?: $CollectionFilter<$DefaultPartial.$Filter>;
    readonly setPartialInterfaceToResolvedInterfaceProperty?: $CollectionFilter<PartialInterface.$Filter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazyPropertiesInterface> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazyPropertiesInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazyPropertiesInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazyPropertiesInterface: LazyPropertiesInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_lazyPropertiesInterface.$identifier.value);
    _hasher.update(_lazyPropertiesInterface.$type);
    LazyPropertiesInterface.$hashShaclProperties(
      _lazyPropertiesInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazyPropertiesInterface: LazyPropertiesInterface,
    _hasher: HasherT,
  ): HasherT {
    _lazyPropertiesInterface.optionalLazyToResolvedInterfaceProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    _lazyPropertiesInterface.optionalLazyToResolvedInterfaceUnionProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    _lazyPropertiesInterface.optionalLazyToResolvedIriIdentifierInterfaceProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    _lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceProperty.partial.ifJust(
      (value1) => {
        PartialInterface.$hash(value1, _hasher);
      },
    );
    _lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceUnionProperty.partial.ifJust(
      (value1) => {
        PartialInterface.$hash(value1, _hasher);
      },
    );
    _lazyPropertiesInterface.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty.partial.ifJust(
      (value1) => {
        PartialInterfaceUnion.$hash(value1, _hasher);
      },
    );
    _lazyPropertiesInterface.requiredLazyToResolvedInterfaceProperty.partial.$hash(
      _hasher,
    );
    PartialInterface.$hash(
      _lazyPropertiesInterface
        .requiredPartialInterfaceToResolvedInterfaceProperty.partial,
      _hasher,
    );
    for (const item1 of _lazyPropertiesInterface
      .setLazyToResolvedInterfaceProperty.partials) {
      item1.$hash(_hasher);
    }

    for (const item1 of _lazyPropertiesInterface
      .setPartialInterfaceToResolvedInterfaceProperty.partials) {
      PartialInterface.$hash(item1, _hasher);
    }

    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazyPropertiesInterface";
    readonly optionalLazyToResolvedInterfaceProperty?: $DefaultPartial.$Json;
    readonly optionalLazyToResolvedInterfaceUnionProperty?: $DefaultPartial.$Json;
    readonly optionalLazyToResolvedIriIdentifierInterfaceProperty?: $NamedDefaultPartial.$Json;
    readonly optionalPartialInterfaceToResolvedInterfaceProperty?: PartialInterface.$Json;
    readonly optionalPartialInterfaceToResolvedInterfaceUnionProperty?: PartialInterface.$Json;
    readonly optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty?:
      | PartialInterfaceUnionMember1.$Json
      | PartialInterfaceUnionMember2.$Json;
    readonly requiredLazyToResolvedInterfaceProperty: $DefaultPartial.$Json;
    readonly requiredPartialInterfaceToResolvedInterfaceProperty: PartialInterface.$Json;
    readonly setLazyToResolvedInterfaceProperty?: readonly $DefaultPartial.$Json[];
    readonly setPartialInterfaceToResolvedInterfaceProperty?: readonly PartialInterface.$Json[];
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazyPropertiesInterface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedInterfaceProperty`,
        }),
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedInterfaceUnionProperty`,
        }),
        $NamedDefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedIriIdentifierInterfaceProperty`,
        }),
        PartialInterface.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalPartialInterfaceToResolvedInterfaceProperty`,
        }),
        PartialInterface.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalPartialInterfaceToResolvedInterfaceUnionProperty`,
        }),
        {
          scope: `${scopePrefix}/properties/optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
          type: "Control",
        },
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/requiredLazyToResolvedInterfaceProperty`,
        }),
        PartialInterface.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/requiredPartialInterfaceToResolvedInterfaceProperty`,
        }),
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/setLazyToResolvedInterfaceProperty`,
        }),
        PartialInterface.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/setPartialInterfaceToResolvedInterfaceProperty`,
        }),
      ],
      label: "LazyPropertiesInterface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazyPropertiesInterface"),
      optionalLazyToResolvedInterfaceProperty: $DefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalLazyToResolvedInterfaceUnionProperty: $DefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalLazyToResolvedIriIdentifierInterfaceProperty: $NamedDefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalPartialInterfaceToResolvedInterfaceProperty:
        PartialInterface.$jsonZodSchema().optional(),
      optionalPartialInterfaceToResolvedInterfaceUnionProperty:
        PartialInterface.$jsonZodSchema().optional(),
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty:
        PartialInterfaceUnion.$jsonZodSchema().optional(),
      requiredLazyToResolvedInterfaceProperty: $DefaultPartial.$jsonZodSchema(),
      requiredPartialInterfaceToResolvedInterfaceProperty:
        PartialInterface.$jsonZodSchema(),
      setLazyToResolvedInterfaceProperty: $DefaultPartial
        .$jsonZodSchema()
        .array()
        .default(() => []),
      setPartialInterfaceToResolvedInterfaceProperty:
        PartialInterface.$jsonZodSchema()
          .array()
          .default(() => []),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    optionalLazyToResolvedInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalLazyToResolvedInterfaceProperty",
      ),
    },
    optionalLazyToResolvedInterfaceUnionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalLazyToResolvedInterfaceUnionProperty",
      ),
    },
    optionalLazyToResolvedIriIdentifierInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalLazyToResolvedIriIdentifierInterfaceProperty",
      ),
    },
    optionalPartialInterfaceToResolvedInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalPartialInterfaceToResolvedInterfaceProperty",
      ),
    },
    optionalPartialInterfaceToResolvedInterfaceUnionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalPartialInterfaceToResolvedInterfaceUnionProperty",
      ),
    },
    optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty",
      ),
    },
    requiredLazyToResolvedInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/requiredLazyToResolvedInterfaceProperty",
      ),
    },
    requiredPartialInterfaceToResolvedInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/requiredPartialInterfaceToResolvedInterfaceProperty",
      ),
    },
    setLazyToResolvedInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/setLazyToResolvedInterfaceProperty",
      ),
    },
    setPartialInterfaceToResolvedInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/setPartialInterfaceToResolvedInterfaceProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazyPropertiesInterface";
      optionalLazyToResolvedInterfaceProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      optionalLazyToResolvedInterfaceUnionProperty: $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >;
      optionalLazyToResolvedIriIdentifierInterfaceProperty: $LazyObjectOption<
        LazilyResolvedIriIdentifierInterface.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriIdentifierInterface
      >;
      optionalPartialInterfaceToResolvedInterfaceProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      optionalPartialInterfaceToResolvedInterfaceUnionProperty: $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterface,
        LazilyResolvedInterfaceUnion
      >;
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty: $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterfaceUnion,
        LazilyResolvedInterfaceUnion
      >;
      requiredLazyToResolvedInterfaceProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      requiredPartialInterfaceToResolvedInterfaceProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      setLazyToResolvedInterfaceProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      setPartialInterfaceToResolvedInterfaceProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "LazyPropertiesInterface" as const;
    const optionalLazyToResolvedInterfaceProperty = new $LazyObjectOption<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >({
      partial: purify.Maybe.fromNullable(
        $jsonObject["optionalLazyToResolvedInterfaceProperty"],
      ).map((item) => $DefaultPartial.$fromJson(item).unsafeCoerce()),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const optionalLazyToResolvedInterfaceUnionProperty = new $LazyObjectOption<
      LazilyResolvedInterfaceUnion.$Identifier,
      $DefaultPartial,
      LazilyResolvedInterfaceUnion
    >({
      partial: purify.Maybe.fromNullable(
        $jsonObject["optionalLazyToResolvedInterfaceUnionProperty"],
      ).map((item) => $DefaultPartial.$fromJson(item).unsafeCoerce()),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const optionalLazyToResolvedIriIdentifierInterfaceProperty =
      new $LazyObjectOption<
        LazilyResolvedIriIdentifierInterface.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriIdentifierInterface
      >({
        partial: purify.Maybe.fromNullable(
          $jsonObject["optionalLazyToResolvedIriIdentifierInterfaceProperty"],
        ).map((item) => $NamedDefaultPartial.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            purify.Left(
              new Error(
                `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const optionalPartialInterfaceToResolvedInterfaceProperty =
      new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partial: purify.Maybe.fromNullable(
          $jsonObject["optionalPartialInterfaceToResolvedInterfaceProperty"],
        ).map((item) => PartialInterface.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            purify.Left(
              new Error(
                `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const optionalPartialInterfaceToResolvedInterfaceUnionProperty =
      new $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterface,
        LazilyResolvedInterfaceUnion
      >({
        partial: purify.Maybe.fromNullable(
          $jsonObject[
            "optionalPartialInterfaceToResolvedInterfaceUnionProperty"
          ],
        ).map((item) => PartialInterface.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            purify.Left(
              new Error(
                `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
      new $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterfaceUnion,
        LazilyResolvedInterfaceUnion
      >({
        partial: purify.Maybe.fromNullable(
          $jsonObject[
            "optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty"
          ],
        ).map((item) => PartialInterfaceUnion.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            purify.Left(
              new Error(
                `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const requiredLazyToResolvedInterfaceProperty = new $LazyObject<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >({
      partial: $DefaultPartial
        .$fromJson($jsonObject["requiredLazyToResolvedInterfaceProperty"])
        .unsafeCoerce(),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const requiredPartialInterfaceToResolvedInterfaceProperty = new $LazyObject<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      PartialInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >({
      partial: PartialInterface.$fromJson(
        $jsonObject["requiredPartialInterfaceToResolvedInterfaceProperty"],
      ).unsafeCoerce(),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const setLazyToResolvedInterfaceProperty = new $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >({
      partials: $jsonObject["setLazyToResolvedInterfaceProperty"].map((item) =>
        $DefaultPartial.$fromJson(item).unsafeCoerce(),
      ),
      resolver: () =>
        Promise.resolve(
          purify.Left(
            new Error("unable to resolve identifiers deserialized from JSON"),
          ),
        ),
    });
    const setPartialInterfaceToResolvedInterfaceProperty = new $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      PartialInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >({
      partials: $jsonObject[
        "setPartialInterfaceToResolvedInterfaceProperty"
      ].map((item) => PartialInterface.$fromJson(item).unsafeCoerce()),
      resolver: () =>
        Promise.resolve(
          purify.Left(
            new Error("unable to resolve identifiers deserialized from JSON"),
          ),
        ),
    });
    return purify.Either.of({
      $identifier,
      $type,
      optionalLazyToResolvedInterfaceProperty,
      optionalLazyToResolvedInterfaceUnionProperty,
      optionalLazyToResolvedIriIdentifierInterfaceProperty,
      optionalPartialInterfaceToResolvedInterfaceProperty,
      optionalPartialInterfaceToResolvedInterfaceUnionProperty,
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
      requiredLazyToResolvedInterfaceProperty,
      requiredPartialInterfaceToResolvedInterfaceProperty,
      setLazyToResolvedInterfaceProperty,
      setPartialInterfaceToResolvedInterfaceProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazyPropertiesInterface";
      optionalLazyToResolvedInterfaceProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      optionalLazyToResolvedInterfaceUnionProperty: $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >;
      optionalLazyToResolvedIriIdentifierInterfaceProperty: $LazyObjectOption<
        LazilyResolvedIriIdentifierInterface.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriIdentifierInterface
      >;
      optionalPartialInterfaceToResolvedInterfaceProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      optionalPartialInterfaceToResolvedInterfaceUnionProperty: $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterface,
        LazilyResolvedInterfaceUnion
      >;
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty: $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterfaceUnion,
        LazilyResolvedInterfaceUnion
      >;
      requiredLazyToResolvedInterfaceProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      requiredPartialInterfaceToResolvedInterfaceProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      setLazyToResolvedInterfaceProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      setPartialInterfaceToResolvedInterfaceProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
    }
  > {
    return purify.Either.of<Error, LazyPropertiesInterface.$Identifier>(
      $parameters.resource.identifier as LazyPropertiesInterface.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<Error, "LazyPropertiesInterface">(
        "LazyPropertiesInterface",
      ).chain(($type) =>
        purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
        >(
          $parameters.resource.values(
            $properties.optionalLazyToResolvedInterfaceProperty["identifier"],
            { unique: true },
          ),
        )
          .chain((values) =>
            values.chainMap((value) =>
              value.toResource().chain((resource) =>
                $DefaultPartial.$fromRdf(resource, {
                  context: $parameters.context,
                  ignoreRdfType: true,
                  objectSet: $parameters.objectSet,
                  preferredLanguages: $parameters.preferredLanguages,
                }),
              ),
            ),
          )
          .map((values) =>
            values.length > 0
              ? values.map((value) => purify.Maybe.of(value))
              : rdfjsResource.Resource.Values.fromValue<
                  purify.Maybe<$DefaultPartial>
                >({
                  focusResource: $parameters.resource,
                  predicate:
                    LazyPropertiesInterface.$properties
                      .optionalLazyToResolvedInterfaceProperty["identifier"],
                  value: purify.Maybe.empty(),
                }),
          )
          .map((values) =>
            values.map(
              (partial) =>
                new $LazyObjectOption<
                  LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
                  $DefaultPartial,
                  LazilyResolvedBlankNodeOrIriIdentifierInterface
                >({
                  partial,
                  resolver: (identifier) =>
                    $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierInterface(
                      identifier,
                    ),
                }),
            ),
          )
          .chain((values) => values.head())
          .chain((optionalLazyToResolvedInterfaceProperty) =>
            purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
            >(
              $parameters.resource.values(
                $properties.optionalLazyToResolvedInterfaceUnionProperty[
                  "identifier"
                ],
                { unique: true },
              ),
            )
              .chain((values) =>
                values.chainMap((value) =>
                  value.toResource().chain((resource) =>
                    $DefaultPartial.$fromRdf(resource, {
                      context: $parameters.context,
                      ignoreRdfType: true,
                      objectSet: $parameters.objectSet,
                      preferredLanguages: $parameters.preferredLanguages,
                    }),
                  ),
                ),
              )
              .map((values) =>
                values.length > 0
                  ? values.map((value) => purify.Maybe.of(value))
                  : rdfjsResource.Resource.Values.fromValue<
                      purify.Maybe<$DefaultPartial>
                    >({
                      focusResource: $parameters.resource,
                      predicate:
                        LazyPropertiesInterface.$properties
                          .optionalLazyToResolvedInterfaceUnionProperty[
                          "identifier"
                        ],
                      value: purify.Maybe.empty(),
                    }),
              )
              .map((values) =>
                values.map(
                  (partial) =>
                    new $LazyObjectOption<
                      LazilyResolvedInterfaceUnion.$Identifier,
                      $DefaultPartial,
                      LazilyResolvedInterfaceUnion
                    >({
                      partial,
                      resolver: (identifier) =>
                        $parameters.objectSet.lazilyResolvedInterfaceUnion(
                          identifier,
                        ),
                    }),
                ),
              )
              .chain((values) => values.head())
              .chain((optionalLazyToResolvedInterfaceUnionProperty) =>
                purify.Either.of<
                  Error,
                  rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                >(
                  $parameters.resource.values(
                    $properties
                      .optionalLazyToResolvedIriIdentifierInterfaceProperty[
                      "identifier"
                    ],
                    { unique: true },
                  ),
                )
                  .chain((values) =>
                    values.chainMap((value) =>
                      value.toResource().chain((resource) =>
                        $NamedDefaultPartial.$fromRdf(resource, {
                          context: $parameters.context,
                          ignoreRdfType: true,
                          objectSet: $parameters.objectSet,
                          preferredLanguages: $parameters.preferredLanguages,
                        }),
                      ),
                    ),
                  )
                  .map((values) =>
                    values.length > 0
                      ? values.map((value) => purify.Maybe.of(value))
                      : rdfjsResource.Resource.Values.fromValue<
                          purify.Maybe<$NamedDefaultPartial>
                        >({
                          focusResource: $parameters.resource,
                          predicate:
                            LazyPropertiesInterface.$properties
                              .optionalLazyToResolvedIriIdentifierInterfaceProperty[
                              "identifier"
                            ],
                          value: purify.Maybe.empty(),
                        }),
                  )
                  .map((values) =>
                    values.map(
                      (partial) =>
                        new $LazyObjectOption<
                          LazilyResolvedIriIdentifierInterface.$Identifier,
                          $NamedDefaultPartial,
                          LazilyResolvedIriIdentifierInterface
                        >({
                          partial,
                          resolver: (identifier) =>
                            $parameters.objectSet.lazilyResolvedIriIdentifierInterface(
                              identifier,
                            ),
                        }),
                    ),
                  )
                  .chain((values) => values.head())
                  .chain(
                    (optionalLazyToResolvedIriIdentifierInterfaceProperty) =>
                      purify.Either.of<
                        Error,
                        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                      >(
                        $parameters.resource.values(
                          $properties
                            .optionalPartialInterfaceToResolvedInterfaceProperty[
                            "identifier"
                          ],
                          { unique: true },
                        ),
                      )
                        .chain((values) =>
                          values.chainMap((value) =>
                            value.toResource().chain((resource) =>
                              PartialInterface.$fromRdf(resource, {
                                context: $parameters.context,
                                ignoreRdfType: true,
                                objectSet: $parameters.objectSet,
                                preferredLanguages:
                                  $parameters.preferredLanguages,
                              }),
                            ),
                          ),
                        )
                        .map((values) =>
                          values.length > 0
                            ? values.map((value) => purify.Maybe.of(value))
                            : rdfjsResource.Resource.Values.fromValue<
                                purify.Maybe<PartialInterface>
                              >({
                                focusResource: $parameters.resource,
                                predicate:
                                  LazyPropertiesInterface.$properties
                                    .optionalPartialInterfaceToResolvedInterfaceProperty[
                                    "identifier"
                                  ],
                                value: purify.Maybe.empty(),
                              }),
                        )
                        .map((values) =>
                          values.map(
                            (partial) =>
                              new $LazyObjectOption<
                                LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
                                PartialInterface,
                                LazilyResolvedBlankNodeOrIriIdentifierInterface
                              >({
                                partial,
                                resolver: (identifier) =>
                                  $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierInterface(
                                    identifier,
                                  ),
                              }),
                          ),
                        )
                        .chain((values) => values.head())
                        .chain(
                          (
                            optionalPartialInterfaceToResolvedInterfaceProperty,
                          ) =>
                            purify.Either.of<
                              Error,
                              rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                            >(
                              $parameters.resource.values(
                                $properties
                                  .optionalPartialInterfaceToResolvedInterfaceUnionProperty[
                                  "identifier"
                                ],
                                { unique: true },
                              ),
                            )
                              .chain((values) =>
                                values.chainMap((value) =>
                                  value.toResource().chain((resource) =>
                                    PartialInterface.$fromRdf(resource, {
                                      context: $parameters.context,
                                      ignoreRdfType: true,
                                      objectSet: $parameters.objectSet,
                                      preferredLanguages:
                                        $parameters.preferredLanguages,
                                    }),
                                  ),
                                ),
                              )
                              .map((values) =>
                                values.length > 0
                                  ? values.map((value) =>
                                      purify.Maybe.of(value),
                                    )
                                  : rdfjsResource.Resource.Values.fromValue<
                                      purify.Maybe<PartialInterface>
                                    >({
                                      focusResource: $parameters.resource,
                                      predicate:
                                        LazyPropertiesInterface.$properties
                                          .optionalPartialInterfaceToResolvedInterfaceUnionProperty[
                                          "identifier"
                                        ],
                                      value: purify.Maybe.empty(),
                                    }),
                              )
                              .map((values) =>
                                values.map(
                                  (partial) =>
                                    new $LazyObjectOption<
                                      LazilyResolvedInterfaceUnion.$Identifier,
                                      PartialInterface,
                                      LazilyResolvedInterfaceUnion
                                    >({
                                      partial,
                                      resolver: (identifier) =>
                                        $parameters.objectSet.lazilyResolvedInterfaceUnion(
                                          identifier,
                                        ),
                                    }),
                                ),
                              )
                              .chain((values) => values.head())
                              .chain(
                                (
                                  optionalPartialInterfaceToResolvedInterfaceUnionProperty,
                                ) =>
                                  purify.Either.of<
                                    Error,
                                    rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                                  >(
                                    $parameters.resource.values(
                                      $properties
                                        .optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty[
                                        "identifier"
                                      ],
                                      { unique: true },
                                    ),
                                  )
                                    .chain((values) =>
                                      values.chainMap((value) =>
                                        value.toResource().chain((resource) =>
                                          PartialInterfaceUnion.$fromRdf(
                                            resource,
                                            {
                                              context: $parameters.context,
                                              ignoreRdfType: false,
                                              objectSet: $parameters.objectSet,
                                              preferredLanguages:
                                                $parameters.preferredLanguages,
                                            },
                                          ),
                                        ),
                                      ),
                                    )
                                    .map((values) =>
                                      values.length > 0
                                        ? values.map((value) =>
                                            purify.Maybe.of(value),
                                          )
                                        : rdfjsResource.Resource.Values.fromValue<
                                            purify.Maybe<PartialInterfaceUnion>
                                          >({
                                            focusResource: $parameters.resource,
                                            predicate:
                                              LazyPropertiesInterface
                                                .$properties
                                                .optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty[
                                                "identifier"
                                              ],
                                            value: purify.Maybe.empty(),
                                          }),
                                    )
                                    .map((values) =>
                                      values.map(
                                        (partial) =>
                                          new $LazyObjectOption<
                                            LazilyResolvedInterfaceUnion.$Identifier,
                                            PartialInterfaceUnion,
                                            LazilyResolvedInterfaceUnion
                                          >({
                                            partial,
                                            resolver: (identifier) =>
                                              $parameters.objectSet.lazilyResolvedInterfaceUnion(
                                                identifier,
                                              ),
                                          }),
                                      ),
                                    )
                                    .chain((values) => values.head())
                                    .chain(
                                      (
                                        optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
                                      ) =>
                                        purify.Either.of<
                                          Error,
                                          rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                                        >(
                                          $parameters.resource.values(
                                            $properties
                                              .requiredLazyToResolvedInterfaceProperty[
                                              "identifier"
                                            ],
                                            { unique: true },
                                          ),
                                        )
                                          .chain((values) =>
                                            values.chainMap((value) =>
                                              value
                                                .toResource()
                                                .chain((resource) =>
                                                  $DefaultPartial.$fromRdf(
                                                    resource,
                                                    {
                                                      context:
                                                        $parameters.context,
                                                      ignoreRdfType: true,
                                                      objectSet:
                                                        $parameters.objectSet,
                                                      preferredLanguages:
                                                        $parameters.preferredLanguages,
                                                    },
                                                  ),
                                                ),
                                            ),
                                          )
                                          .map((values) =>
                                            values.map(
                                              (partial) =>
                                                new $LazyObject<
                                                  LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
                                                  $DefaultPartial,
                                                  LazilyResolvedBlankNodeOrIriIdentifierInterface
                                                >({
                                                  partial,
                                                  resolver: (identifier) =>
                                                    $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierInterface(
                                                      identifier,
                                                    ),
                                                }),
                                            ),
                                          )
                                          .chain((values) => values.head())
                                          .chain(
                                            (
                                              requiredLazyToResolvedInterfaceProperty,
                                            ) =>
                                              purify.Either.of<
                                                Error,
                                                rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                                              >(
                                                $parameters.resource.values(
                                                  $properties
                                                    .requiredPartialInterfaceToResolvedInterfaceProperty[
                                                    "identifier"
                                                  ],
                                                  { unique: true },
                                                ),
                                              )
                                                .chain((values) =>
                                                  values.chainMap((value) =>
                                                    value
                                                      .toResource()
                                                      .chain((resource) =>
                                                        PartialInterface.$fromRdf(
                                                          resource,
                                                          {
                                                            context:
                                                              $parameters.context,
                                                            ignoreRdfType: true,
                                                            objectSet:
                                                              $parameters.objectSet,
                                                            preferredLanguages:
                                                              $parameters.preferredLanguages,
                                                          },
                                                        ),
                                                      ),
                                                  ),
                                                )
                                                .map((values) =>
                                                  values.map(
                                                    (partial) =>
                                                      new $LazyObject<
                                                        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
                                                        PartialInterface,
                                                        LazilyResolvedBlankNodeOrIriIdentifierInterface
                                                      >({
                                                        partial,
                                                        resolver: (
                                                          identifier,
                                                        ) =>
                                                          $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierInterface(
                                                            identifier,
                                                          ),
                                                      }),
                                                  ),
                                                )
                                                .chain((values) =>
                                                  values.head(),
                                                )
                                                .chain(
                                                  (
                                                    requiredPartialInterfaceToResolvedInterfaceProperty,
                                                  ) =>
                                                    purify.Either.of<
                                                      Error,
                                                      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                                                    >(
                                                      $parameters.resource.values(
                                                        $properties
                                                          .setLazyToResolvedInterfaceProperty[
                                                          "identifier"
                                                        ],
                                                        { unique: true },
                                                      ),
                                                    )
                                                      .chain((values) =>
                                                        values.chainMap(
                                                          (value) =>
                                                            value
                                                              .toResource()
                                                              .chain(
                                                                (resource) =>
                                                                  $DefaultPartial.$fromRdf(
                                                                    resource,
                                                                    {
                                                                      context:
                                                                        $parameters.context,
                                                                      ignoreRdfType: true,
                                                                      objectSet:
                                                                        $parameters.objectSet,
                                                                      preferredLanguages:
                                                                        $parameters.preferredLanguages,
                                                                    },
                                                                  ),
                                                              ),
                                                        ),
                                                      )
                                                      .map((values) =>
                                                        values.toArray(),
                                                      )
                                                      .map((valuesArray) =>
                                                        rdfjsResource.Resource.Values.fromValue(
                                                          {
                                                            focusResource:
                                                              $parameters.resource,
                                                            predicate:
                                                              LazyPropertiesInterface
                                                                .$properties
                                                                .setLazyToResolvedInterfaceProperty[
                                                                "identifier"
                                                              ],
                                                            value: valuesArray,
                                                          },
                                                        ),
                                                      )
                                                      .map((values) =>
                                                        values.map(
                                                          (partials) =>
                                                            new $LazyObjectSet<
                                                              LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
                                                              $DefaultPartial,
                                                              LazilyResolvedBlankNodeOrIriIdentifierInterface
                                                            >({
                                                              partials,
                                                              resolver: (
                                                                identifiers,
                                                              ) =>
                                                                $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierInterfaces(
                                                                  {
                                                                    filter: {
                                                                      $identifier:
                                                                        {
                                                                          in: identifiers,
                                                                        },
                                                                    },
                                                                  },
                                                                ),
                                                            }),
                                                        ),
                                                      )
                                                      .chain((values) =>
                                                        values.head(),
                                                      )
                                                      .chain(
                                                        (
                                                          setLazyToResolvedInterfaceProperty,
                                                        ) =>
                                                          purify.Either.of<
                                                            Error,
                                                            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                                                          >(
                                                            $parameters.resource.values(
                                                              $properties
                                                                .setPartialInterfaceToResolvedInterfaceProperty[
                                                                "identifier"
                                                              ],
                                                              { unique: true },
                                                            ),
                                                          )
                                                            .chain((values) =>
                                                              values.chainMap(
                                                                (value) =>
                                                                  value
                                                                    .toResource()
                                                                    .chain(
                                                                      (
                                                                        resource,
                                                                      ) =>
                                                                        PartialInterface.$fromRdf(
                                                                          resource,
                                                                          {
                                                                            context:
                                                                              $parameters.context,
                                                                            ignoreRdfType: true,
                                                                            objectSet:
                                                                              $parameters.objectSet,
                                                                            preferredLanguages:
                                                                              $parameters.preferredLanguages,
                                                                          },
                                                                        ),
                                                                    ),
                                                              ),
                                                            )
                                                            .map((values) =>
                                                              values.toArray(),
                                                            )
                                                            .map(
                                                              (valuesArray) =>
                                                                rdfjsResource.Resource.Values.fromValue(
                                                                  {
                                                                    focusResource:
                                                                      $parameters.resource,
                                                                    predicate:
                                                                      LazyPropertiesInterface
                                                                        .$properties
                                                                        .setPartialInterfaceToResolvedInterfaceProperty[
                                                                        "identifier"
                                                                      ],
                                                                    value:
                                                                      valuesArray,
                                                                  },
                                                                ),
                                                            )
                                                            .map((values) =>
                                                              values.map(
                                                                (partials) =>
                                                                  new $LazyObjectSet<
                                                                    LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
                                                                    PartialInterface,
                                                                    LazilyResolvedBlankNodeOrIriIdentifierInterface
                                                                  >({
                                                                    partials,
                                                                    resolver: (
                                                                      identifiers,
                                                                    ) =>
                                                                      $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierInterfaces(
                                                                        {
                                                                          filter:
                                                                            {
                                                                              $identifier:
                                                                                {
                                                                                  in: identifiers,
                                                                                },
                                                                            },
                                                                        },
                                                                      ),
                                                                  }),
                                                              ),
                                                            )
                                                            .chain((values) =>
                                                              values.head(),
                                                            )
                                                            .map(
                                                              (
                                                                setPartialInterfaceToResolvedInterfaceProperty,
                                                              ) => ({
                                                                $identifier,
                                                                $type,
                                                                optionalLazyToResolvedInterfaceProperty,
                                                                optionalLazyToResolvedInterfaceUnionProperty,
                                                                optionalLazyToResolvedIriIdentifierInterfaceProperty,
                                                                optionalPartialInterfaceToResolvedInterfaceProperty,
                                                                optionalPartialInterfaceToResolvedInterfaceUnionProperty,
                                                                optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
                                                                requiredLazyToResolvedInterfaceProperty,
                                                                requiredPartialInterfaceToResolvedInterfaceProperty,
                                                                setLazyToResolvedInterfaceProperty,
                                                                setPartialInterfaceToResolvedInterfaceProperty,
                                                              }),
                                                            ),
                                                      ),
                                                ),
                                          ),
                                    ),
                              ),
                        ),
                  ),
              ),
          ),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazyPropertiesInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazyPropertiesInterface.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazyPropertiesInterface.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazyPropertiesInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazyPropertiesInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("lazyPropertiesInterface");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .optionalLazyToResolvedInterfaceProperty["identifier"],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceUnionProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .optionalLazyToResolvedInterfaceUnionProperty["identifier"],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceUnionProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceUnionProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedIriIdentifierInterfaceProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .optionalLazyToResolvedIriIdentifierInterfaceProperty["identifier"],
      subject,
    });
    triples.push(
      ...$NamedDefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedIriIdentifierInterfaceProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedIriIdentifierInterfaceProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .optionalPartialInterfaceToResolvedInterfaceProperty["identifier"],
      subject,
    });
    triples.push(
      ...PartialInterface.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .optionalPartialInterfaceToResolvedInterfaceUnionProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...PartialInterface.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...PartialInterfaceUnion.$sparqlConstructTriples({
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredLazyToResolvedInterfaceProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .requiredLazyToResolvedInterfaceProperty["identifier"],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredLazyToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredLazyToResolvedInterfaceProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredPartialInterfaceToResolvedInterfaceProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .requiredPartialInterfaceToResolvedInterfaceProperty["identifier"],
      subject,
    });
    triples.push(
      ...PartialInterface.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredPartialInterfaceToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredPartialInterfaceToResolvedInterfaceProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetLazyToResolvedInterfaceProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties.setLazyToResolvedInterfaceProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetLazyToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetLazyToResolvedInterfaceProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetPartialInterfaceToResolvedInterfaceProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .setPartialInterfaceToResolvedInterfaceProperty["identifier"],
      subject,
    });
    triples.push(
      ...PartialInterface.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetPartialInterfaceToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetPartialInterfaceToResolvedInterfaceProperty`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazyPropertiesInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("lazyPropertiesInterface");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalLazyToResolvedInterfaceProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceProperty`,
                  ),
                  predicate:
                    LazyPropertiesInterface.$properties
                      .optionalLazyToResolvedInterfaceProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $DefaultPartial
                .$sparqlWherePatterns({
                  filter: itemFilter,
                  ignoreRdfType: true,
                  preferredLanguages: parameters?.preferredLanguages,
                  subject: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceProperty`,
                  ),
                  variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceProperty`,
                })
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalLazyToResolvedInterfaceUnionProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceUnionProperty`,
                  ),
                  predicate:
                    LazyPropertiesInterface.$properties
                      .optionalLazyToResolvedInterfaceUnionProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $DefaultPartial
                .$sparqlWherePatterns({
                  filter: itemFilter,
                  ignoreRdfType: true,
                  preferredLanguages: parameters?.preferredLanguages,
                  subject: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceUnionProperty`,
                  ),
                  variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceUnionProperty`,
                })
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter
            ?.optionalLazyToResolvedIriIdentifierInterfaceProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedIriIdentifierInterfaceProperty`,
                  ),
                  predicate:
                    LazyPropertiesInterface.$properties
                      .optionalLazyToResolvedIriIdentifierInterfaceProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $NamedDefaultPartial
                .$sparqlWherePatterns({
                  filter: itemFilter,
                  ignoreRdfType: true,
                  preferredLanguages: parameters?.preferredLanguages,
                  subject: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedIriIdentifierInterfaceProperty`,
                  ),
                  variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedIriIdentifierInterfaceProperty`,
                })
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter
            ?.optionalPartialInterfaceToResolvedInterfaceProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceProperty`,
                  ),
                  predicate:
                    LazyPropertiesInterface.$properties
                      .optionalPartialInterfaceToResolvedInterfaceProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: PartialInterface.$sparqlWherePatterns({
                filter: itemFilter,
                ignoreRdfType: true,
                preferredLanguages: parameters?.preferredLanguages,
                subject: dataFactory.variable!(
                  `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceProperty`,
                ),
                variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceProperty`,
              }).concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter
            ?.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
                  ),
                  predicate:
                    LazyPropertiesInterface.$properties
                      .optionalPartialInterfaceToResolvedInterfaceUnionProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: PartialInterface.$sparqlWherePatterns({
                filter: itemFilter,
                ignoreRdfType: true,
                preferredLanguages: parameters?.preferredLanguages,
                subject: dataFactory.variable!(
                  `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
                ),
                variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
              }).concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter
            ?.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
                  ),
                  predicate:
                    LazyPropertiesInterface.$properties
                      .optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: PartialInterfaceUnion.$sparqlWherePatterns({
                filter: itemFilter,
                preferredLanguages: parameters?.preferredLanguages,
                subject: dataFactory.variable!(
                  `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
                ),
                variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
              }).concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredLazyToResolvedInterfaceProperty`,
            ),
            predicate:
              LazyPropertiesInterface.$properties
                .requiredLazyToResolvedInterfaceProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: $DefaultPartial
          .$sparqlWherePatterns({
            filter: parameters?.filter?.requiredLazyToResolvedInterfaceProperty,
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredLazyToResolvedInterfaceProperty`,
            ),
            variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredLazyToResolvedInterfaceProperty`,
          })
          .concat(),
        type: "group",
      },
    );
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredPartialInterfaceToResolvedInterfaceProperty`,
            ),
            predicate:
              LazyPropertiesInterface.$properties
                .requiredPartialInterfaceToResolvedInterfaceProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: PartialInterface.$sparqlWherePatterns({
          filter:
            parameters?.filter
              ?.requiredPartialInterfaceToResolvedInterfaceProperty,
          ignoreRdfType: true,
          preferredLanguages: parameters?.preferredLanguages,
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredPartialInterfaceToResolvedInterfaceProperty`,
          ),
          variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredPartialInterfaceToResolvedInterfaceProperty`,
        }).concat(),
        type: "group",
      },
    );
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetLazyToResolvedInterfaceProperty`,
              ),
              predicate:
                LazyPropertiesInterface.$properties
                  .setLazyToResolvedInterfaceProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: $DefaultPartial
            .$sparqlWherePatterns({
              filter: parameters?.filter?.setLazyToResolvedInterfaceProperty,
              ignoreRdfType: true,
              preferredLanguages: parameters?.preferredLanguages,
              subject: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetLazyToResolvedInterfaceProperty`,
              ),
              variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetLazyToResolvedInterfaceProperty`,
            })
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetPartialInterfaceToResolvedInterfaceProperty`,
              ),
              predicate:
                LazyPropertiesInterface.$properties
                  .setPartialInterfaceToResolvedInterfaceProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: PartialInterface.$sparqlWherePatterns({
            filter:
              parameters?.filter
                ?.setPartialInterfaceToResolvedInterfaceProperty,
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetPartialInterfaceToResolvedInterfaceProperty`,
            ),
            variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetPartialInterfaceToResolvedInterfaceProperty`,
          }).concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    return patterns;
  }

  export function $toJson(
    _lazyPropertiesInterface: LazyPropertiesInterface,
  ): LazyPropertiesInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _lazyPropertiesInterface.$identifier.termType === "BlankNode"
            ? `_:${_lazyPropertiesInterface.$identifier.value}`
            : _lazyPropertiesInterface.$identifier.value,
        $type: _lazyPropertiesInterface.$type,
        optionalLazyToResolvedInterfaceProperty:
          _lazyPropertiesInterface.optionalLazyToResolvedInterfaceProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalLazyToResolvedInterfaceUnionProperty:
          _lazyPropertiesInterface.optionalLazyToResolvedInterfaceUnionProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalLazyToResolvedIriIdentifierInterfaceProperty:
          _lazyPropertiesInterface.optionalLazyToResolvedIriIdentifierInterfaceProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalPartialInterfaceToResolvedInterfaceProperty:
          _lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceProperty.partial
            .map((item) => PartialInterface.$toJson(item))
            .extract(),
        optionalPartialInterfaceToResolvedInterfaceUnionProperty:
          _lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceUnionProperty.partial
            .map((item) => PartialInterface.$toJson(item))
            .extract(),
        optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty:
          _lazyPropertiesInterface.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty.partial
            .map((item) => PartialInterfaceUnion.$toJson(item))
            .extract(),
        requiredLazyToResolvedInterfaceProperty:
          _lazyPropertiesInterface.requiredLazyToResolvedInterfaceProperty.partial.$toJson(),
        requiredPartialInterfaceToResolvedInterfaceProperty:
          PartialInterface.$toJson(
            _lazyPropertiesInterface
              .requiredPartialInterfaceToResolvedInterfaceProperty.partial,
          ),
        setLazyToResolvedInterfaceProperty:
          _lazyPropertiesInterface.setLazyToResolvedInterfaceProperty.partials.map(
            (item) => item.$toJson(),
          ),
        setPartialInterfaceToResolvedInterfaceProperty:
          _lazyPropertiesInterface.setPartialInterfaceToResolvedInterfaceProperty.partials.map(
            (item) => PartialInterface.$toJson(item),
          ),
      } satisfies LazyPropertiesInterface.$Json),
    );
  }

  export function $toRdf(
    _lazyPropertiesInterface: LazyPropertiesInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _lazyPropertiesInterface.$identifier,
      { mutateGraph },
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .optionalLazyToResolvedInterfaceProperty["identifier"],
      ..._lazyPropertiesInterface.optionalLazyToResolvedInterfaceProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .optionalLazyToResolvedInterfaceUnionProperty["identifier"],
      ..._lazyPropertiesInterface.optionalLazyToResolvedInterfaceUnionProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .optionalLazyToResolvedIriIdentifierInterfaceProperty["identifier"],
      ..._lazyPropertiesInterface.optionalLazyToResolvedIriIdentifierInterfaceProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .optionalPartialInterfaceToResolvedInterfaceProperty["identifier"],
      ..._lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceProperty.partial
        .toList()
        .flatMap((value) => [
          PartialInterface.$toRdf(value, {
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          }).identifier,
        ]),
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .optionalPartialInterfaceToResolvedInterfaceUnionProperty["identifier"],
      ..._lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceUnionProperty.partial
        .toList()
        .flatMap((value) => [
          PartialInterface.$toRdf(value, {
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          }).identifier,
        ]),
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty[
        "identifier"
      ],
      ..._lazyPropertiesInterface.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty.partial
        .toList()
        .flatMap((value) => [
          PartialInterfaceUnion.$toRdf(value, { mutateGraph, resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .requiredLazyToResolvedInterfaceProperty["identifier"],
      ...[
        _lazyPropertiesInterface.requiredLazyToResolvedInterfaceProperty.partial.$toRdf(
          { mutateGraph: mutateGraph, resourceSet: resourceSet },
        ).identifier,
      ],
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .requiredPartialInterfaceToResolvedInterfaceProperty["identifier"],
      ...[
        PartialInterface.$toRdf(
          _lazyPropertiesInterface
            .requiredPartialInterfaceToResolvedInterfaceProperty.partial,
          { mutateGraph: mutateGraph, resourceSet: resourceSet },
        ).identifier,
      ],
    );
    resource.add(
      LazyPropertiesInterface.$properties.setLazyToResolvedInterfaceProperty[
        "identifier"
      ],
      ..._lazyPropertiesInterface.setLazyToResolvedInterfaceProperty.partials.flatMap(
        (item) => [
          item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ],
      ),
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .setPartialInterfaceToResolvedInterfaceProperty["identifier"],
      ..._lazyPropertiesInterface.setPartialInterfaceToResolvedInterfaceProperty.partials.flatMap(
        (item) => [
          PartialInterface.$toRdf(item, {
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          }).identifier,
        ],
      ),
    );
    return resource;
  }

  export function isLazyPropertiesInterface(
    object: $Object,
  ): object is LazyPropertiesInterface {
    switch (object.$type) {
      case "LazyPropertiesInterface":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape used as a partial by LazyPropertiesClass
 */
export class PartialClass {
  private _$identifier?: PartialClass.$Identifier;
  readonly $type = "PartialClass";
  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): PartialClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: PartialClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): PartialClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies PartialClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      PartialClass.$properties.lazilyResolvedStringProperty["identifier"],
      ...[this.lazilyResolvedStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PartialClass {
  export function $filter(
    filter: PartialClass.$Filter,
    value: PartialClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialClass> {
    return $propertiesFromJson(json).map(
      (properties) => new PartialClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PartialClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new PartialClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialClass";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PartialClass"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    return purify.Either.of<Error, PartialClass.$Identifier>(
      $parameters.resource.identifier as PartialClass.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              PartialClass.$properties.lazilyResolvedStringProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((lazilyResolvedStringProperty) => ({
          $identifier,
          lazilyResolvedStringProperty,
        })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            PartialClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClass")}LazilyResolvedStringProperty`,
      ),
      predicate:
        PartialClass.$properties.lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClass")}LazilyResolvedStringProperty`,
            ),
            predicate:
              PartialClass.$properties.lazilyResolvedStringProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClass")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClass")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isPartialClass(object: $Object): object is PartialClass {
    switch (object.$type) {
      case "PartialClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape that has lazy properties.
 */
export class LazyPropertiesClass {
  private _$identifier?: LazyPropertiesClass.$Identifier;
  readonly $type = "LazyPropertiesClass";
  readonly optionalLazyToResolvedClassProperty: $LazyObjectOption<
    LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriIdentifierClass
  >;
  readonly optionalLazyToResolvedClassUnionProperty: $LazyObjectOption<
    LazilyResolvedClassUnion.$Identifier,
    $DefaultPartial,
    LazilyResolvedClassUnion
  >;
  readonly optionalLazyToResolvedIriIdentifierClassProperty: $LazyObjectOption<
    LazilyResolvedIriIdentifierClass.$Identifier,
    $NamedDefaultPartial,
    LazilyResolvedIriIdentifierClass
  >;
  readonly optionalPartialClassToResolvedClassProperty: $LazyObjectOption<
    LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
    PartialClass,
    LazilyResolvedBlankNodeOrIriIdentifierClass
  >;
  readonly optionalPartialClassToResolvedClassUnionProperty: $LazyObjectOption<
    LazilyResolvedClassUnion.$Identifier,
    PartialClass,
    LazilyResolvedClassUnion
  >;
  readonly optionalPartialClassUnionToResolvedClassUnionProperty: $LazyObjectOption<
    LazilyResolvedClassUnion.$Identifier,
    PartialClassUnion,
    LazilyResolvedClassUnion
  >;
  readonly requiredLazyToResolvedClassProperty: $LazyObject<
    LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriIdentifierClass
  >;
  readonly requiredPartialClassToResolvedClassProperty: $LazyObject<
    LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
    PartialClass,
    LazilyResolvedBlankNodeOrIriIdentifierClass
  >;
  readonly setLazyToResolvedClassProperty: $LazyObjectSet<
    LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriIdentifierClass
  >;
  readonly setPartialClassToResolvedClassProperty: $LazyObjectSet<
    LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
    PartialClass,
    LazilyResolvedBlankNodeOrIriIdentifierClass
  >;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly optionalLazyToResolvedClassProperty?:
      | $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >
      | LazilyResolvedBlankNodeOrIriIdentifierClass
      | purify.Maybe<LazilyResolvedBlankNodeOrIriIdentifierClass>;
    readonly optionalLazyToResolvedClassUnionProperty?:
      | $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          $DefaultPartial,
          LazilyResolvedClassUnion
        >
      | LazilyResolvedClassUnion
      | purify.Maybe<LazilyResolvedClassUnion>;
    readonly optionalLazyToResolvedIriIdentifierClassProperty?:
      | $LazyObjectOption<
          LazilyResolvedIriIdentifierClass.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierClass
        >
      | LazilyResolvedIriIdentifierClass
      | purify.Maybe<LazilyResolvedIriIdentifierClass>;
    readonly optionalPartialClassToResolvedClassProperty?:
      | $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >
      | LazilyResolvedBlankNodeOrIriIdentifierClass
      | purify.Maybe<LazilyResolvedBlankNodeOrIriIdentifierClass>;
    readonly optionalPartialClassToResolvedClassUnionProperty?:
      | $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClass,
          LazilyResolvedClassUnion
        >
      | LazilyResolvedClassUnion
      | purify.Maybe<LazilyResolvedClassUnion>;
    readonly optionalPartialClassUnionToResolvedClassUnionProperty?:
      | $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClassUnion,
          LazilyResolvedClassUnion
        >
      | LazilyResolvedClassUnion
      | purify.Maybe<LazilyResolvedClassUnion>;
    readonly requiredLazyToResolvedClassProperty:
      | $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >
      | LazilyResolvedBlankNodeOrIriIdentifierClass;
    readonly requiredPartialClassToResolvedClassProperty:
      | $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >
      | LazilyResolvedBlankNodeOrIriIdentifierClass;
    readonly setLazyToResolvedClassProperty?:
      | $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >
      | readonly LazilyResolvedBlankNodeOrIriIdentifierClass[];
    readonly setPartialClassToResolvedClassProperty?:
      | $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >
      | readonly LazilyResolvedBlankNodeOrIriIdentifierClass[];
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    if (
      typeof parameters.optionalLazyToResolvedClassProperty === "object" &&
      parameters.optionalLazyToResolvedClassProperty instanceof
        $LazyObjectOption
    ) {
      this.optionalLazyToResolvedClassProperty =
        parameters.optionalLazyToResolvedClassProperty;
    } else if (
      purify.Maybe.isMaybe(parameters.optionalLazyToResolvedClassProperty)
    ) {
      this.optionalLazyToResolvedClassProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: parameters.optionalLazyToResolvedClassProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          purify.Either.of(
            (
              parameters.optionalLazyToResolvedClassProperty as purify.Maybe<LazilyResolvedBlankNodeOrIriIdentifierClass>
            ).unsafeCoerce(),
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedClassProperty === "object"
    ) {
      this.optionalLazyToResolvedClassProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: purify.Maybe.of(
          new $DefaultPartial(parameters.optionalLazyToResolvedClassProperty),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.optionalLazyToResolvedClassProperty as LazilyResolvedBlankNodeOrIriIdentifierClass,
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedClassProperty === "undefined"
    ) {
      this.optionalLazyToResolvedClassProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: purify.Maybe.empty(),
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      this.optionalLazyToResolvedClassProperty =
        parameters.optionalLazyToResolvedClassProperty satisfies never;
    }

    if (
      typeof parameters.optionalLazyToResolvedClassUnionProperty === "object" &&
      parameters.optionalLazyToResolvedClassUnionProperty instanceof
        $LazyObjectOption
    ) {
      this.optionalLazyToResolvedClassUnionProperty =
        parameters.optionalLazyToResolvedClassUnionProperty;
    } else if (
      purify.Maybe.isMaybe(parameters.optionalLazyToResolvedClassUnionProperty)
    ) {
      this.optionalLazyToResolvedClassUnionProperty = new $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >({
        partial: parameters.optionalLazyToResolvedClassUnionProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          purify.Either.of(
            (
              parameters.optionalLazyToResolvedClassUnionProperty as purify.Maybe<LazilyResolvedClassUnion>
            ).unsafeCoerce(),
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedClassUnionProperty === "object"
    ) {
      this.optionalLazyToResolvedClassUnionProperty = new $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >({
        partial: purify.Maybe.of(
          new $DefaultPartial(
            parameters.optionalLazyToResolvedClassUnionProperty,
          ),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.optionalLazyToResolvedClassUnionProperty as LazilyResolvedClassUnion,
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedClassUnionProperty === "undefined"
    ) {
      this.optionalLazyToResolvedClassUnionProperty = new $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >({
        partial: purify.Maybe.empty(),
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      this.optionalLazyToResolvedClassUnionProperty =
        parameters.optionalLazyToResolvedClassUnionProperty satisfies never;
    }

    if (
      typeof parameters.optionalLazyToResolvedIriIdentifierClassProperty ===
        "object" &&
      parameters.optionalLazyToResolvedIriIdentifierClassProperty instanceof
        $LazyObjectOption
    ) {
      this.optionalLazyToResolvedIriIdentifierClassProperty =
        parameters.optionalLazyToResolvedIriIdentifierClassProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalLazyToResolvedIriIdentifierClassProperty,
      )
    ) {
      this.optionalLazyToResolvedIriIdentifierClassProperty =
        new $LazyObjectOption<
          LazilyResolvedIriIdentifierClass.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierClass
        >({
          partial:
            parameters.optionalLazyToResolvedIriIdentifierClassProperty.map(
              (object) => new $NamedDefaultPartial(object),
            ),
          resolver: async () =>
            purify.Either.of(
              (
                parameters.optionalLazyToResolvedIriIdentifierClassProperty as purify.Maybe<LazilyResolvedIriIdentifierClass>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalLazyToResolvedIriIdentifierClassProperty ===
      "object"
    ) {
      this.optionalLazyToResolvedIriIdentifierClassProperty =
        new $LazyObjectOption<
          LazilyResolvedIriIdentifierClass.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierClass
        >({
          partial: purify.Maybe.of(
            new $NamedDefaultPartial(
              parameters.optionalLazyToResolvedIriIdentifierClassProperty,
            ),
          ),
          resolver: async () =>
            purify.Either.of(
              parameters.optionalLazyToResolvedIriIdentifierClassProperty as LazilyResolvedIriIdentifierClass,
            ),
        });
    } else if (
      typeof parameters.optionalLazyToResolvedIriIdentifierClassProperty ===
      "undefined"
    ) {
      this.optionalLazyToResolvedIriIdentifierClassProperty =
        new $LazyObjectOption<
          LazilyResolvedIriIdentifierClass.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierClass
        >({
          partial: purify.Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      this.optionalLazyToResolvedIriIdentifierClassProperty =
        parameters.optionalLazyToResolvedIriIdentifierClassProperty satisfies never;
    }

    if (
      typeof parameters.optionalPartialClassToResolvedClassProperty ===
        "object" &&
      parameters.optionalPartialClassToResolvedClassProperty instanceof
        $LazyObjectOption
    ) {
      this.optionalPartialClassToResolvedClassProperty =
        parameters.optionalPartialClassToResolvedClassProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalPartialClassToResolvedClassProperty,
      )
    ) {
      this.optionalPartialClassToResolvedClassProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: parameters.optionalPartialClassToResolvedClassProperty.map(
          (object) => new PartialClass(object),
        ),
        resolver: async () =>
          purify.Either.of(
            (
              parameters.optionalPartialClassToResolvedClassProperty as purify.Maybe<LazilyResolvedBlankNodeOrIriIdentifierClass>
            ).unsafeCoerce(),
          ),
      });
    } else if (
      typeof parameters.optionalPartialClassToResolvedClassProperty === "object"
    ) {
      this.optionalPartialClassToResolvedClassProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: purify.Maybe.of(
          new PartialClass(
            parameters.optionalPartialClassToResolvedClassProperty,
          ),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.optionalPartialClassToResolvedClassProperty as LazilyResolvedBlankNodeOrIriIdentifierClass,
          ),
      });
    } else if (
      typeof parameters.optionalPartialClassToResolvedClassProperty ===
      "undefined"
    ) {
      this.optionalPartialClassToResolvedClassProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: purify.Maybe.empty(),
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      this.optionalPartialClassToResolvedClassProperty =
        parameters.optionalPartialClassToResolvedClassProperty satisfies never;
    }

    if (
      typeof parameters.optionalPartialClassToResolvedClassUnionProperty ===
        "object" &&
      parameters.optionalPartialClassToResolvedClassUnionProperty instanceof
        $LazyObjectOption
    ) {
      this.optionalPartialClassToResolvedClassUnionProperty =
        parameters.optionalPartialClassToResolvedClassUnionProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalPartialClassToResolvedClassUnionProperty,
      )
    ) {
      this.optionalPartialClassToResolvedClassUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClass,
          LazilyResolvedClassUnion
        >({
          partial:
            parameters.optionalPartialClassToResolvedClassUnionProperty.map(
              (object) => new PartialClass(object),
            ),
          resolver: async () =>
            purify.Either.of(
              (
                parameters.optionalPartialClassToResolvedClassUnionProperty as purify.Maybe<LazilyResolvedClassUnion>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalPartialClassToResolvedClassUnionProperty ===
      "object"
    ) {
      this.optionalPartialClassToResolvedClassUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClass,
          LazilyResolvedClassUnion
        >({
          partial: purify.Maybe.of(
            new PartialClass(
              parameters.optionalPartialClassToResolvedClassUnionProperty,
            ),
          ),
          resolver: async () =>
            purify.Either.of(
              parameters.optionalPartialClassToResolvedClassUnionProperty as LazilyResolvedClassUnion,
            ),
        });
    } else if (
      typeof parameters.optionalPartialClassToResolvedClassUnionProperty ===
      "undefined"
    ) {
      this.optionalPartialClassToResolvedClassUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClass,
          LazilyResolvedClassUnion
        >({
          partial: purify.Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      this.optionalPartialClassToResolvedClassUnionProperty =
        parameters.optionalPartialClassToResolvedClassUnionProperty satisfies never;
    }

    if (
      typeof parameters.optionalPartialClassUnionToResolvedClassUnionProperty ===
        "object" &&
      parameters.optionalPartialClassUnionToResolvedClassUnionProperty instanceof
        $LazyObjectOption
    ) {
      this.optionalPartialClassUnionToResolvedClassUnionProperty =
        parameters.optionalPartialClassUnionToResolvedClassUnionProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalPartialClassUnionToResolvedClassUnionProperty,
      )
    ) {
      this.optionalPartialClassUnionToResolvedClassUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClassUnion,
          LazilyResolvedClassUnion
        >({
          partial:
            parameters.optionalPartialClassUnionToResolvedClassUnionProperty.map(
              (object) => {
                switch (object.$type) {
                  case "LazilyResolvedClassUnionMember1":
                    return new PartialClassUnionMember1(object);
                  case "LazilyResolvedClassUnionMember2":
                    return new PartialClassUnionMember2(object);
                  default:
                    object satisfies never;
                    throw new Error("unrecognized type");
                }
              },
            ),
          resolver: async () =>
            purify.Either.of(
              (
                parameters.optionalPartialClassUnionToResolvedClassUnionProperty as purify.Maybe<LazilyResolvedClassUnion>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalPartialClassUnionToResolvedClassUnionProperty ===
      "object"
    ) {
      this.optionalPartialClassUnionToResolvedClassUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClassUnion,
          LazilyResolvedClassUnion
        >({
          partial: purify.Maybe.of(
            parameters.optionalPartialClassUnionToResolvedClassUnionProperty,
          ).map((object) => {
            switch (object.$type) {
              case "LazilyResolvedClassUnionMember1":
                return new PartialClassUnionMember1(object);
              case "LazilyResolvedClassUnionMember2":
                return new PartialClassUnionMember2(object);
              default:
                object satisfies never;
                throw new Error("unrecognized type");
            }
          }),
          resolver: async () =>
            purify.Either.of(
              parameters.optionalPartialClassUnionToResolvedClassUnionProperty as LazilyResolvedClassUnion,
            ),
        });
    } else if (
      typeof parameters.optionalPartialClassUnionToResolvedClassUnionProperty ===
      "undefined"
    ) {
      this.optionalPartialClassUnionToResolvedClassUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClassUnion,
          LazilyResolvedClassUnion
        >({
          partial: purify.Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      this.optionalPartialClassUnionToResolvedClassUnionProperty =
        parameters.optionalPartialClassUnionToResolvedClassUnionProperty satisfies never;
    }

    if (
      typeof parameters.requiredLazyToResolvedClassProperty === "object" &&
      parameters.requiredLazyToResolvedClassProperty instanceof $LazyObject
    ) {
      this.requiredLazyToResolvedClassProperty =
        parameters.requiredLazyToResolvedClassProperty;
    } else if (
      typeof parameters.requiredLazyToResolvedClassProperty === "object"
    ) {
      this.requiredLazyToResolvedClassProperty = new $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: new $DefaultPartial(
          parameters.requiredLazyToResolvedClassProperty,
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.requiredLazyToResolvedClassProperty as LazilyResolvedBlankNodeOrIriIdentifierClass,
          ),
      });
    } else {
      this.requiredLazyToResolvedClassProperty =
        parameters.requiredLazyToResolvedClassProperty satisfies never;
    }

    if (
      typeof parameters.requiredPartialClassToResolvedClassProperty ===
        "object" &&
      parameters.requiredPartialClassToResolvedClassProperty instanceof
        $LazyObject
    ) {
      this.requiredPartialClassToResolvedClassProperty =
        parameters.requiredPartialClassToResolvedClassProperty;
    } else if (
      typeof parameters.requiredPartialClassToResolvedClassProperty === "object"
    ) {
      this.requiredPartialClassToResolvedClassProperty = new $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: new PartialClass(
          parameters.requiredPartialClassToResolvedClassProperty,
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.requiredPartialClassToResolvedClassProperty as LazilyResolvedBlankNodeOrIriIdentifierClass,
          ),
      });
    } else {
      this.requiredPartialClassToResolvedClassProperty =
        parameters.requiredPartialClassToResolvedClassProperty satisfies never;
    }

    if (
      typeof parameters.setLazyToResolvedClassProperty === "object" &&
      parameters.setLazyToResolvedClassProperty instanceof $LazyObjectSet
    ) {
      this.setLazyToResolvedClassProperty =
        parameters.setLazyToResolvedClassProperty;
    } else if (typeof parameters.setLazyToResolvedClassProperty === "object") {
      this.setLazyToResolvedClassProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partials: parameters.setLazyToResolvedClassProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.setLazyToResolvedClassProperty as readonly LazilyResolvedBlankNodeOrIriIdentifierClass[],
          ),
      });
    } else if (
      typeof parameters.setLazyToResolvedClassProperty === "undefined"
    ) {
      this.setLazyToResolvedClassProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partials: [],
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      this.setLazyToResolvedClassProperty =
        parameters.setLazyToResolvedClassProperty satisfies never;
    }

    if (
      typeof parameters.setPartialClassToResolvedClassProperty === "object" &&
      parameters.setPartialClassToResolvedClassProperty instanceof
        $LazyObjectSet
    ) {
      this.setPartialClassToResolvedClassProperty =
        parameters.setPartialClassToResolvedClassProperty;
    } else if (
      typeof parameters.setPartialClassToResolvedClassProperty === "object"
    ) {
      this.setPartialClassToResolvedClassProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partials: parameters.setPartialClassToResolvedClassProperty.map(
          (object) => new PartialClass(object),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.setPartialClassToResolvedClassProperty as readonly LazilyResolvedBlankNodeOrIriIdentifierClass[],
          ),
      });
    } else if (
      typeof parameters.setPartialClassToResolvedClassProperty === "undefined"
    ) {
      this.setPartialClassToResolvedClassProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partials: [],
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      this.setPartialClassToResolvedClassProperty =
        parameters.setPartialClassToResolvedClassProperty satisfies never;
    }
  }

  get $identifier(): LazyPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: LazyPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          this.optionalLazyToResolvedClassProperty,
          other.optionalLazyToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalLazyToResolvedClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          this.optionalLazyToResolvedClassUnionProperty,
          other.optionalLazyToResolvedClassUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalLazyToResolvedClassUnionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          this.optionalLazyToResolvedIriIdentifierClassProperty,
          other.optionalLazyToResolvedIriIdentifierClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalLazyToResolvedIriIdentifierClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          this.optionalPartialClassToResolvedClassProperty,
          other.optionalPartialClassToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalPartialClassToResolvedClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          this.optionalPartialClassToResolvedClassUnionProperty,
          other.optionalPartialClassToResolvedClassUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalPartialClassToResolvedClassUnionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, PartialClassUnion.$equals))(
            left.partial,
            right.partial,
          ))(
          this.optionalPartialClassUnionToResolvedClassUnionProperty,
          other.optionalPartialClassUnionToResolvedClassUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalPartialClassUnionToResolvedClassUnionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) => left.$equals(right))(left.partial, right.partial))(
          this.requiredLazyToResolvedClassProperty,
          other.requiredLazyToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "requiredLazyToResolvedClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) => left.$equals(right))(left.partial, right.partial))(
          this.requiredPartialClassToResolvedClassProperty,
          other.requiredPartialClassToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "requiredPartialClassToResolvedClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $arrayEquals(left, right, (left, right) => left.$equals(right)))(
            left.partials,
            right.partials,
          ))(
          this.setLazyToResolvedClassProperty,
          other.setLazyToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "setLazyToResolvedClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $arrayEquals(left, right, (left, right) => left.$equals(right)))(
            left.partials,
            right.partials,
          ))(
          this.setPartialClassToResolvedClassProperty,
          other.setPartialClassToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "setPartialClassToResolvedClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.optionalLazyToResolvedClassProperty.partial.ifJust((value1) => {
      value1.$hash(_hasher);
    });
    this.optionalLazyToResolvedClassUnionProperty.partial.ifJust((value1) => {
      value1.$hash(_hasher);
    });
    this.optionalLazyToResolvedIriIdentifierClassProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    this.optionalPartialClassToResolvedClassProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    this.optionalPartialClassToResolvedClassUnionProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    this.optionalPartialClassUnionToResolvedClassUnionProperty.partial.ifJust(
      (value1) => {
        PartialClassUnion.$hash(value1, _hasher);
      },
    );
    this.requiredLazyToResolvedClassProperty.partial.$hash(_hasher);
    this.requiredPartialClassToResolvedClassProperty.partial.$hash(_hasher);
    for (const item1 of this.setLazyToResolvedClassProperty.partials) {
      item1.$hash(_hasher);
    }

    for (const item1 of this.setPartialClassToResolvedClassProperty.partials) {
      item1.$hash(_hasher);
    }

    return _hasher;
  }

  $toJson(): LazyPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        optionalLazyToResolvedClassProperty:
          this.optionalLazyToResolvedClassProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalLazyToResolvedClassUnionProperty:
          this.optionalLazyToResolvedClassUnionProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalLazyToResolvedIriIdentifierClassProperty:
          this.optionalLazyToResolvedIriIdentifierClassProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalPartialClassToResolvedClassProperty:
          this.optionalPartialClassToResolvedClassProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalPartialClassToResolvedClassUnionProperty:
          this.optionalPartialClassToResolvedClassUnionProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalPartialClassUnionToResolvedClassUnionProperty:
          this.optionalPartialClassUnionToResolvedClassUnionProperty.partial
            .map((item) => PartialClassUnion.$toJson(item))
            .extract(),
        requiredLazyToResolvedClassProperty:
          this.requiredLazyToResolvedClassProperty.partial.$toJson(),
        requiredPartialClassToResolvedClassProperty:
          this.requiredPartialClassToResolvedClassProperty.partial.$toJson(),
        setLazyToResolvedClassProperty:
          this.setLazyToResolvedClassProperty.partials.map((item) =>
            item.$toJson(),
          ),
        setPartialClassToResolvedClassProperty:
          this.setPartialClassToResolvedClassProperty.partials.map((item) =>
            item.$toJson(),
          ),
      } satisfies LazyPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      LazyPropertiesClass.$properties.optionalLazyToResolvedClassProperty[
        "identifier"
      ],
      ...this.optionalLazyToResolvedClassProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesClass.$properties.optionalLazyToResolvedClassUnionProperty[
        "identifier"
      ],
      ...this.optionalLazyToResolvedClassUnionProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesClass.$properties
        .optionalLazyToResolvedIriIdentifierClassProperty["identifier"],
      ...this.optionalLazyToResolvedIriIdentifierClassProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesClass.$properties
        .optionalPartialClassToResolvedClassProperty["identifier"],
      ...this.optionalPartialClassToResolvedClassProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesClass.$properties
        .optionalPartialClassToResolvedClassUnionProperty["identifier"],
      ...this.optionalPartialClassToResolvedClassUnionProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesClass.$properties
        .optionalPartialClassUnionToResolvedClassUnionProperty["identifier"],
      ...this.optionalPartialClassUnionToResolvedClassUnionProperty.partial
        .toList()
        .flatMap((value) => [
          PartialClassUnion.$toRdf(value, { mutateGraph, resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesClass.$properties.requiredLazyToResolvedClassProperty[
        "identifier"
      ],
      ...[
        this.requiredLazyToResolvedClassProperty.partial.$toRdf({
          mutateGraph: mutateGraph,
          resourceSet: resourceSet,
        }).identifier,
      ],
    );
    resource.add(
      LazyPropertiesClass.$properties
        .requiredPartialClassToResolvedClassProperty["identifier"],
      ...[
        this.requiredPartialClassToResolvedClassProperty.partial.$toRdf({
          mutateGraph: mutateGraph,
          resourceSet: resourceSet,
        }).identifier,
      ],
    );
    resource.add(
      LazyPropertiesClass.$properties.setLazyToResolvedClassProperty[
        "identifier"
      ],
      ...this.setLazyToResolvedClassProperty.partials.flatMap((item) => [
        item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
          .identifier,
      ]),
    );
    resource.add(
      LazyPropertiesClass.$properties.setPartialClassToResolvedClassProperty[
        "identifier"
      ],
      ...this.setPartialClassToResolvedClassProperty.partials.flatMap(
        (item) => [
          item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ],
      ),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LazyPropertiesClass {
  export function $filter(
    filter: LazyPropertiesClass.$Filter,
    value: LazyPropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.optionalLazyToResolvedClassProperty !== "undefined" &&
      !((
        filter: $MaybeFilter<$DefaultPartial.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >,
      ) =>
        $filterMaybe<$DefaultPartial, $DefaultPartial.$Filter>(
          $DefaultPartial.$filter,
        )(filter, value.partial))(
        filter.optionalLazyToResolvedClassProperty,
        value.optionalLazyToResolvedClassProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalLazyToResolvedClassUnionProperty !== "undefined" &&
      !((
        filter: $MaybeFilter<$DefaultPartial.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          $DefaultPartial,
          LazilyResolvedClassUnion
        >,
      ) =>
        $filterMaybe<$DefaultPartial, $DefaultPartial.$Filter>(
          $DefaultPartial.$filter,
        )(filter, value.partial))(
        filter.optionalLazyToResolvedClassUnionProperty,
        value.optionalLazyToResolvedClassUnionProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalLazyToResolvedIriIdentifierClassProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<$NamedDefaultPartial.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedIriIdentifierClass.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierClass
        >,
      ) =>
        $filterMaybe<$NamedDefaultPartial, $NamedDefaultPartial.$Filter>(
          $NamedDefaultPartial.$filter,
        )(filter, value.partial))(
        filter.optionalLazyToResolvedIriIdentifierClassProperty,
        value.optionalLazyToResolvedIriIdentifierClassProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalPartialClassToResolvedClassProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<PartialClass.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >,
      ) =>
        $filterMaybe<PartialClass, PartialClass.$Filter>(PartialClass.$filter)(
          filter,
          value.partial,
        ))(
        filter.optionalPartialClassToResolvedClassProperty,
        value.optionalPartialClassToResolvedClassProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalPartialClassToResolvedClassUnionProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<PartialClass.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClass,
          LazilyResolvedClassUnion
        >,
      ) =>
        $filterMaybe<PartialClass, PartialClass.$Filter>(PartialClass.$filter)(
          filter,
          value.partial,
        ))(
        filter.optionalPartialClassToResolvedClassUnionProperty,
        value.optionalPartialClassToResolvedClassUnionProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalPartialClassUnionToResolvedClassUnionProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<PartialClassUnion.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClassUnion,
          LazilyResolvedClassUnion
        >,
      ) =>
        $filterMaybe<PartialClassUnion, PartialClassUnion.$Filter>(
          PartialClassUnion.$filter,
        )(filter, value.partial))(
        filter.optionalPartialClassUnionToResolvedClassUnionProperty,
        value.optionalPartialClassUnionToResolvedClassUnionProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.requiredLazyToResolvedClassProperty !== "undefined" &&
      !((
        filter: $DefaultPartial.$Filter,
        value: $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >,
      ) => $DefaultPartial.$filter(filter, value.partial))(
        filter.requiredLazyToResolvedClassProperty,
        value.requiredLazyToResolvedClassProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.requiredPartialClassToResolvedClassProperty !==
        "undefined" &&
      !((
        filter: PartialClass.$Filter,
        value: $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >,
      ) => PartialClass.$filter(filter, value.partial))(
        filter.requiredPartialClassToResolvedClassProperty,
        value.requiredPartialClassToResolvedClassProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.setLazyToResolvedClassProperty !== "undefined" &&
      !((
        filter: $CollectionFilter<$DefaultPartial.$Filter>,
        value: $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >,
      ) =>
        $filterArray<$DefaultPartial, $DefaultPartial.$Filter>(
          $DefaultPartial.$filter,
        )(filter, value.partials))(
        filter.setLazyToResolvedClassProperty,
        value.setLazyToResolvedClassProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.setPartialClassToResolvedClassProperty !== "undefined" &&
      !((
        filter: $CollectionFilter<PartialClass.$Filter>,
        value: $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >,
      ) =>
        $filterArray<PartialClass, PartialClass.$Filter>(PartialClass.$filter)(
          filter,
          value.partials,
        ))(
        filter.setPartialClassToResolvedClassProperty,
        value.setPartialClassToResolvedClassProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly optionalLazyToResolvedClassProperty?: $MaybeFilter<$DefaultPartial.$Filter>;
    readonly optionalLazyToResolvedClassUnionProperty?: $MaybeFilter<$DefaultPartial.$Filter>;
    readonly optionalLazyToResolvedIriIdentifierClassProperty?: $MaybeFilter<$NamedDefaultPartial.$Filter>;
    readonly optionalPartialClassToResolvedClassProperty?: $MaybeFilter<PartialClass.$Filter>;
    readonly optionalPartialClassToResolvedClassUnionProperty?: $MaybeFilter<PartialClass.$Filter>;
    readonly optionalPartialClassUnionToResolvedClassUnionProperty?: $MaybeFilter<PartialClassUnion.$Filter>;
    readonly requiredLazyToResolvedClassProperty?: $DefaultPartial.$Filter;
    readonly requiredPartialClassToResolvedClassProperty?: PartialClass.$Filter;
    readonly setLazyToResolvedClassProperty?: $CollectionFilter<$DefaultPartial.$Filter>;
    readonly setPartialClassToResolvedClassProperty?: $CollectionFilter<PartialClass.$Filter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazyPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new LazyPropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazyPropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazyPropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new LazyPropertiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazyPropertiesClass";
    readonly optionalLazyToResolvedClassProperty?: $DefaultPartial.$Json;
    readonly optionalLazyToResolvedClassUnionProperty?: $DefaultPartial.$Json;
    readonly optionalLazyToResolvedIriIdentifierClassProperty?: $NamedDefaultPartial.$Json;
    readonly optionalPartialClassToResolvedClassProperty?: PartialClass.$Json;
    readonly optionalPartialClassToResolvedClassUnionProperty?: PartialClass.$Json;
    readonly optionalPartialClassUnionToResolvedClassUnionProperty?:
      | PartialClassUnionMember1.$Json
      | PartialClassUnionMember2.$Json;
    readonly requiredLazyToResolvedClassProperty: $DefaultPartial.$Json;
    readonly requiredPartialClassToResolvedClassProperty: PartialClass.$Json;
    readonly setLazyToResolvedClassProperty?: readonly $DefaultPartial.$Json[];
    readonly setPartialClassToResolvedClassProperty?: readonly PartialClass.$Json[];
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazyPropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedClassProperty`,
        }),
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedClassUnionProperty`,
        }),
        $NamedDefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedIriIdentifierClassProperty`,
        }),
        PartialClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalPartialClassToResolvedClassProperty`,
        }),
        PartialClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalPartialClassToResolvedClassUnionProperty`,
        }),
        {
          scope: `${scopePrefix}/properties/optionalPartialClassUnionToResolvedClassUnionProperty`,
          type: "Control",
        },
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/requiredLazyToResolvedClassProperty`,
        }),
        PartialClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/requiredPartialClassToResolvedClassProperty`,
        }),
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/setLazyToResolvedClassProperty`,
        }),
        PartialClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/setPartialClassToResolvedClassProperty`,
        }),
      ],
      label: "LazyPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazyPropertiesClass"),
      optionalLazyToResolvedClassProperty: $DefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalLazyToResolvedClassUnionProperty: $DefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalLazyToResolvedIriIdentifierClassProperty: $NamedDefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalPartialClassToResolvedClassProperty:
        PartialClass.$jsonZodSchema().optional(),
      optionalPartialClassToResolvedClassUnionProperty:
        PartialClass.$jsonZodSchema().optional(),
      optionalPartialClassUnionToResolvedClassUnionProperty:
        PartialClassUnion.$jsonZodSchema().optional(),
      requiredLazyToResolvedClassProperty: $DefaultPartial.$jsonZodSchema(),
      requiredPartialClassToResolvedClassProperty:
        PartialClass.$jsonZodSchema(),
      setLazyToResolvedClassProperty: $DefaultPartial
        .$jsonZodSchema()
        .array()
        .default(() => []),
      setPartialClassToResolvedClassProperty: PartialClass.$jsonZodSchema()
        .array()
        .default(() => []),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    optionalLazyToResolvedClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalLazyToResolvedClassProperty",
      ),
    },
    optionalLazyToResolvedClassUnionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalLazyToResolvedClassUnionProperty",
      ),
    },
    optionalLazyToResolvedIriIdentifierClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalLazyToResolvedIriIdentifierClassProperty",
      ),
    },
    optionalPartialClassToResolvedClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalPartialClassToResolvedClassProperty",
      ),
    },
    optionalPartialClassToResolvedClassUnionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalPartialClassToResolvedClassUnionProperty",
      ),
    },
    optionalPartialClassUnionToResolvedClassUnionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalPartialClassUnionToResolvedClassUnionProperty",
      ),
    },
    requiredLazyToResolvedClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/requiredLazyToResolvedClassProperty",
      ),
    },
    requiredPartialClassToResolvedClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/requiredPartialClassToResolvedClassProperty",
      ),
    },
    setLazyToResolvedClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/setLazyToResolvedClassProperty",
      ),
    },
    setPartialClassToResolvedClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/setPartialClassToResolvedClassProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      optionalLazyToResolvedClassProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      optionalLazyToResolvedClassUnionProperty: $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >;
      optionalLazyToResolvedIriIdentifierClassProperty: $LazyObjectOption<
        LazilyResolvedIriIdentifierClass.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriIdentifierClass
      >;
      optionalPartialClassToResolvedClassProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      optionalPartialClassToResolvedClassUnionProperty: $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        PartialClass,
        LazilyResolvedClassUnion
      >;
      optionalPartialClassUnionToResolvedClassUnionProperty: $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        PartialClassUnion,
        LazilyResolvedClassUnion
      >;
      requiredLazyToResolvedClassProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      requiredPartialClassToResolvedClassProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      setLazyToResolvedClassProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      setPartialClassToResolvedClassProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const optionalLazyToResolvedClassProperty = new $LazyObjectOption<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierClass
    >({
      partial: purify.Maybe.fromNullable(
        $jsonObject["optionalLazyToResolvedClassProperty"],
      ).map((item) => $DefaultPartial.$fromJson(item).unsafeCoerce()),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const optionalLazyToResolvedClassUnionProperty = new $LazyObjectOption<
      LazilyResolvedClassUnion.$Identifier,
      $DefaultPartial,
      LazilyResolvedClassUnion
    >({
      partial: purify.Maybe.fromNullable(
        $jsonObject["optionalLazyToResolvedClassUnionProperty"],
      ).map((item) => $DefaultPartial.$fromJson(item).unsafeCoerce()),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const optionalLazyToResolvedIriIdentifierClassProperty =
      new $LazyObjectOption<
        LazilyResolvedIriIdentifierClass.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriIdentifierClass
      >({
        partial: purify.Maybe.fromNullable(
          $jsonObject["optionalLazyToResolvedIriIdentifierClassProperty"],
        ).map((item) => $NamedDefaultPartial.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            purify.Left(
              new Error(
                `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const optionalPartialClassToResolvedClassProperty = new $LazyObjectOption<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
      PartialClass,
      LazilyResolvedBlankNodeOrIriIdentifierClass
    >({
      partial: purify.Maybe.fromNullable(
        $jsonObject["optionalPartialClassToResolvedClassProperty"],
      ).map((item) => PartialClass.$fromJson(item).unsafeCoerce()),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const optionalPartialClassToResolvedClassUnionProperty =
      new $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        PartialClass,
        LazilyResolvedClassUnion
      >({
        partial: purify.Maybe.fromNullable(
          $jsonObject["optionalPartialClassToResolvedClassUnionProperty"],
        ).map((item) => PartialClass.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            purify.Left(
              new Error(
                `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const optionalPartialClassUnionToResolvedClassUnionProperty =
      new $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        PartialClassUnion,
        LazilyResolvedClassUnion
      >({
        partial: purify.Maybe.fromNullable(
          $jsonObject["optionalPartialClassUnionToResolvedClassUnionProperty"],
        ).map((item) => PartialClassUnion.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            purify.Left(
              new Error(
                `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const requiredLazyToResolvedClassProperty = new $LazyObject<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierClass
    >({
      partial: $DefaultPartial
        .$fromJson($jsonObject["requiredLazyToResolvedClassProperty"])
        .unsafeCoerce(),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const requiredPartialClassToResolvedClassProperty = new $LazyObject<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
      PartialClass,
      LazilyResolvedBlankNodeOrIriIdentifierClass
    >({
      partial: PartialClass.$fromJson(
        $jsonObject["requiredPartialClassToResolvedClassProperty"],
      ).unsafeCoerce(),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const setLazyToResolvedClassProperty = new $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierClass
    >({
      partials: $jsonObject["setLazyToResolvedClassProperty"].map((item) =>
        $DefaultPartial.$fromJson(item).unsafeCoerce(),
      ),
      resolver: () =>
        Promise.resolve(
          purify.Left(
            new Error("unable to resolve identifiers deserialized from JSON"),
          ),
        ),
    });
    const setPartialClassToResolvedClassProperty = new $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
      PartialClass,
      LazilyResolvedBlankNodeOrIriIdentifierClass
    >({
      partials: $jsonObject["setPartialClassToResolvedClassProperty"].map(
        (item) => PartialClass.$fromJson(item).unsafeCoerce(),
      ),
      resolver: () =>
        Promise.resolve(
          purify.Left(
            new Error("unable to resolve identifiers deserialized from JSON"),
          ),
        ),
    });
    return purify.Either.of({
      $identifier,
      optionalLazyToResolvedClassProperty,
      optionalLazyToResolvedClassUnionProperty,
      optionalLazyToResolvedIriIdentifierClassProperty,
      optionalPartialClassToResolvedClassProperty,
      optionalPartialClassToResolvedClassUnionProperty,
      optionalPartialClassUnionToResolvedClassUnionProperty,
      requiredLazyToResolvedClassProperty,
      requiredPartialClassToResolvedClassProperty,
      setLazyToResolvedClassProperty,
      setPartialClassToResolvedClassProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      optionalLazyToResolvedClassProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      optionalLazyToResolvedClassUnionProperty: $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >;
      optionalLazyToResolvedIriIdentifierClassProperty: $LazyObjectOption<
        LazilyResolvedIriIdentifierClass.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriIdentifierClass
      >;
      optionalPartialClassToResolvedClassProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      optionalPartialClassToResolvedClassUnionProperty: $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        PartialClass,
        LazilyResolvedClassUnion
      >;
      optionalPartialClassUnionToResolvedClassUnionProperty: $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        PartialClassUnion,
        LazilyResolvedClassUnion
      >;
      requiredLazyToResolvedClassProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      requiredPartialClassToResolvedClassProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      setLazyToResolvedClassProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      setPartialClassToResolvedClassProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
    }
  > {
    return purify.Either.of<Error, LazyPropertiesClass.$Identifier>(
      $parameters.resource.identifier as LazyPropertiesClass.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.optionalLazyToResolvedClassProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          values.chainMap((value) =>
            value.toResource().chain((resource) =>
              $DefaultPartial.$fromRdf(resource, {
                context: $parameters.context,
                ignoreRdfType: true,
                objectSet: $parameters.objectSet,
                preferredLanguages: $parameters.preferredLanguages,
              }),
            ),
          ),
        )
        .map((values) =>
          values.length > 0
            ? values.map((value) => purify.Maybe.of(value))
            : rdfjsResource.Resource.Values.fromValue<
                purify.Maybe<$DefaultPartial>
              >({
                focusResource: $parameters.resource,
                predicate:
                  LazyPropertiesClass.$properties
                    .optionalLazyToResolvedClassProperty["identifier"],
                value: purify.Maybe.empty(),
              }),
        )
        .map((values) =>
          values.map(
            (partial) =>
              new $LazyObjectOption<
                LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
                $DefaultPartial,
                LazilyResolvedBlankNodeOrIriIdentifierClass
              >({
                partial,
                resolver: (identifier) =>
                  $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierClass(
                    identifier,
                  ),
              }),
          ),
        )
        .chain((values) => values.head())
        .chain((optionalLazyToResolvedClassProperty) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.optionalLazyToResolvedClassUnionProperty[
                "identifier"
              ],
              { unique: true },
            ),
          )
            .chain((values) =>
              values.chainMap((value) =>
                value.toResource().chain((resource) =>
                  $DefaultPartial.$fromRdf(resource, {
                    context: $parameters.context,
                    ignoreRdfType: true,
                    objectSet: $parameters.objectSet,
                    preferredLanguages: $parameters.preferredLanguages,
                  }),
                ),
              ),
            )
            .map((values) =>
              values.length > 0
                ? values.map((value) => purify.Maybe.of(value))
                : rdfjsResource.Resource.Values.fromValue<
                    purify.Maybe<$DefaultPartial>
                  >({
                    focusResource: $parameters.resource,
                    predicate:
                      LazyPropertiesClass.$properties
                        .optionalLazyToResolvedClassUnionProperty["identifier"],
                    value: purify.Maybe.empty(),
                  }),
            )
            .map((values) =>
              values.map(
                (partial) =>
                  new $LazyObjectOption<
                    LazilyResolvedClassUnion.$Identifier,
                    $DefaultPartial,
                    LazilyResolvedClassUnion
                  >({
                    partial,
                    resolver: (identifier) =>
                      $parameters.objectSet.lazilyResolvedClassUnion(
                        identifier,
                      ),
                  }),
              ),
            )
            .chain((values) => values.head())
            .chain((optionalLazyToResolvedClassUnionProperty) =>
              purify.Either.of<
                Error,
                rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
              >(
                $parameters.resource.values(
                  $properties.optionalLazyToResolvedIriIdentifierClassProperty[
                    "identifier"
                  ],
                  { unique: true },
                ),
              )
                .chain((values) =>
                  values.chainMap((value) =>
                    value.toResource().chain((resource) =>
                      $NamedDefaultPartial.$fromRdf(resource, {
                        context: $parameters.context,
                        ignoreRdfType: true,
                        objectSet: $parameters.objectSet,
                        preferredLanguages: $parameters.preferredLanguages,
                      }),
                    ),
                  ),
                )
                .map((values) =>
                  values.length > 0
                    ? values.map((value) => purify.Maybe.of(value))
                    : rdfjsResource.Resource.Values.fromValue<
                        purify.Maybe<$NamedDefaultPartial>
                      >({
                        focusResource: $parameters.resource,
                        predicate:
                          LazyPropertiesClass.$properties
                            .optionalLazyToResolvedIriIdentifierClassProperty[
                            "identifier"
                          ],
                        value: purify.Maybe.empty(),
                      }),
                )
                .map((values) =>
                  values.map(
                    (partial) =>
                      new $LazyObjectOption<
                        LazilyResolvedIriIdentifierClass.$Identifier,
                        $NamedDefaultPartial,
                        LazilyResolvedIriIdentifierClass
                      >({
                        partial,
                        resolver: (identifier) =>
                          $parameters.objectSet.lazilyResolvedIriIdentifierClass(
                            identifier,
                          ),
                      }),
                  ),
                )
                .chain((values) => values.head())
                .chain((optionalLazyToResolvedIriIdentifierClassProperty) =>
                  purify.Either.of<
                    Error,
                    rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                  >(
                    $parameters.resource.values(
                      $properties.optionalPartialClassToResolvedClassProperty[
                        "identifier"
                      ],
                      { unique: true },
                    ),
                  )
                    .chain((values) =>
                      values.chainMap((value) =>
                        value.toResource().chain((resource) =>
                          PartialClass.$fromRdf(resource, {
                            context: $parameters.context,
                            ignoreRdfType: true,
                            objectSet: $parameters.objectSet,
                            preferredLanguages: $parameters.preferredLanguages,
                          }),
                        ),
                      ),
                    )
                    .map((values) =>
                      values.length > 0
                        ? values.map((value) => purify.Maybe.of(value))
                        : rdfjsResource.Resource.Values.fromValue<
                            purify.Maybe<PartialClass>
                          >({
                            focusResource: $parameters.resource,
                            predicate:
                              LazyPropertiesClass.$properties
                                .optionalPartialClassToResolvedClassProperty[
                                "identifier"
                              ],
                            value: purify.Maybe.empty(),
                          }),
                    )
                    .map((values) =>
                      values.map(
                        (partial) =>
                          new $LazyObjectOption<
                            LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
                            PartialClass,
                            LazilyResolvedBlankNodeOrIriIdentifierClass
                          >({
                            partial,
                            resolver: (identifier) =>
                              $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierClass(
                                identifier,
                              ),
                          }),
                      ),
                    )
                    .chain((values) => values.head())
                    .chain((optionalPartialClassToResolvedClassProperty) =>
                      purify.Either.of<
                        Error,
                        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                      >(
                        $parameters.resource.values(
                          $properties
                            .optionalPartialClassToResolvedClassUnionProperty[
                            "identifier"
                          ],
                          { unique: true },
                        ),
                      )
                        .chain((values) =>
                          values.chainMap((value) =>
                            value.toResource().chain((resource) =>
                              PartialClass.$fromRdf(resource, {
                                context: $parameters.context,
                                ignoreRdfType: true,
                                objectSet: $parameters.objectSet,
                                preferredLanguages:
                                  $parameters.preferredLanguages,
                              }),
                            ),
                          ),
                        )
                        .map((values) =>
                          values.length > 0
                            ? values.map((value) => purify.Maybe.of(value))
                            : rdfjsResource.Resource.Values.fromValue<
                                purify.Maybe<PartialClass>
                              >({
                                focusResource: $parameters.resource,
                                predicate:
                                  LazyPropertiesClass.$properties
                                    .optionalPartialClassToResolvedClassUnionProperty[
                                    "identifier"
                                  ],
                                value: purify.Maybe.empty(),
                              }),
                        )
                        .map((values) =>
                          values.map(
                            (partial) =>
                              new $LazyObjectOption<
                                LazilyResolvedClassUnion.$Identifier,
                                PartialClass,
                                LazilyResolvedClassUnion
                              >({
                                partial,
                                resolver: (identifier) =>
                                  $parameters.objectSet.lazilyResolvedClassUnion(
                                    identifier,
                                  ),
                              }),
                          ),
                        )
                        .chain((values) => values.head())
                        .chain(
                          (optionalPartialClassToResolvedClassUnionProperty) =>
                            purify.Either.of<
                              Error,
                              rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                            >(
                              $parameters.resource.values(
                                $properties
                                  .optionalPartialClassUnionToResolvedClassUnionProperty[
                                  "identifier"
                                ],
                                { unique: true },
                              ),
                            )
                              .chain((values) =>
                                values.chainMap((value) =>
                                  value.toResource().chain((resource) =>
                                    PartialClassUnion.$fromRdf(resource, {
                                      context: $parameters.context,
                                      ignoreRdfType: false,
                                      objectSet: $parameters.objectSet,
                                      preferredLanguages:
                                        $parameters.preferredLanguages,
                                    }),
                                  ),
                                ),
                              )
                              .map((values) =>
                                values.length > 0
                                  ? values.map((value) =>
                                      purify.Maybe.of(value),
                                    )
                                  : rdfjsResource.Resource.Values.fromValue<
                                      purify.Maybe<PartialClassUnion>
                                    >({
                                      focusResource: $parameters.resource,
                                      predicate:
                                        LazyPropertiesClass.$properties
                                          .optionalPartialClassUnionToResolvedClassUnionProperty[
                                          "identifier"
                                        ],
                                      value: purify.Maybe.empty(),
                                    }),
                              )
                              .map((values) =>
                                values.map(
                                  (partial) =>
                                    new $LazyObjectOption<
                                      LazilyResolvedClassUnion.$Identifier,
                                      PartialClassUnion,
                                      LazilyResolvedClassUnion
                                    >({
                                      partial,
                                      resolver: (identifier) =>
                                        $parameters.objectSet.lazilyResolvedClassUnion(
                                          identifier,
                                        ),
                                    }),
                                ),
                              )
                              .chain((values) => values.head())
                              .chain(
                                (
                                  optionalPartialClassUnionToResolvedClassUnionProperty,
                                ) =>
                                  purify.Either.of<
                                    Error,
                                    rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                                  >(
                                    $parameters.resource.values(
                                      $properties
                                        .requiredLazyToResolvedClassProperty[
                                        "identifier"
                                      ],
                                      { unique: true },
                                    ),
                                  )
                                    .chain((values) =>
                                      values.chainMap((value) =>
                                        value.toResource().chain((resource) =>
                                          $DefaultPartial.$fromRdf(resource, {
                                            context: $parameters.context,
                                            ignoreRdfType: true,
                                            objectSet: $parameters.objectSet,
                                            preferredLanguages:
                                              $parameters.preferredLanguages,
                                          }),
                                        ),
                                      ),
                                    )
                                    .map((values) =>
                                      values.map(
                                        (partial) =>
                                          new $LazyObject<
                                            LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
                                            $DefaultPartial,
                                            LazilyResolvedBlankNodeOrIriIdentifierClass
                                          >({
                                            partial,
                                            resolver: (identifier) =>
                                              $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierClass(
                                                identifier,
                                              ),
                                          }),
                                      ),
                                    )
                                    .chain((values) => values.head())
                                    .chain(
                                      (requiredLazyToResolvedClassProperty) =>
                                        purify.Either.of<
                                          Error,
                                          rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                                        >(
                                          $parameters.resource.values(
                                            $properties
                                              .requiredPartialClassToResolvedClassProperty[
                                              "identifier"
                                            ],
                                            { unique: true },
                                          ),
                                        )
                                          .chain((values) =>
                                            values.chainMap((value) =>
                                              value
                                                .toResource()
                                                .chain((resource) =>
                                                  PartialClass.$fromRdf(
                                                    resource,
                                                    {
                                                      context:
                                                        $parameters.context,
                                                      ignoreRdfType: true,
                                                      objectSet:
                                                        $parameters.objectSet,
                                                      preferredLanguages:
                                                        $parameters.preferredLanguages,
                                                    },
                                                  ),
                                                ),
                                            ),
                                          )
                                          .map((values) =>
                                            values.map(
                                              (partial) =>
                                                new $LazyObject<
                                                  LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
                                                  PartialClass,
                                                  LazilyResolvedBlankNodeOrIriIdentifierClass
                                                >({
                                                  partial,
                                                  resolver: (identifier) =>
                                                    $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierClass(
                                                      identifier,
                                                    ),
                                                }),
                                            ),
                                          )
                                          .chain((values) => values.head())
                                          .chain(
                                            (
                                              requiredPartialClassToResolvedClassProperty,
                                            ) =>
                                              purify.Either.of<
                                                Error,
                                                rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                                              >(
                                                $parameters.resource.values(
                                                  $properties
                                                    .setLazyToResolvedClassProperty[
                                                    "identifier"
                                                  ],
                                                  { unique: true },
                                                ),
                                              )
                                                .chain((values) =>
                                                  values.chainMap((value) =>
                                                    value
                                                      .toResource()
                                                      .chain((resource) =>
                                                        $DefaultPartial.$fromRdf(
                                                          resource,
                                                          {
                                                            context:
                                                              $parameters.context,
                                                            ignoreRdfType: true,
                                                            objectSet:
                                                              $parameters.objectSet,
                                                            preferredLanguages:
                                                              $parameters.preferredLanguages,
                                                          },
                                                        ),
                                                      ),
                                                  ),
                                                )
                                                .map((values) =>
                                                  values.toArray(),
                                                )
                                                .map((valuesArray) =>
                                                  rdfjsResource.Resource.Values.fromValue(
                                                    {
                                                      focusResource:
                                                        $parameters.resource,
                                                      predicate:
                                                        LazyPropertiesClass
                                                          .$properties
                                                          .setLazyToResolvedClassProperty[
                                                          "identifier"
                                                        ],
                                                      value: valuesArray,
                                                    },
                                                  ),
                                                )
                                                .map((values) =>
                                                  values.map(
                                                    (partials) =>
                                                      new $LazyObjectSet<
                                                        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
                                                        $DefaultPartial,
                                                        LazilyResolvedBlankNodeOrIriIdentifierClass
                                                      >({
                                                        partials,
                                                        resolver: (
                                                          identifiers,
                                                        ) =>
                                                          $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierClasses(
                                                            {
                                                              filter: {
                                                                $identifier: {
                                                                  in: identifiers,
                                                                },
                                                              },
                                                            },
                                                          ),
                                                      }),
                                                  ),
                                                )
                                                .chain((values) =>
                                                  values.head(),
                                                )
                                                .chain(
                                                  (
                                                    setLazyToResolvedClassProperty,
                                                  ) =>
                                                    purify.Either.of<
                                                      Error,
                                                      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                                                    >(
                                                      $parameters.resource.values(
                                                        $properties
                                                          .setPartialClassToResolvedClassProperty[
                                                          "identifier"
                                                        ],
                                                        { unique: true },
                                                      ),
                                                    )
                                                      .chain((values) =>
                                                        values.chainMap(
                                                          (value) =>
                                                            value
                                                              .toResource()
                                                              .chain(
                                                                (resource) =>
                                                                  PartialClass.$fromRdf(
                                                                    resource,
                                                                    {
                                                                      context:
                                                                        $parameters.context,
                                                                      ignoreRdfType: true,
                                                                      objectSet:
                                                                        $parameters.objectSet,
                                                                      preferredLanguages:
                                                                        $parameters.preferredLanguages,
                                                                    },
                                                                  ),
                                                              ),
                                                        ),
                                                      )
                                                      .map((values) =>
                                                        values.toArray(),
                                                      )
                                                      .map((valuesArray) =>
                                                        rdfjsResource.Resource.Values.fromValue(
                                                          {
                                                            focusResource:
                                                              $parameters.resource,
                                                            predicate:
                                                              LazyPropertiesClass
                                                                .$properties
                                                                .setPartialClassToResolvedClassProperty[
                                                                "identifier"
                                                              ],
                                                            value: valuesArray,
                                                          },
                                                        ),
                                                      )
                                                      .map((values) =>
                                                        values.map(
                                                          (partials) =>
                                                            new $LazyObjectSet<
                                                              LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
                                                              PartialClass,
                                                              LazilyResolvedBlankNodeOrIriIdentifierClass
                                                            >({
                                                              partials,
                                                              resolver: (
                                                                identifiers,
                                                              ) =>
                                                                $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierClasses(
                                                                  {
                                                                    filter: {
                                                                      $identifier:
                                                                        {
                                                                          in: identifiers,
                                                                        },
                                                                    },
                                                                  },
                                                                ),
                                                            }),
                                                        ),
                                                      )
                                                      .chain((values) =>
                                                        values.head(),
                                                      )
                                                      .map(
                                                        (
                                                          setPartialClassToResolvedClassProperty,
                                                        ) => ({
                                                          $identifier,
                                                          optionalLazyToResolvedClassProperty,
                                                          optionalLazyToResolvedClassUnionProperty,
                                                          optionalLazyToResolvedIriIdentifierClassProperty,
                                                          optionalPartialClassToResolvedClassProperty,
                                                          optionalPartialClassToResolvedClassUnionProperty,
                                                          optionalPartialClassUnionToResolvedClassUnionProperty,
                                                          requiredLazyToResolvedClassProperty,
                                                          requiredPartialClassToResolvedClassProperty,
                                                          setLazyToResolvedClassProperty,
                                                          setPartialClassToResolvedClassProperty,
                                                        }),
                                                      ),
                                                ),
                                          ),
                                    ),
                              ),
                        ),
                    ),
                ),
            ),
        ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazyPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazyPropertiesClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazyPropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazyPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazyPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("lazyPropertiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties.optionalLazyToResolvedClassProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassUnionProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties
          .optionalLazyToResolvedClassUnionProperty["identifier"],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassUnionProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassUnionProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedIriIdentifierClassProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties
          .optionalLazyToResolvedIriIdentifierClassProperty["identifier"],
      subject,
    });
    triples.push(
      ...$NamedDefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedIriIdentifierClassProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedIriIdentifierClassProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties
          .optionalPartialClassToResolvedClassProperty["identifier"],
      subject,
    });
    triples.push(
      ...PartialClass.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassUnionProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties
          .optionalPartialClassToResolvedClassUnionProperty["identifier"],
      subject,
    });
    triples.push(
      ...PartialClass.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassUnionProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassUnionProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassUnionToResolvedClassUnionProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties
          .optionalPartialClassUnionToResolvedClassUnionProperty["identifier"],
      subject,
    });
    triples.push(
      ...PartialClassUnion.$sparqlConstructTriples({
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassUnionToResolvedClassUnionProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassUnionToResolvedClassUnionProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredLazyToResolvedClassProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties.requiredLazyToResolvedClassProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredLazyToResolvedClassProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredLazyToResolvedClassProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredPartialClassToResolvedClassProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties
          .requiredPartialClassToResolvedClassProperty["identifier"],
      subject,
    });
    triples.push(
      ...PartialClass.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredPartialClassToResolvedClassProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredPartialClassToResolvedClassProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetLazyToResolvedClassProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties.setLazyToResolvedClassProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetLazyToResolvedClassProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetLazyToResolvedClassProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetPartialClassToResolvedClassProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties.setPartialClassToResolvedClassProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...PartialClass.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetPartialClassToResolvedClassProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetPartialClassToResolvedClassProperty`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazyPropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("lazyPropertiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalLazyToResolvedClassProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassProperty`,
                  ),
                  predicate:
                    LazyPropertiesClass.$properties
                      .optionalLazyToResolvedClassProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $DefaultPartial
                .$sparqlWherePatterns({
                  filter: itemFilter,
                  ignoreRdfType: true,
                  preferredLanguages: parameters?.preferredLanguages,
                  subject: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassProperty`,
                  ),
                  variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassProperty`,
                })
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalLazyToResolvedClassUnionProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassUnionProperty`,
                  ),
                  predicate:
                    LazyPropertiesClass.$properties
                      .optionalLazyToResolvedClassUnionProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $DefaultPartial
                .$sparqlWherePatterns({
                  filter: itemFilter,
                  ignoreRdfType: true,
                  preferredLanguages: parameters?.preferredLanguages,
                  subject: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassUnionProperty`,
                  ),
                  variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassUnionProperty`,
                })
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalLazyToResolvedIriIdentifierClassProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedIriIdentifierClassProperty`,
                  ),
                  predicate:
                    LazyPropertiesClass.$properties
                      .optionalLazyToResolvedIriIdentifierClassProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $NamedDefaultPartial
                .$sparqlWherePatterns({
                  filter: itemFilter,
                  ignoreRdfType: true,
                  preferredLanguages: parameters?.preferredLanguages,
                  subject: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedIriIdentifierClassProperty`,
                  ),
                  variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedIriIdentifierClassProperty`,
                })
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalPartialClassToResolvedClassProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassProperty`,
                  ),
                  predicate:
                    LazyPropertiesClass.$properties
                      .optionalPartialClassToResolvedClassProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: PartialClass.$sparqlWherePatterns({
                filter: itemFilter,
                ignoreRdfType: true,
                preferredLanguages: parameters?.preferredLanguages,
                subject: dataFactory.variable!(
                  `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassProperty`,
                ),
                variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassProperty`,
              }).concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalPartialClassToResolvedClassUnionProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassUnionProperty`,
                  ),
                  predicate:
                    LazyPropertiesClass.$properties
                      .optionalPartialClassToResolvedClassUnionProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: PartialClass.$sparqlWherePatterns({
                filter: itemFilter,
                ignoreRdfType: true,
                preferredLanguages: parameters?.preferredLanguages,
                subject: dataFactory.variable!(
                  `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassUnionProperty`,
                ),
                variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassUnionProperty`,
              }).concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter
            ?.optionalPartialClassUnionToResolvedClassUnionProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassUnionToResolvedClassUnionProperty`,
                  ),
                  predicate:
                    LazyPropertiesClass.$properties
                      .optionalPartialClassUnionToResolvedClassUnionProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: PartialClassUnion.$sparqlWherePatterns({
                filter: itemFilter,
                preferredLanguages: parameters?.preferredLanguages,
                subject: dataFactory.variable!(
                  `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassUnionToResolvedClassUnionProperty`,
                ),
                variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassUnionToResolvedClassUnionProperty`,
              }).concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredLazyToResolvedClassProperty`,
            ),
            predicate:
              LazyPropertiesClass.$properties
                .requiredLazyToResolvedClassProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: $DefaultPartial
          .$sparqlWherePatterns({
            filter: parameters?.filter?.requiredLazyToResolvedClassProperty,
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredLazyToResolvedClassProperty`,
            ),
            variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredLazyToResolvedClassProperty`,
          })
          .concat(),
        type: "group",
      },
    );
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredPartialClassToResolvedClassProperty`,
            ),
            predicate:
              LazyPropertiesClass.$properties
                .requiredPartialClassToResolvedClassProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: PartialClass.$sparqlWherePatterns({
          filter:
            parameters?.filter?.requiredPartialClassToResolvedClassProperty,
          ignoreRdfType: true,
          preferredLanguages: parameters?.preferredLanguages,
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredPartialClassToResolvedClassProperty`,
          ),
          variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredPartialClassToResolvedClassProperty`,
        }).concat(),
        type: "group",
      },
    );
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetLazyToResolvedClassProperty`,
              ),
              predicate:
                LazyPropertiesClass.$properties.setLazyToResolvedClassProperty[
                  "identifier"
                ],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: $DefaultPartial
            .$sparqlWherePatterns({
              filter: parameters?.filter?.setLazyToResolvedClassProperty,
              ignoreRdfType: true,
              preferredLanguages: parameters?.preferredLanguages,
              subject: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetLazyToResolvedClassProperty`,
              ),
              variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetLazyToResolvedClassProperty`,
            })
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetPartialClassToResolvedClassProperty`,
              ),
              predicate:
                LazyPropertiesClass.$properties
                  .setPartialClassToResolvedClassProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: PartialClass.$sparqlWherePatterns({
            filter: parameters?.filter?.setPartialClassToResolvedClassProperty,
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetPartialClassToResolvedClassProperty`,
            ),
            variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetPartialClassToResolvedClassProperty`,
          }).concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    return patterns;
  }

  export function isLazyPropertiesClass(
    object: $Object,
  ): object is LazyPropertiesClass {
    switch (object.$type) {
      case "LazyPropertiesClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape resolved by LazyPropertiesInterface
 */
export interface LazilyResolvedIriIdentifierInterface {
  readonly $identifier: LazilyResolvedIriIdentifierInterface.$Identifier;
  readonly $type: "LazilyResolvedIriIdentifierInterface";
  readonly lazilyResolvedStringProperty: string;
}

export namespace LazilyResolvedIriIdentifierInterface {
  export function $create(parameters: {
    readonly $identifier: rdfjs.NamedNode | string;
    readonly lazilyResolvedStringProperty: string;
  }): LazilyResolvedIriIdentifierInterface {
    let $identifier: LazilyResolvedIriIdentifierInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "LazilyResolvedIriIdentifierInterface" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: LazilyResolvedIriIdentifierInterface,
    right: LazilyResolvedIriIdentifierInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export function $filter(
    filter: LazilyResolvedIriIdentifierInterface.$Filter,
    value: LazilyResolvedIriIdentifierInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedIriIdentifierInterface> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedIriIdentifierInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedIriIdentifierInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedIriIdentifierInterface: LazilyResolvedIriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_lazilyResolvedIriIdentifierInterface.$identifier.value);
    _hasher.update(_lazilyResolvedIriIdentifierInterface.$type);
    LazilyResolvedIriIdentifierInterface.$hashShaclProperties(
      _lazilyResolvedIriIdentifierInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedIriIdentifierInterface: LazilyResolvedIriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _lazilyResolvedIriIdentifierInterface.lazilyResolvedStringProperty,
    );
    return _hasher;
  }

  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedIriIdentifierInterface";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedIriIdentifierInterface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedIriIdentifierInterface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedIriIdentifierInterface"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.NamedNode;
      $type: "LazilyResolvedIriIdentifierInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const $type = "LazilyResolvedIriIdentifierInterface" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.NamedNode;
      $type: "LazilyResolvedIriIdentifierInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    return (
      $parameters.resource.identifier.termType === "NamedNode"
        ? purify.Either.of<
            Error,
            LazilyResolvedIriIdentifierInterface.$Identifier
          >($parameters.resource.identifier)
        : purify.Left(
            new rdfjsResource.Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "(rdfjs.NamedNode)",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
    ).chain(($identifier) =>
      purify.Either.of<Error, "LazilyResolvedIriIdentifierInterface">(
        "LazilyResolvedIriIdentifierInterface",
      ).chain(($type) =>
        purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
        >(
          $parameters.resource.values(
            $properties.lazilyResolvedStringProperty["identifier"],
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                LazilyResolvedIriIdentifierInterface.$properties
                  .lazilyResolvedStringProperty["identifier"],
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((lazilyResolvedStringProperty) => ({
            $identifier,
            $type,
            lazilyResolvedStringProperty,
          })),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedIriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedIriIdentifierInterface.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazilyResolvedIriIdentifierInterface.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedIriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedIriIdentifierInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedIriIdentifierInterface");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedIriIdentifierInterface")}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedIriIdentifierInterface.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedIriIdentifierInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedIriIdentifierInterface");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedIriIdentifierInterface")}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedIriIdentifierInterface.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedIriIdentifierInterface")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedIriIdentifierInterface")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _lazilyResolvedIriIdentifierInterface: LazilyResolvedIriIdentifierInterface,
  ): LazilyResolvedIriIdentifierInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": _lazilyResolvedIriIdentifierInterface.$identifier.value,
        $type: _lazilyResolvedIriIdentifierInterface.$type,
        lazilyResolvedStringProperty:
          _lazilyResolvedIriIdentifierInterface.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedIriIdentifierInterface.$Json),
    );
  }

  export function $toRdf(
    _lazilyResolvedIriIdentifierInterface: LazilyResolvedIriIdentifierInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(
      _lazilyResolvedIriIdentifierInterface.$identifier,
      { mutateGraph },
    );
    resource.add(
      LazilyResolvedIriIdentifierInterface.$properties
        .lazilyResolvedStringProperty["identifier"],
      ...[_lazilyResolvedIriIdentifierInterface.lazilyResolvedStringProperty],
    );
    return resource;
  }

  export function isLazilyResolvedIriIdentifierInterface(
    object: $Object,
  ): object is LazilyResolvedIriIdentifierInterface {
    switch (object.$type) {
      case "LazilyResolvedIriIdentifierInterface":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape resolved by LazyPropertiesClass
 */
export class LazilyResolvedIriIdentifierClass {
  readonly $identifier: LazilyResolvedIriIdentifierClass.$Identifier;
  readonly $type = "LazilyResolvedIriIdentifierClass";
  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier: rdfjs.NamedNode | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this.$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this.$identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      this.$identifier = parameters.$identifier satisfies never;
    }

    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  $equals(other: LazilyResolvedIriIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): LazilyResolvedIriIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedIriIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      LazilyResolvedIriIdentifierClass.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[this.lazilyResolvedStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LazilyResolvedIriIdentifierClass {
  export function $filter(
    filter: LazilyResolvedIriIdentifierClass.$Filter,
    value: LazilyResolvedIriIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedIriIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new LazilyResolvedIriIdentifierClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedIriIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedIriIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new LazilyResolvedIriIdentifierClass(properties));
  }

  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedIriIdentifierClass";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedIriIdentifierClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedIriIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedIriIdentifierClass"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.NamedNode; lazilyResolvedStringProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.NamedNode; lazilyResolvedStringProperty: string }
  > {
    return (
      $parameters.resource.identifier.termType === "NamedNode"
        ? purify.Either.of<Error, LazilyResolvedIriIdentifierClass.$Identifier>(
            $parameters.resource.identifier,
          )
        : purify.Left(
            new rdfjsResource.Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "(rdfjs.NamedNode)",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              LazilyResolvedIriIdentifierClass.$properties
                .lazilyResolvedStringProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((lazilyResolvedStringProperty) => ({
          $identifier,
          lazilyResolvedStringProperty,
        })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedIriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedIriIdentifierClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazilyResolvedIriIdentifierClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedIriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedIriIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedIriIdentifierClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedIriIdentifierClass")}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedIriIdentifierClass.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedIriIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedIriIdentifierClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedIriIdentifierClass")}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedIriIdentifierClass.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedIriIdentifierClass")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedIriIdentifierClass")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isLazilyResolvedIriIdentifierClass(
    object: $Object,
  ): object is LazilyResolvedIriIdentifierClass {
    switch (object.$type) {
      case "LazilyResolvedIriIdentifierClass":
        return true;
      default:
        return false;
    }
  }
}
export interface LazilyResolvedInterfaceUnionMember2 {
  readonly $identifier: LazilyResolvedInterfaceUnionMember2.$Identifier;
  readonly $type: "LazilyResolvedInterfaceUnionMember2";
  readonly lazilyResolvedStringProperty: string;
}

export namespace LazilyResolvedInterfaceUnionMember2 {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): LazilyResolvedInterfaceUnionMember2 {
    let $identifier: LazilyResolvedInterfaceUnionMember2.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "LazilyResolvedInterfaceUnionMember2" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: LazilyResolvedInterfaceUnionMember2,
    right: LazilyResolvedInterfaceUnionMember2,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export function $filter(
    filter: LazilyResolvedInterfaceUnionMember2.$Filter,
    value: LazilyResolvedInterfaceUnionMember2,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedInterfaceUnionMember2> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedInterfaceUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedInterfaceUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedInterfaceUnionMember2",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedInterfaceUnionMember2: LazilyResolvedInterfaceUnionMember2,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_lazilyResolvedInterfaceUnionMember2.$identifier.value);
    _hasher.update(_lazilyResolvedInterfaceUnionMember2.$type);
    LazilyResolvedInterfaceUnionMember2.$hashShaclProperties(
      _lazilyResolvedInterfaceUnionMember2,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedInterfaceUnionMember2: LazilyResolvedInterfaceUnionMember2,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _lazilyResolvedInterfaceUnionMember2.lazilyResolvedStringProperty,
    );
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedInterfaceUnionMember2";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedInterfaceUnionMember2" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedInterfaceUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedInterfaceUnionMember2"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazilyResolvedInterfaceUnionMember2";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "LazilyResolvedInterfaceUnionMember2" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazilyResolvedInterfaceUnionMember2";
      lazilyResolvedStringProperty: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/LazilyResolvedInterfaceUnionMember2":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  LazilyResolvedInterfaceUnionMember2.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedInterfaceUnionMember2)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      purify.Either.of<Error, LazilyResolvedInterfaceUnionMember2.$Identifier>(
        $parameters.resource
          .identifier as LazilyResolvedInterfaceUnionMember2.$Identifier,
      ).chain(($identifier) =>
        purify.Either.of<Error, "LazilyResolvedInterfaceUnionMember2">(
          "LazilyResolvedInterfaceUnionMember2",
        ).chain(($type) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.lazilyResolvedStringProperty["identifier"],
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  LazilyResolvedInterfaceUnionMember2.$properties
                    .lazilyResolvedStringProperty["identifier"],
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((lazilyResolvedStringProperty) => ({
              $identifier,
              $type,
              lazilyResolvedStringProperty,
            })),
        ),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedInterfaceUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedInterfaceUnionMember2.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazilyResolvedInterfaceUnionMember2.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedInterfaceUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedInterfaceUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedInterfaceUnionMember2");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember2")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember2")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember2")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember2")}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedInterfaceUnionMember2.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedInterfaceUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedInterfaceUnionMember2");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember2")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedInterfaceUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember2")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember2")}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedInterfaceUnionMember2.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember2")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember2")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _lazilyResolvedInterfaceUnionMember2: LazilyResolvedInterfaceUnionMember2,
  ): LazilyResolvedInterfaceUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _lazilyResolvedInterfaceUnionMember2.$identifier.termType ===
          "BlankNode"
            ? `_:${_lazilyResolvedInterfaceUnionMember2.$identifier.value}`
            : _lazilyResolvedInterfaceUnionMember2.$identifier.value,
        $type: _lazilyResolvedInterfaceUnionMember2.$type,
        lazilyResolvedStringProperty:
          _lazilyResolvedInterfaceUnionMember2.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedInterfaceUnionMember2.$Json),
    );
  }

  export function $toRdf(
    _lazilyResolvedInterfaceUnionMember2: LazilyResolvedInterfaceUnionMember2,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _lazilyResolvedInterfaceUnionMember2.$identifier,
      { mutateGraph },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/LazilyResolvedInterfaceUnionMember2",
        ),
      );
    }

    resource.add(
      LazilyResolvedInterfaceUnionMember2.$properties
        .lazilyResolvedStringProperty["identifier"],
      ...[_lazilyResolvedInterfaceUnionMember2.lazilyResolvedStringProperty],
    );
    return resource;
  }

  export function isLazilyResolvedInterfaceUnionMember2(
    object: $Object,
  ): object is LazilyResolvedInterfaceUnionMember2 {
    switch (object.$type) {
      case "LazilyResolvedInterfaceUnionMember2":
        return true;
      default:
        return false;
    }
  }
}
export interface LazilyResolvedInterfaceUnionMember1 {
  readonly $identifier: LazilyResolvedInterfaceUnionMember1.$Identifier;
  readonly $type: "LazilyResolvedInterfaceUnionMember1";
  readonly lazilyResolvedStringProperty: string;
}

export namespace LazilyResolvedInterfaceUnionMember1 {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): LazilyResolvedInterfaceUnionMember1 {
    let $identifier: LazilyResolvedInterfaceUnionMember1.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "LazilyResolvedInterfaceUnionMember1" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: LazilyResolvedInterfaceUnionMember1,
    right: LazilyResolvedInterfaceUnionMember1,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export function $filter(
    filter: LazilyResolvedInterfaceUnionMember1.$Filter,
    value: LazilyResolvedInterfaceUnionMember1,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedInterfaceUnionMember1> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedInterfaceUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedInterfaceUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedInterfaceUnionMember1",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedInterfaceUnionMember1: LazilyResolvedInterfaceUnionMember1,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_lazilyResolvedInterfaceUnionMember1.$identifier.value);
    _hasher.update(_lazilyResolvedInterfaceUnionMember1.$type);
    LazilyResolvedInterfaceUnionMember1.$hashShaclProperties(
      _lazilyResolvedInterfaceUnionMember1,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedInterfaceUnionMember1: LazilyResolvedInterfaceUnionMember1,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _lazilyResolvedInterfaceUnionMember1.lazilyResolvedStringProperty,
    );
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedInterfaceUnionMember1";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedInterfaceUnionMember1" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedInterfaceUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedInterfaceUnionMember1"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazilyResolvedInterfaceUnionMember1";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "LazilyResolvedInterfaceUnionMember1" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazilyResolvedInterfaceUnionMember1";
      lazilyResolvedStringProperty: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/LazilyResolvedInterfaceUnionMember1":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  LazilyResolvedInterfaceUnionMember1.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedInterfaceUnionMember1)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      purify.Either.of<Error, LazilyResolvedInterfaceUnionMember1.$Identifier>(
        $parameters.resource
          .identifier as LazilyResolvedInterfaceUnionMember1.$Identifier,
      ).chain(($identifier) =>
        purify.Either.of<Error, "LazilyResolvedInterfaceUnionMember1">(
          "LazilyResolvedInterfaceUnionMember1",
        ).chain(($type) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.lazilyResolvedStringProperty["identifier"],
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  LazilyResolvedInterfaceUnionMember1.$properties
                    .lazilyResolvedStringProperty["identifier"],
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((lazilyResolvedStringProperty) => ({
              $identifier,
              $type,
              lazilyResolvedStringProperty,
            })),
        ),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedInterfaceUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedInterfaceUnionMember1.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazilyResolvedInterfaceUnionMember1.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedInterfaceUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedInterfaceUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedInterfaceUnionMember1");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember1")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember1")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember1")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember1")}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedInterfaceUnionMember1.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedInterfaceUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedInterfaceUnionMember1");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember1")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedInterfaceUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember1")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember1")}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedInterfaceUnionMember1.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember1")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember1")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _lazilyResolvedInterfaceUnionMember1: LazilyResolvedInterfaceUnionMember1,
  ): LazilyResolvedInterfaceUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _lazilyResolvedInterfaceUnionMember1.$identifier.termType ===
          "BlankNode"
            ? `_:${_lazilyResolvedInterfaceUnionMember1.$identifier.value}`
            : _lazilyResolvedInterfaceUnionMember1.$identifier.value,
        $type: _lazilyResolvedInterfaceUnionMember1.$type,
        lazilyResolvedStringProperty:
          _lazilyResolvedInterfaceUnionMember1.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedInterfaceUnionMember1.$Json),
    );
  }

  export function $toRdf(
    _lazilyResolvedInterfaceUnionMember1: LazilyResolvedInterfaceUnionMember1,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _lazilyResolvedInterfaceUnionMember1.$identifier,
      { mutateGraph },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/LazilyResolvedInterfaceUnionMember1",
        ),
      );
    }

    resource.add(
      LazilyResolvedInterfaceUnionMember1.$properties
        .lazilyResolvedStringProperty["identifier"],
      ...[_lazilyResolvedInterfaceUnionMember1.lazilyResolvedStringProperty],
    );
    return resource;
  }

  export function isLazilyResolvedInterfaceUnionMember1(
    object: $Object,
  ): object is LazilyResolvedInterfaceUnionMember1 {
    switch (object.$type) {
      case "LazilyResolvedInterfaceUnionMember1":
        return true;
      default:
        return false;
    }
  }
}
export class LazilyResolvedClassUnionMember2 {
  private _$identifier?: LazilyResolvedClassUnionMember2.$Identifier;
  readonly $type = "LazilyResolvedClassUnionMember2";
  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): LazilyResolvedClassUnionMember2.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: LazilyResolvedClassUnionMember2): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): LazilyResolvedClassUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedClassUnionMember2.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/LazilyResolvedClassUnionMember2",
        ),
      );
    }

    resource.add(
      LazilyResolvedClassUnionMember2.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[this.lazilyResolvedStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LazilyResolvedClassUnionMember2 {
  export function $filter(
    filter: LazilyResolvedClassUnionMember2.$Filter,
    value: LazilyResolvedClassUnionMember2,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedClassUnionMember2> {
    return $propertiesFromJson(json).map(
      (properties) => new LazilyResolvedClassUnionMember2(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedClassUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedClassUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new LazilyResolvedClassUnionMember2(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedClassUnionMember2",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedClassUnionMember2";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedClassUnionMember2" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedClassUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedClassUnionMember2"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/LazilyResolvedClassUnionMember2":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  LazilyResolvedClassUnionMember2.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedClassUnionMember2)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      purify.Either.of<Error, LazilyResolvedClassUnionMember2.$Identifier>(
        $parameters.resource
          .identifier as LazilyResolvedClassUnionMember2.$Identifier,
      ).chain(($identifier) =>
        purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
        >(
          $parameters.resource.values(
            $properties.lazilyResolvedStringProperty["identifier"],
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                LazilyResolvedClassUnionMember2.$properties
                  .lazilyResolvedStringProperty["identifier"],
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((lazilyResolvedStringProperty) => ({
            $identifier,
            lazilyResolvedStringProperty,
          })),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedClassUnionMember2.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazilyResolvedClassUnionMember2.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedClassUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedClassUnionMember2");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember2")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember2")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember2")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember2")}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedClassUnionMember2.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedClassUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedClassUnionMember2");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember2")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedClassUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember2")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember2")}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedClassUnionMember2.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember2")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember2")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isLazilyResolvedClassUnionMember2(
    object: $Object,
  ): object is LazilyResolvedClassUnionMember2 {
    switch (object.$type) {
      case "LazilyResolvedClassUnionMember2":
        return true;
      default:
        return false;
    }
  }
}
export class LazilyResolvedClassUnionMember1 {
  private _$identifier?: LazilyResolvedClassUnionMember1.$Identifier;
  readonly $type = "LazilyResolvedClassUnionMember1";
  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): LazilyResolvedClassUnionMember1.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: LazilyResolvedClassUnionMember1): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): LazilyResolvedClassUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedClassUnionMember1.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/LazilyResolvedClassUnionMember1",
        ),
      );
    }

    resource.add(
      LazilyResolvedClassUnionMember1.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[this.lazilyResolvedStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LazilyResolvedClassUnionMember1 {
  export function $filter(
    filter: LazilyResolvedClassUnionMember1.$Filter,
    value: LazilyResolvedClassUnionMember1,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedClassUnionMember1> {
    return $propertiesFromJson(json).map(
      (properties) => new LazilyResolvedClassUnionMember1(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedClassUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedClassUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new LazilyResolvedClassUnionMember1(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedClassUnionMember1",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedClassUnionMember1";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedClassUnionMember1" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedClassUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedClassUnionMember1"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/LazilyResolvedClassUnionMember1":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  LazilyResolvedClassUnionMember1.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedClassUnionMember1)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      purify.Either.of<Error, LazilyResolvedClassUnionMember1.$Identifier>(
        $parameters.resource
          .identifier as LazilyResolvedClassUnionMember1.$Identifier,
      ).chain(($identifier) =>
        purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
        >(
          $parameters.resource.values(
            $properties.lazilyResolvedStringProperty["identifier"],
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                LazilyResolvedClassUnionMember1.$properties
                  .lazilyResolvedStringProperty["identifier"],
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((lazilyResolvedStringProperty) => ({
            $identifier,
            lazilyResolvedStringProperty,
          })),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedClassUnionMember1.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazilyResolvedClassUnionMember1.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedClassUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedClassUnionMember1");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember1")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember1")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember1")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember1")}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedClassUnionMember1.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedClassUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedClassUnionMember1");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember1")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedClassUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember1")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember1")}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedClassUnionMember1.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember1")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember1")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isLazilyResolvedClassUnionMember1(
    object: $Object,
  ): object is LazilyResolvedClassUnionMember1 {
    switch (object.$type) {
      case "LazilyResolvedClassUnionMember1":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape resolved by LazyPropertiesInterface
 */
export interface LazilyResolvedBlankNodeOrIriIdentifierInterface {
  readonly $identifier: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier;
  readonly $type: "LazilyResolvedBlankNodeOrIriIdentifierInterface";
  readonly lazilyResolvedStringProperty: string;
}

export namespace LazilyResolvedBlankNodeOrIriIdentifierInterface {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): LazilyResolvedBlankNodeOrIriIdentifierInterface {
    let $identifier: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "LazilyResolvedBlankNodeOrIriIdentifierInterface" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: LazilyResolvedBlankNodeOrIriIdentifierInterface,
    right: LazilyResolvedBlankNodeOrIriIdentifierInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export function $filter(
    filter: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
    value: LazilyResolvedBlankNodeOrIriIdentifierInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<
    zod.ZodError,
    LazilyResolvedBlankNodeOrIriIdentifierInterface
  > {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedBlankNodeOrIriIdentifierInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedBlankNodeOrIriIdentifierInterface",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedBlankNodeOrIriIdentifierInterface: LazilyResolvedBlankNodeOrIriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _lazilyResolvedBlankNodeOrIriIdentifierInterface.$identifier.value,
    );
    _hasher.update(_lazilyResolvedBlankNodeOrIriIdentifierInterface.$type);
    LazilyResolvedBlankNodeOrIriIdentifierInterface.$hashShaclProperties(
      _lazilyResolvedBlankNodeOrIriIdentifierInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedBlankNodeOrIriIdentifierInterface: LazilyResolvedBlankNodeOrIriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _lazilyResolvedBlankNodeOrIriIdentifierInterface.lazilyResolvedStringProperty,
    );
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedBlankNodeOrIriIdentifierInterface";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: {
                const: "LazilyResolvedBlankNodeOrIriIdentifierInterface",
              },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedBlankNodeOrIriIdentifierInterface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedBlankNodeOrIriIdentifierInterface"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazilyResolvedBlankNodeOrIriIdentifierInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "LazilyResolvedBlankNodeOrIriIdentifierInterface" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazilyResolvedBlankNodeOrIriIdentifierInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/LazilyResolvedBlankNodeOrIriIdentifierInterface":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedBlankNodeOrIriIdentifierInterface)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      purify.Either.of<
        Error,
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
      >(
        $parameters.resource
          .identifier as LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      ).chain(($identifier) =>
        purify.Either.of<
          Error,
          "LazilyResolvedBlankNodeOrIriIdentifierInterface"
        >("LazilyResolvedBlankNodeOrIriIdentifierInterface").chain(($type) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.lazilyResolvedStringProperty["identifier"],
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  LazilyResolvedBlankNodeOrIriIdentifierInterface.$properties
                    .lazilyResolvedStringProperty["identifier"],
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((lazilyResolvedStringProperty) => ({
              $identifier,
              $type,
              lazilyResolvedStringProperty,
            })),
        ),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$sparqlConstructTriples(
          { ignoreRdfType, subject },
        ),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazilyResolvedBlankNodeOrIriIdentifierInterface.$sparqlWherePatterns(
              { filter, ignoreRdfType, preferredLanguages, subject },
            ),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$sparqlConstructQuery(
        parameters,
      ),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedBlankNodeOrIriIdentifierInterface");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierInterface")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierInterface")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierInterface")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierInterface")}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedBlankNodeOrIriIdentifierInterface");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierInterface")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierInterface")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierInterface")}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedBlankNodeOrIriIdentifierInterface.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierInterface")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierInterface")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _lazilyResolvedBlankNodeOrIriIdentifierInterface: LazilyResolvedBlankNodeOrIriIdentifierInterface,
  ): LazilyResolvedBlankNodeOrIriIdentifierInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _lazilyResolvedBlankNodeOrIriIdentifierInterface.$identifier
            .termType === "BlankNode"
            ? `_:${_lazilyResolvedBlankNodeOrIriIdentifierInterface.$identifier.value}`
            : _lazilyResolvedBlankNodeOrIriIdentifierInterface.$identifier
                .value,
        $type: _lazilyResolvedBlankNodeOrIriIdentifierInterface.$type,
        lazilyResolvedStringProperty:
          _lazilyResolvedBlankNodeOrIriIdentifierInterface.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedBlankNodeOrIriIdentifierInterface.$Json),
    );
  }

  export function $toRdf(
    _lazilyResolvedBlankNodeOrIriIdentifierInterface: LazilyResolvedBlankNodeOrIriIdentifierInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _lazilyResolvedBlankNodeOrIriIdentifierInterface.$identifier,
      { mutateGraph },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/LazilyResolvedBlankNodeOrIriIdentifierInterface",
        ),
      );
    }

    resource.add(
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$properties
        .lazilyResolvedStringProperty["identifier"],
      ...[
        _lazilyResolvedBlankNodeOrIriIdentifierInterface.lazilyResolvedStringProperty,
      ],
    );
    return resource;
  }

  export function isLazilyResolvedBlankNodeOrIriIdentifierInterface(
    object: $Object,
  ): object is LazilyResolvedBlankNodeOrIriIdentifierInterface {
    switch (object.$type) {
      case "LazilyResolvedBlankNodeOrIriIdentifierInterface":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape resolved by LazyPropertiesClass
 */
export class LazilyResolvedBlankNodeOrIriIdentifierClass {
  private _$identifier?: LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier;
  readonly $type = "LazilyResolvedBlankNodeOrIriIdentifierClass";
  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: LazilyResolvedBlankNodeOrIriIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): LazilyResolvedBlankNodeOrIriIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedBlankNodeOrIriIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/LazilyResolvedBlankNodeOrIriIdentifierClass",
        ),
      );
    }

    resource.add(
      LazilyResolvedBlankNodeOrIriIdentifierClass.$properties
        .lazilyResolvedStringProperty["identifier"],
      ...[this.lazilyResolvedStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LazilyResolvedBlankNodeOrIriIdentifierClass {
  export function $filter(
    filter: LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
    value: LazilyResolvedBlankNodeOrIriIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedBlankNodeOrIriIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) =>
        new LazilyResolvedBlankNodeOrIriIdentifierClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedBlankNodeOrIriIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map(
      (properties) =>
        new LazilyResolvedBlankNodeOrIriIdentifierClass(properties),
    );
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedBlankNodeOrIriIdentifierClass",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedBlankNodeOrIriIdentifierClass";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedBlankNodeOrIriIdentifierClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedBlankNodeOrIriIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedBlankNodeOrIriIdentifierClass"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/LazilyResolvedBlankNodeOrIriIdentifierClass":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedBlankNodeOrIriIdentifierClass)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      purify.Either.of<
        Error,
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
      >(
        $parameters.resource
          .identifier as LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
      ).chain(($identifier) =>
        purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
        >(
          $parameters.resource.values(
            $properties.lazilyResolvedStringProperty["identifier"],
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                LazilyResolvedBlankNodeOrIriIdentifierClass.$properties
                  .lazilyResolvedStringProperty["identifier"],
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((lazilyResolvedStringProperty) => ({
            $identifier,
            lazilyResolvedStringProperty,
          })),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedBlankNodeOrIriIdentifierClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazilyResolvedBlankNodeOrIriIdentifierClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedBlankNodeOrIriIdentifierClass.$sparqlConstructQuery(
        parameters,
      ),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedBlankNodeOrIriIdentifierClass");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierClass")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierClass")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierClass")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierClass")}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedBlankNodeOrIriIdentifierClass.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedBlankNodeOrIriIdentifierClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierClass")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierClass")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierClass")}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedBlankNodeOrIriIdentifierClass.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierClass")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierClass")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isLazilyResolvedBlankNodeOrIriIdentifierClass(
    object: $Object,
  ): object is LazilyResolvedBlankNodeOrIriIdentifierClass {
    switch (object.$type) {
      case "LazilyResolvedBlankNodeOrIriIdentifierClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Shape that uses the StringList in a property.
 */
export class LanguageInPropertiesClass {
  private _$identifier?: LanguageInPropertiesClass.$Identifier;
  readonly $type = "LanguageInPropertiesClass";
  /**
   * literal property for testing languageIn
   */
  readonly languageInLiteralProperty: purify.NonEmptyList<rdfjs.Literal>;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly languageInLiteralProperty: purify.NonEmptyList<rdfjs.Literal>;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.languageInLiteralProperty = parameters.languageInLiteralProperty;
  }

  get $identifier(): LanguageInPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: LanguageInPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.languageInLiteralProperty,
          other.languageInLiteralProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "languageInLiteralProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    for (const item0 of this.languageInLiteralProperty) {
      _hasher.update(item0.datatype.value);
      _hasher.update(item0.language);
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }

    return _hasher;
  }

  $toJson(): LanguageInPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        languageInLiteralProperty: this.languageInLiteralProperty.map(
          (item) => ({
            "@language": item.language.length > 0 ? item.language : undefined,
            "@type":
              item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? item.datatype.value
                : undefined,
            "@value": item.value,
          }),
        ),
      } satisfies LanguageInPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      LanguageInPropertiesClass.$properties.languageInLiteralProperty[
        "identifier"
      ],
      ...this.languageInLiteralProperty.flatMap((item) => [item]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LanguageInPropertiesClass {
  export function $filter(
    filter: LanguageInPropertiesClass.$Filter,
    value: LanguageInPropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.languageInLiteralProperty !== "undefined" &&
      !$filterArray<rdfjs.Literal, $LiteralFilter>($filterLiteral)(
        filter.languageInLiteralProperty,
        value.languageInLiteralProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly languageInLiteralProperty?: $CollectionFilter<$LiteralFilter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LanguageInPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new LanguageInPropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LanguageInPropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LanguageInPropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new LanguageInPropertiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LanguageInPropertiesClass";
    readonly languageInLiteralProperty: readonly {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    }[];
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LanguageInPropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/languageInLiteralProperty`,
          type: "Control",
        },
      ],
      label: "LanguageInPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LanguageInPropertiesClass"),
      languageInLiteralProperty: zod
        .object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
        })
        .array()
        .nonempty()
        .min(1)
        .describe("literal property for testing languageIn"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    languageInLiteralProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/languageInLiteralProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      languageInLiteralProperty: purify.NonEmptyList<rdfjs.Literal>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const languageInLiteralProperty = purify.NonEmptyList.fromArray(
      $jsonObject["languageInLiteralProperty"],
    )
      .unsafeCoerce()
      .map((item) =>
        dataFactory.literal(
          item["@value"],
          typeof item["@language"] !== "undefined"
            ? item["@language"]
            : typeof item["@type"] !== "undefined"
              ? dataFactory.namedNode(item["@type"])
              : undefined,
        ),
      );
    return purify.Either.of({ $identifier, languageInLiteralProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      languageInLiteralProperty: purify.NonEmptyList<rdfjs.Literal>;
    }
  > {
    return purify.Either.of<Error, LanguageInPropertiesClass.$Identifier>(
      $parameters.resource.identifier as LanguageInPropertiesClass.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.languageInLiteralProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          values.chainMap((value) =>
            value.toLiteral().chain((literalValue) => {
              switch (literalValue.language) {
                case "en":
                case "fr":
                  return purify.Either.of(value);
                default:
                  return purify.Left(
                    new rdfjsResource.Resource.MistypedTermValueError({
                      actualValue: literalValue,
                      expectedValueType: "(rdfjs.Literal)",
                      focusResource: $parameters.resource,
                      predicate:
                        LanguageInPropertiesClass.$properties
                          .languageInLiteralProperty["identifier"],
                    }),
                  );
              }
            }),
          ),
        )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              LanguageInPropertiesClass.$properties.languageInLiteralProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toLiteral()))
        .chain((values) =>
          purify.NonEmptyList.fromArray(values.toArray()).toEither(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} is an empty set`,
            ),
          ),
        )
        .map((valuesArray) =>
          rdfjsResource.Resource.Values.fromValue({
            focusResource: $parameters.resource,
            predicate:
              LanguageInPropertiesClass.$properties.languageInLiteralProperty[
                "identifier"
              ],
            value: valuesArray,
          }),
        )
        .chain((values) => values.head())
        .map((languageInLiteralProperty) => ({
          $identifier,
          languageInLiteralProperty,
        })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LanguageInPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LanguageInPropertiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LanguageInPropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LanguageInPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LanguageInPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("languageInPropertiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "languageInPropertiesClass")}LanguageInLiteralProperty`,
      ),
      predicate:
        LanguageInPropertiesClass.$properties.languageInLiteralProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LanguageInPropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("languageInPropertiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "languageInPropertiesClass")}LanguageInLiteralProperty`,
            ),
            predicate:
              LanguageInPropertiesClass.$properties.languageInLiteralProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [
          [
            ...$arrayIntersection(
              ["en", "fr"],
              parameters?.preferredLanguages ?? [],
            ),
          ],
        ]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "languageInPropertiesClass")}LanguageInLiteralProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $LiteralFilter
          .$sparqlWherePatterns(
            parameters?.filter?.languageInLiteralProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "languageInPropertiesClass")}LanguageInLiteralProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isLanguageInPropertiesClass(
    object: $Object,
  ): object is LanguageInPropertiesClass {
    switch (object.$type) {
      case "LanguageInPropertiesClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Shape with sh:xone (union) properties with JavaScript primitive types (e.g., boolean, number, et al.). Unions of these are common in actual models.
 */
export class JsPrimitiveUnionPropertyClass {
  private _$identifier?: JsPrimitiveUnionPropertyClass.$Identifier;
  readonly $type = "JsPrimitiveUnionPropertyClass";
  readonly jsPrimitiveUnionProperty: readonly (boolean | number | string)[];

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly jsPrimitiveUnionProperty?: readonly (boolean | number | string)[];
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (typeof parameters?.jsPrimitiveUnionProperty === "undefined") {
      this.jsPrimitiveUnionProperty = [];
    } else if (typeof parameters?.jsPrimitiveUnionProperty === "object") {
      this.jsPrimitiveUnionProperty = parameters?.jsPrimitiveUnionProperty;
    } else {
      this.jsPrimitiveUnionProperty =
        parameters?.jsPrimitiveUnionProperty satisfies never;
    }
  }

  get $identifier(): JsPrimitiveUnionPropertyClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: JsPrimitiveUnionPropertyClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(
            left,
            right,
            (
              left: boolean | number | string,
              right: boolean | number | string,
            ) => {
              if (typeof left === "boolean" && typeof right === "boolean") {
                return $strictEquals(left, right);
              }
              if (typeof left === "number" && typeof right === "number") {
                return $strictEquals(left, right);
              }
              if (typeof left === "string" && typeof right === "string") {
                return $strictEquals(left, right);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(
          this.jsPrimitiveUnionProperty,
          other.jsPrimitiveUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "jsPrimitiveUnionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    for (const item0 of this.jsPrimitiveUnionProperty) {
      switch (typeof item0) {
        case "boolean": {
          _hasher.update(item0.toString());
          break;
        }
        case "number": {
          _hasher.update(item0.toString());
          break;
        }
        case "string": {
          _hasher.update(item0);
          break;
        }
        default:
          item0 satisfies never;
          throw new Error("unrecognized type");
      }
    }

    return _hasher;
  }

  $toJson(): JsPrimitiveUnionPropertyClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        jsPrimitiveUnionProperty: this.jsPrimitiveUnionProperty.map(
          (item) => item,
        ),
      } satisfies JsPrimitiveUnionPropertyClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      JsPrimitiveUnionPropertyClass.$properties.jsPrimitiveUnionProperty[
        "identifier"
      ],
      ...this.jsPrimitiveUnionProperty.flatMap((item) =>
        typeof item === "string"
          ? ([item] as readonly Parameters<
              rdfjsResource.MutableResource["add"]
            >[1][])
          : typeof item === "number"
            ? ([
                dataFactory.literal(
                  item.toString(10),
                  $RdfVocabularies.xsd.decimal,
                ),
              ] as readonly Parameters<
                rdfjsResource.MutableResource["add"]
              >[1][])
            : ([item] as readonly Parameters<
                rdfjsResource.MutableResource["add"]
              >[1][]),
      ),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace JsPrimitiveUnionPropertyClass {
  export function $filter(
    filter: JsPrimitiveUnionPropertyClass.$Filter,
    value: JsPrimitiveUnionPropertyClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.jsPrimitiveUnionProperty !== "undefined" &&
      !$filterArray<
        boolean | number | string,
        {
          readonly on?: {
            readonly boolean?: $BooleanFilter;
            readonly number?: $NumberFilter;
            readonly string?: $StringFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly boolean?: $BooleanFilter;
              readonly number?: $NumberFilter;
              readonly string?: $StringFilter;
            };
          },
          value: boolean | number | string,
        ) => {
          if (typeof filter.on?.["boolean"] !== "undefined") {
            switch (typeof value) {
              case "boolean":
                if (!$filterBoolean(filter.on["boolean"], value)) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["number"] !== "undefined") {
            switch (typeof value) {
              case "number":
                if (!$filterNumber(filter.on["number"], value)) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["string"] !== "undefined") {
            switch (typeof value) {
              case "string":
                if (!$filterString(filter.on["string"], value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.jsPrimitiveUnionProperty, value.jsPrimitiveUnionProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly jsPrimitiveUnionProperty?: $CollectionFilter<{
      readonly on?: {
        readonly boolean?: $BooleanFilter;
        readonly number?: $NumberFilter;
        readonly string?: $StringFilter;
      };
    }>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, JsPrimitiveUnionPropertyClass> {
    return $propertiesFromJson(json).map(
      (properties) => new JsPrimitiveUnionPropertyClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, JsPrimitiveUnionPropertyClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return JsPrimitiveUnionPropertyClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new JsPrimitiveUnionPropertyClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "JsPrimitiveUnionPropertyClass";
    readonly jsPrimitiveUnionProperty?: readonly (boolean | number | string)[];
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "JsPrimitiveUnionPropertyClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/jsPrimitiveUnionProperty`,
          type: "Control",
        },
      ],
      label: "JsPrimitiveUnionPropertyClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("JsPrimitiveUnionPropertyClass"),
      jsPrimitiveUnionProperty: zod
        .union([zod.boolean(), zod.number(), zod.string()])
        .array()
        .default(() => []),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    jsPrimitiveUnionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/jsPrimitiveUnionProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      jsPrimitiveUnionProperty: readonly (boolean | number | string)[];
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const jsPrimitiveUnionProperty = $jsonObject["jsPrimitiveUnionProperty"];
    return purify.Either.of({ $identifier, jsPrimitiveUnionProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      jsPrimitiveUnionProperty: readonly (boolean | number | string)[];
    }
  > {
    return purify.Either.of<Error, JsPrimitiveUnionPropertyClass.$Identifier>(
      $parameters.resource
        .identifier as JsPrimitiveUnionPropertyClass.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.jsPrimitiveUnionProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          values.chainMap((value) => {
            const valueAsValues = purify.Either.of(value.toValues());
            return (
              valueAsValues.chain((values) =>
                values.chainMap((value) => value.toBoolean()),
              ) as purify.Either<
                Error,
                rdfjsResource.Resource.Values<boolean | number | string>
              >
            )
              .altLazy(
                () =>
                  valueAsValues.chain((values) =>
                    values.chainMap((value) => value.toNumber()),
                  ) as purify.Either<
                    Error,
                    rdfjsResource.Resource.Values<boolean | number | string>
                  >,
              )
              .altLazy(
                () =>
                  valueAsValues
                    .chain((values) =>
                      $fromRdfPreferredLanguages({
                        focusResource: $parameters.resource,
                        predicate:
                          JsPrimitiveUnionPropertyClass.$properties
                            .jsPrimitiveUnionProperty["identifier"],
                        preferredLanguages: $parameters.preferredLanguages,
                        values,
                      }),
                    )
                    .chain((values) =>
                      values.chainMap((value) => value.toString()),
                    ) as purify.Either<
                    Error,
                    rdfjsResource.Resource.Values<boolean | number | string>
                  >,
              )
              .chain((values) => values.head());
          }),
        )
        .map((values) => values.toArray())
        .map((valuesArray) =>
          rdfjsResource.Resource.Values.fromValue({
            focusResource: $parameters.resource,
            predicate:
              JsPrimitiveUnionPropertyClass.$properties
                .jsPrimitiveUnionProperty["identifier"],
            value: valuesArray,
          }),
        )
        .chain((values) => values.head())
        .map((jsPrimitiveUnionProperty) => ({
          $identifier,
          jsPrimitiveUnionProperty,
        })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: JsPrimitiveUnionPropertyClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        JsPrimitiveUnionPropertyClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            JsPrimitiveUnionPropertyClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: JsPrimitiveUnionPropertyClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      JsPrimitiveUnionPropertyClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("jsPrimitiveUnionPropertyClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "jsPrimitiveUnionPropertyClass")}JsPrimitiveUnionProperty`,
      ),
      predicate:
        JsPrimitiveUnionPropertyClass.$properties.jsPrimitiveUnionProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: JsPrimitiveUnionPropertyClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("jsPrimitiveUnionPropertyClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: [
        {
          patterns: [
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "jsPrimitiveUnionPropertyClass")}JsPrimitiveUnionProperty`,
                      ),
                      predicate:
                        JsPrimitiveUnionPropertyClass.$properties
                          .jsPrimitiveUnionProperty["identifier"],
                      subject: subject,
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: $BooleanFilter
                    .$sparqlWherePatterns(
                      parameters?.filter?.jsPrimitiveUnionProperty?.on?.[
                        "boolean"
                      ],
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "jsPrimitiveUnionPropertyClass")}JsPrimitiveUnionProperty`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
              ],
              type: "group",
            },
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "jsPrimitiveUnionPropertyClass")}JsPrimitiveUnionProperty`,
                      ),
                      predicate:
                        JsPrimitiveUnionPropertyClass.$properties
                          .jsPrimitiveUnionProperty["identifier"],
                      subject: subject,
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: $NumberFilter
                    .$sparqlWherePatterns(
                      parameters?.filter?.jsPrimitiveUnionProperty?.on?.[
                        "number"
                      ],
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "jsPrimitiveUnionPropertyClass")}JsPrimitiveUnionProperty`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
              ],
              type: "group",
            },
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "jsPrimitiveUnionPropertyClass")}JsPrimitiveUnionProperty`,
                      ),
                      predicate:
                        JsPrimitiveUnionPropertyClass.$properties
                          .jsPrimitiveUnionProperty["identifier"],
                      subject: subject,
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: [parameters?.preferredLanguages ?? []]
                    .filter((languages) => languages.length > 0)
                    .map((languages) =>
                      languages.map((language) => ({
                        type: "operation" as const,
                        operator: "=",
                        args: [
                          {
                            type: "operation" as const,
                            operator: "lang",
                            args: [
                              dataFactory.variable!(
                                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "jsPrimitiveUnionPropertyClass")}JsPrimitiveUnionProperty`,
                              ),
                            ],
                          },
                          dataFactory.literal(language),
                        ],
                      })),
                    )
                    .map((langEqualsExpressions) => ({
                      type: "filter" as const,
                      expression: langEqualsExpressions.reduce(
                        (reducedExpression, langEqualsExpression) => {
                          if (reducedExpression === null) {
                            return langEqualsExpression;
                          }
                          return {
                            type: "operation" as const,
                            operator: "||",
                            args: [reducedExpression, langEqualsExpression],
                          };
                        },
                        null as sparqljs.Expression | null,
                      ) as sparqljs.Expression,
                    }))
                    .concat(),
                  type: "group",
                },
                {
                  patterns: $StringFilter
                    .$sparqlWherePatterns(
                      parameters?.filter?.jsPrimitiveUnionProperty?.on?.[
                        "string"
                      ],
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "jsPrimitiveUnionPropertyClass")}JsPrimitiveUnionProperty`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
              ],
              type: "group",
            },
          ],
          type: "union",
        },
      ],
      type: "optional",
    });
    return patterns;
  }

  export function isJsPrimitiveUnionPropertyClass(
    object: $Object,
  ): object is JsPrimitiveUnionPropertyClass {
    switch (object.$type) {
      case "JsPrimitiveUnionPropertyClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * A node shape that only allows IRI identifiers.
 */
export interface IriIdentifierInterface {
  readonly $identifier: IriIdentifierInterface.$Identifier;
  readonly $type: "IriIdentifierInterface";
}

export namespace IriIdentifierInterface {
  export function $create(parameters: {
    readonly $identifier: rdfjs.NamedNode | string;
  }): IriIdentifierInterface {
    let $identifier: IriIdentifierInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "IriIdentifierInterface" as const;
    return { $identifier, $type };
  }

  export function $equals(
    left: IriIdentifierInterface,
    right: IriIdentifierInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  export function $filter(
    filter: IriIdentifierInterface.$Filter,
    value: IriIdentifierInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = { readonly $identifier?: $NamedNodeFilter };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, IriIdentifierInterface> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, IriIdentifierInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return IriIdentifierInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _iriIdentifierInterface: IriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_iriIdentifierInterface.$identifier.value);
    _hasher.update(_iriIdentifierInterface.$type);
    IriIdentifierInterface.$hashShaclProperties(
      _iriIdentifierInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _iriIdentifierInterface: IriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    return _hasher;
  }

  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "IriIdentifierInterface";
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "IriIdentifierInterface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "IriIdentifierInterface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("IriIdentifierInterface"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {};

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.NamedNode; $type: "IriIdentifierInterface" }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const $type = "IriIdentifierInterface" as const;
    return purify.Either.of({ $identifier, $type });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.NamedNode; $type: "IriIdentifierInterface" }
  > {
    return (
      $parameters.resource.identifier.termType === "NamedNode"
        ? purify.Either.of<Error, IriIdentifierInterface.$Identifier>(
            $parameters.resource.identifier,
          )
        : purify.Left(
            new rdfjsResource.Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "(rdfjs.NamedNode)",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
    ).chain(($identifier) =>
      purify.Either.of<Error, "IriIdentifierInterface">(
        "IriIdentifierInterface",
      ).map(($type) => ({ $identifier, $type })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IriIdentifierInterface.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            IriIdentifierInterface.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IriIdentifierInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IriIdentifierInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("iriIdentifierInterface");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }

  export function $toJson(
    _iriIdentifierInterface: IriIdentifierInterface,
  ): IriIdentifierInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": _iriIdentifierInterface.$identifier.value,
        $type: _iriIdentifierInterface.$type,
      } satisfies IriIdentifierInterface.$Json),
    );
  }

  export function $toRdf(
    _iriIdentifierInterface: IriIdentifierInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(
      _iriIdentifierInterface.$identifier,
      { mutateGraph },
    );
    return resource;
  }

  export function isIriIdentifierInterface(
    object: $Object,
  ): object is IriIdentifierInterface {
    switch (object.$type) {
      case "IriIdentifierInterface":
        return true;
      default:
        return false;
    }
  }
}
/**
 * A node shape that only allows IRI identifiers.
 */
export class IriIdentifierClass {
  readonly $identifier: IriIdentifierClass.$Identifier;
  readonly $type = "IriIdentifierClass";

  constructor(parameters: { readonly $identifier: rdfjs.NamedNode | string }) {
    if (typeof parameters.$identifier === "object") {
      this.$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this.$identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      this.$identifier = parameters.$identifier satisfies never;
    }
  }

  $equals(other: IriIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    return _hasher;
  }

  $toJson(): IriIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
      } satisfies IriIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(this.$identifier, {
      mutateGraph,
    });
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IriIdentifierClass {
  export function $filter(
    filter: IriIdentifierClass.$Filter,
    value: IriIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = { readonly $identifier?: $NamedNodeFilter };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, IriIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new IriIdentifierClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, IriIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return IriIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new IriIdentifierClass(properties));
  }

  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "IriIdentifierClass";
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "IriIdentifierClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "IriIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("IriIdentifierClass"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {};

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<zod.ZodError, { $identifier: rdfjs.NamedNode }> {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    return purify.Either.of({ $identifier });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<Error, { $identifier: rdfjs.NamedNode }> {
    return (
      $parameters.resource.identifier.termType === "NamedNode"
        ? purify.Either.of<Error, IriIdentifierClass.$Identifier>(
            $parameters.resource.identifier,
          )
        : purify.Left(
            new rdfjsResource.Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "(rdfjs.NamedNode)",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
    ).map(($identifier) => ({ $identifier }));
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IriIdentifierClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            IriIdentifierClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IriIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IriIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("iriIdentifierClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }

  export function isIriIdentifierClass(
    object: $Object,
  ): object is IriIdentifierClass {
    switch (object.$type) {
      case "IriIdentifierClass":
        return true;
      default:
        return false;
    }
  }
}
export interface InterfaceUnionMemberCommonParent {
  readonly $identifier: InterfaceUnionMemberCommonParentStatic.$Identifier;
  readonly $type: "InterfaceUnionMember1" | "InterfaceUnionMember2";
  readonly interfaceUnionMemberCommonParentProperty: string;
}

export namespace InterfaceUnionMemberCommonParentStatic {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly interfaceUnionMemberCommonParentProperty: string;
  }): Omit<InterfaceUnionMemberCommonParent, "$type"> {
    let $identifier: InterfaceUnionMemberCommonParentStatic.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const interfaceUnionMemberCommonParentProperty =
      parameters.interfaceUnionMemberCommonParentProperty;
    return { $identifier, interfaceUnionMemberCommonParentProperty };
  }

  export function $equals(
    left: InterfaceUnionMemberCommonParent,
    right: InterfaceUnionMemberCommonParent,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.interfaceUnionMemberCommonParentProperty,
          right.interfaceUnionMemberCommonParentProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "interfaceUnionMemberCommonParentProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export function $filter(
    filter: InterfaceUnionMemberCommonParentStatic.$Filter,
    value: InterfaceUnionMemberCommonParent,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.interfaceUnionMemberCommonParentProperty !== "undefined" &&
      !$filterString(
        filter.interfaceUnionMemberCommonParentProperty,
        value.interfaceUnionMemberCommonParentProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly interfaceUnionMemberCommonParentProperty?: $StringFilter;
  };

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _interfaceUnionMemberCommonParent: InterfaceUnionMemberCommonParent,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_interfaceUnionMemberCommonParent.$identifier.value);
    _hasher.update(_interfaceUnionMemberCommonParent.$type);
    InterfaceUnionMemberCommonParentStatic.$hashShaclProperties(
      _interfaceUnionMemberCommonParent,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _interfaceUnionMemberCommonParent: InterfaceUnionMemberCommonParent,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _interfaceUnionMemberCommonParent.interfaceUnionMemberCommonParentProperty,
    );
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "InterfaceUnionMember1" | "InterfaceUnionMember2";
    readonly interfaceUnionMemberCommonParentProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "InterfaceUnionMemberCommonParent" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/interfaceUnionMemberCommonParentProperty`,
          type: "Control",
        },
      ],
      label: "InterfaceUnionMemberCommonParent",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.enum(["InterfaceUnionMember1", "InterfaceUnionMember2"]),
      interfaceUnionMemberCommonParentProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    interfaceUnionMemberCommonParentProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/interfaceUnionMemberCommonParentProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      interfaceUnionMemberCommonParentProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const interfaceUnionMemberCommonParentProperty =
      $jsonObject["interfaceUnionMemberCommonParentProperty"];
    return purify.Either.of({
      $identifier,
      interfaceUnionMemberCommonParentProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      interfaceUnionMemberCommonParentProperty: string;
    }
  > {
    return purify.Either.of<
      Error,
      InterfaceUnionMemberCommonParentStatic.$Identifier
    >(
      $parameters.resource
        .identifier as InterfaceUnionMemberCommonParentStatic.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.interfaceUnionMemberCommonParentProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              InterfaceUnionMemberCommonParentStatic.$properties
                .interfaceUnionMemberCommonParentProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((interfaceUnionMemberCommonParentProperty) => ({
          $identifier,
          interfaceUnionMemberCommonParentProperty,
        })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: InterfaceUnionMemberCommonParentStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InterfaceUnionMemberCommonParentStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            InterfaceUnionMemberCommonParentStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: InterfaceUnionMemberCommonParentStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InterfaceUnionMemberCommonParentStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("interfaceUnionMemberCommonParent");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMemberCommonParent")}InterfaceUnionMemberCommonParentProperty`,
      ),
      predicate:
        InterfaceUnionMemberCommonParentStatic.$properties
          .interfaceUnionMemberCommonParentProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: InterfaceUnionMemberCommonParentStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("interfaceUnionMemberCommonParent");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMemberCommonParent")}InterfaceUnionMemberCommonParentProperty`,
            ),
            predicate:
              InterfaceUnionMemberCommonParentStatic.$properties
                .interfaceUnionMemberCommonParentProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMemberCommonParent")}InterfaceUnionMemberCommonParentProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.interfaceUnionMemberCommonParentProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMemberCommonParent")}InterfaceUnionMemberCommonParentProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _interfaceUnionMemberCommonParent: InterfaceUnionMemberCommonParent,
  ): InterfaceUnionMemberCommonParentStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _interfaceUnionMemberCommonParent.$identifier.termType === "BlankNode"
            ? `_:${_interfaceUnionMemberCommonParent.$identifier.value}`
            : _interfaceUnionMemberCommonParent.$identifier.value,
        $type: _interfaceUnionMemberCommonParent.$type,
        interfaceUnionMemberCommonParentProperty:
          _interfaceUnionMemberCommonParent.interfaceUnionMemberCommonParentProperty,
      } satisfies InterfaceUnionMemberCommonParentStatic.$Json),
    );
  }

  export function $toRdf(
    _interfaceUnionMemberCommonParent: InterfaceUnionMemberCommonParent,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _interfaceUnionMemberCommonParent.$identifier,
      { mutateGraph },
    );
    resource.add(
      InterfaceUnionMemberCommonParentStatic.$properties
        .interfaceUnionMemberCommonParentProperty["identifier"],
      ...[
        _interfaceUnionMemberCommonParent.interfaceUnionMemberCommonParentProperty,
      ],
    );
    return resource;
  }

  export function isInterfaceUnionMemberCommonParent(
    object: $Object,
  ): object is InterfaceUnionMemberCommonParent {
    switch (object.$type) {
      case "InterfaceUnionMember1":
      case "InterfaceUnionMember2":
        return true;
      default:
        return false;
    }
  }
}
export interface InterfaceUnionMember2
  extends InterfaceUnionMemberCommonParent {
  readonly $identifier: InterfaceUnionMember2.$Identifier;
  readonly $type: "InterfaceUnionMember2";
  readonly interfaceUnionMember2Property: string;
}

export namespace InterfaceUnionMember2 {
  export function $create(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly interfaceUnionMember2Property: string;
    } & Parameters<typeof InterfaceUnionMemberCommonParentStatic.$create>[0],
  ): InterfaceUnionMember2 {
    let $identifier: InterfaceUnionMember2.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "InterfaceUnionMember2" as const;
    const interfaceUnionMember2Property =
      parameters.interfaceUnionMember2Property;
    return {
      ...InterfaceUnionMemberCommonParentStatic.$create(parameters),
      $identifier,
      $type,
      interfaceUnionMember2Property,
    };
  }

  export function $equals(
    left: InterfaceUnionMember2,
    right: InterfaceUnionMember2,
  ): $EqualsResult {
    return InterfaceUnionMemberCommonParentStatic.$equals(left, right).chain(
      () =>
        $strictEquals(
          left.interfaceUnionMember2Property,
          right.interfaceUnionMember2Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "interfaceUnionMember2Property",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
    );
  }

  export function $filter(
    filter: InterfaceUnionMember2.$Filter,
    value: InterfaceUnionMember2,
  ): boolean {
    if (!InterfaceUnionMemberCommonParentStatic.$filter(filter, value)) {
      return false;
    }

    if (
      typeof filter.interfaceUnionMember2Property !== "undefined" &&
      !$filterString(
        filter.interfaceUnionMember2Property,
        value.interfaceUnionMember2Property,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly interfaceUnionMember2Property?: $StringFilter;
  } & InterfaceUnionMemberCommonParentStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, InterfaceUnionMember2> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, InterfaceUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return InterfaceUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/InterfaceUnionMember2",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_interfaceUnionMember2: InterfaceUnionMember2, _hasher: HasherT): HasherT {
    InterfaceUnionMember2.$hashShaclProperties(_interfaceUnionMember2, _hasher);
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_interfaceUnionMember2: InterfaceUnionMember2, _hasher: HasherT): HasherT {
    InterfaceUnionMemberCommonParentStatic.$hashShaclProperties(
      _interfaceUnionMember2,
      _hasher,
    );
    _hasher.update(_interfaceUnionMember2.interfaceUnionMember2Property);
    return _hasher;
  }

  export type $Identifier = InterfaceUnionMemberCommonParentStatic.$Identifier;
  export const $Identifier = InterfaceUnionMemberCommonParentStatic.$Identifier;
  export type $Json = {
    readonly interfaceUnionMember2Property: string;
  } & InterfaceUnionMemberCommonParentStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InterfaceUnionMemberCommonParentStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/interfaceUnionMember2Property`,
          type: "Control",
        },
      ],
      label: "InterfaceUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return InterfaceUnionMemberCommonParentStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("InterfaceUnionMember2"),
        interfaceUnionMember2Property: zod.string(),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    ...InterfaceUnionMemberCommonParentStatic.$properties,
    interfaceUnionMember2Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/interfaceUnionMember2Property",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "InterfaceUnionMember2";
      interfaceUnionMember2Property: string;
    } & $UnwrapR<
      ReturnType<
        typeof InterfaceUnionMemberCommonParentStatic.$propertiesFromJson
      >
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "InterfaceUnionMember2" as const;
    const interfaceUnionMember2Property =
      $jsonObject["interfaceUnionMember2Property"];
    return InterfaceUnionMemberCommonParentStatic.$propertiesFromJson(
      $jsonObject,
    ).map(($super0) => ({
      ...$super0,
      $identifier,
      $type,
      interfaceUnionMember2Property,
    }));
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "InterfaceUnionMember2";
      interfaceUnionMember2Property: string;
    } & $UnwrapR<
      ReturnType<
        typeof InterfaceUnionMemberCommonParentStatic.$propertiesFromRdf
      >
    >
  > {
    return InterfaceUnionMemberCommonParentStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/InterfaceUnionMember2":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  InterfaceUnionMember2.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/InterfaceUnionMember2)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        purify.Either.of<Error, InterfaceUnionMember2.$Identifier>(
          $parameters.resource.identifier as InterfaceUnionMember2.$Identifier,
        ).chain(($identifier) =>
          purify.Either.of<Error, "InterfaceUnionMember2">(
            "InterfaceUnionMember2",
          ).chain(($type) =>
            purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
            >(
              $parameters.resource.values(
                $properties.interfaceUnionMember2Property["identifier"],
                { unique: true },
              ),
            )
              .chain((values) =>
                $fromRdfPreferredLanguages({
                  focusResource: $parameters.resource,
                  predicate:
                    InterfaceUnionMember2.$properties
                      .interfaceUnionMember2Property["identifier"],
                  preferredLanguages: $parameters.preferredLanguages,
                  values,
                }),
              )
              .chain((values) => values.chainMap((value) => value.toString()))
              .chain((values) => values.head())
              .map((interfaceUnionMember2Property) => ({
                ...$super0,
                $identifier,
                $type,
                interfaceUnionMember2Property,
              })),
          ),
        ),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: InterfaceUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InterfaceUnionMember2.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            InterfaceUnionMember2.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: InterfaceUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InterfaceUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("interfaceUnionMember2");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...InterfaceUnionMemberCommonParentStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "interfaceUnionMember2"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember2")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember2")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember2")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember2")}InterfaceUnionMember2Property`,
      ),
      predicate:
        InterfaceUnionMember2.$properties.interfaceUnionMember2Property[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: InterfaceUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("interfaceUnionMember2");
    patterns.push(
      ...InterfaceUnionMemberCommonParentStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "interfaceUnionMember2"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember2")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: InterfaceUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember2")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember2")}InterfaceUnionMember2Property`,
            ),
            predicate:
              InterfaceUnionMember2.$properties.interfaceUnionMember2Property[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember2")}InterfaceUnionMember2Property`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.interfaceUnionMember2Property,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember2")}InterfaceUnionMember2Property`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _interfaceUnionMember2: InterfaceUnionMember2,
  ): InterfaceUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        ...InterfaceUnionMemberCommonParentStatic.$toJson(
          _interfaceUnionMember2,
        ),
        interfaceUnionMember2Property:
          _interfaceUnionMember2.interfaceUnionMember2Property,
      } satisfies InterfaceUnionMember2.$Json),
    );
  }

  export function $toRdf(
    _interfaceUnionMember2: InterfaceUnionMember2,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = InterfaceUnionMemberCommonParentStatic.$toRdf(
      _interfaceUnionMember2,
      { ignoreRdfType: true, mutateGraph, resourceSet },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/InterfaceUnionMember2",
        ),
      );
    }

    resource.add(
      InterfaceUnionMember2.$properties.interfaceUnionMember2Property[
        "identifier"
      ],
      ...[_interfaceUnionMember2.interfaceUnionMember2Property],
    );
    return resource;
  }

  export function isInterfaceUnionMember2(
    object: $Object,
  ): object is InterfaceUnionMember2 {
    switch (object.$type) {
      case "InterfaceUnionMember2":
        return true;
      default:
        return false;
    }
  }
}
export interface InterfaceUnionMember1
  extends InterfaceUnionMemberCommonParent {
  readonly $identifier: InterfaceUnionMember1.$Identifier;
  readonly $type: "InterfaceUnionMember1";
  readonly interfaceUnionMember1Property: string;
}

export namespace InterfaceUnionMember1 {
  export function $create(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly interfaceUnionMember1Property: string;
    } & Parameters<typeof InterfaceUnionMemberCommonParentStatic.$create>[0],
  ): InterfaceUnionMember1 {
    let $identifier: InterfaceUnionMember1.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "InterfaceUnionMember1" as const;
    const interfaceUnionMember1Property =
      parameters.interfaceUnionMember1Property;
    return {
      ...InterfaceUnionMemberCommonParentStatic.$create(parameters),
      $identifier,
      $type,
      interfaceUnionMember1Property,
    };
  }

  export function $equals(
    left: InterfaceUnionMember1,
    right: InterfaceUnionMember1,
  ): $EqualsResult {
    return InterfaceUnionMemberCommonParentStatic.$equals(left, right).chain(
      () =>
        $strictEquals(
          left.interfaceUnionMember1Property,
          right.interfaceUnionMember1Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "interfaceUnionMember1Property",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
    );
  }

  export function $filter(
    filter: InterfaceUnionMember1.$Filter,
    value: InterfaceUnionMember1,
  ): boolean {
    if (!InterfaceUnionMemberCommonParentStatic.$filter(filter, value)) {
      return false;
    }

    if (
      typeof filter.interfaceUnionMember1Property !== "undefined" &&
      !$filterString(
        filter.interfaceUnionMember1Property,
        value.interfaceUnionMember1Property,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly interfaceUnionMember1Property?: $StringFilter;
  } & InterfaceUnionMemberCommonParentStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, InterfaceUnionMember1> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, InterfaceUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return InterfaceUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/InterfaceUnionMember1",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_interfaceUnionMember1: InterfaceUnionMember1, _hasher: HasherT): HasherT {
    InterfaceUnionMember1.$hashShaclProperties(_interfaceUnionMember1, _hasher);
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_interfaceUnionMember1: InterfaceUnionMember1, _hasher: HasherT): HasherT {
    InterfaceUnionMemberCommonParentStatic.$hashShaclProperties(
      _interfaceUnionMember1,
      _hasher,
    );
    _hasher.update(_interfaceUnionMember1.interfaceUnionMember1Property);
    return _hasher;
  }

  export type $Identifier = InterfaceUnionMemberCommonParentStatic.$Identifier;
  export const $Identifier = InterfaceUnionMemberCommonParentStatic.$Identifier;
  export type $Json = {
    readonly interfaceUnionMember1Property: string;
  } & InterfaceUnionMemberCommonParentStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InterfaceUnionMemberCommonParentStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/interfaceUnionMember1Property`,
          type: "Control",
        },
      ],
      label: "InterfaceUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return InterfaceUnionMemberCommonParentStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("InterfaceUnionMember1"),
        interfaceUnionMember1Property: zod.string(),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    ...InterfaceUnionMemberCommonParentStatic.$properties,
    interfaceUnionMember1Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/interfaceUnionMember1Property",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "InterfaceUnionMember1";
      interfaceUnionMember1Property: string;
    } & $UnwrapR<
      ReturnType<
        typeof InterfaceUnionMemberCommonParentStatic.$propertiesFromJson
      >
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "InterfaceUnionMember1" as const;
    const interfaceUnionMember1Property =
      $jsonObject["interfaceUnionMember1Property"];
    return InterfaceUnionMemberCommonParentStatic.$propertiesFromJson(
      $jsonObject,
    ).map(($super0) => ({
      ...$super0,
      $identifier,
      $type,
      interfaceUnionMember1Property,
    }));
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "InterfaceUnionMember1";
      interfaceUnionMember1Property: string;
    } & $UnwrapR<
      ReturnType<
        typeof InterfaceUnionMemberCommonParentStatic.$propertiesFromRdf
      >
    >
  > {
    return InterfaceUnionMemberCommonParentStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/InterfaceUnionMember1":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  InterfaceUnionMember1.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/InterfaceUnionMember1)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        purify.Either.of<Error, InterfaceUnionMember1.$Identifier>(
          $parameters.resource.identifier as InterfaceUnionMember1.$Identifier,
        ).chain(($identifier) =>
          purify.Either.of<Error, "InterfaceUnionMember1">(
            "InterfaceUnionMember1",
          ).chain(($type) =>
            purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
            >(
              $parameters.resource.values(
                $properties.interfaceUnionMember1Property["identifier"],
                { unique: true },
              ),
            )
              .chain((values) =>
                $fromRdfPreferredLanguages({
                  focusResource: $parameters.resource,
                  predicate:
                    InterfaceUnionMember1.$properties
                      .interfaceUnionMember1Property["identifier"],
                  preferredLanguages: $parameters.preferredLanguages,
                  values,
                }),
              )
              .chain((values) => values.chainMap((value) => value.toString()))
              .chain((values) => values.head())
              .map((interfaceUnionMember1Property) => ({
                ...$super0,
                $identifier,
                $type,
                interfaceUnionMember1Property,
              })),
          ),
        ),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: InterfaceUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InterfaceUnionMember1.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            InterfaceUnionMember1.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: InterfaceUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InterfaceUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("interfaceUnionMember1");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...InterfaceUnionMemberCommonParentStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "interfaceUnionMember1"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember1")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember1")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember1")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember1")}InterfaceUnionMember1Property`,
      ),
      predicate:
        InterfaceUnionMember1.$properties.interfaceUnionMember1Property[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: InterfaceUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("interfaceUnionMember1");
    patterns.push(
      ...InterfaceUnionMemberCommonParentStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "interfaceUnionMember1"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember1")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: InterfaceUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember1")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember1")}InterfaceUnionMember1Property`,
            ),
            predicate:
              InterfaceUnionMember1.$properties.interfaceUnionMember1Property[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember1")}InterfaceUnionMember1Property`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.interfaceUnionMember1Property,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember1")}InterfaceUnionMember1Property`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _interfaceUnionMember1: InterfaceUnionMember1,
  ): InterfaceUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        ...InterfaceUnionMemberCommonParentStatic.$toJson(
          _interfaceUnionMember1,
        ),
        interfaceUnionMember1Property:
          _interfaceUnionMember1.interfaceUnionMember1Property,
      } satisfies InterfaceUnionMember1.$Json),
    );
  }

  export function $toRdf(
    _interfaceUnionMember1: InterfaceUnionMember1,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = InterfaceUnionMemberCommonParentStatic.$toRdf(
      _interfaceUnionMember1,
      { ignoreRdfType: true, mutateGraph, resourceSet },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/InterfaceUnionMember1",
        ),
      );
    }

    resource.add(
      InterfaceUnionMember1.$properties.interfaceUnionMember1Property[
        "identifier"
      ],
      ...[_interfaceUnionMember1.interfaceUnionMember1Property],
    );
    return resource;
  }

  export function isInterfaceUnionMember1(
    object: $Object,
  ): object is InterfaceUnionMember1 {
    switch (object.$type) {
      case "InterfaceUnionMember1":
        return true;
      default:
        return false;
    }
  }
}
/**
 * A node shape that's generated as a TypeScript interface instead of a class.
 */
export interface Interface {
  readonly $identifier: Interface.$Identifier;
  readonly $type: "Interface";
  readonly interfaceProperty: string;
}

export namespace Interface {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly interfaceProperty: string;
  }): Interface {
    let $identifier: Interface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "Interface" as const;
    const interfaceProperty = parameters.interfaceProperty;
    return { $identifier, $type, interfaceProperty };
  }

  export function $equals(left: Interface, right: Interface): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(left.interfaceProperty, right.interfaceProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "interfaceProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  export function $filter(
    filter: Interface.$Filter,
    value: Interface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.interfaceProperty !== "undefined" &&
      !$filterString(filter.interfaceProperty, value.interfaceProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly interfaceProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Interface> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, Interface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return Interface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_interface: Interface, _hasher: HasherT): HasherT {
    _hasher.update(_interface.$identifier.value);
    _hasher.update(_interface.$type);
    Interface.$hashShaclProperties(_interface, _hasher);
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_interface: Interface, _hasher: HasherT): HasherT {
    _hasher.update(_interface.interfaceProperty);
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "Interface";
    readonly interfaceProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "Interface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/interfaceProperty`,
          type: "Control",
        },
      ],
      label: "Interface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("Interface"),
      interfaceProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    interfaceProperty: {
      identifier: dataFactory.namedNode("http://example.com/interfaceProperty"),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "Interface";
      interfaceProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "Interface" as const;
    const interfaceProperty = $jsonObject["interfaceProperty"];
    return purify.Either.of({ $identifier, $type, interfaceProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "Interface";
      interfaceProperty: string;
    }
  > {
    return purify.Either.of<Error, Interface.$Identifier>(
      $parameters.resource.identifier as Interface.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<Error, "Interface">("Interface").chain(($type) =>
        purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
        >(
          $parameters.resource.values(
            $properties.interfaceProperty["identifier"],
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate: Interface.$properties.interfaceProperty["identifier"],
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((interfaceProperty) => ({
            $identifier,
            $type,
            interfaceProperty,
          })),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: Interface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Interface.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            Interface.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: Interface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Interface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("interface");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interface")}InterfaceProperty`,
      ),
      predicate: Interface.$properties.interfaceProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: Interface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("interface");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interface")}InterfaceProperty`,
            ),
            predicate: Interface.$properties.interfaceProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interface")}InterfaceProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.interfaceProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interface")}InterfaceProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(_interface: Interface): Interface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _interface.$identifier.termType === "BlankNode"
            ? `_:${_interface.$identifier.value}`
            : _interface.$identifier.value,
        $type: _interface.$type,
        interfaceProperty: _interface.interfaceProperty,
      } satisfies Interface.$Json),
    );
  }

  export function $toRdf(
    _interface: Interface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(_interface.$identifier, {
      mutateGraph,
    });
    resource.add(
      Interface.$properties.interfaceProperty["identifier"],
      ...[_interface.interfaceProperty],
    );
    return resource;
  }

  export function isInterface(object: $Object): object is Interface {
    switch (object.$type) {
      case "Interface":
        return true;
      default:
        return false;
    }
  }
}
export class IndirectRecursiveHelperClass {
  private _$identifier?: IndirectRecursiveHelperClass.$Identifier;
  readonly $type = "IndirectRecursiveHelperClass";
  readonly indirectRecursiveProperty: purify.Maybe<IndirectRecursiveClass>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly indirectRecursiveProperty?:
      | IndirectRecursiveClass
      | purify.Maybe<IndirectRecursiveClass>;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.indirectRecursiveProperty)) {
      this.indirectRecursiveProperty = parameters?.indirectRecursiveProperty;
    } else if (
      typeof parameters?.indirectRecursiveProperty === "object" &&
      parameters?.indirectRecursiveProperty instanceof IndirectRecursiveClass
    ) {
      this.indirectRecursiveProperty = purify.Maybe.of(
        parameters?.indirectRecursiveProperty,
      );
    } else if (typeof parameters?.indirectRecursiveProperty === "undefined") {
      this.indirectRecursiveProperty = purify.Maybe.empty();
    } else {
      this.indirectRecursiveProperty =
        parameters?.indirectRecursiveProperty satisfies never;
    }
  }

  get $identifier(): IndirectRecursiveHelperClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: IndirectRecursiveHelperClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.indirectRecursiveProperty,
          other.indirectRecursiveProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "indirectRecursiveProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.indirectRecursiveProperty.ifJust((value0) => {
      value0.$hash(_hasher);
    });
    return _hasher;
  }

  $toJson(): IndirectRecursiveHelperClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        indirectRecursiveProperty: this.indirectRecursiveProperty
          .map((item) => item.$toJson())
          .extract(),
      } satisfies IndirectRecursiveHelperClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      IndirectRecursiveHelperClass.$properties.indirectRecursiveProperty[
        "identifier"
      ],
      ...this.indirectRecursiveProperty
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IndirectRecursiveHelperClass {
  export function $filter(
    filter: IndirectRecursiveHelperClass.$Filter,
    value: IndirectRecursiveHelperClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.indirectRecursiveProperty !== "undefined" &&
      !$filterMaybe<IndirectRecursiveClass, IndirectRecursiveClass.$Filter>(
        IndirectRecursiveClass.$filter,
      )(filter.indirectRecursiveProperty, value.indirectRecursiveProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly indirectRecursiveProperty?: $MaybeFilter<IndirectRecursiveClass.$Filter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, IndirectRecursiveHelperClass> {
    return $propertiesFromJson(json).map(
      (properties) => new IndirectRecursiveHelperClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, IndirectRecursiveHelperClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return IndirectRecursiveHelperClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new IndirectRecursiveHelperClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "IndirectRecursiveHelperClass";
    readonly indirectRecursiveProperty?: IndirectRecursiveClass.$Json;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "IndirectRecursiveHelperClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        IndirectRecursiveClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/indirectRecursiveProperty`,
        }),
      ],
      label: "IndirectRecursiveHelperClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("IndirectRecursiveHelperClass"),
      indirectRecursiveProperty: zod
        .lazy(
          (): zod.ZodType<IndirectRecursiveClass.$Json> =>
            IndirectRecursiveClass.$jsonZodSchema(),
        )
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    indirectRecursiveProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/indirectRecursiveProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      indirectRecursiveProperty: purify.Maybe<IndirectRecursiveClass>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const indirectRecursiveProperty = purify.Maybe.fromNullable(
      $jsonObject["indirectRecursiveProperty"],
    ).map((item) => IndirectRecursiveClass.$fromJson(item).unsafeCoerce());
    return purify.Either.of({ $identifier, indirectRecursiveProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      indirectRecursiveProperty: purify.Maybe<IndirectRecursiveClass>;
    }
  > {
    return purify.Either.of<Error, IndirectRecursiveHelperClass.$Identifier>(
      $parameters.resource
        .identifier as IndirectRecursiveHelperClass.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.indirectRecursiveProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          values.chainMap((value) =>
            value.toResource().chain((resource) =>
              IndirectRecursiveClass.$fromRdf(resource, {
                context: $parameters.context,
                ignoreRdfType: true,
                objectSet: $parameters.objectSet,
                preferredLanguages: $parameters.preferredLanguages,
              }),
            ),
          ),
        )
        .map((values) =>
          values.length > 0
            ? values.map((value) => purify.Maybe.of(value))
            : rdfjsResource.Resource.Values.fromValue<
                purify.Maybe<IndirectRecursiveClass>
              >({
                focusResource: $parameters.resource,
                predicate:
                  IndirectRecursiveHelperClass.$properties
                    .indirectRecursiveProperty["identifier"],
                value: purify.Maybe.empty(),
              }),
        )
        .chain((values) => values.head())
        .map((indirectRecursiveProperty) => ({
          $identifier,
          indirectRecursiveProperty,
        })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IndirectRecursiveHelperClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IndirectRecursiveHelperClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            IndirectRecursiveHelperClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IndirectRecursiveHelperClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IndirectRecursiveHelperClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IndirectRecursiveHelperClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("indirectRecursiveHelperClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }

  export function isIndirectRecursiveHelperClass(
    object: $Object,
  ): object is IndirectRecursiveHelperClass {
    switch (object.$type) {
      case "IndirectRecursiveHelperClass":
        return true;
      default:
        return false;
    }
  }
}
export class IndirectRecursiveClass {
  private _$identifier?: IndirectRecursiveClass.$Identifier;
  readonly $type = "IndirectRecursiveClass";
  readonly indirectRecursiveHelperProperty: purify.Maybe<IndirectRecursiveHelperClass>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly indirectRecursiveHelperProperty?:
      | IndirectRecursiveHelperClass
      | purify.Maybe<IndirectRecursiveHelperClass>;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.indirectRecursiveHelperProperty)) {
      this.indirectRecursiveHelperProperty =
        parameters?.indirectRecursiveHelperProperty;
    } else if (
      typeof parameters?.indirectRecursiveHelperProperty === "object" &&
      parameters?.indirectRecursiveHelperProperty instanceof
        IndirectRecursiveHelperClass
    ) {
      this.indirectRecursiveHelperProperty = purify.Maybe.of(
        parameters?.indirectRecursiveHelperProperty,
      );
    } else if (
      typeof parameters?.indirectRecursiveHelperProperty === "undefined"
    ) {
      this.indirectRecursiveHelperProperty = purify.Maybe.empty();
    } else {
      this.indirectRecursiveHelperProperty =
        parameters?.indirectRecursiveHelperProperty satisfies never;
    }
  }

  get $identifier(): IndirectRecursiveClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: IndirectRecursiveClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.indirectRecursiveHelperProperty,
          other.indirectRecursiveHelperProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "indirectRecursiveHelperProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.indirectRecursiveHelperProperty.ifJust((value0) => {
      value0.$hash(_hasher);
    });
    return _hasher;
  }

  $toJson(): IndirectRecursiveClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        indirectRecursiveHelperProperty: this.indirectRecursiveHelperProperty
          .map((item) => item.$toJson())
          .extract(),
      } satisfies IndirectRecursiveClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      IndirectRecursiveClass.$properties.indirectRecursiveHelperProperty[
        "identifier"
      ],
      ...this.indirectRecursiveHelperProperty
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IndirectRecursiveClass {
  export function $filter(
    filter: IndirectRecursiveClass.$Filter,
    value: IndirectRecursiveClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.indirectRecursiveHelperProperty !== "undefined" &&
      !$filterMaybe<
        IndirectRecursiveHelperClass,
        IndirectRecursiveHelperClass.$Filter
      >(IndirectRecursiveHelperClass.$filter)(
        filter.indirectRecursiveHelperProperty,
        value.indirectRecursiveHelperProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly indirectRecursiveHelperProperty?: $MaybeFilter<IndirectRecursiveHelperClass.$Filter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, IndirectRecursiveClass> {
    return $propertiesFromJson(json).map(
      (properties) => new IndirectRecursiveClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, IndirectRecursiveClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return IndirectRecursiveClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new IndirectRecursiveClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "IndirectRecursiveClass";
    readonly indirectRecursiveHelperProperty?: IndirectRecursiveHelperClass.$Json;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "IndirectRecursiveClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        IndirectRecursiveHelperClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/indirectRecursiveHelperProperty`,
        }),
      ],
      label: "IndirectRecursiveClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("IndirectRecursiveClass"),
      indirectRecursiveHelperProperty: zod
        .lazy(
          (): zod.ZodType<IndirectRecursiveHelperClass.$Json> =>
            IndirectRecursiveHelperClass.$jsonZodSchema(),
        )
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    indirectRecursiveHelperProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/indirectRecursiveHelperProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      indirectRecursiveHelperProperty: purify.Maybe<IndirectRecursiveHelperClass>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const indirectRecursiveHelperProperty = purify.Maybe.fromNullable(
      $jsonObject["indirectRecursiveHelperProperty"],
    ).map((item) =>
      IndirectRecursiveHelperClass.$fromJson(item).unsafeCoerce(),
    );
    return purify.Either.of({ $identifier, indirectRecursiveHelperProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      indirectRecursiveHelperProperty: purify.Maybe<IndirectRecursiveHelperClass>;
    }
  > {
    return purify.Either.of<Error, IndirectRecursiveClass.$Identifier>(
      $parameters.resource.identifier as IndirectRecursiveClass.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.indirectRecursiveHelperProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          values.chainMap((value) =>
            value.toResource().chain((resource) =>
              IndirectRecursiveHelperClass.$fromRdf(resource, {
                context: $parameters.context,
                ignoreRdfType: true,
                objectSet: $parameters.objectSet,
                preferredLanguages: $parameters.preferredLanguages,
              }),
            ),
          ),
        )
        .map((values) =>
          values.length > 0
            ? values.map((value) => purify.Maybe.of(value))
            : rdfjsResource.Resource.Values.fromValue<
                purify.Maybe<IndirectRecursiveHelperClass>
              >({
                focusResource: $parameters.resource,
                predicate:
                  IndirectRecursiveClass.$properties
                    .indirectRecursiveHelperProperty["identifier"],
                value: purify.Maybe.empty(),
              }),
        )
        .chain((values) => values.head())
        .map((indirectRecursiveHelperProperty) => ({
          $identifier,
          indirectRecursiveHelperProperty,
        })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IndirectRecursiveClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IndirectRecursiveClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            IndirectRecursiveClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IndirectRecursiveClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IndirectRecursiveClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IndirectRecursiveClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("indirectRecursiveClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }

  export function isIndirectRecursiveClass(
    object: $Object,
  ): object is IndirectRecursiveClass {
    switch (object.$type) {
      case "IndirectRecursiveClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Shape with sh:in properties.
 */
export class InPropertiesClass {
  private _$identifier?: InPropertiesClass.$Identifier;
  readonly $type = "InPropertiesClass";
  readonly inBooleansProperty: purify.Maybe<true>;
  readonly inDateTimesProperty: purify.Maybe<Date>;
  readonly inIrisProperty: purify.Maybe<
    rdfjs.NamedNode<
      | "http://example.com/InPropertiesIri1"
      | "http://example.com/InPropertiesIri2"
    >
  >;
  readonly inNumbersProperty: purify.Maybe<1 | 2>;
  readonly inStringsProperty: purify.Maybe<"text" | "html">;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly inBooleansProperty?: purify.Maybe<true> | true;
    readonly inDateTimesProperty?: Date | purify.Maybe<Date>;
    readonly inIrisProperty?:
      | "http://example.com/InPropertiesIri1"
      | "http://example.com/InPropertiesIri2"
      | purify.Maybe<
          rdfjs.NamedNode<
            | "http://example.com/InPropertiesIri1"
            | "http://example.com/InPropertiesIri2"
          >
        >
      | rdfjs.NamedNode<
          | "http://example.com/InPropertiesIri1"
          | "http://example.com/InPropertiesIri2"
        >;
    readonly inNumbersProperty?: 1 | 2 | purify.Maybe<1 | 2>;
    readonly inStringsProperty?:
      | "text"
      | "html"
      | purify.Maybe<"text" | "html">;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.inBooleansProperty)) {
      this.inBooleansProperty = parameters?.inBooleansProperty;
    } else if (typeof parameters?.inBooleansProperty === "boolean") {
      this.inBooleansProperty = purify.Maybe.of(parameters?.inBooleansProperty);
    } else if (typeof parameters?.inBooleansProperty === "undefined") {
      this.inBooleansProperty = purify.Maybe.empty();
    } else {
      this.inBooleansProperty = parameters?.inBooleansProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.inDateTimesProperty)) {
      this.inDateTimesProperty = parameters?.inDateTimesProperty;
    } else if (
      typeof parameters?.inDateTimesProperty === "object" &&
      parameters?.inDateTimesProperty instanceof Date
    ) {
      this.inDateTimesProperty = purify.Maybe.of(
        parameters?.inDateTimesProperty,
      );
    } else if (typeof parameters?.inDateTimesProperty === "undefined") {
      this.inDateTimesProperty = purify.Maybe.empty();
    } else {
      this.inDateTimesProperty =
        parameters?.inDateTimesProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.inIrisProperty)) {
      this.inIrisProperty = parameters?.inIrisProperty;
    } else if (typeof parameters?.inIrisProperty === "object") {
      this.inIrisProperty = purify.Maybe.of(parameters?.inIrisProperty);
    } else if (typeof parameters?.inIrisProperty === "string") {
      this.inIrisProperty = purify.Maybe.of(
        dataFactory.namedNode(parameters?.inIrisProperty),
      );
    } else if (typeof parameters?.inIrisProperty === "undefined") {
      this.inIrisProperty = purify.Maybe.empty();
    } else {
      this.inIrisProperty = parameters?.inIrisProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.inNumbersProperty)) {
      this.inNumbersProperty = parameters?.inNumbersProperty;
    } else if (typeof parameters?.inNumbersProperty === "number") {
      this.inNumbersProperty = purify.Maybe.of(parameters?.inNumbersProperty);
    } else if (typeof parameters?.inNumbersProperty === "undefined") {
      this.inNumbersProperty = purify.Maybe.empty();
    } else {
      this.inNumbersProperty = parameters?.inNumbersProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.inStringsProperty)) {
      this.inStringsProperty = parameters?.inStringsProperty;
    } else if (typeof parameters?.inStringsProperty === "string") {
      this.inStringsProperty = purify.Maybe.of(parameters?.inStringsProperty);
    } else if (typeof parameters?.inStringsProperty === "undefined") {
      this.inStringsProperty = purify.Maybe.empty();
    } else {
      this.inStringsProperty = parameters?.inStringsProperty satisfies never;
    }
  }

  get $identifier(): InPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: InPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.inBooleansProperty,
          other.inBooleansProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inBooleansProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.inDateTimesProperty,
          other.inDateTimesProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inDateTimesProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.inIrisProperty,
          other.inIrisProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inIrisProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.inNumbersProperty,
          other.inNumbersProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inNumbersProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.inStringsProperty,
          other.inStringsProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inStringsProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.inBooleansProperty.ifJust((value0) => {
      _hasher.update(value0.toString());
    });
    this.inDateTimesProperty.ifJust((value0) => {
      _hasher.update(value0.toISOString());
    });
    this.inIrisProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    this.inNumbersProperty.ifJust((value0) => {
      _hasher.update(value0.toString());
    });
    this.inStringsProperty.ifJust((value0) => {
      _hasher.update(value0);
    });
    return _hasher;
  }

  $toJson(): InPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        inBooleansProperty: this.inBooleansProperty
          .map((item) => item)
          .extract(),
        inDateTimesProperty: this.inDateTimesProperty
          .map((item) => item.toISOString())
          .extract(),
        inIrisProperty: this.inIrisProperty
          .map((item) => ({ "@id": item.value }))
          .extract(),
        inNumbersProperty: this.inNumbersProperty.map((item) => item).extract(),
        inStringsProperty: this.inStringsProperty.map((item) => item).extract(),
      } satisfies InPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      InPropertiesClass.$properties.inBooleansProperty["identifier"],
      ...this.inBooleansProperty.toList(),
    );
    resource.add(
      InPropertiesClass.$properties.inDateTimesProperty["identifier"],
      ...this.inDateTimesProperty
        .toList()
        .flatMap((value) => [
          dataFactory.literal(
            value.toISOString(),
            $RdfVocabularies.xsd.dateTime,
          ),
        ]),
    );
    resource.add(
      InPropertiesClass.$properties.inIrisProperty["identifier"],
      ...this.inIrisProperty.toList(),
    );
    resource.add(
      InPropertiesClass.$properties.inNumbersProperty["identifier"],
      ...this.inNumbersProperty
        .toList()
        .flatMap((value) => [
          dataFactory.literal(value.toString(10), $RdfVocabularies.xsd.integer),
        ]),
    );
    resource.add(
      InPropertiesClass.$properties.inStringsProperty["identifier"],
      ...this.inStringsProperty.toList(),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace InPropertiesClass {
  export function $filter(
    filter: InPropertiesClass.$Filter,
    value: InPropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.inBooleansProperty !== "undefined" &&
      !$filterMaybe<true, $BooleanFilter>($filterBoolean)(
        filter.inBooleansProperty,
        value.inBooleansProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.inDateTimesProperty !== "undefined" &&
      !$filterMaybe<Date, $DateFilter>($filterDate)(
        filter.inDateTimesProperty,
        value.inDateTimesProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.inIrisProperty !== "undefined" &&
      !$filterMaybe<
        rdfjs.NamedNode<
          | "http://example.com/InPropertiesIri1"
          | "http://example.com/InPropertiesIri2"
        >,
        $NamedNodeFilter
      >($filterNamedNode)(filter.inIrisProperty, value.inIrisProperty)
    ) {
      return false;
    }

    if (
      typeof filter.inNumbersProperty !== "undefined" &&
      !$filterMaybe<1 | 2, $NumberFilter>($filterNumber)(
        filter.inNumbersProperty,
        value.inNumbersProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.inStringsProperty !== "undefined" &&
      !$filterMaybe<"text" | "html", $StringFilter>($filterString)(
        filter.inStringsProperty,
        value.inStringsProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly inBooleansProperty?: $MaybeFilter<$BooleanFilter>;
    readonly inDateTimesProperty?: $MaybeFilter<$DateFilter>;
    readonly inIrisProperty?: $MaybeFilter<$NamedNodeFilter>;
    readonly inNumbersProperty?: $MaybeFilter<$NumberFilter>;
    readonly inStringsProperty?: $MaybeFilter<$StringFilter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, InPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new InPropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, InPropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return InPropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new InPropertiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "InPropertiesClass";
    readonly inBooleansProperty?: true;
    readonly inDateTimesProperty?: string;
    readonly inIrisProperty?: {
      readonly "@id":
        | "http://example.com/InPropertiesIri1"
        | "http://example.com/InPropertiesIri2";
    };
    readonly inNumbersProperty?: 1 | 2;
    readonly inStringsProperty?: "text" | "html";
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "InPropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/inBooleansProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/inDateTimesProperty`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/inIrisProperty`, type: "Control" },
        {
          scope: `${scopePrefix}/properties/inNumbersProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/inStringsProperty`,
          type: "Control",
        },
      ],
      label: "InPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("InPropertiesClass"),
      inBooleansProperty: zod.literal(true).optional(),
      inDateTimesProperty: zod.iso.datetime().optional(),
      inIrisProperty: zod
        .object({
          "@id": zod.enum([
            "http://example.com/InPropertiesIri1",
            "http://example.com/InPropertiesIri2",
          ]),
        })
        .optional(),
      inNumbersProperty: zod.union([zod.literal(1), zod.literal(2)]).optional(),
      inStringsProperty: zod.enum(["text", "html"]).optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    inBooleansProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/inBooleansProperty",
      ),
    },
    inDateTimesProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/inDateTimesProperty",
      ),
    },
    inIrisProperty: {
      identifier: dataFactory.namedNode("http://example.com/inIrisProperty"),
    },
    inNumbersProperty: {
      identifier: dataFactory.namedNode("http://example.com/inNumbersProperty"),
    },
    inStringsProperty: {
      identifier: dataFactory.namedNode("http://example.com/inStringsProperty"),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      inBooleansProperty: purify.Maybe<true>;
      inDateTimesProperty: purify.Maybe<Date>;
      inIrisProperty: purify.Maybe<
        rdfjs.NamedNode<
          | "http://example.com/InPropertiesIri1"
          | "http://example.com/InPropertiesIri2"
        >
      >;
      inNumbersProperty: purify.Maybe<1 | 2>;
      inStringsProperty: purify.Maybe<"text" | "html">;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const inBooleansProperty = purify.Maybe.fromNullable(
      $jsonObject["inBooleansProperty"],
    );
    const inDateTimesProperty = purify.Maybe.fromNullable(
      $jsonObject["inDateTimesProperty"],
    ).map((item) => new Date(item));
    const inIrisProperty = purify.Maybe.fromNullable(
      $jsonObject["inIrisProperty"],
    ).map((item) => dataFactory.namedNode(item["@id"]));
    const inNumbersProperty = purify.Maybe.fromNullable(
      $jsonObject["inNumbersProperty"],
    );
    const inStringsProperty = purify.Maybe.fromNullable(
      $jsonObject["inStringsProperty"],
    );
    return purify.Either.of({
      $identifier,
      inBooleansProperty,
      inDateTimesProperty,
      inIrisProperty,
      inNumbersProperty,
      inStringsProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      inBooleansProperty: purify.Maybe<true>;
      inDateTimesProperty: purify.Maybe<Date>;
      inIrisProperty: purify.Maybe<
        rdfjs.NamedNode<
          | "http://example.com/InPropertiesIri1"
          | "http://example.com/InPropertiesIri2"
        >
      >;
      inNumbersProperty: purify.Maybe<1 | 2>;
      inStringsProperty: purify.Maybe<"text" | "html">;
    }
  > {
    return purify.Either.of<Error, InPropertiesClass.$Identifier>(
      $parameters.resource.identifier as InPropertiesClass.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.inBooleansProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          values.chainMap((value) =>
            value.toBoolean().chain((primitiveValue) =>
              primitiveValue === true
                ? purify.Either.of<Error, true>(primitiveValue)
                : purify.Left<Error, true>(
                    new rdfjsResource.Resource.MistypedTermValueError({
                      actualValue: value.toTerm(),
                      expectedValueType: "true",
                      focusResource: $parameters.resource,
                      predicate:
                        InPropertiesClass.$properties.inBooleansProperty[
                          "identifier"
                        ],
                    }),
                  ),
            ),
          ),
        )
        .map((values) =>
          values.length > 0
            ? values.map((value) => purify.Maybe.of(value))
            : rdfjsResource.Resource.Values.fromValue<purify.Maybe<true>>({
                focusResource: $parameters.resource,
                predicate:
                  InPropertiesClass.$properties.inBooleansProperty[
                    "identifier"
                  ],
                value: purify.Maybe.empty(),
              }),
        )
        .chain((values) => values.head())
        .chain((inBooleansProperty) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.inDateTimesProperty["identifier"],
              { unique: true },
            ),
          )
            .chain((values) =>
              values.chainMap((value) =>
                value.toDate().chain((primitiveValue) => {
                  if (primitiveValue.getTime() === 1523268000000) {
                    return purify.Either.of<Error, Date>(primitiveValue);
                  }
                  return purify.Left<Error, Date>(
                    new rdfjsResource.Resource.MistypedTermValueError({
                      actualValue: value.toTerm(),
                      expectedValueType: "Date",
                      focusResource: $parameters.resource,
                      predicate:
                        InPropertiesClass.$properties.inDateTimesProperty[
                          "identifier"
                        ],
                    }),
                  );
                }),
              ),
            )
            .map((values) =>
              values.length > 0
                ? values.map((value) => purify.Maybe.of(value))
                : rdfjsResource.Resource.Values.fromValue<purify.Maybe<Date>>({
                    focusResource: $parameters.resource,
                    predicate:
                      InPropertiesClass.$properties.inDateTimesProperty[
                        "identifier"
                      ],
                    value: purify.Maybe.empty(),
                  }),
            )
            .chain((values) => values.head())
            .chain((inDateTimesProperty) =>
              purify.Either.of<
                Error,
                rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
              >(
                $parameters.resource.values(
                  $properties.inIrisProperty["identifier"],
                  { unique: true },
                ),
              )
                .chain((values) =>
                  values.chainMap((value) =>
                    value.toIri().chain((iri) => {
                      switch (iri.value) {
                        case "http://example.com/InPropertiesIri1":
                          return purify.Either.of<
                            Error,
                            rdfjs.NamedNode<
                              | "http://example.com/InPropertiesIri1"
                              | "http://example.com/InPropertiesIri2"
                            >
                          >(
                            iri as rdfjs.NamedNode<"http://example.com/InPropertiesIri1">,
                          );
                        case "http://example.com/InPropertiesIri2":
                          return purify.Either.of<
                            Error,
                            rdfjs.NamedNode<
                              | "http://example.com/InPropertiesIri1"
                              | "http://example.com/InPropertiesIri2"
                            >
                          >(
                            iri as rdfjs.NamedNode<"http://example.com/InPropertiesIri2">,
                          );
                        default:
                          return purify.Left<
                            Error,
                            rdfjs.NamedNode<
                              | "http://example.com/InPropertiesIri1"
                              | "http://example.com/InPropertiesIri2"
                            >
                          >(
                            new rdfjsResource.Resource.MistypedTermValueError({
                              actualValue: iri,
                              expectedValueType:
                                'rdfjs.NamedNode<"http://example.com/InPropertiesIri1" | "http://example.com/InPropertiesIri2">',
                              focusResource: $parameters.resource,
                              predicate:
                                InPropertiesClass.$properties.inIrisProperty[
                                  "identifier"
                                ],
                            }),
                          );
                      }
                    }),
                  ),
                )
                .map((values) =>
                  values.length > 0
                    ? values.map((value) => purify.Maybe.of(value))
                    : rdfjsResource.Resource.Values.fromValue<
                        purify.Maybe<
                          rdfjs.NamedNode<
                            | "http://example.com/InPropertiesIri1"
                            | "http://example.com/InPropertiesIri2"
                          >
                        >
                      >({
                        focusResource: $parameters.resource,
                        predicate:
                          InPropertiesClass.$properties.inIrisProperty[
                            "identifier"
                          ],
                        value: purify.Maybe.empty(),
                      }),
                )
                .chain((values) => values.head())
                .chain((inIrisProperty) =>
                  purify.Either.of<
                    Error,
                    rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                  >(
                    $parameters.resource.values(
                      $properties.inNumbersProperty["identifier"],
                      { unique: true },
                    ),
                  )
                    .chain((values) =>
                      values.chainMap((value) =>
                        value.toNumber().chain((primitiveValue) => {
                          switch (primitiveValue) {
                            case 1:
                            case 2:
                              return purify.Either.of<Error, 1 | 2>(
                                primitiveValue,
                              );
                            default:
                              return purify.Left<Error, 1 | 2>(
                                new rdfjsResource.Resource.MistypedTermValueError(
                                  {
                                    actualValue: value.toTerm(),
                                    expectedValueType: "1 | 2",
                                    focusResource: $parameters.resource,
                                    predicate:
                                      InPropertiesClass.$properties
                                        .inNumbersProperty["identifier"],
                                  },
                                ),
                              );
                          }
                        }),
                      ),
                    )
                    .map((values) =>
                      values.length > 0
                        ? values.map((value) => purify.Maybe.of(value))
                        : rdfjsResource.Resource.Values.fromValue<
                            purify.Maybe<1 | 2>
                          >({
                            focusResource: $parameters.resource,
                            predicate:
                              InPropertiesClass.$properties.inNumbersProperty[
                                "identifier"
                              ],
                            value: purify.Maybe.empty(),
                          }),
                    )
                    .chain((values) => values.head())
                    .chain((inNumbersProperty) =>
                      purify.Either.of<
                        Error,
                        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                      >(
                        $parameters.resource.values(
                          $properties.inStringsProperty["identifier"],
                          { unique: true },
                        ),
                      )
                        .chain((values) =>
                          $fromRdfPreferredLanguages({
                            focusResource: $parameters.resource,
                            predicate:
                              InPropertiesClass.$properties.inStringsProperty[
                                "identifier"
                              ],
                            preferredLanguages: $parameters.preferredLanguages,
                            values,
                          }),
                        )
                        .chain((values) =>
                          values.chainMap((value) =>
                            value.toString().chain((string_) => {
                              switch (string_) {
                                case "text":
                                case "html":
                                  return purify.Either.of<
                                    Error,
                                    "text" | "html"
                                  >(string_);
                                default:
                                  return purify.Left<Error, "text" | "html">(
                                    new rdfjsResource.Resource.MistypedTermValueError(
                                      {
                                        actualValue: value.toTerm(),
                                        expectedValueType: '"text" | "html"',
                                        focusResource: $parameters.resource,
                                        predicate:
                                          InPropertiesClass.$properties
                                            .inStringsProperty["identifier"],
                                      },
                                    ),
                                  );
                              }
                            }),
                          ),
                        )
                        .map((values) =>
                          values.length > 0
                            ? values.map((value) => purify.Maybe.of(value))
                            : rdfjsResource.Resource.Values.fromValue<
                                purify.Maybe<"text" | "html">
                              >({
                                focusResource: $parameters.resource,
                                predicate:
                                  InPropertiesClass.$properties
                                    .inStringsProperty["identifier"],
                                value: purify.Maybe.empty(),
                              }),
                        )
                        .chain((values) => values.head())
                        .map((inStringsProperty) => ({
                          $identifier,
                          inBooleansProperty,
                          inDateTimesProperty,
                          inIrisProperty,
                          inNumbersProperty,
                          inStringsProperty,
                        })),
                    ),
                ),
            ),
        ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: InPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InPropertiesClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            InPropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: InPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("inPropertiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InBooleansProperty`,
      ),
      predicate: InPropertiesClass.$properties.inBooleansProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InDateTimesProperty`,
      ),
      predicate:
        InPropertiesClass.$properties.inDateTimesProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InIrisProperty`,
      ),
      predicate: InPropertiesClass.$properties.inIrisProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InNumbersProperty`,
      ),
      predicate: InPropertiesClass.$properties.inNumbersProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InStringsProperty`,
      ),
      predicate: InPropertiesClass.$properties.inStringsProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: InPropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("inPropertiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.inBooleansProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InBooleansProperty`,
                  ),
                  predicate:
                    InPropertiesClass.$properties.inBooleansProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $BooleanFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InBooleansProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.inDateTimesProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InDateTimesProperty`,
                  ),
                  predicate:
                    InPropertiesClass.$properties.inDateTimesProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $DateFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InDateTimesProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.inIrisProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InIrisProperty`,
                  ),
                  predicate:
                    InPropertiesClass.$properties.inIrisProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $NamedNodeFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InIrisProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.inNumbersProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InNumbersProperty`,
                  ),
                  predicate:
                    InPropertiesClass.$properties.inNumbersProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $NumberFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InNumbersProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.inStringsProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InStringsProperty`,
                  ),
                  predicate:
                    InPropertiesClass.$properties.inStringsProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [parameters?.preferredLanguages ?? []]
                .filter((languages) => languages.length > 0)
                .map((languages) =>
                  languages.map((language) => ({
                    type: "operation" as const,
                    operator: "=",
                    args: [
                      {
                        type: "operation" as const,
                        operator: "lang",
                        args: [
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InStringsProperty`,
                          ),
                        ],
                      },
                      dataFactory.literal(language),
                    ],
                  })),
                )
                .map((langEqualsExpressions) => ({
                  type: "filter" as const,
                  expression: langEqualsExpressions.reduce(
                    (reducedExpression, langEqualsExpression) => {
                      if (reducedExpression === null) {
                        return langEqualsExpression;
                      }
                      return {
                        type: "operation" as const,
                        operator: "||",
                        args: [reducedExpression, langEqualsExpression],
                      };
                    },
                    null as sparqljs.Expression | null,
                  ) as sparqljs.Expression,
                }))
                .concat(),
              type: "group",
            },
            {
              patterns: $StringFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InStringsProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    return patterns;
  }

  export function isInPropertiesClass(
    object: $Object,
  ): object is InPropertiesClass {
    switch (object.$type) {
      case "InPropertiesClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Shape with sh:in constraining its identifier.
 */
export class InIdentifierClass {
  readonly $identifier: InIdentifierClass.$Identifier;
  readonly $type = "InIdentifierClass";
  readonly inIdentifierProperty: purify.Maybe<string>;

  constructor(parameters: {
    readonly $identifier:
      | "http://example.com/InIdentifierInstance1"
      | "http://example.com/InIdentifierInstance2"
      | rdfjs.NamedNode<
          | "http://example.com/InIdentifierInstance1"
          | "http://example.com/InIdentifierInstance2"
        >;
    readonly inIdentifierProperty?: purify.Maybe<string> | string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this.$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this.$identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      this.$identifier = parameters.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.inIdentifierProperty)) {
      this.inIdentifierProperty = parameters.inIdentifierProperty;
    } else if (typeof parameters.inIdentifierProperty === "string") {
      this.inIdentifierProperty = purify.Maybe.of(
        parameters.inIdentifierProperty,
      );
    } else if (typeof parameters.inIdentifierProperty === "undefined") {
      this.inIdentifierProperty = purify.Maybe.empty();
    } else {
      this.inIdentifierProperty =
        parameters.inIdentifierProperty satisfies never;
    }
  }

  $equals(other: InIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.inIdentifierProperty,
          other.inIdentifierProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inIdentifierProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.inIdentifierProperty.ifJust((value0) => {
      _hasher.update(value0);
    });
    return _hasher;
  }

  $toJson(): InIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
        inIdentifierProperty: this.inIdentifierProperty
          .map((item) => item)
          .extract(),
      } satisfies InIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      InIdentifierClass.$properties.inIdentifierProperty["identifier"],
      ...this.inIdentifierProperty.toList(),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace InIdentifierClass {
  export function $filter(
    filter: InIdentifierClass.$Filter,
    value: InIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.inIdentifierProperty !== "undefined" &&
      !$filterMaybe<string, $StringFilter>($filterString)(
        filter.inIdentifierProperty,
        value.inIdentifierProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
    readonly inIdentifierProperty?: $MaybeFilter<$StringFilter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, InIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new InIdentifierClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, InIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return InIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new InIdentifierClass(properties));
  }

  export type $Identifier = rdfjs.NamedNode<
    | "http://example.com/InIdentifierInstance1"
    | "http://example.com/InIdentifierInstance2"
  >;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<
      Error,
      rdfjs.NamedNode<
        | "http://example.com/InIdentifierInstance1"
        | "http://example.com/InIdentifierInstance2"
      >
    > {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      )
        .chain((identifier) =>
          identifier.termType === "NamedNode"
            ? purify.Either.of(identifier)
            : purify.Left(new Error("expected identifier to be NamedNode")),
        )
        .chain((identifier) => {
          switch (identifier.value) {
            case "http://example.com/InIdentifierInstance1":
              return purify.Either.of(
                identifier as rdfjs.NamedNode<"http://example.com/InIdentifierInstance1">,
              );
            case "http://example.com/InIdentifierInstance2":
              return purify.Either.of(
                identifier as rdfjs.NamedNode<"http://example.com/InIdentifierInstance2">,
              );
            default:
              return purify.Left(
                new Error(
                  "expected NamedNode identifier to be one of http://example.com/InIdentifierInstance1 http://example.com/InIdentifierInstance2",
                ),
              );
          }
        }) as purify.Either<
        Error,
        rdfjs.NamedNode<
          | "http://example.com/InIdentifierInstance1"
          | "http://example.com/InIdentifierInstance2"
        >
      >;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "InIdentifierClass";
    readonly inIdentifierProperty?: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "InIdentifierClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/inIdentifierProperty`,
          type: "Control",
        },
      ],
      label: "InIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.enum([
        "http://example.com/InIdentifierInstance1",
        "http://example.com/InIdentifierInstance2",
      ]),
      $type: zod.literal("InIdentifierClass"),
      inIdentifierProperty: zod.string().optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    inIdentifierProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/inIdentifierProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.NamedNode<
        | "http://example.com/InIdentifierInstance1"
        | "http://example.com/InIdentifierInstance2"
      >;
      inIdentifierProperty: purify.Maybe<string>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const inIdentifierProperty = purify.Maybe.fromNullable(
      $jsonObject["inIdentifierProperty"],
    );
    return purify.Either.of({ $identifier, inIdentifierProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.NamedNode<
        | "http://example.com/InIdentifierInstance1"
        | "http://example.com/InIdentifierInstance2"
      >;
      inIdentifierProperty: purify.Maybe<string>;
    }
  > {
    return (
      $parameters.resource.identifier.value ===
        "http://example.com/InIdentifierInstance1" ||
      $parameters.resource.identifier.value ===
        "http://example.com/InIdentifierInstance2"
        ? purify.Either.of<Error, InIdentifierClass.$Identifier>(
            $parameters.resource.identifier as InIdentifierClass.$Identifier,
          )
        : purify.Left(
            new rdfjsResource.Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType:
                'rdfjs.NamedNode<"http://example.com/InIdentifierInstance1" | "http://example.com/InIdentifierInstance2">',
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.inIdentifierProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              InIdentifierClass.$properties.inIdentifierProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .map((values) =>
          values.length > 0
            ? values.map((value) => purify.Maybe.of(value))
            : rdfjsResource.Resource.Values.fromValue<purify.Maybe<string>>({
                focusResource: $parameters.resource,
                predicate:
                  InIdentifierClass.$properties.inIdentifierProperty[
                    "identifier"
                  ],
                value: purify.Maybe.empty(),
              }),
        )
        .chain((values) => values.head())
        .map((inIdentifierProperty) => ({ $identifier, inIdentifierProperty })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: InIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InIdentifierClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            InIdentifierClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: InIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("inIdentifierClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inIdentifierClass")}InIdentifierProperty`,
      ),
      predicate:
        InIdentifierClass.$properties.inIdentifierProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: InIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("inIdentifierClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.inIdentifierProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inIdentifierClass")}InIdentifierProperty`,
                  ),
                  predicate:
                    InIdentifierClass.$properties.inIdentifierProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [parameters?.preferredLanguages ?? []]
                .filter((languages) => languages.length > 0)
                .map((languages) =>
                  languages.map((language) => ({
                    type: "operation" as const,
                    operator: "=",
                    args: [
                      {
                        type: "operation" as const,
                        operator: "lang",
                        args: [
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inIdentifierClass")}InIdentifierProperty`,
                          ),
                        ],
                      },
                      dataFactory.literal(language),
                    ],
                  })),
                )
                .map((langEqualsExpressions) => ({
                  type: "filter" as const,
                  expression: langEqualsExpressions.reduce(
                    (reducedExpression, langEqualsExpression) => {
                      if (reducedExpression === null) {
                        return langEqualsExpression;
                      }
                      return {
                        type: "operation" as const,
                        operator: "||",
                        args: [reducedExpression, langEqualsExpression],
                      };
                    },
                    null as sparqljs.Expression | null,
                  ) as sparqljs.Expression,
                }))
                .concat(),
              type: "group",
            },
            {
              patterns: $StringFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inIdentifierClass")}InIdentifierProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    return patterns;
  }

  export function isInIdentifierClass(
    object: $Object,
  ): object is InIdentifierClass {
    switch (object.$type) {
      case "InIdentifierClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape for testing identifier type overriding: blank node or IRI identifier, abstract
 */
export abstract class IdentifierOverride1Class {
  protected _$identifier?: IdentifierOverride1ClassStatic.$Identifier;
  abstract readonly $type:
    | "IdentifierOverride3Class"
    | "IdentifierOverride4Class"
    | "IdentifierOverride5Class";
  readonly identifierOverrideProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly identifierOverrideProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.identifierOverrideProperty = parameters.identifierOverrideProperty;
  }

  get $identifier(): IdentifierOverride1ClassStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: IdentifierOverride1Class): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.identifierOverrideProperty,
          other.identifierOverrideProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "identifierOverrideProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.identifierOverrideProperty);
    return _hasher;
  }

  $toJson(): IdentifierOverride1ClassStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        identifierOverrideProperty: this.identifierOverrideProperty,
      } satisfies IdentifierOverride1ClassStatic.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      IdentifierOverride1ClassStatic.$properties.identifierOverrideProperty[
        "identifier"
      ],
      ...[this.identifierOverrideProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IdentifierOverride1ClassStatic {
  export function $filter(
    filter: IdentifierOverride1ClassStatic.$Filter,
    value: IdentifierOverride1Class,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.identifierOverrideProperty !== "undefined" &&
      !$filterString(
        filter.identifierOverrideProperty,
        value.identifierOverrideProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly identifierOverrideProperty?: $StringFilter;
  };
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type:
      | "IdentifierOverride3Class"
      | "IdentifierOverride4Class"
      | "IdentifierOverride5Class";
    readonly identifierOverrideProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "IdentifierOverride1Class" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/identifierOverrideProperty`,
          type: "Control",
        },
      ],
      label: "IdentifierOverride1Class",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.enum([
        "IdentifierOverride3Class",
        "IdentifierOverride4Class",
        "IdentifierOverride5Class",
      ]),
      identifierOverrideProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    identifierOverrideProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/identifierOverrideProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      identifierOverrideProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const identifierOverrideProperty =
      $jsonObject["identifierOverrideProperty"];
    return purify.Either.of({ $identifier, identifierOverrideProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      identifierOverrideProperty: string;
    }
  > {
    return purify.Either.of<Error, IdentifierOverride1ClassStatic.$Identifier>(
      $parameters.resource
        .identifier as IdentifierOverride1ClassStatic.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.identifierOverrideProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              IdentifierOverride1ClassStatic.$properties
                .identifierOverrideProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((identifierOverrideProperty) => ({
          $identifier,
          identifierOverrideProperty,
        })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IdentifierOverride1ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IdentifierOverride1ClassStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            IdentifierOverride1ClassStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IdentifierOverride1ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IdentifierOverride1ClassStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride1Class");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride1Class")}IdentifierOverrideProperty`,
      ),
      predicate:
        IdentifierOverride1ClassStatic.$properties.identifierOverrideProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IdentifierOverride1ClassStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride1Class");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride1Class")}IdentifierOverrideProperty`,
            ),
            predicate:
              IdentifierOverride1ClassStatic.$properties
                .identifierOverrideProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride1Class")}IdentifierOverrideProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.identifierOverrideProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride1Class")}IdentifierOverrideProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isIdentifierOverride1Class(
    object: $Object,
  ): object is IdentifierOverride1Class {
    switch (object.$type) {
      case "IdentifierOverride3Class":
      case "IdentifierOverride4Class":
      case "IdentifierOverride5Class":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape for testing identifier type overriding: blank node or IRI identifier, abstract
 */
export abstract class IdentifierOverride2Class extends IdentifierOverride1Class {
  abstract override readonly $type:
    | "IdentifierOverride3Class"
    | "IdentifierOverride4Class"
    | "IdentifierOverride5Class";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: ConstructorParameters<typeof IdentifierOverride1Class>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): IdentifierOverride2ClassStatic.$Identifier {
    const identifier = super.$identifier;
    if (identifier.termType !== "NamedNode") {
      throw new Error(
        `expected identifier to be NamedNode, not ${identifier.termType}`,
      );
    }

    return identifier;
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IdentifierOverride2ClassStatic {
  export function $filter(
    filter: IdentifierOverride2ClassStatic.$Filter,
    value: IdentifierOverride2Class,
  ): boolean {
    if (!IdentifierOverride1ClassStatic.$filter(filter, value)) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
  } & IdentifierOverride1ClassStatic.$Filter;
  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = IdentifierOverride1ClassStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [IdentifierOverride1ClassStatic.$jsonUiSchema({ scopePrefix })],
      label: "IdentifierOverride2Class",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IdentifierOverride1ClassStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "IdentifierOverride3Class",
          "IdentifierOverride4Class",
          "IdentifierOverride5Class",
        ]),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = { ...IdentifierOverride1ClassStatic.$properties };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride1ClassStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    return IdentifierOverride1ClassStatic.$propertiesFromJson($jsonObject).map(
      ($super0) => ({ ...$super0, $identifier }),
    );
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride1ClassStatic.$propertiesFromRdf>
    >
  > {
    return IdentifierOverride1ClassStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      ($parameters.resource.identifier.termType === "NamedNode"
        ? purify.Either.of<Error, IdentifierOverride2ClassStatic.$Identifier>(
            $parameters.resource.identifier,
          )
        : purify.Left(
            new rdfjsResource.Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "(rdfjs.NamedNode)",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
      ).map(($identifier) => ({ ...$super0, $identifier })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IdentifierOverride2ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IdentifierOverride2ClassStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            IdentifierOverride2ClassStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IdentifierOverride2ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IdentifierOverride2ClassStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride2Class");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...IdentifierOverride1ClassStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride2Class"),
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IdentifierOverride2ClassStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride2Class");
    patterns.push(
      ...IdentifierOverride1ClassStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride2Class"),
      }),
    );
    return patterns;
  }

  export function isIdentifierOverride2Class(
    object: $Object,
  ): object is IdentifierOverride2Class {
    switch (object.$type) {
      case "IdentifierOverride3Class":
      case "IdentifierOverride4Class":
      case "IdentifierOverride5Class":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape for testing identifier type overriding: IRI identifier, concrete
 */
export class IdentifierOverride3Class extends IdentifierOverride2Class {
  override readonly $type:
    | "IdentifierOverride3Class"
    | "IdentifierOverride4Class"
    | "IdentifierOverride5Class" = "IdentifierOverride3Class";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof IdentifierOverride2Class>[0],
  ) {
    super(parameters);
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/IdentifierOverride3Class",
        ),
      );
    }

    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IdentifierOverride3ClassStatic {
  export function $filter(
    filter: IdentifierOverride3ClassStatic.$Filter,
    value: IdentifierOverride3Class,
  ): boolean {
    if (!IdentifierOverride2ClassStatic.$filter(filter, value)) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
  } & IdentifierOverride2ClassStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, IdentifierOverride3Class> {
    return $propertiesFromJson(json).map(
      (properties) => new IdentifierOverride3Class(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, IdentifierOverride3Class> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return IdentifierOverride3ClassStatic.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new IdentifierOverride3Class(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/IdentifierOverride3Class",
  );
  export type $Identifier = IdentifierOverride2ClassStatic.$Identifier;
  export const $Identifier = IdentifierOverride2ClassStatic.$Identifier;
  export type $Json = IdentifierOverride2ClassStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [IdentifierOverride2ClassStatic.$jsonUiSchema({ scopePrefix })],
      label: "IdentifierOverride3Class",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IdentifierOverride2ClassStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "IdentifierOverride3Class",
          "IdentifierOverride4Class",
          "IdentifierOverride5Class",
        ]),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = { ...IdentifierOverride2ClassStatic.$properties };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride2ClassStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    return IdentifierOverride2ClassStatic.$propertiesFromJson($jsonObject).map(
      ($super0) => ({ ...$super0, $identifier }),
    );
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride2ClassStatic.$propertiesFromRdf>
    >
  > {
    return IdentifierOverride2ClassStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/IdentifierOverride3Class":
                case "http://example.com/IdentifierOverride4Class":
                case "http://example.com/IdentifierOverride5Class":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  IdentifierOverride3ClassStatic.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/IdentifierOverride3Class)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        ($parameters.resource.identifier.termType === "NamedNode"
          ? purify.Either.of<Error, IdentifierOverride3ClassStatic.$Identifier>(
              $parameters.resource.identifier,
            )
          : purify.Left(
              new rdfjsResource.Resource.MistypedTermValueError({
                actualValue: $parameters.resource.identifier,
                expectedValueType: "(rdfjs.NamedNode)",
                focusResource: $parameters.resource,
                predicate: $RdfVocabularies.rdf.subject,
              }),
            )
        ).map(($identifier) => ({ ...$super0, $identifier })),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IdentifierOverride3ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IdentifierOverride3ClassStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            IdentifierOverride3ClassStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IdentifierOverride3ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IdentifierOverride3ClassStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride3Class");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...IdentifierOverride2ClassStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride3Class"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride3Class")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride3Class")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride3Class")}RdfClass`,
          ),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IdentifierOverride3ClassStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride3Class");
    patterns.push(
      ...IdentifierOverride2ClassStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride3Class"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride3Class")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        {
          type: "values" as const,
          values: [
            IdentifierOverride3ClassStatic.$fromRdfType,
            IdentifierOverride4ClassStatic.$fromRdfType,
            IdentifierOverride5Class.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[
              `?${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride3Class")}FromRdfType`
            ] = identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride3Class")}FromRdfType`,
          ),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride3Class")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    return patterns;
  }

  export function isIdentifierOverride3Class(
    object: $Object,
  ): object is IdentifierOverride3Class {
    switch (object.$type) {
      case "IdentifierOverride4Class":
      case "IdentifierOverride5Class":
      case "IdentifierOverride3Class":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape for testing identifier type overriding: IRI identifier, concrete, UUIDv4 minting
 */
export class IdentifierOverride4Class extends IdentifierOverride3Class {
  protected readonly _$identifierPrefix?: string;
  override readonly $type:
    | "IdentifierOverride4Class"
    | "IdentifierOverride5Class" = "IdentifierOverride4Class";

  constructor(
    parameters: {
      readonly $identifier?: rdfjs.NamedNode | string;
      readonly $identifierPrefix?: string;
    } & ConstructorParameters<typeof IdentifierOverride3Class>[0],
  ) {
    super(parameters);
    this._$identifierPrefix = parameters.$identifierPrefix;
  }

  override get $identifier(): IdentifierOverride4ClassStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${uuid.v4()}`,
      );
    }

    if (this._$identifier.termType !== "NamedNode") {
      throw new Error(
        `expected identifier to be NamedNode, not ${this._$identifier.termType}`,
      );
    }

    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/IdentifierOverride4Class",
        ),
      );
    }

    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IdentifierOverride4ClassStatic {
  export function $filter(
    filter: IdentifierOverride4ClassStatic.$Filter,
    value: IdentifierOverride4Class,
  ): boolean {
    if (!IdentifierOverride3ClassStatic.$filter(filter, value)) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
  } & IdentifierOverride3ClassStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, IdentifierOverride4Class> {
    return $propertiesFromJson(json).map(
      (properties) => new IdentifierOverride4Class(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, IdentifierOverride4Class> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return IdentifierOverride4ClassStatic.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new IdentifierOverride4Class(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/IdentifierOverride4Class",
  );
  export type $Identifier = IdentifierOverride3ClassStatic.$Identifier;
  export const $Identifier = IdentifierOverride3ClassStatic.$Identifier;
  export type $Json = IdentifierOverride3ClassStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [IdentifierOverride3ClassStatic.$jsonUiSchema({ scopePrefix })],
      label: "IdentifierOverride4Class",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IdentifierOverride3ClassStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "IdentifierOverride4Class",
          "IdentifierOverride5Class",
        ]),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = { ...IdentifierOverride3ClassStatic.$properties };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride3ClassStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    return IdentifierOverride3ClassStatic.$propertiesFromJson($jsonObject).map(
      ($super0) => ({ ...$super0, $identifier }),
    );
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride3ClassStatic.$propertiesFromRdf>
    >
  > {
    return IdentifierOverride3ClassStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/IdentifierOverride4Class":
                case "http://example.com/IdentifierOverride5Class":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  IdentifierOverride4ClassStatic.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/IdentifierOverride4Class)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        ($parameters.resource.identifier.termType === "NamedNode"
          ? purify.Either.of<Error, IdentifierOverride4ClassStatic.$Identifier>(
              $parameters.resource.identifier,
            )
          : purify.Left(
              new rdfjsResource.Resource.MistypedTermValueError({
                actualValue: $parameters.resource.identifier,
                expectedValueType: "(rdfjs.NamedNode)",
                focusResource: $parameters.resource,
                predicate: $RdfVocabularies.rdf.subject,
              }),
            )
        ).map(($identifier) => ({ ...$super0, $identifier })),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IdentifierOverride4ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IdentifierOverride4ClassStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            IdentifierOverride4ClassStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IdentifierOverride4ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IdentifierOverride4ClassStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride4Class");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...IdentifierOverride3ClassStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride4Class"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride4Class")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride4Class")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride4Class")}RdfClass`,
          ),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IdentifierOverride4ClassStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride4Class");
    patterns.push(
      ...IdentifierOverride3ClassStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride4Class"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride4Class")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        {
          type: "values" as const,
          values: [
            IdentifierOverride4ClassStatic.$fromRdfType,
            IdentifierOverride5Class.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[
              `?${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride4Class")}FromRdfType`
            ] = identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride4Class")}FromRdfType`,
          ),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride4Class")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    return patterns;
  }

  export function isIdentifierOverride4Class(
    object: $Object,
  ): object is IdentifierOverride4Class {
    switch (object.$type) {
      case "IdentifierOverride5Class":
      case "IdentifierOverride4Class":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape for testing identifier type overriding: IRI identifier, concrete, SHA-256 minting
 */
export class IdentifierOverride5Class extends IdentifierOverride4Class {
  override readonly $type = "IdentifierOverride5Class";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: rdfjs.NamedNode | string;
      readonly $identifierPrefix?: string;
    } & ConstructorParameters<typeof IdentifierOverride4Class>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): IdentifierOverride5Class.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }

    if (this._$identifier.termType !== "NamedNode") {
      throw new Error(
        `expected identifier to be NamedNode, not ${this._$identifier.termType}`,
      );
    }

    return this._$identifier;
  }

  protected override get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/IdentifierOverride5Class",
        ),
      );
    }

    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IdentifierOverride5Class {
  export function $filter(
    filter: IdentifierOverride5Class.$Filter,
    value: IdentifierOverride5Class,
  ): boolean {
    if (!IdentifierOverride4ClassStatic.$filter(filter, value)) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
  } & IdentifierOverride4ClassStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, IdentifierOverride5Class> {
    return $propertiesFromJson(json).map(
      (properties) => new IdentifierOverride5Class(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, IdentifierOverride5Class> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return IdentifierOverride5Class.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new IdentifierOverride5Class(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/IdentifierOverride5Class",
  );
  export type $Identifier = IdentifierOverride4ClassStatic.$Identifier;
  export const $Identifier = IdentifierOverride4ClassStatic.$Identifier;
  export type $Json = IdentifierOverride4ClassStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [IdentifierOverride4ClassStatic.$jsonUiSchema({ scopePrefix })],
      label: "IdentifierOverride5Class",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IdentifierOverride4ClassStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("IdentifierOverride5Class"),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = { ...IdentifierOverride4ClassStatic.$properties };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride4ClassStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    return IdentifierOverride4ClassStatic.$propertiesFromJson($jsonObject).map(
      ($super0) => ({ ...$super0, $identifier }),
    );
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride4ClassStatic.$propertiesFromRdf>
    >
  > {
    return IdentifierOverride4ClassStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/IdentifierOverride5Class":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  IdentifierOverride5Class.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/IdentifierOverride5Class)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        ($parameters.resource.identifier.termType === "NamedNode"
          ? purify.Either.of<Error, IdentifierOverride5Class.$Identifier>(
              $parameters.resource.identifier,
            )
          : purify.Left(
              new rdfjsResource.Resource.MistypedTermValueError({
                actualValue: $parameters.resource.identifier,
                expectedValueType: "(rdfjs.NamedNode)",
                focusResource: $parameters.resource,
                predicate: $RdfVocabularies.rdf.subject,
              }),
            )
        ).map(($identifier) => ({ ...$super0, $identifier })),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IdentifierOverride5Class.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IdentifierOverride5Class.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            IdentifierOverride5Class.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IdentifierOverride5Class.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IdentifierOverride5Class.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride5Class");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...IdentifierOverride4ClassStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride5Class"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride5Class")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride5Class")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride5Class")}RdfClass`,
          ),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IdentifierOverride5Class.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride5Class");
    patterns.push(
      ...IdentifierOverride4ClassStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride5Class"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride5Class")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: IdentifierOverride5Class.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride5Class")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    return patterns;
  }

  export function isIdentifierOverride5Class(
    object: $Object,
  ): object is IdentifierOverride5Class {
    switch (object.$type) {
      case "IdentifierOverride5Class":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Shape with sh:hasValue properties.
 */
export class HasValuePropertiesClass {
  private _$identifier?: HasValuePropertiesClass.$Identifier;
  readonly $type = "HasValuePropertiesClass";
  readonly hasIriValueProperty: rdfjs.NamedNode;
  readonly hasLiteralValueProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly hasIriValueProperty: rdfjs.NamedNode | string;
    readonly hasLiteralValueProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    if (typeof parameters.hasIriValueProperty === "object") {
      this.hasIriValueProperty = parameters.hasIriValueProperty;
    } else if (typeof parameters.hasIriValueProperty === "string") {
      this.hasIriValueProperty = dataFactory.namedNode(
        parameters.hasIriValueProperty,
      );
    } else {
      this.hasIriValueProperty = parameters.hasIriValueProperty satisfies never;
    }

    this.hasLiteralValueProperty = parameters.hasLiteralValueProperty;
  }

  get $identifier(): HasValuePropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: HasValuePropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $booleanEquals(
          this.hasIriValueProperty,
          other.hasIriValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "hasIriValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.hasLiteralValueProperty,
          other.hasLiteralValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "hasLiteralValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.hasIriValueProperty.termType);
    _hasher.update(this.hasIriValueProperty.value);
    _hasher.update(this.hasLiteralValueProperty);
    return _hasher;
  }

  $toJson(): HasValuePropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        hasIriValueProperty: { "@id": this.hasIriValueProperty.value },
        hasLiteralValueProperty: this.hasLiteralValueProperty,
      } satisfies HasValuePropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      HasValuePropertiesClass.$properties.hasIriValueProperty["identifier"],
      ...[this.hasIriValueProperty],
    );
    resource.add(
      HasValuePropertiesClass.$properties.hasLiteralValueProperty["identifier"],
      ...[this.hasLiteralValueProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace HasValuePropertiesClass {
  export function $filter(
    filter: HasValuePropertiesClass.$Filter,
    value: HasValuePropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.hasIriValueProperty !== "undefined" &&
      !$filterNamedNode(filter.hasIriValueProperty, value.hasIriValueProperty)
    ) {
      return false;
    }

    if (
      typeof filter.hasLiteralValueProperty !== "undefined" &&
      !$filterString(
        filter.hasLiteralValueProperty,
        value.hasLiteralValueProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly hasIriValueProperty?: $NamedNodeFilter;
    readonly hasLiteralValueProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, HasValuePropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new HasValuePropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, HasValuePropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return HasValuePropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new HasValuePropertiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "HasValuePropertiesClass";
    readonly hasIriValueProperty: { readonly "@id": string };
    readonly hasLiteralValueProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "HasValuePropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/hasIriValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/hasLiteralValueProperty`,
          type: "Control",
        },
      ],
      label: "HasValuePropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("HasValuePropertiesClass"),
      hasIriValueProperty: zod.object({ "@id": zod.string().min(1) }),
      hasLiteralValueProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    hasIriValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/hasIriValueProperty",
      ),
    },
    hasLiteralValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/hasLiteralValueProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      hasIriValueProperty: rdfjs.NamedNode;
      hasLiteralValueProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const hasIriValueProperty = dataFactory.namedNode(
      $jsonObject["hasIriValueProperty"]["@id"],
    );
    const hasLiteralValueProperty = $jsonObject["hasLiteralValueProperty"];
    return purify.Either.of({
      $identifier,
      hasIriValueProperty,
      hasLiteralValueProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      hasIriValueProperty: rdfjs.NamedNode;
      hasLiteralValueProperty: string;
    }
  > {
    return purify.Either.of<Error, HasValuePropertiesClass.$Identifier>(
      $parameters.resource.identifier as HasValuePropertiesClass.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.hasIriValueProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          purify.Either.sequence(
            [
              dataFactory.namedNode(
                "http://example.com/HasValuePropertiesClassIri1",
              ),
            ].map((hasValue) =>
              values.find((value) => value.toTerm().equals(hasValue)),
            ),
          ).map(() => values),
        )
        .chain((values) => values.chainMap((value) => value.toIri()))
        .chain((values) => values.head())
        .chain((hasIriValueProperty) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.hasLiteralValueProperty["identifier"],
              { unique: true },
            ),
          )
            .chain((values) =>
              purify.Either.sequence(
                [dataFactory.literal("test")].map((hasValue) =>
                  values.find((value) => value.toTerm().equals(hasValue)),
                ),
              ).map(() => values),
            )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  HasValuePropertiesClass.$properties.hasLiteralValueProperty[
                    "identifier"
                  ],
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((hasLiteralValueProperty) => ({
              $identifier,
              hasIriValueProperty,
              hasLiteralValueProperty,
            })),
        ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: HasValuePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        HasValuePropertiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            HasValuePropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: HasValuePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      HasValuePropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("hasValuePropertiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "hasValuePropertiesClass")}HasIriValueProperty`,
      ),
      predicate:
        HasValuePropertiesClass.$properties.hasIriValueProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "hasValuePropertiesClass")}HasLiteralValueProperty`,
      ),
      predicate:
        HasValuePropertiesClass.$properties.hasLiteralValueProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: HasValuePropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("hasValuePropertiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "hasValuePropertiesClass")}HasIriValueProperty`,
            ),
            predicate:
              HasValuePropertiesClass.$properties.hasIriValueProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(
            parameters?.filter?.hasIriValueProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "hasValuePropertiesClass")}HasIriValueProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "hasValuePropertiesClass")}HasLiteralValueProperty`,
            ),
            predicate:
              HasValuePropertiesClass.$properties.hasLiteralValueProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "hasValuePropertiesClass")}HasLiteralValueProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.hasLiteralValueProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "hasValuePropertiesClass")}HasLiteralValueProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isHasValuePropertiesClass(
    object: $Object,
  ): object is HasValuePropertiesClass {
    switch (object.$type) {
      case "HasValuePropertiesClass":
        return true;
      default:
        return false;
    }
  }
}
export class FlattenClassUnionMember3 {
  private _$identifier?: FlattenClassUnionMember3.$Identifier;
  readonly $type = "FlattenClassUnionMember3";
  readonly flattenClassUnionMember3Property: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly flattenClassUnionMember3Property: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.flattenClassUnionMember3Property =
      parameters.flattenClassUnionMember3Property;
  }

  get $identifier(): FlattenClassUnionMember3.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: FlattenClassUnionMember3): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.flattenClassUnionMember3Property,
          other.flattenClassUnionMember3Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "flattenClassUnionMember3Property",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.flattenClassUnionMember3Property);
    return _hasher;
  }

  $toJson(): FlattenClassUnionMember3.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        flattenClassUnionMember3Property: this.flattenClassUnionMember3Property,
      } satisfies FlattenClassUnionMember3.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/FlattenClassUnionMember3",
        ),
      );
    }

    resource.add(
      FlattenClassUnionMember3.$properties.flattenClassUnionMember3Property[
        "identifier"
      ],
      ...[this.flattenClassUnionMember3Property],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace FlattenClassUnionMember3 {
  export function $filter(
    filter: FlattenClassUnionMember3.$Filter,
    value: FlattenClassUnionMember3,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.flattenClassUnionMember3Property !== "undefined" &&
      !$filterString(
        filter.flattenClassUnionMember3Property,
        value.flattenClassUnionMember3Property,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly flattenClassUnionMember3Property?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, FlattenClassUnionMember3> {
    return $propertiesFromJson(json).map(
      (properties) => new FlattenClassUnionMember3(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, FlattenClassUnionMember3> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return FlattenClassUnionMember3.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new FlattenClassUnionMember3(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/FlattenClassUnionMember3",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "FlattenClassUnionMember3";
    readonly flattenClassUnionMember3Property: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "FlattenClassUnionMember3" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/flattenClassUnionMember3Property`,
          type: "Control",
        },
      ],
      label: "FlattenClassUnionMember3",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("FlattenClassUnionMember3"),
      flattenClassUnionMember3Property: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    flattenClassUnionMember3Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/flattenClassUnionMember3Property",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      flattenClassUnionMember3Property: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const flattenClassUnionMember3Property =
      $jsonObject["flattenClassUnionMember3Property"];
    return purify.Either.of({ $identifier, flattenClassUnionMember3Property });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      flattenClassUnionMember3Property: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/FlattenClassUnionMember3":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  FlattenClassUnionMember3.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/FlattenClassUnionMember3)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      purify.Either.of<Error, FlattenClassUnionMember3.$Identifier>(
        $parameters.resource.identifier as FlattenClassUnionMember3.$Identifier,
      ).chain(($identifier) =>
        purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
        >(
          $parameters.resource.values(
            $properties.flattenClassUnionMember3Property["identifier"],
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                FlattenClassUnionMember3.$properties
                  .flattenClassUnionMember3Property["identifier"],
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((flattenClassUnionMember3Property) => ({
            $identifier,
            flattenClassUnionMember3Property,
          })),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: FlattenClassUnionMember3.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        FlattenClassUnionMember3.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            FlattenClassUnionMember3.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: FlattenClassUnionMember3.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      FlattenClassUnionMember3.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("flattenClassUnionMember3");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "flattenClassUnionMember3")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "flattenClassUnionMember3")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "flattenClassUnionMember3")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "flattenClassUnionMember3")}FlattenClassUnionMember3Property`,
      ),
      predicate:
        FlattenClassUnionMember3.$properties.flattenClassUnionMember3Property[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: FlattenClassUnionMember3.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("flattenClassUnionMember3");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "flattenClassUnionMember3")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: FlattenClassUnionMember3.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "flattenClassUnionMember3")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "flattenClassUnionMember3")}FlattenClassUnionMember3Property`,
            ),
            predicate:
              FlattenClassUnionMember3.$properties
                .flattenClassUnionMember3Property["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "flattenClassUnionMember3")}FlattenClassUnionMember3Property`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.flattenClassUnionMember3Property,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "flattenClassUnionMember3")}FlattenClassUnionMember3Property`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isFlattenClassUnionMember3(
    object: $Object,
  ): object is FlattenClassUnionMember3 {
    switch (object.$type) {
      case "FlattenClassUnionMember3":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape that references the ExternClass in a property.
 */
export class ExternClassPropertyClass {
  private _$identifier?: ExternClassPropertyClass.$Identifier;
  readonly $type = "ExternClassPropertyClass";
  readonly externClassProperty: purify.Maybe<ExternClass>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly externClassProperty?: ExternClass | purify.Maybe<ExternClass>;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.externClassProperty)) {
      this.externClassProperty = parameters?.externClassProperty;
    } else if (
      typeof parameters?.externClassProperty === "object" &&
      parameters?.externClassProperty instanceof ExternClass
    ) {
      this.externClassProperty = purify.Maybe.of(
        parameters?.externClassProperty,
      );
    } else if (typeof parameters?.externClassProperty === "undefined") {
      this.externClassProperty = purify.Maybe.empty();
    } else {
      this.externClassProperty =
        parameters?.externClassProperty satisfies never;
    }
  }

  get $identifier(): ExternClassPropertyClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: ExternClassPropertyClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.externClassProperty,
          other.externClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "externClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.externClassProperty.ifJust((value0) => {
      value0.$hash(_hasher);
    });
    return _hasher;
  }

  $toJson(): ExternClassPropertyClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        externClassProperty: this.externClassProperty
          .map((item) => item.$toJson())
          .extract(),
      } satisfies ExternClassPropertyClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      ExternClassPropertyClass.$properties.externClassProperty["identifier"],
      ...this.externClassProperty
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ExternClassPropertyClass {
  export function $filter(
    filter: ExternClassPropertyClass.$Filter,
    value: ExternClassPropertyClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.externClassProperty !== "undefined" &&
      !$filterMaybe<ExternClass, ExternClass.$Filter>(ExternClass.$filter)(
        filter.externClassProperty,
        value.externClassProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly externClassProperty?: $MaybeFilter<ExternClass.$Filter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ExternClassPropertyClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ExternClassPropertyClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ExternClassPropertyClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ExternClassPropertyClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ExternClassPropertyClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ExternClassPropertyClass";
    readonly externClassProperty?: ExternClass.$Json;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ExternClassPropertyClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        ExternClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/externClassProperty`,
        }),
      ],
      label: "ExternClassPropertyClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("ExternClassPropertyClass"),
      externClassProperty: ExternClass.$jsonZodSchema().optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    externClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/externClassProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      externClassProperty: purify.Maybe<ExternClass>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const externClassProperty = purify.Maybe.fromNullable(
      $jsonObject["externClassProperty"],
    ).map((item) => ExternClass.$fromJson(item).unsafeCoerce());
    return purify.Either.of({ $identifier, externClassProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      externClassProperty: purify.Maybe<ExternClass>;
    }
  > {
    return purify.Either.of<Error, ExternClassPropertyClass.$Identifier>(
      $parameters.resource.identifier as ExternClassPropertyClass.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.externClassProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          values.chainMap((value) =>
            value.toResource().chain((resource) =>
              ExternClass.$fromRdf(resource, {
                context: $parameters.context,
                ignoreRdfType: true,
                objectSet: $parameters.objectSet,
                preferredLanguages: $parameters.preferredLanguages,
              }),
            ),
          ),
        )
        .map((values) =>
          values.length > 0
            ? values.map((value) => purify.Maybe.of(value))
            : rdfjsResource.Resource.Values.fromValue<
                purify.Maybe<ExternClass>
              >({
                focusResource: $parameters.resource,
                predicate:
                  ExternClassPropertyClass.$properties.externClassProperty[
                    "identifier"
                  ],
                value: purify.Maybe.empty(),
              }),
        )
        .chain((values) => values.head())
        .map((externClassProperty) => ({ $identifier, externClassProperty })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ExternClassPropertyClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ExternClassPropertyClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ExternClassPropertyClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ExternClassPropertyClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ExternClassPropertyClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("externClassPropertyClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "externClassPropertyClass")}ExternClassProperty`,
      ),
      predicate:
        ExternClassPropertyClass.$properties.externClassProperty["identifier"],
      subject,
    });
    triples.push(
      ...ExternClass.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "externClassPropertyClass")}ExternClassProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "externClassPropertyClass")}ExternClassProperty`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ExternClassPropertyClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("externClassPropertyClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.externClassProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "externClassPropertyClass")}ExternClassProperty`,
                  ),
                  predicate:
                    ExternClassPropertyClass.$properties.externClassProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: ExternClass.$sparqlWherePatterns({
                filter: itemFilter,
                ignoreRdfType: true,
                preferredLanguages: parameters?.preferredLanguages,
                subject: dataFactory.variable!(
                  `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "externClassPropertyClass")}ExternClassProperty`,
                ),
                variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "externClassPropertyClass")}ExternClassProperty`,
              }).concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    return patterns;
  }

  export function isExternClassPropertyClass(
    object: $Object,
  ): object is ExternClassPropertyClass {
    switch (object.$type) {
      case "ExternClassPropertyClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * An abstract base class that will be inherited by the extern object type, showing how to mix generated and hand-written code.
 */
export abstract class AbstractBaseClassForExternClass {
  protected _$identifier?: AbstractBaseClassForExternClassStatic.$Identifier;
  abstract readonly $type: "ExternClass";
  readonly abstractBaseClassForExternClassProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly abstractBaseClassForExternClassProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.abstractBaseClassForExternClassProperty =
      parameters.abstractBaseClassForExternClassProperty;
  }

  get $identifier(): AbstractBaseClassForExternClassStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: AbstractBaseClassForExternClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.abstractBaseClassForExternClassProperty,
          other.abstractBaseClassForExternClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "abstractBaseClassForExternClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.abstractBaseClassForExternClassProperty);
    return _hasher;
  }

  $toJson(): AbstractBaseClassForExternClassStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        abstractBaseClassForExternClassProperty:
          this.abstractBaseClassForExternClassProperty,
      } satisfies AbstractBaseClassForExternClassStatic.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      AbstractBaseClassForExternClassStatic.$properties
        .abstractBaseClassForExternClassProperty["identifier"],
      ...[this.abstractBaseClassForExternClassProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace AbstractBaseClassForExternClassStatic {
  export function $filter(
    filter: AbstractBaseClassForExternClassStatic.$Filter,
    value: AbstractBaseClassForExternClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.abstractBaseClassForExternClassProperty !== "undefined" &&
      !$filterString(
        filter.abstractBaseClassForExternClassProperty,
        value.abstractBaseClassForExternClassProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly abstractBaseClassForExternClassProperty?: $StringFilter;
  };
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ExternClass";
    readonly abstractBaseClassForExternClassProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "AbstractBaseClassForExternClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/abstractBaseClassForExternClassProperty`,
          type: "Control",
        },
      ],
      label: "AbstractBaseClassForExternClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("ExternClass"),
      abstractBaseClassForExternClassProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    abstractBaseClassForExternClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/abstractBaseClassForExternClassProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      abstractBaseClassForExternClassProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const abstractBaseClassForExternClassProperty =
      $jsonObject["abstractBaseClassForExternClassProperty"];
    return purify.Either.of({
      $identifier,
      abstractBaseClassForExternClassProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      abstractBaseClassForExternClassProperty: string;
    }
  > {
    return purify.Either.of<
      Error,
      AbstractBaseClassForExternClassStatic.$Identifier
    >(
      $parameters.resource
        .identifier as AbstractBaseClassForExternClassStatic.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.abstractBaseClassForExternClassProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              AbstractBaseClassForExternClassStatic.$properties
                .abstractBaseClassForExternClassProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((abstractBaseClassForExternClassProperty) => ({
          $identifier,
          abstractBaseClassForExternClassProperty,
        })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: AbstractBaseClassForExternClassStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        AbstractBaseClassForExternClassStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            AbstractBaseClassForExternClassStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: AbstractBaseClassForExternClassStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      AbstractBaseClassForExternClassStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassForExternClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "abstractBaseClassForExternClass")}AbstractBaseClassForExternClassProperty`,
      ),
      predicate:
        AbstractBaseClassForExternClassStatic.$properties
          .abstractBaseClassForExternClassProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: AbstractBaseClassForExternClassStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassForExternClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "abstractBaseClassForExternClass")}AbstractBaseClassForExternClassProperty`,
            ),
            predicate:
              AbstractBaseClassForExternClassStatic.$properties
                .abstractBaseClassForExternClassProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "abstractBaseClassForExternClass")}AbstractBaseClassForExternClassProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.abstractBaseClassForExternClassProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "abstractBaseClassForExternClass")}AbstractBaseClassForExternClassProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isAbstractBaseClassForExternClass(
    object: $Object,
  ): object is AbstractBaseClassForExternClass {
    switch (object.$type) {
      case "ExternClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Shape with custom rdf:type's.
 *
 * The shaclmate:rdfType is expected on deserialization and added on serialization.
 */
export class ExplicitRdfTypeClass {
  private _$identifier?: ExplicitRdfTypeClass.$Identifier;
  readonly $type = "ExplicitRdfTypeClass";
  readonly explicitRdfTypeProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly explicitRdfTypeProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.explicitRdfTypeProperty = parameters.explicitRdfTypeProperty;
  }

  get $identifier(): ExplicitRdfTypeClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: ExplicitRdfTypeClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.explicitRdfTypeProperty,
          other.explicitRdfTypeProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "explicitRdfTypeProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.explicitRdfTypeProperty);
    return _hasher;
  }

  $toJson(): ExplicitRdfTypeClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        explicitRdfTypeProperty: this.explicitRdfTypeProperty,
      } satisfies ExplicitRdfTypeClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode("http://example.com/RdfType"),
      );
    }

    resource.add(
      ExplicitRdfTypeClass.$properties.explicitRdfTypeProperty["identifier"],
      ...[this.explicitRdfTypeProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ExplicitRdfTypeClass {
  export function $filter(
    filter: ExplicitRdfTypeClass.$Filter,
    value: ExplicitRdfTypeClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.explicitRdfTypeProperty !== "undefined" &&
      !$filterString(
        filter.explicitRdfTypeProperty,
        value.explicitRdfTypeProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly explicitRdfTypeProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ExplicitRdfTypeClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ExplicitRdfTypeClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ExplicitRdfTypeClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ExplicitRdfTypeClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ExplicitRdfTypeClass(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/RdfType",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ExplicitRdfTypeClass";
    readonly explicitRdfTypeProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ExplicitRdfTypeClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/explicitRdfTypeProperty`,
          type: "Control",
        },
      ],
      label: "ExplicitRdfTypeClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("ExplicitRdfTypeClass"),
      explicitRdfTypeProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    explicitRdfTypeProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/explicitRdfTypeProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      explicitRdfTypeProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const explicitRdfTypeProperty = $jsonObject["explicitRdfTypeProperty"];
    return purify.Either.of({ $identifier, explicitRdfTypeProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      explicitRdfTypeProperty: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/RdfType":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  ExplicitRdfTypeClass.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/RdfType)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      purify.Either.of<Error, ExplicitRdfTypeClass.$Identifier>(
        $parameters.resource.identifier as ExplicitRdfTypeClass.$Identifier,
      ).chain(($identifier) =>
        purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
        >(
          $parameters.resource.values(
            $properties.explicitRdfTypeProperty["identifier"],
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                ExplicitRdfTypeClass.$properties.explicitRdfTypeProperty[
                  "identifier"
                ],
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((explicitRdfTypeProperty) => ({
            $identifier,
            explicitRdfTypeProperty,
          })),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ExplicitRdfTypeClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ExplicitRdfTypeClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ExplicitRdfTypeClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ExplicitRdfTypeClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ExplicitRdfTypeClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("explicitRdfTypeClass");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitRdfTypeClass")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitRdfTypeClass")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitRdfTypeClass")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitRdfTypeClass")}ExplicitRdfTypeProperty`,
      ),
      predicate:
        ExplicitRdfTypeClass.$properties.explicitRdfTypeProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ExplicitRdfTypeClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("explicitRdfTypeClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitRdfTypeClass")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ExplicitRdfTypeClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitRdfTypeClass")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitRdfTypeClass")}ExplicitRdfTypeProperty`,
            ),
            predicate:
              ExplicitRdfTypeClass.$properties.explicitRdfTypeProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitRdfTypeClass")}ExplicitRdfTypeProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.explicitRdfTypeProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitRdfTypeClass")}ExplicitRdfTypeProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isExplicitRdfTypeClass(
    object: $Object,
  ): object is ExplicitRdfTypeClass {
    switch (object.$type) {
      case "ExplicitRdfTypeClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Shape with custom rdf:type's.
 *
 * The shaclmate:fromRdfType is expected on deserialization.
 * shaclmate:toRdfType's are added an serialization.
 */
export class ExplicitFromToRdfTypesClass {
  private _$identifier?: ExplicitFromToRdfTypesClass.$Identifier;
  readonly $type = "ExplicitFromToRdfTypesClass";
  readonly explicitFromToRdfTypesProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly explicitFromToRdfTypesProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.explicitFromToRdfTypesProperty =
      parameters.explicitFromToRdfTypesProperty;
  }

  get $identifier(): ExplicitFromToRdfTypesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: ExplicitFromToRdfTypesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.explicitFromToRdfTypesProperty,
          other.explicitFromToRdfTypesProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "explicitFromToRdfTypesProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.explicitFromToRdfTypesProperty);
    return _hasher;
  }

  $toJson(): ExplicitFromToRdfTypesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        explicitFromToRdfTypesProperty: this.explicitFromToRdfTypesProperty,
      } satisfies ExplicitFromToRdfTypesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode("http://example.com/ToRdfType"),
      );
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode("http://example.com/FromRdfType"),
      );
    }

    resource.add(
      ExplicitFromToRdfTypesClass.$properties.explicitFromToRdfTypesProperty[
        "identifier"
      ],
      ...[this.explicitFromToRdfTypesProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ExplicitFromToRdfTypesClass {
  export function $filter(
    filter: ExplicitFromToRdfTypesClass.$Filter,
    value: ExplicitFromToRdfTypesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.explicitFromToRdfTypesProperty !== "undefined" &&
      !$filterString(
        filter.explicitFromToRdfTypesProperty,
        value.explicitFromToRdfTypesProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly explicitFromToRdfTypesProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ExplicitFromToRdfTypesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ExplicitFromToRdfTypesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ExplicitFromToRdfTypesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ExplicitFromToRdfTypesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ExplicitFromToRdfTypesClass(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/FromRdfType",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ExplicitFromToRdfTypesClass";
    readonly explicitFromToRdfTypesProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ExplicitFromToRdfTypesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/explicitFromToRdfTypesProperty`,
          type: "Control",
        },
      ],
      label: "ExplicitFromToRdfTypesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("ExplicitFromToRdfTypesClass"),
      explicitFromToRdfTypesProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    explicitFromToRdfTypesProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/explicitFromToRdfTypesProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      explicitFromToRdfTypesProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const explicitFromToRdfTypesProperty =
      $jsonObject["explicitFromToRdfTypesProperty"];
    return purify.Either.of({ $identifier, explicitFromToRdfTypesProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      explicitFromToRdfTypesProperty: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/FromRdfType":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  ExplicitFromToRdfTypesClass.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/FromRdfType)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      purify.Either.of<Error, ExplicitFromToRdfTypesClass.$Identifier>(
        $parameters.resource
          .identifier as ExplicitFromToRdfTypesClass.$Identifier,
      ).chain(($identifier) =>
        purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
        >(
          $parameters.resource.values(
            $properties.explicitFromToRdfTypesProperty["identifier"],
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                ExplicitFromToRdfTypesClass.$properties
                  .explicitFromToRdfTypesProperty["identifier"],
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((explicitFromToRdfTypesProperty) => ({
            $identifier,
            explicitFromToRdfTypesProperty,
          })),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ExplicitFromToRdfTypesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ExplicitFromToRdfTypesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ExplicitFromToRdfTypesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ExplicitFromToRdfTypesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ExplicitFromToRdfTypesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("explicitFromToRdfTypesClass");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitFromToRdfTypesClass")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitFromToRdfTypesClass")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitFromToRdfTypesClass")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitFromToRdfTypesClass")}ExplicitFromToRdfTypesProperty`,
      ),
      predicate:
        ExplicitFromToRdfTypesClass.$properties.explicitFromToRdfTypesProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ExplicitFromToRdfTypesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("explicitFromToRdfTypesClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitFromToRdfTypesClass")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ExplicitFromToRdfTypesClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitFromToRdfTypesClass")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitFromToRdfTypesClass")}ExplicitFromToRdfTypesProperty`,
            ),
            predicate:
              ExplicitFromToRdfTypesClass.$properties
                .explicitFromToRdfTypesProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitFromToRdfTypesClass")}ExplicitFromToRdfTypesProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.explicitFromToRdfTypesProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitFromToRdfTypesClass")}ExplicitFromToRdfTypesProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isExplicitFromToRdfTypesClass(
    object: $Object,
  ): object is ExplicitFromToRdfTypesClass {
    switch (object.$type) {
      case "ExplicitFromToRdfTypesClass":
        return true;
      default:
        return false;
    }
  }
}
export class DirectRecursiveClass {
  private _$identifier?: DirectRecursiveClass.$Identifier;
  readonly $type = "DirectRecursiveClass";
  readonly directRecursiveProperty: purify.Maybe<DirectRecursiveClass>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly directRecursiveProperty?:
      | DirectRecursiveClass
      | purify.Maybe<DirectRecursiveClass>;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.directRecursiveProperty)) {
      this.directRecursiveProperty = parameters?.directRecursiveProperty;
    } else if (
      typeof parameters?.directRecursiveProperty === "object" &&
      parameters?.directRecursiveProperty instanceof DirectRecursiveClass
    ) {
      this.directRecursiveProperty = purify.Maybe.of(
        parameters?.directRecursiveProperty,
      );
    } else if (typeof parameters?.directRecursiveProperty === "undefined") {
      this.directRecursiveProperty = purify.Maybe.empty();
    } else {
      this.directRecursiveProperty =
        parameters?.directRecursiveProperty satisfies never;
    }
  }

  get $identifier(): DirectRecursiveClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: DirectRecursiveClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.directRecursiveProperty,
          other.directRecursiveProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "directRecursiveProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.directRecursiveProperty.ifJust((value0) => {
      value0.$hash(_hasher);
    });
    return _hasher;
  }

  $toJson(): DirectRecursiveClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        directRecursiveProperty: this.directRecursiveProperty
          .map((item) => item.$toJson())
          .extract(),
      } satisfies DirectRecursiveClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      DirectRecursiveClass.$properties.directRecursiveProperty["identifier"],
      ...this.directRecursiveProperty
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace DirectRecursiveClass {
  export function $filter(
    filter: DirectRecursiveClass.$Filter,
    value: DirectRecursiveClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.directRecursiveProperty !== "undefined" &&
      !$filterMaybe<DirectRecursiveClass, DirectRecursiveClass.$Filter>(
        DirectRecursiveClass.$filter,
      )(filter.directRecursiveProperty, value.directRecursiveProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly directRecursiveProperty?: $MaybeFilter<DirectRecursiveClass.$Filter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, DirectRecursiveClass> {
    return $propertiesFromJson(json).map(
      (properties) => new DirectRecursiveClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, DirectRecursiveClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return DirectRecursiveClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new DirectRecursiveClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "DirectRecursiveClass";
    readonly directRecursiveProperty?: DirectRecursiveClass.$Json;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "DirectRecursiveClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        DirectRecursiveClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/directRecursiveProperty`,
        }),
      ],
      label: "DirectRecursiveClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("DirectRecursiveClass"),
      directRecursiveProperty: zod
        .lazy(
          (): zod.ZodType<DirectRecursiveClass.$Json> =>
            DirectRecursiveClass.$jsonZodSchema(),
        )
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    directRecursiveProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/directRecursiveProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      directRecursiveProperty: purify.Maybe<DirectRecursiveClass>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const directRecursiveProperty = purify.Maybe.fromNullable(
      $jsonObject["directRecursiveProperty"],
    ).map((item) => DirectRecursiveClass.$fromJson(item).unsafeCoerce());
    return purify.Either.of({ $identifier, directRecursiveProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      directRecursiveProperty: purify.Maybe<DirectRecursiveClass>;
    }
  > {
    return purify.Either.of<Error, DirectRecursiveClass.$Identifier>(
      $parameters.resource.identifier as DirectRecursiveClass.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.directRecursiveProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          values.chainMap((value) =>
            value.toResource().chain((resource) =>
              DirectRecursiveClass.$fromRdf(resource, {
                context: $parameters.context,
                ignoreRdfType: true,
                objectSet: $parameters.objectSet,
                preferredLanguages: $parameters.preferredLanguages,
              }),
            ),
          ),
        )
        .map((values) =>
          values.length > 0
            ? values.map((value) => purify.Maybe.of(value))
            : rdfjsResource.Resource.Values.fromValue<
                purify.Maybe<DirectRecursiveClass>
              >({
                focusResource: $parameters.resource,
                predicate:
                  DirectRecursiveClass.$properties.directRecursiveProperty[
                    "identifier"
                  ],
                value: purify.Maybe.empty(),
              }),
        )
        .chain((values) => values.head())
        .map((directRecursiveProperty) => ({
          $identifier,
          directRecursiveProperty,
        })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: DirectRecursiveClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        DirectRecursiveClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            DirectRecursiveClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: DirectRecursiveClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      DirectRecursiveClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: DirectRecursiveClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("directRecursiveClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }

  export function isDirectRecursiveClass(
    object: $Object,
  ): object is DirectRecursiveClass {
    switch (object.$type) {
      case "DirectRecursiveClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Shape with sh:defaultValue properties.
 */
export class DefaultValuePropertiesClass {
  private _$identifier?: DefaultValuePropertiesClass.$Identifier;
  protected readonly _$identifierPrefix?: string;
  readonly $type = "DefaultValuePropertiesClass";
  readonly dateDefaultValueProperty: Date;
  readonly dateTimeDefaultValueProperty: Date;
  readonly falseBooleanDefaultValueProperty: boolean;
  readonly numberDefaultValueProperty: number;
  readonly stringDefaultValueProperty: string;
  readonly trueBooleanDefaultValueProperty: boolean;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly $identifierPrefix?: string;
    readonly dateDefaultValueProperty?: Date;
    readonly dateTimeDefaultValueProperty?: Date;
    readonly falseBooleanDefaultValueProperty?: boolean;
    readonly numberDefaultValueProperty?: number;
    readonly stringDefaultValueProperty?: string;
    readonly trueBooleanDefaultValueProperty?: boolean;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    this._$identifierPrefix = parameters?.$identifierPrefix;
    if (
      typeof parameters?.dateDefaultValueProperty === "object" &&
      parameters?.dateDefaultValueProperty instanceof Date
    ) {
      this.dateDefaultValueProperty = parameters?.dateDefaultValueProperty;
    } else if (typeof parameters?.dateDefaultValueProperty === "undefined") {
      this.dateDefaultValueProperty = new Date("2018-04-09T00:00:00.000Z");
    } else {
      this.dateDefaultValueProperty =
        parameters?.dateDefaultValueProperty satisfies never;
    }

    if (
      typeof parameters?.dateTimeDefaultValueProperty === "object" &&
      parameters?.dateTimeDefaultValueProperty instanceof Date
    ) {
      this.dateTimeDefaultValueProperty =
        parameters?.dateTimeDefaultValueProperty;
    } else if (
      typeof parameters?.dateTimeDefaultValueProperty === "undefined"
    ) {
      this.dateTimeDefaultValueProperty = new Date("2018-04-09T10:00:00.000Z");
    } else {
      this.dateTimeDefaultValueProperty =
        parameters?.dateTimeDefaultValueProperty satisfies never;
    }

    if (typeof parameters?.falseBooleanDefaultValueProperty === "boolean") {
      this.falseBooleanDefaultValueProperty =
        parameters?.falseBooleanDefaultValueProperty;
    } else if (
      typeof parameters?.falseBooleanDefaultValueProperty === "undefined"
    ) {
      this.falseBooleanDefaultValueProperty = false;
    } else {
      this.falseBooleanDefaultValueProperty =
        parameters?.falseBooleanDefaultValueProperty satisfies never;
    }

    if (typeof parameters?.numberDefaultValueProperty === "number") {
      this.numberDefaultValueProperty = parameters?.numberDefaultValueProperty;
    } else if (typeof parameters?.numberDefaultValueProperty === "undefined") {
      this.numberDefaultValueProperty = 0;
    } else {
      this.numberDefaultValueProperty =
        parameters?.numberDefaultValueProperty satisfies never;
    }

    if (typeof parameters?.stringDefaultValueProperty === "string") {
      this.stringDefaultValueProperty = parameters?.stringDefaultValueProperty;
    } else if (typeof parameters?.stringDefaultValueProperty === "undefined") {
      this.stringDefaultValueProperty = "";
    } else {
      this.stringDefaultValueProperty =
        parameters?.stringDefaultValueProperty satisfies never;
    }

    if (typeof parameters?.trueBooleanDefaultValueProperty === "boolean") {
      this.trueBooleanDefaultValueProperty =
        parameters?.trueBooleanDefaultValueProperty;
    } else if (
      typeof parameters?.trueBooleanDefaultValueProperty === "undefined"
    ) {
      this.trueBooleanDefaultValueProperty = true;
    } else {
      this.trueBooleanDefaultValueProperty =
        parameters?.trueBooleanDefaultValueProperty satisfies never;
    }
  }

  get $identifier(): DefaultValuePropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }

    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  $equals(other: DefaultValuePropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$identifierPrefix, other.$identifierPrefix).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$identifierPrefix",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $dateEquals(
          this.dateDefaultValueProperty,
          other.dateDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "dateDefaultValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $dateEquals(
          this.dateTimeDefaultValueProperty,
          other.dateTimeDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "dateTimeDefaultValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.falseBooleanDefaultValueProperty,
          other.falseBooleanDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "falseBooleanDefaultValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.numberDefaultValueProperty,
          other.numberDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "numberDefaultValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.stringDefaultValueProperty,
          other.stringDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "stringDefaultValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.trueBooleanDefaultValueProperty,
          other.trueBooleanDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "trueBooleanDefaultValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.dateDefaultValueProperty.toISOString());
    _hasher.update(this.dateTimeDefaultValueProperty.toISOString());
    _hasher.update(this.falseBooleanDefaultValueProperty.toString());
    _hasher.update(this.numberDefaultValueProperty.toString());
    _hasher.update(this.stringDefaultValueProperty);
    _hasher.update(this.trueBooleanDefaultValueProperty.toString());
    return _hasher;
  }

  $toJson(): DefaultValuePropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        dateDefaultValueProperty: this.dateDefaultValueProperty
          .toISOString()
          .replace(/T.*$/, ""),
        dateTimeDefaultValueProperty:
          this.dateTimeDefaultValueProperty.toISOString(),
        falseBooleanDefaultValueProperty: this.falseBooleanDefaultValueProperty,
        numberDefaultValueProperty: this.numberDefaultValueProperty,
        stringDefaultValueProperty: this.stringDefaultValueProperty,
        trueBooleanDefaultValueProperty: this.trueBooleanDefaultValueProperty,
      } satisfies DefaultValuePropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      DefaultValuePropertiesClass.$properties.dateDefaultValueProperty[
        "identifier"
      ],
      ...(this.dateDefaultValueProperty.getTime() !== 1523232000000
        ? [
            dataFactory.literal(
              this.dateDefaultValueProperty.toISOString().replace(/T.*$/, ""),
              $RdfVocabularies.xsd.date,
            ),
          ]
        : []),
    );
    resource.add(
      DefaultValuePropertiesClass.$properties.dateTimeDefaultValueProperty[
        "identifier"
      ],
      ...(this.dateTimeDefaultValueProperty.getTime() !== 1523268000000
        ? [
            dataFactory.literal(
              this.dateTimeDefaultValueProperty.toISOString(),
              $RdfVocabularies.xsd.dateTime,
            ),
          ]
        : []),
    );
    resource.add(
      DefaultValuePropertiesClass.$properties.falseBooleanDefaultValueProperty[
        "identifier"
      ],
      ...(this.falseBooleanDefaultValueProperty ? [true] : []),
    );
    resource.add(
      DefaultValuePropertiesClass.$properties.numberDefaultValueProperty[
        "identifier"
      ],
      ...(this.numberDefaultValueProperty !== 0
        ? [
            dataFactory.literal(
              this.numberDefaultValueProperty.toString(10),
              $RdfVocabularies.xsd.integer,
            ),
          ]
        : []),
    );
    resource.add(
      DefaultValuePropertiesClass.$properties.stringDefaultValueProperty[
        "identifier"
      ],
      ...(this.stringDefaultValueProperty !== ""
        ? [this.stringDefaultValueProperty]
        : []),
    );
    resource.add(
      DefaultValuePropertiesClass.$properties.trueBooleanDefaultValueProperty[
        "identifier"
      ],
      ...(!this.trueBooleanDefaultValueProperty ? [false] : []),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace DefaultValuePropertiesClass {
  export function $filter(
    filter: DefaultValuePropertiesClass.$Filter,
    value: DefaultValuePropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.dateDefaultValueProperty !== "undefined" &&
      !$filterDate(
        filter.dateDefaultValueProperty,
        value.dateDefaultValueProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.dateTimeDefaultValueProperty !== "undefined" &&
      !$filterDate(
        filter.dateTimeDefaultValueProperty,
        value.dateTimeDefaultValueProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.falseBooleanDefaultValueProperty !== "undefined" &&
      !$filterBoolean(
        filter.falseBooleanDefaultValueProperty,
        value.falseBooleanDefaultValueProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.numberDefaultValueProperty !== "undefined" &&
      !$filterNumber(
        filter.numberDefaultValueProperty,
        value.numberDefaultValueProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.stringDefaultValueProperty !== "undefined" &&
      !$filterString(
        filter.stringDefaultValueProperty,
        value.stringDefaultValueProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.trueBooleanDefaultValueProperty !== "undefined" &&
      !$filterBoolean(
        filter.trueBooleanDefaultValueProperty,
        value.trueBooleanDefaultValueProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly dateDefaultValueProperty?: $DateFilter;
    readonly dateTimeDefaultValueProperty?: $DateFilter;
    readonly falseBooleanDefaultValueProperty?: $BooleanFilter;
    readonly numberDefaultValueProperty?: $NumberFilter;
    readonly stringDefaultValueProperty?: $StringFilter;
    readonly trueBooleanDefaultValueProperty?: $BooleanFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, DefaultValuePropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new DefaultValuePropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, DefaultValuePropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return DefaultValuePropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new DefaultValuePropertiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "DefaultValuePropertiesClass";
    readonly dateDefaultValueProperty: string;
    readonly dateTimeDefaultValueProperty: string;
    readonly falseBooleanDefaultValueProperty: boolean;
    readonly numberDefaultValueProperty: number;
    readonly stringDefaultValueProperty: string;
    readonly trueBooleanDefaultValueProperty: boolean;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "DefaultValuePropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateDefaultValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateTimeDefaultValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/falseBooleanDefaultValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/numberDefaultValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/stringDefaultValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/trueBooleanDefaultValueProperty`,
          type: "Control",
        },
      ],
      label: "DefaultValuePropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("DefaultValuePropertiesClass"),
      dateDefaultValueProperty: zod.iso.date(),
      dateTimeDefaultValueProperty: zod.iso.datetime(),
      falseBooleanDefaultValueProperty: zod.boolean(),
      numberDefaultValueProperty: zod.number(),
      stringDefaultValueProperty: zod.string(),
      trueBooleanDefaultValueProperty: zod.boolean(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    dateDefaultValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/dateDefaultValueProperty",
      ),
    },
    dateTimeDefaultValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/dateTimeDefaultValueProperty",
      ),
    },
    falseBooleanDefaultValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/falseBooleanDefaultValueProperty",
      ),
    },
    numberDefaultValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/numberDefaultValueProperty",
      ),
    },
    stringDefaultValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/stringDefaultValueProperty",
      ),
    },
    trueBooleanDefaultValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/trueBooleanDefaultValueProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      dateDefaultValueProperty: Date;
      dateTimeDefaultValueProperty: Date;
      falseBooleanDefaultValueProperty: boolean;
      numberDefaultValueProperty: number;
      stringDefaultValueProperty: string;
      trueBooleanDefaultValueProperty: boolean;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const dateDefaultValueProperty = new Date(
      $jsonObject["dateDefaultValueProperty"],
    );
    const dateTimeDefaultValueProperty = new Date(
      $jsonObject["dateTimeDefaultValueProperty"],
    );
    const falseBooleanDefaultValueProperty =
      $jsonObject["falseBooleanDefaultValueProperty"];
    const numberDefaultValueProperty =
      $jsonObject["numberDefaultValueProperty"];
    const stringDefaultValueProperty =
      $jsonObject["stringDefaultValueProperty"];
    const trueBooleanDefaultValueProperty =
      $jsonObject["trueBooleanDefaultValueProperty"];
    return purify.Either.of({
      $identifier,
      dateDefaultValueProperty,
      dateTimeDefaultValueProperty,
      falseBooleanDefaultValueProperty,
      numberDefaultValueProperty,
      stringDefaultValueProperty,
      trueBooleanDefaultValueProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      dateDefaultValueProperty: Date;
      dateTimeDefaultValueProperty: Date;
      falseBooleanDefaultValueProperty: boolean;
      numberDefaultValueProperty: number;
      stringDefaultValueProperty: string;
      trueBooleanDefaultValueProperty: boolean;
    }
  > {
    return purify.Either.of<Error, DefaultValuePropertiesClass.$Identifier>(
      $parameters.resource
        .identifier as DefaultValuePropertiesClass.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.dateDefaultValueProperty["identifier"],
          { unique: true },
        ),
      )
        .map((values) =>
          values.length > 0
            ? values
            : new rdfjsResource.Resource.TermValue({
                focusResource: $parameters.resource,
                predicate:
                  DefaultValuePropertiesClass.$properties
                    .dateDefaultValueProperty["identifier"],
                term: dataFactory.literal(
                  "2018-04-09",
                  $RdfVocabularies.xsd.date,
                ),
              }).toValues(),
        )
        .chain((values) => values.chainMap((value) => value.toDate()))
        .chain((values) => values.head())
        .chain((dateDefaultValueProperty) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.dateTimeDefaultValueProperty["identifier"],
              { unique: true },
            ),
          )
            .map((values) =>
              values.length > 0
                ? values
                : new rdfjsResource.Resource.TermValue({
                    focusResource: $parameters.resource,
                    predicate:
                      DefaultValuePropertiesClass.$properties
                        .dateTimeDefaultValueProperty["identifier"],
                    term: dataFactory.literal(
                      "2018-04-09T10:00:00Z",
                      $RdfVocabularies.xsd.dateTime,
                    ),
                  }).toValues(),
            )
            .chain((values) => values.chainMap((value) => value.toDate()))
            .chain((values) => values.head())
            .chain((dateTimeDefaultValueProperty) =>
              purify.Either.of<
                Error,
                rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
              >(
                $parameters.resource.values(
                  $properties.falseBooleanDefaultValueProperty["identifier"],
                  { unique: true },
                ),
              )
                .map((values) =>
                  values.length > 0
                    ? values
                    : new rdfjsResource.Resource.TermValue({
                        focusResource: $parameters.resource,
                        predicate:
                          DefaultValuePropertiesClass.$properties
                            .falseBooleanDefaultValueProperty["identifier"],
                        term: dataFactory.literal(
                          "false",
                          $RdfVocabularies.xsd.boolean,
                        ),
                      }).toValues(),
                )
                .chain((values) =>
                  values.chainMap((value) => value.toBoolean()),
                )
                .chain((values) => values.head())
                .chain((falseBooleanDefaultValueProperty) =>
                  purify.Either.of<
                    Error,
                    rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                  >(
                    $parameters.resource.values(
                      $properties.numberDefaultValueProperty["identifier"],
                      { unique: true },
                    ),
                  )
                    .map((values) =>
                      values.length > 0
                        ? values
                        : new rdfjsResource.Resource.TermValue({
                            focusResource: $parameters.resource,
                            predicate:
                              DefaultValuePropertiesClass.$properties
                                .numberDefaultValueProperty["identifier"],
                            term: dataFactory.literal(
                              "0",
                              $RdfVocabularies.xsd.integer,
                            ),
                          }).toValues(),
                    )
                    .chain((values) =>
                      values.chainMap((value) => value.toNumber()),
                    )
                    .chain((values) => values.head())
                    .chain((numberDefaultValueProperty) =>
                      purify.Either.of<
                        Error,
                        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                      >(
                        $parameters.resource.values(
                          $properties.stringDefaultValueProperty["identifier"],
                          { unique: true },
                        ),
                      )
                        .map((values) =>
                          values.length > 0
                            ? values
                            : new rdfjsResource.Resource.TermValue({
                                focusResource: $parameters.resource,
                                predicate:
                                  DefaultValuePropertiesClass.$properties
                                    .stringDefaultValueProperty["identifier"],
                                term: dataFactory.literal(""),
                              }).toValues(),
                        )
                        .chain((values) =>
                          $fromRdfPreferredLanguages({
                            focusResource: $parameters.resource,
                            predicate:
                              DefaultValuePropertiesClass.$properties
                                .stringDefaultValueProperty["identifier"],
                            preferredLanguages: $parameters.preferredLanguages,
                            values,
                          }),
                        )
                        .chain((values) =>
                          values.chainMap((value) => value.toString()),
                        )
                        .chain((values) => values.head())
                        .chain((stringDefaultValueProperty) =>
                          purify.Either.of<
                            Error,
                            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                          >(
                            $parameters.resource.values(
                              $properties.trueBooleanDefaultValueProperty[
                                "identifier"
                              ],
                              { unique: true },
                            ),
                          )
                            .map((values) =>
                              values.length > 0
                                ? values
                                : new rdfjsResource.Resource.TermValue({
                                    focusResource: $parameters.resource,
                                    predicate:
                                      DefaultValuePropertiesClass.$properties
                                        .trueBooleanDefaultValueProperty[
                                        "identifier"
                                      ],
                                    term: dataFactory.literal(
                                      "true",
                                      $RdfVocabularies.xsd.boolean,
                                    ),
                                  }).toValues(),
                            )
                            .chain((values) =>
                              values.chainMap((value) => value.toBoolean()),
                            )
                            .chain((values) => values.head())
                            .map((trueBooleanDefaultValueProperty) => ({
                              $identifier,
                              dateDefaultValueProperty,
                              dateTimeDefaultValueProperty,
                              falseBooleanDefaultValueProperty,
                              numberDefaultValueProperty,
                              stringDefaultValueProperty,
                              trueBooleanDefaultValueProperty,
                            })),
                        ),
                    ),
                ),
            ),
        ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: DefaultValuePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        DefaultValuePropertiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            DefaultValuePropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: DefaultValuePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      DefaultValuePropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("defaultValuePropertiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}DateDefaultValueProperty`,
      ),
      predicate:
        DefaultValuePropertiesClass.$properties.dateDefaultValueProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}DateTimeDefaultValueProperty`,
      ),
      predicate:
        DefaultValuePropertiesClass.$properties.dateTimeDefaultValueProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}FalseBooleanDefaultValueProperty`,
      ),
      predicate:
        DefaultValuePropertiesClass.$properties
          .falseBooleanDefaultValueProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}NumberDefaultValueProperty`,
      ),
      predicate:
        DefaultValuePropertiesClass.$properties.numberDefaultValueProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}StringDefaultValueProperty`,
      ),
      predicate:
        DefaultValuePropertiesClass.$properties.stringDefaultValueProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}TrueBooleanDefaultValueProperty`,
      ),
      predicate:
        DefaultValuePropertiesClass.$properties.trueBooleanDefaultValueProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: DefaultValuePropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("defaultValuePropertiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}DateDefaultValueProperty`,
              ),
              predicate:
                DefaultValuePropertiesClass.$properties
                  .dateDefaultValueProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: $DateFilter
            .$sparqlWherePatterns(
              parameters?.filter?.dateDefaultValueProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}DateDefaultValueProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}DateTimeDefaultValueProperty`,
              ),
              predicate:
                DefaultValuePropertiesClass.$properties
                  .dateTimeDefaultValueProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: $DateFilter
            .$sparqlWherePatterns(
              parameters?.filter?.dateTimeDefaultValueProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}DateTimeDefaultValueProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}FalseBooleanDefaultValueProperty`,
              ),
              predicate:
                DefaultValuePropertiesClass.$properties
                  .falseBooleanDefaultValueProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: $BooleanFilter
            .$sparqlWherePatterns(
              parameters?.filter?.falseBooleanDefaultValueProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}FalseBooleanDefaultValueProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}NumberDefaultValueProperty`,
              ),
              predicate:
                DefaultValuePropertiesClass.$properties
                  .numberDefaultValueProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: $NumberFilter
            .$sparqlWherePatterns(
              parameters?.filter?.numberDefaultValueProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}NumberDefaultValueProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}StringDefaultValueProperty`,
              ),
              predicate:
                DefaultValuePropertiesClass.$properties
                  .stringDefaultValueProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: [parameters?.preferredLanguages ?? []]
            .filter((languages) => languages.length > 0)
            .map((languages) =>
              languages.map((language) => ({
                type: "operation" as const,
                operator: "=",
                args: [
                  {
                    type: "operation" as const,
                    operator: "lang",
                    args: [
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}StringDefaultValueProperty`,
                      ),
                    ],
                  },
                  dataFactory.literal(language),
                ],
              })),
            )
            .map((langEqualsExpressions) => ({
              type: "filter" as const,
              expression: langEqualsExpressions.reduce(
                (reducedExpression, langEqualsExpression) => {
                  if (reducedExpression === null) {
                    return langEqualsExpression;
                  }
                  return {
                    type: "operation" as const,
                    operator: "||",
                    args: [reducedExpression, langEqualsExpression],
                  };
                },
                null as sparqljs.Expression | null,
              ) as sparqljs.Expression,
            }))
            .concat(),
          type: "group",
        },
        {
          patterns: $StringFilter
            .$sparqlWherePatterns(
              parameters?.filter?.stringDefaultValueProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}StringDefaultValueProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}TrueBooleanDefaultValueProperty`,
              ),
              predicate:
                DefaultValuePropertiesClass.$properties
                  .trueBooleanDefaultValueProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: $BooleanFilter
            .$sparqlWherePatterns(
              parameters?.filter?.trueBooleanDefaultValueProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}TrueBooleanDefaultValueProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    return patterns;
  }

  export function isDefaultValuePropertiesClass(
    object: $Object,
  ): object is DefaultValuePropertiesClass {
    switch (object.$type) {
      case "DefaultValuePropertiesClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Shape with sh:xone (union) properties related to dates and date-times. Unions of these and strings are common in actual models.
 */
export class DateUnionPropertiesClass {
  private _$identifier?: DateUnionPropertiesClass.$Identifier;
  readonly $type = "DateUnionPropertiesClass";
  readonly dateOrDateTimeProperty: purify.Maybe<
    { type: "date"; value: Date } | { type: "dateTime"; value: Date }
  >;
  readonly dateOrStringProperty: purify.Maybe<
    { type: "date"; value: Date } | { type: "string"; value: string }
  >;
  readonly dateTimeOrDateProperty: purify.Maybe<
    { type: "dateTime"; value: Date } | { type: "date"; value: Date }
  >;
  readonly stringOrDateProperty: purify.Maybe<
    { type: "string"; value: string } | { type: "date"; value: Date }
  >;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly dateOrDateTimeProperty?:
      | ({ type: "date"; value: Date } | { type: "dateTime"; value: Date })
      | purify.Maybe<
          { type: "date"; value: Date } | { type: "dateTime"; value: Date }
        >;
    readonly dateOrStringProperty?:
      | ({ type: "date"; value: Date } | { type: "string"; value: string })
      | purify.Maybe<
          { type: "date"; value: Date } | { type: "string"; value: string }
        >;
    readonly dateTimeOrDateProperty?:
      | ({ type: "dateTime"; value: Date } | { type: "date"; value: Date })
      | purify.Maybe<
          { type: "dateTime"; value: Date } | { type: "date"; value: Date }
        >;
    readonly stringOrDateProperty?:
      | ({ type: "string"; value: string } | { type: "date"; value: Date })
      | purify.Maybe<
          { type: "string"; value: string } | { type: "date"; value: Date }
        >;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.dateOrDateTimeProperty)) {
      this.dateOrDateTimeProperty = parameters?.dateOrDateTimeProperty;
    } else if (typeof parameters?.dateOrDateTimeProperty === "object") {
      this.dateOrDateTimeProperty = purify.Maybe.of(
        parameters?.dateOrDateTimeProperty,
      );
    } else if (typeof parameters?.dateOrDateTimeProperty === "undefined") {
      this.dateOrDateTimeProperty = purify.Maybe.empty();
    } else {
      this.dateOrDateTimeProperty =
        parameters?.dateOrDateTimeProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.dateOrStringProperty)) {
      this.dateOrStringProperty = parameters?.dateOrStringProperty;
    } else if (typeof parameters?.dateOrStringProperty === "object") {
      this.dateOrStringProperty = purify.Maybe.of(
        parameters?.dateOrStringProperty,
      );
    } else if (typeof parameters?.dateOrStringProperty === "undefined") {
      this.dateOrStringProperty = purify.Maybe.empty();
    } else {
      this.dateOrStringProperty =
        parameters?.dateOrStringProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.dateTimeOrDateProperty)) {
      this.dateTimeOrDateProperty = parameters?.dateTimeOrDateProperty;
    } else if (typeof parameters?.dateTimeOrDateProperty === "object") {
      this.dateTimeOrDateProperty = purify.Maybe.of(
        parameters?.dateTimeOrDateProperty,
      );
    } else if (typeof parameters?.dateTimeOrDateProperty === "undefined") {
      this.dateTimeOrDateProperty = purify.Maybe.empty();
    } else {
      this.dateTimeOrDateProperty =
        parameters?.dateTimeOrDateProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.stringOrDateProperty)) {
      this.stringOrDateProperty = parameters?.stringOrDateProperty;
    } else if (typeof parameters?.stringOrDateProperty === "object") {
      this.stringOrDateProperty = purify.Maybe.of(
        parameters?.stringOrDateProperty,
      );
    } else if (typeof parameters?.stringOrDateProperty === "undefined") {
      this.stringOrDateProperty = purify.Maybe.empty();
    } else {
      this.stringOrDateProperty =
        parameters?.stringOrDateProperty satisfies never;
    }
  }

  get $identifier(): DateUnionPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: DateUnionPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (
              left:
                | { type: "date"; value: Date }
                | { type: "dateTime"; value: Date },
              right:
                | { type: "date"; value: Date }
                | { type: "dateTime"; value: Date },
            ) => {
              if (left.type === "date" && right.type === "date") {
                return $dateEquals(left.value, right.value);
              }
              if (left.type === "dateTime" && right.type === "dateTime") {
                return $dateEquals(left.value, right.value);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(this.dateOrDateTimeProperty, other.dateOrDateTimeProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "dateOrDateTimeProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (
              left:
                | { type: "date"; value: Date }
                | { type: "string"; value: string },
              right:
                | { type: "date"; value: Date }
                | { type: "string"; value: string },
            ) => {
              if (left.type === "date" && right.type === "date") {
                return $dateEquals(left.value, right.value);
              }
              if (left.type === "string" && right.type === "string") {
                return $strictEquals(left.value, right.value);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(this.dateOrStringProperty, other.dateOrStringProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "dateOrStringProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (
              left:
                | { type: "dateTime"; value: Date }
                | { type: "date"; value: Date },
              right:
                | { type: "dateTime"; value: Date }
                | { type: "date"; value: Date },
            ) => {
              if (left.type === "dateTime" && right.type === "dateTime") {
                return $dateEquals(left.value, right.value);
              }
              if (left.type === "date" && right.type === "date") {
                return $dateEquals(left.value, right.value);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(this.dateTimeOrDateProperty, other.dateTimeOrDateProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "dateTimeOrDateProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (
              left:
                | { type: "string"; value: string }
                | { type: "date"; value: Date },
              right:
                | { type: "string"; value: string }
                | { type: "date"; value: Date },
            ) => {
              if (left.type === "string" && right.type === "string") {
                return $strictEquals(left.value, right.value);
              }
              if (left.type === "date" && right.type === "date") {
                return $dateEquals(left.value, right.value);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(this.stringOrDateProperty, other.stringOrDateProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "stringOrDateProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.dateOrDateTimeProperty.ifJust((value0) => {
      switch (value0.type) {
        case "date": {
          _hasher.update(value0.value.toISOString());
          break;
        }
        case "dateTime": {
          _hasher.update(value0.value.toISOString());
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    this.dateOrStringProperty.ifJust((value0) => {
      switch (value0.type) {
        case "date": {
          _hasher.update(value0.value.toISOString());
          break;
        }
        case "string": {
          _hasher.update(value0.value);
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    this.dateTimeOrDateProperty.ifJust((value0) => {
      switch (value0.type) {
        case "dateTime": {
          _hasher.update(value0.value.toISOString());
          break;
        }
        case "date": {
          _hasher.update(value0.value.toISOString());
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    this.stringOrDateProperty.ifJust((value0) => {
      switch (value0.type) {
        case "string": {
          _hasher.update(value0.value);
          break;
        }
        case "date": {
          _hasher.update(value0.value.toISOString());
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    return _hasher;
  }

  $toJson(): DateUnionPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        dateOrDateTimeProperty: this.dateOrDateTimeProperty
          .map((item) =>
            item.type === "dateTime"
              ? { type: "dateTime" as const, value: item.value.toISOString() }
              : {
                  type: "date" as const,
                  value: item.value.toISOString().replace(/T.*$/, ""),
                },
          )
          .extract(),
        dateOrStringProperty: this.dateOrStringProperty
          .map((item) =>
            item.type === "string"
              ? { type: "string" as const, value: item.value }
              : {
                  type: "date" as const,
                  value: item.value.toISOString().replace(/T.*$/, ""),
                },
          )
          .extract(),
        dateTimeOrDateProperty: this.dateTimeOrDateProperty
          .map((item) =>
            item.type === "date"
              ? {
                  type: "date" as const,
                  value: item.value.toISOString().replace(/T.*$/, ""),
                }
              : { type: "dateTime" as const, value: item.value.toISOString() },
          )
          .extract(),
        stringOrDateProperty: this.stringOrDateProperty
          .map((item) =>
            item.type === "date"
              ? {
                  type: "date" as const,
                  value: item.value.toISOString().replace(/T.*$/, ""),
                }
              : { type: "string" as const, value: item.value },
          )
          .extract(),
      } satisfies DateUnionPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      DateUnionPropertiesClass.$properties.dateOrDateTimeProperty["identifier"],
      ...this.dateOrDateTimeProperty
        .toList()
        .flatMap((value) =>
          value.type === "dateTime"
            ? ([
                dataFactory.literal(
                  value.value.toISOString(),
                  $RdfVocabularies.xsd.dateTime,
                ),
              ] as readonly Parameters<
                rdfjsResource.MutableResource["add"]
              >[1][])
            : ([
                dataFactory.literal(
                  value.value.toISOString().replace(/T.*$/, ""),
                  $RdfVocabularies.xsd.date,
                ),
              ] as readonly Parameters<
                rdfjsResource.MutableResource["add"]
              >[1][]),
        ),
    );
    resource.add(
      DateUnionPropertiesClass.$properties.dateOrStringProperty["identifier"],
      ...this.dateOrStringProperty
        .toList()
        .flatMap((value) =>
          value.type === "string"
            ? ([value.value] as readonly Parameters<
                rdfjsResource.MutableResource["add"]
              >[1][])
            : ([
                dataFactory.literal(
                  value.value.toISOString().replace(/T.*$/, ""),
                  $RdfVocabularies.xsd.date,
                ),
              ] as readonly Parameters<
                rdfjsResource.MutableResource["add"]
              >[1][]),
        ),
    );
    resource.add(
      DateUnionPropertiesClass.$properties.dateTimeOrDateProperty["identifier"],
      ...this.dateTimeOrDateProperty
        .toList()
        .flatMap((value) =>
          value.type === "date"
            ? ([
                dataFactory.literal(
                  value.value.toISOString().replace(/T.*$/, ""),
                  $RdfVocabularies.xsd.date,
                ),
              ] as readonly Parameters<
                rdfjsResource.MutableResource["add"]
              >[1][])
            : ([
                dataFactory.literal(
                  value.value.toISOString(),
                  $RdfVocabularies.xsd.dateTime,
                ),
              ] as readonly Parameters<
                rdfjsResource.MutableResource["add"]
              >[1][]),
        ),
    );
    resource.add(
      DateUnionPropertiesClass.$properties.stringOrDateProperty["identifier"],
      ...this.stringOrDateProperty
        .toList()
        .flatMap((value) =>
          value.type === "date"
            ? ([
                dataFactory.literal(
                  value.value.toISOString().replace(/T.*$/, ""),
                  $RdfVocabularies.xsd.date,
                ),
              ] as readonly Parameters<
                rdfjsResource.MutableResource["add"]
              >[1][])
            : ([value.value] as readonly Parameters<
                rdfjsResource.MutableResource["add"]
              >[1][]),
        ),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace DateUnionPropertiesClass {
  export function $filter(
    filter: DateUnionPropertiesClass.$Filter,
    value: DateUnionPropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.dateOrDateTimeProperty !== "undefined" &&
      !$filterMaybe<
        { type: "date"; value: Date } | { type: "dateTime"; value: Date },
        {
          readonly on?: {
            readonly date?: $DateFilter;
            readonly dateTime?: $DateFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly date?: $DateFilter;
              readonly dateTime?: $DateFilter;
            };
          },
          value:
            | { type: "date"; value: Date }
            | { type: "dateTime"; value: Date },
        ) => {
          if (typeof filter.on?.["date"] !== "undefined") {
            switch (value.type) {
              case "date":
                if (!$filterDate(filter.on["date"], value.value)) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["dateTime"] !== "undefined") {
            switch (value.type) {
              case "dateTime":
                if (!$filterDate(filter.on["dateTime"], value.value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.dateOrDateTimeProperty, value.dateOrDateTimeProperty)
    ) {
      return false;
    }

    if (
      typeof filter.dateOrStringProperty !== "undefined" &&
      !$filterMaybe<
        { type: "date"; value: Date } | { type: "string"; value: string },
        {
          readonly on?: {
            readonly date?: $DateFilter;
            readonly string?: $StringFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly date?: $DateFilter;
              readonly string?: $StringFilter;
            };
          },
          value:
            | { type: "date"; value: Date }
            | { type: "string"; value: string },
        ) => {
          if (typeof filter.on?.["date"] !== "undefined") {
            switch (value.type) {
              case "date":
                if (!$filterDate(filter.on["date"], value.value)) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["string"] !== "undefined") {
            switch (value.type) {
              case "string":
                if (!$filterString(filter.on["string"], value.value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.dateOrStringProperty, value.dateOrStringProperty)
    ) {
      return false;
    }

    if (
      typeof filter.dateTimeOrDateProperty !== "undefined" &&
      !$filterMaybe<
        { type: "dateTime"; value: Date } | { type: "date"; value: Date },
        {
          readonly on?: {
            readonly dateTime?: $DateFilter;
            readonly date?: $DateFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly dateTime?: $DateFilter;
              readonly date?: $DateFilter;
            };
          },
          value:
            | { type: "dateTime"; value: Date }
            | { type: "date"; value: Date },
        ) => {
          if (typeof filter.on?.["dateTime"] !== "undefined") {
            switch (value.type) {
              case "dateTime":
                if (!$filterDate(filter.on["dateTime"], value.value)) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["date"] !== "undefined") {
            switch (value.type) {
              case "date":
                if (!$filterDate(filter.on["date"], value.value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.dateTimeOrDateProperty, value.dateTimeOrDateProperty)
    ) {
      return false;
    }

    if (
      typeof filter.stringOrDateProperty !== "undefined" &&
      !$filterMaybe<
        { type: "string"; value: string } | { type: "date"; value: Date },
        {
          readonly on?: {
            readonly string?: $StringFilter;
            readonly date?: $DateFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly string?: $StringFilter;
              readonly date?: $DateFilter;
            };
          },
          value:
            | { type: "string"; value: string }
            | { type: "date"; value: Date },
        ) => {
          if (typeof filter.on?.["string"] !== "undefined") {
            switch (value.type) {
              case "string":
                if (!$filterString(filter.on["string"], value.value)) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["date"] !== "undefined") {
            switch (value.type) {
              case "date":
                if (!$filterDate(filter.on["date"], value.value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.stringOrDateProperty, value.stringOrDateProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly dateOrDateTimeProperty?: $MaybeFilter<{
      readonly on?: {
        readonly date?: $DateFilter;
        readonly dateTime?: $DateFilter;
      };
    }>;
    readonly dateOrStringProperty?: $MaybeFilter<{
      readonly on?: {
        readonly date?: $DateFilter;
        readonly string?: $StringFilter;
      };
    }>;
    readonly dateTimeOrDateProperty?: $MaybeFilter<{
      readonly on?: {
        readonly dateTime?: $DateFilter;
        readonly date?: $DateFilter;
      };
    }>;
    readonly stringOrDateProperty?: $MaybeFilter<{
      readonly on?: {
        readonly string?: $StringFilter;
        readonly date?: $DateFilter;
      };
    }>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, DateUnionPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new DateUnionPropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, DateUnionPropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return DateUnionPropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new DateUnionPropertiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "DateUnionPropertiesClass";
    readonly dateOrDateTimeProperty?:
      | { type: "date"; value: string }
      | { type: "dateTime"; value: string };
    readonly dateOrStringProperty?:
      | { type: "date"; value: string }
      | { type: "string"; value: string };
    readonly dateTimeOrDateProperty?:
      | { type: "dateTime"; value: string }
      | { type: "date"; value: string };
    readonly stringOrDateProperty?:
      | { type: "string"; value: string }
      | { type: "date"; value: string };
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "DateUnionPropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateOrDateTimeProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateOrStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateTimeOrDateProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/stringOrDateProperty`,
          type: "Control",
        },
      ],
      label: "DateUnionPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("DateUnionPropertiesClass"),
      dateOrDateTimeProperty: zod
        .discriminatedUnion("type", [
          zod.object({ type: zod.literal("date"), value: zod.iso.date() }),
          zod.object({
            type: zod.literal("dateTime"),
            value: zod.iso.datetime(),
          }),
        ])
        .optional(),
      dateOrStringProperty: zod
        .discriminatedUnion("type", [
          zod.object({ type: zod.literal("date"), value: zod.iso.date() }),
          zod.object({ type: zod.literal("string"), value: zod.string() }),
        ])
        .optional(),
      dateTimeOrDateProperty: zod
        .discriminatedUnion("type", [
          zod.object({
            type: zod.literal("dateTime"),
            value: zod.iso.datetime(),
          }),
          zod.object({ type: zod.literal("date"), value: zod.iso.date() }),
        ])
        .optional(),
      stringOrDateProperty: zod
        .discriminatedUnion("type", [
          zod.object({ type: zod.literal("string"), value: zod.string() }),
          zod.object({ type: zod.literal("date"), value: zod.iso.date() }),
        ])
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    dateOrDateTimeProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/dateOrDateTimeProperty",
      ),
    },
    dateOrStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/dateOrStringProperty",
      ),
    },
    dateTimeOrDateProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/dateTimeOrDateProperty",
      ),
    },
    stringOrDateProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/stringOrDateProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      dateOrDateTimeProperty: purify.Maybe<
        { type: "date"; value: Date } | { type: "dateTime"; value: Date }
      >;
      dateOrStringProperty: purify.Maybe<
        { type: "date"; value: Date } | { type: "string"; value: string }
      >;
      dateTimeOrDateProperty: purify.Maybe<
        { type: "dateTime"; value: Date } | { type: "date"; value: Date }
      >;
      stringOrDateProperty: purify.Maybe<
        { type: "string"; value: string } | { type: "date"; value: Date }
      >;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const dateOrDateTimeProperty = purify.Maybe.fromNullable(
      $jsonObject["dateOrDateTimeProperty"],
    ).map((item) =>
      item.type === "dateTime"
        ? { type: "dateTime" as const, value: new Date(item.value) }
        : { type: "date" as const, value: new Date(item.value) },
    );
    const dateOrStringProperty = purify.Maybe.fromNullable(
      $jsonObject["dateOrStringProperty"],
    ).map((item) =>
      item.type === "string"
        ? { type: "string" as const, value: item.value }
        : { type: "date" as const, value: new Date(item.value) },
    );
    const dateTimeOrDateProperty = purify.Maybe.fromNullable(
      $jsonObject["dateTimeOrDateProperty"],
    ).map((item) =>
      item.type === "date"
        ? { type: "date" as const, value: new Date(item.value) }
        : { type: "dateTime" as const, value: new Date(item.value) },
    );
    const stringOrDateProperty = purify.Maybe.fromNullable(
      $jsonObject["stringOrDateProperty"],
    ).map((item) =>
      item.type === "date"
        ? { type: "date" as const, value: new Date(item.value) }
        : { type: "string" as const, value: item.value },
    );
    return purify.Either.of({
      $identifier,
      dateOrDateTimeProperty,
      dateOrStringProperty,
      dateTimeOrDateProperty,
      stringOrDateProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      dateOrDateTimeProperty: purify.Maybe<
        { type: "date"; value: Date } | { type: "dateTime"; value: Date }
      >;
      dateOrStringProperty: purify.Maybe<
        { type: "date"; value: Date } | { type: "string"; value: string }
      >;
      dateTimeOrDateProperty: purify.Maybe<
        { type: "dateTime"; value: Date } | { type: "date"; value: Date }
      >;
      stringOrDateProperty: purify.Maybe<
        { type: "string"; value: string } | { type: "date"; value: Date }
      >;
    }
  > {
    return purify.Either.of<Error, DateUnionPropertiesClass.$Identifier>(
      $parameters.resource.identifier as DateUnionPropertiesClass.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.dateOrDateTimeProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          values.chainMap((value) => {
            const valueAsValues = purify.Either.of(value.toValues());
            return (
              valueAsValues
                .chain((values) => values.chainMap((value) => value.toDate()))
                .map((values) =>
                  values.map(
                    (value) =>
                      ({ type: "date" as const, value }) as
                        | { type: "date"; value: Date }
                        | { type: "dateTime"; value: Date },
                  ),
                ) as purify.Either<
                Error,
                rdfjsResource.Resource.Values<
                  | { type: "date"; value: Date }
                  | { type: "dateTime"; value: Date }
                >
              >
            )
              .altLazy(
                () =>
                  valueAsValues
                    .chain((values) =>
                      values.chainMap((value) => value.toDate()),
                    )
                    .map((values) =>
                      values.map(
                        (value) =>
                          ({ type: "dateTime" as const, value }) as
                            | { type: "date"; value: Date }
                            | { type: "dateTime"; value: Date },
                      ),
                    ) as purify.Either<
                    Error,
                    rdfjsResource.Resource.Values<
                      | { type: "date"; value: Date }
                      | { type: "dateTime"; value: Date }
                    >
                  >,
              )
              .chain((values) => values.head());
          }),
        )
        .map((values) =>
          values.length > 0
            ? values.map((value) => purify.Maybe.of(value))
            : rdfjsResource.Resource.Values.fromValue<
                purify.Maybe<
                  | { type: "date"; value: Date }
                  | { type: "dateTime"; value: Date }
                >
              >({
                focusResource: $parameters.resource,
                predicate:
                  DateUnionPropertiesClass.$properties.dateOrDateTimeProperty[
                    "identifier"
                  ],
                value: purify.Maybe.empty(),
              }),
        )
        .chain((values) => values.head())
        .chain((dateOrDateTimeProperty) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.dateOrStringProperty["identifier"],
              { unique: true },
            ),
          )
            .chain((values) =>
              values.chainMap((value) => {
                const valueAsValues = purify.Either.of(value.toValues());
                return (
                  valueAsValues
                    .chain((values) =>
                      values.chainMap((value) => value.toDate()),
                    )
                    .map((values) =>
                      values.map(
                        (value) =>
                          ({ type: "date" as const, value }) as
                            | { type: "date"; value: Date }
                            | { type: "string"; value: string },
                      ),
                    ) as purify.Either<
                    Error,
                    rdfjsResource.Resource.Values<
                      | { type: "date"; value: Date }
                      | { type: "string"; value: string }
                    >
                  >
                )
                  .altLazy(
                    () =>
                      valueAsValues
                        .chain((values) =>
                          $fromRdfPreferredLanguages({
                            focusResource: $parameters.resource,
                            predicate:
                              DateUnionPropertiesClass.$properties
                                .dateOrStringProperty["identifier"],
                            preferredLanguages: $parameters.preferredLanguages,
                            values,
                          }),
                        )
                        .chain((values) =>
                          values.chainMap((value) => value.toString()),
                        )
                        .map((values) =>
                          values.map(
                            (value) =>
                              ({ type: "string" as const, value }) as
                                | { type: "date"; value: Date }
                                | { type: "string"; value: string },
                          ),
                        ) as purify.Either<
                        Error,
                        rdfjsResource.Resource.Values<
                          | { type: "date"; value: Date }
                          | { type: "string"; value: string }
                        >
                      >,
                  )
                  .chain((values) => values.head());
              }),
            )
            .map((values) =>
              values.length > 0
                ? values.map((value) => purify.Maybe.of(value))
                : rdfjsResource.Resource.Values.fromValue<
                    purify.Maybe<
                      | { type: "date"; value: Date }
                      | { type: "string"; value: string }
                    >
                  >({
                    focusResource: $parameters.resource,
                    predicate:
                      DateUnionPropertiesClass.$properties.dateOrStringProperty[
                        "identifier"
                      ],
                    value: purify.Maybe.empty(),
                  }),
            )
            .chain((values) => values.head())
            .chain((dateOrStringProperty) =>
              purify.Either.of<
                Error,
                rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
              >(
                $parameters.resource.values(
                  $properties.dateTimeOrDateProperty["identifier"],
                  { unique: true },
                ),
              )
                .chain((values) =>
                  values.chainMap((value) => {
                    const valueAsValues = purify.Either.of(value.toValues());
                    return (
                      valueAsValues
                        .chain((values) =>
                          values.chainMap((value) => value.toDate()),
                        )
                        .map((values) =>
                          values.map(
                            (value) =>
                              ({ type: "dateTime" as const, value }) as
                                | { type: "dateTime"; value: Date }
                                | { type: "date"; value: Date },
                          ),
                        ) as purify.Either<
                        Error,
                        rdfjsResource.Resource.Values<
                          | { type: "dateTime"; value: Date }
                          | { type: "date"; value: Date }
                        >
                      >
                    )
                      .altLazy(
                        () =>
                          valueAsValues
                            .chain((values) =>
                              values.chainMap((value) => value.toDate()),
                            )
                            .map((values) =>
                              values.map(
                                (value) =>
                                  ({ type: "date" as const, value }) as
                                    | { type: "dateTime"; value: Date }
                                    | { type: "date"; value: Date },
                              ),
                            ) as purify.Either<
                            Error,
                            rdfjsResource.Resource.Values<
                              | { type: "dateTime"; value: Date }
                              | { type: "date"; value: Date }
                            >
                          >,
                      )
                      .chain((values) => values.head());
                  }),
                )
                .map((values) =>
                  values.length > 0
                    ? values.map((value) => purify.Maybe.of(value))
                    : rdfjsResource.Resource.Values.fromValue<
                        purify.Maybe<
                          | { type: "dateTime"; value: Date }
                          | { type: "date"; value: Date }
                        >
                      >({
                        focusResource: $parameters.resource,
                        predicate:
                          DateUnionPropertiesClass.$properties
                            .dateTimeOrDateProperty["identifier"],
                        value: purify.Maybe.empty(),
                      }),
                )
                .chain((values) => values.head())
                .chain((dateTimeOrDateProperty) =>
                  purify.Either.of<
                    Error,
                    rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                  >(
                    $parameters.resource.values(
                      $properties.stringOrDateProperty["identifier"],
                      { unique: true },
                    ),
                  )
                    .chain((values) =>
                      values.chainMap((value) => {
                        const valueAsValues = purify.Either.of(
                          value.toValues(),
                        );
                        return (
                          valueAsValues
                            .chain((values) =>
                              $fromRdfPreferredLanguages({
                                focusResource: $parameters.resource,
                                predicate:
                                  DateUnionPropertiesClass.$properties
                                    .stringOrDateProperty["identifier"],
                                preferredLanguages:
                                  $parameters.preferredLanguages,
                                values,
                              }),
                            )
                            .chain((values) =>
                              values.chainMap((value) => value.toString()),
                            )
                            .map((values) =>
                              values.map(
                                (value) =>
                                  ({ type: "string" as const, value }) as
                                    | { type: "string"; value: string }
                                    | { type: "date"; value: Date },
                              ),
                            ) as purify.Either<
                            Error,
                            rdfjsResource.Resource.Values<
                              | { type: "string"; value: string }
                              | { type: "date"; value: Date }
                            >
                          >
                        )
                          .altLazy(
                            () =>
                              valueAsValues
                                .chain((values) =>
                                  values.chainMap((value) => value.toDate()),
                                )
                                .map((values) =>
                                  values.map(
                                    (value) =>
                                      ({ type: "date" as const, value }) as
                                        | { type: "string"; value: string }
                                        | { type: "date"; value: Date },
                                  ),
                                ) as purify.Either<
                                Error,
                                rdfjsResource.Resource.Values<
                                  | { type: "string"; value: string }
                                  | { type: "date"; value: Date }
                                >
                              >,
                          )
                          .chain((values) => values.head());
                      }),
                    )
                    .map((values) =>
                      values.length > 0
                        ? values.map((value) => purify.Maybe.of(value))
                        : rdfjsResource.Resource.Values.fromValue<
                            purify.Maybe<
                              | { type: "string"; value: string }
                              | { type: "date"; value: Date }
                            >
                          >({
                            focusResource: $parameters.resource,
                            predicate:
                              DateUnionPropertiesClass.$properties
                                .stringOrDateProperty["identifier"],
                            value: purify.Maybe.empty(),
                          }),
                    )
                    .chain((values) => values.head())
                    .map((stringOrDateProperty) => ({
                      $identifier,
                      dateOrDateTimeProperty,
                      dateOrStringProperty,
                      dateTimeOrDateProperty,
                      stringOrDateProperty,
                    })),
                ),
            ),
        ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: DateUnionPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        DateUnionPropertiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            DateUnionPropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: DateUnionPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      DateUnionPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("dateUnionPropertiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrDateTimeProperty`,
      ),
      predicate:
        DateUnionPropertiesClass.$properties.dateOrDateTimeProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrStringProperty`,
      ),
      predicate:
        DateUnionPropertiesClass.$properties.dateOrStringProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateTimeOrDateProperty`,
      ),
      predicate:
        DateUnionPropertiesClass.$properties.dateTimeOrDateProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}StringOrDateProperty`,
      ),
      predicate:
        DateUnionPropertiesClass.$properties.stringOrDateProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: DateUnionPropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("dateUnionPropertiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.dateOrDateTimeProperty,
          (itemFilter) => [
            {
              patterns: [
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrDateTimeProperty`,
                          ),
                          predicate:
                            DateUnionPropertiesClass.$properties
                              .dateOrDateTimeProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: $DateFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["date"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrDateTimeProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrDateTimeProperty`,
                          ),
                          predicate:
                            DateUnionPropertiesClass.$properties
                              .dateOrDateTimeProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: $DateFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["dateTime"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrDateTimeProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
              ],
              type: "union",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.dateOrStringProperty,
          (itemFilter) => [
            {
              patterns: [
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrStringProperty`,
                          ),
                          predicate:
                            DateUnionPropertiesClass.$properties
                              .dateOrStringProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: $DateFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["date"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrStringProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrStringProperty`,
                          ),
                          predicate:
                            DateUnionPropertiesClass.$properties
                              .dateOrStringProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: [parameters?.preferredLanguages ?? []]
                        .filter((languages) => languages.length > 0)
                        .map((languages) =>
                          languages.map((language) => ({
                            type: "operation" as const,
                            operator: "=",
                            args: [
                              {
                                type: "operation" as const,
                                operator: "lang",
                                args: [
                                  dataFactory.variable!(
                                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrStringProperty`,
                                  ),
                                ],
                              },
                              dataFactory.literal(language),
                            ],
                          })),
                        )
                        .map((langEqualsExpressions) => ({
                          type: "filter" as const,
                          expression: langEqualsExpressions.reduce(
                            (reducedExpression, langEqualsExpression) => {
                              if (reducedExpression === null) {
                                return langEqualsExpression;
                              }
                              return {
                                type: "operation" as const,
                                operator: "||",
                                args: [reducedExpression, langEqualsExpression],
                              };
                            },
                            null as sparqljs.Expression | null,
                          ) as sparqljs.Expression,
                        }))
                        .concat(),
                      type: "group",
                    },
                    {
                      patterns: $StringFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["string"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrStringProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
              ],
              type: "union",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.dateTimeOrDateProperty,
          (itemFilter) => [
            {
              patterns: [
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateTimeOrDateProperty`,
                          ),
                          predicate:
                            DateUnionPropertiesClass.$properties
                              .dateTimeOrDateProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: $DateFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["dateTime"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateTimeOrDateProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateTimeOrDateProperty`,
                          ),
                          predicate:
                            DateUnionPropertiesClass.$properties
                              .dateTimeOrDateProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: $DateFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["date"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateTimeOrDateProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
              ],
              type: "union",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.stringOrDateProperty,
          (itemFilter) => [
            {
              patterns: [
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}StringOrDateProperty`,
                          ),
                          predicate:
                            DateUnionPropertiesClass.$properties
                              .stringOrDateProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: [parameters?.preferredLanguages ?? []]
                        .filter((languages) => languages.length > 0)
                        .map((languages) =>
                          languages.map((language) => ({
                            type: "operation" as const,
                            operator: "=",
                            args: [
                              {
                                type: "operation" as const,
                                operator: "lang",
                                args: [
                                  dataFactory.variable!(
                                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}StringOrDateProperty`,
                                  ),
                                ],
                              },
                              dataFactory.literal(language),
                            ],
                          })),
                        )
                        .map((langEqualsExpressions) => ({
                          type: "filter" as const,
                          expression: langEqualsExpressions.reduce(
                            (reducedExpression, langEqualsExpression) => {
                              if (reducedExpression === null) {
                                return langEqualsExpression;
                              }
                              return {
                                type: "operation" as const,
                                operator: "||",
                                args: [reducedExpression, langEqualsExpression],
                              };
                            },
                            null as sparqljs.Expression | null,
                          ) as sparqljs.Expression,
                        }))
                        .concat(),
                      type: "group",
                    },
                    {
                      patterns: $StringFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["string"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}StringOrDateProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}StringOrDateProperty`,
                          ),
                          predicate:
                            DateUnionPropertiesClass.$properties
                              .stringOrDateProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: $DateFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["date"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}StringOrDateProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
              ],
              type: "union",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    return patterns;
  }

  export function isDateUnionPropertiesClass(
    object: $Object,
  ): object is DateUnionPropertiesClass {
    switch (object.$type) {
      case "DateUnionPropertiesClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape with properties whose types are convertible from other types on construction e.g., string to IRI.
 */
export class ConvertibleTypePropertiesClass {
  private _$identifier?: ConvertibleTypePropertiesClass.$Identifier;
  readonly $type = "ConvertibleTypePropertiesClass";
  readonly convertibleIriNonEmptySetProperty: purify.NonEmptyList<rdfjs.NamedNode>;
  readonly convertibleIriOptionProperty: purify.Maybe<rdfjs.NamedNode>;
  readonly convertibleIriProperty: rdfjs.NamedNode;
  readonly convertibleIriSetProperty: readonly rdfjs.NamedNode[];
  readonly convertibleLiteralNonEmptySetProperty: purify.NonEmptyList<rdfjs.Literal>;
  readonly convertibleLiteralOptionProperty: purify.Maybe<rdfjs.Literal>;
  readonly convertibleLiteralProperty: rdfjs.Literal;
  readonly convertibleLiteralSetProperty: readonly rdfjs.Literal[];
  readonly convertibleTermNonEmptySetProperty: purify.NonEmptyList<
    rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
  >;
  readonly convertibleTermOptionProperty: purify.Maybe<
    rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
  >;
  readonly convertibleTermProperty:
    | rdfjs.BlankNode
    | rdfjs.Literal
    | rdfjs.NamedNode;
  readonly convertibleTermSetProperty: readonly (
    | rdfjs.BlankNode
    | rdfjs.Literal
    | rdfjs.NamedNode
  )[];

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly convertibleIriNonEmptySetProperty: purify.NonEmptyList<rdfjs.NamedNode>;
    readonly convertibleIriOptionProperty?:
      | rdfjs.NamedNode
      | purify.Maybe<rdfjs.NamedNode>
      | string;
    readonly convertibleIriProperty: rdfjs.NamedNode | string;
    readonly convertibleIriSetProperty?:
      | readonly rdfjs.NamedNode[]
      | readonly string[];
    readonly convertibleLiteralNonEmptySetProperty: purify.NonEmptyList<rdfjs.Literal>;
    readonly convertibleLiteralOptionProperty?:
      | rdfjs.Literal
      | Date
      | boolean
      | number
      | purify.Maybe<rdfjs.Literal>
      | string;
    readonly convertibleLiteralProperty:
      | rdfjs.Literal
      | Date
      | boolean
      | number
      | string;
    readonly convertibleLiteralSetProperty?:
      | readonly rdfjs.Literal[]
      | readonly boolean[]
      | readonly number[]
      | readonly string[];
    readonly convertibleTermNonEmptySetProperty: purify.NonEmptyList<
      rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
    >;
    readonly convertibleTermOptionProperty?:
      | (rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode)
      | Date
      | boolean
      | number
      | purify.Maybe<rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode>
      | string;
    readonly convertibleTermProperty:
      | (rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode)
      | Date
      | boolean
      | number
      | string;
    readonly convertibleTermSetProperty?:
      | readonly (rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode)[]
      | readonly boolean[]
      | readonly number[]
      | readonly string[];
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.convertibleIriNonEmptySetProperty =
      parameters.convertibleIriNonEmptySetProperty;
    if (purify.Maybe.isMaybe(parameters.convertibleIriOptionProperty)) {
      this.convertibleIriOptionProperty =
        parameters.convertibleIriOptionProperty;
    } else if (typeof parameters.convertibleIriOptionProperty === "object") {
      this.convertibleIriOptionProperty = purify.Maybe.of(
        parameters.convertibleIriOptionProperty,
      );
    } else if (typeof parameters.convertibleIriOptionProperty === "string") {
      this.convertibleIriOptionProperty = purify.Maybe.of(
        dataFactory.namedNode(parameters.convertibleIriOptionProperty),
      );
    } else if (typeof parameters.convertibleIriOptionProperty === "undefined") {
      this.convertibleIriOptionProperty = purify.Maybe.empty();
    } else {
      this.convertibleIriOptionProperty =
        parameters.convertibleIriOptionProperty satisfies never;
    }

    if (typeof parameters.convertibleIriProperty === "object") {
      this.convertibleIriProperty = parameters.convertibleIriProperty;
    } else if (typeof parameters.convertibleIriProperty === "string") {
      this.convertibleIriProperty = dataFactory.namedNode(
        parameters.convertibleIriProperty,
      );
    } else {
      this.convertibleIriProperty =
        parameters.convertibleIriProperty satisfies never;
    }

    if (typeof parameters.convertibleIriSetProperty === "undefined") {
      this.convertibleIriSetProperty = [];
    } else if ($isReadonlyObjectArray(parameters.convertibleIriSetProperty)) {
      this.convertibleIriSetProperty = parameters.convertibleIriSetProperty;
    } else if ($isReadonlyStringArray(parameters.convertibleIriSetProperty)) {
      this.convertibleIriSetProperty = parameters.convertibleIriSetProperty.map(
        (item) => dataFactory.namedNode(item),
      );
    } else {
      this.convertibleIriSetProperty =
        parameters.convertibleIriSetProperty satisfies never;
    }

    this.convertibleLiteralNonEmptySetProperty =
      parameters.convertibleLiteralNonEmptySetProperty;
    if (purify.Maybe.isMaybe(parameters.convertibleLiteralOptionProperty)) {
      this.convertibleLiteralOptionProperty =
        parameters.convertibleLiteralOptionProperty;
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "boolean"
    ) {
      this.convertibleLiteralOptionProperty = purify.Maybe.of(
        $toLiteral(parameters.convertibleLiteralOptionProperty),
      );
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "object" &&
      parameters.convertibleLiteralOptionProperty instanceof Date
    ) {
      this.convertibleLiteralOptionProperty = purify.Maybe.of(
        $toLiteral(parameters.convertibleLiteralOptionProperty),
      );
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "number"
    ) {
      this.convertibleLiteralOptionProperty = purify.Maybe.of(
        $toLiteral(parameters.convertibleLiteralOptionProperty),
      );
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "string"
    ) {
      this.convertibleLiteralOptionProperty = purify.Maybe.of(
        $toLiteral(parameters.convertibleLiteralOptionProperty),
      );
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "object"
    ) {
      this.convertibleLiteralOptionProperty = purify.Maybe.of(
        parameters.convertibleLiteralOptionProperty,
      );
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "undefined"
    ) {
      this.convertibleLiteralOptionProperty = purify.Maybe.empty();
    } else {
      this.convertibleLiteralOptionProperty =
        parameters.convertibleLiteralOptionProperty satisfies never;
    }

    if (typeof parameters.convertibleLiteralProperty === "boolean") {
      this.convertibleLiteralProperty = $toLiteral(
        parameters.convertibleLiteralProperty,
      );
    } else if (
      typeof parameters.convertibleLiteralProperty === "object" &&
      parameters.convertibleLiteralProperty instanceof Date
    ) {
      this.convertibleLiteralProperty = $toLiteral(
        parameters.convertibleLiteralProperty,
      );
    } else if (typeof parameters.convertibleLiteralProperty === "number") {
      this.convertibleLiteralProperty = $toLiteral(
        parameters.convertibleLiteralProperty,
      );
    } else if (typeof parameters.convertibleLiteralProperty === "string") {
      this.convertibleLiteralProperty = $toLiteral(
        parameters.convertibleLiteralProperty,
      );
    } else if (typeof parameters.convertibleLiteralProperty === "object") {
      this.convertibleLiteralProperty = parameters.convertibleLiteralProperty;
    } else {
      this.convertibleLiteralProperty =
        parameters.convertibleLiteralProperty satisfies never;
    }

    if (typeof parameters.convertibleLiteralSetProperty === "undefined") {
      this.convertibleLiteralSetProperty = [];
    } else if (
      $isReadonlyObjectArray(parameters.convertibleLiteralSetProperty)
    ) {
      this.convertibleLiteralSetProperty =
        parameters.convertibleLiteralSetProperty;
    } else if (
      $isReadonlyBooleanArray(parameters.convertibleLiteralSetProperty)
    ) {
      this.convertibleLiteralSetProperty =
        parameters.convertibleLiteralSetProperty.map((item) =>
          $toLiteral(item),
        );
    } else if (
      $isReadonlyNumberArray(parameters.convertibleLiteralSetProperty)
    ) {
      this.convertibleLiteralSetProperty =
        parameters.convertibleLiteralSetProperty.map((item) =>
          $toLiteral(item),
        );
    } else if (
      $isReadonlyStringArray(parameters.convertibleLiteralSetProperty)
    ) {
      this.convertibleLiteralSetProperty =
        parameters.convertibleLiteralSetProperty.map((item) =>
          $toLiteral(item),
        );
    } else {
      this.convertibleLiteralSetProperty =
        parameters.convertibleLiteralSetProperty satisfies never;
    }

    this.convertibleTermNonEmptySetProperty =
      parameters.convertibleTermNonEmptySetProperty;
    if (purify.Maybe.isMaybe(parameters.convertibleTermOptionProperty)) {
      this.convertibleTermOptionProperty =
        parameters.convertibleTermOptionProperty;
    } else if (typeof parameters.convertibleTermOptionProperty === "boolean") {
      this.convertibleTermOptionProperty = purify.Maybe.of(
        $toLiteral(parameters.convertibleTermOptionProperty),
      );
    } else if (
      typeof parameters.convertibleTermOptionProperty === "object" &&
      parameters.convertibleTermOptionProperty instanceof Date
    ) {
      this.convertibleTermOptionProperty = purify.Maybe.of(
        $toLiteral(parameters.convertibleTermOptionProperty),
      );
    } else if (typeof parameters.convertibleTermOptionProperty === "number") {
      this.convertibleTermOptionProperty = purify.Maybe.of(
        $toLiteral(parameters.convertibleTermOptionProperty),
      );
    } else if (typeof parameters.convertibleTermOptionProperty === "string") {
      this.convertibleTermOptionProperty = purify.Maybe.of(
        $toLiteral(parameters.convertibleTermOptionProperty),
      );
    } else if (typeof parameters.convertibleTermOptionProperty === "object") {
      this.convertibleTermOptionProperty = purify.Maybe.of(
        parameters.convertibleTermOptionProperty,
      );
    } else if (
      typeof parameters.convertibleTermOptionProperty === "undefined"
    ) {
      this.convertibleTermOptionProperty = purify.Maybe.empty();
    } else {
      this.convertibleTermOptionProperty =
        parameters.convertibleTermOptionProperty satisfies never;
    }

    if (typeof parameters.convertibleTermProperty === "boolean") {
      this.convertibleTermProperty = $toLiteral(
        parameters.convertibleTermProperty,
      );
    } else if (
      typeof parameters.convertibleTermProperty === "object" &&
      parameters.convertibleTermProperty instanceof Date
    ) {
      this.convertibleTermProperty = $toLiteral(
        parameters.convertibleTermProperty,
      );
    } else if (typeof parameters.convertibleTermProperty === "number") {
      this.convertibleTermProperty = $toLiteral(
        parameters.convertibleTermProperty,
      );
    } else if (typeof parameters.convertibleTermProperty === "string") {
      this.convertibleTermProperty = $toLiteral(
        parameters.convertibleTermProperty,
      );
    } else if (typeof parameters.convertibleTermProperty === "object") {
      this.convertibleTermProperty = parameters.convertibleTermProperty;
    } else {
      this.convertibleTermProperty =
        parameters.convertibleTermProperty satisfies never;
    }

    if (typeof parameters.convertibleTermSetProperty === "undefined") {
      this.convertibleTermSetProperty = [];
    } else if ($isReadonlyObjectArray(parameters.convertibleTermSetProperty)) {
      this.convertibleTermSetProperty = parameters.convertibleTermSetProperty;
    } else if ($isReadonlyBooleanArray(parameters.convertibleTermSetProperty)) {
      this.convertibleTermSetProperty =
        parameters.convertibleTermSetProperty.map((item) => $toLiteral(item));
    } else if ($isReadonlyNumberArray(parameters.convertibleTermSetProperty)) {
      this.convertibleTermSetProperty =
        parameters.convertibleTermSetProperty.map((item) => $toLiteral(item));
    } else if ($isReadonlyStringArray(parameters.convertibleTermSetProperty)) {
      this.convertibleTermSetProperty =
        parameters.convertibleTermSetProperty.map((item) => $toLiteral(item));
    } else {
      this.convertibleTermSetProperty =
        parameters.convertibleTermSetProperty satisfies never;
    }
  }

  get $identifier(): ConvertibleTypePropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: ConvertibleTypePropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleIriNonEmptySetProperty,
          other.convertibleIriNonEmptySetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleIriNonEmptySetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.convertibleIriOptionProperty,
          other.convertibleIriOptionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleIriOptionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $booleanEquals(
          this.convertibleIriProperty,
          other.convertibleIriProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleIriProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleIriSetProperty,
          other.convertibleIriSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleIriSetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleLiteralNonEmptySetProperty,
          other.convertibleLiteralNonEmptySetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleLiteralNonEmptySetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.convertibleLiteralOptionProperty,
          other.convertibleLiteralOptionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleLiteralOptionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $booleanEquals(
          this.convertibleLiteralProperty,
          other.convertibleLiteralProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleLiteralProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleLiteralSetProperty,
          other.convertibleLiteralSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleLiteralSetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleTermNonEmptySetProperty,
          other.convertibleTermNonEmptySetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleTermNonEmptySetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.convertibleTermOptionProperty,
          other.convertibleTermOptionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleTermOptionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $booleanEquals(
          this.convertibleTermProperty,
          other.convertibleTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleTermSetProperty,
          other.convertibleTermSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleTermSetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    for (const item0 of this.convertibleIriNonEmptySetProperty) {
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }

    this.convertibleIriOptionProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    _hasher.update(this.convertibleIriProperty.termType);
    _hasher.update(this.convertibleIriProperty.value);
    for (const item0 of this.convertibleIriSetProperty) {
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }

    for (const item0 of this.convertibleLiteralNonEmptySetProperty) {
      _hasher.update(item0.datatype.value);
      _hasher.update(item0.language);
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }

    this.convertibleLiteralOptionProperty.ifJust((value0) => {
      _hasher.update(value0.datatype.value);
      _hasher.update(value0.language);
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    _hasher.update(this.convertibleLiteralProperty.datatype.value);
    _hasher.update(this.convertibleLiteralProperty.language);
    _hasher.update(this.convertibleLiteralProperty.termType);
    _hasher.update(this.convertibleLiteralProperty.value);
    for (const item0 of this.convertibleLiteralSetProperty) {
      _hasher.update(item0.datatype.value);
      _hasher.update(item0.language);
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }

    for (const item0 of this.convertibleTermNonEmptySetProperty) {
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }

    this.convertibleTermOptionProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    _hasher.update(this.convertibleTermProperty.termType);
    _hasher.update(this.convertibleTermProperty.value);
    for (const item0 of this.convertibleTermSetProperty) {
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }

    return _hasher;
  }

  $toJson(): ConvertibleTypePropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        convertibleIriNonEmptySetProperty:
          this.convertibleIriNonEmptySetProperty.map((item) => ({
            "@id": item.value,
          })),
        convertibleIriOptionProperty: this.convertibleIriOptionProperty
          .map((item) => ({ "@id": item.value }))
          .extract(),
        convertibleIriProperty: { "@id": this.convertibleIriProperty.value },
        convertibleIriSetProperty: this.convertibleIriSetProperty.map(
          (item) => ({ "@id": item.value }),
        ),
        convertibleLiteralNonEmptySetProperty:
          this.convertibleLiteralNonEmptySetProperty.map((item) => ({
            "@language": item.language.length > 0 ? item.language : undefined,
            "@type":
              item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? item.datatype.value
                : undefined,
            "@value": item.value,
          })),
        convertibleLiteralOptionProperty: this.convertibleLiteralOptionProperty
          .map((item) => ({
            "@language": item.language.length > 0 ? item.language : undefined,
            "@type":
              item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? item.datatype.value
                : undefined,
            "@value": item.value,
          }))
          .extract(),
        convertibleLiteralProperty: {
          "@language":
            this.convertibleLiteralProperty.language.length > 0
              ? this.convertibleLiteralProperty.language
              : undefined,
          "@type":
            this.convertibleLiteralProperty.datatype.value !==
            "http://www.w3.org/2001/XMLSchema#string"
              ? this.convertibleLiteralProperty.datatype.value
              : undefined,
          "@value": this.convertibleLiteralProperty.value,
        },
        convertibleLiteralSetProperty: this.convertibleLiteralSetProperty.map(
          (item) => ({
            "@language": item.language.length > 0 ? item.language : undefined,
            "@type":
              item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? item.datatype.value
                : undefined,
            "@value": item.value,
          }),
        ),
        convertibleTermNonEmptySetProperty:
          this.convertibleTermNonEmptySetProperty.map((item) =>
            item.termType === "NamedNode"
              ? { "@id": item.value, termType: "NamedNode" as const }
              : item.termType === "Literal"
                ? {
                    "@language":
                      item.language.length > 0 ? item.language : undefined,
                    "@type":
                      item.datatype.value !==
                      "http://www.w3.org/2001/XMLSchema#string"
                        ? item.datatype.value
                        : undefined,
                    "@value": item.value,
                    termType: "Literal" as const,
                  }
                : { "@id": `_:${item.value}`, termType: "BlankNode" as const },
          ),
        convertibleTermOptionProperty: this.convertibleTermOptionProperty
          .map((item) =>
            item.termType === "NamedNode"
              ? { "@id": item.value, termType: "NamedNode" as const }
              : item.termType === "Literal"
                ? {
                    "@language":
                      item.language.length > 0 ? item.language : undefined,
                    "@type":
                      item.datatype.value !==
                      "http://www.w3.org/2001/XMLSchema#string"
                        ? item.datatype.value
                        : undefined,
                    "@value": item.value,
                    termType: "Literal" as const,
                  }
                : { "@id": `_:${item.value}`, termType: "BlankNode" as const },
          )
          .extract(),
        convertibleTermProperty:
          this.convertibleTermProperty.termType === "NamedNode"
            ? {
                "@id": this.convertibleTermProperty.value,
                termType: "NamedNode" as const,
              }
            : this.convertibleTermProperty.termType === "Literal"
              ? {
                  "@language":
                    this.convertibleTermProperty.language.length > 0
                      ? this.convertibleTermProperty.language
                      : undefined,
                  "@type":
                    this.convertibleTermProperty.datatype.value !==
                    "http://www.w3.org/2001/XMLSchema#string"
                      ? this.convertibleTermProperty.datatype.value
                      : undefined,
                  "@value": this.convertibleTermProperty.value,
                  termType: "Literal" as const,
                }
              : {
                  "@id": `_:${this.convertibleTermProperty.value}`,
                  termType: "BlankNode" as const,
                },
        convertibleTermSetProperty: this.convertibleTermSetProperty.map(
          (item) =>
            item.termType === "NamedNode"
              ? { "@id": item.value, termType: "NamedNode" as const }
              : item.termType === "Literal"
                ? {
                    "@language":
                      item.language.length > 0 ? item.language : undefined,
                    "@type":
                      item.datatype.value !==
                      "http://www.w3.org/2001/XMLSchema#string"
                        ? item.datatype.value
                        : undefined,
                    "@value": item.value,
                    termType: "Literal" as const,
                  }
                : { "@id": `_:${item.value}`, termType: "BlankNode" as const },
        ),
      } satisfies ConvertibleTypePropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/ConvertibleTypePropertiesClass",
        ),
      );
    }

    resource.add(
      ConvertibleTypePropertiesClass.$properties
        .convertibleIriNonEmptySetProperty["identifier"],
      ...this.convertibleIriNonEmptySetProperty.flatMap((item) => [item]),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleIriOptionProperty[
        "identifier"
      ],
      ...this.convertibleIriOptionProperty.toList(),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleIriProperty[
        "identifier"
      ],
      ...[this.convertibleIriProperty],
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleIriSetProperty[
        "identifier"
      ],
      ...this.convertibleIriSetProperty.flatMap((item) => [item]),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties
        .convertibleLiteralNonEmptySetProperty["identifier"],
      ...this.convertibleLiteralNonEmptySetProperty.flatMap((item) => [item]),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties
        .convertibleLiteralOptionProperty["identifier"],
      ...this.convertibleLiteralOptionProperty.toList(),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleLiteralProperty[
        "identifier"
      ],
      ...[this.convertibleLiteralProperty],
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleLiteralSetProperty[
        "identifier"
      ],
      ...this.convertibleLiteralSetProperty.flatMap((item) => [item]),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties
        .convertibleTermNonEmptySetProperty["identifier"],
      ...this.convertibleTermNonEmptySetProperty.flatMap((item) => [item]),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleTermOptionProperty[
        "identifier"
      ],
      ...this.convertibleTermOptionProperty.toList(),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleTermProperty[
        "identifier"
      ],
      ...[this.convertibleTermProperty],
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleTermSetProperty[
        "identifier"
      ],
      ...this.convertibleTermSetProperty.flatMap((item) => [item]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ConvertibleTypePropertiesClass {
  export function $filter(
    filter: ConvertibleTypePropertiesClass.$Filter,
    value: ConvertibleTypePropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.convertibleIriNonEmptySetProperty !== "undefined" &&
      !$filterArray<rdfjs.NamedNode, $NamedNodeFilter>($filterNamedNode)(
        filter.convertibleIriNonEmptySetProperty,
        value.convertibleIriNonEmptySetProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleIriOptionProperty !== "undefined" &&
      !$filterMaybe<rdfjs.NamedNode, $NamedNodeFilter>($filterNamedNode)(
        filter.convertibleIriOptionProperty,
        value.convertibleIriOptionProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleIriProperty !== "undefined" &&
      !$filterNamedNode(
        filter.convertibleIriProperty,
        value.convertibleIriProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleIriSetProperty !== "undefined" &&
      !$filterArray<rdfjs.NamedNode, $NamedNodeFilter>($filterNamedNode)(
        filter.convertibleIriSetProperty,
        value.convertibleIriSetProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleLiteralNonEmptySetProperty !== "undefined" &&
      !$filterArray<rdfjs.Literal, $LiteralFilter>($filterLiteral)(
        filter.convertibleLiteralNonEmptySetProperty,
        value.convertibleLiteralNonEmptySetProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleLiteralOptionProperty !== "undefined" &&
      !$filterMaybe<rdfjs.Literal, $LiteralFilter>($filterLiteral)(
        filter.convertibleLiteralOptionProperty,
        value.convertibleLiteralOptionProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleLiteralProperty !== "undefined" &&
      !$filterLiteral(
        filter.convertibleLiteralProperty,
        value.convertibleLiteralProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleLiteralSetProperty !== "undefined" &&
      !$filterArray<rdfjs.Literal, $LiteralFilter>($filterLiteral)(
        filter.convertibleLiteralSetProperty,
        value.convertibleLiteralSetProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleTermNonEmptySetProperty !== "undefined" &&
      !$filterArray<
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode,
        $TermFilter
      >($filterTerm)(
        filter.convertibleTermNonEmptySetProperty,
        value.convertibleTermNonEmptySetProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleTermOptionProperty !== "undefined" &&
      !$filterMaybe<
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode,
        $TermFilter
      >($filterTerm)(
        filter.convertibleTermOptionProperty,
        value.convertibleTermOptionProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleTermProperty !== "undefined" &&
      !$filterTerm(
        filter.convertibleTermProperty,
        value.convertibleTermProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleTermSetProperty !== "undefined" &&
      !$filterArray<
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode,
        $TermFilter
      >($filterTerm)(
        filter.convertibleTermSetProperty,
        value.convertibleTermSetProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly convertibleIriNonEmptySetProperty?: $CollectionFilter<$NamedNodeFilter>;
    readonly convertibleIriOptionProperty?: $MaybeFilter<$NamedNodeFilter>;
    readonly convertibleIriProperty?: $NamedNodeFilter;
    readonly convertibleIriSetProperty?: $CollectionFilter<$NamedNodeFilter>;
    readonly convertibleLiteralNonEmptySetProperty?: $CollectionFilter<$LiteralFilter>;
    readonly convertibleLiteralOptionProperty?: $MaybeFilter<$LiteralFilter>;
    readonly convertibleLiteralProperty?: $LiteralFilter;
    readonly convertibleLiteralSetProperty?: $CollectionFilter<$LiteralFilter>;
    readonly convertibleTermNonEmptySetProperty?: $CollectionFilter<$TermFilter>;
    readonly convertibleTermOptionProperty?: $MaybeFilter<$TermFilter>;
    readonly convertibleTermProperty?: $TermFilter;
    readonly convertibleTermSetProperty?: $CollectionFilter<$TermFilter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ConvertibleTypePropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ConvertibleTypePropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ConvertibleTypePropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ConvertibleTypePropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ConvertibleTypePropertiesClass(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ConvertibleTypePropertiesClass",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ConvertibleTypePropertiesClass";
    readonly convertibleIriNonEmptySetProperty: readonly {
      readonly "@id": string;
    }[];
    readonly convertibleIriOptionProperty?: { readonly "@id": string };
    readonly convertibleIriProperty: { readonly "@id": string };
    readonly convertibleIriSetProperty?: readonly { readonly "@id": string }[];
    readonly convertibleLiteralNonEmptySetProperty: readonly {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    }[];
    readonly convertibleLiteralOptionProperty?: {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    };
    readonly convertibleLiteralProperty: {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    };
    readonly convertibleLiteralSetProperty?: readonly {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    }[];
    readonly convertibleTermNonEmptySetProperty: readonly (
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly "@type"?: string;
          readonly "@value": string;
          readonly termType: "Literal";
        }
    )[];
    readonly convertibleTermOptionProperty?:
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly "@type"?: string;
          readonly "@value": string;
          readonly termType: "Literal";
        };
    readonly convertibleTermProperty:
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly "@type"?: string;
          readonly "@value": string;
          readonly termType: "Literal";
        };
    readonly convertibleTermSetProperty?: readonly (
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly "@type"?: string;
          readonly "@value": string;
          readonly termType: "Literal";
        }
    )[];
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ConvertibleTypePropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleIriNonEmptySetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleIriOptionProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleIriProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleIriSetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleLiteralNonEmptySetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleLiteralOptionProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleLiteralProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleLiteralSetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleTermNonEmptySetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleTermOptionProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleTermSetProperty`,
          type: "Control",
        },
      ],
      label: "ConvertibleTypePropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("ConvertibleTypePropertiesClass"),
      convertibleIriNonEmptySetProperty: zod
        .object({ "@id": zod.string().min(1) })
        .array()
        .nonempty()
        .min(1),
      convertibleIriOptionProperty: zod
        .object({ "@id": zod.string().min(1) })
        .optional(),
      convertibleIriProperty: zod.object({ "@id": zod.string().min(1) }),
      convertibleIriSetProperty: zod
        .object({ "@id": zod.string().min(1) })
        .array()
        .default(() => []),
      convertibleLiteralNonEmptySetProperty: zod
        .object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
        })
        .array()
        .nonempty()
        .min(1),
      convertibleLiteralOptionProperty: zod
        .object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
        })
        .optional(),
      convertibleLiteralProperty: zod.object({
        "@language": zod.string().optional(),
        "@type": zod.string().optional(),
        "@value": zod.string(),
      }),
      convertibleLiteralSetProperty: zod
        .object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
        })
        .array()
        .default(() => []),
      convertibleTermNonEmptySetProperty: zod
        .discriminatedUnion("termType", [
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("BlankNode"),
          }),
          zod.object({
            "@language": zod.string().optional(),
            "@type": zod.string().optional(),
            "@value": zod.string(),
            termType: zod.literal("Literal"),
          }),
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("NamedNode"),
          }),
        ])
        .array()
        .nonempty()
        .min(1),
      convertibleTermOptionProperty: zod
        .discriminatedUnion("termType", [
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("BlankNode"),
          }),
          zod.object({
            "@language": zod.string().optional(),
            "@type": zod.string().optional(),
            "@value": zod.string(),
            termType: zod.literal("Literal"),
          }),
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("NamedNode"),
          }),
        ])
        .optional(),
      convertibleTermProperty: zod.discriminatedUnion("termType", [
        zod.object({
          "@id": zod.string().min(1),
          termType: zod.literal("BlankNode"),
        }),
        zod.object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
          termType: zod.literal("Literal"),
        }),
        zod.object({
          "@id": zod.string().min(1),
          termType: zod.literal("NamedNode"),
        }),
      ]),
      convertibleTermSetProperty: zod
        .discriminatedUnion("termType", [
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("BlankNode"),
          }),
          zod.object({
            "@language": zod.string().optional(),
            "@type": zod.string().optional(),
            "@value": zod.string(),
            termType: zod.literal("Literal"),
          }),
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("NamedNode"),
          }),
        ])
        .array()
        .default(() => []),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    convertibleIriNonEmptySetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleIriNonEmptySetProperty",
      ),
    },
    convertibleIriOptionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleIriOptionProperty",
      ),
    },
    convertibleIriProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleIriProperty",
      ),
    },
    convertibleIriSetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleIriSetProperty",
      ),
    },
    convertibleLiteralNonEmptySetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleLiteralNonEmptySetProperty",
      ),
    },
    convertibleLiteralOptionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleLiteralOptionProperty",
      ),
    },
    convertibleLiteralProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleLiteralProperty",
      ),
    },
    convertibleLiteralSetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleLiteralSetProperty",
      ),
    },
    convertibleTermNonEmptySetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleTermNonEmptySetProperty",
      ),
    },
    convertibleTermOptionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleTermOptionProperty",
      ),
    },
    convertibleTermProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleTermProperty",
      ),
    },
    convertibleTermSetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleTermSetProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      convertibleIriNonEmptySetProperty: purify.NonEmptyList<rdfjs.NamedNode>;
      convertibleIriOptionProperty: purify.Maybe<rdfjs.NamedNode>;
      convertibleIriProperty: rdfjs.NamedNode;
      convertibleIriSetProperty: readonly rdfjs.NamedNode[];
      convertibleLiteralNonEmptySetProperty: purify.NonEmptyList<rdfjs.Literal>;
      convertibleLiteralOptionProperty: purify.Maybe<rdfjs.Literal>;
      convertibleLiteralProperty: rdfjs.Literal;
      convertibleLiteralSetProperty: readonly rdfjs.Literal[];
      convertibleTermNonEmptySetProperty: purify.NonEmptyList<
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
      >;
      convertibleTermOptionProperty: purify.Maybe<
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
      >;
      convertibleTermProperty:
        | rdfjs.BlankNode
        | rdfjs.Literal
        | rdfjs.NamedNode;
      convertibleTermSetProperty: readonly (
        | rdfjs.BlankNode
        | rdfjs.Literal
        | rdfjs.NamedNode
      )[];
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const convertibleIriNonEmptySetProperty = purify.NonEmptyList.fromArray(
      $jsonObject["convertibleIriNonEmptySetProperty"],
    )
      .unsafeCoerce()
      .map((item) => dataFactory.namedNode(item["@id"]));
    const convertibleIriOptionProperty = purify.Maybe.fromNullable(
      $jsonObject["convertibleIriOptionProperty"],
    ).map((item) => dataFactory.namedNode(item["@id"]));
    const convertibleIriProperty = dataFactory.namedNode(
      $jsonObject["convertibleIriProperty"]["@id"],
    );
    const convertibleIriSetProperty = $jsonObject[
      "convertibleIriSetProperty"
    ].map((item) => dataFactory.namedNode(item["@id"]));
    const convertibleLiteralNonEmptySetProperty = purify.NonEmptyList.fromArray(
      $jsonObject["convertibleLiteralNonEmptySetProperty"],
    )
      .unsafeCoerce()
      .map((item) =>
        dataFactory.literal(
          item["@value"],
          typeof item["@language"] !== "undefined"
            ? item["@language"]
            : typeof item["@type"] !== "undefined"
              ? dataFactory.namedNode(item["@type"])
              : undefined,
        ),
      );
    const convertibleLiteralOptionProperty = purify.Maybe.fromNullable(
      $jsonObject["convertibleLiteralOptionProperty"],
    ).map((item) =>
      dataFactory.literal(
        item["@value"],
        typeof item["@language"] !== "undefined"
          ? item["@language"]
          : typeof item["@type"] !== "undefined"
            ? dataFactory.namedNode(item["@type"])
            : undefined,
      ),
    );
    const convertibleLiteralProperty = dataFactory.literal(
      $jsonObject["convertibleLiteralProperty"]["@value"],
      typeof $jsonObject["convertibleLiteralProperty"]["@language"] !==
        "undefined"
        ? $jsonObject["convertibleLiteralProperty"]["@language"]
        : typeof $jsonObject["convertibleLiteralProperty"]["@type"] !==
            "undefined"
          ? dataFactory.namedNode(
              $jsonObject["convertibleLiteralProperty"]["@type"],
            )
          : undefined,
    );
    const convertibleLiteralSetProperty = $jsonObject[
      "convertibleLiteralSetProperty"
    ].map((item) =>
      dataFactory.literal(
        item["@value"],
        typeof item["@language"] !== "undefined"
          ? item["@language"]
          : typeof item["@type"] !== "undefined"
            ? dataFactory.namedNode(item["@type"])
            : undefined,
      ),
    );
    const convertibleTermNonEmptySetProperty = purify.NonEmptyList.fromArray(
      $jsonObject["convertibleTermNonEmptySetProperty"],
    )
      .unsafeCoerce()
      .map((item) =>
        item.termType === "NamedNode"
          ? dataFactory.namedNode(item["@id"])
          : item.termType === "Literal"
            ? dataFactory.literal(
                item["@value"],
                typeof item["@language"] !== "undefined"
                  ? item["@language"]
                  : typeof item["@type"] !== "undefined"
                    ? dataFactory.namedNode(item["@type"])
                    : undefined,
              )
            : dataFactory.blankNode(item["@id"].substring(2)),
      );
    const convertibleTermOptionProperty = purify.Maybe.fromNullable(
      $jsonObject["convertibleTermOptionProperty"],
    ).map((item) =>
      item.termType === "NamedNode"
        ? dataFactory.namedNode(item["@id"])
        : item.termType === "Literal"
          ? dataFactory.literal(
              item["@value"],
              typeof item["@language"] !== "undefined"
                ? item["@language"]
                : typeof item["@type"] !== "undefined"
                  ? dataFactory.namedNode(item["@type"])
                  : undefined,
            )
          : dataFactory.blankNode(item["@id"].substring(2)),
    );
    const convertibleTermProperty =
      $jsonObject["convertibleTermProperty"].termType === "NamedNode"
        ? dataFactory.namedNode($jsonObject["convertibleTermProperty"]["@id"])
        : $jsonObject["convertibleTermProperty"].termType === "Literal"
          ? dataFactory.literal(
              $jsonObject["convertibleTermProperty"]["@value"],
              typeof $jsonObject["convertibleTermProperty"]["@language"] !==
                "undefined"
                ? $jsonObject["convertibleTermProperty"]["@language"]
                : typeof $jsonObject["convertibleTermProperty"]["@type"] !==
                    "undefined"
                  ? dataFactory.namedNode(
                      $jsonObject["convertibleTermProperty"]["@type"],
                    )
                  : undefined,
            )
          : dataFactory.blankNode(
              $jsonObject["convertibleTermProperty"]["@id"].substring(2),
            );
    const convertibleTermSetProperty = $jsonObject[
      "convertibleTermSetProperty"
    ].map((item) =>
      item.termType === "NamedNode"
        ? dataFactory.namedNode(item["@id"])
        : item.termType === "Literal"
          ? dataFactory.literal(
              item["@value"],
              typeof item["@language"] !== "undefined"
                ? item["@language"]
                : typeof item["@type"] !== "undefined"
                  ? dataFactory.namedNode(item["@type"])
                  : undefined,
            )
          : dataFactory.blankNode(item["@id"].substring(2)),
    );
    return purify.Either.of({
      $identifier,
      convertibleIriNonEmptySetProperty,
      convertibleIriOptionProperty,
      convertibleIriProperty,
      convertibleIriSetProperty,
      convertibleLiteralNonEmptySetProperty,
      convertibleLiteralOptionProperty,
      convertibleLiteralProperty,
      convertibleLiteralSetProperty,
      convertibleTermNonEmptySetProperty,
      convertibleTermOptionProperty,
      convertibleTermProperty,
      convertibleTermSetProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      convertibleIriNonEmptySetProperty: purify.NonEmptyList<rdfjs.NamedNode>;
      convertibleIriOptionProperty: purify.Maybe<rdfjs.NamedNode>;
      convertibleIriProperty: rdfjs.NamedNode;
      convertibleIriSetProperty: readonly rdfjs.NamedNode[];
      convertibleLiteralNonEmptySetProperty: purify.NonEmptyList<rdfjs.Literal>;
      convertibleLiteralOptionProperty: purify.Maybe<rdfjs.Literal>;
      convertibleLiteralProperty: rdfjs.Literal;
      convertibleLiteralSetProperty: readonly rdfjs.Literal[];
      convertibleTermNonEmptySetProperty: purify.NonEmptyList<
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
      >;
      convertibleTermOptionProperty: purify.Maybe<
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
      >;
      convertibleTermProperty:
        | rdfjs.BlankNode
        | rdfjs.Literal
        | rdfjs.NamedNode;
      convertibleTermSetProperty: readonly (
        | rdfjs.BlankNode
        | rdfjs.Literal
        | rdfjs.NamedNode
      )[];
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/ConvertibleTypePropertiesClass":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  ConvertibleTypePropertiesClass.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ConvertibleTypePropertiesClass)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      purify.Either.of<Error, ConvertibleTypePropertiesClass.$Identifier>(
        $parameters.resource
          .identifier as ConvertibleTypePropertiesClass.$Identifier,
      ).chain(($identifier) =>
        purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
        >(
          $parameters.resource.values(
            $properties.convertibleIriNonEmptySetProperty["identifier"],
            { unique: true },
          ),
        )
          .chain((values) => values.chainMap((value) => value.toIri()))
          .chain((values) =>
            purify.NonEmptyList.fromArray(values.toArray()).toEither(
              new Error(
                `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} is an empty set`,
              ),
            ),
          )
          .map((valuesArray) =>
            rdfjsResource.Resource.Values.fromValue({
              focusResource: $parameters.resource,
              predicate:
                ConvertibleTypePropertiesClass.$properties
                  .convertibleIriNonEmptySetProperty["identifier"],
              value: valuesArray,
            }),
          )
          .chain((values) => values.head())
          .chain((convertibleIriNonEmptySetProperty) =>
            purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
            >(
              $parameters.resource.values(
                $properties.convertibleIriOptionProperty["identifier"],
                { unique: true },
              ),
            )
              .chain((values) => values.chainMap((value) => value.toIri()))
              .map((values) =>
                values.length > 0
                  ? values.map((value) => purify.Maybe.of(value))
                  : rdfjsResource.Resource.Values.fromValue<
                      purify.Maybe<rdfjs.NamedNode>
                    >({
                      focusResource: $parameters.resource,
                      predicate:
                        ConvertibleTypePropertiesClass.$properties
                          .convertibleIriOptionProperty["identifier"],
                      value: purify.Maybe.empty(),
                    }),
              )
              .chain((values) => values.head())
              .chain((convertibleIriOptionProperty) =>
                purify.Either.of<
                  Error,
                  rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                >(
                  $parameters.resource.values(
                    $properties.convertibleIriProperty["identifier"],
                    { unique: true },
                  ),
                )
                  .chain((values) => values.chainMap((value) => value.toIri()))
                  .chain((values) => values.head())
                  .chain((convertibleIriProperty) =>
                    purify.Either.of<
                      Error,
                      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                    >(
                      $parameters.resource.values(
                        $properties.convertibleIriSetProperty["identifier"],
                        { unique: true },
                      ),
                    )
                      .chain((values) =>
                        values.chainMap((value) => value.toIri()),
                      )
                      .map((values) => values.toArray())
                      .map((valuesArray) =>
                        rdfjsResource.Resource.Values.fromValue({
                          focusResource: $parameters.resource,
                          predicate:
                            ConvertibleTypePropertiesClass.$properties
                              .convertibleIriSetProperty["identifier"],
                          value: valuesArray,
                        }),
                      )
                      .chain((values) => values.head())
                      .chain((convertibleIriSetProperty) =>
                        purify.Either.of<
                          Error,
                          rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                        >(
                          $parameters.resource.values(
                            $properties.convertibleLiteralNonEmptySetProperty[
                              "identifier"
                            ],
                            { unique: true },
                          ),
                        )
                          .chain((values) =>
                            $fromRdfPreferredLanguages({
                              focusResource: $parameters.resource,
                              predicate:
                                ConvertibleTypePropertiesClass.$properties
                                  .convertibleLiteralNonEmptySetProperty[
                                  "identifier"
                                ],
                              preferredLanguages:
                                $parameters.preferredLanguages,
                              values,
                            }),
                          )
                          .chain((values) =>
                            values.chainMap((value) => value.toLiteral()),
                          )
                          .chain((values) =>
                            purify.NonEmptyList.fromArray(
                              values.toArray(),
                            ).toEither(
                              new Error(
                                `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} is an empty set`,
                              ),
                            ),
                          )
                          .map((valuesArray) =>
                            rdfjsResource.Resource.Values.fromValue({
                              focusResource: $parameters.resource,
                              predicate:
                                ConvertibleTypePropertiesClass.$properties
                                  .convertibleLiteralNonEmptySetProperty[
                                  "identifier"
                                ],
                              value: valuesArray,
                            }),
                          )
                          .chain((values) => values.head())
                          .chain((convertibleLiteralNonEmptySetProperty) =>
                            purify.Either.of<
                              Error,
                              rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                            >(
                              $parameters.resource.values(
                                $properties.convertibleLiteralOptionProperty[
                                  "identifier"
                                ],
                                { unique: true },
                              ),
                            )
                              .chain((values) =>
                                $fromRdfPreferredLanguages({
                                  focusResource: $parameters.resource,
                                  predicate:
                                    ConvertibleTypePropertiesClass.$properties
                                      .convertibleLiteralOptionProperty[
                                      "identifier"
                                    ],
                                  preferredLanguages:
                                    $parameters.preferredLanguages,
                                  values,
                                }),
                              )
                              .chain((values) =>
                                values.chainMap((value) => value.toLiteral()),
                              )
                              .map((values) =>
                                values.length > 0
                                  ? values.map((value) =>
                                      purify.Maybe.of(value),
                                    )
                                  : rdfjsResource.Resource.Values.fromValue<
                                      purify.Maybe<rdfjs.Literal>
                                    >({
                                      focusResource: $parameters.resource,
                                      predicate:
                                        ConvertibleTypePropertiesClass
                                          .$properties
                                          .convertibleLiteralOptionProperty[
                                          "identifier"
                                        ],
                                      value: purify.Maybe.empty(),
                                    }),
                              )
                              .chain((values) => values.head())
                              .chain((convertibleLiteralOptionProperty) =>
                                purify.Either.of<
                                  Error,
                                  rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                                >(
                                  $parameters.resource.values(
                                    $properties.convertibleLiteralProperty[
                                      "identifier"
                                    ],
                                    { unique: true },
                                  ),
                                )
                                  .chain((values) =>
                                    $fromRdfPreferredLanguages({
                                      focusResource: $parameters.resource,
                                      predicate:
                                        ConvertibleTypePropertiesClass
                                          .$properties
                                          .convertibleLiteralProperty[
                                          "identifier"
                                        ],
                                      preferredLanguages:
                                        $parameters.preferredLanguages,
                                      values,
                                    }),
                                  )
                                  .chain((values) =>
                                    values.chainMap((value) =>
                                      value.toLiteral(),
                                    ),
                                  )
                                  .chain((values) => values.head())
                                  .chain((convertibleLiteralProperty) =>
                                    purify.Either.of<
                                      Error,
                                      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                                    >(
                                      $parameters.resource.values(
                                        $properties
                                          .convertibleLiteralSetProperty[
                                          "identifier"
                                        ],
                                        { unique: true },
                                      ),
                                    )
                                      .chain((values) =>
                                        $fromRdfPreferredLanguages({
                                          focusResource: $parameters.resource,
                                          predicate:
                                            ConvertibleTypePropertiesClass
                                              .$properties
                                              .convertibleLiteralSetProperty[
                                              "identifier"
                                            ],
                                          preferredLanguages:
                                            $parameters.preferredLanguages,
                                          values,
                                        }),
                                      )
                                      .chain((values) =>
                                        values.chainMap((value) =>
                                          value.toLiteral(),
                                        ),
                                      )
                                      .map((values) => values.toArray())
                                      .map((valuesArray) =>
                                        rdfjsResource.Resource.Values.fromValue(
                                          {
                                            focusResource: $parameters.resource,
                                            predicate:
                                              ConvertibleTypePropertiesClass
                                                .$properties
                                                .convertibleLiteralSetProperty[
                                                "identifier"
                                              ],
                                            value: valuesArray,
                                          },
                                        ),
                                      )
                                      .chain((values) => values.head())
                                      .chain((convertibleLiteralSetProperty) =>
                                        purify.Either.of<
                                          Error,
                                          rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                                        >(
                                          $parameters.resource.values(
                                            $properties
                                              .convertibleTermNonEmptySetProperty[
                                              "identifier"
                                            ],
                                            { unique: true },
                                          ),
                                        )
                                          .chain((values) =>
                                            values.chainMap((value) =>
                                              purify.Either.of<
                                                Error,
                                                | rdfjs.BlankNode
                                                | rdfjs.Literal
                                                | rdfjs.NamedNode
                                              >(value.toTerm()),
                                            ),
                                          )
                                          .chain((values) =>
                                            purify.NonEmptyList.fromArray(
                                              values.toArray(),
                                            ).toEither(
                                              new Error(
                                                `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} is an empty set`,
                                              ),
                                            ),
                                          )
                                          .map((valuesArray) =>
                                            rdfjsResource.Resource.Values.fromValue(
                                              {
                                                focusResource:
                                                  $parameters.resource,
                                                predicate:
                                                  ConvertibleTypePropertiesClass
                                                    .$properties
                                                    .convertibleTermNonEmptySetProperty[
                                                    "identifier"
                                                  ],
                                                value: valuesArray,
                                              },
                                            ),
                                          )
                                          .chain((values) => values.head())
                                          .chain(
                                            (
                                              convertibleTermNonEmptySetProperty,
                                            ) =>
                                              purify.Either.of<
                                                Error,
                                                rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                                              >(
                                                $parameters.resource.values(
                                                  $properties
                                                    .convertibleTermOptionProperty[
                                                    "identifier"
                                                  ],
                                                  { unique: true },
                                                ),
                                              )
                                                .chain((values) =>
                                                  values.chainMap((value) =>
                                                    purify.Either.of<
                                                      Error,
                                                      | rdfjs.BlankNode
                                                      | rdfjs.Literal
                                                      | rdfjs.NamedNode
                                                    >(value.toTerm()),
                                                  ),
                                                )
                                                .map((values) =>
                                                  values.length > 0
                                                    ? values.map((value) =>
                                                        purify.Maybe.of(value),
                                                      )
                                                    : rdfjsResource.Resource.Values.fromValue<
                                                        purify.Maybe<
                                                          | rdfjs.BlankNode
                                                          | rdfjs.Literal
                                                          | rdfjs.NamedNode
                                                        >
                                                      >({
                                                        focusResource:
                                                          $parameters.resource,
                                                        predicate:
                                                          ConvertibleTypePropertiesClass
                                                            .$properties
                                                            .convertibleTermOptionProperty[
                                                            "identifier"
                                                          ],
                                                        value:
                                                          purify.Maybe.empty(),
                                                      }),
                                                )
                                                .chain((values) =>
                                                  values.head(),
                                                )
                                                .chain(
                                                  (
                                                    convertibleTermOptionProperty,
                                                  ) =>
                                                    purify.Either.of<
                                                      Error,
                                                      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                                                    >(
                                                      $parameters.resource.values(
                                                        $properties
                                                          .convertibleTermProperty[
                                                          "identifier"
                                                        ],
                                                        { unique: true },
                                                      ),
                                                    )
                                                      .chain((values) =>
                                                        values.chainMap(
                                                          (value) =>
                                                            purify.Either.of<
                                                              Error,
                                                              | rdfjs.BlankNode
                                                              | rdfjs.Literal
                                                              | rdfjs.NamedNode
                                                            >(value.toTerm()),
                                                        ),
                                                      )
                                                      .chain((values) =>
                                                        values.head(),
                                                      )
                                                      .chain(
                                                        (
                                                          convertibleTermProperty,
                                                        ) =>
                                                          purify.Either.of<
                                                            Error,
                                                            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
                                                          >(
                                                            $parameters.resource.values(
                                                              $properties
                                                                .convertibleTermSetProperty[
                                                                "identifier"
                                                              ],
                                                              { unique: true },
                                                            ),
                                                          )
                                                            .chain((values) =>
                                                              values.chainMap(
                                                                (value) =>
                                                                  purify.Either.of<
                                                                    Error,
                                                                    | rdfjs.BlankNode
                                                                    | rdfjs.Literal
                                                                    | rdfjs.NamedNode
                                                                  >(
                                                                    value.toTerm(),
                                                                  ),
                                                              ),
                                                            )
                                                            .map((values) =>
                                                              values.toArray(),
                                                            )
                                                            .map(
                                                              (valuesArray) =>
                                                                rdfjsResource.Resource.Values.fromValue(
                                                                  {
                                                                    focusResource:
                                                                      $parameters.resource,
                                                                    predicate:
                                                                      ConvertibleTypePropertiesClass
                                                                        .$properties
                                                                        .convertibleTermSetProperty[
                                                                        "identifier"
                                                                      ],
                                                                    value:
                                                                      valuesArray,
                                                                  },
                                                                ),
                                                            )
                                                            .chain((values) =>
                                                              values.head(),
                                                            )
                                                            .map(
                                                              (
                                                                convertibleTermSetProperty,
                                                              ) => ({
                                                                $identifier,
                                                                convertibleIriNonEmptySetProperty,
                                                                convertibleIriOptionProperty,
                                                                convertibleIriProperty,
                                                                convertibleIriSetProperty,
                                                                convertibleLiteralNonEmptySetProperty,
                                                                convertibleLiteralOptionProperty,
                                                                convertibleLiteralProperty,
                                                                convertibleLiteralSetProperty,
                                                                convertibleTermNonEmptySetProperty,
                                                                convertibleTermOptionProperty,
                                                                convertibleTermProperty,
                                                                convertibleTermSetProperty,
                                                              }),
                                                            ),
                                                      ),
                                                ),
                                          ),
                                      ),
                                  ),
                              ),
                          ),
                      ),
                  ),
              ),
          ),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ConvertibleTypePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConvertibleTypePropertiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ConvertibleTypePropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ConvertibleTypePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConvertibleTypePropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("convertibleTypePropertiesClass");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriNonEmptySetProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties
          .convertibleIriNonEmptySetProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriOptionProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties.convertibleIriOptionProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties.convertibleIriProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriSetProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties.convertibleIriSetProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralNonEmptySetProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties
          .convertibleLiteralNonEmptySetProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralOptionProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties
          .convertibleLiteralOptionProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties.convertibleLiteralProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralSetProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties
          .convertibleLiteralSetProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermNonEmptySetProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties
          .convertibleTermNonEmptySetProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermOptionProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties
          .convertibleTermOptionProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties.convertibleTermProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermSetProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties.convertibleTermSetProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ConvertibleTypePropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("convertibleTypePropertiesClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ConvertibleTypePropertiesClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriNonEmptySetProperty`,
            ),
            predicate:
              ConvertibleTypePropertiesClass.$properties
                .convertibleIriNonEmptySetProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(
            parameters?.filter?.convertibleIriNonEmptySetProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriNonEmptySetProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.convertibleIriOptionProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriOptionProperty`,
                  ),
                  predicate:
                    ConvertibleTypePropertiesClass.$properties
                      .convertibleIriOptionProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $NamedNodeFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriOptionProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriProperty`,
            ),
            predicate:
              ConvertibleTypePropertiesClass.$properties.convertibleIriProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(
            parameters?.filter?.convertibleIriProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriSetProperty`,
              ),
              predicate:
                ConvertibleTypePropertiesClass.$properties
                  .convertibleIriSetProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: $NamedNodeFilter
            .$sparqlWherePatterns(
              parameters?.filter?.convertibleIriSetProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriSetProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralNonEmptySetProperty`,
            ),
            predicate:
              ConvertibleTypePropertiesClass.$properties
                .convertibleLiteralNonEmptySetProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralNonEmptySetProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $LiteralFilter
          .$sparqlWherePatterns(
            parameters?.filter?.convertibleLiteralNonEmptySetProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralNonEmptySetProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.convertibleLiteralOptionProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralOptionProperty`,
                  ),
                  predicate:
                    ConvertibleTypePropertiesClass.$properties
                      .convertibleLiteralOptionProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [parameters?.preferredLanguages ?? []]
                .filter((languages) => languages.length > 0)
                .map((languages) =>
                  languages.map((language) => ({
                    type: "operation" as const,
                    operator: "=",
                    args: [
                      {
                        type: "operation" as const,
                        operator: "lang",
                        args: [
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralOptionProperty`,
                          ),
                        ],
                      },
                      dataFactory.literal(language),
                    ],
                  })),
                )
                .map((langEqualsExpressions) => ({
                  type: "filter" as const,
                  expression: langEqualsExpressions.reduce(
                    (reducedExpression, langEqualsExpression) => {
                      if (reducedExpression === null) {
                        return langEqualsExpression;
                      }
                      return {
                        type: "operation" as const,
                        operator: "||",
                        args: [reducedExpression, langEqualsExpression],
                      };
                    },
                    null as sparqljs.Expression | null,
                  ) as sparqljs.Expression,
                }))
                .concat(),
              type: "group",
            },
            {
              patterns: $LiteralFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralOptionProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralProperty`,
            ),
            predicate:
              ConvertibleTypePropertiesClass.$properties
                .convertibleLiteralProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $LiteralFilter
          .$sparqlWherePatterns(
            parameters?.filter?.convertibleLiteralProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralSetProperty`,
              ),
              predicate:
                ConvertibleTypePropertiesClass.$properties
                  .convertibleLiteralSetProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: [parameters?.preferredLanguages ?? []]
            .filter((languages) => languages.length > 0)
            .map((languages) =>
              languages.map((language) => ({
                type: "operation" as const,
                operator: "=",
                args: [
                  {
                    type: "operation" as const,
                    operator: "lang",
                    args: [
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralSetProperty`,
                      ),
                    ],
                  },
                  dataFactory.literal(language),
                ],
              })),
            )
            .map((langEqualsExpressions) => ({
              type: "filter" as const,
              expression: langEqualsExpressions.reduce(
                (reducedExpression, langEqualsExpression) => {
                  if (reducedExpression === null) {
                    return langEqualsExpression;
                  }
                  return {
                    type: "operation" as const,
                    operator: "||",
                    args: [reducedExpression, langEqualsExpression],
                  };
                },
                null as sparqljs.Expression | null,
              ) as sparqljs.Expression,
            }))
            .concat(),
          type: "group",
        },
        {
          patterns: $LiteralFilter
            .$sparqlWherePatterns(
              parameters?.filter?.convertibleLiteralSetProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralSetProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermNonEmptySetProperty`,
            ),
            predicate:
              ConvertibleTypePropertiesClass.$properties
                .convertibleTermNonEmptySetProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: $TermFilter
          .$sparqlWherePatterns(
            parameters?.filter?.convertibleTermNonEmptySetProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermNonEmptySetProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.convertibleTermOptionProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermOptionProperty`,
                  ),
                  predicate:
                    ConvertibleTypePropertiesClass.$properties
                      .convertibleTermOptionProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $TermFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermOptionProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermProperty`,
            ),
            predicate:
              ConvertibleTypePropertiesClass.$properties
                .convertibleTermProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: $TermFilter
          .$sparqlWherePatterns(
            parameters?.filter?.convertibleTermProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermSetProperty`,
              ),
              predicate:
                ConvertibleTypePropertiesClass.$properties
                  .convertibleTermSetProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: $TermFilter
            .$sparqlWherePatterns(
              parameters?.filter?.convertibleTermSetProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermSetProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    return patterns;
  }

  export function isConvertibleTypePropertiesClass(
    object: $Object,
  ): object is ConvertibleTypePropertiesClass {
    switch (object.$type) {
      case "ConvertibleTypePropertiesClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Base interface for other node shapes.
 */
export interface BaseInterfaceWithProperties {
  readonly $identifier: BaseInterfaceWithPropertiesStatic.$Identifier;
  readonly $type:
    | "BaseInterfaceWithProperties"
    | "BaseInterfaceWithoutProperties"
    | "ConcreteChildInterface"
    | "ConcreteParentInterface";
  readonly baseInterfaceWithPropertiesProperty: string;
}

export namespace BaseInterfaceWithPropertiesStatic {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly baseInterfaceWithPropertiesProperty: string;
  }): BaseInterfaceWithProperties {
    let $identifier: BaseInterfaceWithPropertiesStatic.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "BaseInterfaceWithProperties" as const;
    const baseInterfaceWithPropertiesProperty =
      parameters.baseInterfaceWithPropertiesProperty;
    return { $identifier, $type, baseInterfaceWithPropertiesProperty };
  }

  export function $equals(
    left: BaseInterfaceWithProperties,
    right: BaseInterfaceWithProperties,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.baseInterfaceWithPropertiesProperty,
          right.baseInterfaceWithPropertiesProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "baseInterfaceWithPropertiesProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export function $filter(
    filter: BaseInterfaceWithPropertiesStatic.$Filter,
    value: BaseInterfaceWithProperties,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.baseInterfaceWithPropertiesProperty !== "undefined" &&
      !$filterString(
        filter.baseInterfaceWithPropertiesProperty,
        value.baseInterfaceWithPropertiesProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly baseInterfaceWithPropertiesProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, BaseInterfaceWithProperties> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, BaseInterfaceWithProperties> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return BaseInterfaceWithPropertiesStatic.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/BaseInterfaceWithProperties",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _baseInterfaceWithProperties: BaseInterfaceWithProperties,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_baseInterfaceWithProperties.$identifier.value);
    _hasher.update(_baseInterfaceWithProperties.$type);
    BaseInterfaceWithPropertiesStatic.$hashShaclProperties(
      _baseInterfaceWithProperties,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _baseInterfaceWithProperties: BaseInterfaceWithProperties,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _baseInterfaceWithProperties.baseInterfaceWithPropertiesProperty,
    );
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type:
      | "BaseInterfaceWithProperties"
      | "BaseInterfaceWithoutProperties"
      | "ConcreteChildInterface"
      | "ConcreteParentInterface";
    readonly baseInterfaceWithPropertiesProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "BaseInterfaceWithProperties" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/baseInterfaceWithPropertiesProperty`,
          type: "Control",
        },
      ],
      label: "BaseInterfaceWithProperties",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.enum([
        "BaseInterfaceWithProperties",
        "BaseInterfaceWithoutProperties",
        "ConcreteChildInterface",
        "ConcreteParentInterface",
      ]),
      baseInterfaceWithPropertiesProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    baseInterfaceWithPropertiesProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/baseInterfaceWithPropertiesProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type:
        | "BaseInterfaceWithProperties"
        | "BaseInterfaceWithoutProperties"
        | "ConcreteChildInterface"
        | "ConcreteParentInterface";
      baseInterfaceWithPropertiesProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "BaseInterfaceWithProperties" as const;
    const baseInterfaceWithPropertiesProperty =
      $jsonObject["baseInterfaceWithPropertiesProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      baseInterfaceWithPropertiesProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type:
        | "BaseInterfaceWithProperties"
        | "BaseInterfaceWithoutProperties"
        | "ConcreteChildInterface"
        | "ConcreteParentInterface";
      baseInterfaceWithPropertiesProperty: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/BaseInterfaceWithProperties":
                case "http://example.com/BaseInterfaceWithoutProperties":
                case "http://example.com/ConcreteParentInterface":
                case "http://example.com/ConcreteChildInterface":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  BaseInterfaceWithPropertiesStatic.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/BaseInterfaceWithProperties)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      purify.Either.of<Error, BaseInterfaceWithPropertiesStatic.$Identifier>(
        $parameters.resource
          .identifier as BaseInterfaceWithPropertiesStatic.$Identifier,
      ).chain(($identifier) =>
        purify.Either.of<Error, "BaseInterfaceWithProperties">(
          "BaseInterfaceWithProperties",
        ).chain(($type) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.baseInterfaceWithPropertiesProperty["identifier"],
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  BaseInterfaceWithPropertiesStatic.$properties
                    .baseInterfaceWithPropertiesProperty["identifier"],
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((baseInterfaceWithPropertiesProperty) => ({
              $identifier,
              $type,
              baseInterfaceWithPropertiesProperty,
            })),
        ),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: BaseInterfaceWithPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BaseInterfaceWithPropertiesStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            BaseInterfaceWithPropertiesStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: BaseInterfaceWithPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BaseInterfaceWithPropertiesStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("baseInterfaceWithProperties");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}BaseInterfaceWithPropertiesProperty`,
      ),
      predicate:
        BaseInterfaceWithPropertiesStatic.$properties
          .baseInterfaceWithPropertiesProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: BaseInterfaceWithPropertiesStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("baseInterfaceWithProperties");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        {
          type: "values" as const,
          values: [
            BaseInterfaceWithPropertiesStatic.$fromRdfType,
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[
              `?${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}FromRdfType`
            ] = identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}FromRdfType`,
          ),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}BaseInterfaceWithPropertiesProperty`,
            ),
            predicate:
              BaseInterfaceWithPropertiesStatic.$properties
                .baseInterfaceWithPropertiesProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}BaseInterfaceWithPropertiesProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.baseInterfaceWithPropertiesProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}BaseInterfaceWithPropertiesProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _baseInterfaceWithProperties: BaseInterfaceWithProperties,
  ): BaseInterfaceWithPropertiesStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _baseInterfaceWithProperties.$identifier.termType === "BlankNode"
            ? `_:${_baseInterfaceWithProperties.$identifier.value}`
            : _baseInterfaceWithProperties.$identifier.value,
        $type: _baseInterfaceWithProperties.$type,
        baseInterfaceWithPropertiesProperty:
          _baseInterfaceWithProperties.baseInterfaceWithPropertiesProperty,
      } satisfies BaseInterfaceWithPropertiesStatic.$Json),
    );
  }

  export function $toRdf(
    _baseInterfaceWithProperties: BaseInterfaceWithProperties,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _baseInterfaceWithProperties.$identifier,
      { mutateGraph },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/BaseInterfaceWithProperties",
        ),
      );
    }

    resource.add(
      BaseInterfaceWithPropertiesStatic.$properties
        .baseInterfaceWithPropertiesProperty["identifier"],
      ...[_baseInterfaceWithProperties.baseInterfaceWithPropertiesProperty],
    );
    return resource;
  }

  export function isBaseInterfaceWithProperties(
    object: $Object,
  ): object is BaseInterfaceWithProperties {
    switch (object.$type) {
      case "BaseInterfaceWithoutProperties":
      case "ConcreteChildInterface":
      case "ConcreteParentInterface":
      case "BaseInterfaceWithProperties":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Base interface for other node shapes. Put the base interface with properties above the base interface without.
 */
export interface BaseInterfaceWithoutProperties
  extends BaseInterfaceWithProperties {
  readonly $identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier;
  readonly $type:
    | "BaseInterfaceWithoutProperties"
    | "ConcreteChildInterface"
    | "ConcreteParentInterface";
}

export namespace BaseInterfaceWithoutPropertiesStatic {
  export function $create(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & Parameters<typeof BaseInterfaceWithPropertiesStatic.$create>[0],
  ): BaseInterfaceWithoutProperties {
    let $identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "BaseInterfaceWithoutProperties" as const;
    return {
      ...BaseInterfaceWithPropertiesStatic.$create(parameters),
      $identifier,
      $type,
    };
  }

  export function $equals(
    left: BaseInterfaceWithoutProperties,
    right: BaseInterfaceWithoutProperties,
  ): $EqualsResult {
    return BaseInterfaceWithPropertiesStatic.$equals(left, right);
  }

  export function $filter(
    filter: BaseInterfaceWithoutPropertiesStatic.$Filter,
    value: BaseInterfaceWithoutProperties,
  ): boolean {
    if (!BaseInterfaceWithPropertiesStatic.$filter(filter, value)) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
  } & BaseInterfaceWithPropertiesStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, BaseInterfaceWithoutProperties> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, BaseInterfaceWithoutProperties> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return BaseInterfaceWithoutPropertiesStatic.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/BaseInterfaceWithoutProperties",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _baseInterfaceWithoutProperties: BaseInterfaceWithoutProperties,
    _hasher: HasherT,
  ): HasherT {
    BaseInterfaceWithoutPropertiesStatic.$hashShaclProperties(
      _baseInterfaceWithoutProperties,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _baseInterfaceWithoutProperties: BaseInterfaceWithoutProperties,
    _hasher: HasherT,
  ): HasherT {
    BaseInterfaceWithPropertiesStatic.$hashShaclProperties(
      _baseInterfaceWithoutProperties,
      _hasher,
    );
    return _hasher;
  }

  export type $Identifier = BaseInterfaceWithPropertiesStatic.$Identifier;
  export const $Identifier = BaseInterfaceWithPropertiesStatic.$Identifier;
  export type $Json = BaseInterfaceWithPropertiesStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseInterfaceWithPropertiesStatic.$jsonUiSchema({ scopePrefix }),
      ],
      label: "BaseInterfaceWithoutProperties",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return BaseInterfaceWithPropertiesStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "BaseInterfaceWithoutProperties",
          "ConcreteChildInterface",
          "ConcreteParentInterface",
        ]),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    ...BaseInterfaceWithPropertiesStatic.$properties,
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type:
        | "BaseInterfaceWithoutProperties"
        | "ConcreteChildInterface"
        | "ConcreteParentInterface";
    } & $UnwrapR<
      ReturnType<typeof BaseInterfaceWithPropertiesStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "BaseInterfaceWithoutProperties" as const;
    return BaseInterfaceWithPropertiesStatic.$propertiesFromJson(
      $jsonObject,
    ).map(($super0) => ({ ...$super0, $identifier, $type }));
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type:
        | "BaseInterfaceWithoutProperties"
        | "ConcreteChildInterface"
        | "ConcreteParentInterface";
    } & $UnwrapR<
      ReturnType<typeof BaseInterfaceWithPropertiesStatic.$propertiesFromRdf>
    >
  > {
    return BaseInterfaceWithPropertiesStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/BaseInterfaceWithoutProperties":
                case "http://example.com/ConcreteParentInterface":
                case "http://example.com/ConcreteChildInterface":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/BaseInterfaceWithoutProperties)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        purify.Either.of<
          Error,
          BaseInterfaceWithoutPropertiesStatic.$Identifier
        >(
          $parameters.resource
            .identifier as BaseInterfaceWithoutPropertiesStatic.$Identifier,
        ).chain(($identifier) =>
          purify.Either.of<Error, "BaseInterfaceWithoutProperties">(
            "BaseInterfaceWithoutProperties",
          ).map(($type) => ({ ...$super0, $identifier, $type })),
        ),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: BaseInterfaceWithoutPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BaseInterfaceWithoutPropertiesStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            BaseInterfaceWithoutPropertiesStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: BaseInterfaceWithoutPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BaseInterfaceWithoutPropertiesStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("baseInterfaceWithoutProperties");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...BaseInterfaceWithPropertiesStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "baseInterfaceWithoutProperties"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithoutProperties")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithoutProperties")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithoutProperties")}RdfClass`,
          ),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: BaseInterfaceWithoutPropertiesStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("baseInterfaceWithoutProperties");
    patterns.push(
      ...BaseInterfaceWithPropertiesStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "baseInterfaceWithoutProperties"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithoutProperties")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        {
          type: "values" as const,
          values: [
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[
              `?${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithoutProperties")}FromRdfType`
            ] = identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithoutProperties")}FromRdfType`,
          ),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithoutProperties")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    return patterns;
  }

  export function $toJson(
    _baseInterfaceWithoutProperties: BaseInterfaceWithoutProperties,
  ): BaseInterfaceWithoutPropertiesStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...BaseInterfaceWithPropertiesStatic.$toJson(
          _baseInterfaceWithoutProperties,
        ),
      } satisfies BaseInterfaceWithoutPropertiesStatic.$Json),
    );
  }

  export function $toRdf(
    _baseInterfaceWithoutProperties: BaseInterfaceWithoutProperties,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = BaseInterfaceWithPropertiesStatic.$toRdf(
      _baseInterfaceWithoutProperties,
      { ignoreRdfType: true, mutateGraph, resourceSet },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/BaseInterfaceWithoutProperties",
        ),
      );
    }

    return resource;
  }

  export function isBaseInterfaceWithoutProperties(
    object: $Object,
  ): object is BaseInterfaceWithoutProperties {
    switch (object.$type) {
      case "ConcreteChildInterface":
      case "ConcreteParentInterface":
      case "BaseInterfaceWithoutProperties":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Interface node shape that inherits the base interface and is the parent of the ConcreteChildInterface.
 */
export interface ConcreteParentInterface
  extends BaseInterfaceWithoutProperties {
  readonly $identifier: ConcreteParentInterfaceStatic.$Identifier;
  readonly $type: "ConcreteParentInterface" | "ConcreteChildInterface";
  readonly concreteParentInterfaceProperty: string;
}

export namespace ConcreteParentInterfaceStatic {
  export function $create(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly concreteParentInterfaceProperty: string;
    } & Parameters<typeof BaseInterfaceWithoutPropertiesStatic.$create>[0],
  ): ConcreteParentInterface {
    let $identifier: ConcreteParentInterfaceStatic.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "ConcreteParentInterface" as const;
    const concreteParentInterfaceProperty =
      parameters.concreteParentInterfaceProperty;
    return {
      ...BaseInterfaceWithoutPropertiesStatic.$create(parameters),
      $identifier,
      $type,
      concreteParentInterfaceProperty,
    };
  }

  export function $equals(
    left: ConcreteParentInterface,
    right: ConcreteParentInterface,
  ): $EqualsResult {
    return BaseInterfaceWithoutPropertiesStatic.$equals(left, right).chain(() =>
      $strictEquals(
        left.concreteParentInterfaceProperty,
        right.concreteParentInterfaceProperty,
      ).mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "concreteParentInterfaceProperty",
        propertyValuesUnequal,
        type: "Property" as const,
      })),
    );
  }

  export function $filter(
    filter: ConcreteParentInterfaceStatic.$Filter,
    value: ConcreteParentInterface,
  ): boolean {
    if (!BaseInterfaceWithoutPropertiesStatic.$filter(filter, value)) {
      return false;
    }

    if (
      typeof filter.concreteParentInterfaceProperty !== "undefined" &&
      !$filterString(
        filter.concreteParentInterfaceProperty,
        value.concreteParentInterfaceProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly concreteParentInterfaceProperty?: $StringFilter;
  } & BaseInterfaceWithoutPropertiesStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ConcreteParentInterface> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ConcreteParentInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ConcreteParentInterfaceStatic.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ConcreteParentInterface",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _concreteParentInterface: ConcreteParentInterface,
    _hasher: HasherT,
  ): HasherT {
    ConcreteParentInterfaceStatic.$hashShaclProperties(
      _concreteParentInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _concreteParentInterface: ConcreteParentInterface,
    _hasher: HasherT,
  ): HasherT {
    BaseInterfaceWithoutPropertiesStatic.$hashShaclProperties(
      _concreteParentInterface,
      _hasher,
    );
    _hasher.update(_concreteParentInterface.concreteParentInterfaceProperty);
    return _hasher;
  }

  export type $Identifier = BaseInterfaceWithoutPropertiesStatic.$Identifier;
  export const $Identifier = BaseInterfaceWithoutPropertiesStatic.$Identifier;
  export type $Json = {
    readonly concreteParentInterfaceProperty: string;
  } & BaseInterfaceWithoutPropertiesStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseInterfaceWithoutPropertiesStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/concreteParentInterfaceProperty`,
          type: "Control",
        },
      ],
      label: "ConcreteParentInterface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return BaseInterfaceWithoutPropertiesStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["ConcreteParentInterface", "ConcreteChildInterface"]),
        concreteParentInterfaceProperty: zod.string(),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    ...BaseInterfaceWithoutPropertiesStatic.$properties,
    concreteParentInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/concreteParentInterfaceProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "ConcreteParentInterface" | "ConcreteChildInterface";
      concreteParentInterfaceProperty: string;
    } & $UnwrapR<
      ReturnType<
        typeof BaseInterfaceWithoutPropertiesStatic.$propertiesFromJson
      >
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "ConcreteParentInterface" as const;
    const concreteParentInterfaceProperty =
      $jsonObject["concreteParentInterfaceProperty"];
    return BaseInterfaceWithoutPropertiesStatic.$propertiesFromJson(
      $jsonObject,
    ).map(($super0) => ({
      ...$super0,
      $identifier,
      $type,
      concreteParentInterfaceProperty,
    }));
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "ConcreteParentInterface" | "ConcreteChildInterface";
      concreteParentInterfaceProperty: string;
    } & $UnwrapR<
      ReturnType<typeof BaseInterfaceWithoutPropertiesStatic.$propertiesFromRdf>
    >
  > {
    return BaseInterfaceWithoutPropertiesStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/ConcreteParentInterface":
                case "http://example.com/ConcreteChildInterface":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  ConcreteParentInterfaceStatic.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ConcreteParentInterface)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        purify.Either.of<Error, ConcreteParentInterfaceStatic.$Identifier>(
          $parameters.resource
            .identifier as ConcreteParentInterfaceStatic.$Identifier,
        ).chain(($identifier) =>
          purify.Either.of<Error, "ConcreteParentInterface">(
            "ConcreteParentInterface",
          ).chain(($type) =>
            purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
            >(
              $parameters.resource.values(
                $properties.concreteParentInterfaceProperty["identifier"],
                { unique: true },
              ),
            )
              .chain((values) =>
                $fromRdfPreferredLanguages({
                  focusResource: $parameters.resource,
                  predicate:
                    ConcreteParentInterfaceStatic.$properties
                      .concreteParentInterfaceProperty["identifier"],
                  preferredLanguages: $parameters.preferredLanguages,
                  values,
                }),
              )
              .chain((values) => values.chainMap((value) => value.toString()))
              .chain((values) => values.head())
              .map((concreteParentInterfaceProperty) => ({
                ...$super0,
                $identifier,
                $type,
                concreteParentInterfaceProperty,
              })),
          ),
        ),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ConcreteParentInterfaceStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConcreteParentInterfaceStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ConcreteParentInterfaceStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ConcreteParentInterfaceStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConcreteParentInterfaceStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteParentInterface");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...BaseInterfaceWithoutPropertiesStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteParentInterface"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}ConcreteParentInterfaceProperty`,
      ),
      predicate:
        ConcreteParentInterfaceStatic.$properties
          .concreteParentInterfaceProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ConcreteParentInterfaceStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteParentInterface");
    patterns.push(
      ...BaseInterfaceWithoutPropertiesStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteParentInterface"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        {
          type: "values" as const,
          values: [
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[
              `?${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}FromRdfType`
            ] = identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}FromRdfType`,
          ),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}ConcreteParentInterfaceProperty`,
            ),
            predicate:
              ConcreteParentInterfaceStatic.$properties
                .concreteParentInterfaceProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}ConcreteParentInterfaceProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.concreteParentInterfaceProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}ConcreteParentInterfaceProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _concreteParentInterface: ConcreteParentInterface,
  ): ConcreteParentInterfaceStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...BaseInterfaceWithoutPropertiesStatic.$toJson(
          _concreteParentInterface,
        ),
        concreteParentInterfaceProperty:
          _concreteParentInterface.concreteParentInterfaceProperty,
      } satisfies ConcreteParentInterfaceStatic.$Json),
    );
  }

  export function $toRdf(
    _concreteParentInterface: ConcreteParentInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = BaseInterfaceWithoutPropertiesStatic.$toRdf(
      _concreteParentInterface,
      { ignoreRdfType: true, mutateGraph, resourceSet },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/ConcreteParentInterface",
        ),
      );
    }

    resource.add(
      ConcreteParentInterfaceStatic.$properties.concreteParentInterfaceProperty[
        "identifier"
      ],
      ...[_concreteParentInterface.concreteParentInterfaceProperty],
    );
    return resource;
  }

  export function isConcreteParentInterface(
    object: $Object,
  ): object is ConcreteParentInterface {
    switch (object.$type) {
      case "ConcreteChildInterface":
      case "ConcreteParentInterface":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Child interface of ConcreteParentInterface. Should inherit properties and node kinds.
 */
export interface ConcreteChildInterface extends ConcreteParentInterface {
  readonly $identifier: ConcreteChildInterface.$Identifier;
  readonly $type: "ConcreteChildInterface";
  readonly concreteChildInterfaceProperty: string;
}

export namespace ConcreteChildInterface {
  export function $create(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly concreteChildInterfaceProperty: string;
    } & Parameters<typeof ConcreteParentInterfaceStatic.$create>[0],
  ): ConcreteChildInterface {
    let $identifier: ConcreteChildInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "ConcreteChildInterface" as const;
    const concreteChildInterfaceProperty =
      parameters.concreteChildInterfaceProperty;
    return {
      ...ConcreteParentInterfaceStatic.$create(parameters),
      $identifier,
      $type,
      concreteChildInterfaceProperty,
    };
  }

  export function $equals(
    left: ConcreteChildInterface,
    right: ConcreteChildInterface,
  ): $EqualsResult {
    return ConcreteParentInterfaceStatic.$equals(left, right).chain(() =>
      $strictEquals(
        left.concreteChildInterfaceProperty,
        right.concreteChildInterfaceProperty,
      ).mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "concreteChildInterfaceProperty",
        propertyValuesUnequal,
        type: "Property" as const,
      })),
    );
  }

  export function $filter(
    filter: ConcreteChildInterface.$Filter,
    value: ConcreteChildInterface,
  ): boolean {
    if (!ConcreteParentInterfaceStatic.$filter(filter, value)) {
      return false;
    }

    if (
      typeof filter.concreteChildInterfaceProperty !== "undefined" &&
      !$filterString(
        filter.concreteChildInterfaceProperty,
        value.concreteChildInterfaceProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly concreteChildInterfaceProperty?: $StringFilter;
  } & ConcreteParentInterfaceStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ConcreteChildInterface> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ConcreteChildInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ConcreteChildInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ConcreteChildInterface",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _concreteChildInterface: ConcreteChildInterface,
    _hasher: HasherT,
  ): HasherT {
    ConcreteChildInterface.$hashShaclProperties(
      _concreteChildInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _concreteChildInterface: ConcreteChildInterface,
    _hasher: HasherT,
  ): HasherT {
    ConcreteParentInterfaceStatic.$hashShaclProperties(
      _concreteChildInterface,
      _hasher,
    );
    _hasher.update(_concreteChildInterface.concreteChildInterfaceProperty);
    return _hasher;
  }

  export type $Identifier = ConcreteParentInterfaceStatic.$Identifier;
  export const $Identifier = ConcreteParentInterfaceStatic.$Identifier;
  export type $Json = {
    readonly concreteChildInterfaceProperty: string;
  } & ConcreteParentInterfaceStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ConcreteParentInterfaceStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/concreteChildInterfaceProperty`,
          type: "Control",
        },
      ],
      label: "ConcreteChildInterface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ConcreteParentInterfaceStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("ConcreteChildInterface"),
        concreteChildInterfaceProperty: zod.string(),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    ...ConcreteParentInterfaceStatic.$properties,
    concreteChildInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/concreteChildInterfaceProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "ConcreteChildInterface";
      concreteChildInterfaceProperty: string;
    } & $UnwrapR<
      ReturnType<typeof ConcreteParentInterfaceStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "ConcreteChildInterface" as const;
    const concreteChildInterfaceProperty =
      $jsonObject["concreteChildInterfaceProperty"];
    return ConcreteParentInterfaceStatic.$propertiesFromJson($jsonObject).map(
      ($super0) => ({
        ...$super0,
        $identifier,
        $type,
        concreteChildInterfaceProperty,
      }),
    );
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "ConcreteChildInterface";
      concreteChildInterfaceProperty: string;
    } & $UnwrapR<
      ReturnType<typeof ConcreteParentInterfaceStatic.$propertiesFromRdf>
    >
  > {
    return ConcreteParentInterfaceStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/ConcreteChildInterface":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  ConcreteChildInterface.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ConcreteChildInterface)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        purify.Either.of<Error, ConcreteChildInterface.$Identifier>(
          $parameters.resource.identifier as ConcreteChildInterface.$Identifier,
        ).chain(($identifier) =>
          purify.Either.of<Error, "ConcreteChildInterface">(
            "ConcreteChildInterface",
          ).chain(($type) =>
            purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
            >(
              $parameters.resource.values(
                $properties.concreteChildInterfaceProperty["identifier"],
                { unique: true },
              ),
            )
              .chain((values) =>
                $fromRdfPreferredLanguages({
                  focusResource: $parameters.resource,
                  predicate:
                    ConcreteChildInterface.$properties
                      .concreteChildInterfaceProperty["identifier"],
                  preferredLanguages: $parameters.preferredLanguages,
                  values,
                }),
              )
              .chain((values) => values.chainMap((value) => value.toString()))
              .chain((values) => values.head())
              .map((concreteChildInterfaceProperty) => ({
                ...$super0,
                $identifier,
                $type,
                concreteChildInterfaceProperty,
              })),
          ),
        ),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ConcreteChildInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConcreteChildInterface.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ConcreteChildInterface.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ConcreteChildInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConcreteChildInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteChildInterface");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...ConcreteParentInterfaceStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteChildInterface"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildInterface")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildInterface")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildInterface")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildInterface")}ConcreteChildInterfaceProperty`,
      ),
      predicate:
        ConcreteChildInterface.$properties.concreteChildInterfaceProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ConcreteChildInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteChildInterface");
    patterns.push(
      ...ConcreteParentInterfaceStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteChildInterface"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildInterface")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ConcreteChildInterface.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildInterface")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildInterface")}ConcreteChildInterfaceProperty`,
            ),
            predicate:
              ConcreteChildInterface.$properties.concreteChildInterfaceProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildInterface")}ConcreteChildInterfaceProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.concreteChildInterfaceProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildInterface")}ConcreteChildInterfaceProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _concreteChildInterface: ConcreteChildInterface,
  ): ConcreteChildInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        ...ConcreteParentInterfaceStatic.$toJson(_concreteChildInterface),
        concreteChildInterfaceProperty:
          _concreteChildInterface.concreteChildInterfaceProperty,
      } satisfies ConcreteChildInterface.$Json),
    );
  }

  export function $toRdf(
    _concreteChildInterface: ConcreteChildInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = ConcreteParentInterfaceStatic.$toRdf(
      _concreteChildInterface,
      { ignoreRdfType: true, mutateGraph, resourceSet },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/ConcreteChildInterface",
        ),
      );
    }

    resource.add(
      ConcreteChildInterface.$properties.concreteChildInterfaceProperty[
        "identifier"
      ],
      ...[_concreteChildInterface.concreteChildInterfaceProperty],
    );
    return resource;
  }

  export function isConcreteChildInterface(
    object: $Object,
  ): object is ConcreteChildInterface {
    switch (object.$type) {
      case "ConcreteChildInterface":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape that serves as an abstract base class for child node shapes.
 *
 * It's marked abstract in TypeScript and not exported from the module.
 *
 * Common pattern: put the minting strategy and nodeKind on an ABC.
 */
export abstract class AbstractBaseClassWithProperties {
  protected _$identifier?: AbstractBaseClassWithPropertiesStatic.$Identifier;
  protected readonly _$identifierPrefix?: string;
  abstract readonly $type: "ConcreteChildClass" | "ConcreteParentClass";
  readonly abstractBaseClassWithPropertiesProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly $identifierPrefix?: string;
    readonly abstractBaseClassWithPropertiesProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this._$identifierPrefix = parameters.$identifierPrefix;
    this.abstractBaseClassWithPropertiesProperty =
      parameters.abstractBaseClassWithPropertiesProperty;
  }

  get $identifier(): AbstractBaseClassWithPropertiesStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }

    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  $equals(other: AbstractBaseClassWithProperties): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$identifierPrefix, other.$identifierPrefix).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$identifierPrefix",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.abstractBaseClassWithPropertiesProperty,
          other.abstractBaseClassWithPropertiesProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "abstractBaseClassWithPropertiesProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.abstractBaseClassWithPropertiesProperty);
    return _hasher;
  }

  $toJson(): AbstractBaseClassWithPropertiesStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        abstractBaseClassWithPropertiesProperty:
          this.abstractBaseClassWithPropertiesProperty,
      } satisfies AbstractBaseClassWithPropertiesStatic.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      AbstractBaseClassWithPropertiesStatic.$properties
        .abstractBaseClassWithPropertiesProperty["identifier"],
      ...[this.abstractBaseClassWithPropertiesProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace AbstractBaseClassWithPropertiesStatic {
  export function $filter(
    filter: AbstractBaseClassWithPropertiesStatic.$Filter,
    value: AbstractBaseClassWithProperties,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.abstractBaseClassWithPropertiesProperty !== "undefined" &&
      !$filterString(
        filter.abstractBaseClassWithPropertiesProperty,
        value.abstractBaseClassWithPropertiesProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly abstractBaseClassWithPropertiesProperty?: $StringFilter;
  };
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ConcreteChildClass" | "ConcreteParentClass";
    readonly abstractBaseClassWithPropertiesProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "AbstractBaseClassWithProperties" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/abstractBaseClassWithPropertiesProperty`,
          type: "Control",
        },
      ],
      label: "AbstractBaseClassWithProperties",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.enum(["ConcreteChildClass", "ConcreteParentClass"]),
      abstractBaseClassWithPropertiesProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    abstractBaseClassWithPropertiesProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/abstractBaseClassWithPropertiesProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      abstractBaseClassWithPropertiesProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const abstractBaseClassWithPropertiesProperty =
      $jsonObject["abstractBaseClassWithPropertiesProperty"];
    return purify.Either.of({
      $identifier,
      abstractBaseClassWithPropertiesProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      abstractBaseClassWithPropertiesProperty: string;
    }
  > {
    return purify.Either.of<
      Error,
      AbstractBaseClassWithPropertiesStatic.$Identifier
    >(
      $parameters.resource
        .identifier as AbstractBaseClassWithPropertiesStatic.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.abstractBaseClassWithPropertiesProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              AbstractBaseClassWithPropertiesStatic.$properties
                .abstractBaseClassWithPropertiesProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((abstractBaseClassWithPropertiesProperty) => ({
          $identifier,
          abstractBaseClassWithPropertiesProperty,
        })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: AbstractBaseClassWithPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        AbstractBaseClassWithPropertiesStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            AbstractBaseClassWithPropertiesStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: AbstractBaseClassWithPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      AbstractBaseClassWithPropertiesStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassWithProperties");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "abstractBaseClassWithProperties")}AbstractBaseClassWithPropertiesProperty`,
      ),
      predicate:
        AbstractBaseClassWithPropertiesStatic.$properties
          .abstractBaseClassWithPropertiesProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: AbstractBaseClassWithPropertiesStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassWithProperties");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "abstractBaseClassWithProperties")}AbstractBaseClassWithPropertiesProperty`,
            ),
            predicate:
              AbstractBaseClassWithPropertiesStatic.$properties
                .abstractBaseClassWithPropertiesProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "abstractBaseClassWithProperties")}AbstractBaseClassWithPropertiesProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.abstractBaseClassWithPropertiesProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "abstractBaseClassWithProperties")}AbstractBaseClassWithPropertiesProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isAbstractBaseClassWithProperties(
    object: $Object,
  ): object is AbstractBaseClassWithProperties {
    switch (object.$type) {
      case "ConcreteChildClass":
      case "ConcreteParentClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Abstract base for other node shapes. Put the ABC with properties above the ABC without.
 */
export abstract class AbstractBaseClassWithoutProperties extends AbstractBaseClassWithProperties {
  abstract override readonly $type:
    | "ConcreteChildClass"
    | "ConcreteParentClass";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: { readonly $identifierPrefix?: string } & ConstructorParameters<
      typeof AbstractBaseClassWithProperties
    >[0],
  ) {
    super(parameters);
  }

  override get $identifier(): AbstractBaseClassWithoutPropertiesStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }

    return this._$identifier;
  }

  protected override get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace AbstractBaseClassWithoutPropertiesStatic {
  export function $filter(
    filter: AbstractBaseClassWithoutPropertiesStatic.$Filter,
    value: AbstractBaseClassWithoutProperties,
  ): boolean {
    if (!AbstractBaseClassWithPropertiesStatic.$filter(filter, value)) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
  } & AbstractBaseClassWithPropertiesStatic.$Filter;
  export type $Identifier = AbstractBaseClassWithPropertiesStatic.$Identifier;
  export const $Identifier = AbstractBaseClassWithPropertiesStatic.$Identifier;
  export type $Json = AbstractBaseClassWithPropertiesStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        AbstractBaseClassWithPropertiesStatic.$jsonUiSchema({ scopePrefix }),
      ],
      label: "AbstractBaseClassWithoutProperties",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return AbstractBaseClassWithPropertiesStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["ConcreteChildClass", "ConcreteParentClass"]),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    ...AbstractBaseClassWithPropertiesStatic.$properties,
  };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<
        typeof AbstractBaseClassWithPropertiesStatic.$propertiesFromJson
      >
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    return AbstractBaseClassWithPropertiesStatic.$propertiesFromJson(
      $jsonObject,
    ).map(($super0) => ({ ...$super0, $identifier }));
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<
        typeof AbstractBaseClassWithPropertiesStatic.$propertiesFromRdf
      >
    >
  > {
    return AbstractBaseClassWithPropertiesStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      purify.Either.of<
        Error,
        AbstractBaseClassWithoutPropertiesStatic.$Identifier
      >(
        $parameters.resource
          .identifier as AbstractBaseClassWithoutPropertiesStatic.$Identifier,
      ).map(($identifier) => ({ ...$super0, $identifier })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: AbstractBaseClassWithoutPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        AbstractBaseClassWithoutPropertiesStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            AbstractBaseClassWithoutPropertiesStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: AbstractBaseClassWithoutPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      AbstractBaseClassWithoutPropertiesStatic.$sparqlConstructQuery(
        parameters,
      ),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassWithoutProperties");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...AbstractBaseClassWithPropertiesStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "abstractBaseClassWithoutProperties"),
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: AbstractBaseClassWithoutPropertiesStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassWithoutProperties");
    patterns.push(
      ...AbstractBaseClassWithPropertiesStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "abstractBaseClassWithoutProperties"),
      }),
    );
    return patterns;
  }

  export function isAbstractBaseClassWithoutProperties(
    object: $Object,
  ): object is AbstractBaseClassWithoutProperties {
    switch (object.$type) {
      case "ConcreteChildClass":
      case "ConcreteParentClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Class node shape that inherits the abstract base class and is the parent of the ConcreteChildClass.
 */
export class ConcreteParentClass extends AbstractBaseClassWithoutProperties {
  override readonly $type: "ConcreteParentClass" | "ConcreteChildClass" =
    "ConcreteParentClass";
  readonly concreteParentClassProperty: string;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly $identifierPrefix?: string;
      readonly concreteParentClassProperty: string;
    } & ConstructorParameters<typeof AbstractBaseClassWithoutProperties>[0],
  ) {
    super(parameters);
    this.concreteParentClassProperty = parameters.concreteParentClassProperty;
  }

  override get $identifier(): ConcreteParentClassStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }

    return this._$identifier;
  }

  protected override get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  override $equals(other: ConcreteParentClass): $EqualsResult {
    return super.$equals(other).chain(() =>
      $strictEquals(
        this.concreteParentClassProperty,
        other.concreteParentClassProperty,
      ).mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "concreteParentClassProperty",
        propertyValuesUnequal,
        type: "Property" as const,
      })),
    );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    _hasher.update(this.concreteParentClassProperty);
    return _hasher;
  }

  override $toJson(): ConcreteParentClassStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        concreteParentClassProperty: this.concreteParentClassProperty,
      } satisfies ConcreteParentClassStatic.$Json),
    );
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/ConcreteParentClass",
        ),
      );
    }

    resource.add(
      ConcreteParentClassStatic.$properties.concreteParentClassProperty[
        "identifier"
      ],
      ...[this.concreteParentClassProperty],
    );
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ConcreteParentClassStatic {
  export function $filter(
    filter: ConcreteParentClassStatic.$Filter,
    value: ConcreteParentClass,
  ): boolean {
    if (!AbstractBaseClassWithoutPropertiesStatic.$filter(filter, value)) {
      return false;
    }

    if (
      typeof filter.concreteParentClassProperty !== "undefined" &&
      !$filterString(
        filter.concreteParentClassProperty,
        value.concreteParentClassProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly concreteParentClassProperty?: $StringFilter;
  } & AbstractBaseClassWithoutPropertiesStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ConcreteParentClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ConcreteParentClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ConcreteParentClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ConcreteParentClassStatic.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ConcreteParentClass(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ConcreteParentClass",
  );
  export type $Identifier =
    AbstractBaseClassWithoutPropertiesStatic.$Identifier;
  export const $Identifier =
    AbstractBaseClassWithoutPropertiesStatic.$Identifier;
  export type $Json = {
    readonly concreteParentClassProperty: string;
  } & AbstractBaseClassWithoutPropertiesStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        AbstractBaseClassWithoutPropertiesStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/concreteParentClassProperty`,
          type: "Control",
        },
      ],
      label: "ConcreteParentClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return AbstractBaseClassWithoutPropertiesStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["ConcreteParentClass", "ConcreteChildClass"]),
        concreteParentClassProperty: zod.string(),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    ...AbstractBaseClassWithoutPropertiesStatic.$properties,
    concreteParentClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/concreteParentClassProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      concreteParentClassProperty: string;
    } & $UnwrapR<
      ReturnType<
        typeof AbstractBaseClassWithoutPropertiesStatic.$propertiesFromJson
      >
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const concreteParentClassProperty =
      $jsonObject["concreteParentClassProperty"];
    return AbstractBaseClassWithoutPropertiesStatic.$propertiesFromJson(
      $jsonObject,
    ).map(($super0) => ({
      ...$super0,
      $identifier,
      concreteParentClassProperty,
    }));
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      concreteParentClassProperty: string;
    } & $UnwrapR<
      ReturnType<
        typeof AbstractBaseClassWithoutPropertiesStatic.$propertiesFromRdf
      >
    >
  > {
    return AbstractBaseClassWithoutPropertiesStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/ConcreteParentClass":
                case "http://example.com/ConcreteChildClass":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  ConcreteParentClassStatic.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ConcreteParentClass)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        purify.Either.of<Error, ConcreteParentClassStatic.$Identifier>(
          $parameters.resource
            .identifier as ConcreteParentClassStatic.$Identifier,
        ).chain(($identifier) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.concreteParentClassProperty["identifier"],
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  ConcreteParentClassStatic.$properties
                    .concreteParentClassProperty["identifier"],
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((concreteParentClassProperty) => ({
              ...$super0,
              $identifier,
              concreteParentClassProperty,
            })),
        ),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ConcreteParentClassStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConcreteParentClassStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ConcreteParentClassStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ConcreteParentClassStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConcreteParentClassStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteParentClass");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...AbstractBaseClassWithoutPropertiesStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteParentClass"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}ConcreteParentClassProperty`,
      ),
      predicate:
        ConcreteParentClassStatic.$properties.concreteParentClassProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ConcreteParentClassStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteParentClass");
    patterns.push(
      ...AbstractBaseClassWithoutPropertiesStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteParentClass"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        {
          type: "values" as const,
          values: [
            ConcreteParentClassStatic.$fromRdfType,
            ConcreteChildClass.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[
              `?${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}FromRdfType`
            ] = identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}FromRdfType`,
          ),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}ConcreteParentClassProperty`,
            ),
            predicate:
              ConcreteParentClassStatic.$properties.concreteParentClassProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}ConcreteParentClassProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.concreteParentClassProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}ConcreteParentClassProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isConcreteParentClass(
    object: $Object,
  ): object is ConcreteParentClass {
    switch (object.$type) {
      case "ConcreteChildClass":
      case "ConcreteParentClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Child (class) of ConcreteParentClass. Should inherit properties, node kinds, and minting strategy.
 */
export class ConcreteChildClass extends ConcreteParentClass {
  override readonly $type = "ConcreteChildClass";
  readonly concreteChildClassProperty: string;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly $identifierPrefix?: string;
      readonly concreteChildClassProperty: string;
    } & ConstructorParameters<typeof ConcreteParentClass>[0],
  ) {
    super(parameters);
    this.concreteChildClassProperty = parameters.concreteChildClassProperty;
  }

  override get $identifier(): ConcreteChildClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }

    return this._$identifier;
  }

  protected override get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  override $equals(other: ConcreteChildClass): $EqualsResult {
    return super.$equals(other).chain(() =>
      $strictEquals(
        this.concreteChildClassProperty,
        other.concreteChildClassProperty,
      ).mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "concreteChildClassProperty",
        propertyValuesUnequal,
        type: "Property" as const,
      })),
    );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    _hasher.update(this.concreteChildClassProperty);
    return _hasher;
  }

  override $toJson(): ConcreteChildClass.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        concreteChildClassProperty: this.concreteChildClassProperty,
      } satisfies ConcreteChildClass.$Json),
    );
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode("http://example.com/ConcreteChildClass"),
      );
    }

    resource.add(
      ConcreteChildClass.$properties.concreteChildClassProperty["identifier"],
      ...[this.concreteChildClassProperty],
    );
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ConcreteChildClass {
  export function $filter(
    filter: ConcreteChildClass.$Filter,
    value: ConcreteChildClass,
  ): boolean {
    if (!ConcreteParentClassStatic.$filter(filter, value)) {
      return false;
    }

    if (
      typeof filter.concreteChildClassProperty !== "undefined" &&
      !$filterString(
        filter.concreteChildClassProperty,
        value.concreteChildClassProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly concreteChildClassProperty?: $StringFilter;
  } & ConcreteParentClassStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ConcreteChildClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ConcreteChildClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ConcreteChildClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ConcreteChildClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ConcreteChildClass(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ConcreteChildClass",
  );
  export type $Identifier = ConcreteParentClassStatic.$Identifier;
  export const $Identifier = ConcreteParentClassStatic.$Identifier;
  export type $Json = {
    readonly concreteChildClassProperty: string;
  } & ConcreteParentClassStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ConcreteParentClassStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/concreteChildClassProperty`,
          type: "Control",
        },
      ],
      label: "ConcreteChildClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ConcreteParentClassStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("ConcreteChildClass"),
        concreteChildClassProperty: zod.string(),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    ...ConcreteParentClassStatic.$properties,
    concreteChildClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/concreteChildClassProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      concreteChildClassProperty: string;
    } & $UnwrapR<
      ReturnType<typeof ConcreteParentClassStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const concreteChildClassProperty =
      $jsonObject["concreteChildClassProperty"];
    return ConcreteParentClassStatic.$propertiesFromJson($jsonObject).map(
      ($super0) => ({ ...$super0, $identifier, concreteChildClassProperty }),
    );
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      concreteChildClassProperty: string;
    } & $UnwrapR<
      ReturnType<typeof ConcreteParentClassStatic.$propertiesFromRdf>
    >
  > {
    return ConcreteParentClassStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/ConcreteChildClass":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  ConcreteChildClass.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ConcreteChildClass)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        purify.Either.of<Error, ConcreteChildClass.$Identifier>(
          $parameters.resource.identifier as ConcreteChildClass.$Identifier,
        ).chain(($identifier) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.concreteChildClassProperty["identifier"],
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  ConcreteChildClass.$properties.concreteChildClassProperty[
                    "identifier"
                  ],
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((concreteChildClassProperty) => ({
              ...$super0,
              $identifier,
              concreteChildClassProperty,
            })),
        ),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ConcreteChildClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConcreteChildClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ConcreteChildClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ConcreteChildClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConcreteChildClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteChildClass");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...ConcreteParentClassStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteChildClass"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildClass")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildClass")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildClass")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildClass")}ConcreteChildClassProperty`,
      ),
      predicate:
        ConcreteChildClass.$properties.concreteChildClassProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ConcreteChildClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteChildClass");
    patterns.push(
      ...ConcreteParentClassStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteChildClass"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildClass")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ConcreteChildClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildClass")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildClass")}ConcreteChildClassProperty`,
            ),
            predicate:
              ConcreteChildClass.$properties.concreteChildClassProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildClass")}ConcreteChildClassProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.concreteChildClassProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildClass")}ConcreteChildClassProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isConcreteChildClass(
    object: $Object,
  ): object is ConcreteChildClass {
    switch (object.$type) {
      case "ConcreteChildClass":
        return true;
      default:
        return false;
    }
  }
}
export abstract class ClassUnionMemberCommonParent {
  protected _$identifier?: ClassUnionMemberCommonParentStatic.$Identifier;
  abstract readonly $type: "ClassUnionMember1" | "ClassUnionMember2";
  readonly classUnionMemberCommonParentProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly classUnionMemberCommonParentProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.classUnionMemberCommonParentProperty =
      parameters.classUnionMemberCommonParentProperty;
  }

  get $identifier(): ClassUnionMemberCommonParentStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: ClassUnionMemberCommonParent): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.classUnionMemberCommonParentProperty,
          other.classUnionMemberCommonParentProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "classUnionMemberCommonParentProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.classUnionMemberCommonParentProperty);
    return _hasher;
  }

  $toJson(): ClassUnionMemberCommonParentStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        classUnionMemberCommonParentProperty:
          this.classUnionMemberCommonParentProperty,
      } satisfies ClassUnionMemberCommonParentStatic.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      ClassUnionMemberCommonParentStatic.$properties
        .classUnionMemberCommonParentProperty["identifier"],
      ...[this.classUnionMemberCommonParentProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ClassUnionMemberCommonParentStatic {
  export function $filter(
    filter: ClassUnionMemberCommonParentStatic.$Filter,
    value: ClassUnionMemberCommonParent,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.classUnionMemberCommonParentProperty !== "undefined" &&
      !$filterString(
        filter.classUnionMemberCommonParentProperty,
        value.classUnionMemberCommonParentProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly classUnionMemberCommonParentProperty?: $StringFilter;
  };
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ClassUnionMember1" | "ClassUnionMember2";
    readonly classUnionMemberCommonParentProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ClassUnionMemberCommonParent" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/classUnionMemberCommonParentProperty`,
          type: "Control",
        },
      ],
      label: "ClassUnionMemberCommonParent",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.enum(["ClassUnionMember1", "ClassUnionMember2"]),
      classUnionMemberCommonParentProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    classUnionMemberCommonParentProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/classUnionMemberCommonParentProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      classUnionMemberCommonParentProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const classUnionMemberCommonParentProperty =
      $jsonObject["classUnionMemberCommonParentProperty"];
    return purify.Either.of({
      $identifier,
      classUnionMemberCommonParentProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      classUnionMemberCommonParentProperty: string;
    }
  > {
    return purify.Either.of<
      Error,
      ClassUnionMemberCommonParentStatic.$Identifier
    >(
      $parameters.resource
        .identifier as ClassUnionMemberCommonParentStatic.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.classUnionMemberCommonParentProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              ClassUnionMemberCommonParentStatic.$properties
                .classUnionMemberCommonParentProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((classUnionMemberCommonParentProperty) => ({
          $identifier,
          classUnionMemberCommonParentProperty,
        })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ClassUnionMemberCommonParentStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ClassUnionMemberCommonParentStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ClassUnionMemberCommonParentStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ClassUnionMemberCommonParentStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ClassUnionMemberCommonParentStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("classUnionMemberCommonParent");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMemberCommonParent")}ClassUnionMemberCommonParentProperty`,
      ),
      predicate:
        ClassUnionMemberCommonParentStatic.$properties
          .classUnionMemberCommonParentProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ClassUnionMemberCommonParentStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("classUnionMemberCommonParent");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMemberCommonParent")}ClassUnionMemberCommonParentProperty`,
            ),
            predicate:
              ClassUnionMemberCommonParentStatic.$properties
                .classUnionMemberCommonParentProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMemberCommonParent")}ClassUnionMemberCommonParentProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.classUnionMemberCommonParentProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMemberCommonParent")}ClassUnionMemberCommonParentProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isClassUnionMemberCommonParent(
    object: $Object,
  ): object is ClassUnionMemberCommonParent {
    switch (object.$type) {
      case "ClassUnionMember1":
      case "ClassUnionMember2":
        return true;
      default:
        return false;
    }
  }
}
export class ClassUnionMember2 extends ClassUnionMemberCommonParent {
  override readonly $type = "ClassUnionMember2";
  readonly classUnionMember2Property: string;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly classUnionMember2Property: string;
    } & ConstructorParameters<typeof ClassUnionMemberCommonParent>[0],
  ) {
    super(parameters);
    this.classUnionMember2Property = parameters.classUnionMember2Property;
  }

  override get $identifier(): ClassUnionMember2.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  override $equals(other: ClassUnionMember2): $EqualsResult {
    return super.$equals(other).chain(() =>
      $strictEquals(
        this.classUnionMember2Property,
        other.classUnionMember2Property,
      ).mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "classUnionMember2Property",
        propertyValuesUnequal,
        type: "Property" as const,
      })),
    );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    _hasher.update(this.classUnionMember2Property);
    return _hasher;
  }

  override $toJson(): ClassUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        classUnionMember2Property: this.classUnionMember2Property,
      } satisfies ClassUnionMember2.$Json),
    );
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode("http://example.com/ClassUnionMember2"),
      );
    }

    resource.add(
      ClassUnionMember2.$properties.classUnionMember2Property["identifier"],
      ...[this.classUnionMember2Property],
    );
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ClassUnionMember2 {
  export function $filter(
    filter: ClassUnionMember2.$Filter,
    value: ClassUnionMember2,
  ): boolean {
    if (!ClassUnionMemberCommonParentStatic.$filter(filter, value)) {
      return false;
    }

    if (
      typeof filter.classUnionMember2Property !== "undefined" &&
      !$filterString(
        filter.classUnionMember2Property,
        value.classUnionMember2Property,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly classUnionMember2Property?: $StringFilter;
  } & ClassUnionMemberCommonParentStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ClassUnionMember2> {
    return $propertiesFromJson(json).map(
      (properties) => new ClassUnionMember2(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ClassUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ClassUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ClassUnionMember2(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ClassUnionMember2",
  );
  export type $Identifier = ClassUnionMemberCommonParentStatic.$Identifier;
  export const $Identifier = ClassUnionMemberCommonParentStatic.$Identifier;
  export type $Json = {
    readonly classUnionMember2Property: string;
  } & ClassUnionMemberCommonParentStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ClassUnionMemberCommonParentStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/classUnionMember2Property`,
          type: "Control",
        },
      ],
      label: "ClassUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ClassUnionMemberCommonParentStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("ClassUnionMember2"),
        classUnionMember2Property: zod.string(),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    ...ClassUnionMemberCommonParentStatic.$properties,
    classUnionMember2Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/classUnionMember2Property",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      classUnionMember2Property: string;
    } & $UnwrapR<
      ReturnType<typeof ClassUnionMemberCommonParentStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const classUnionMember2Property = $jsonObject["classUnionMember2Property"];
    return ClassUnionMemberCommonParentStatic.$propertiesFromJson(
      $jsonObject,
    ).map(($super0) => ({
      ...$super0,
      $identifier,
      classUnionMember2Property,
    }));
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      classUnionMember2Property: string;
    } & $UnwrapR<
      ReturnType<typeof ClassUnionMemberCommonParentStatic.$propertiesFromRdf>
    >
  > {
    return ClassUnionMemberCommonParentStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/ClassUnionMember2":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  ClassUnionMember2.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ClassUnionMember2)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        purify.Either.of<Error, ClassUnionMember2.$Identifier>(
          $parameters.resource.identifier as ClassUnionMember2.$Identifier,
        ).chain(($identifier) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.classUnionMember2Property["identifier"],
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  ClassUnionMember2.$properties.classUnionMember2Property[
                    "identifier"
                  ],
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((classUnionMember2Property) => ({
              ...$super0,
              $identifier,
              classUnionMember2Property,
            })),
        ),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ClassUnionMember2.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ClassUnionMember2.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ClassUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("classUnionMember2");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...ClassUnionMemberCommonParentStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "classUnionMember2"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember2")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember2")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember2")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember2")}ClassUnionMember2Property`,
      ),
      predicate:
        ClassUnionMember2.$properties.classUnionMember2Property["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ClassUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("classUnionMember2");
    patterns.push(
      ...ClassUnionMemberCommonParentStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "classUnionMember2"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember2")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ClassUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember2")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember2")}ClassUnionMember2Property`,
            ),
            predicate:
              ClassUnionMember2.$properties.classUnionMember2Property[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember2")}ClassUnionMember2Property`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.classUnionMember2Property,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember2")}ClassUnionMember2Property`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isClassUnionMember2(
    object: $Object,
  ): object is ClassUnionMember2 {
    switch (object.$type) {
      case "ClassUnionMember2":
        return true;
      default:
        return false;
    }
  }
}
export class ClassUnionMember1 extends ClassUnionMemberCommonParent {
  override readonly $type = "ClassUnionMember1";
  readonly classUnionMember1Property: string;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly classUnionMember1Property: string;
    } & ConstructorParameters<typeof ClassUnionMemberCommonParent>[0],
  ) {
    super(parameters);
    this.classUnionMember1Property = parameters.classUnionMember1Property;
  }

  override get $identifier(): ClassUnionMember1.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  override $equals(other: ClassUnionMember1): $EqualsResult {
    return super.$equals(other).chain(() =>
      $strictEquals(
        this.classUnionMember1Property,
        other.classUnionMember1Property,
      ).mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "classUnionMember1Property",
        propertyValuesUnequal,
        type: "Property" as const,
      })),
    );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    _hasher.update(this.classUnionMember1Property);
    return _hasher;
  }

  override $toJson(): ClassUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        classUnionMember1Property: this.classUnionMember1Property,
      } satisfies ClassUnionMember1.$Json),
    );
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode("http://example.com/ClassUnionMember1"),
      );
    }

    resource.add(
      ClassUnionMember1.$properties.classUnionMember1Property["identifier"],
      ...[this.classUnionMember1Property],
    );
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ClassUnionMember1 {
  export function $filter(
    filter: ClassUnionMember1.$Filter,
    value: ClassUnionMember1,
  ): boolean {
    if (!ClassUnionMemberCommonParentStatic.$filter(filter, value)) {
      return false;
    }

    if (
      typeof filter.classUnionMember1Property !== "undefined" &&
      !$filterString(
        filter.classUnionMember1Property,
        value.classUnionMember1Property,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly classUnionMember1Property?: $StringFilter;
  } & ClassUnionMemberCommonParentStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ClassUnionMember1> {
    return $propertiesFromJson(json).map(
      (properties) => new ClassUnionMember1(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ClassUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ClassUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ClassUnionMember1(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ClassUnionMember1",
  );
  export type $Identifier = ClassUnionMemberCommonParentStatic.$Identifier;
  export const $Identifier = ClassUnionMemberCommonParentStatic.$Identifier;
  export type $Json = {
    readonly classUnionMember1Property: string;
  } & ClassUnionMemberCommonParentStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ClassUnionMemberCommonParentStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/classUnionMember1Property`,
          type: "Control",
        },
      ],
      label: "ClassUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ClassUnionMemberCommonParentStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("ClassUnionMember1"),
        classUnionMember1Property: zod.string(),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    ...ClassUnionMemberCommonParentStatic.$properties,
    classUnionMember1Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/classUnionMember1Property",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      classUnionMember1Property: string;
    } & $UnwrapR<
      ReturnType<typeof ClassUnionMemberCommonParentStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const classUnionMember1Property = $jsonObject["classUnionMember1Property"];
    return ClassUnionMemberCommonParentStatic.$propertiesFromJson(
      $jsonObject,
    ).map(($super0) => ({
      ...$super0,
      $identifier,
      classUnionMember1Property,
    }));
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      classUnionMember1Property: string;
    } & $UnwrapR<
      ReturnType<typeof ClassUnionMemberCommonParentStatic.$propertiesFromRdf>
    >
  > {
    return ClassUnionMemberCommonParentStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/ClassUnionMember1":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  ClassUnionMember1.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ClassUnionMember1)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        purify.Either.of<Error, ClassUnionMember1.$Identifier>(
          $parameters.resource.identifier as ClassUnionMember1.$Identifier,
        ).chain(($identifier) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            $parameters.resource.values(
              $properties.classUnionMember1Property["identifier"],
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  ClassUnionMember1.$properties.classUnionMember1Property[
                    "identifier"
                  ],
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((classUnionMember1Property) => ({
              ...$super0,
              $identifier,
              classUnionMember1Property,
            })),
        ),
      ),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ClassUnionMember1.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ClassUnionMember1.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ClassUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("classUnionMember1");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...ClassUnionMemberCommonParentStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "classUnionMember1"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember1")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember1")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember1")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember1")}ClassUnionMember1Property`,
      ),
      predicate:
        ClassUnionMember1.$properties.classUnionMember1Property["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ClassUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("classUnionMember1");
    patterns.push(
      ...ClassUnionMemberCommonParentStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "classUnionMember1"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember1")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ClassUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember1")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember1")}ClassUnionMember1Property`,
            ),
            predicate:
              ClassUnionMember1.$properties.classUnionMember1Property[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember1")}ClassUnionMember1Property`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.classUnionMember1Property,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember1")}ClassUnionMember1Property`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isClassUnionMember1(
    object: $Object,
  ): object is ClassUnionMember1 {
    switch (object.$type) {
      case "ClassUnionMember1":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape that can have a blank node or IRI as an identifier
 */
export interface BlankNodeOrIriIdentifierInterface {
  readonly $identifier: BlankNodeOrIriIdentifierInterface.$Identifier;
  readonly $type: "BlankNodeOrIriIdentifierInterface";
}

export namespace BlankNodeOrIriIdentifierInterface {
  export function $create(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
  }): BlankNodeOrIriIdentifierInterface {
    let $identifier: BlankNodeOrIriIdentifierInterface.$Identifier;
    if (typeof parameters?.$identifier === "object") {
      $identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters?.$identifier satisfies never;
    }

    const $type = "BlankNodeOrIriIdentifierInterface" as const;
    return { $identifier, $type };
  }

  export function $equals(
    left: BlankNodeOrIriIdentifierInterface,
    right: BlankNodeOrIriIdentifierInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  export function $filter(
    filter: BlankNodeOrIriIdentifierInterface.$Filter,
    value: BlankNodeOrIriIdentifierInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = { readonly $identifier?: $IdentifierFilter };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, BlankNodeOrIriIdentifierInterface> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, BlankNodeOrIriIdentifierInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return BlankNodeOrIriIdentifierInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _blankNodeOrIriIdentifierInterface: BlankNodeOrIriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_blankNodeOrIriIdentifierInterface.$identifier.value);
    _hasher.update(_blankNodeOrIriIdentifierInterface.$type);
    BlankNodeOrIriIdentifierInterface.$hashShaclProperties(
      _blankNodeOrIriIdentifierInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _blankNodeOrIriIdentifierInterface: BlankNodeOrIriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "BlankNodeOrIriIdentifierInterface";
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "BlankNodeOrIriIdentifierInterface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "BlankNodeOrIriIdentifierInterface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("BlankNodeOrIriIdentifierInterface"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {};

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "BlankNodeOrIriIdentifierInterface";
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "BlankNodeOrIriIdentifierInterface" as const;
    return purify.Either.of({ $identifier, $type });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "BlankNodeOrIriIdentifierInterface";
    }
  > {
    return purify.Either.of<
      Error,
      BlankNodeOrIriIdentifierInterface.$Identifier
    >(
      $parameters.resource
        .identifier as BlankNodeOrIriIdentifierInterface.$Identifier,
    ).chain(($identifier) =>
      purify.Either.of<Error, "BlankNodeOrIriIdentifierInterface">(
        "BlankNodeOrIriIdentifierInterface",
      ).map(($type) => ({ $identifier, $type })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: BlankNodeOrIriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BlankNodeOrIriIdentifierInterface.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            BlankNodeOrIriIdentifierInterface.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: BlankNodeOrIriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BlankNodeOrIriIdentifierInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: BlankNodeOrIriIdentifierInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("blankNodeOrIriIdentifierInterface");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }

  export function $toJson(
    _blankNodeOrIriIdentifierInterface: BlankNodeOrIriIdentifierInterface,
  ): BlankNodeOrIriIdentifierInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _blankNodeOrIriIdentifierInterface.$identifier.termType ===
          "BlankNode"
            ? `_:${_blankNodeOrIriIdentifierInterface.$identifier.value}`
            : _blankNodeOrIriIdentifierInterface.$identifier.value,
        $type: _blankNodeOrIriIdentifierInterface.$type,
      } satisfies BlankNodeOrIriIdentifierInterface.$Json),
    );
  }

  export function $toRdf(
    _blankNodeOrIriIdentifierInterface: BlankNodeOrIriIdentifierInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _blankNodeOrIriIdentifierInterface.$identifier,
      { mutateGraph },
    );
    return resource;
  }

  export function isBlankNodeOrIriIdentifierInterface(
    object: $Object,
  ): object is BlankNodeOrIriIdentifierInterface {
    switch (object.$type) {
      case "BlankNodeOrIriIdentifierInterface":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape that can have a blank node or IRI as an identifier
 */
export class BlankNodeOrIriIdentifierClass {
  private _$identifier?: BlankNodeOrIriIdentifierClass.$Identifier;
  readonly $type = "BlankNodeOrIriIdentifierClass";

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }
  }

  get $identifier(): BlankNodeOrIriIdentifierClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: BlankNodeOrIriIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    return _hasher;
  }

  $toJson(): BlankNodeOrIriIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
      } satisfies BlankNodeOrIriIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/BlankNodeOrIriIdentifierClass",
        ),
      );
    }

    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace BlankNodeOrIriIdentifierClass {
  export function $filter(
    filter: BlankNodeOrIriIdentifierClass.$Filter,
    value: BlankNodeOrIriIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = { readonly $identifier?: $IdentifierFilter };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, BlankNodeOrIriIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new BlankNodeOrIriIdentifierClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, BlankNodeOrIriIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return BlankNodeOrIriIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new BlankNodeOrIriIdentifierClass(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/BlankNodeOrIriIdentifierClass",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "BlankNodeOrIriIdentifierClass";
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "BlankNodeOrIriIdentifierClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "BlankNodeOrIriIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("BlankNodeOrIriIdentifierClass"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {};

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    return purify.Either.of({ $identifier });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<Error, { $identifier: rdfjs.BlankNode | rdfjs.NamedNode }> {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/BlankNodeOrIriIdentifierClass":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  BlankNodeOrIriIdentifierClass.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/BlankNodeOrIriIdentifierClass)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      purify.Either.of<Error, BlankNodeOrIriIdentifierClass.$Identifier>(
        $parameters.resource
          .identifier as BlankNodeOrIriIdentifierClass.$Identifier,
      ).map(($identifier) => ({ $identifier })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: BlankNodeOrIriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BlankNodeOrIriIdentifierClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            BlankNodeOrIriIdentifierClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: BlankNodeOrIriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BlankNodeOrIriIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("blankNodeOrIriIdentifierClass");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "blankNodeOrIriIdentifierClass")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "blankNodeOrIriIdentifierClass")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "blankNodeOrIriIdentifierClass")}RdfClass`,
          ),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: BlankNodeOrIriIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("blankNodeOrIriIdentifierClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "blankNodeOrIriIdentifierClass")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: BlankNodeOrIriIdentifierClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "blankNodeOrIriIdentifierClass")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }

  export function isBlankNodeOrIriIdentifierClass(
    object: $Object,
  ): object is BlankNodeOrIriIdentifierClass {
    switch (object.$type) {
      case "BlankNodeOrIriIdentifierClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape that can only have a blank node as an identifier
 */
export interface BlankNodeIdentifierInterface {
  readonly $identifier: BlankNodeIdentifierInterface.$Identifier;
  readonly $type: "BlankNodeIdentifierInterface";
}

export namespace BlankNodeIdentifierInterface {
  export function $create(parameters?: {
    readonly $identifier?: rdfjs.BlankNode;
  }): BlankNodeIdentifierInterface {
    let $identifier: BlankNodeIdentifierInterface.$Identifier;
    if (typeof parameters?.$identifier === "object") {
      $identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters?.$identifier satisfies never;
    }

    const $type = "BlankNodeIdentifierInterface" as const;
    return { $identifier, $type };
  }

  export function $equals(
    left: BlankNodeIdentifierInterface,
    right: BlankNodeIdentifierInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  export function $filter(
    filter: BlankNodeIdentifierInterface.$Filter,
    value: BlankNodeIdentifierInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterBlankNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = { readonly $identifier?: $BlankNodeFilter };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, BlankNodeIdentifierInterface> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, BlankNodeIdentifierInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return BlankNodeIdentifierInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _blankNodeIdentifierInterface: BlankNodeIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_blankNodeIdentifierInterface.$identifier.value);
    _hasher.update(_blankNodeIdentifierInterface.$type);
    BlankNodeIdentifierInterface.$hashShaclProperties(
      _blankNodeIdentifierInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _blankNodeIdentifierInterface: BlankNodeIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.BlankNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ) as purify.Either<Error, rdfjs.BlankNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "BlankNodeIdentifierInterface";
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "BlankNodeIdentifierInterface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "BlankNodeIdentifierInterface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("BlankNodeIdentifierInterface"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {};

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode; $type: "BlankNodeIdentifierInterface" }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.blankNode($jsonObject["@id"].substring(2));
    const $type = "BlankNodeIdentifierInterface" as const;
    return purify.Either.of({ $identifier, $type });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.BlankNode; $type: "BlankNodeIdentifierInterface" }
  > {
    return (
      $parameters.resource.identifier.termType === "BlankNode"
        ? purify.Either.of<Error, BlankNodeIdentifierInterface.$Identifier>(
            $parameters.resource.identifier,
          )
        : purify.Left(
            new rdfjsResource.Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "(rdfjs.BlankNode)",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
    ).chain(($identifier) =>
      purify.Either.of<Error, "BlankNodeIdentifierInterface">(
        "BlankNodeIdentifierInterface",
      ).map(($type) => ({ $identifier, $type })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: BlankNodeIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BlankNodeIdentifierInterface.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            BlankNodeIdentifierInterface.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: BlankNodeIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BlankNodeIdentifierInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: BlankNodeIdentifierInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("blankNodeIdentifierInterface");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $BlankNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }

  export function $toJson(
    _blankNodeIdentifierInterface: BlankNodeIdentifierInterface,
  ): BlankNodeIdentifierInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": `_:${_blankNodeIdentifierInterface.$identifier.value}`,
        $type: _blankNodeIdentifierInterface.$type,
      } satisfies BlankNodeIdentifierInterface.$Json),
    );
  }

  export function $toRdf(
    _blankNodeIdentifierInterface: BlankNodeIdentifierInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _blankNodeIdentifierInterface.$identifier,
      { mutateGraph },
    );
    return resource;
  }

  export function isBlankNodeIdentifierInterface(
    object: $Object,
  ): object is BlankNodeIdentifierInterface {
    switch (object.$type) {
      case "BlankNodeIdentifierInterface":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape that can only have a blank node as an identifier
 */
export class BlankNodeIdentifierClass {
  private _$identifier?: BlankNodeIdentifierClass.$Identifier;
  readonly $type = "BlankNodeIdentifierClass";

  constructor(parameters?: { readonly $identifier?: rdfjs.BlankNode }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }
  }

  get $identifier(): BlankNodeIdentifierClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    if (this._$identifier.termType !== "BlankNode") {
      throw new Error(
        `expected identifier to be BlankNode, not ${this._$identifier.termType}`,
      );
    }

    return this._$identifier;
  }

  $equals(other: BlankNodeIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    return _hasher;
  }

  $toJson(): BlankNodeIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": `_:${this.$identifier.value}`,
        $type: this.$type,
      } satisfies BlankNodeIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/BlankNodeIdentifierClass",
        ),
      );
    }

    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace BlankNodeIdentifierClass {
  export function $filter(
    filter: BlankNodeIdentifierClass.$Filter,
    value: BlankNodeIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterBlankNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = { readonly $identifier?: $BlankNodeFilter };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, BlankNodeIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new BlankNodeIdentifierClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, BlankNodeIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return BlankNodeIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new BlankNodeIdentifierClass(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/BlankNodeIdentifierClass",
  );
  export type $Identifier = rdfjs.BlankNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.BlankNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ) as purify.Either<Error, rdfjs.BlankNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "BlankNodeIdentifierClass";
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "BlankNodeIdentifierClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "BlankNodeIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("BlankNodeIdentifierClass"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {};

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<zod.ZodError, { $identifier: rdfjs.BlankNode }> {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.blankNode($jsonObject["@id"].substring(2));
    return purify.Either.of({ $identifier });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<Error, { $identifier: rdfjs.BlankNode }> {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/BlankNodeIdentifierClass":
                  return purify.Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  BlankNodeIdentifierClass.$fromRdfType,
                )
              ) {
                return purify.Either.of<Error, true>(true);
              }

              return purify.Left(
                new Error(
                  `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/BlankNodeIdentifierClass)`,
                ),
              );
            })
        : purify.Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      ($parameters.resource.identifier.termType === "BlankNode"
        ? purify.Either.of<Error, BlankNodeIdentifierClass.$Identifier>(
            $parameters.resource.identifier,
          )
        : purify.Left(
            new rdfjsResource.Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "(rdfjs.BlankNode)",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
      ).map(($identifier) => ({ $identifier })),
    );
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: BlankNodeIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BlankNodeIdentifierClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            BlankNodeIdentifierClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: BlankNodeIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BlankNodeIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("blankNodeIdentifierClass");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "blankNodeIdentifierClass")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "blankNodeIdentifierClass")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "blankNodeIdentifierClass")}RdfClass`,
          ),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: BlankNodeIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("blankNodeIdentifierClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "blankNodeIdentifierClass")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: BlankNodeIdentifierClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "blankNodeIdentifierClass")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $BlankNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }

  export function isBlankNodeIdentifierClass(
    object: $Object,
  ): object is BlankNodeIdentifierClass {
    switch (object.$type) {
      case "BlankNodeIdentifierClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape sh:xone's other node shapes. This will usually be generated as a discriminated union.
 */
export type ClassUnion = ClassUnionMember1 | ClassUnionMember2;

export namespace ClassUnion {
  export function $equals(left: ClassUnion, right: ClassUnion): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      if (ClassUnionMember1.isClassUnionMember1(left)) {
        return left.$equals(right as unknown as ClassUnionMember1);
      }
      if (ClassUnionMember2.isClassUnionMember2(left)) {
        return left.$equals(right as unknown as ClassUnionMember2);
      }
      return $EqualsResult.Equal;
    });
  }

  export function $filter(
    filter: ClassUnion.$Filter,
    value: ClassUnion,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      ClassUnionMember1.isClassUnionMember1(value) &&
      filter.on?.ClassUnionMember1 &&
      !ClassUnionMember1.$filter(
        filter.on.ClassUnionMember1,
        value as ClassUnionMember1,
      )
    ) {
      return false;
    }

    if (
      ClassUnionMember2.isClassUnionMember2(value) &&
      filter.on?.ClassUnionMember2 &&
      !ClassUnionMember2.$filter(
        filter.on.ClassUnionMember2,
        value as ClassUnionMember2,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly on?: {
      readonly ClassUnionMember1?: Omit<
        ClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly ClassUnionMember2?: Omit<
        ClassUnionMember2.$Filter,
        "$identifier"
      >;
    };
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ClassUnion> {
    return (
      ClassUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        ClassUnion
      >
    ).altLazy(
      () =>
        ClassUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          ClassUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ClassUnion> {
    return (
      ClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, ClassUnion>
    ).altLazy(
      () =>
        ClassUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, ClassUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_classUnion: ClassUnion, _hasher: HasherT): HasherT {
    if (ClassUnionMember1.isClassUnionMember1(_classUnion)) {
      return _classUnion.$hash(_hasher);
    }

    if (ClassUnionMember2.isClassUnionMember2(_classUnion)) {
      return _classUnion.$hash(_hasher);
    }

    throw new Error("unrecognized type");
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = ClassUnionMember1.$Json | ClassUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      ClassUnionMember1.$jsonZodSchema(),
      ClassUnionMember2.$jsonZodSchema(),
    ]);
  }

  export const $properties = {
    classUnionMemberCommonParentProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/classUnionMemberCommonParentProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ClassUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ClassUnion.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ClassUnion.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ClassUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...ClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("classUnionClassUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ClassUnionMember1`
          : "classUnionClassUnionMember1",
      }).concat(),
      ...ClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("classUnionClassUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ClassUnionMember2`
          : "classUnionClassUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ClassUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("classUnion");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: [
        {
          patterns: ClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!("classUnionClassUnionMember1"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ClassUnionMember1`
              : "classUnionClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: ClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!("classUnionClassUnionMember2"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ClassUnionMember2`
              : "classUnionClassUnionMember2",
          }).concat(),
          type: "group",
        },
      ],
      type: "union",
    });
    return patterns;
  }

  export function $toJson(
    _classUnion: ClassUnion,
  ): ClassUnionMember1.$Json | ClassUnionMember2.$Json {
    if (ClassUnionMember1.isClassUnionMember1(_classUnion)) {
      return _classUnion.$toJson();
    }

    if (ClassUnionMember2.isClassUnionMember2(_classUnion)) {
      return _classUnion.$toJson();
    }

    throw new Error("unrecognized type");
  }

  export function $toRdf(
    _classUnion: ClassUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    if (ClassUnionMember1.isClassUnionMember1(_classUnion)) {
      return _classUnion.$toRdf(_parameters);
    }

    if (ClassUnionMember2.isClassUnionMember2(_classUnion)) {
      return _classUnion.$toRdf(_parameters);
    }

    throw new Error("unrecognized type");
  }

  export function isClassUnion(object: $Object): object is ClassUnion {
    return (
      ClassUnionMember1.isClassUnionMember1(object) ||
      ClassUnionMember2.isClassUnionMember2(object)
    );
  }
}
/**
 * Node shape that unions a node shape and another union of node shapes. Generated code will usually flatten these.
 */
export type FlattenClassUnion =
  | ClassUnionMember1
  | ClassUnionMember2
  | FlattenClassUnionMember3;

export namespace FlattenClassUnion {
  export function $equals(
    left: FlattenClassUnion,
    right: FlattenClassUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      if (ClassUnionMember1.isClassUnionMember1(left)) {
        return left.$equals(right as unknown as ClassUnionMember1);
      }
      if (ClassUnionMember2.isClassUnionMember2(left)) {
        return left.$equals(right as unknown as ClassUnionMember2);
      }
      if (FlattenClassUnionMember3.isFlattenClassUnionMember3(left)) {
        return left.$equals(right as unknown as FlattenClassUnionMember3);
      }
      return $EqualsResult.Equal;
    });
  }

  export function $filter(
    filter: FlattenClassUnion.$Filter,
    value: FlattenClassUnion,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      ClassUnionMember1.isClassUnionMember1(value) &&
      filter.on?.ClassUnionMember1 &&
      !ClassUnionMember1.$filter(
        filter.on.ClassUnionMember1,
        value as ClassUnionMember1,
      )
    ) {
      return false;
    }

    if (
      ClassUnionMember2.isClassUnionMember2(value) &&
      filter.on?.ClassUnionMember2 &&
      !ClassUnionMember2.$filter(
        filter.on.ClassUnionMember2,
        value as ClassUnionMember2,
      )
    ) {
      return false;
    }

    if (
      FlattenClassUnionMember3.isFlattenClassUnionMember3(value) &&
      filter.on?.FlattenClassUnionMember3 &&
      !FlattenClassUnionMember3.$filter(
        filter.on.FlattenClassUnionMember3,
        value as FlattenClassUnionMember3,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly on?: {
      readonly ClassUnionMember1?: Omit<
        ClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly ClassUnionMember2?: Omit<
        ClassUnionMember2.$Filter,
        "$identifier"
      >;
      readonly FlattenClassUnionMember3?: Omit<
        FlattenClassUnionMember3.$Filter,
        "$identifier"
      >;
    };
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, FlattenClassUnion> {
    return (
      ClassUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        FlattenClassUnion
      >
    )
      .altLazy(
        () =>
          ClassUnionMember2.$fromJson(json) as purify.Either<
            zod.ZodError,
            FlattenClassUnion
          >,
      )
      .altLazy(
        () =>
          FlattenClassUnionMember3.$fromJson(json) as purify.Either<
            zod.ZodError,
            FlattenClassUnion
          >,
      );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, FlattenClassUnion> {
    return (
      ClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, FlattenClassUnion>
    )
      .altLazy(
        () =>
          ClassUnionMember2.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, FlattenClassUnion>,
      )
      .altLazy(
        () =>
          FlattenClassUnionMember3.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, FlattenClassUnion>,
      );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_flattenClassUnion: FlattenClassUnion, _hasher: HasherT): HasherT {
    if (ClassUnionMember1.isClassUnionMember1(_flattenClassUnion)) {
      return _flattenClassUnion.$hash(_hasher);
    }

    if (ClassUnionMember2.isClassUnionMember2(_flattenClassUnion)) {
      return _flattenClassUnion.$hash(_hasher);
    }

    if (
      FlattenClassUnionMember3.isFlattenClassUnionMember3(_flattenClassUnion)
    ) {
      return _flattenClassUnion.$hash(_hasher);
    }

    throw new Error("unrecognized type");
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json =
    | ClassUnionMember1.$Json
    | ClassUnionMember2.$Json
    | FlattenClassUnionMember3.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      ClassUnionMember1.$jsonZodSchema(),
      ClassUnionMember2.$jsonZodSchema(),
      FlattenClassUnionMember3.$jsonZodSchema(),
    ]);
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: FlattenClassUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        FlattenClassUnion.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            FlattenClassUnion.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: FlattenClassUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      FlattenClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...ClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("flattenClassUnionClassUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ClassUnionMember1`
          : "flattenClassUnionClassUnionMember1",
      }).concat(),
      ...ClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("flattenClassUnionClassUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ClassUnionMember2`
          : "flattenClassUnionClassUnionMember2",
      }).concat(),
      ...FlattenClassUnionMember3.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("flattenClassUnionFlattenClassUnionMember3"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}FlattenClassUnionMember3`
          : "flattenClassUnionFlattenClassUnionMember3",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: FlattenClassUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("flattenClassUnion");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: [
        {
          patterns: ClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!("flattenClassUnionClassUnionMember1"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ClassUnionMember1`
              : "flattenClassUnionClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: ClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!("flattenClassUnionClassUnionMember2"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ClassUnionMember2`
              : "flattenClassUnionClassUnionMember2",
          }).concat(),
          type: "group",
        },
        {
          patterns: FlattenClassUnionMember3.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.FlattenClassUnionMember3,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "flattenClassUnionFlattenClassUnionMember3",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}FlattenClassUnionMember3`
              : "flattenClassUnionFlattenClassUnionMember3",
          }).concat(),
          type: "group",
        },
      ],
      type: "union",
    });
    return patterns;
  }

  export function $toJson(
    _flattenClassUnion: FlattenClassUnion,
  ):
    | ClassUnionMember1.$Json
    | ClassUnionMember2.$Json
    | FlattenClassUnionMember3.$Json {
    if (ClassUnionMember1.isClassUnionMember1(_flattenClassUnion)) {
      return _flattenClassUnion.$toJson();
    }

    if (ClassUnionMember2.isClassUnionMember2(_flattenClassUnion)) {
      return _flattenClassUnion.$toJson();
    }

    if (
      FlattenClassUnionMember3.isFlattenClassUnionMember3(_flattenClassUnion)
    ) {
      return _flattenClassUnion.$toJson();
    }

    throw new Error("unrecognized type");
  }

  export function $toRdf(
    _flattenClassUnion: FlattenClassUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    if (ClassUnionMember1.isClassUnionMember1(_flattenClassUnion)) {
      return _flattenClassUnion.$toRdf(_parameters);
    }

    if (ClassUnionMember2.isClassUnionMember2(_flattenClassUnion)) {
      return _flattenClassUnion.$toRdf(_parameters);
    }

    if (
      FlattenClassUnionMember3.isFlattenClassUnionMember3(_flattenClassUnion)
    ) {
      return _flattenClassUnion.$toRdf(_parameters);
    }

    throw new Error("unrecognized type");
  }

  export function isFlattenClassUnion(
    object: $Object,
  ): object is FlattenClassUnion {
    return (
      ClassUnionMember1.isClassUnionMember1(object) ||
      ClassUnionMember2.isClassUnionMember2(object) ||
      FlattenClassUnionMember3.isFlattenClassUnionMember3(object)
    );
  }
}
/**
 * Node shape that sh:xone's other node shapes. This will usually be generated as a discriminated union.
 */
export type InterfaceUnion = InterfaceUnionMember1 | InterfaceUnionMember2;

export namespace InterfaceUnion {
  export function $equals(
    left: InterfaceUnion,
    right: InterfaceUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      if (InterfaceUnionMember1.isInterfaceUnionMember1(left)) {
        return InterfaceUnionMember1.$equals(
          left,
          right as unknown as InterfaceUnionMember1,
        );
      }
      if (InterfaceUnionMember2.isInterfaceUnionMember2(left)) {
        return InterfaceUnionMember2.$equals(
          left,
          right as unknown as InterfaceUnionMember2,
        );
      }
      return $EqualsResult.Equal;
    });
  }

  export function $filter(
    filter: InterfaceUnion.$Filter,
    value: InterfaceUnion,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      InterfaceUnionMember1.isInterfaceUnionMember1(value) &&
      filter.on?.InterfaceUnionMember1 &&
      !InterfaceUnionMember1.$filter(
        filter.on.InterfaceUnionMember1,
        value as InterfaceUnionMember1,
      )
    ) {
      return false;
    }

    if (
      InterfaceUnionMember2.isInterfaceUnionMember2(value) &&
      filter.on?.InterfaceUnionMember2 &&
      !InterfaceUnionMember2.$filter(
        filter.on.InterfaceUnionMember2,
        value as InterfaceUnionMember2,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly on?: {
      readonly InterfaceUnionMember1?: Omit<
        InterfaceUnionMember1.$Filter,
        "$identifier"
      >;
      readonly InterfaceUnionMember2?: Omit<
        InterfaceUnionMember2.$Filter,
        "$identifier"
      >;
    };
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, InterfaceUnion> {
    return (
      InterfaceUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        InterfaceUnion
      >
    ).altLazy(
      () =>
        InterfaceUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          InterfaceUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, InterfaceUnion> {
    return (
      InterfaceUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, InterfaceUnion>
    ).altLazy(
      () =>
        InterfaceUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, InterfaceUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_interfaceUnion: InterfaceUnion, _hasher: HasherT): HasherT {
    if (InterfaceUnionMember1.isInterfaceUnionMember1(_interfaceUnion)) {
      return InterfaceUnionMember1.$hash(_interfaceUnion, _hasher);
    }

    if (InterfaceUnionMember2.isInterfaceUnionMember2(_interfaceUnion)) {
      return InterfaceUnionMember2.$hash(_interfaceUnion, _hasher);
    }

    throw new Error("unrecognized type");
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = InterfaceUnionMember1.$Json | InterfaceUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      InterfaceUnionMember1.$jsonZodSchema(),
      InterfaceUnionMember2.$jsonZodSchema(),
    ]);
  }

  export const $properties = {
    interfaceUnionMemberCommonParentProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/interfaceUnionMemberCommonParentProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: InterfaceUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InterfaceUnion.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            InterfaceUnion.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: InterfaceUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InterfaceUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...InterfaceUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("interfaceUnionInterfaceUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}InterfaceUnionMember1`
          : "interfaceUnionInterfaceUnionMember1",
      }).concat(),
      ...InterfaceUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("interfaceUnionInterfaceUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}InterfaceUnionMember2`
          : "interfaceUnionInterfaceUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: InterfaceUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("interfaceUnion");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: [
        {
          patterns: InterfaceUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.InterfaceUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!("interfaceUnionInterfaceUnionMember1"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}InterfaceUnionMember1`
              : "interfaceUnionInterfaceUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: InterfaceUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.InterfaceUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!("interfaceUnionInterfaceUnionMember2"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}InterfaceUnionMember2`
              : "interfaceUnionInterfaceUnionMember2",
          }).concat(),
          type: "group",
        },
      ],
      type: "union",
    });
    return patterns;
  }

  export function $toJson(
    _interfaceUnion: InterfaceUnion,
  ): InterfaceUnionMember1.$Json | InterfaceUnionMember2.$Json {
    if (InterfaceUnionMember1.isInterfaceUnionMember1(_interfaceUnion)) {
      return InterfaceUnionMember1.$toJson(_interfaceUnion);
    }

    if (InterfaceUnionMember2.isInterfaceUnionMember2(_interfaceUnion)) {
      return InterfaceUnionMember2.$toJson(_interfaceUnion);
    }

    throw new Error("unrecognized type");
  }

  export function $toRdf(
    _interfaceUnion: InterfaceUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    if (InterfaceUnionMember1.isInterfaceUnionMember1(_interfaceUnion)) {
      return InterfaceUnionMember1.$toRdf(_interfaceUnion, _parameters);
    }

    if (InterfaceUnionMember2.isInterfaceUnionMember2(_interfaceUnion)) {
      return InterfaceUnionMember2.$toRdf(_interfaceUnion, _parameters);
    }

    throw new Error("unrecognized type");
  }

  export function isInterfaceUnion(object: $Object): object is InterfaceUnion {
    return (
      InterfaceUnionMember1.isInterfaceUnionMember1(object) ||
      InterfaceUnionMember2.isInterfaceUnionMember2(object)
    );
  }
}
/**
 * Node shape sh:xone's other node shapes. This will usually be generated as a discriminated union.
 */
export type LazilyResolvedClassUnion =
  | LazilyResolvedClassUnionMember1
  | LazilyResolvedClassUnionMember2;

export namespace LazilyResolvedClassUnion {
  export function $equals(
    left: LazilyResolvedClassUnion,
    right: LazilyResolvedClassUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      if (
        LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(left)
      ) {
        return left.$equals(
          right as unknown as LazilyResolvedClassUnionMember1,
        );
      }
      if (
        LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(left)
      ) {
        return left.$equals(
          right as unknown as LazilyResolvedClassUnionMember2,
        );
      }
      return $EqualsResult.Equal;
    });
  }

  export function $filter(
    filter: LazilyResolvedClassUnion.$Filter,
    value: LazilyResolvedClassUnion,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(
        value,
      ) &&
      filter.on?.LazilyResolvedClassUnionMember1 &&
      !LazilyResolvedClassUnionMember1.$filter(
        filter.on.LazilyResolvedClassUnionMember1,
        value as LazilyResolvedClassUnionMember1,
      )
    ) {
      return false;
    }

    if (
      LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(
        value,
      ) &&
      filter.on?.LazilyResolvedClassUnionMember2 &&
      !LazilyResolvedClassUnionMember2.$filter(
        filter.on.LazilyResolvedClassUnionMember2,
        value as LazilyResolvedClassUnionMember2,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly on?: {
      readonly LazilyResolvedClassUnionMember1?: Omit<
        LazilyResolvedClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly LazilyResolvedClassUnionMember2?: Omit<
        LazilyResolvedClassUnionMember2.$Filter,
        "$identifier"
      >;
    };
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedClassUnion> {
    return (
      LazilyResolvedClassUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        LazilyResolvedClassUnion
      >
    ).altLazy(
      () =>
        LazilyResolvedClassUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          LazilyResolvedClassUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedClassUnion> {
    return (
      LazilyResolvedClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, LazilyResolvedClassUnion>
    ).altLazy(
      () =>
        LazilyResolvedClassUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, LazilyResolvedClassUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedClassUnion: LazilyResolvedClassUnion,
    _hasher: HasherT,
  ): HasherT {
    if (
      LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(
        _lazilyResolvedClassUnion,
      )
    ) {
      return _lazilyResolvedClassUnion.$hash(_hasher);
    }

    if (
      LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(
        _lazilyResolvedClassUnion,
      )
    ) {
      return _lazilyResolvedClassUnion.$hash(_hasher);
    }

    throw new Error("unrecognized type");
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json =
    | LazilyResolvedClassUnionMember1.$Json
    | LazilyResolvedClassUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      LazilyResolvedClassUnionMember1.$jsonZodSchema(),
      LazilyResolvedClassUnionMember2.$jsonZodSchema(),
    ]);
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedClassUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedClassUnion.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazilyResolvedClassUnion.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedClassUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...LazilyResolvedClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "lazilyResolvedClassUnionLazilyResolvedClassUnionMember1",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember1`
          : "lazilyResolvedClassUnionLazilyResolvedClassUnionMember1",
      }).concat(),
      ...LazilyResolvedClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "lazilyResolvedClassUnionLazilyResolvedClassUnionMember2",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember2`
          : "lazilyResolvedClassUnionLazilyResolvedClassUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedClassUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("lazilyResolvedClassUnion");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: [
        {
          patterns: LazilyResolvedClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazilyResolvedClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "lazilyResolvedClassUnionLazilyResolvedClassUnionMember1",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember1`
              : "lazilyResolvedClassUnionLazilyResolvedClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: LazilyResolvedClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazilyResolvedClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "lazilyResolvedClassUnionLazilyResolvedClassUnionMember2",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember2`
              : "lazilyResolvedClassUnionLazilyResolvedClassUnionMember2",
          }).concat(),
          type: "group",
        },
      ],
      type: "union",
    });
    return patterns;
  }

  export function $toJson(
    _lazilyResolvedClassUnion: LazilyResolvedClassUnion,
  ):
    | LazilyResolvedClassUnionMember1.$Json
    | LazilyResolvedClassUnionMember2.$Json {
    if (
      LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(
        _lazilyResolvedClassUnion,
      )
    ) {
      return _lazilyResolvedClassUnion.$toJson();
    }

    if (
      LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(
        _lazilyResolvedClassUnion,
      )
    ) {
      return _lazilyResolvedClassUnion.$toJson();
    }

    throw new Error("unrecognized type");
  }

  export function $toRdf(
    _lazilyResolvedClassUnion: LazilyResolvedClassUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    if (
      LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(
        _lazilyResolvedClassUnion,
      )
    ) {
      return _lazilyResolvedClassUnion.$toRdf(_parameters);
    }

    if (
      LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(
        _lazilyResolvedClassUnion,
      )
    ) {
      return _lazilyResolvedClassUnion.$toRdf(_parameters);
    }

    throw new Error("unrecognized type");
  }

  export function isLazilyResolvedClassUnion(
    object: $Object,
  ): object is LazilyResolvedClassUnion {
    return (
      LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(
        object,
      ) ||
      LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(object)
    );
  }
}
/**
 * Node shape sh:xone's other node shapes. This will usually be generated as a discriminated union.
 */
export type LazilyResolvedInterfaceUnion =
  | LazilyResolvedInterfaceUnionMember1
  | LazilyResolvedInterfaceUnionMember2;

export namespace LazilyResolvedInterfaceUnion {
  export function $equals(
    left: LazilyResolvedInterfaceUnion,
    right: LazilyResolvedInterfaceUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      if (
        LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
          left,
        )
      ) {
        return LazilyResolvedInterfaceUnionMember1.$equals(
          left,
          right as unknown as LazilyResolvedInterfaceUnionMember1,
        );
      }
      if (
        LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
          left,
        )
      ) {
        return LazilyResolvedInterfaceUnionMember2.$equals(
          left,
          right as unknown as LazilyResolvedInterfaceUnionMember2,
        );
      }
      return $EqualsResult.Equal;
    });
  }

  export function $filter(
    filter: LazilyResolvedInterfaceUnion.$Filter,
    value: LazilyResolvedInterfaceUnion,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
        value,
      ) &&
      filter.on?.LazilyResolvedInterfaceUnionMember1 &&
      !LazilyResolvedInterfaceUnionMember1.$filter(
        filter.on.LazilyResolvedInterfaceUnionMember1,
        value as LazilyResolvedInterfaceUnionMember1,
      )
    ) {
      return false;
    }

    if (
      LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
        value,
      ) &&
      filter.on?.LazilyResolvedInterfaceUnionMember2 &&
      !LazilyResolvedInterfaceUnionMember2.$filter(
        filter.on.LazilyResolvedInterfaceUnionMember2,
        value as LazilyResolvedInterfaceUnionMember2,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly on?: {
      readonly LazilyResolvedInterfaceUnionMember1?: Omit<
        LazilyResolvedInterfaceUnionMember1.$Filter,
        "$identifier"
      >;
      readonly LazilyResolvedInterfaceUnionMember2?: Omit<
        LazilyResolvedInterfaceUnionMember2.$Filter,
        "$identifier"
      >;
    };
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedInterfaceUnion> {
    return (
      LazilyResolvedInterfaceUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        LazilyResolvedInterfaceUnion
      >
    ).altLazy(
      () =>
        LazilyResolvedInterfaceUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          LazilyResolvedInterfaceUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedInterfaceUnion> {
    return (
      LazilyResolvedInterfaceUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, LazilyResolvedInterfaceUnion>
    ).altLazy(
      () =>
        LazilyResolvedInterfaceUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, LazilyResolvedInterfaceUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedInterfaceUnion: LazilyResolvedInterfaceUnion,
    _hasher: HasherT,
  ): HasherT {
    if (
      LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
        _lazilyResolvedInterfaceUnion,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember1.$hash(
        _lazilyResolvedInterfaceUnion,
        _hasher,
      );
    }

    if (
      LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
        _lazilyResolvedInterfaceUnion,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember2.$hash(
        _lazilyResolvedInterfaceUnion,
        _hasher,
      );
    }

    throw new Error("unrecognized type");
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json =
    | LazilyResolvedInterfaceUnionMember1.$Json
    | LazilyResolvedInterfaceUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      LazilyResolvedInterfaceUnionMember1.$jsonZodSchema(),
      LazilyResolvedInterfaceUnionMember2.$jsonZodSchema(),
    ]);
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedInterfaceUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedInterfaceUnion.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazilyResolvedInterfaceUnion.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedInterfaceUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedInterfaceUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...LazilyResolvedInterfaceUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember1",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember1`
          : "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember1",
      }).concat(),
      ...LazilyResolvedInterfaceUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember2",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember2`
          : "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedInterfaceUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedInterfaceUnion");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: [
        {
          patterns: LazilyResolvedInterfaceUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazilyResolvedInterfaceUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember1",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember1`
              : "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: LazilyResolvedInterfaceUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazilyResolvedInterfaceUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember2",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember2`
              : "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember2",
          }).concat(),
          type: "group",
        },
      ],
      type: "union",
    });
    return patterns;
  }

  export function $toJson(
    _lazilyResolvedInterfaceUnion: LazilyResolvedInterfaceUnion,
  ):
    | LazilyResolvedInterfaceUnionMember1.$Json
    | LazilyResolvedInterfaceUnionMember2.$Json {
    if (
      LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
        _lazilyResolvedInterfaceUnion,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember1.$toJson(
        _lazilyResolvedInterfaceUnion,
      );
    }

    if (
      LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
        _lazilyResolvedInterfaceUnion,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember2.$toJson(
        _lazilyResolvedInterfaceUnion,
      );
    }

    throw new Error("unrecognized type");
  }

  export function $toRdf(
    _lazilyResolvedInterfaceUnion: LazilyResolvedInterfaceUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    if (
      LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
        _lazilyResolvedInterfaceUnion,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember1.$toRdf(
        _lazilyResolvedInterfaceUnion,
        _parameters,
      );
    }

    if (
      LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
        _lazilyResolvedInterfaceUnion,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember2.$toRdf(
        _lazilyResolvedInterfaceUnion,
        _parameters,
      );
    }

    throw new Error("unrecognized type");
  }

  export function isLazilyResolvedInterfaceUnion(
    object: $Object,
  ): object is LazilyResolvedInterfaceUnion {
    return (
      LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
        object,
      ) ||
      LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
        object,
      )
    );
  }
}
/**
 * Counterpart of ClassUnion for lazy resolution. The partial union must have the same number of members, in the corresponding order, as the 'full' union.
 */
export type PartialClassUnion =
  | PartialClassUnionMember1
  | PartialClassUnionMember2;

export namespace PartialClassUnion {
  export function $equals(
    left: PartialClassUnion,
    right: PartialClassUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      if (PartialClassUnionMember1.isPartialClassUnionMember1(left)) {
        return left.$equals(right as unknown as PartialClassUnionMember1);
      }
      if (PartialClassUnionMember2.isPartialClassUnionMember2(left)) {
        return left.$equals(right as unknown as PartialClassUnionMember2);
      }
      return $EqualsResult.Equal;
    });
  }

  export function $filter(
    filter: PartialClassUnion.$Filter,
    value: PartialClassUnion,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      PartialClassUnionMember1.isPartialClassUnionMember1(value) &&
      filter.on?.PartialClassUnionMember1 &&
      !PartialClassUnionMember1.$filter(
        filter.on.PartialClassUnionMember1,
        value as PartialClassUnionMember1,
      )
    ) {
      return false;
    }

    if (
      PartialClassUnionMember2.isPartialClassUnionMember2(value) &&
      filter.on?.PartialClassUnionMember2 &&
      !PartialClassUnionMember2.$filter(
        filter.on.PartialClassUnionMember2,
        value as PartialClassUnionMember2,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly on?: {
      readonly PartialClassUnionMember1?: Omit<
        PartialClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly PartialClassUnionMember2?: Omit<
        PartialClassUnionMember2.$Filter,
        "$identifier"
      >;
    };
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialClassUnion> {
    return (
      PartialClassUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        PartialClassUnion
      >
    ).altLazy(
      () =>
        PartialClassUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          PartialClassUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialClassUnion> {
    return (
      PartialClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, PartialClassUnion>
    ).altLazy(
      () =>
        PartialClassUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, PartialClassUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_partialClassUnion: PartialClassUnion, _hasher: HasherT): HasherT {
    if (
      PartialClassUnionMember1.isPartialClassUnionMember1(_partialClassUnion)
    ) {
      return _partialClassUnion.$hash(_hasher);
    }

    if (
      PartialClassUnionMember2.isPartialClassUnionMember2(_partialClassUnion)
    ) {
      return _partialClassUnion.$hash(_hasher);
    }

    throw new Error("unrecognized type");
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json =
    | PartialClassUnionMember1.$Json
    | PartialClassUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      PartialClassUnionMember1.$jsonZodSchema(),
      PartialClassUnionMember2.$jsonZodSchema(),
    ]);
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialClassUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialClassUnion.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            PartialClassUnion.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialClassUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...PartialClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("partialClassUnionPartialClassUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialClassUnionMember1`
          : "partialClassUnionPartialClassUnionMember1",
      }).concat(),
      ...PartialClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("partialClassUnionPartialClassUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialClassUnionMember2`
          : "partialClassUnionPartialClassUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialClassUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClassUnion");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: [
        {
          patterns: PartialClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PartialClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "partialClassUnionPartialClassUnionMember1",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PartialClassUnionMember1`
              : "partialClassUnionPartialClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: PartialClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PartialClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "partialClassUnionPartialClassUnionMember2",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PartialClassUnionMember2`
              : "partialClassUnionPartialClassUnionMember2",
          }).concat(),
          type: "group",
        },
      ],
      type: "union",
    });
    return patterns;
  }

  export function $toJson(
    _partialClassUnion: PartialClassUnion,
  ): PartialClassUnionMember1.$Json | PartialClassUnionMember2.$Json {
    if (
      PartialClassUnionMember1.isPartialClassUnionMember1(_partialClassUnion)
    ) {
      return _partialClassUnion.$toJson();
    }

    if (
      PartialClassUnionMember2.isPartialClassUnionMember2(_partialClassUnion)
    ) {
      return _partialClassUnion.$toJson();
    }

    throw new Error("unrecognized type");
  }

  export function $toRdf(
    _partialClassUnion: PartialClassUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    if (
      PartialClassUnionMember1.isPartialClassUnionMember1(_partialClassUnion)
    ) {
      return _partialClassUnion.$toRdf(_parameters);
    }

    if (
      PartialClassUnionMember2.isPartialClassUnionMember2(_partialClassUnion)
    ) {
      return _partialClassUnion.$toRdf(_parameters);
    }

    throw new Error("unrecognized type");
  }

  export function isPartialClassUnion(
    object: $Object,
  ): object is PartialClassUnion {
    return (
      PartialClassUnionMember1.isPartialClassUnionMember1(object) ||
      PartialClassUnionMember2.isPartialClassUnionMember2(object)
    );
  }
}
/**
 * Counterpart of InterfaceUnion for lazy resolution. The partial union must have the same number of members, in the corresponding order, as the 'full' union.
 */
export type PartialInterfaceUnion =
  | PartialInterfaceUnionMember1
  | PartialInterfaceUnionMember2;

export namespace PartialInterfaceUnion {
  export function $equals(
    left: PartialInterfaceUnion,
    right: PartialInterfaceUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      if (PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(left)) {
        return PartialInterfaceUnionMember1.$equals(
          left,
          right as unknown as PartialInterfaceUnionMember1,
        );
      }
      if (PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(left)) {
        return PartialInterfaceUnionMember2.$equals(
          left,
          right as unknown as PartialInterfaceUnionMember2,
        );
      }
      return $EqualsResult.Equal;
    });
  }

  export function $filter(
    filter: PartialInterfaceUnion.$Filter,
    value: PartialInterfaceUnion,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(value) &&
      filter.on?.PartialInterfaceUnionMember1 &&
      !PartialInterfaceUnionMember1.$filter(
        filter.on.PartialInterfaceUnionMember1,
        value as PartialInterfaceUnionMember1,
      )
    ) {
      return false;
    }

    if (
      PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(value) &&
      filter.on?.PartialInterfaceUnionMember2 &&
      !PartialInterfaceUnionMember2.$filter(
        filter.on.PartialInterfaceUnionMember2,
        value as PartialInterfaceUnionMember2,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly on?: {
      readonly PartialInterfaceUnionMember1?: Omit<
        PartialInterfaceUnionMember1.$Filter,
        "$identifier"
      >;
      readonly PartialInterfaceUnionMember2?: Omit<
        PartialInterfaceUnionMember2.$Filter,
        "$identifier"
      >;
    };
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialInterfaceUnion> {
    return (
      PartialInterfaceUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        PartialInterfaceUnion
      >
    ).altLazy(
      () =>
        PartialInterfaceUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          PartialInterfaceUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialInterfaceUnion> {
    return (
      PartialInterfaceUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, PartialInterfaceUnion>
    ).altLazy(
      () =>
        PartialInterfaceUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, PartialInterfaceUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_partialInterfaceUnion: PartialInterfaceUnion, _hasher: HasherT): HasherT {
    if (
      PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(
        _partialInterfaceUnion,
      )
    ) {
      return PartialInterfaceUnionMember1.$hash(
        _partialInterfaceUnion,
        _hasher,
      );
    }

    if (
      PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(
        _partialInterfaceUnion,
      )
    ) {
      return PartialInterfaceUnionMember2.$hash(
        _partialInterfaceUnion,
        _hasher,
      );
    }

    throw new Error("unrecognized type");
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json =
    | PartialInterfaceUnionMember1.$Json
    | PartialInterfaceUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      PartialInterfaceUnionMember1.$jsonZodSchema(),
      PartialInterfaceUnionMember2.$jsonZodSchema(),
    ]);
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialInterfaceUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialInterfaceUnion.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            PartialInterfaceUnion.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialInterfaceUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialInterfaceUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...PartialInterfaceUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "partialInterfaceUnionPartialInterfaceUnionMember1",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialInterfaceUnionMember1`
          : "partialInterfaceUnionPartialInterfaceUnionMember1",
      }).concat(),
      ...PartialInterfaceUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "partialInterfaceUnionPartialInterfaceUnionMember2",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialInterfaceUnionMember2`
          : "partialInterfaceUnionPartialInterfaceUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialInterfaceUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialInterfaceUnion");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: [
        {
          patterns: PartialInterfaceUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PartialInterfaceUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "partialInterfaceUnionPartialInterfaceUnionMember1",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PartialInterfaceUnionMember1`
              : "partialInterfaceUnionPartialInterfaceUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: PartialInterfaceUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PartialInterfaceUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "partialInterfaceUnionPartialInterfaceUnionMember2",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PartialInterfaceUnionMember2`
              : "partialInterfaceUnionPartialInterfaceUnionMember2",
          }).concat(),
          type: "group",
        },
      ],
      type: "union",
    });
    return patterns;
  }

  export function $toJson(
    _partialInterfaceUnion: PartialInterfaceUnion,
  ): PartialInterfaceUnionMember1.$Json | PartialInterfaceUnionMember2.$Json {
    if (
      PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(
        _partialInterfaceUnion,
      )
    ) {
      return PartialInterfaceUnionMember1.$toJson(_partialInterfaceUnion);
    }

    if (
      PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(
        _partialInterfaceUnion,
      )
    ) {
      return PartialInterfaceUnionMember2.$toJson(_partialInterfaceUnion);
    }

    throw new Error("unrecognized type");
  }

  export function $toRdf(
    _partialInterfaceUnion: PartialInterfaceUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    if (
      PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(
        _partialInterfaceUnion,
      )
    ) {
      return PartialInterfaceUnionMember1.$toRdf(
        _partialInterfaceUnion,
        _parameters,
      );
    }

    if (
      PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(
        _partialInterfaceUnion,
      )
    ) {
      return PartialInterfaceUnionMember2.$toRdf(
        _partialInterfaceUnion,
        _parameters,
      );
    }

    throw new Error("unrecognized type");
  }

  export function isPartialInterfaceUnion(
    object: $Object,
  ): object is PartialInterfaceUnion {
    return (
      PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(object) ||
      PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(object)
    );
  }
}
/**
 * Node shape sh:xone's other node shapes. These don't have RDF types since they're not owl:Class's
 */
export type NoRdfTypeClassUnion =
  | NoRdfTypeClassUnionMember1
  | NoRdfTypeClassUnionMember2;

export namespace NoRdfTypeClassUnion {
  export function $equals(
    left: NoRdfTypeClassUnion,
    right: NoRdfTypeClassUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      if (NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(left)) {
        return left.$equals(right as unknown as NoRdfTypeClassUnionMember1);
      }
      if (NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(left)) {
        return left.$equals(right as unknown as NoRdfTypeClassUnionMember2);
      }
      return $EqualsResult.Equal;
    });
  }

  export function $filter(
    filter: NoRdfTypeClassUnion.$Filter,
    value: NoRdfTypeClassUnion,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(value) &&
      filter.on?.NoRdfTypeClassUnionMember1 &&
      !NoRdfTypeClassUnionMember1.$filter(
        filter.on.NoRdfTypeClassUnionMember1,
        value as NoRdfTypeClassUnionMember1,
      )
    ) {
      return false;
    }

    if (
      NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(value) &&
      filter.on?.NoRdfTypeClassUnionMember2 &&
      !NoRdfTypeClassUnionMember2.$filter(
        filter.on.NoRdfTypeClassUnionMember2,
        value as NoRdfTypeClassUnionMember2,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly on?: {
      readonly NoRdfTypeClassUnionMember1?: Omit<
        NoRdfTypeClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly NoRdfTypeClassUnionMember2?: Omit<
        NoRdfTypeClassUnionMember2.$Filter,
        "$identifier"
      >;
    };
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, NoRdfTypeClassUnion> {
    return (
      NoRdfTypeClassUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        NoRdfTypeClassUnion
      >
    ).altLazy(
      () =>
        NoRdfTypeClassUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          NoRdfTypeClassUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, NoRdfTypeClassUnion> {
    return (
      NoRdfTypeClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, NoRdfTypeClassUnion>
    ).altLazy(
      () =>
        NoRdfTypeClassUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, NoRdfTypeClassUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_noRdfTypeClassUnion: NoRdfTypeClassUnion, _hasher: HasherT): HasherT {
    if (
      NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(
        _noRdfTypeClassUnion,
      )
    ) {
      return _noRdfTypeClassUnion.$hash(_hasher);
    }

    if (
      NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(
        _noRdfTypeClassUnion,
      )
    ) {
      return _noRdfTypeClassUnion.$hash(_hasher);
    }

    throw new Error("unrecognized type");
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json =
    | NoRdfTypeClassUnionMember1.$Json
    | NoRdfTypeClassUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      NoRdfTypeClassUnionMember1.$jsonZodSchema(),
      NoRdfTypeClassUnionMember2.$jsonZodSchema(),
    ]);
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: NoRdfTypeClassUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        NoRdfTypeClassUnion.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            NoRdfTypeClassUnion.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: NoRdfTypeClassUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      NoRdfTypeClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...NoRdfTypeClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "noRdfTypeClassUnionNoRdfTypeClassUnionMember1",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}NoRdfTypeClassUnionMember1`
          : "noRdfTypeClassUnionNoRdfTypeClassUnionMember1",
      }).concat(),
      ...NoRdfTypeClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "noRdfTypeClassUnionNoRdfTypeClassUnionMember2",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}NoRdfTypeClassUnionMember2`
          : "noRdfTypeClassUnionNoRdfTypeClassUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: NoRdfTypeClassUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("noRdfTypeClassUnion");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: [
        {
          patterns: NoRdfTypeClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.NoRdfTypeClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "noRdfTypeClassUnionNoRdfTypeClassUnionMember1",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}NoRdfTypeClassUnionMember1`
              : "noRdfTypeClassUnionNoRdfTypeClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: NoRdfTypeClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.NoRdfTypeClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "noRdfTypeClassUnionNoRdfTypeClassUnionMember2",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}NoRdfTypeClassUnionMember2`
              : "noRdfTypeClassUnionNoRdfTypeClassUnionMember2",
          }).concat(),
          type: "group",
        },
      ],
      type: "union",
    });
    return patterns;
  }

  export function $toJson(
    _noRdfTypeClassUnion: NoRdfTypeClassUnion,
  ): NoRdfTypeClassUnionMember1.$Json | NoRdfTypeClassUnionMember2.$Json {
    if (
      NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(
        _noRdfTypeClassUnion,
      )
    ) {
      return _noRdfTypeClassUnion.$toJson();
    }

    if (
      NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(
        _noRdfTypeClassUnion,
      )
    ) {
      return _noRdfTypeClassUnion.$toJson();
    }

    throw new Error("unrecognized type");
  }

  export function $toRdf(
    _noRdfTypeClassUnion: NoRdfTypeClassUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    if (
      NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(
        _noRdfTypeClassUnion,
      )
    ) {
      return _noRdfTypeClassUnion.$toRdf(_parameters);
    }

    if (
      NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(
        _noRdfTypeClassUnion,
      )
    ) {
      return _noRdfTypeClassUnion.$toRdf(_parameters);
    }

    throw new Error("unrecognized type");
  }

  export function isNoRdfTypeClassUnion(
    object: $Object,
  ): object is NoRdfTypeClassUnion {
    return (
      NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(object) ||
      NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(object)
    );
  }
}
/**
 * Node shape sh:xone's node shapes that have properties with the union's type
 */
export type RecursiveClassUnion =
  | RecursiveClassUnionMember1
  | RecursiveClassUnionMember2;

export namespace RecursiveClassUnion {
  export function $equals(
    left: RecursiveClassUnion,
    right: RecursiveClassUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      if (RecursiveClassUnionMember1.isRecursiveClassUnionMember1(left)) {
        return left.$equals(right as unknown as RecursiveClassUnionMember1);
      }
      if (RecursiveClassUnionMember2.isRecursiveClassUnionMember2(left)) {
        return left.$equals(right as unknown as RecursiveClassUnionMember2);
      }
      return $EqualsResult.Equal;
    });
  }

  export function $filter(
    filter: RecursiveClassUnion.$Filter,
    value: RecursiveClassUnion,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      RecursiveClassUnionMember1.isRecursiveClassUnionMember1(value) &&
      filter.on?.RecursiveClassUnionMember1 &&
      !RecursiveClassUnionMember1.$filter(
        filter.on.RecursiveClassUnionMember1,
        value as RecursiveClassUnionMember1,
      )
    ) {
      return false;
    }

    if (
      RecursiveClassUnionMember2.isRecursiveClassUnionMember2(value) &&
      filter.on?.RecursiveClassUnionMember2 &&
      !RecursiveClassUnionMember2.$filter(
        filter.on.RecursiveClassUnionMember2,
        value as RecursiveClassUnionMember2,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly on?: {
      readonly RecursiveClassUnionMember1?: Omit<
        RecursiveClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly RecursiveClassUnionMember2?: Omit<
        RecursiveClassUnionMember2.$Filter,
        "$identifier"
      >;
    };
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, RecursiveClassUnion> {
    return (
      RecursiveClassUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        RecursiveClassUnion
      >
    ).altLazy(
      () =>
        RecursiveClassUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          RecursiveClassUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, RecursiveClassUnion> {
    return (
      RecursiveClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, RecursiveClassUnion>
    ).altLazy(
      () =>
        RecursiveClassUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, RecursiveClassUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_recursiveClassUnion: RecursiveClassUnion, _hasher: HasherT): HasherT {
    if (
      RecursiveClassUnionMember1.isRecursiveClassUnionMember1(
        _recursiveClassUnion,
      )
    ) {
      return _recursiveClassUnion.$hash(_hasher);
    }

    if (
      RecursiveClassUnionMember2.isRecursiveClassUnionMember2(
        _recursiveClassUnion,
      )
    ) {
      return _recursiveClassUnion.$hash(_hasher);
    }

    throw new Error("unrecognized type");
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json =
    | RecursiveClassUnionMember1.$Json
    | RecursiveClassUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      RecursiveClassUnionMember1.$jsonZodSchema(),
      RecursiveClassUnionMember2.$jsonZodSchema(),
    ]);
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: RecursiveClassUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        RecursiveClassUnion.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            RecursiveClassUnion.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: RecursiveClassUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      RecursiveClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...RecursiveClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "recursiveClassUnionRecursiveClassUnionMember1",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}RecursiveClassUnionMember1`
          : "recursiveClassUnionRecursiveClassUnionMember1",
      }).concat(),
      ...RecursiveClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "recursiveClassUnionRecursiveClassUnionMember2",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}RecursiveClassUnionMember2`
          : "recursiveClassUnionRecursiveClassUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: RecursiveClassUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("recursiveClassUnion");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: [
        {
          patterns: RecursiveClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.RecursiveClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "recursiveClassUnionRecursiveClassUnionMember1",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}RecursiveClassUnionMember1`
              : "recursiveClassUnionRecursiveClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: RecursiveClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.RecursiveClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "recursiveClassUnionRecursiveClassUnionMember2",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}RecursiveClassUnionMember2`
              : "recursiveClassUnionRecursiveClassUnionMember2",
          }).concat(),
          type: "group",
        },
      ],
      type: "union",
    });
    return patterns;
  }

  export function $toJson(
    _recursiveClassUnion: RecursiveClassUnion,
  ): RecursiveClassUnionMember1.$Json | RecursiveClassUnionMember2.$Json {
    if (
      RecursiveClassUnionMember1.isRecursiveClassUnionMember1(
        _recursiveClassUnion,
      )
    ) {
      return _recursiveClassUnion.$toJson();
    }

    if (
      RecursiveClassUnionMember2.isRecursiveClassUnionMember2(
        _recursiveClassUnion,
      )
    ) {
      return _recursiveClassUnion.$toJson();
    }

    throw new Error("unrecognized type");
  }

  export function $toRdf(
    _recursiveClassUnion: RecursiveClassUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    if (
      RecursiveClassUnionMember1.isRecursiveClassUnionMember1(
        _recursiveClassUnion,
      )
    ) {
      return _recursiveClassUnion.$toRdf(_parameters);
    }

    if (
      RecursiveClassUnionMember2.isRecursiveClassUnionMember2(
        _recursiveClassUnion,
      )
    ) {
      return _recursiveClassUnion.$toRdf(_parameters);
    }

    throw new Error("unrecognized type");
  }

  export function isRecursiveClassUnion(
    object: $Object,
  ): object is RecursiveClassUnion {
    return (
      RecursiveClassUnionMember1.isRecursiveClassUnionMember1(object) ||
      RecursiveClassUnionMember2.isRecursiveClassUnionMember2(object)
    );
  }
}
export type $Object =
  | BlankNodeIdentifierClass
  | BlankNodeIdentifierInterface
  | BlankNodeOrIriIdentifierClass
  | BlankNodeOrIriIdentifierInterface
  | ClassUnionMember1
  | ClassUnionMember2
  | ClassUnionMemberCommonParent
  | ConcreteChildClass
  | ConcreteParentClass
  | AbstractBaseClassWithoutProperties
  | AbstractBaseClassWithProperties
  | ConcreteChildInterface
  | ConcreteParentInterface
  | BaseInterfaceWithoutProperties
  | BaseInterfaceWithProperties
  | ConvertibleTypePropertiesClass
  | DateUnionPropertiesClass
  | DefaultValuePropertiesClass
  | DirectRecursiveClass
  | ExplicitFromToRdfTypesClass
  | ExplicitRdfTypeClass
  | ExternClass
  | AbstractBaseClassForExternClass
  | ExternClassPropertyClass
  | FlattenClassUnionMember3
  | HasValuePropertiesClass
  | IdentifierOverride5Class
  | IdentifierOverride4Class
  | IdentifierOverride3Class
  | IdentifierOverride2Class
  | IdentifierOverride1Class
  | InIdentifierClass
  | InPropertiesClass
  | IndirectRecursiveClass
  | IndirectRecursiveHelperClass
  | Interface
  | InterfaceUnionMember1
  | InterfaceUnionMember2
  | InterfaceUnionMemberCommonParent
  | IriIdentifierClass
  | IriIdentifierInterface
  | JsPrimitiveUnionPropertyClass
  | LanguageInPropertiesClass
  | LazilyResolvedBlankNodeOrIriIdentifierClass
  | LazilyResolvedBlankNodeOrIriIdentifierInterface
  | LazilyResolvedClassUnionMember1
  | LazilyResolvedClassUnionMember2
  | LazilyResolvedInterfaceUnionMember1
  | LazilyResolvedInterfaceUnionMember2
  | LazilyResolvedIriIdentifierClass
  | LazilyResolvedIriIdentifierInterface
  | LazyPropertiesClass
  | PartialClass
  | LazyPropertiesInterface
  | PartialInterface
  | ListPropertiesClass
  | MutablePropertiesClass
  | NoRdfTypeClassUnionMember1
  | NoRdfTypeClassUnionMember2
  | NonClass
  | OrderedPropertiesClass
  | PartialClassUnionMember1
  | PartialClassUnionMember2
  | PartialInterfaceUnionMember1
  | PartialInterfaceUnionMember2
  | PropertyCardinalitiesClass
  | PropertyVisibilitiesClass
  | RecursiveClassUnionMember1
  | RecursiveClassUnionMember2
  | Sha256IriIdentifierClass
  | TermPropertiesClass
  | UnionDiscriminantsClass
  | UuidV4IriIdentifierClass
  | UuidV4IriIdentifierInterface
  | $DefaultPartial
  | $NamedDefaultPartial;

export namespace $Object {
  export function $equals(left: $Object, right: $Object): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      if (BlankNodeIdentifierClass.isBlankNodeIdentifierClass(left)) {
        return left.$equals(right as unknown as BlankNodeIdentifierClass);
      }
      if (BlankNodeIdentifierInterface.isBlankNodeIdentifierInterface(left)) {
        return BlankNodeIdentifierInterface.$equals(
          left,
          right as unknown as BlankNodeIdentifierInterface,
        );
      }
      if (BlankNodeOrIriIdentifierClass.isBlankNodeOrIriIdentifierClass(left)) {
        return left.$equals(right as unknown as BlankNodeOrIriIdentifierClass);
      }
      if (
        BlankNodeOrIriIdentifierInterface.isBlankNodeOrIriIdentifierInterface(
          left,
        )
      ) {
        return BlankNodeOrIriIdentifierInterface.$equals(
          left,
          right as unknown as BlankNodeOrIriIdentifierInterface,
        );
      }
      if (ClassUnionMember1.isClassUnionMember1(left)) {
        return left.$equals(right as unknown as ClassUnionMember1);
      }
      if (ClassUnionMember2.isClassUnionMember2(left)) {
        return left.$equals(right as unknown as ClassUnionMember2);
      }
      if (ConcreteChildClass.isConcreteChildClass(left)) {
        return left.$equals(right as unknown as ConcreteChildClass);
      }
      if (ConcreteParentClassStatic.isConcreteParentClass(left)) {
        return left.$equals(right as unknown as ConcreteParentClass);
      }
      if (ConcreteChildInterface.isConcreteChildInterface(left)) {
        return ConcreteChildInterface.$equals(
          left,
          right as unknown as ConcreteChildInterface,
        );
      }
      if (ConcreteParentInterfaceStatic.isConcreteParentInterface(left)) {
        return ConcreteParentInterfaceStatic.$equals(
          left,
          right as unknown as ConcreteParentInterface,
        );
      }
      if (
        BaseInterfaceWithoutPropertiesStatic.isBaseInterfaceWithoutProperties(
          left,
        )
      ) {
        return BaseInterfaceWithoutPropertiesStatic.$equals(
          left,
          right as unknown as BaseInterfaceWithoutProperties,
        );
      }
      if (
        BaseInterfaceWithPropertiesStatic.isBaseInterfaceWithProperties(left)
      ) {
        return BaseInterfaceWithPropertiesStatic.$equals(
          left,
          right as unknown as BaseInterfaceWithProperties,
        );
      }
      if (
        ConvertibleTypePropertiesClass.isConvertibleTypePropertiesClass(left)
      ) {
        return left.$equals(right as unknown as ConvertibleTypePropertiesClass);
      }
      if (DateUnionPropertiesClass.isDateUnionPropertiesClass(left)) {
        return left.$equals(right as unknown as DateUnionPropertiesClass);
      }
      if (DefaultValuePropertiesClass.isDefaultValuePropertiesClass(left)) {
        return left.$equals(right as unknown as DefaultValuePropertiesClass);
      }
      if (DirectRecursiveClass.isDirectRecursiveClass(left)) {
        return left.$equals(right as unknown as DirectRecursiveClass);
      }
      if (ExplicitFromToRdfTypesClass.isExplicitFromToRdfTypesClass(left)) {
        return left.$equals(right as unknown as ExplicitFromToRdfTypesClass);
      }
      if (ExplicitRdfTypeClass.isExplicitRdfTypeClass(left)) {
        return left.$equals(right as unknown as ExplicitRdfTypeClass);
      }
      if (ExternClass.isExternClass(left)) {
        return left.$equals(right as unknown as ExternClass);
      }
      if (ExternClassPropertyClass.isExternClassPropertyClass(left)) {
        return left.$equals(right as unknown as ExternClassPropertyClass);
      }
      if (FlattenClassUnionMember3.isFlattenClassUnionMember3(left)) {
        return left.$equals(right as unknown as FlattenClassUnionMember3);
      }
      if (HasValuePropertiesClass.isHasValuePropertiesClass(left)) {
        return left.$equals(right as unknown as HasValuePropertiesClass);
      }
      if (IdentifierOverride5Class.isIdentifierOverride5Class(left)) {
        return left.$equals(right as unknown as IdentifierOverride5Class);
      }
      if (IdentifierOverride4ClassStatic.isIdentifierOverride4Class(left)) {
        return left.$equals(right as unknown as IdentifierOverride4Class);
      }
      if (IdentifierOverride3ClassStatic.isIdentifierOverride3Class(left)) {
        return left.$equals(right as unknown as IdentifierOverride3Class);
      }
      if (InIdentifierClass.isInIdentifierClass(left)) {
        return left.$equals(right as unknown as InIdentifierClass);
      }
      if (InPropertiesClass.isInPropertiesClass(left)) {
        return left.$equals(right as unknown as InPropertiesClass);
      }
      if (IndirectRecursiveClass.isIndirectRecursiveClass(left)) {
        return left.$equals(right as unknown as IndirectRecursiveClass);
      }
      if (IndirectRecursiveHelperClass.isIndirectRecursiveHelperClass(left)) {
        return left.$equals(right as unknown as IndirectRecursiveHelperClass);
      }
      if (Interface.isInterface(left)) {
        return Interface.$equals(left, right as unknown as Interface);
      }
      if (InterfaceUnionMember1.isInterfaceUnionMember1(left)) {
        return InterfaceUnionMember1.$equals(
          left,
          right as unknown as InterfaceUnionMember1,
        );
      }
      if (InterfaceUnionMember2.isInterfaceUnionMember2(left)) {
        return InterfaceUnionMember2.$equals(
          left,
          right as unknown as InterfaceUnionMember2,
        );
      }
      if (IriIdentifierClass.isIriIdentifierClass(left)) {
        return left.$equals(right as unknown as IriIdentifierClass);
      }
      if (IriIdentifierInterface.isIriIdentifierInterface(left)) {
        return IriIdentifierInterface.$equals(
          left,
          right as unknown as IriIdentifierInterface,
        );
      }
      if (JsPrimitiveUnionPropertyClass.isJsPrimitiveUnionPropertyClass(left)) {
        return left.$equals(right as unknown as JsPrimitiveUnionPropertyClass);
      }
      if (LanguageInPropertiesClass.isLanguageInPropertiesClass(left)) {
        return left.$equals(right as unknown as LanguageInPropertiesClass);
      }
      if (
        LazilyResolvedBlankNodeOrIriIdentifierClass.isLazilyResolvedBlankNodeOrIriIdentifierClass(
          left,
        )
      ) {
        return left.$equals(
          right as unknown as LazilyResolvedBlankNodeOrIriIdentifierClass,
        );
      }
      if (
        LazilyResolvedBlankNodeOrIriIdentifierInterface.isLazilyResolvedBlankNodeOrIriIdentifierInterface(
          left,
        )
      ) {
        return LazilyResolvedBlankNodeOrIriIdentifierInterface.$equals(
          left,
          right as unknown as LazilyResolvedBlankNodeOrIriIdentifierInterface,
        );
      }
      if (
        LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(left)
      ) {
        return left.$equals(
          right as unknown as LazilyResolvedClassUnionMember1,
        );
      }
      if (
        LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(left)
      ) {
        return left.$equals(
          right as unknown as LazilyResolvedClassUnionMember2,
        );
      }
      if (
        LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
          left,
        )
      ) {
        return LazilyResolvedInterfaceUnionMember1.$equals(
          left,
          right as unknown as LazilyResolvedInterfaceUnionMember1,
        );
      }
      if (
        LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
          left,
        )
      ) {
        return LazilyResolvedInterfaceUnionMember2.$equals(
          left,
          right as unknown as LazilyResolvedInterfaceUnionMember2,
        );
      }
      if (
        LazilyResolvedIriIdentifierClass.isLazilyResolvedIriIdentifierClass(
          left,
        )
      ) {
        return left.$equals(
          right as unknown as LazilyResolvedIriIdentifierClass,
        );
      }
      if (
        LazilyResolvedIriIdentifierInterface.isLazilyResolvedIriIdentifierInterface(
          left,
        )
      ) {
        return LazilyResolvedIriIdentifierInterface.$equals(
          left,
          right as unknown as LazilyResolvedIriIdentifierInterface,
        );
      }
      if (LazyPropertiesClass.isLazyPropertiesClass(left)) {
        return left.$equals(right as unknown as LazyPropertiesClass);
      }
      if (PartialClass.isPartialClass(left)) {
        return left.$equals(right as unknown as PartialClass);
      }
      if (LazyPropertiesInterface.isLazyPropertiesInterface(left)) {
        return LazyPropertiesInterface.$equals(
          left,
          right as unknown as LazyPropertiesInterface,
        );
      }
      if (PartialInterface.isPartialInterface(left)) {
        return PartialInterface.$equals(
          left,
          right as unknown as PartialInterface,
        );
      }
      if (ListPropertiesClass.isListPropertiesClass(left)) {
        return left.$equals(right as unknown as ListPropertiesClass);
      }
      if (MutablePropertiesClass.isMutablePropertiesClass(left)) {
        return left.$equals(right as unknown as MutablePropertiesClass);
      }
      if (NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(left)) {
        return left.$equals(right as unknown as NoRdfTypeClassUnionMember1);
      }
      if (NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(left)) {
        return left.$equals(right as unknown as NoRdfTypeClassUnionMember2);
      }
      if (NonClass.isNonClass(left)) {
        return left.$equals(right as unknown as NonClass);
      }
      if (OrderedPropertiesClass.isOrderedPropertiesClass(left)) {
        return left.$equals(right as unknown as OrderedPropertiesClass);
      }
      if (PartialClassUnionMember1.isPartialClassUnionMember1(left)) {
        return left.$equals(right as unknown as PartialClassUnionMember1);
      }
      if (PartialClassUnionMember2.isPartialClassUnionMember2(left)) {
        return left.$equals(right as unknown as PartialClassUnionMember2);
      }
      if (PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(left)) {
        return PartialInterfaceUnionMember1.$equals(
          left,
          right as unknown as PartialInterfaceUnionMember1,
        );
      }
      if (PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(left)) {
        return PartialInterfaceUnionMember2.$equals(
          left,
          right as unknown as PartialInterfaceUnionMember2,
        );
      }
      if (PropertyCardinalitiesClass.isPropertyCardinalitiesClass(left)) {
        return left.$equals(right as unknown as PropertyCardinalitiesClass);
      }
      if (PropertyVisibilitiesClass.isPropertyVisibilitiesClass(left)) {
        return left.$equals(right as unknown as PropertyVisibilitiesClass);
      }
      if (RecursiveClassUnionMember1.isRecursiveClassUnionMember1(left)) {
        return left.$equals(right as unknown as RecursiveClassUnionMember1);
      }
      if (RecursiveClassUnionMember2.isRecursiveClassUnionMember2(left)) {
        return left.$equals(right as unknown as RecursiveClassUnionMember2);
      }
      if (Sha256IriIdentifierClass.isSha256IriIdentifierClass(left)) {
        return left.$equals(right as unknown as Sha256IriIdentifierClass);
      }
      if (TermPropertiesClass.isTermPropertiesClass(left)) {
        return left.$equals(right as unknown as TermPropertiesClass);
      }
      if (UnionDiscriminantsClass.isUnionDiscriminantsClass(left)) {
        return left.$equals(right as unknown as UnionDiscriminantsClass);
      }
      if (UuidV4IriIdentifierClass.isUuidV4IriIdentifierClass(left)) {
        return left.$equals(right as unknown as UuidV4IriIdentifierClass);
      }
      if (UuidV4IriIdentifierInterface.isUuidV4IriIdentifierInterface(left)) {
        return UuidV4IriIdentifierInterface.$equals(
          left,
          right as unknown as UuidV4IriIdentifierInterface,
        );
      }
      if ($DefaultPartial.is$DefaultPartial(left)) {
        return left.$equals(right as unknown as $DefaultPartial);
      }
      if ($NamedDefaultPartial.is$NamedDefaultPartial(left)) {
        return left.$equals(right as unknown as $NamedDefaultPartial);
      }
      return $EqualsResult.Equal;
    });
  }

  export function $filter(filter: $Object.$Filter, value: $Object): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      BlankNodeIdentifierClass.isBlankNodeIdentifierClass(value) &&
      filter.on?.BlankNodeIdentifierClass &&
      !BlankNodeIdentifierClass.$filter(
        filter.on.BlankNodeIdentifierClass,
        value as BlankNodeIdentifierClass,
      )
    ) {
      return false;
    }

    if (
      BlankNodeIdentifierInterface.isBlankNodeIdentifierInterface(value) &&
      filter.on?.BlankNodeIdentifierInterface &&
      !BlankNodeIdentifierInterface.$filter(
        filter.on.BlankNodeIdentifierInterface,
        value as BlankNodeIdentifierInterface,
      )
    ) {
      return false;
    }

    if (
      BlankNodeOrIriIdentifierClass.isBlankNodeOrIriIdentifierClass(value) &&
      filter.on?.BlankNodeOrIriIdentifierClass &&
      !BlankNodeOrIriIdentifierClass.$filter(
        filter.on.BlankNodeOrIriIdentifierClass,
        value as BlankNodeOrIriIdentifierClass,
      )
    ) {
      return false;
    }

    if (
      BlankNodeOrIriIdentifierInterface.isBlankNodeOrIriIdentifierInterface(
        value,
      ) &&
      filter.on?.BlankNodeOrIriIdentifierInterface &&
      !BlankNodeOrIriIdentifierInterface.$filter(
        filter.on.BlankNodeOrIriIdentifierInterface,
        value as BlankNodeOrIriIdentifierInterface,
      )
    ) {
      return false;
    }

    if (
      ClassUnionMember1.isClassUnionMember1(value) &&
      filter.on?.ClassUnionMember1 &&
      !ClassUnionMember1.$filter(
        filter.on.ClassUnionMember1,
        value as ClassUnionMember1,
      )
    ) {
      return false;
    }

    if (
      ClassUnionMember2.isClassUnionMember2(value) &&
      filter.on?.ClassUnionMember2 &&
      !ClassUnionMember2.$filter(
        filter.on.ClassUnionMember2,
        value as ClassUnionMember2,
      )
    ) {
      return false;
    }

    if (
      ClassUnionMemberCommonParentStatic.isClassUnionMemberCommonParent(
        value,
      ) &&
      filter.on?.ClassUnionMemberCommonParent &&
      !ClassUnionMemberCommonParentStatic.$filter(
        filter.on.ClassUnionMemberCommonParent,
        value as ClassUnionMemberCommonParent,
      )
    ) {
      return false;
    }

    if (
      ConcreteChildClass.isConcreteChildClass(value) &&
      filter.on?.ConcreteChildClass &&
      !ConcreteChildClass.$filter(
        filter.on.ConcreteChildClass,
        value as ConcreteChildClass,
      )
    ) {
      return false;
    }

    if (
      ConcreteParentClassStatic.isConcreteParentClass(value) &&
      filter.on?.ConcreteParentClass &&
      !ConcreteParentClassStatic.$filter(
        filter.on.ConcreteParentClass,
        value as ConcreteParentClass,
      )
    ) {
      return false;
    }

    if (
      AbstractBaseClassWithoutPropertiesStatic.isAbstractBaseClassWithoutProperties(
        value,
      ) &&
      filter.on?.AbstractBaseClassWithoutProperties &&
      !AbstractBaseClassWithoutPropertiesStatic.$filter(
        filter.on.AbstractBaseClassWithoutProperties,
        value as AbstractBaseClassWithoutProperties,
      )
    ) {
      return false;
    }

    if (
      AbstractBaseClassWithPropertiesStatic.isAbstractBaseClassWithProperties(
        value,
      ) &&
      filter.on?.AbstractBaseClassWithProperties &&
      !AbstractBaseClassWithPropertiesStatic.$filter(
        filter.on.AbstractBaseClassWithProperties,
        value as AbstractBaseClassWithProperties,
      )
    ) {
      return false;
    }

    if (
      ConcreteChildInterface.isConcreteChildInterface(value) &&
      filter.on?.ConcreteChildInterface &&
      !ConcreteChildInterface.$filter(
        filter.on.ConcreteChildInterface,
        value as ConcreteChildInterface,
      )
    ) {
      return false;
    }

    if (
      ConcreteParentInterfaceStatic.isConcreteParentInterface(value) &&
      filter.on?.ConcreteParentInterface &&
      !ConcreteParentInterfaceStatic.$filter(
        filter.on.ConcreteParentInterface,
        value as ConcreteParentInterface,
      )
    ) {
      return false;
    }

    if (
      BaseInterfaceWithoutPropertiesStatic.isBaseInterfaceWithoutProperties(
        value,
      ) &&
      filter.on?.BaseInterfaceWithoutProperties &&
      !BaseInterfaceWithoutPropertiesStatic.$filter(
        filter.on.BaseInterfaceWithoutProperties,
        value as BaseInterfaceWithoutProperties,
      )
    ) {
      return false;
    }

    if (
      BaseInterfaceWithPropertiesStatic.isBaseInterfaceWithProperties(value) &&
      filter.on?.BaseInterfaceWithProperties &&
      !BaseInterfaceWithPropertiesStatic.$filter(
        filter.on.BaseInterfaceWithProperties,
        value as BaseInterfaceWithProperties,
      )
    ) {
      return false;
    }

    if (
      ConvertibleTypePropertiesClass.isConvertibleTypePropertiesClass(value) &&
      filter.on?.ConvertibleTypePropertiesClass &&
      !ConvertibleTypePropertiesClass.$filter(
        filter.on.ConvertibleTypePropertiesClass,
        value as ConvertibleTypePropertiesClass,
      )
    ) {
      return false;
    }

    if (
      DateUnionPropertiesClass.isDateUnionPropertiesClass(value) &&
      filter.on?.DateUnionPropertiesClass &&
      !DateUnionPropertiesClass.$filter(
        filter.on.DateUnionPropertiesClass,
        value as DateUnionPropertiesClass,
      )
    ) {
      return false;
    }

    if (
      DefaultValuePropertiesClass.isDefaultValuePropertiesClass(value) &&
      filter.on?.DefaultValuePropertiesClass &&
      !DefaultValuePropertiesClass.$filter(
        filter.on.DefaultValuePropertiesClass,
        value as DefaultValuePropertiesClass,
      )
    ) {
      return false;
    }

    if (
      DirectRecursiveClass.isDirectRecursiveClass(value) &&
      filter.on?.DirectRecursiveClass &&
      !DirectRecursiveClass.$filter(
        filter.on.DirectRecursiveClass,
        value as DirectRecursiveClass,
      )
    ) {
      return false;
    }

    if (
      ExplicitFromToRdfTypesClass.isExplicitFromToRdfTypesClass(value) &&
      filter.on?.ExplicitFromToRdfTypesClass &&
      !ExplicitFromToRdfTypesClass.$filter(
        filter.on.ExplicitFromToRdfTypesClass,
        value as ExplicitFromToRdfTypesClass,
      )
    ) {
      return false;
    }

    if (
      ExplicitRdfTypeClass.isExplicitRdfTypeClass(value) &&
      filter.on?.ExplicitRdfTypeClass &&
      !ExplicitRdfTypeClass.$filter(
        filter.on.ExplicitRdfTypeClass,
        value as ExplicitRdfTypeClass,
      )
    ) {
      return false;
    }

    if (
      ExternClass.isExternClass(value) &&
      filter.on?.ExternClass &&
      !ExternClass.$filter(filter.on.ExternClass, value as ExternClass)
    ) {
      return false;
    }

    if (
      AbstractBaseClassForExternClassStatic.isAbstractBaseClassForExternClass(
        value,
      ) &&
      filter.on?.AbstractBaseClassForExternClass &&
      !AbstractBaseClassForExternClassStatic.$filter(
        filter.on.AbstractBaseClassForExternClass,
        value as AbstractBaseClassForExternClass,
      )
    ) {
      return false;
    }

    if (
      ExternClassPropertyClass.isExternClassPropertyClass(value) &&
      filter.on?.ExternClassPropertyClass &&
      !ExternClassPropertyClass.$filter(
        filter.on.ExternClassPropertyClass,
        value as ExternClassPropertyClass,
      )
    ) {
      return false;
    }

    if (
      FlattenClassUnionMember3.isFlattenClassUnionMember3(value) &&
      filter.on?.FlattenClassUnionMember3 &&
      !FlattenClassUnionMember3.$filter(
        filter.on.FlattenClassUnionMember3,
        value as FlattenClassUnionMember3,
      )
    ) {
      return false;
    }

    if (
      HasValuePropertiesClass.isHasValuePropertiesClass(value) &&
      filter.on?.HasValuePropertiesClass &&
      !HasValuePropertiesClass.$filter(
        filter.on.HasValuePropertiesClass,
        value as HasValuePropertiesClass,
      )
    ) {
      return false;
    }

    if (
      IdentifierOverride5Class.isIdentifierOverride5Class(value) &&
      filter.on?.IdentifierOverride5Class &&
      !IdentifierOverride5Class.$filter(
        filter.on.IdentifierOverride5Class,
        value as IdentifierOverride5Class,
      )
    ) {
      return false;
    }

    if (
      IdentifierOverride4ClassStatic.isIdentifierOverride4Class(value) &&
      filter.on?.IdentifierOverride4Class &&
      !IdentifierOverride4ClassStatic.$filter(
        filter.on.IdentifierOverride4Class,
        value as IdentifierOverride4Class,
      )
    ) {
      return false;
    }

    if (
      IdentifierOverride3ClassStatic.isIdentifierOverride3Class(value) &&
      filter.on?.IdentifierOverride3Class &&
      !IdentifierOverride3ClassStatic.$filter(
        filter.on.IdentifierOverride3Class,
        value as IdentifierOverride3Class,
      )
    ) {
      return false;
    }

    if (
      IdentifierOverride2ClassStatic.isIdentifierOverride2Class(value) &&
      filter.on?.IdentifierOverride2Class &&
      !IdentifierOverride2ClassStatic.$filter(
        filter.on.IdentifierOverride2Class,
        value as IdentifierOverride2Class,
      )
    ) {
      return false;
    }

    if (
      IdentifierOverride1ClassStatic.isIdentifierOverride1Class(value) &&
      filter.on?.IdentifierOverride1Class &&
      !IdentifierOverride1ClassStatic.$filter(
        filter.on.IdentifierOverride1Class,
        value as IdentifierOverride1Class,
      )
    ) {
      return false;
    }

    if (
      InIdentifierClass.isInIdentifierClass(value) &&
      filter.on?.InIdentifierClass &&
      !InIdentifierClass.$filter(
        filter.on.InIdentifierClass,
        value as InIdentifierClass,
      )
    ) {
      return false;
    }

    if (
      InPropertiesClass.isInPropertiesClass(value) &&
      filter.on?.InPropertiesClass &&
      !InPropertiesClass.$filter(
        filter.on.InPropertiesClass,
        value as InPropertiesClass,
      )
    ) {
      return false;
    }

    if (
      IndirectRecursiveClass.isIndirectRecursiveClass(value) &&
      filter.on?.IndirectRecursiveClass &&
      !IndirectRecursiveClass.$filter(
        filter.on.IndirectRecursiveClass,
        value as IndirectRecursiveClass,
      )
    ) {
      return false;
    }

    if (
      IndirectRecursiveHelperClass.isIndirectRecursiveHelperClass(value) &&
      filter.on?.IndirectRecursiveHelperClass &&
      !IndirectRecursiveHelperClass.$filter(
        filter.on.IndirectRecursiveHelperClass,
        value as IndirectRecursiveHelperClass,
      )
    ) {
      return false;
    }

    if (
      Interface.isInterface(value) &&
      filter.on?.Interface &&
      !Interface.$filter(filter.on.Interface, value as Interface)
    ) {
      return false;
    }

    if (
      InterfaceUnionMember1.isInterfaceUnionMember1(value) &&
      filter.on?.InterfaceUnionMember1 &&
      !InterfaceUnionMember1.$filter(
        filter.on.InterfaceUnionMember1,
        value as InterfaceUnionMember1,
      )
    ) {
      return false;
    }

    if (
      InterfaceUnionMember2.isInterfaceUnionMember2(value) &&
      filter.on?.InterfaceUnionMember2 &&
      !InterfaceUnionMember2.$filter(
        filter.on.InterfaceUnionMember2,
        value as InterfaceUnionMember2,
      )
    ) {
      return false;
    }

    if (
      InterfaceUnionMemberCommonParentStatic.isInterfaceUnionMemberCommonParent(
        value,
      ) &&
      filter.on?.InterfaceUnionMemberCommonParent &&
      !InterfaceUnionMemberCommonParentStatic.$filter(
        filter.on.InterfaceUnionMemberCommonParent,
        value as InterfaceUnionMemberCommonParent,
      )
    ) {
      return false;
    }

    if (
      IriIdentifierClass.isIriIdentifierClass(value) &&
      filter.on?.IriIdentifierClass &&
      !IriIdentifierClass.$filter(
        filter.on.IriIdentifierClass,
        value as IriIdentifierClass,
      )
    ) {
      return false;
    }

    if (
      IriIdentifierInterface.isIriIdentifierInterface(value) &&
      filter.on?.IriIdentifierInterface &&
      !IriIdentifierInterface.$filter(
        filter.on.IriIdentifierInterface,
        value as IriIdentifierInterface,
      )
    ) {
      return false;
    }

    if (
      JsPrimitiveUnionPropertyClass.isJsPrimitiveUnionPropertyClass(value) &&
      filter.on?.JsPrimitiveUnionPropertyClass &&
      !JsPrimitiveUnionPropertyClass.$filter(
        filter.on.JsPrimitiveUnionPropertyClass,
        value as JsPrimitiveUnionPropertyClass,
      )
    ) {
      return false;
    }

    if (
      LanguageInPropertiesClass.isLanguageInPropertiesClass(value) &&
      filter.on?.LanguageInPropertiesClass &&
      !LanguageInPropertiesClass.$filter(
        filter.on.LanguageInPropertiesClass,
        value as LanguageInPropertiesClass,
      )
    ) {
      return false;
    }

    if (
      LazilyResolvedBlankNodeOrIriIdentifierClass.isLazilyResolvedBlankNodeOrIriIdentifierClass(
        value,
      ) &&
      filter.on?.LazilyResolvedBlankNodeOrIriIdentifierClass &&
      !LazilyResolvedBlankNodeOrIriIdentifierClass.$filter(
        filter.on.LazilyResolvedBlankNodeOrIriIdentifierClass,
        value as LazilyResolvedBlankNodeOrIriIdentifierClass,
      )
    ) {
      return false;
    }

    if (
      LazilyResolvedBlankNodeOrIriIdentifierInterface.isLazilyResolvedBlankNodeOrIriIdentifierInterface(
        value,
      ) &&
      filter.on?.LazilyResolvedBlankNodeOrIriIdentifierInterface &&
      !LazilyResolvedBlankNodeOrIriIdentifierInterface.$filter(
        filter.on.LazilyResolvedBlankNodeOrIriIdentifierInterface,
        value as LazilyResolvedBlankNodeOrIriIdentifierInterface,
      )
    ) {
      return false;
    }

    if (
      LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(
        value,
      ) &&
      filter.on?.LazilyResolvedClassUnionMember1 &&
      !LazilyResolvedClassUnionMember1.$filter(
        filter.on.LazilyResolvedClassUnionMember1,
        value as LazilyResolvedClassUnionMember1,
      )
    ) {
      return false;
    }

    if (
      LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(
        value,
      ) &&
      filter.on?.LazilyResolvedClassUnionMember2 &&
      !LazilyResolvedClassUnionMember2.$filter(
        filter.on.LazilyResolvedClassUnionMember2,
        value as LazilyResolvedClassUnionMember2,
      )
    ) {
      return false;
    }

    if (
      LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
        value,
      ) &&
      filter.on?.LazilyResolvedInterfaceUnionMember1 &&
      !LazilyResolvedInterfaceUnionMember1.$filter(
        filter.on.LazilyResolvedInterfaceUnionMember1,
        value as LazilyResolvedInterfaceUnionMember1,
      )
    ) {
      return false;
    }

    if (
      LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
        value,
      ) &&
      filter.on?.LazilyResolvedInterfaceUnionMember2 &&
      !LazilyResolvedInterfaceUnionMember2.$filter(
        filter.on.LazilyResolvedInterfaceUnionMember2,
        value as LazilyResolvedInterfaceUnionMember2,
      )
    ) {
      return false;
    }

    if (
      LazilyResolvedIriIdentifierClass.isLazilyResolvedIriIdentifierClass(
        value,
      ) &&
      filter.on?.LazilyResolvedIriIdentifierClass &&
      !LazilyResolvedIriIdentifierClass.$filter(
        filter.on.LazilyResolvedIriIdentifierClass,
        value as LazilyResolvedIriIdentifierClass,
      )
    ) {
      return false;
    }

    if (
      LazilyResolvedIriIdentifierInterface.isLazilyResolvedIriIdentifierInterface(
        value,
      ) &&
      filter.on?.LazilyResolvedIriIdentifierInterface &&
      !LazilyResolvedIriIdentifierInterface.$filter(
        filter.on.LazilyResolvedIriIdentifierInterface,
        value as LazilyResolvedIriIdentifierInterface,
      )
    ) {
      return false;
    }

    if (
      LazyPropertiesClass.isLazyPropertiesClass(value) &&
      filter.on?.LazyPropertiesClass &&
      !LazyPropertiesClass.$filter(
        filter.on.LazyPropertiesClass,
        value as LazyPropertiesClass,
      )
    ) {
      return false;
    }

    if (
      PartialClass.isPartialClass(value) &&
      filter.on?.PartialClass &&
      !PartialClass.$filter(filter.on.PartialClass, value as PartialClass)
    ) {
      return false;
    }

    if (
      LazyPropertiesInterface.isLazyPropertiesInterface(value) &&
      filter.on?.LazyPropertiesInterface &&
      !LazyPropertiesInterface.$filter(
        filter.on.LazyPropertiesInterface,
        value as LazyPropertiesInterface,
      )
    ) {
      return false;
    }

    if (
      PartialInterface.isPartialInterface(value) &&
      filter.on?.PartialInterface &&
      !PartialInterface.$filter(
        filter.on.PartialInterface,
        value as PartialInterface,
      )
    ) {
      return false;
    }

    if (
      ListPropertiesClass.isListPropertiesClass(value) &&
      filter.on?.ListPropertiesClass &&
      !ListPropertiesClass.$filter(
        filter.on.ListPropertiesClass,
        value as ListPropertiesClass,
      )
    ) {
      return false;
    }

    if (
      MutablePropertiesClass.isMutablePropertiesClass(value) &&
      filter.on?.MutablePropertiesClass &&
      !MutablePropertiesClass.$filter(
        filter.on.MutablePropertiesClass,
        value as MutablePropertiesClass,
      )
    ) {
      return false;
    }

    if (
      NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(value) &&
      filter.on?.NoRdfTypeClassUnionMember1 &&
      !NoRdfTypeClassUnionMember1.$filter(
        filter.on.NoRdfTypeClassUnionMember1,
        value as NoRdfTypeClassUnionMember1,
      )
    ) {
      return false;
    }

    if (
      NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(value) &&
      filter.on?.NoRdfTypeClassUnionMember2 &&
      !NoRdfTypeClassUnionMember2.$filter(
        filter.on.NoRdfTypeClassUnionMember2,
        value as NoRdfTypeClassUnionMember2,
      )
    ) {
      return false;
    }

    if (
      NonClass.isNonClass(value) &&
      filter.on?.NonClass &&
      !NonClass.$filter(filter.on.NonClass, value as NonClass)
    ) {
      return false;
    }

    if (
      OrderedPropertiesClass.isOrderedPropertiesClass(value) &&
      filter.on?.OrderedPropertiesClass &&
      !OrderedPropertiesClass.$filter(
        filter.on.OrderedPropertiesClass,
        value as OrderedPropertiesClass,
      )
    ) {
      return false;
    }

    if (
      PartialClassUnionMember1.isPartialClassUnionMember1(value) &&
      filter.on?.PartialClassUnionMember1 &&
      !PartialClassUnionMember1.$filter(
        filter.on.PartialClassUnionMember1,
        value as PartialClassUnionMember1,
      )
    ) {
      return false;
    }

    if (
      PartialClassUnionMember2.isPartialClassUnionMember2(value) &&
      filter.on?.PartialClassUnionMember2 &&
      !PartialClassUnionMember2.$filter(
        filter.on.PartialClassUnionMember2,
        value as PartialClassUnionMember2,
      )
    ) {
      return false;
    }

    if (
      PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(value) &&
      filter.on?.PartialInterfaceUnionMember1 &&
      !PartialInterfaceUnionMember1.$filter(
        filter.on.PartialInterfaceUnionMember1,
        value as PartialInterfaceUnionMember1,
      )
    ) {
      return false;
    }

    if (
      PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(value) &&
      filter.on?.PartialInterfaceUnionMember2 &&
      !PartialInterfaceUnionMember2.$filter(
        filter.on.PartialInterfaceUnionMember2,
        value as PartialInterfaceUnionMember2,
      )
    ) {
      return false;
    }

    if (
      PropertyCardinalitiesClass.isPropertyCardinalitiesClass(value) &&
      filter.on?.PropertyCardinalitiesClass &&
      !PropertyCardinalitiesClass.$filter(
        filter.on.PropertyCardinalitiesClass,
        value as PropertyCardinalitiesClass,
      )
    ) {
      return false;
    }

    if (
      PropertyVisibilitiesClass.isPropertyVisibilitiesClass(value) &&
      filter.on?.PropertyVisibilitiesClass &&
      !PropertyVisibilitiesClass.$filter(
        filter.on.PropertyVisibilitiesClass,
        value as PropertyVisibilitiesClass,
      )
    ) {
      return false;
    }

    if (
      RecursiveClassUnionMember1.isRecursiveClassUnionMember1(value) &&
      filter.on?.RecursiveClassUnionMember1 &&
      !RecursiveClassUnionMember1.$filter(
        filter.on.RecursiveClassUnionMember1,
        value as RecursiveClassUnionMember1,
      )
    ) {
      return false;
    }

    if (
      RecursiveClassUnionMember2.isRecursiveClassUnionMember2(value) &&
      filter.on?.RecursiveClassUnionMember2 &&
      !RecursiveClassUnionMember2.$filter(
        filter.on.RecursiveClassUnionMember2,
        value as RecursiveClassUnionMember2,
      )
    ) {
      return false;
    }

    if (
      Sha256IriIdentifierClass.isSha256IriIdentifierClass(value) &&
      filter.on?.Sha256IriIdentifierClass &&
      !Sha256IriIdentifierClass.$filter(
        filter.on.Sha256IriIdentifierClass,
        value as Sha256IriIdentifierClass,
      )
    ) {
      return false;
    }

    if (
      TermPropertiesClass.isTermPropertiesClass(value) &&
      filter.on?.TermPropertiesClass &&
      !TermPropertiesClass.$filter(
        filter.on.TermPropertiesClass,
        value as TermPropertiesClass,
      )
    ) {
      return false;
    }

    if (
      UnionDiscriminantsClass.isUnionDiscriminantsClass(value) &&
      filter.on?.UnionDiscriminantsClass &&
      !UnionDiscriminantsClass.$filter(
        filter.on.UnionDiscriminantsClass,
        value as UnionDiscriminantsClass,
      )
    ) {
      return false;
    }

    if (
      UuidV4IriIdentifierClass.isUuidV4IriIdentifierClass(value) &&
      filter.on?.UuidV4IriIdentifierClass &&
      !UuidV4IriIdentifierClass.$filter(
        filter.on.UuidV4IriIdentifierClass,
        value as UuidV4IriIdentifierClass,
      )
    ) {
      return false;
    }

    if (
      UuidV4IriIdentifierInterface.isUuidV4IriIdentifierInterface(value) &&
      filter.on?.UuidV4IriIdentifierInterface &&
      !UuidV4IriIdentifierInterface.$filter(
        filter.on.UuidV4IriIdentifierInterface,
        value as UuidV4IriIdentifierInterface,
      )
    ) {
      return false;
    }

    if (
      $DefaultPartial.is$DefaultPartial(value) &&
      filter.on?.$DefaultPartial &&
      !$DefaultPartial.$filter(
        filter.on.$DefaultPartial,
        value as $DefaultPartial,
      )
    ) {
      return false;
    }

    if (
      $NamedDefaultPartial.is$NamedDefaultPartial(value) &&
      filter.on?.$NamedDefaultPartial &&
      !$NamedDefaultPartial.$filter(
        filter.on.$NamedDefaultPartial,
        value as $NamedDefaultPartial,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly on?: {
      readonly BlankNodeIdentifierClass?: Omit<
        BlankNodeIdentifierClass.$Filter,
        "$identifier"
      >;
      readonly BlankNodeIdentifierInterface?: Omit<
        BlankNodeIdentifierInterface.$Filter,
        "$identifier"
      >;
      readonly BlankNodeOrIriIdentifierClass?: Omit<
        BlankNodeOrIriIdentifierClass.$Filter,
        "$identifier"
      >;
      readonly BlankNodeOrIriIdentifierInterface?: Omit<
        BlankNodeOrIriIdentifierInterface.$Filter,
        "$identifier"
      >;
      readonly ClassUnionMember1?: Omit<
        ClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly ClassUnionMember2?: Omit<
        ClassUnionMember2.$Filter,
        "$identifier"
      >;
      readonly ClassUnionMemberCommonParent?: Omit<
        ClassUnionMemberCommonParentStatic.$Filter,
        "$identifier"
      >;
      readonly ConcreteChildClass?: Omit<
        ConcreteChildClass.$Filter,
        "$identifier"
      >;
      readonly ConcreteParentClass?: Omit<
        ConcreteParentClassStatic.$Filter,
        "$identifier"
      >;
      readonly AbstractBaseClassWithoutProperties?: Omit<
        AbstractBaseClassWithoutPropertiesStatic.$Filter,
        "$identifier"
      >;
      readonly AbstractBaseClassWithProperties?: Omit<
        AbstractBaseClassWithPropertiesStatic.$Filter,
        "$identifier"
      >;
      readonly ConcreteChildInterface?: Omit<
        ConcreteChildInterface.$Filter,
        "$identifier"
      >;
      readonly ConcreteParentInterface?: Omit<
        ConcreteParentInterfaceStatic.$Filter,
        "$identifier"
      >;
      readonly BaseInterfaceWithoutProperties?: Omit<
        BaseInterfaceWithoutPropertiesStatic.$Filter,
        "$identifier"
      >;
      readonly BaseInterfaceWithProperties?: Omit<
        BaseInterfaceWithPropertiesStatic.$Filter,
        "$identifier"
      >;
      readonly ConvertibleTypePropertiesClass?: Omit<
        ConvertibleTypePropertiesClass.$Filter,
        "$identifier"
      >;
      readonly DateUnionPropertiesClass?: Omit<
        DateUnionPropertiesClass.$Filter,
        "$identifier"
      >;
      readonly DefaultValuePropertiesClass?: Omit<
        DefaultValuePropertiesClass.$Filter,
        "$identifier"
      >;
      readonly DirectRecursiveClass?: Omit<
        DirectRecursiveClass.$Filter,
        "$identifier"
      >;
      readonly ExplicitFromToRdfTypesClass?: Omit<
        ExplicitFromToRdfTypesClass.$Filter,
        "$identifier"
      >;
      readonly ExplicitRdfTypeClass?: Omit<
        ExplicitRdfTypeClass.$Filter,
        "$identifier"
      >;
      readonly ExternClass?: Omit<ExternClass.$Filter, "$identifier">;
      readonly AbstractBaseClassForExternClass?: Omit<
        AbstractBaseClassForExternClassStatic.$Filter,
        "$identifier"
      >;
      readonly ExternClassPropertyClass?: Omit<
        ExternClassPropertyClass.$Filter,
        "$identifier"
      >;
      readonly FlattenClassUnionMember3?: Omit<
        FlattenClassUnionMember3.$Filter,
        "$identifier"
      >;
      readonly HasValuePropertiesClass?: Omit<
        HasValuePropertiesClass.$Filter,
        "$identifier"
      >;
      readonly IdentifierOverride5Class?: Omit<
        IdentifierOverride5Class.$Filter,
        "$identifier"
      >;
      readonly IdentifierOverride4Class?: Omit<
        IdentifierOverride4ClassStatic.$Filter,
        "$identifier"
      >;
      readonly IdentifierOverride3Class?: Omit<
        IdentifierOverride3ClassStatic.$Filter,
        "$identifier"
      >;
      readonly IdentifierOverride2Class?: Omit<
        IdentifierOverride2ClassStatic.$Filter,
        "$identifier"
      >;
      readonly IdentifierOverride1Class?: Omit<
        IdentifierOverride1ClassStatic.$Filter,
        "$identifier"
      >;
      readonly InIdentifierClass?: Omit<
        InIdentifierClass.$Filter,
        "$identifier"
      >;
      readonly InPropertiesClass?: Omit<
        InPropertiesClass.$Filter,
        "$identifier"
      >;
      readonly IndirectRecursiveClass?: Omit<
        IndirectRecursiveClass.$Filter,
        "$identifier"
      >;
      readonly IndirectRecursiveHelperClass?: Omit<
        IndirectRecursiveHelperClass.$Filter,
        "$identifier"
      >;
      readonly Interface?: Omit<Interface.$Filter, "$identifier">;
      readonly InterfaceUnionMember1?: Omit<
        InterfaceUnionMember1.$Filter,
        "$identifier"
      >;
      readonly InterfaceUnionMember2?: Omit<
        InterfaceUnionMember2.$Filter,
        "$identifier"
      >;
      readonly InterfaceUnionMemberCommonParent?: Omit<
        InterfaceUnionMemberCommonParentStatic.$Filter,
        "$identifier"
      >;
      readonly IriIdentifierClass?: Omit<
        IriIdentifierClass.$Filter,
        "$identifier"
      >;
      readonly IriIdentifierInterface?: Omit<
        IriIdentifierInterface.$Filter,
        "$identifier"
      >;
      readonly JsPrimitiveUnionPropertyClass?: Omit<
        JsPrimitiveUnionPropertyClass.$Filter,
        "$identifier"
      >;
      readonly LanguageInPropertiesClass?: Omit<
        LanguageInPropertiesClass.$Filter,
        "$identifier"
      >;
      readonly LazilyResolvedBlankNodeOrIriIdentifierClass?: Omit<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
        "$identifier"
      >;
      readonly LazilyResolvedBlankNodeOrIriIdentifierInterface?: Omit<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
        "$identifier"
      >;
      readonly LazilyResolvedClassUnionMember1?: Omit<
        LazilyResolvedClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly LazilyResolvedClassUnionMember2?: Omit<
        LazilyResolvedClassUnionMember2.$Filter,
        "$identifier"
      >;
      readonly LazilyResolvedInterfaceUnionMember1?: Omit<
        LazilyResolvedInterfaceUnionMember1.$Filter,
        "$identifier"
      >;
      readonly LazilyResolvedInterfaceUnionMember2?: Omit<
        LazilyResolvedInterfaceUnionMember2.$Filter,
        "$identifier"
      >;
      readonly LazilyResolvedIriIdentifierClass?: Omit<
        LazilyResolvedIriIdentifierClass.$Filter,
        "$identifier"
      >;
      readonly LazilyResolvedIriIdentifierInterface?: Omit<
        LazilyResolvedIriIdentifierInterface.$Filter,
        "$identifier"
      >;
      readonly LazyPropertiesClass?: Omit<
        LazyPropertiesClass.$Filter,
        "$identifier"
      >;
      readonly PartialClass?: Omit<PartialClass.$Filter, "$identifier">;
      readonly LazyPropertiesInterface?: Omit<
        LazyPropertiesInterface.$Filter,
        "$identifier"
      >;
      readonly PartialInterface?: Omit<PartialInterface.$Filter, "$identifier">;
      readonly ListPropertiesClass?: Omit<
        ListPropertiesClass.$Filter,
        "$identifier"
      >;
      readonly MutablePropertiesClass?: Omit<
        MutablePropertiesClass.$Filter,
        "$identifier"
      >;
      readonly NoRdfTypeClassUnionMember1?: Omit<
        NoRdfTypeClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly NoRdfTypeClassUnionMember2?: Omit<
        NoRdfTypeClassUnionMember2.$Filter,
        "$identifier"
      >;
      readonly NonClass?: Omit<NonClass.$Filter, "$identifier">;
      readonly OrderedPropertiesClass?: Omit<
        OrderedPropertiesClass.$Filter,
        "$identifier"
      >;
      readonly PartialClassUnionMember1?: Omit<
        PartialClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly PartialClassUnionMember2?: Omit<
        PartialClassUnionMember2.$Filter,
        "$identifier"
      >;
      readonly PartialInterfaceUnionMember1?: Omit<
        PartialInterfaceUnionMember1.$Filter,
        "$identifier"
      >;
      readonly PartialInterfaceUnionMember2?: Omit<
        PartialInterfaceUnionMember2.$Filter,
        "$identifier"
      >;
      readonly PropertyCardinalitiesClass?: Omit<
        PropertyCardinalitiesClass.$Filter,
        "$identifier"
      >;
      readonly PropertyVisibilitiesClass?: Omit<
        PropertyVisibilitiesClass.$Filter,
        "$identifier"
      >;
      readonly RecursiveClassUnionMember1?: Omit<
        RecursiveClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly RecursiveClassUnionMember2?: Omit<
        RecursiveClassUnionMember2.$Filter,
        "$identifier"
      >;
      readonly Sha256IriIdentifierClass?: Omit<
        Sha256IriIdentifierClass.$Filter,
        "$identifier"
      >;
      readonly TermPropertiesClass?: Omit<
        TermPropertiesClass.$Filter,
        "$identifier"
      >;
      readonly UnionDiscriminantsClass?: Omit<
        UnionDiscriminantsClass.$Filter,
        "$identifier"
      >;
      readonly UuidV4IriIdentifierClass?: Omit<
        UuidV4IriIdentifierClass.$Filter,
        "$identifier"
      >;
      readonly UuidV4IriIdentifierInterface?: Omit<
        UuidV4IriIdentifierInterface.$Filter,
        "$identifier"
      >;
      readonly $DefaultPartial?: Omit<$DefaultPartial.$Filter, "$identifier">;
      readonly $NamedDefaultPartial?: Omit<
        $NamedDefaultPartial.$Filter,
        "$identifier"
      >;
    };
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, $Object> {
    return (
      BlankNodeIdentifierClass.$fromJson(json) as purify.Either<
        zod.ZodError,
        $Object
      >
    )
      .altLazy(
        () =>
          BlankNodeIdentifierInterface.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          BlankNodeOrIriIdentifierClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          BlankNodeOrIriIdentifierInterface.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          ClassUnionMember1.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          ClassUnionMember2.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          ConcreteChildClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          ConcreteParentClassStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          ConcreteChildInterface.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          ConcreteParentInterfaceStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          BaseInterfaceWithoutPropertiesStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          BaseInterfaceWithPropertiesStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          ConvertibleTypePropertiesClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          DateUnionPropertiesClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          DefaultValuePropertiesClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          DirectRecursiveClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          ExplicitFromToRdfTypesClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          ExplicitRdfTypeClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          ExternClass.$fromJson(json) as purify.Either<zod.ZodError, $Object>,
      )
      .altLazy(
        () =>
          ExternClassPropertyClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          FlattenClassUnionMember3.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          HasValuePropertiesClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          IdentifierOverride5Class.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          IdentifierOverride4ClassStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          IdentifierOverride3ClassStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          InIdentifierClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          InPropertiesClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          IndirectRecursiveClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          IndirectRecursiveHelperClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () => Interface.$fromJson(json) as purify.Either<zod.ZodError, $Object>,
      )
      .altLazy(
        () =>
          InterfaceUnionMember1.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          InterfaceUnionMember2.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          IriIdentifierClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          IriIdentifierInterface.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          JsPrimitiveUnionPropertyClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          LanguageInPropertiesClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          LazilyResolvedBlankNodeOrIriIdentifierClass.$fromJson(
            json,
          ) as purify.Either<zod.ZodError, $Object>,
      )
      .altLazy(
        () =>
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromJson(
            json,
          ) as purify.Either<zod.ZodError, $Object>,
      )
      .altLazy(
        () =>
          LazilyResolvedClassUnionMember1.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          LazilyResolvedClassUnionMember2.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          LazilyResolvedInterfaceUnionMember1.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          LazilyResolvedInterfaceUnionMember2.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          LazilyResolvedIriIdentifierClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          LazilyResolvedIriIdentifierInterface.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          LazyPropertiesClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          PartialClass.$fromJson(json) as purify.Either<zod.ZodError, $Object>,
      )
      .altLazy(
        () =>
          LazyPropertiesInterface.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          PartialInterface.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          ListPropertiesClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          MutablePropertiesClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          NoRdfTypeClassUnionMember1.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          NoRdfTypeClassUnionMember2.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () => NonClass.$fromJson(json) as purify.Either<zod.ZodError, $Object>,
      )
      .altLazy(
        () =>
          OrderedPropertiesClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          PartialClassUnionMember1.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          PartialClassUnionMember2.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          PartialInterfaceUnionMember1.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          PartialInterfaceUnionMember2.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          PropertyCardinalitiesClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          PropertyVisibilitiesClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          RecursiveClassUnionMember1.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          RecursiveClassUnionMember2.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          Sha256IriIdentifierClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          TermPropertiesClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          UnionDiscriminantsClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          UuidV4IriIdentifierClass.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          UuidV4IriIdentifierInterface.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          $DefaultPartial.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          $NamedDefaultPartial.$fromJson(json) as purify.Either<
            zod.ZodError,
            $Object
          >,
      );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, $Object> {
    return (
      BlankNodeIdentifierClass.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, $Object>
    )
      .altLazy(
        () =>
          BlankNodeIdentifierInterface.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          BlankNodeOrIriIdentifierClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          BlankNodeOrIriIdentifierInterface.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ClassUnionMember1.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ClassUnionMember2.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ConcreteChildClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ConcreteParentClassStatic.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ConcreteChildInterface.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ConcreteParentInterfaceStatic.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          BaseInterfaceWithoutPropertiesStatic.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          BaseInterfaceWithPropertiesStatic.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ConvertibleTypePropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          DateUnionPropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          DefaultValuePropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          DirectRecursiveClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ExplicitFromToRdfTypesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ExplicitRdfTypeClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ExternClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ExternClassPropertyClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          FlattenClassUnionMember3.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          HasValuePropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          IdentifierOverride5Class.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          IdentifierOverride4ClassStatic.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          IdentifierOverride3ClassStatic.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          InIdentifierClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          InPropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          IndirectRecursiveClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          IndirectRecursiveHelperClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          Interface.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          InterfaceUnionMember1.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          InterfaceUnionMember2.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          IriIdentifierClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          IriIdentifierInterface.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          JsPrimitiveUnionPropertyClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LanguageInPropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LazilyResolvedClassUnionMember1.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LazilyResolvedClassUnionMember2.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LazilyResolvedInterfaceUnionMember1.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LazilyResolvedInterfaceUnionMember2.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LazilyResolvedIriIdentifierClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LazilyResolvedIriIdentifierInterface.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LazyPropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          PartialClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LazyPropertiesInterface.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          PartialInterface.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ListPropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          MutablePropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          NoRdfTypeClassUnionMember1.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          NoRdfTypeClassUnionMember2.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          NonClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          OrderedPropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          PartialClassUnionMember1.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          PartialClassUnionMember2.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          PartialInterfaceUnionMember1.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          PartialInterfaceUnionMember2.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          PropertyCardinalitiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          PropertyVisibilitiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          RecursiveClassUnionMember1.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          RecursiveClassUnionMember2.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          Sha256IriIdentifierClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          TermPropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          UnionDiscriminantsClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          UuidV4IriIdentifierClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          UuidV4IriIdentifierInterface.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          $DefaultPartial.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      )
      .altLazy(
        () =>
          $NamedDefaultPartial.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, $Object>,
      );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_object: $Object, _hasher: HasherT): HasherT {
    if (BlankNodeIdentifierClass.isBlankNodeIdentifierClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (BlankNodeIdentifierInterface.isBlankNodeIdentifierInterface(_object)) {
      return BlankNodeIdentifierInterface.$hash(_object, _hasher);
    }

    if (
      BlankNodeOrIriIdentifierClass.isBlankNodeOrIriIdentifierClass(_object)
    ) {
      return _object.$hash(_hasher);
    }

    if (
      BlankNodeOrIriIdentifierInterface.isBlankNodeOrIriIdentifierInterface(
        _object,
      )
    ) {
      return BlankNodeOrIriIdentifierInterface.$hash(_object, _hasher);
    }

    if (ClassUnionMember1.isClassUnionMember1(_object)) {
      return _object.$hash(_hasher);
    }

    if (ClassUnionMember2.isClassUnionMember2(_object)) {
      return _object.$hash(_hasher);
    }

    if (ConcreteChildClass.isConcreteChildClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (ConcreteParentClassStatic.isConcreteParentClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (ConcreteChildInterface.isConcreteChildInterface(_object)) {
      return ConcreteChildInterface.$hash(_object, _hasher);
    }

    if (ConcreteParentInterfaceStatic.isConcreteParentInterface(_object)) {
      return ConcreteParentInterfaceStatic.$hash(_object, _hasher);
    }

    if (
      BaseInterfaceWithoutPropertiesStatic.isBaseInterfaceWithoutProperties(
        _object,
      )
    ) {
      return BaseInterfaceWithoutPropertiesStatic.$hash(_object, _hasher);
    }

    if (
      BaseInterfaceWithPropertiesStatic.isBaseInterfaceWithProperties(_object)
    ) {
      return BaseInterfaceWithPropertiesStatic.$hash(_object, _hasher);
    }

    if (
      ConvertibleTypePropertiesClass.isConvertibleTypePropertiesClass(_object)
    ) {
      return _object.$hash(_hasher);
    }

    if (DateUnionPropertiesClass.isDateUnionPropertiesClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (DefaultValuePropertiesClass.isDefaultValuePropertiesClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (DirectRecursiveClass.isDirectRecursiveClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (ExplicitFromToRdfTypesClass.isExplicitFromToRdfTypesClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (ExplicitRdfTypeClass.isExplicitRdfTypeClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (ExternClass.isExternClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (ExternClassPropertyClass.isExternClassPropertyClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (FlattenClassUnionMember3.isFlattenClassUnionMember3(_object)) {
      return _object.$hash(_hasher);
    }

    if (HasValuePropertiesClass.isHasValuePropertiesClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (IdentifierOverride5Class.isIdentifierOverride5Class(_object)) {
      return _object.$hash(_hasher);
    }

    if (IdentifierOverride4ClassStatic.isIdentifierOverride4Class(_object)) {
      return _object.$hash(_hasher);
    }

    if (IdentifierOverride3ClassStatic.isIdentifierOverride3Class(_object)) {
      return _object.$hash(_hasher);
    }

    if (InIdentifierClass.isInIdentifierClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (InPropertiesClass.isInPropertiesClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (IndirectRecursiveClass.isIndirectRecursiveClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (IndirectRecursiveHelperClass.isIndirectRecursiveHelperClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (Interface.isInterface(_object)) {
      return Interface.$hash(_object, _hasher);
    }

    if (InterfaceUnionMember1.isInterfaceUnionMember1(_object)) {
      return InterfaceUnionMember1.$hash(_object, _hasher);
    }

    if (InterfaceUnionMember2.isInterfaceUnionMember2(_object)) {
      return InterfaceUnionMember2.$hash(_object, _hasher);
    }

    if (IriIdentifierClass.isIriIdentifierClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (IriIdentifierInterface.isIriIdentifierInterface(_object)) {
      return IriIdentifierInterface.$hash(_object, _hasher);
    }

    if (
      JsPrimitiveUnionPropertyClass.isJsPrimitiveUnionPropertyClass(_object)
    ) {
      return _object.$hash(_hasher);
    }

    if (LanguageInPropertiesClass.isLanguageInPropertiesClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (
      LazilyResolvedBlankNodeOrIriIdentifierClass.isLazilyResolvedBlankNodeOrIriIdentifierClass(
        _object,
      )
    ) {
      return _object.$hash(_hasher);
    }

    if (
      LazilyResolvedBlankNodeOrIriIdentifierInterface.isLazilyResolvedBlankNodeOrIriIdentifierInterface(
        _object,
      )
    ) {
      return LazilyResolvedBlankNodeOrIriIdentifierInterface.$hash(
        _object,
        _hasher,
      );
    }

    if (
      LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(_object)
    ) {
      return _object.$hash(_hasher);
    }

    if (
      LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(_object)
    ) {
      return _object.$hash(_hasher);
    }

    if (
      LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
        _object,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember1.$hash(_object, _hasher);
    }

    if (
      LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
        _object,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember2.$hash(_object, _hasher);
    }

    if (
      LazilyResolvedIriIdentifierClass.isLazilyResolvedIriIdentifierClass(
        _object,
      )
    ) {
      return _object.$hash(_hasher);
    }

    if (
      LazilyResolvedIriIdentifierInterface.isLazilyResolvedIriIdentifierInterface(
        _object,
      )
    ) {
      return LazilyResolvedIriIdentifierInterface.$hash(_object, _hasher);
    }

    if (LazyPropertiesClass.isLazyPropertiesClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (PartialClass.isPartialClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (LazyPropertiesInterface.isLazyPropertiesInterface(_object)) {
      return LazyPropertiesInterface.$hash(_object, _hasher);
    }

    if (PartialInterface.isPartialInterface(_object)) {
      return PartialInterface.$hash(_object, _hasher);
    }

    if (ListPropertiesClass.isListPropertiesClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (MutablePropertiesClass.isMutablePropertiesClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(_object)) {
      return _object.$hash(_hasher);
    }

    if (NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(_object)) {
      return _object.$hash(_hasher);
    }

    if (NonClass.isNonClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (OrderedPropertiesClass.isOrderedPropertiesClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (PartialClassUnionMember1.isPartialClassUnionMember1(_object)) {
      return _object.$hash(_hasher);
    }

    if (PartialClassUnionMember2.isPartialClassUnionMember2(_object)) {
      return _object.$hash(_hasher);
    }

    if (PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(_object)) {
      return PartialInterfaceUnionMember1.$hash(_object, _hasher);
    }

    if (PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(_object)) {
      return PartialInterfaceUnionMember2.$hash(_object, _hasher);
    }

    if (PropertyCardinalitiesClass.isPropertyCardinalitiesClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (PropertyVisibilitiesClass.isPropertyVisibilitiesClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (RecursiveClassUnionMember1.isRecursiveClassUnionMember1(_object)) {
      return _object.$hash(_hasher);
    }

    if (RecursiveClassUnionMember2.isRecursiveClassUnionMember2(_object)) {
      return _object.$hash(_hasher);
    }

    if (Sha256IriIdentifierClass.isSha256IriIdentifierClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (TermPropertiesClass.isTermPropertiesClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (UnionDiscriminantsClass.isUnionDiscriminantsClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (UuidV4IriIdentifierClass.isUuidV4IriIdentifierClass(_object)) {
      return _object.$hash(_hasher);
    }

    if (UuidV4IriIdentifierInterface.isUuidV4IriIdentifierInterface(_object)) {
      return UuidV4IriIdentifierInterface.$hash(_object, _hasher);
    }

    if ($DefaultPartial.is$DefaultPartial(_object)) {
      return _object.$hash(_hasher);
    }

    if ($NamedDefaultPartial.is$NamedDefaultPartial(_object)) {
      return _object.$hash(_hasher);
    }

    throw new Error("unrecognized type");
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json =
    | BlankNodeIdentifierClass.$Json
    | BlankNodeIdentifierInterface.$Json
    | BlankNodeOrIriIdentifierClass.$Json
    | BlankNodeOrIriIdentifierInterface.$Json
    | ClassUnionMember1.$Json
    | ClassUnionMember2.$Json
    | ConcreteChildClass.$Json
    | ConcreteParentClassStatic.$Json
    | ConcreteChildInterface.$Json
    | ConcreteParentInterfaceStatic.$Json
    | BaseInterfaceWithoutPropertiesStatic.$Json
    | BaseInterfaceWithPropertiesStatic.$Json
    | ConvertibleTypePropertiesClass.$Json
    | DateUnionPropertiesClass.$Json
    | DefaultValuePropertiesClass.$Json
    | DirectRecursiveClass.$Json
    | ExplicitFromToRdfTypesClass.$Json
    | ExplicitRdfTypeClass.$Json
    | ExternClass.$Json
    | ExternClassPropertyClass.$Json
    | FlattenClassUnionMember3.$Json
    | HasValuePropertiesClass.$Json
    | IdentifierOverride5Class.$Json
    | IdentifierOverride4ClassStatic.$Json
    | IdentifierOverride3ClassStatic.$Json
    | InIdentifierClass.$Json
    | InPropertiesClass.$Json
    | IndirectRecursiveClass.$Json
    | IndirectRecursiveHelperClass.$Json
    | Interface.$Json
    | InterfaceUnionMember1.$Json
    | InterfaceUnionMember2.$Json
    | IriIdentifierClass.$Json
    | IriIdentifierInterface.$Json
    | JsPrimitiveUnionPropertyClass.$Json
    | LanguageInPropertiesClass.$Json
    | LazilyResolvedBlankNodeOrIriIdentifierClass.$Json
    | LazilyResolvedBlankNodeOrIriIdentifierInterface.$Json
    | LazilyResolvedClassUnionMember1.$Json
    | LazilyResolvedClassUnionMember2.$Json
    | LazilyResolvedInterfaceUnionMember1.$Json
    | LazilyResolvedInterfaceUnionMember2.$Json
    | LazilyResolvedIriIdentifierClass.$Json
    | LazilyResolvedIriIdentifierInterface.$Json
    | LazyPropertiesClass.$Json
    | PartialClass.$Json
    | LazyPropertiesInterface.$Json
    | PartialInterface.$Json
    | ListPropertiesClass.$Json
    | MutablePropertiesClass.$Json
    | NoRdfTypeClassUnionMember1.$Json
    | NoRdfTypeClassUnionMember2.$Json
    | NonClass.$Json
    | OrderedPropertiesClass.$Json
    | PartialClassUnionMember1.$Json
    | PartialClassUnionMember2.$Json
    | PartialInterfaceUnionMember1.$Json
    | PartialInterfaceUnionMember2.$Json
    | PropertyCardinalitiesClass.$Json
    | PropertyVisibilitiesClass.$Json
    | RecursiveClassUnionMember1.$Json
    | RecursiveClassUnionMember2.$Json
    | Sha256IriIdentifierClass.$Json
    | TermPropertiesClass.$Json
    | UnionDiscriminantsClass.$Json
    | UuidV4IriIdentifierClass.$Json
    | UuidV4IriIdentifierInterface.$Json
    | $DefaultPartial.$Json
    | $NamedDefaultPartial.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      BlankNodeIdentifierClass.$jsonZodSchema(),
      BlankNodeIdentifierInterface.$jsonZodSchema(),
      BlankNodeOrIriIdentifierClass.$jsonZodSchema(),
      BlankNodeOrIriIdentifierInterface.$jsonZodSchema(),
      ClassUnionMember1.$jsonZodSchema(),
      ClassUnionMember2.$jsonZodSchema(),
      ConcreteChildClass.$jsonZodSchema(),
      ConcreteParentClassStatic.$jsonZodSchema(),
      ConcreteChildInterface.$jsonZodSchema(),
      ConcreteParentInterfaceStatic.$jsonZodSchema(),
      BaseInterfaceWithoutPropertiesStatic.$jsonZodSchema(),
      BaseInterfaceWithPropertiesStatic.$jsonZodSchema(),
      ConvertibleTypePropertiesClass.$jsonZodSchema(),
      DateUnionPropertiesClass.$jsonZodSchema(),
      DefaultValuePropertiesClass.$jsonZodSchema(),
      DirectRecursiveClass.$jsonZodSchema(),
      ExplicitFromToRdfTypesClass.$jsonZodSchema(),
      ExplicitRdfTypeClass.$jsonZodSchema(),
      ExternClass.$jsonZodSchema(),
      ExternClassPropertyClass.$jsonZodSchema(),
      FlattenClassUnionMember3.$jsonZodSchema(),
      HasValuePropertiesClass.$jsonZodSchema(),
      IdentifierOverride5Class.$jsonZodSchema(),
      IdentifierOverride4ClassStatic.$jsonZodSchema(),
      IdentifierOverride3ClassStatic.$jsonZodSchema(),
      InIdentifierClass.$jsonZodSchema(),
      InPropertiesClass.$jsonZodSchema(),
      IndirectRecursiveClass.$jsonZodSchema(),
      IndirectRecursiveHelperClass.$jsonZodSchema(),
      Interface.$jsonZodSchema(),
      InterfaceUnionMember1.$jsonZodSchema(),
      InterfaceUnionMember2.$jsonZodSchema(),
      IriIdentifierClass.$jsonZodSchema(),
      IriIdentifierInterface.$jsonZodSchema(),
      JsPrimitiveUnionPropertyClass.$jsonZodSchema(),
      LanguageInPropertiesClass.$jsonZodSchema(),
      LazilyResolvedBlankNodeOrIriIdentifierClass.$jsonZodSchema(),
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$jsonZodSchema(),
      LazilyResolvedClassUnionMember1.$jsonZodSchema(),
      LazilyResolvedClassUnionMember2.$jsonZodSchema(),
      LazilyResolvedInterfaceUnionMember1.$jsonZodSchema(),
      LazilyResolvedInterfaceUnionMember2.$jsonZodSchema(),
      LazilyResolvedIriIdentifierClass.$jsonZodSchema(),
      LazilyResolvedIriIdentifierInterface.$jsonZodSchema(),
      LazyPropertiesClass.$jsonZodSchema(),
      PartialClass.$jsonZodSchema(),
      LazyPropertiesInterface.$jsonZodSchema(),
      PartialInterface.$jsonZodSchema(),
      ListPropertiesClass.$jsonZodSchema(),
      MutablePropertiesClass.$jsonZodSchema(),
      NoRdfTypeClassUnionMember1.$jsonZodSchema(),
      NoRdfTypeClassUnionMember2.$jsonZodSchema(),
      NonClass.$jsonZodSchema(),
      OrderedPropertiesClass.$jsonZodSchema(),
      PartialClassUnionMember1.$jsonZodSchema(),
      PartialClassUnionMember2.$jsonZodSchema(),
      PartialInterfaceUnionMember1.$jsonZodSchema(),
      PartialInterfaceUnionMember2.$jsonZodSchema(),
      PropertyCardinalitiesClass.$jsonZodSchema(),
      PropertyVisibilitiesClass.$jsonZodSchema(),
      RecursiveClassUnionMember1.$jsonZodSchema(),
      RecursiveClassUnionMember2.$jsonZodSchema(),
      Sha256IriIdentifierClass.$jsonZodSchema(),
      TermPropertiesClass.$jsonZodSchema(),
      UnionDiscriminantsClass.$jsonZodSchema(),
      UuidV4IriIdentifierClass.$jsonZodSchema(),
      UuidV4IriIdentifierInterface.$jsonZodSchema(),
      $DefaultPartial.$jsonZodSchema(),
      $NamedDefaultPartial.$jsonZodSchema(),
    ]);
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: $Object.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        $Object.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            $Object.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: $Object.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      $Object.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...BlankNodeIdentifierClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectBlankNodeIdentifierClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}BlankNodeIdentifierClass`
          : "objectBlankNodeIdentifierClass",
      }).concat(),
      ...BlankNodeIdentifierInterface.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectBlankNodeIdentifierInterface"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}BlankNodeIdentifierInterface`
          : "objectBlankNodeIdentifierInterface",
      }).concat(),
      ...BlankNodeOrIriIdentifierClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectBlankNodeOrIriIdentifierClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}BlankNodeOrIriIdentifierClass`
          : "objectBlankNodeOrIriIdentifierClass",
      }).concat(),
      ...BlankNodeOrIriIdentifierInterface.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectBlankNodeOrIriIdentifierInterface"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}BlankNodeOrIriIdentifierInterface`
          : "objectBlankNodeOrIriIdentifierInterface",
      }).concat(),
      ...ClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectClassUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ClassUnionMember1`
          : "objectClassUnionMember1",
      }).concat(),
      ...ClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectClassUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ClassUnionMember2`
          : "objectClassUnionMember2",
      }).concat(),
      ...ConcreteChildClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectConcreteChildClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ConcreteChildClass`
          : "objectConcreteChildClass",
      }).concat(),
      ...ConcreteParentClassStatic.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectConcreteParentClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ConcreteParentClass`
          : "objectConcreteParentClass",
      }).concat(),
      ...ConcreteChildInterface.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectConcreteChildInterface"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ConcreteChildInterface`
          : "objectConcreteChildInterface",
      }).concat(),
      ...ConcreteParentInterfaceStatic.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectConcreteParentInterface"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ConcreteParentInterface`
          : "objectConcreteParentInterface",
      }).concat(),
      ...BaseInterfaceWithoutPropertiesStatic.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectBaseInterfaceWithoutProperties"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}BaseInterfaceWithoutProperties`
          : "objectBaseInterfaceWithoutProperties",
      }).concat(),
      ...BaseInterfaceWithPropertiesStatic.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectBaseInterfaceWithProperties"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}BaseInterfaceWithProperties`
          : "objectBaseInterfaceWithProperties",
      }).concat(),
      ...ConvertibleTypePropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectConvertibleTypePropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ConvertibleTypePropertiesClass`
          : "objectConvertibleTypePropertiesClass",
      }).concat(),
      ...DateUnionPropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectDateUnionPropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}DateUnionPropertiesClass`
          : "objectDateUnionPropertiesClass",
      }).concat(),
      ...DefaultValuePropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectDefaultValuePropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}DefaultValuePropertiesClass`
          : "objectDefaultValuePropertiesClass",
      }).concat(),
      ...DirectRecursiveClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectDirectRecursiveClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}DirectRecursiveClass`
          : "objectDirectRecursiveClass",
      }).concat(),
      ...ExplicitFromToRdfTypesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectExplicitFromToRdfTypesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ExplicitFromToRdfTypesClass`
          : "objectExplicitFromToRdfTypesClass",
      }).concat(),
      ...ExplicitRdfTypeClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectExplicitRdfTypeClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ExplicitRdfTypeClass`
          : "objectExplicitRdfTypeClass",
      }).concat(),
      ...ExternClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ?? dataFactory.variable!("objectExternClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ExternClass`
          : "objectExternClass",
      }).concat(),
      ...ExternClassPropertyClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectExternClassPropertyClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ExternClassPropertyClass`
          : "objectExternClassPropertyClass",
      }).concat(),
      ...FlattenClassUnionMember3.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectFlattenClassUnionMember3"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}FlattenClassUnionMember3`
          : "objectFlattenClassUnionMember3",
      }).concat(),
      ...HasValuePropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectHasValuePropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}HasValuePropertiesClass`
          : "objectHasValuePropertiesClass",
      }).concat(),
      ...IdentifierOverride5Class.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectIdentifierOverride5Class"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}IdentifierOverride5Class`
          : "objectIdentifierOverride5Class",
      }).concat(),
      ...IdentifierOverride4ClassStatic.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectIdentifierOverride4Class"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}IdentifierOverride4Class`
          : "objectIdentifierOverride4Class",
      }).concat(),
      ...IdentifierOverride3ClassStatic.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectIdentifierOverride3Class"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}IdentifierOverride3Class`
          : "objectIdentifierOverride3Class",
      }).concat(),
      ...InIdentifierClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectInIdentifierClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}InIdentifierClass`
          : "objectInIdentifierClass",
      }).concat(),
      ...InPropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectInPropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}InPropertiesClass`
          : "objectInPropertiesClass",
      }).concat(),
      ...IndirectRecursiveClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectIndirectRecursiveClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}IndirectRecursiveClass`
          : "objectIndirectRecursiveClass",
      }).concat(),
      ...IndirectRecursiveHelperClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectIndirectRecursiveHelperClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}IndirectRecursiveHelperClass`
          : "objectIndirectRecursiveHelperClass",
      }).concat(),
      ...Interface.$sparqlConstructTriples({
        subject:
          parameters?.subject ?? dataFactory.variable!("objectInterface"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}Interface`
          : "objectInterface",
      }).concat(),
      ...InterfaceUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectInterfaceUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}InterfaceUnionMember1`
          : "objectInterfaceUnionMember1",
      }).concat(),
      ...InterfaceUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectInterfaceUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}InterfaceUnionMember2`
          : "objectInterfaceUnionMember2",
      }).concat(),
      ...IriIdentifierClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectIriIdentifierClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}IriIdentifierClass`
          : "objectIriIdentifierClass",
      }).concat(),
      ...IriIdentifierInterface.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectIriIdentifierInterface"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}IriIdentifierInterface`
          : "objectIriIdentifierInterface",
      }).concat(),
      ...JsPrimitiveUnionPropertyClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectJsPrimitiveUnionPropertyClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}JsPrimitiveUnionPropertyClass`
          : "objectJsPrimitiveUnionPropertyClass",
      }).concat(),
      ...LanguageInPropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectLanguageInPropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LanguageInPropertiesClass`
          : "objectLanguageInPropertiesClass",
      }).concat(),
      ...LazilyResolvedBlankNodeOrIriIdentifierClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "objectLazilyResolvedBlankNodeOrIriIdentifierClass",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedBlankNodeOrIriIdentifierClass`
          : "objectLazilyResolvedBlankNodeOrIriIdentifierClass",
      }).concat(),
      ...LazilyResolvedBlankNodeOrIriIdentifierInterface.$sparqlConstructTriples(
        {
          subject:
            parameters?.subject ??
            dataFactory.variable!(
              "objectLazilyResolvedBlankNodeOrIriIdentifierInterface",
            ),
          variablePrefix: parameters?.variablePrefix
            ? `${parameters.variablePrefix}LazilyResolvedBlankNodeOrIriIdentifierInterface`
            : "objectLazilyResolvedBlankNodeOrIriIdentifierInterface",
        },
      ).concat(),
      ...LazilyResolvedClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectLazilyResolvedClassUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember1`
          : "objectLazilyResolvedClassUnionMember1",
      }).concat(),
      ...LazilyResolvedClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectLazilyResolvedClassUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember2`
          : "objectLazilyResolvedClassUnionMember2",
      }).concat(),
      ...LazilyResolvedInterfaceUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectLazilyResolvedInterfaceUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember1`
          : "objectLazilyResolvedInterfaceUnionMember1",
      }).concat(),
      ...LazilyResolvedInterfaceUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectLazilyResolvedInterfaceUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember2`
          : "objectLazilyResolvedInterfaceUnionMember2",
      }).concat(),
      ...LazilyResolvedIriIdentifierClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectLazilyResolvedIriIdentifierClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedIriIdentifierClass`
          : "objectLazilyResolvedIriIdentifierClass",
      }).concat(),
      ...LazilyResolvedIriIdentifierInterface.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectLazilyResolvedIriIdentifierInterface"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedIriIdentifierInterface`
          : "objectLazilyResolvedIriIdentifierInterface",
      }).concat(),
      ...LazyPropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectLazyPropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazyPropertiesClass`
          : "objectLazyPropertiesClass",
      }).concat(),
      ...PartialClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ?? dataFactory.variable!("objectPartialClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialClass`
          : "objectPartialClass",
      }).concat(),
      ...LazyPropertiesInterface.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectLazyPropertiesInterface"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazyPropertiesInterface`
          : "objectLazyPropertiesInterface",
      }).concat(),
      ...PartialInterface.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectPartialInterface"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialInterface`
          : "objectPartialInterface",
      }).concat(),
      ...ListPropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectListPropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ListPropertiesClass`
          : "objectListPropertiesClass",
      }).concat(),
      ...MutablePropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectMutablePropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}MutablePropertiesClass`
          : "objectMutablePropertiesClass",
      }).concat(),
      ...NoRdfTypeClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectNoRdfTypeClassUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}NoRdfTypeClassUnionMember1`
          : "objectNoRdfTypeClassUnionMember1",
      }).concat(),
      ...NoRdfTypeClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectNoRdfTypeClassUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}NoRdfTypeClassUnionMember2`
          : "objectNoRdfTypeClassUnionMember2",
      }).concat(),
      ...NonClass.$sparqlConstructTriples({
        subject: parameters?.subject ?? dataFactory.variable!("objectNonClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}NonClass`
          : "objectNonClass",
      }).concat(),
      ...OrderedPropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectOrderedPropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}OrderedPropertiesClass`
          : "objectOrderedPropertiesClass",
      }).concat(),
      ...PartialClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectPartialClassUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialClassUnionMember1`
          : "objectPartialClassUnionMember1",
      }).concat(),
      ...PartialClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectPartialClassUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialClassUnionMember2`
          : "objectPartialClassUnionMember2",
      }).concat(),
      ...PartialInterfaceUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectPartialInterfaceUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialInterfaceUnionMember1`
          : "objectPartialInterfaceUnionMember1",
      }).concat(),
      ...PartialInterfaceUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectPartialInterfaceUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialInterfaceUnionMember2`
          : "objectPartialInterfaceUnionMember2",
      }).concat(),
      ...PropertyCardinalitiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectPropertyCardinalitiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PropertyCardinalitiesClass`
          : "objectPropertyCardinalitiesClass",
      }).concat(),
      ...PropertyVisibilitiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectPropertyVisibilitiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PropertyVisibilitiesClass`
          : "objectPropertyVisibilitiesClass",
      }).concat(),
      ...RecursiveClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectRecursiveClassUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}RecursiveClassUnionMember1`
          : "objectRecursiveClassUnionMember1",
      }).concat(),
      ...RecursiveClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectRecursiveClassUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}RecursiveClassUnionMember2`
          : "objectRecursiveClassUnionMember2",
      }).concat(),
      ...Sha256IriIdentifierClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectSha256IriIdentifierClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}Sha256IriIdentifierClass`
          : "objectSha256IriIdentifierClass",
      }).concat(),
      ...TermPropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectTermPropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}TermPropertiesClass`
          : "objectTermPropertiesClass",
      }).concat(),
      ...UnionDiscriminantsClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectUnionDiscriminantsClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}UnionDiscriminantsClass`
          : "objectUnionDiscriminantsClass",
      }).concat(),
      ...UuidV4IriIdentifierClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectUuidV4IriIdentifierClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}UuidV4IriIdentifierClass`
          : "objectUuidV4IriIdentifierClass",
      }).concat(),
      ...UuidV4IriIdentifierInterface.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectUuidV4IriIdentifierInterface"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}UuidV4IriIdentifierInterface`
          : "objectUuidV4IriIdentifierInterface",
      }).concat(),
      ...$DefaultPartial
        .$sparqlConstructTriples({
          subject:
            parameters?.subject ??
            dataFactory.variable!("objectDefaultPartial"),
          variablePrefix: parameters?.variablePrefix
            ? `${parameters.variablePrefix}DefaultPartial`
            : "objectDefaultPartial",
        })
        .concat(),
      ...$NamedDefaultPartial
        .$sparqlConstructTriples({
          subject:
            parameters?.subject ??
            dataFactory.variable!("objectNamedDefaultPartial"),
          variablePrefix: parameters?.variablePrefix
            ? `${parameters.variablePrefix}NamedDefaultPartial`
            : "objectNamedDefaultPartial",
        })
        .concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: $Object.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("object");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: [
        {
          patterns: BlankNodeIdentifierClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.BlankNodeIdentifierClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectBlankNodeIdentifierClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}BlankNodeIdentifierClass`
              : "objectBlankNodeIdentifierClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: BlankNodeIdentifierInterface.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.BlankNodeIdentifierInterface,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectBlankNodeIdentifierInterface"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}BlankNodeIdentifierInterface`
              : "objectBlankNodeIdentifierInterface",
          }).concat(),
          type: "group",
        },
        {
          patterns: BlankNodeOrIriIdentifierClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.BlankNodeOrIriIdentifierClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectBlankNodeOrIriIdentifierClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}BlankNodeOrIriIdentifierClass`
              : "objectBlankNodeOrIriIdentifierClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: BlankNodeOrIriIdentifierInterface.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.BlankNodeOrIriIdentifierInterface,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectBlankNodeOrIriIdentifierInterface"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}BlankNodeOrIriIdentifierInterface`
              : "objectBlankNodeOrIriIdentifierInterface",
          }).concat(),
          type: "group",
        },
        {
          patterns: ClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectClassUnionMember1"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ClassUnionMember1`
              : "objectClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: ClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectClassUnionMember2"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ClassUnionMember2`
              : "objectClassUnionMember2",
          }).concat(),
          type: "group",
        },
        {
          patterns: ConcreteChildClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ConcreteChildClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectConcreteChildClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ConcreteChildClass`
              : "objectConcreteChildClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: ConcreteParentClassStatic.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ConcreteParentClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectConcreteParentClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ConcreteParentClass`
              : "objectConcreteParentClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: ConcreteChildInterface.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ConcreteChildInterface,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectConcreteChildInterface"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ConcreteChildInterface`
              : "objectConcreteChildInterface",
          }).concat(),
          type: "group",
        },
        {
          patterns: ConcreteParentInterfaceStatic.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ConcreteParentInterface,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectConcreteParentInterface"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ConcreteParentInterface`
              : "objectConcreteParentInterface",
          }).concat(),
          type: "group",
        },
        {
          patterns: BaseInterfaceWithoutPropertiesStatic.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.BaseInterfaceWithoutProperties,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectBaseInterfaceWithoutProperties"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}BaseInterfaceWithoutProperties`
              : "objectBaseInterfaceWithoutProperties",
          }).concat(),
          type: "group",
        },
        {
          patterns: BaseInterfaceWithPropertiesStatic.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.BaseInterfaceWithProperties,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectBaseInterfaceWithProperties"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}BaseInterfaceWithProperties`
              : "objectBaseInterfaceWithProperties",
          }).concat(),
          type: "group",
        },
        {
          patterns: ConvertibleTypePropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ConvertibleTypePropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectConvertibleTypePropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ConvertibleTypePropertiesClass`
              : "objectConvertibleTypePropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: DateUnionPropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.DateUnionPropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectDateUnionPropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}DateUnionPropertiesClass`
              : "objectDateUnionPropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: DefaultValuePropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.DefaultValuePropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectDefaultValuePropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}DefaultValuePropertiesClass`
              : "objectDefaultValuePropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: DirectRecursiveClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.DirectRecursiveClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectDirectRecursiveClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}DirectRecursiveClass`
              : "objectDirectRecursiveClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: ExplicitFromToRdfTypesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ExplicitFromToRdfTypesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectExplicitFromToRdfTypesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ExplicitFromToRdfTypesClass`
              : "objectExplicitFromToRdfTypesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: ExplicitRdfTypeClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ExplicitRdfTypeClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectExplicitRdfTypeClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ExplicitRdfTypeClass`
              : "objectExplicitRdfTypeClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: ExternClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ExternClass,
            subject:
              parameters?.subject ?? dataFactory.variable!("objectExternClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ExternClass`
              : "objectExternClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: ExternClassPropertyClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ExternClassPropertyClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectExternClassPropertyClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ExternClassPropertyClass`
              : "objectExternClassPropertyClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: FlattenClassUnionMember3.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.FlattenClassUnionMember3,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectFlattenClassUnionMember3"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}FlattenClassUnionMember3`
              : "objectFlattenClassUnionMember3",
          }).concat(),
          type: "group",
        },
        {
          patterns: HasValuePropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.HasValuePropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectHasValuePropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}HasValuePropertiesClass`
              : "objectHasValuePropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: IdentifierOverride5Class.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.IdentifierOverride5Class,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectIdentifierOverride5Class"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}IdentifierOverride5Class`
              : "objectIdentifierOverride5Class",
          }).concat(),
          type: "group",
        },
        {
          patterns: IdentifierOverride4ClassStatic.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.IdentifierOverride4Class,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectIdentifierOverride4Class"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}IdentifierOverride4Class`
              : "objectIdentifierOverride4Class",
          }).concat(),
          type: "group",
        },
        {
          patterns: IdentifierOverride3ClassStatic.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.IdentifierOverride3Class,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectIdentifierOverride3Class"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}IdentifierOverride3Class`
              : "objectIdentifierOverride3Class",
          }).concat(),
          type: "group",
        },
        {
          patterns: InIdentifierClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.InIdentifierClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectInIdentifierClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}InIdentifierClass`
              : "objectInIdentifierClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: InPropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.InPropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectInPropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}InPropertiesClass`
              : "objectInPropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: IndirectRecursiveClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.IndirectRecursiveClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectIndirectRecursiveClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}IndirectRecursiveClass`
              : "objectIndirectRecursiveClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: IndirectRecursiveHelperClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.IndirectRecursiveHelperClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectIndirectRecursiveHelperClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}IndirectRecursiveHelperClass`
              : "objectIndirectRecursiveHelperClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: Interface.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.Interface,
            subject:
              parameters?.subject ?? dataFactory.variable!("objectInterface"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}Interface`
              : "objectInterface",
          }).concat(),
          type: "group",
        },
        {
          patterns: InterfaceUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.InterfaceUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectInterfaceUnionMember1"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}InterfaceUnionMember1`
              : "objectInterfaceUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: InterfaceUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.InterfaceUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectInterfaceUnionMember2"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}InterfaceUnionMember2`
              : "objectInterfaceUnionMember2",
          }).concat(),
          type: "group",
        },
        {
          patterns: IriIdentifierClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.IriIdentifierClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectIriIdentifierClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}IriIdentifierClass`
              : "objectIriIdentifierClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: IriIdentifierInterface.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.IriIdentifierInterface,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectIriIdentifierInterface"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}IriIdentifierInterface`
              : "objectIriIdentifierInterface",
          }).concat(),
          type: "group",
        },
        {
          patterns: JsPrimitiveUnionPropertyClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.JsPrimitiveUnionPropertyClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectJsPrimitiveUnionPropertyClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}JsPrimitiveUnionPropertyClass`
              : "objectJsPrimitiveUnionPropertyClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: LanguageInPropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LanguageInPropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectLanguageInPropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LanguageInPropertiesClass`
              : "objectLanguageInPropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns:
            LazilyResolvedBlankNodeOrIriIdentifierClass.$sparqlWherePatterns({
              filter:
                parameters?.filter?.on
                  ?.LazilyResolvedBlankNodeOrIriIdentifierClass,
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "objectLazilyResolvedBlankNodeOrIriIdentifierClass",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}LazilyResolvedBlankNodeOrIriIdentifierClass`
                : "objectLazilyResolvedBlankNodeOrIriIdentifierClass",
            }).concat(),
          type: "group",
        },
        {
          patterns:
            LazilyResolvedBlankNodeOrIriIdentifierInterface.$sparqlWherePatterns(
              {
                filter:
                  parameters?.filter?.on
                    ?.LazilyResolvedBlankNodeOrIriIdentifierInterface,
                subject:
                  parameters?.subject ??
                  dataFactory.variable!(
                    "objectLazilyResolvedBlankNodeOrIriIdentifierInterface",
                  ),
                variablePrefix: parameters?.variablePrefix
                  ? `${parameters.variablePrefix}LazilyResolvedBlankNodeOrIriIdentifierInterface`
                  : "objectLazilyResolvedBlankNodeOrIriIdentifierInterface",
              },
            ).concat(),
          type: "group",
        },
        {
          patterns: LazilyResolvedClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazilyResolvedClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectLazilyResolvedClassUnionMember1"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember1`
              : "objectLazilyResolvedClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: LazilyResolvedClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazilyResolvedClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectLazilyResolvedClassUnionMember2"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember2`
              : "objectLazilyResolvedClassUnionMember2",
          }).concat(),
          type: "group",
        },
        {
          patterns: LazilyResolvedInterfaceUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazilyResolvedInterfaceUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "objectLazilyResolvedInterfaceUnionMember1",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember1`
              : "objectLazilyResolvedInterfaceUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: LazilyResolvedInterfaceUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazilyResolvedInterfaceUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "objectLazilyResolvedInterfaceUnionMember2",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember2`
              : "objectLazilyResolvedInterfaceUnionMember2",
          }).concat(),
          type: "group",
        },
        {
          patterns: LazilyResolvedIriIdentifierClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazilyResolvedIriIdentifierClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectLazilyResolvedIriIdentifierClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazilyResolvedIriIdentifierClass`
              : "objectLazilyResolvedIriIdentifierClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: LazilyResolvedIriIdentifierInterface.$sparqlWherePatterns({
            filter:
              parameters?.filter?.on?.LazilyResolvedIriIdentifierInterface,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "objectLazilyResolvedIriIdentifierInterface",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazilyResolvedIriIdentifierInterface`
              : "objectLazilyResolvedIriIdentifierInterface",
          }).concat(),
          type: "group",
        },
        {
          patterns: LazyPropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazyPropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectLazyPropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazyPropertiesClass`
              : "objectLazyPropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: PartialClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PartialClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectPartialClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PartialClass`
              : "objectPartialClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: LazyPropertiesInterface.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazyPropertiesInterface,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectLazyPropertiesInterface"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazyPropertiesInterface`
              : "objectLazyPropertiesInterface",
          }).concat(),
          type: "group",
        },
        {
          patterns: PartialInterface.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PartialInterface,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectPartialInterface"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PartialInterface`
              : "objectPartialInterface",
          }).concat(),
          type: "group",
        },
        {
          patterns: ListPropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ListPropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectListPropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ListPropertiesClass`
              : "objectListPropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: MutablePropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.MutablePropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectMutablePropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}MutablePropertiesClass`
              : "objectMutablePropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: NoRdfTypeClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.NoRdfTypeClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectNoRdfTypeClassUnionMember1"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}NoRdfTypeClassUnionMember1`
              : "objectNoRdfTypeClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: NoRdfTypeClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.NoRdfTypeClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectNoRdfTypeClassUnionMember2"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}NoRdfTypeClassUnionMember2`
              : "objectNoRdfTypeClassUnionMember2",
          }).concat(),
          type: "group",
        },
        {
          patterns: NonClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.NonClass,
            subject:
              parameters?.subject ?? dataFactory.variable!("objectNonClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}NonClass`
              : "objectNonClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: OrderedPropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.OrderedPropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectOrderedPropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}OrderedPropertiesClass`
              : "objectOrderedPropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: PartialClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PartialClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectPartialClassUnionMember1"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PartialClassUnionMember1`
              : "objectPartialClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: PartialClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PartialClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectPartialClassUnionMember2"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PartialClassUnionMember2`
              : "objectPartialClassUnionMember2",
          }).concat(),
          type: "group",
        },
        {
          patterns: PartialInterfaceUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PartialInterfaceUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectPartialInterfaceUnionMember1"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PartialInterfaceUnionMember1`
              : "objectPartialInterfaceUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: PartialInterfaceUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PartialInterfaceUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectPartialInterfaceUnionMember2"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PartialInterfaceUnionMember2`
              : "objectPartialInterfaceUnionMember2",
          }).concat(),
          type: "group",
        },
        {
          patterns: PropertyCardinalitiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PropertyCardinalitiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectPropertyCardinalitiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PropertyCardinalitiesClass`
              : "objectPropertyCardinalitiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: PropertyVisibilitiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PropertyVisibilitiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectPropertyVisibilitiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PropertyVisibilitiesClass`
              : "objectPropertyVisibilitiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: RecursiveClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.RecursiveClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectRecursiveClassUnionMember1"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}RecursiveClassUnionMember1`
              : "objectRecursiveClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: RecursiveClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.RecursiveClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectRecursiveClassUnionMember2"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}RecursiveClassUnionMember2`
              : "objectRecursiveClassUnionMember2",
          }).concat(),
          type: "group",
        },
        {
          patterns: Sha256IriIdentifierClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.Sha256IriIdentifierClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectSha256IriIdentifierClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}Sha256IriIdentifierClass`
              : "objectSha256IriIdentifierClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: TermPropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.TermPropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectTermPropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}TermPropertiesClass`
              : "objectTermPropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: UnionDiscriminantsClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.UnionDiscriminantsClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectUnionDiscriminantsClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}UnionDiscriminantsClass`
              : "objectUnionDiscriminantsClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: UuidV4IriIdentifierClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.UuidV4IriIdentifierClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectUuidV4IriIdentifierClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}UuidV4IriIdentifierClass`
              : "objectUuidV4IriIdentifierClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: UuidV4IriIdentifierInterface.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.UuidV4IriIdentifierInterface,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectUuidV4IriIdentifierInterface"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}UuidV4IriIdentifierInterface`
              : "objectUuidV4IriIdentifierInterface",
          }).concat(),
          type: "group",
        },
        {
          patterns: $DefaultPartial
            .$sparqlWherePatterns({
              filter: parameters?.filter?.on?.$DefaultPartial,
              subject:
                parameters?.subject ??
                dataFactory.variable!("objectDefaultPartial"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}DefaultPartial`
                : "objectDefaultPartial",
            })
            .concat(),
          type: "group",
        },
        {
          patterns: $NamedDefaultPartial
            .$sparqlWherePatterns({
              filter: parameters?.filter?.on?.$NamedDefaultPartial,
              subject:
                parameters?.subject ??
                dataFactory.variable!("objectNamedDefaultPartial"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}NamedDefaultPartial`
                : "objectNamedDefaultPartial",
            })
            .concat(),
          type: "group",
        },
      ],
      type: "union",
    });
    return patterns;
  }

  export function $toJson(
    _object: $Object,
  ):
    | BlankNodeIdentifierClass.$Json
    | BlankNodeIdentifierInterface.$Json
    | BlankNodeOrIriIdentifierClass.$Json
    | BlankNodeOrIriIdentifierInterface.$Json
    | ClassUnionMember1.$Json
    | ClassUnionMember2.$Json
    | ClassUnionMemberCommonParentStatic.$Json
    | ConcreteChildClass.$Json
    | ConcreteParentClassStatic.$Json
    | AbstractBaseClassWithoutPropertiesStatic.$Json
    | AbstractBaseClassWithPropertiesStatic.$Json
    | ConcreteChildInterface.$Json
    | ConcreteParentInterfaceStatic.$Json
    | BaseInterfaceWithoutPropertiesStatic.$Json
    | BaseInterfaceWithPropertiesStatic.$Json
    | ConvertibleTypePropertiesClass.$Json
    | DateUnionPropertiesClass.$Json
    | DefaultValuePropertiesClass.$Json
    | DirectRecursiveClass.$Json
    | ExplicitFromToRdfTypesClass.$Json
    | ExplicitRdfTypeClass.$Json
    | ExternClass.$Json
    | AbstractBaseClassForExternClassStatic.$Json
    | ExternClassPropertyClass.$Json
    | FlattenClassUnionMember3.$Json
    | HasValuePropertiesClass.$Json
    | IdentifierOverride5Class.$Json
    | IdentifierOverride4ClassStatic.$Json
    | IdentifierOverride3ClassStatic.$Json
    | IdentifierOverride2ClassStatic.$Json
    | IdentifierOverride1ClassStatic.$Json
    | InIdentifierClass.$Json
    | InPropertiesClass.$Json
    | IndirectRecursiveClass.$Json
    | IndirectRecursiveHelperClass.$Json
    | Interface.$Json
    | InterfaceUnionMember1.$Json
    | InterfaceUnionMember2.$Json
    | InterfaceUnionMemberCommonParentStatic.$Json
    | IriIdentifierClass.$Json
    | IriIdentifierInterface.$Json
    | JsPrimitiveUnionPropertyClass.$Json
    | LanguageInPropertiesClass.$Json
    | LazilyResolvedBlankNodeOrIriIdentifierClass.$Json
    | LazilyResolvedBlankNodeOrIriIdentifierInterface.$Json
    | LazilyResolvedClassUnionMember1.$Json
    | LazilyResolvedClassUnionMember2.$Json
    | LazilyResolvedInterfaceUnionMember1.$Json
    | LazilyResolvedInterfaceUnionMember2.$Json
    | LazilyResolvedIriIdentifierClass.$Json
    | LazilyResolvedIriIdentifierInterface.$Json
    | LazyPropertiesClass.$Json
    | PartialClass.$Json
    | LazyPropertiesInterface.$Json
    | PartialInterface.$Json
    | ListPropertiesClass.$Json
    | MutablePropertiesClass.$Json
    | NoRdfTypeClassUnionMember1.$Json
    | NoRdfTypeClassUnionMember2.$Json
    | NonClass.$Json
    | OrderedPropertiesClass.$Json
    | PartialClassUnionMember1.$Json
    | PartialClassUnionMember2.$Json
    | PartialInterfaceUnionMember1.$Json
    | PartialInterfaceUnionMember2.$Json
    | PropertyCardinalitiesClass.$Json
    | PropertyVisibilitiesClass.$Json
    | RecursiveClassUnionMember1.$Json
    | RecursiveClassUnionMember2.$Json
    | Sha256IriIdentifierClass.$Json
    | TermPropertiesClass.$Json
    | UnionDiscriminantsClass.$Json
    | UuidV4IriIdentifierClass.$Json
    | UuidV4IriIdentifierInterface.$Json
    | $DefaultPartial.$Json
    | $NamedDefaultPartial.$Json {
    if (BlankNodeIdentifierClass.isBlankNodeIdentifierClass(_object)) {
      return _object.$toJson();
    }

    if (BlankNodeIdentifierInterface.isBlankNodeIdentifierInterface(_object)) {
      return BlankNodeIdentifierInterface.$toJson(_object);
    }

    if (
      BlankNodeOrIriIdentifierClass.isBlankNodeOrIriIdentifierClass(_object)
    ) {
      return _object.$toJson();
    }

    if (
      BlankNodeOrIriIdentifierInterface.isBlankNodeOrIriIdentifierInterface(
        _object,
      )
    ) {
      return BlankNodeOrIriIdentifierInterface.$toJson(_object);
    }

    if (ClassUnionMember1.isClassUnionMember1(_object)) {
      return _object.$toJson();
    }

    if (ClassUnionMember2.isClassUnionMember2(_object)) {
      return _object.$toJson();
    }

    if (ConcreteChildClass.isConcreteChildClass(_object)) {
      return _object.$toJson();
    }

    if (ConcreteParentClassStatic.isConcreteParentClass(_object)) {
      return _object.$toJson();
    }

    if (ConcreteChildInterface.isConcreteChildInterface(_object)) {
      return ConcreteChildInterface.$toJson(_object);
    }

    if (ConcreteParentInterfaceStatic.isConcreteParentInterface(_object)) {
      return ConcreteParentInterfaceStatic.$toJson(_object);
    }

    if (
      BaseInterfaceWithoutPropertiesStatic.isBaseInterfaceWithoutProperties(
        _object,
      )
    ) {
      return BaseInterfaceWithoutPropertiesStatic.$toJson(_object);
    }

    if (
      BaseInterfaceWithPropertiesStatic.isBaseInterfaceWithProperties(_object)
    ) {
      return BaseInterfaceWithPropertiesStatic.$toJson(_object);
    }

    if (
      ConvertibleTypePropertiesClass.isConvertibleTypePropertiesClass(_object)
    ) {
      return _object.$toJson();
    }

    if (DateUnionPropertiesClass.isDateUnionPropertiesClass(_object)) {
      return _object.$toJson();
    }

    if (DefaultValuePropertiesClass.isDefaultValuePropertiesClass(_object)) {
      return _object.$toJson();
    }

    if (DirectRecursiveClass.isDirectRecursiveClass(_object)) {
      return _object.$toJson();
    }

    if (ExplicitFromToRdfTypesClass.isExplicitFromToRdfTypesClass(_object)) {
      return _object.$toJson();
    }

    if (ExplicitRdfTypeClass.isExplicitRdfTypeClass(_object)) {
      return _object.$toJson();
    }

    if (ExternClass.isExternClass(_object)) {
      return _object.$toJson();
    }

    if (ExternClassPropertyClass.isExternClassPropertyClass(_object)) {
      return _object.$toJson();
    }

    if (FlattenClassUnionMember3.isFlattenClassUnionMember3(_object)) {
      return _object.$toJson();
    }

    if (HasValuePropertiesClass.isHasValuePropertiesClass(_object)) {
      return _object.$toJson();
    }

    if (IdentifierOverride5Class.isIdentifierOverride5Class(_object)) {
      return _object.$toJson();
    }

    if (IdentifierOverride4ClassStatic.isIdentifierOverride4Class(_object)) {
      return _object.$toJson();
    }

    if (IdentifierOverride3ClassStatic.isIdentifierOverride3Class(_object)) {
      return _object.$toJson();
    }

    if (InIdentifierClass.isInIdentifierClass(_object)) {
      return _object.$toJson();
    }

    if (InPropertiesClass.isInPropertiesClass(_object)) {
      return _object.$toJson();
    }

    if (IndirectRecursiveClass.isIndirectRecursiveClass(_object)) {
      return _object.$toJson();
    }

    if (IndirectRecursiveHelperClass.isIndirectRecursiveHelperClass(_object)) {
      return _object.$toJson();
    }

    if (Interface.isInterface(_object)) {
      return Interface.$toJson(_object);
    }

    if (InterfaceUnionMember1.isInterfaceUnionMember1(_object)) {
      return InterfaceUnionMember1.$toJson(_object);
    }

    if (InterfaceUnionMember2.isInterfaceUnionMember2(_object)) {
      return InterfaceUnionMember2.$toJson(_object);
    }

    if (IriIdentifierClass.isIriIdentifierClass(_object)) {
      return _object.$toJson();
    }

    if (IriIdentifierInterface.isIriIdentifierInterface(_object)) {
      return IriIdentifierInterface.$toJson(_object);
    }

    if (
      JsPrimitiveUnionPropertyClass.isJsPrimitiveUnionPropertyClass(_object)
    ) {
      return _object.$toJson();
    }

    if (LanguageInPropertiesClass.isLanguageInPropertiesClass(_object)) {
      return _object.$toJson();
    }

    if (
      LazilyResolvedBlankNodeOrIriIdentifierClass.isLazilyResolvedBlankNodeOrIriIdentifierClass(
        _object,
      )
    ) {
      return _object.$toJson();
    }

    if (
      LazilyResolvedBlankNodeOrIriIdentifierInterface.isLazilyResolvedBlankNodeOrIriIdentifierInterface(
        _object,
      )
    ) {
      return LazilyResolvedBlankNodeOrIriIdentifierInterface.$toJson(_object);
    }

    if (
      LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(_object)
    ) {
      return _object.$toJson();
    }

    if (
      LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(_object)
    ) {
      return _object.$toJson();
    }

    if (
      LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
        _object,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember1.$toJson(_object);
    }

    if (
      LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
        _object,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember2.$toJson(_object);
    }

    if (
      LazilyResolvedIriIdentifierClass.isLazilyResolvedIriIdentifierClass(
        _object,
      )
    ) {
      return _object.$toJson();
    }

    if (
      LazilyResolvedIriIdentifierInterface.isLazilyResolvedIriIdentifierInterface(
        _object,
      )
    ) {
      return LazilyResolvedIriIdentifierInterface.$toJson(_object);
    }

    if (LazyPropertiesClass.isLazyPropertiesClass(_object)) {
      return _object.$toJson();
    }

    if (PartialClass.isPartialClass(_object)) {
      return _object.$toJson();
    }

    if (LazyPropertiesInterface.isLazyPropertiesInterface(_object)) {
      return LazyPropertiesInterface.$toJson(_object);
    }

    if (PartialInterface.isPartialInterface(_object)) {
      return PartialInterface.$toJson(_object);
    }

    if (ListPropertiesClass.isListPropertiesClass(_object)) {
      return _object.$toJson();
    }

    if (MutablePropertiesClass.isMutablePropertiesClass(_object)) {
      return _object.$toJson();
    }

    if (NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(_object)) {
      return _object.$toJson();
    }

    if (NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(_object)) {
      return _object.$toJson();
    }

    if (NonClass.isNonClass(_object)) {
      return _object.$toJson();
    }

    if (OrderedPropertiesClass.isOrderedPropertiesClass(_object)) {
      return _object.$toJson();
    }

    if (PartialClassUnionMember1.isPartialClassUnionMember1(_object)) {
      return _object.$toJson();
    }

    if (PartialClassUnionMember2.isPartialClassUnionMember2(_object)) {
      return _object.$toJson();
    }

    if (PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(_object)) {
      return PartialInterfaceUnionMember1.$toJson(_object);
    }

    if (PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(_object)) {
      return PartialInterfaceUnionMember2.$toJson(_object);
    }

    if (PropertyCardinalitiesClass.isPropertyCardinalitiesClass(_object)) {
      return _object.$toJson();
    }

    if (PropertyVisibilitiesClass.isPropertyVisibilitiesClass(_object)) {
      return _object.$toJson();
    }

    if (RecursiveClassUnionMember1.isRecursiveClassUnionMember1(_object)) {
      return _object.$toJson();
    }

    if (RecursiveClassUnionMember2.isRecursiveClassUnionMember2(_object)) {
      return _object.$toJson();
    }

    if (Sha256IriIdentifierClass.isSha256IriIdentifierClass(_object)) {
      return _object.$toJson();
    }

    if (TermPropertiesClass.isTermPropertiesClass(_object)) {
      return _object.$toJson();
    }

    if (UnionDiscriminantsClass.isUnionDiscriminantsClass(_object)) {
      return _object.$toJson();
    }

    if (UuidV4IriIdentifierClass.isUuidV4IriIdentifierClass(_object)) {
      return _object.$toJson();
    }

    if (UuidV4IriIdentifierInterface.isUuidV4IriIdentifierInterface(_object)) {
      return UuidV4IriIdentifierInterface.$toJson(_object);
    }

    if ($DefaultPartial.is$DefaultPartial(_object)) {
      return _object.$toJson();
    }

    if ($NamedDefaultPartial.is$NamedDefaultPartial(_object)) {
      return _object.$toJson();
    }

    throw new Error("unrecognized type");
  }

  export function $toRdf(
    _object: $Object,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.Resource {
    if (BlankNodeIdentifierClass.isBlankNodeIdentifierClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (BlankNodeIdentifierInterface.isBlankNodeIdentifierInterface(_object)) {
      return BlankNodeIdentifierInterface.$toRdf(_object, _parameters);
    }

    if (
      BlankNodeOrIriIdentifierClass.isBlankNodeOrIriIdentifierClass(_object)
    ) {
      return _object.$toRdf(_parameters);
    }

    if (
      BlankNodeOrIriIdentifierInterface.isBlankNodeOrIriIdentifierInterface(
        _object,
      )
    ) {
      return BlankNodeOrIriIdentifierInterface.$toRdf(_object, _parameters);
    }

    if (ClassUnionMember1.isClassUnionMember1(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (ClassUnionMember2.isClassUnionMember2(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (ConcreteChildClass.isConcreteChildClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (ConcreteParentClassStatic.isConcreteParentClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (ConcreteChildInterface.isConcreteChildInterface(_object)) {
      return ConcreteChildInterface.$toRdf(_object, _parameters);
    }

    if (ConcreteParentInterfaceStatic.isConcreteParentInterface(_object)) {
      return ConcreteParentInterfaceStatic.$toRdf(_object, _parameters);
    }

    if (
      BaseInterfaceWithoutPropertiesStatic.isBaseInterfaceWithoutProperties(
        _object,
      )
    ) {
      return BaseInterfaceWithoutPropertiesStatic.$toRdf(_object, _parameters);
    }

    if (
      BaseInterfaceWithPropertiesStatic.isBaseInterfaceWithProperties(_object)
    ) {
      return BaseInterfaceWithPropertiesStatic.$toRdf(_object, _parameters);
    }

    if (
      ConvertibleTypePropertiesClass.isConvertibleTypePropertiesClass(_object)
    ) {
      return _object.$toRdf(_parameters);
    }

    if (DateUnionPropertiesClass.isDateUnionPropertiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (DefaultValuePropertiesClass.isDefaultValuePropertiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (DirectRecursiveClass.isDirectRecursiveClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (ExplicitFromToRdfTypesClass.isExplicitFromToRdfTypesClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (ExplicitRdfTypeClass.isExplicitRdfTypeClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (ExternClass.isExternClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (ExternClassPropertyClass.isExternClassPropertyClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (FlattenClassUnionMember3.isFlattenClassUnionMember3(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (HasValuePropertiesClass.isHasValuePropertiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (IdentifierOverride5Class.isIdentifierOverride5Class(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (IdentifierOverride4ClassStatic.isIdentifierOverride4Class(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (IdentifierOverride3ClassStatic.isIdentifierOverride3Class(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (InIdentifierClass.isInIdentifierClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (InPropertiesClass.isInPropertiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (IndirectRecursiveClass.isIndirectRecursiveClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (IndirectRecursiveHelperClass.isIndirectRecursiveHelperClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (Interface.isInterface(_object)) {
      return Interface.$toRdf(_object, _parameters);
    }

    if (InterfaceUnionMember1.isInterfaceUnionMember1(_object)) {
      return InterfaceUnionMember1.$toRdf(_object, _parameters);
    }

    if (InterfaceUnionMember2.isInterfaceUnionMember2(_object)) {
      return InterfaceUnionMember2.$toRdf(_object, _parameters);
    }

    if (IriIdentifierClass.isIriIdentifierClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (IriIdentifierInterface.isIriIdentifierInterface(_object)) {
      return IriIdentifierInterface.$toRdf(_object, _parameters);
    }

    if (
      JsPrimitiveUnionPropertyClass.isJsPrimitiveUnionPropertyClass(_object)
    ) {
      return _object.$toRdf(_parameters);
    }

    if (LanguageInPropertiesClass.isLanguageInPropertiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (
      LazilyResolvedBlankNodeOrIriIdentifierClass.isLazilyResolvedBlankNodeOrIriIdentifierClass(
        _object,
      )
    ) {
      return _object.$toRdf(_parameters);
    }

    if (
      LazilyResolvedBlankNodeOrIriIdentifierInterface.isLazilyResolvedBlankNodeOrIriIdentifierInterface(
        _object,
      )
    ) {
      return LazilyResolvedBlankNodeOrIriIdentifierInterface.$toRdf(
        _object,
        _parameters,
      );
    }

    if (
      LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(_object)
    ) {
      return _object.$toRdf(_parameters);
    }

    if (
      LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(_object)
    ) {
      return _object.$toRdf(_parameters);
    }

    if (
      LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
        _object,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember1.$toRdf(_object, _parameters);
    }

    if (
      LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
        _object,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember2.$toRdf(_object, _parameters);
    }

    if (
      LazilyResolvedIriIdentifierClass.isLazilyResolvedIriIdentifierClass(
        _object,
      )
    ) {
      return _object.$toRdf(_parameters);
    }

    if (
      LazilyResolvedIriIdentifierInterface.isLazilyResolvedIriIdentifierInterface(
        _object,
      )
    ) {
      return LazilyResolvedIriIdentifierInterface.$toRdf(_object, _parameters);
    }

    if (LazyPropertiesClass.isLazyPropertiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (PartialClass.isPartialClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (LazyPropertiesInterface.isLazyPropertiesInterface(_object)) {
      return LazyPropertiesInterface.$toRdf(_object, _parameters);
    }

    if (PartialInterface.isPartialInterface(_object)) {
      return PartialInterface.$toRdf(_object, _parameters);
    }

    if (ListPropertiesClass.isListPropertiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (MutablePropertiesClass.isMutablePropertiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (NonClass.isNonClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (OrderedPropertiesClass.isOrderedPropertiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (PartialClassUnionMember1.isPartialClassUnionMember1(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (PartialClassUnionMember2.isPartialClassUnionMember2(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(_object)) {
      return PartialInterfaceUnionMember1.$toRdf(_object, _parameters);
    }

    if (PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(_object)) {
      return PartialInterfaceUnionMember2.$toRdf(_object, _parameters);
    }

    if (PropertyCardinalitiesClass.isPropertyCardinalitiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (PropertyVisibilitiesClass.isPropertyVisibilitiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (RecursiveClassUnionMember1.isRecursiveClassUnionMember1(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (RecursiveClassUnionMember2.isRecursiveClassUnionMember2(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (Sha256IriIdentifierClass.isSha256IriIdentifierClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (TermPropertiesClass.isTermPropertiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (UnionDiscriminantsClass.isUnionDiscriminantsClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (UuidV4IriIdentifierClass.isUuidV4IriIdentifierClass(_object)) {
      return _object.$toRdf(_parameters);
    }

    if (UuidV4IriIdentifierInterface.isUuidV4IriIdentifierInterface(_object)) {
      return UuidV4IriIdentifierInterface.$toRdf(_object, _parameters);
    }

    if ($DefaultPartial.is$DefaultPartial(_object)) {
      return _object.$toRdf(_parameters);
    }

    if ($NamedDefaultPartial.is$NamedDefaultPartial(_object)) {
      return _object.$toRdf(_parameters);
    }

    throw new Error("unrecognized type");
  }
}
export interface $ObjectSet {
  baseInterfaceWithoutProperties(
    identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithoutProperties>>;
  baseInterfaceWithoutPropertiesIdentifiers(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithoutPropertiesStatic.$Identifier[]
    >
  >;
  baseInterfaceWithoutPropertieses(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithoutProperties[]>>;
  baseInterfaceWithoutPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  baseInterfaceWithProperties(
    identifier: BaseInterfaceWithPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithProperties>>;
  baseInterfaceWithPropertiesIdentifiers(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithPropertiesStatic.$Identifier[]
    >
  >;
  baseInterfaceWithPropertieses(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithProperties[]>>;
  baseInterfaceWithPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  blankNodeIdentifierClass(
    identifier: BlankNodeIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeIdentifierClass>>;
  blankNodeIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<BlankNodeIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeIdentifierClass.$Identifier[]>
  >;
  blankNodeIdentifierClasses(
    query?: $ObjectSet.Query<BlankNodeIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly BlankNodeIdentifierClass[]>>;
  blankNodeIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<BlankNodeIdentifierClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  blankNodeIdentifierInterface(
    identifier: BlankNodeIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeIdentifierInterface>>;
  blankNodeIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<BlankNodeIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeIdentifierInterface.$Identifier[]>
  >;
  blankNodeIdentifierInterfaces(
    query?: $ObjectSet.Query<BlankNodeIdentifierInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly BlankNodeIdentifierInterface[]>>;
  blankNodeIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<BlankNodeIdentifierInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  blankNodeOrIriIdentifierClass(
    identifier: BlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeOrIriIdentifierClass>>;
  blankNodeOrIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeOrIriIdentifierClass.$Identifier[]>
  >;
  blankNodeOrIriIdentifierClasses(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly BlankNodeOrIriIdentifierClass[]>>;
  blankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  blankNodeOrIriIdentifierInterface(
    identifier: BlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeOrIriIdentifierInterface>>;
  blankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly BlankNodeOrIriIdentifierInterface.$Identifier[]
    >
  >;
  blankNodeOrIriIdentifierInterfaces(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeOrIriIdentifierInterface[]>
  >;
  blankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  classUnionMember1(
    identifier: ClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember1>>;
  classUnionMember1Identifiers(
    query?: $ObjectSet.Query<ClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1.$Identifier[]>>;
  classUnionMember1s(
    query?: $ObjectSet.Query<ClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1[]>>;
  classUnionMember1sCount(
    query?: Pick<$ObjectSet.Query<ClassUnionMember1.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  classUnionMember2(
    identifier: ClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember2>>;
  classUnionMember2Identifiers(
    query?: $ObjectSet.Query<ClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2.$Identifier[]>>;
  classUnionMember2s(
    query?: $ObjectSet.Query<ClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2[]>>;
  classUnionMember2sCount(
    query?: Pick<$ObjectSet.Query<ClassUnionMember2.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  concreteChildClass(
    identifier: ConcreteChildClass.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildClass>>;
  concreteChildClassIdentifiers(
    query?: $ObjectSet.Query<ConcreteChildClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass.$Identifier[]>>;
  concreteChildClasses(
    query?: $ObjectSet.Query<ConcreteChildClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass[]>>;
  concreteChildClassesCount(
    query?: Pick<$ObjectSet.Query<ConcreteChildClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  concreteChildInterface(
    identifier: ConcreteChildInterface.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildInterface>>;
  concreteChildInterfaceIdentifiers(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ConcreteChildInterface.$Identifier[]>
  >;
  concreteChildInterfaces(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly ConcreteChildInterface[]>>;
  concreteChildInterfacesCount(
    query?: Pick<$ObjectSet.Query<ConcreteChildInterface.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  concreteParentClass(
    identifier: ConcreteParentClassStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentClass>>;
  concreteParentClassIdentifiers(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentClassStatic.$Identifier[]>
  >;
  concreteParentClasses(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly ConcreteParentClass[]>>;
  concreteParentClassesCount(
    query?: Pick<$ObjectSet.Query<ConcreteParentClassStatic.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  concreteParentInterface(
    identifier: ConcreteParentInterfaceStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentInterface>>;
  concreteParentInterfaceIdentifiers(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentInterfaceStatic.$Identifier[]>
  >;
  concreteParentInterfaces(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly ConcreteParentInterface[]>>;
  concreteParentInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<ConcreteParentInterfaceStatic.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  convertibleTypePropertiesClass(
    identifier: ConvertibleTypePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ConvertibleTypePropertiesClass>>;
  convertibleTypePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ConvertibleTypePropertiesClass.$Identifier[]>
  >;
  convertibleTypePropertiesClasses(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ConvertibleTypePropertiesClass[]>>;
  convertibleTypePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<ConvertibleTypePropertiesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  dateUnionPropertiesClass(
    identifier: DateUnionPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, DateUnionPropertiesClass>>;
  dateUnionPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<DateUnionPropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly DateUnionPropertiesClass.$Identifier[]>
  >;
  dateUnionPropertiesClasses(
    query?: $ObjectSet.Query<DateUnionPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly DateUnionPropertiesClass[]>>;
  dateUnionPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<DateUnionPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  defaultValuePropertiesClass(
    identifier: DefaultValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, DefaultValuePropertiesClass>>;
  defaultValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly DefaultValuePropertiesClass.$Identifier[]>
  >;
  defaultValuePropertiesClasses(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly DefaultValuePropertiesClass[]>>;
  defaultValuePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<DefaultValuePropertiesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  directRecursiveClass(
    identifier: DirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, DirectRecursiveClass>>;
  directRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Filter>,
  ): Promise<purify.Either<Error, readonly DirectRecursiveClass.$Identifier[]>>;
  directRecursiveClasses(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Filter>,
  ): Promise<purify.Either<Error, readonly DirectRecursiveClass[]>>;
  directRecursiveClassesCount(
    query?: Pick<$ObjectSet.Query<DirectRecursiveClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  explicitFromToRdfTypesClass(
    identifier: ExplicitFromToRdfTypesClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitFromToRdfTypesClass>>;
  explicitFromToRdfTypesClassIdentifiers(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ExplicitFromToRdfTypesClass.$Identifier[]>
  >;
  explicitFromToRdfTypesClasses(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ExplicitFromToRdfTypesClass[]>>;
  explicitFromToRdfTypesClassesCount(
    query?: Pick<
      $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  explicitRdfTypeClass(
    identifier: ExplicitRdfTypeClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitRdfTypeClass>>;
  explicitRdfTypeClassIdentifiers(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ExplicitRdfTypeClass.$Identifier[]>>;
  explicitRdfTypeClasses(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ExplicitRdfTypeClass[]>>;
  explicitRdfTypeClassesCount(
    query?: Pick<$ObjectSet.Query<ExplicitRdfTypeClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  externClassPropertyClass(
    identifier: ExternClassPropertyClass.$Identifier,
  ): Promise<purify.Either<Error, ExternClassPropertyClass>>;
  externClassPropertyClassIdentifiers(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ExternClassPropertyClass.$Identifier[]>
  >;
  externClassPropertyClasses(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ExternClassPropertyClass[]>>;
  externClassPropertyClassesCount(
    query?: Pick<$ObjectSet.Query<ExternClassPropertyClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  flattenClassUnionMember3(
    identifier: FlattenClassUnionMember3.$Identifier,
  ): Promise<purify.Either<Error, FlattenClassUnionMember3>>;
  flattenClassUnionMember3Identifiers(
    query?: $ObjectSet.Query<FlattenClassUnionMember3.$Filter>,
  ): Promise<
    purify.Either<Error, readonly FlattenClassUnionMember3.$Identifier[]>
  >;
  flattenClassUnionMember3s(
    query?: $ObjectSet.Query<FlattenClassUnionMember3.$Filter>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnionMember3[]>>;
  flattenClassUnionMember3sCount(
    query?: Pick<$ObjectSet.Query<FlattenClassUnionMember3.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  hasValuePropertiesClass(
    identifier: HasValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, HasValuePropertiesClass>>;
  hasValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly HasValuePropertiesClass.$Identifier[]>
  >;
  hasValuePropertiesClasses(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly HasValuePropertiesClass[]>>;
  hasValuePropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<HasValuePropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  identifierOverride3Class(
    identifier: IdentifierOverride3ClassStatic.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride3Class>>;
  identifierOverride3ClassIdentifiers(
    query?: $ObjectSet.Query<IdentifierOverride3ClassStatic.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride3ClassStatic.$Identifier[]>
  >;
  identifierOverride3Classes(
    query?: $ObjectSet.Query<IdentifierOverride3ClassStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride3Class[]>>;
  identifierOverride3ClassesCount(
    query?: Pick<
      $ObjectSet.Query<IdentifierOverride3ClassStatic.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  identifierOverride4Class(
    identifier: IdentifierOverride4ClassStatic.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride4Class>>;
  identifierOverride4ClassIdentifiers(
    query?: $ObjectSet.Query<IdentifierOverride4ClassStatic.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride4ClassStatic.$Identifier[]>
  >;
  identifierOverride4Classes(
    query?: $ObjectSet.Query<IdentifierOverride4ClassStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride4Class[]>>;
  identifierOverride4ClassesCount(
    query?: Pick<
      $ObjectSet.Query<IdentifierOverride4ClassStatic.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  identifierOverride5Class(
    identifier: IdentifierOverride5Class.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride5Class>>;
  identifierOverride5ClassIdentifiers(
    query?: $ObjectSet.Query<IdentifierOverride5Class.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride5Class.$Identifier[]>
  >;
  identifierOverride5Classes(
    query?: $ObjectSet.Query<IdentifierOverride5Class.$Filter>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride5Class[]>>;
  identifierOverride5ClassesCount(
    query?: Pick<$ObjectSet.Query<IdentifierOverride5Class.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  indirectRecursiveClass(
    identifier: IndirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveClass>>;
  indirectRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveClass.$Identifier[]>
  >;
  indirectRecursiveClasses(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Filter>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveClass[]>>;
  indirectRecursiveClassesCount(
    query?: Pick<$ObjectSet.Query<IndirectRecursiveClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  indirectRecursiveHelperClass(
    identifier: IndirectRecursiveHelperClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveHelperClass>>;
  indirectRecursiveHelperClassIdentifiers(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveHelperClass.$Identifier[]>
  >;
  indirectRecursiveHelperClasses(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Filter>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveHelperClass[]>>;
  indirectRecursiveHelperClassesCount(
    query?: Pick<
      $ObjectSet.Query<IndirectRecursiveHelperClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  inIdentifierClass(
    identifier: InIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, InIdentifierClass>>;
  inIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<InIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass.$Identifier[]>>;
  inIdentifierClasses(
    query?: $ObjectSet.Query<InIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass[]>>;
  inIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<InIdentifierClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  inPropertiesClass(
    identifier: InPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, InPropertiesClass>>;
  inPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<InPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass.$Identifier[]>>;
  inPropertiesClasses(
    query?: $ObjectSet.Query<InPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass[]>>;
  inPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<InPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  interface(
    identifier: Interface.$Identifier,
  ): Promise<purify.Either<Error, Interface>>;
  interfaceIdentifiers(
    query?: $ObjectSet.Query<Interface.$Filter>,
  ): Promise<purify.Either<Error, readonly Interface.$Identifier[]>>;
  interfaces(
    query?: $ObjectSet.Query<Interface.$Filter>,
  ): Promise<purify.Either<Error, readonly Interface[]>>;
  interfacesCount(
    query?: Pick<$ObjectSet.Query<Interface.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  interfaceUnionMember1(
    identifier: InterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember1>>;
  interfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember1.$Identifier[]>
  >;
  interfaceUnionMember1s(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember1[]>>;
  interfaceUnionMember1sCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember1.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  interfaceUnionMember2(
    identifier: InterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember2>>;
  interfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember2.$Identifier[]>
  >;
  interfaceUnionMember2s(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember2[]>>;
  interfaceUnionMember2sCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember2.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  iriIdentifierClass(
    identifier: IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, IriIdentifierClass>>;
  iriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<IriIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly IriIdentifierClass.$Identifier[]>>;
  iriIdentifierClasses(
    query?: $ObjectSet.Query<IriIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly IriIdentifierClass[]>>;
  iriIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<IriIdentifierClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  iriIdentifierInterface(
    identifier: IriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, IriIdentifierInterface>>;
  iriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<IriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IriIdentifierInterface.$Identifier[]>
  >;
  iriIdentifierInterfaces(
    query?: $ObjectSet.Query<IriIdentifierInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly IriIdentifierInterface[]>>;
  iriIdentifierInterfacesCount(
    query?: Pick<$ObjectSet.Query<IriIdentifierInterface.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  jsPrimitiveUnionPropertyClass(
    identifier: JsPrimitiveUnionPropertyClass.$Identifier,
  ): Promise<purify.Either<Error, JsPrimitiveUnionPropertyClass>>;
  jsPrimitiveUnionPropertyClassIdentifiers(
    query?: $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly JsPrimitiveUnionPropertyClass.$Identifier[]>
  >;
  jsPrimitiveUnionPropertyClasses(
    query?: $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Filter>,
  ): Promise<purify.Either<Error, readonly JsPrimitiveUnionPropertyClass[]>>;
  jsPrimitiveUnionPropertyClassesCount(
    query?: Pick<
      $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  languageInPropertiesClass(
    identifier: LanguageInPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LanguageInPropertiesClass>>;
  languageInPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LanguageInPropertiesClass.$Identifier[]>
  >;
  languageInPropertiesClasses(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly LanguageInPropertiesClass[]>>;
  languageInPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<LanguageInPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedBlankNodeOrIriIdentifierClass(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierClass>>;
  lazilyResolvedBlankNodeOrIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier[]
    >
  >;
  lazilyResolvedBlankNodeOrIriIdentifierClasses(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedBlankNodeOrIriIdentifierClass[]>
  >;
  lazilyResolvedBlankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedBlankNodeOrIriIdentifierInterface(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<
    purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierInterface>
  >;
  lazilyResolvedBlankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier[]
    >
  >;
  lazilyResolvedBlankNodeOrIriIdentifierInterfaces(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[]
    >
  >;
  lazilyResolvedBlankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedClassUnionMember1(
    identifier: LazilyResolvedClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember1>>;
  lazilyResolvedClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember1.$Identifier[]>
  >;
  lazilyResolvedClassUnionMember1s(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember1[]>>;
  lazilyResolvedClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedClassUnionMember2(
    identifier: LazilyResolvedClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember2>>;
  lazilyResolvedClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember2.$Identifier[]>
  >;
  lazilyResolvedClassUnionMember2s(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember2[]>>;
  lazilyResolvedClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedInterfaceUnionMember1(
    identifier: LazilyResolvedInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember1>>;
  lazilyResolvedInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember1.$Identifier[]
    >
  >;
  lazilyResolvedInterfaceUnionMember1s(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember1[]>
  >;
  lazilyResolvedInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedInterfaceUnionMember2(
    identifier: LazilyResolvedInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember2>>;
  lazilyResolvedInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember2.$Identifier[]
    >
  >;
  lazilyResolvedInterfaceUnionMember2s(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember2[]>
  >;
  lazilyResolvedInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedIriIdentifierClass(
    identifier: LazilyResolvedIriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriIdentifierClass>>;
  lazilyResolvedIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedIriIdentifierClass.$Identifier[]
    >
  >;
  lazilyResolvedIriIdentifierClasses(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedIriIdentifierClass[]>>;
  lazilyResolvedIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedIriIdentifierInterface(
    identifier: LazilyResolvedIriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriIdentifierInterface>>;
  lazilyResolvedIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedIriIdentifierInterface.$Identifier[]
    >
  >;
  lazilyResolvedIriIdentifierInterfaces(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriIdentifierInterface[]>
  >;
  lazilyResolvedIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazyPropertiesClass(
    identifier: LazyPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesClass>>;
  lazyPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass.$Identifier[]>>;
  lazyPropertiesClasses(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass[]>>;
  lazyPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<LazyPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  lazyPropertiesInterface(
    identifier: LazyPropertiesInterface.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesInterface>>;
  lazyPropertiesInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazyPropertiesInterface.$Identifier[]>
  >;
  lazyPropertiesInterfaces(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesInterface[]>>;
  lazyPropertiesInterfacesCount(
    query?: Pick<$ObjectSet.Query<LazyPropertiesInterface.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  listPropertiesClass(
    identifier: ListPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ListPropertiesClass>>;
  listPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<ListPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass.$Identifier[]>>;
  listPropertiesClasses(
    query?: $ObjectSet.Query<ListPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass[]>>;
  listPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<ListPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  mutablePropertiesClass(
    identifier: MutablePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, MutablePropertiesClass>>;
  mutablePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly MutablePropertiesClass.$Identifier[]>
  >;
  mutablePropertiesClasses(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly MutablePropertiesClass[]>>;
  mutablePropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<MutablePropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  nonClass(
    identifier: NonClass.$Identifier,
  ): Promise<purify.Either<Error, NonClass>>;
  nonClassIdentifiers(
    query?: $ObjectSet.Query<NonClass.$Filter>,
  ): Promise<purify.Either<Error, readonly NonClass.$Identifier[]>>;
  nonClasses(
    query?: $ObjectSet.Query<NonClass.$Filter>,
  ): Promise<purify.Either<Error, readonly NonClass[]>>;
  nonClassesCount(
    query?: Pick<$ObjectSet.Query<NonClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  noRdfTypeClassUnionMember1(
    identifier: NoRdfTypeClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnionMember1>>;
  noRdfTypeClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly NoRdfTypeClassUnionMember1.$Identifier[]>
  >;
  noRdfTypeClassUnionMember1s(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnionMember1[]>>;
  noRdfTypeClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  noRdfTypeClassUnionMember2(
    identifier: NoRdfTypeClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnionMember2>>;
  noRdfTypeClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly NoRdfTypeClassUnionMember2.$Identifier[]>
  >;
  noRdfTypeClassUnionMember2s(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnionMember2[]>>;
  noRdfTypeClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  orderedPropertiesClass(
    identifier: OrderedPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, OrderedPropertiesClass>>;
  orderedPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly OrderedPropertiesClass.$Identifier[]>
  >;
  orderedPropertiesClasses(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly OrderedPropertiesClass[]>>;
  orderedPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<OrderedPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  partialClass(
    identifier: PartialClass.$Identifier,
  ): Promise<purify.Either<Error, PartialClass>>;
  partialClassIdentifiers(
    query?: $ObjectSet.Query<PartialClass.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClass.$Identifier[]>>;
  partialClasses(
    query?: $ObjectSet.Query<PartialClass.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClass[]>>;
  partialClassesCount(
    query?: Pick<$ObjectSet.Query<PartialClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  partialClassUnionMember1(
    identifier: PartialClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember1>>;
  partialClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember1.$Identifier[]>
  >;
  partialClassUnionMember1s(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember1[]>>;
  partialClassUnionMember1sCount(
    query?: Pick<$ObjectSet.Query<PartialClassUnionMember1.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  partialClassUnionMember2(
    identifier: PartialClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember2>>;
  partialClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember2.$Identifier[]>
  >;
  partialClassUnionMember2s(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember2[]>>;
  partialClassUnionMember2sCount(
    query?: Pick<$ObjectSet.Query<PartialClassUnionMember2.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  partialInterface(
    identifier: PartialInterface.$Identifier,
  ): Promise<purify.Either<Error, PartialInterface>>;
  partialInterfaceIdentifiers(
    query?: $ObjectSet.Query<PartialInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialInterface.$Identifier[]>>;
  partialInterfaces(
    query?: $ObjectSet.Query<PartialInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialInterface[]>>;
  partialInterfacesCount(
    query?: Pick<$ObjectSet.Query<PartialInterface.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  partialInterfaceUnionMember1(
    identifier: PartialInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember1>>;
  partialInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember1.$Identifier[]>
  >;
  partialInterfaceUnionMember1s(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember1[]>>;
  partialInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  partialInterfaceUnionMember2(
    identifier: PartialInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember2>>;
  partialInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember2.$Identifier[]>
  >;
  partialInterfaceUnionMember2s(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember2[]>>;
  partialInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  propertyCardinalitiesClass(
    identifier: PropertyCardinalitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyCardinalitiesClass>>;
  propertyCardinalitiesClassIdentifiers(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PropertyCardinalitiesClass.$Identifier[]>
  >;
  propertyCardinalitiesClasses(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly PropertyCardinalitiesClass[]>>;
  propertyCardinalitiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<PropertyCardinalitiesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  propertyVisibilitiesClass(
    identifier: PropertyVisibilitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyVisibilitiesClass>>;
  propertyVisibilitiesClassIdentifiers(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PropertyVisibilitiesClass.$Identifier[]>
  >;
  propertyVisibilitiesClasses(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly PropertyVisibilitiesClass[]>>;
  propertyVisibilitiesClassesCount(
    query?: Pick<$ObjectSet.Query<PropertyVisibilitiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  recursiveClassUnionMember1(
    identifier: RecursiveClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember1>>;
  recursiveClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember1.$Identifier[]>
  >;
  recursiveClassUnionMember1s(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember1[]>>;
  recursiveClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  recursiveClassUnionMember2(
    identifier: RecursiveClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember2>>;
  recursiveClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember2.$Identifier[]>
  >;
  recursiveClassUnionMember2s(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember2[]>>;
  recursiveClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  sha256IriIdentifierClass(
    identifier: Sha256IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, Sha256IriIdentifierClass>>;
  sha256IriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<Sha256IriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly Sha256IriIdentifierClass.$Identifier[]>
  >;
  sha256IriIdentifierClasses(
    query?: $ObjectSet.Query<Sha256IriIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly Sha256IriIdentifierClass[]>>;
  sha256IriIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<Sha256IriIdentifierClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  termPropertiesClass(
    identifier: TermPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, TermPropertiesClass>>;
  termPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<TermPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass.$Identifier[]>>;
  termPropertiesClasses(
    query?: $ObjectSet.Query<TermPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass[]>>;
  termPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<TermPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  unionDiscriminantsClass(
    identifier: UnionDiscriminantsClass.$Identifier,
  ): Promise<purify.Either<Error, UnionDiscriminantsClass>>;
  unionDiscriminantsClassIdentifiers(
    query?: $ObjectSet.Query<UnionDiscriminantsClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly UnionDiscriminantsClass.$Identifier[]>
  >;
  unionDiscriminantsClasses(
    query?: $ObjectSet.Query<UnionDiscriminantsClass.$Filter>,
  ): Promise<purify.Either<Error, readonly UnionDiscriminantsClass[]>>;
  unionDiscriminantsClassesCount(
    query?: Pick<$ObjectSet.Query<UnionDiscriminantsClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  uuidV4IriIdentifierClass(
    identifier: UuidV4IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriIdentifierClass>>;
  uuidV4IriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<UuidV4IriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly UuidV4IriIdentifierClass.$Identifier[]>
  >;
  uuidV4IriIdentifierClasses(
    query?: $ObjectSet.Query<UuidV4IriIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly UuidV4IriIdentifierClass[]>>;
  uuidV4IriIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<UuidV4IriIdentifierClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  uuidV4IriIdentifierInterface(
    identifier: UuidV4IriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriIdentifierInterface>>;
  uuidV4IriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<UuidV4IriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly UuidV4IriIdentifierInterface.$Identifier[]>
  >;
  uuidV4IriIdentifierInterfaces(
    query?: $ObjectSet.Query<UuidV4IriIdentifierInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly UuidV4IriIdentifierInterface[]>>;
  uuidV4IriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<UuidV4IriIdentifierInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  classUnion(
    identifier: ClassUnion.$Identifier,
  ): Promise<purify.Either<Error, ClassUnion>>;
  classUnionIdentifiers(
    query?: $ObjectSet.Query<ClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnion.$Identifier[]>>;
  classUnions(
    query?: $ObjectSet.Query<ClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnion[]>>;
  classUnionsCount(
    query?: Pick<$ObjectSet.Query<ClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  flattenClassUnion(
    identifier: FlattenClassUnion.$Identifier,
  ): Promise<purify.Either<Error, FlattenClassUnion>>;
  flattenClassUnionIdentifiers(
    query?: $ObjectSet.Query<FlattenClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnion.$Identifier[]>>;
  flattenClassUnions(
    query?: $ObjectSet.Query<FlattenClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnion[]>>;
  flattenClassUnionsCount(
    query?: Pick<$ObjectSet.Query<FlattenClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  interfaceUnion(
    identifier: InterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnion>>;
  interfaceUnionIdentifiers(
    query?: $ObjectSet.Query<InterfaceUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion.$Identifier[]>>;
  interfaceUnions(
    query?: $ObjectSet.Query<InterfaceUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion[]>>;
  interfaceUnionsCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedClassUnion(
    identifier: LazilyResolvedClassUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnion>>;
  lazilyResolvedClassUnionIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnion.$Identifier[]>
  >;
  lazilyResolvedClassUnions(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnion[]>>;
  lazilyResolvedClassUnionsCount(
    query?: Pick<$ObjectSet.Query<LazilyResolvedClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedInterfaceUnion(
    identifier: LazilyResolvedInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnion>>;
  lazilyResolvedInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnion.$Identifier[]>
  >;
  lazilyResolvedInterfaceUnions(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedInterfaceUnion[]>>;
  lazilyResolvedInterfaceUnionsCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>>;
  noRdfTypeClassUnion(
    identifier: NoRdfTypeClassUnion.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnion>>;
  noRdfTypeClassUnionIdentifiers(
    query?: $ObjectSet.Query<NoRdfTypeClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnion.$Identifier[]>>;
  noRdfTypeClassUnions(
    query?: $ObjectSet.Query<NoRdfTypeClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnion[]>>;
  noRdfTypeClassUnionsCount(
    query?: Pick<$ObjectSet.Query<NoRdfTypeClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  partialClassUnion(
    identifier: PartialClassUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnion>>;
  partialClassUnionIdentifiers(
    query?: $ObjectSet.Query<PartialClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion.$Identifier[]>>;
  partialClassUnions(
    query?: $ObjectSet.Query<PartialClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion[]>>;
  partialClassUnionsCount(
    query?: Pick<$ObjectSet.Query<PartialClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  partialInterfaceUnion(
    identifier: PartialInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnion>>;
  partialInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnion.$Identifier[]>
  >;
  partialInterfaceUnions(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnion[]>>;
  partialInterfaceUnionsCount(
    query?: Pick<$ObjectSet.Query<PartialInterfaceUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  recursiveClassUnion(
    identifier: RecursiveClassUnion.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnion>>;
  recursiveClassUnionIdentifiers(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion.$Identifier[]>>;
  recursiveClassUnions(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion[]>>;
  recursiveClassUnionsCount(
    query?: Pick<$ObjectSet.Query<RecursiveClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
  object(
    identifier: $Object.$Identifier,
  ): Promise<purify.Either<Error, $Object>>;
  objectIdentifiers(
    query?: $ObjectSet.Query<$Object.$Filter>,
  ): Promise<purify.Either<Error, readonly $Object.$Identifier[]>>;
  objects(
    query?: $ObjectSet.Query<$Object.$Filter>,
  ): Promise<purify.Either<Error, readonly $Object[]>>;
  objectsCount(
    query?: Pick<$ObjectSet.Query<$Object.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>>;
}

export namespace $ObjectSet {
  export type Query<
    ObjectFilterT extends {
      readonly $identifier?: {
        readonly in?: readonly (rdfjs.BlankNode | rdfjs.NamedNode)[];
      };
    },
  > = {
    readonly filter?: ObjectFilterT;
    readonly limit?: number;
    readonly offset?: number;
  };
}

export abstract class $ForwardingObjectSet implements $ObjectSet {
  protected abstract get $delegate(): $ObjectSet;

  baseInterfaceWithoutProperties(
    identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithoutProperties>> {
    return this.$delegate.baseInterfaceWithoutProperties(identifier);
  }

  baseInterfaceWithoutPropertiesIdentifiers(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithoutPropertiesStatic.$Identifier[]
    >
  > {
    return this.$delegate.baseInterfaceWithoutPropertiesIdentifiers(query);
  }

  baseInterfaceWithoutPropertieses(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithoutProperties[]>> {
    return this.$delegate.baseInterfaceWithoutPropertieses(query);
  }

  baseInterfaceWithoutPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.baseInterfaceWithoutPropertiesesCount(query);
  }

  baseInterfaceWithProperties(
    identifier: BaseInterfaceWithPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithProperties>> {
    return this.$delegate.baseInterfaceWithProperties(identifier);
  }

  baseInterfaceWithPropertiesIdentifiers(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithPropertiesStatic.$Identifier[]
    >
  > {
    return this.$delegate.baseInterfaceWithPropertiesIdentifiers(query);
  }

  baseInterfaceWithPropertieses(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithProperties[]>> {
    return this.$delegate.baseInterfaceWithPropertieses(query);
  }

  baseInterfaceWithPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.baseInterfaceWithPropertiesesCount(query);
  }

  blankNodeIdentifierClass(
    identifier: BlankNodeIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeIdentifierClass>> {
    return this.$delegate.blankNodeIdentifierClass(identifier);
  }

  blankNodeIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<BlankNodeIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeIdentifierClass.$Identifier[]>
  > {
    return this.$delegate.blankNodeIdentifierClassIdentifiers(query);
  }

  blankNodeIdentifierClasses(
    query?: $ObjectSet.Query<BlankNodeIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly BlankNodeIdentifierClass[]>> {
    return this.$delegate.blankNodeIdentifierClasses(query);
  }

  blankNodeIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<BlankNodeIdentifierClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.blankNodeIdentifierClassesCount(query);
  }

  blankNodeIdentifierInterface(
    identifier: BlankNodeIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeIdentifierInterface>> {
    return this.$delegate.blankNodeIdentifierInterface(identifier);
  }

  blankNodeIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<BlankNodeIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeIdentifierInterface.$Identifier[]>
  > {
    return this.$delegate.blankNodeIdentifierInterfaceIdentifiers(query);
  }

  blankNodeIdentifierInterfaces(
    query?: $ObjectSet.Query<BlankNodeIdentifierInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly BlankNodeIdentifierInterface[]>> {
    return this.$delegate.blankNodeIdentifierInterfaces(query);
  }

  blankNodeIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<BlankNodeIdentifierInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.blankNodeIdentifierInterfacesCount(query);
  }

  blankNodeOrIriIdentifierClass(
    identifier: BlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeOrIriIdentifierClass>> {
    return this.$delegate.blankNodeOrIriIdentifierClass(identifier);
  }

  blankNodeOrIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeOrIriIdentifierClass.$Identifier[]>
  > {
    return this.$delegate.blankNodeOrIriIdentifierClassIdentifiers(query);
  }

  blankNodeOrIriIdentifierClasses(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly BlankNodeOrIriIdentifierClass[]>> {
    return this.$delegate.blankNodeOrIriIdentifierClasses(query);
  }

  blankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.blankNodeOrIriIdentifierClassesCount(query);
  }

  blankNodeOrIriIdentifierInterface(
    identifier: BlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeOrIriIdentifierInterface>> {
    return this.$delegate.blankNodeOrIriIdentifierInterface(identifier);
  }

  blankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly BlankNodeOrIriIdentifierInterface.$Identifier[]
    >
  > {
    return this.$delegate.blankNodeOrIriIdentifierInterfaceIdentifiers(query);
  }

  blankNodeOrIriIdentifierInterfaces(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeOrIriIdentifierInterface[]>
  > {
    return this.$delegate.blankNodeOrIriIdentifierInterfaces(query);
  }

  blankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.blankNodeOrIriIdentifierInterfacesCount(query);
  }

  classUnionMember1(
    identifier: ClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember1>> {
    return this.$delegate.classUnionMember1(identifier);
  }

  classUnionMember1Identifiers(
    query?: $ObjectSet.Query<ClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1.$Identifier[]>> {
    return this.$delegate.classUnionMember1Identifiers(query);
  }

  classUnionMember1s(
    query?: $ObjectSet.Query<ClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1[]>> {
    return this.$delegate.classUnionMember1s(query);
  }

  classUnionMember1sCount(
    query?: Pick<$ObjectSet.Query<ClassUnionMember1.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.classUnionMember1sCount(query);
  }

  classUnionMember2(
    identifier: ClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember2>> {
    return this.$delegate.classUnionMember2(identifier);
  }

  classUnionMember2Identifiers(
    query?: $ObjectSet.Query<ClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2.$Identifier[]>> {
    return this.$delegate.classUnionMember2Identifiers(query);
  }

  classUnionMember2s(
    query?: $ObjectSet.Query<ClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2[]>> {
    return this.$delegate.classUnionMember2s(query);
  }

  classUnionMember2sCount(
    query?: Pick<$ObjectSet.Query<ClassUnionMember2.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.classUnionMember2sCount(query);
  }

  concreteChildClass(
    identifier: ConcreteChildClass.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildClass>> {
    return this.$delegate.concreteChildClass(identifier);
  }

  concreteChildClassIdentifiers(
    query?: $ObjectSet.Query<ConcreteChildClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass.$Identifier[]>> {
    return this.$delegate.concreteChildClassIdentifiers(query);
  }

  concreteChildClasses(
    query?: $ObjectSet.Query<ConcreteChildClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass[]>> {
    return this.$delegate.concreteChildClasses(query);
  }

  concreteChildClassesCount(
    query?: Pick<$ObjectSet.Query<ConcreteChildClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.concreteChildClassesCount(query);
  }

  concreteChildInterface(
    identifier: ConcreteChildInterface.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildInterface>> {
    return this.$delegate.concreteChildInterface(identifier);
  }

  concreteChildInterfaceIdentifiers(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ConcreteChildInterface.$Identifier[]>
  > {
    return this.$delegate.concreteChildInterfaceIdentifiers(query);
  }

  concreteChildInterfaces(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly ConcreteChildInterface[]>> {
    return this.$delegate.concreteChildInterfaces(query);
  }

  concreteChildInterfacesCount(
    query?: Pick<$ObjectSet.Query<ConcreteChildInterface.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.concreteChildInterfacesCount(query);
  }

  concreteParentClass(
    identifier: ConcreteParentClassStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentClass>> {
    return this.$delegate.concreteParentClass(identifier);
  }

  concreteParentClassIdentifiers(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentClassStatic.$Identifier[]>
  > {
    return this.$delegate.concreteParentClassIdentifiers(query);
  }

  concreteParentClasses(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly ConcreteParentClass[]>> {
    return this.$delegate.concreteParentClasses(query);
  }

  concreteParentClassesCount(
    query?: Pick<$ObjectSet.Query<ConcreteParentClassStatic.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.concreteParentClassesCount(query);
  }

  concreteParentInterface(
    identifier: ConcreteParentInterfaceStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentInterface>> {
    return this.$delegate.concreteParentInterface(identifier);
  }

  concreteParentInterfaceIdentifiers(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentInterfaceStatic.$Identifier[]>
  > {
    return this.$delegate.concreteParentInterfaceIdentifiers(query);
  }

  concreteParentInterfaces(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly ConcreteParentInterface[]>> {
    return this.$delegate.concreteParentInterfaces(query);
  }

  concreteParentInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<ConcreteParentInterfaceStatic.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.concreteParentInterfacesCount(query);
  }

  convertibleTypePropertiesClass(
    identifier: ConvertibleTypePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ConvertibleTypePropertiesClass>> {
    return this.$delegate.convertibleTypePropertiesClass(identifier);
  }

  convertibleTypePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ConvertibleTypePropertiesClass.$Identifier[]>
  > {
    return this.$delegate.convertibleTypePropertiesClassIdentifiers(query);
  }

  convertibleTypePropertiesClasses(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ConvertibleTypePropertiesClass[]>> {
    return this.$delegate.convertibleTypePropertiesClasses(query);
  }

  convertibleTypePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<ConvertibleTypePropertiesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.convertibleTypePropertiesClassesCount(query);
  }

  dateUnionPropertiesClass(
    identifier: DateUnionPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, DateUnionPropertiesClass>> {
    return this.$delegate.dateUnionPropertiesClass(identifier);
  }

  dateUnionPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<DateUnionPropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly DateUnionPropertiesClass.$Identifier[]>
  > {
    return this.$delegate.dateUnionPropertiesClassIdentifiers(query);
  }

  dateUnionPropertiesClasses(
    query?: $ObjectSet.Query<DateUnionPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly DateUnionPropertiesClass[]>> {
    return this.$delegate.dateUnionPropertiesClasses(query);
  }

  dateUnionPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<DateUnionPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.dateUnionPropertiesClassesCount(query);
  }

  defaultValuePropertiesClass(
    identifier: DefaultValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, DefaultValuePropertiesClass>> {
    return this.$delegate.defaultValuePropertiesClass(identifier);
  }

  defaultValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly DefaultValuePropertiesClass.$Identifier[]>
  > {
    return this.$delegate.defaultValuePropertiesClassIdentifiers(query);
  }

  defaultValuePropertiesClasses(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly DefaultValuePropertiesClass[]>> {
    return this.$delegate.defaultValuePropertiesClasses(query);
  }

  defaultValuePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<DefaultValuePropertiesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.defaultValuePropertiesClassesCount(query);
  }

  directRecursiveClass(
    identifier: DirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, DirectRecursiveClass>> {
    return this.$delegate.directRecursiveClass(identifier);
  }

  directRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly DirectRecursiveClass.$Identifier[]>
  > {
    return this.$delegate.directRecursiveClassIdentifiers(query);
  }

  directRecursiveClasses(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Filter>,
  ): Promise<purify.Either<Error, readonly DirectRecursiveClass[]>> {
    return this.$delegate.directRecursiveClasses(query);
  }

  directRecursiveClassesCount(
    query?: Pick<$ObjectSet.Query<DirectRecursiveClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.directRecursiveClassesCount(query);
  }

  explicitFromToRdfTypesClass(
    identifier: ExplicitFromToRdfTypesClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitFromToRdfTypesClass>> {
    return this.$delegate.explicitFromToRdfTypesClass(identifier);
  }

  explicitFromToRdfTypesClassIdentifiers(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ExplicitFromToRdfTypesClass.$Identifier[]>
  > {
    return this.$delegate.explicitFromToRdfTypesClassIdentifiers(query);
  }

  explicitFromToRdfTypesClasses(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ExplicitFromToRdfTypesClass[]>> {
    return this.$delegate.explicitFromToRdfTypesClasses(query);
  }

  explicitFromToRdfTypesClassesCount(
    query?: Pick<
      $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.explicitFromToRdfTypesClassesCount(query);
  }

  explicitRdfTypeClass(
    identifier: ExplicitRdfTypeClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitRdfTypeClass>> {
    return this.$delegate.explicitRdfTypeClass(identifier);
  }

  explicitRdfTypeClassIdentifiers(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ExplicitRdfTypeClass.$Identifier[]>
  > {
    return this.$delegate.explicitRdfTypeClassIdentifiers(query);
  }

  explicitRdfTypeClasses(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ExplicitRdfTypeClass[]>> {
    return this.$delegate.explicitRdfTypeClasses(query);
  }

  explicitRdfTypeClassesCount(
    query?: Pick<$ObjectSet.Query<ExplicitRdfTypeClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.explicitRdfTypeClassesCount(query);
  }

  externClassPropertyClass(
    identifier: ExternClassPropertyClass.$Identifier,
  ): Promise<purify.Either<Error, ExternClassPropertyClass>> {
    return this.$delegate.externClassPropertyClass(identifier);
  }

  externClassPropertyClassIdentifiers(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ExternClassPropertyClass.$Identifier[]>
  > {
    return this.$delegate.externClassPropertyClassIdentifiers(query);
  }

  externClassPropertyClasses(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ExternClassPropertyClass[]>> {
    return this.$delegate.externClassPropertyClasses(query);
  }

  externClassPropertyClassesCount(
    query?: Pick<$ObjectSet.Query<ExternClassPropertyClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.externClassPropertyClassesCount(query);
  }

  flattenClassUnionMember3(
    identifier: FlattenClassUnionMember3.$Identifier,
  ): Promise<purify.Either<Error, FlattenClassUnionMember3>> {
    return this.$delegate.flattenClassUnionMember3(identifier);
  }

  flattenClassUnionMember3Identifiers(
    query?: $ObjectSet.Query<FlattenClassUnionMember3.$Filter>,
  ): Promise<
    purify.Either<Error, readonly FlattenClassUnionMember3.$Identifier[]>
  > {
    return this.$delegate.flattenClassUnionMember3Identifiers(query);
  }

  flattenClassUnionMember3s(
    query?: $ObjectSet.Query<FlattenClassUnionMember3.$Filter>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnionMember3[]>> {
    return this.$delegate.flattenClassUnionMember3s(query);
  }

  flattenClassUnionMember3sCount(
    query?: Pick<$ObjectSet.Query<FlattenClassUnionMember3.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.flattenClassUnionMember3sCount(query);
  }

  hasValuePropertiesClass(
    identifier: HasValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, HasValuePropertiesClass>> {
    return this.$delegate.hasValuePropertiesClass(identifier);
  }

  hasValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly HasValuePropertiesClass.$Identifier[]>
  > {
    return this.$delegate.hasValuePropertiesClassIdentifiers(query);
  }

  hasValuePropertiesClasses(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly HasValuePropertiesClass[]>> {
    return this.$delegate.hasValuePropertiesClasses(query);
  }

  hasValuePropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<HasValuePropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.hasValuePropertiesClassesCount(query);
  }

  identifierOverride3Class(
    identifier: IdentifierOverride3ClassStatic.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride3Class>> {
    return this.$delegate.identifierOverride3Class(identifier);
  }

  identifierOverride3ClassIdentifiers(
    query?: $ObjectSet.Query<IdentifierOverride3ClassStatic.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride3ClassStatic.$Identifier[]>
  > {
    return this.$delegate.identifierOverride3ClassIdentifiers(query);
  }

  identifierOverride3Classes(
    query?: $ObjectSet.Query<IdentifierOverride3ClassStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride3Class[]>> {
    return this.$delegate.identifierOverride3Classes(query);
  }

  identifierOverride3ClassesCount(
    query?: Pick<
      $ObjectSet.Query<IdentifierOverride3ClassStatic.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.identifierOverride3ClassesCount(query);
  }

  identifierOverride4Class(
    identifier: IdentifierOverride4ClassStatic.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride4Class>> {
    return this.$delegate.identifierOverride4Class(identifier);
  }

  identifierOverride4ClassIdentifiers(
    query?: $ObjectSet.Query<IdentifierOverride4ClassStatic.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride4ClassStatic.$Identifier[]>
  > {
    return this.$delegate.identifierOverride4ClassIdentifiers(query);
  }

  identifierOverride4Classes(
    query?: $ObjectSet.Query<IdentifierOverride4ClassStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride4Class[]>> {
    return this.$delegate.identifierOverride4Classes(query);
  }

  identifierOverride4ClassesCount(
    query?: Pick<
      $ObjectSet.Query<IdentifierOverride4ClassStatic.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.identifierOverride4ClassesCount(query);
  }

  identifierOverride5Class(
    identifier: IdentifierOverride5Class.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride5Class>> {
    return this.$delegate.identifierOverride5Class(identifier);
  }

  identifierOverride5ClassIdentifiers(
    query?: $ObjectSet.Query<IdentifierOverride5Class.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride5Class.$Identifier[]>
  > {
    return this.$delegate.identifierOverride5ClassIdentifiers(query);
  }

  identifierOverride5Classes(
    query?: $ObjectSet.Query<IdentifierOverride5Class.$Filter>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride5Class[]>> {
    return this.$delegate.identifierOverride5Classes(query);
  }

  identifierOverride5ClassesCount(
    query?: Pick<$ObjectSet.Query<IdentifierOverride5Class.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.identifierOverride5ClassesCount(query);
  }

  indirectRecursiveClass(
    identifier: IndirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveClass>> {
    return this.$delegate.indirectRecursiveClass(identifier);
  }

  indirectRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveClass.$Identifier[]>
  > {
    return this.$delegate.indirectRecursiveClassIdentifiers(query);
  }

  indirectRecursiveClasses(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Filter>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveClass[]>> {
    return this.$delegate.indirectRecursiveClasses(query);
  }

  indirectRecursiveClassesCount(
    query?: Pick<$ObjectSet.Query<IndirectRecursiveClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.indirectRecursiveClassesCount(query);
  }

  indirectRecursiveHelperClass(
    identifier: IndirectRecursiveHelperClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveHelperClass>> {
    return this.$delegate.indirectRecursiveHelperClass(identifier);
  }

  indirectRecursiveHelperClassIdentifiers(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveHelperClass.$Identifier[]>
  > {
    return this.$delegate.indirectRecursiveHelperClassIdentifiers(query);
  }

  indirectRecursiveHelperClasses(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Filter>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveHelperClass[]>> {
    return this.$delegate.indirectRecursiveHelperClasses(query);
  }

  indirectRecursiveHelperClassesCount(
    query?: Pick<
      $ObjectSet.Query<IndirectRecursiveHelperClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.indirectRecursiveHelperClassesCount(query);
  }

  inIdentifierClass(
    identifier: InIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, InIdentifierClass>> {
    return this.$delegate.inIdentifierClass(identifier);
  }

  inIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<InIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass.$Identifier[]>> {
    return this.$delegate.inIdentifierClassIdentifiers(query);
  }

  inIdentifierClasses(
    query?: $ObjectSet.Query<InIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass[]>> {
    return this.$delegate.inIdentifierClasses(query);
  }

  inIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<InIdentifierClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.inIdentifierClassesCount(query);
  }

  inPropertiesClass(
    identifier: InPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, InPropertiesClass>> {
    return this.$delegate.inPropertiesClass(identifier);
  }

  inPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<InPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass.$Identifier[]>> {
    return this.$delegate.inPropertiesClassIdentifiers(query);
  }

  inPropertiesClasses(
    query?: $ObjectSet.Query<InPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass[]>> {
    return this.$delegate.inPropertiesClasses(query);
  }

  inPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<InPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.inPropertiesClassesCount(query);
  }

  interface(
    identifier: Interface.$Identifier,
  ): Promise<purify.Either<Error, Interface>> {
    return this.$delegate.interface(identifier);
  }

  interfaceIdentifiers(
    query?: $ObjectSet.Query<Interface.$Filter>,
  ): Promise<purify.Either<Error, readonly Interface.$Identifier[]>> {
    return this.$delegate.interfaceIdentifiers(query);
  }

  interfaces(
    query?: $ObjectSet.Query<Interface.$Filter>,
  ): Promise<purify.Either<Error, readonly Interface[]>> {
    return this.$delegate.interfaces(query);
  }

  interfacesCount(
    query?: Pick<$ObjectSet.Query<Interface.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.interfacesCount(query);
  }

  interfaceUnionMember1(
    identifier: InterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember1>> {
    return this.$delegate.interfaceUnionMember1(identifier);
  }

  interfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember1.$Identifier[]>
  > {
    return this.$delegate.interfaceUnionMember1Identifiers(query);
  }

  interfaceUnionMember1s(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember1[]>> {
    return this.$delegate.interfaceUnionMember1s(query);
  }

  interfaceUnionMember1sCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember1.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.interfaceUnionMember1sCount(query);
  }

  interfaceUnionMember2(
    identifier: InterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember2>> {
    return this.$delegate.interfaceUnionMember2(identifier);
  }

  interfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember2.$Identifier[]>
  > {
    return this.$delegate.interfaceUnionMember2Identifiers(query);
  }

  interfaceUnionMember2s(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember2[]>> {
    return this.$delegate.interfaceUnionMember2s(query);
  }

  interfaceUnionMember2sCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember2.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.interfaceUnionMember2sCount(query);
  }

  iriIdentifierClass(
    identifier: IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, IriIdentifierClass>> {
    return this.$delegate.iriIdentifierClass(identifier);
  }

  iriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<IriIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly IriIdentifierClass.$Identifier[]>> {
    return this.$delegate.iriIdentifierClassIdentifiers(query);
  }

  iriIdentifierClasses(
    query?: $ObjectSet.Query<IriIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly IriIdentifierClass[]>> {
    return this.$delegate.iriIdentifierClasses(query);
  }

  iriIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<IriIdentifierClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.iriIdentifierClassesCount(query);
  }

  iriIdentifierInterface(
    identifier: IriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, IriIdentifierInterface>> {
    return this.$delegate.iriIdentifierInterface(identifier);
  }

  iriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<IriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IriIdentifierInterface.$Identifier[]>
  > {
    return this.$delegate.iriIdentifierInterfaceIdentifiers(query);
  }

  iriIdentifierInterfaces(
    query?: $ObjectSet.Query<IriIdentifierInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly IriIdentifierInterface[]>> {
    return this.$delegate.iriIdentifierInterfaces(query);
  }

  iriIdentifierInterfacesCount(
    query?: Pick<$ObjectSet.Query<IriIdentifierInterface.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.iriIdentifierInterfacesCount(query);
  }

  jsPrimitiveUnionPropertyClass(
    identifier: JsPrimitiveUnionPropertyClass.$Identifier,
  ): Promise<purify.Either<Error, JsPrimitiveUnionPropertyClass>> {
    return this.$delegate.jsPrimitiveUnionPropertyClass(identifier);
  }

  jsPrimitiveUnionPropertyClassIdentifiers(
    query?: $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly JsPrimitiveUnionPropertyClass.$Identifier[]>
  > {
    return this.$delegate.jsPrimitiveUnionPropertyClassIdentifiers(query);
  }

  jsPrimitiveUnionPropertyClasses(
    query?: $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Filter>,
  ): Promise<purify.Either<Error, readonly JsPrimitiveUnionPropertyClass[]>> {
    return this.$delegate.jsPrimitiveUnionPropertyClasses(query);
  }

  jsPrimitiveUnionPropertyClassesCount(
    query?: Pick<
      $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.jsPrimitiveUnionPropertyClassesCount(query);
  }

  languageInPropertiesClass(
    identifier: LanguageInPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LanguageInPropertiesClass>> {
    return this.$delegate.languageInPropertiesClass(identifier);
  }

  languageInPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LanguageInPropertiesClass.$Identifier[]>
  > {
    return this.$delegate.languageInPropertiesClassIdentifiers(query);
  }

  languageInPropertiesClasses(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly LanguageInPropertiesClass[]>> {
    return this.$delegate.languageInPropertiesClasses(query);
  }

  languageInPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<LanguageInPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.languageInPropertiesClassesCount(query);
  }

  lazilyResolvedBlankNodeOrIriIdentifierClass(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<
    purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierClass>
  > {
    return this.$delegate.lazilyResolvedBlankNodeOrIriIdentifierClass(
      identifier,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier[]
    >
  > {
    return this.$delegate.lazilyResolvedBlankNodeOrIriIdentifierClassIdentifiers(
      query,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierClasses(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedBlankNodeOrIriIdentifierClass[]>
  > {
    return this.$delegate.lazilyResolvedBlankNodeOrIriIdentifierClasses(query);
  }

  lazilyResolvedBlankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedBlankNodeOrIriIdentifierClassesCount(
      query,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierInterface(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<
    purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierInterface>
  > {
    return this.$delegate.lazilyResolvedBlankNodeOrIriIdentifierInterface(
      identifier,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier[]
    >
  > {
    return this.$delegate.lazilyResolvedBlankNodeOrIriIdentifierInterfaceIdentifiers(
      query,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierInterfaces(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[]
    >
  > {
    return this.$delegate.lazilyResolvedBlankNodeOrIriIdentifierInterfaces(
      query,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedBlankNodeOrIriIdentifierInterfacesCount(
      query,
    );
  }

  lazilyResolvedClassUnionMember1(
    identifier: LazilyResolvedClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember1>> {
    return this.$delegate.lazilyResolvedClassUnionMember1(identifier);
  }

  lazilyResolvedClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember1.$Identifier[]>
  > {
    return this.$delegate.lazilyResolvedClassUnionMember1Identifiers(query);
  }

  lazilyResolvedClassUnionMember1s(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember1[]>> {
    return this.$delegate.lazilyResolvedClassUnionMember1s(query);
  }

  lazilyResolvedClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedClassUnionMember1sCount(query);
  }

  lazilyResolvedClassUnionMember2(
    identifier: LazilyResolvedClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember2>> {
    return this.$delegate.lazilyResolvedClassUnionMember2(identifier);
  }

  lazilyResolvedClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember2.$Identifier[]>
  > {
    return this.$delegate.lazilyResolvedClassUnionMember2Identifiers(query);
  }

  lazilyResolvedClassUnionMember2s(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember2[]>> {
    return this.$delegate.lazilyResolvedClassUnionMember2s(query);
  }

  lazilyResolvedClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedClassUnionMember2sCount(query);
  }

  lazilyResolvedInterfaceUnionMember1(
    identifier: LazilyResolvedInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember1>> {
    return this.$delegate.lazilyResolvedInterfaceUnionMember1(identifier);
  }

  lazilyResolvedInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember1.$Identifier[]
    >
  > {
    return this.$delegate.lazilyResolvedInterfaceUnionMember1Identifiers(query);
  }

  lazilyResolvedInterfaceUnionMember1s(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember1[]>
  > {
    return this.$delegate.lazilyResolvedInterfaceUnionMember1s(query);
  }

  lazilyResolvedInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedInterfaceUnionMember1sCount(query);
  }

  lazilyResolvedInterfaceUnionMember2(
    identifier: LazilyResolvedInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember2>> {
    return this.$delegate.lazilyResolvedInterfaceUnionMember2(identifier);
  }

  lazilyResolvedInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember2.$Identifier[]
    >
  > {
    return this.$delegate.lazilyResolvedInterfaceUnionMember2Identifiers(query);
  }

  lazilyResolvedInterfaceUnionMember2s(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember2[]>
  > {
    return this.$delegate.lazilyResolvedInterfaceUnionMember2s(query);
  }

  lazilyResolvedInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedInterfaceUnionMember2sCount(query);
  }

  lazilyResolvedIriIdentifierClass(
    identifier: LazilyResolvedIriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriIdentifierClass>> {
    return this.$delegate.lazilyResolvedIriIdentifierClass(identifier);
  }

  lazilyResolvedIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedIriIdentifierClass.$Identifier[]
    >
  > {
    return this.$delegate.lazilyResolvedIriIdentifierClassIdentifiers(query);
  }

  lazilyResolvedIriIdentifierClasses(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriIdentifierClass[]>
  > {
    return this.$delegate.lazilyResolvedIriIdentifierClasses(query);
  }

  lazilyResolvedIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedIriIdentifierClassesCount(query);
  }

  lazilyResolvedIriIdentifierInterface(
    identifier: LazilyResolvedIriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriIdentifierInterface>> {
    return this.$delegate.lazilyResolvedIriIdentifierInterface(identifier);
  }

  lazilyResolvedIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedIriIdentifierInterface.$Identifier[]
    >
  > {
    return this.$delegate.lazilyResolvedIriIdentifierInterfaceIdentifiers(
      query,
    );
  }

  lazilyResolvedIriIdentifierInterfaces(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriIdentifierInterface[]>
  > {
    return this.$delegate.lazilyResolvedIriIdentifierInterfaces(query);
  }

  lazilyResolvedIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedIriIdentifierInterfacesCount(query);
  }

  lazyPropertiesClass(
    identifier: LazyPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesClass>> {
    return this.$delegate.lazyPropertiesClass(identifier);
  }

  lazyPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass.$Identifier[]>> {
    return this.$delegate.lazyPropertiesClassIdentifiers(query);
  }

  lazyPropertiesClasses(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass[]>> {
    return this.$delegate.lazyPropertiesClasses(query);
  }

  lazyPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<LazyPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazyPropertiesClassesCount(query);
  }

  lazyPropertiesInterface(
    identifier: LazyPropertiesInterface.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesInterface>> {
    return this.$delegate.lazyPropertiesInterface(identifier);
  }

  lazyPropertiesInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazyPropertiesInterface.$Identifier[]>
  > {
    return this.$delegate.lazyPropertiesInterfaceIdentifiers(query);
  }

  lazyPropertiesInterfaces(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesInterface[]>> {
    return this.$delegate.lazyPropertiesInterfaces(query);
  }

  lazyPropertiesInterfacesCount(
    query?: Pick<$ObjectSet.Query<LazyPropertiesInterface.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazyPropertiesInterfacesCount(query);
  }

  listPropertiesClass(
    identifier: ListPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ListPropertiesClass>> {
    return this.$delegate.listPropertiesClass(identifier);
  }

  listPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<ListPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass.$Identifier[]>> {
    return this.$delegate.listPropertiesClassIdentifiers(query);
  }

  listPropertiesClasses(
    query?: $ObjectSet.Query<ListPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass[]>> {
    return this.$delegate.listPropertiesClasses(query);
  }

  listPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<ListPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.listPropertiesClassesCount(query);
  }

  mutablePropertiesClass(
    identifier: MutablePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, MutablePropertiesClass>> {
    return this.$delegate.mutablePropertiesClass(identifier);
  }

  mutablePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly MutablePropertiesClass.$Identifier[]>
  > {
    return this.$delegate.mutablePropertiesClassIdentifiers(query);
  }

  mutablePropertiesClasses(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly MutablePropertiesClass[]>> {
    return this.$delegate.mutablePropertiesClasses(query);
  }

  mutablePropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<MutablePropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.mutablePropertiesClassesCount(query);
  }

  nonClass(
    identifier: NonClass.$Identifier,
  ): Promise<purify.Either<Error, NonClass>> {
    return this.$delegate.nonClass(identifier);
  }

  nonClassIdentifiers(
    query?: $ObjectSet.Query<NonClass.$Filter>,
  ): Promise<purify.Either<Error, readonly NonClass.$Identifier[]>> {
    return this.$delegate.nonClassIdentifiers(query);
  }

  nonClasses(
    query?: $ObjectSet.Query<NonClass.$Filter>,
  ): Promise<purify.Either<Error, readonly NonClass[]>> {
    return this.$delegate.nonClasses(query);
  }

  nonClassesCount(
    query?: Pick<$ObjectSet.Query<NonClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.nonClassesCount(query);
  }

  noRdfTypeClassUnionMember1(
    identifier: NoRdfTypeClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnionMember1>> {
    return this.$delegate.noRdfTypeClassUnionMember1(identifier);
  }

  noRdfTypeClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly NoRdfTypeClassUnionMember1.$Identifier[]>
  > {
    return this.$delegate.noRdfTypeClassUnionMember1Identifiers(query);
  }

  noRdfTypeClassUnionMember1s(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnionMember1[]>> {
    return this.$delegate.noRdfTypeClassUnionMember1s(query);
  }

  noRdfTypeClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.noRdfTypeClassUnionMember1sCount(query);
  }

  noRdfTypeClassUnionMember2(
    identifier: NoRdfTypeClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnionMember2>> {
    return this.$delegate.noRdfTypeClassUnionMember2(identifier);
  }

  noRdfTypeClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly NoRdfTypeClassUnionMember2.$Identifier[]>
  > {
    return this.$delegate.noRdfTypeClassUnionMember2Identifiers(query);
  }

  noRdfTypeClassUnionMember2s(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnionMember2[]>> {
    return this.$delegate.noRdfTypeClassUnionMember2s(query);
  }

  noRdfTypeClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.noRdfTypeClassUnionMember2sCount(query);
  }

  orderedPropertiesClass(
    identifier: OrderedPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, OrderedPropertiesClass>> {
    return this.$delegate.orderedPropertiesClass(identifier);
  }

  orderedPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly OrderedPropertiesClass.$Identifier[]>
  > {
    return this.$delegate.orderedPropertiesClassIdentifiers(query);
  }

  orderedPropertiesClasses(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly OrderedPropertiesClass[]>> {
    return this.$delegate.orderedPropertiesClasses(query);
  }

  orderedPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<OrderedPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.orderedPropertiesClassesCount(query);
  }

  partialClass(
    identifier: PartialClass.$Identifier,
  ): Promise<purify.Either<Error, PartialClass>> {
    return this.$delegate.partialClass(identifier);
  }

  partialClassIdentifiers(
    query?: $ObjectSet.Query<PartialClass.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClass.$Identifier[]>> {
    return this.$delegate.partialClassIdentifiers(query);
  }

  partialClasses(
    query?: $ObjectSet.Query<PartialClass.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClass[]>> {
    return this.$delegate.partialClasses(query);
  }

  partialClassesCount(
    query?: Pick<$ObjectSet.Query<PartialClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialClassesCount(query);
  }

  partialClassUnionMember1(
    identifier: PartialClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember1>> {
    return this.$delegate.partialClassUnionMember1(identifier);
  }

  partialClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember1.$Identifier[]>
  > {
    return this.$delegate.partialClassUnionMember1Identifiers(query);
  }

  partialClassUnionMember1s(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember1[]>> {
    return this.$delegate.partialClassUnionMember1s(query);
  }

  partialClassUnionMember1sCount(
    query?: Pick<$ObjectSet.Query<PartialClassUnionMember1.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialClassUnionMember1sCount(query);
  }

  partialClassUnionMember2(
    identifier: PartialClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember2>> {
    return this.$delegate.partialClassUnionMember2(identifier);
  }

  partialClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember2.$Identifier[]>
  > {
    return this.$delegate.partialClassUnionMember2Identifiers(query);
  }

  partialClassUnionMember2s(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember2[]>> {
    return this.$delegate.partialClassUnionMember2s(query);
  }

  partialClassUnionMember2sCount(
    query?: Pick<$ObjectSet.Query<PartialClassUnionMember2.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialClassUnionMember2sCount(query);
  }

  partialInterface(
    identifier: PartialInterface.$Identifier,
  ): Promise<purify.Either<Error, PartialInterface>> {
    return this.$delegate.partialInterface(identifier);
  }

  partialInterfaceIdentifiers(
    query?: $ObjectSet.Query<PartialInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialInterface.$Identifier[]>> {
    return this.$delegate.partialInterfaceIdentifiers(query);
  }

  partialInterfaces(
    query?: $ObjectSet.Query<PartialInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialInterface[]>> {
    return this.$delegate.partialInterfaces(query);
  }

  partialInterfacesCount(
    query?: Pick<$ObjectSet.Query<PartialInterface.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialInterfacesCount(query);
  }

  partialInterfaceUnionMember1(
    identifier: PartialInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember1>> {
    return this.$delegate.partialInterfaceUnionMember1(identifier);
  }

  partialInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember1.$Identifier[]>
  > {
    return this.$delegate.partialInterfaceUnionMember1Identifiers(query);
  }

  partialInterfaceUnionMember1s(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember1[]>> {
    return this.$delegate.partialInterfaceUnionMember1s(query);
  }

  partialInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialInterfaceUnionMember1sCount(query);
  }

  partialInterfaceUnionMember2(
    identifier: PartialInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember2>> {
    return this.$delegate.partialInterfaceUnionMember2(identifier);
  }

  partialInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember2.$Identifier[]>
  > {
    return this.$delegate.partialInterfaceUnionMember2Identifiers(query);
  }

  partialInterfaceUnionMember2s(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember2[]>> {
    return this.$delegate.partialInterfaceUnionMember2s(query);
  }

  partialInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialInterfaceUnionMember2sCount(query);
  }

  propertyCardinalitiesClass(
    identifier: PropertyCardinalitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyCardinalitiesClass>> {
    return this.$delegate.propertyCardinalitiesClass(identifier);
  }

  propertyCardinalitiesClassIdentifiers(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PropertyCardinalitiesClass.$Identifier[]>
  > {
    return this.$delegate.propertyCardinalitiesClassIdentifiers(query);
  }

  propertyCardinalitiesClasses(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly PropertyCardinalitiesClass[]>> {
    return this.$delegate.propertyCardinalitiesClasses(query);
  }

  propertyCardinalitiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<PropertyCardinalitiesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.propertyCardinalitiesClassesCount(query);
  }

  propertyVisibilitiesClass(
    identifier: PropertyVisibilitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyVisibilitiesClass>> {
    return this.$delegate.propertyVisibilitiesClass(identifier);
  }

  propertyVisibilitiesClassIdentifiers(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PropertyVisibilitiesClass.$Identifier[]>
  > {
    return this.$delegate.propertyVisibilitiesClassIdentifiers(query);
  }

  propertyVisibilitiesClasses(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly PropertyVisibilitiesClass[]>> {
    return this.$delegate.propertyVisibilitiesClasses(query);
  }

  propertyVisibilitiesClassesCount(
    query?: Pick<$ObjectSet.Query<PropertyVisibilitiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.propertyVisibilitiesClassesCount(query);
  }

  recursiveClassUnionMember1(
    identifier: RecursiveClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember1>> {
    return this.$delegate.recursiveClassUnionMember1(identifier);
  }

  recursiveClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember1.$Identifier[]>
  > {
    return this.$delegate.recursiveClassUnionMember1Identifiers(query);
  }

  recursiveClassUnionMember1s(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember1[]>> {
    return this.$delegate.recursiveClassUnionMember1s(query);
  }

  recursiveClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.recursiveClassUnionMember1sCount(query);
  }

  recursiveClassUnionMember2(
    identifier: RecursiveClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember2>> {
    return this.$delegate.recursiveClassUnionMember2(identifier);
  }

  recursiveClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember2.$Identifier[]>
  > {
    return this.$delegate.recursiveClassUnionMember2Identifiers(query);
  }

  recursiveClassUnionMember2s(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember2[]>> {
    return this.$delegate.recursiveClassUnionMember2s(query);
  }

  recursiveClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.recursiveClassUnionMember2sCount(query);
  }

  sha256IriIdentifierClass(
    identifier: Sha256IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, Sha256IriIdentifierClass>> {
    return this.$delegate.sha256IriIdentifierClass(identifier);
  }

  sha256IriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<Sha256IriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly Sha256IriIdentifierClass.$Identifier[]>
  > {
    return this.$delegate.sha256IriIdentifierClassIdentifiers(query);
  }

  sha256IriIdentifierClasses(
    query?: $ObjectSet.Query<Sha256IriIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly Sha256IriIdentifierClass[]>> {
    return this.$delegate.sha256IriIdentifierClasses(query);
  }

  sha256IriIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<Sha256IriIdentifierClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.sha256IriIdentifierClassesCount(query);
  }

  termPropertiesClass(
    identifier: TermPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, TermPropertiesClass>> {
    return this.$delegate.termPropertiesClass(identifier);
  }

  termPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<TermPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass.$Identifier[]>> {
    return this.$delegate.termPropertiesClassIdentifiers(query);
  }

  termPropertiesClasses(
    query?: $ObjectSet.Query<TermPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass[]>> {
    return this.$delegate.termPropertiesClasses(query);
  }

  termPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<TermPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.termPropertiesClassesCount(query);
  }

  unionDiscriminantsClass(
    identifier: UnionDiscriminantsClass.$Identifier,
  ): Promise<purify.Either<Error, UnionDiscriminantsClass>> {
    return this.$delegate.unionDiscriminantsClass(identifier);
  }

  unionDiscriminantsClassIdentifiers(
    query?: $ObjectSet.Query<UnionDiscriminantsClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly UnionDiscriminantsClass.$Identifier[]>
  > {
    return this.$delegate.unionDiscriminantsClassIdentifiers(query);
  }

  unionDiscriminantsClasses(
    query?: $ObjectSet.Query<UnionDiscriminantsClass.$Filter>,
  ): Promise<purify.Either<Error, readonly UnionDiscriminantsClass[]>> {
    return this.$delegate.unionDiscriminantsClasses(query);
  }

  unionDiscriminantsClassesCount(
    query?: Pick<$ObjectSet.Query<UnionDiscriminantsClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.unionDiscriminantsClassesCount(query);
  }

  uuidV4IriIdentifierClass(
    identifier: UuidV4IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriIdentifierClass>> {
    return this.$delegate.uuidV4IriIdentifierClass(identifier);
  }

  uuidV4IriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<UuidV4IriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly UuidV4IriIdentifierClass.$Identifier[]>
  > {
    return this.$delegate.uuidV4IriIdentifierClassIdentifiers(query);
  }

  uuidV4IriIdentifierClasses(
    query?: $ObjectSet.Query<UuidV4IriIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly UuidV4IriIdentifierClass[]>> {
    return this.$delegate.uuidV4IriIdentifierClasses(query);
  }

  uuidV4IriIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<UuidV4IriIdentifierClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.uuidV4IriIdentifierClassesCount(query);
  }

  uuidV4IriIdentifierInterface(
    identifier: UuidV4IriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriIdentifierInterface>> {
    return this.$delegate.uuidV4IriIdentifierInterface(identifier);
  }

  uuidV4IriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<UuidV4IriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly UuidV4IriIdentifierInterface.$Identifier[]>
  > {
    return this.$delegate.uuidV4IriIdentifierInterfaceIdentifiers(query);
  }

  uuidV4IriIdentifierInterfaces(
    query?: $ObjectSet.Query<UuidV4IriIdentifierInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly UuidV4IriIdentifierInterface[]>> {
    return this.$delegate.uuidV4IriIdentifierInterfaces(query);
  }

  uuidV4IriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<UuidV4IriIdentifierInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.uuidV4IriIdentifierInterfacesCount(query);
  }

  classUnion(
    identifier: ClassUnion.$Identifier,
  ): Promise<purify.Either<Error, ClassUnion>> {
    return this.$delegate.classUnion(identifier);
  }

  classUnionIdentifiers(
    query?: $ObjectSet.Query<ClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnion.$Identifier[]>> {
    return this.$delegate.classUnionIdentifiers(query);
  }

  classUnions(
    query?: $ObjectSet.Query<ClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnion[]>> {
    return this.$delegate.classUnions(query);
  }

  classUnionsCount(
    query?: Pick<$ObjectSet.Query<ClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.classUnionsCount(query);
  }

  flattenClassUnion(
    identifier: FlattenClassUnion.$Identifier,
  ): Promise<purify.Either<Error, FlattenClassUnion>> {
    return this.$delegate.flattenClassUnion(identifier);
  }

  flattenClassUnionIdentifiers(
    query?: $ObjectSet.Query<FlattenClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnion.$Identifier[]>> {
    return this.$delegate.flattenClassUnionIdentifiers(query);
  }

  flattenClassUnions(
    query?: $ObjectSet.Query<FlattenClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnion[]>> {
    return this.$delegate.flattenClassUnions(query);
  }

  flattenClassUnionsCount(
    query?: Pick<$ObjectSet.Query<FlattenClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.flattenClassUnionsCount(query);
  }

  interfaceUnion(
    identifier: InterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnion>> {
    return this.$delegate.interfaceUnion(identifier);
  }

  interfaceUnionIdentifiers(
    query?: $ObjectSet.Query<InterfaceUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion.$Identifier[]>> {
    return this.$delegate.interfaceUnionIdentifiers(query);
  }

  interfaceUnions(
    query?: $ObjectSet.Query<InterfaceUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion[]>> {
    return this.$delegate.interfaceUnions(query);
  }

  interfaceUnionsCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.interfaceUnionsCount(query);
  }

  lazilyResolvedClassUnion(
    identifier: LazilyResolvedClassUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnion>> {
    return this.$delegate.lazilyResolvedClassUnion(identifier);
  }

  lazilyResolvedClassUnionIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnion.$Identifier[]>
  > {
    return this.$delegate.lazilyResolvedClassUnionIdentifiers(query);
  }

  lazilyResolvedClassUnions(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnion[]>> {
    return this.$delegate.lazilyResolvedClassUnions(query);
  }

  lazilyResolvedClassUnionsCount(
    query?: Pick<$ObjectSet.Query<LazilyResolvedClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedClassUnionsCount(query);
  }

  lazilyResolvedInterfaceUnion(
    identifier: LazilyResolvedInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnion>> {
    return this.$delegate.lazilyResolvedInterfaceUnion(identifier);
  }

  lazilyResolvedInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnion.$Identifier[]>
  > {
    return this.$delegate.lazilyResolvedInterfaceUnionIdentifiers(query);
  }

  lazilyResolvedInterfaceUnions(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedInterfaceUnion[]>> {
    return this.$delegate.lazilyResolvedInterfaceUnions(query);
  }

  lazilyResolvedInterfaceUnionsCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedInterfaceUnionsCount(query);
  }

  noRdfTypeClassUnion(
    identifier: NoRdfTypeClassUnion.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnion>> {
    return this.$delegate.noRdfTypeClassUnion(identifier);
  }

  noRdfTypeClassUnionIdentifiers(
    query?: $ObjectSet.Query<NoRdfTypeClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnion.$Identifier[]>> {
    return this.$delegate.noRdfTypeClassUnionIdentifiers(query);
  }

  noRdfTypeClassUnions(
    query?: $ObjectSet.Query<NoRdfTypeClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnion[]>> {
    return this.$delegate.noRdfTypeClassUnions(query);
  }

  noRdfTypeClassUnionsCount(
    query?: Pick<$ObjectSet.Query<NoRdfTypeClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.noRdfTypeClassUnionsCount(query);
  }

  partialClassUnion(
    identifier: PartialClassUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnion>> {
    return this.$delegate.partialClassUnion(identifier);
  }

  partialClassUnionIdentifiers(
    query?: $ObjectSet.Query<PartialClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion.$Identifier[]>> {
    return this.$delegate.partialClassUnionIdentifiers(query);
  }

  partialClassUnions(
    query?: $ObjectSet.Query<PartialClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion[]>> {
    return this.$delegate.partialClassUnions(query);
  }

  partialClassUnionsCount(
    query?: Pick<$ObjectSet.Query<PartialClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialClassUnionsCount(query);
  }

  partialInterfaceUnion(
    identifier: PartialInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnion>> {
    return this.$delegate.partialInterfaceUnion(identifier);
  }

  partialInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnion.$Identifier[]>
  > {
    return this.$delegate.partialInterfaceUnionIdentifiers(query);
  }

  partialInterfaceUnions(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnion[]>> {
    return this.$delegate.partialInterfaceUnions(query);
  }

  partialInterfaceUnionsCount(
    query?: Pick<$ObjectSet.Query<PartialInterfaceUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialInterfaceUnionsCount(query);
  }

  recursiveClassUnion(
    identifier: RecursiveClassUnion.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnion>> {
    return this.$delegate.recursiveClassUnion(identifier);
  }

  recursiveClassUnionIdentifiers(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion.$Identifier[]>> {
    return this.$delegate.recursiveClassUnionIdentifiers(query);
  }

  recursiveClassUnions(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion[]>> {
    return this.$delegate.recursiveClassUnions(query);
  }

  recursiveClassUnionsCount(
    query?: Pick<$ObjectSet.Query<RecursiveClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.recursiveClassUnionsCount(query);
  }

  object(
    identifier: $Object.$Identifier,
  ): Promise<purify.Either<Error, $Object>> {
    return this.$delegate.object(identifier);
  }

  objectIdentifiers(
    query?: $ObjectSet.Query<$Object.$Filter>,
  ): Promise<purify.Either<Error, readonly $Object.$Identifier[]>> {
    return this.$delegate.objectIdentifiers(query);
  }

  objects(
    query?: $ObjectSet.Query<$Object.$Filter>,
  ): Promise<purify.Either<Error, readonly $Object[]>> {
    return this.$delegate.objects(query);
  }

  objectsCount(
    query?: Pick<$ObjectSet.Query<$Object.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.objectsCount(query);
  }
}

export class $RdfjsDatasetObjectSet implements $ObjectSet {
  readonly resourceSet: rdfjsResource.ResourceSet;

  constructor({ dataset }: { dataset: rdfjs.DatasetCore }) {
    this.resourceSet = new rdfjsResource.ResourceSet({ dataset });
  }

  async baseInterfaceWithoutProperties(
    identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithoutProperties>> {
    return this.baseInterfaceWithoutPropertiesSync(identifier);
  }

  baseInterfaceWithoutPropertiesSync(
    identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier,
  ): purify.Either<Error, BaseInterfaceWithoutProperties> {
    return this.baseInterfaceWithoutPropertiesesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async baseInterfaceWithoutPropertiesIdentifiers(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithoutPropertiesStatic.$Identifier[]
    >
  > {
    return this.baseInterfaceWithoutPropertiesIdentifiersSync(query);
  }

  baseInterfaceWithoutPropertiesIdentifiersSync(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Filter>,
  ): purify.Either<
    Error,
    readonly BaseInterfaceWithoutPropertiesStatic.$Identifier[]
  > {
    return this.baseInterfaceWithoutPropertiesesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async baseInterfaceWithoutPropertieses(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithoutProperties[]>> {
    return this.baseInterfaceWithoutPropertiesesSync(query);
  }

  async baseInterfaceWithoutPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.baseInterfaceWithoutPropertiesesCountSync(query);
  }

  baseInterfaceWithoutPropertiesesCountSync(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.baseInterfaceWithoutPropertiesesSync(query).map(
      (objects) => objects.length,
    );
  }

  baseInterfaceWithoutPropertiesesSync(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Filter>,
  ): purify.Either<Error, readonly BaseInterfaceWithoutProperties[]> {
    return this.$objectsSync<
      BaseInterfaceWithoutProperties,
      BaseInterfaceWithoutPropertiesStatic.$Filter,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >(
      {
        $filter: BaseInterfaceWithoutPropertiesStatic.$filter,
        $fromRdf: BaseInterfaceWithoutPropertiesStatic.$fromRdf,
        $fromRdfTypes: [
          BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
          ConcreteParentInterfaceStatic.$fromRdfType,
          ConcreteChildInterface.$fromRdfType,
        ],
      },
      query,
    );
  }

  async baseInterfaceWithProperties(
    identifier: BaseInterfaceWithPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithProperties>> {
    return this.baseInterfaceWithPropertiesSync(identifier);
  }

  baseInterfaceWithPropertiesSync(
    identifier: BaseInterfaceWithPropertiesStatic.$Identifier,
  ): purify.Either<Error, BaseInterfaceWithProperties> {
    return this.baseInterfaceWithPropertiesesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async baseInterfaceWithPropertiesIdentifiers(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithPropertiesStatic.$Identifier[]
    >
  > {
    return this.baseInterfaceWithPropertiesIdentifiersSync(query);
  }

  baseInterfaceWithPropertiesIdentifiersSync(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Filter>,
  ): purify.Either<
    Error,
    readonly BaseInterfaceWithPropertiesStatic.$Identifier[]
  > {
    return this.baseInterfaceWithPropertiesesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async baseInterfaceWithPropertieses(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithProperties[]>> {
    return this.baseInterfaceWithPropertiesesSync(query);
  }

  async baseInterfaceWithPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.baseInterfaceWithPropertiesesCountSync(query);
  }

  baseInterfaceWithPropertiesesCountSync(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.baseInterfaceWithPropertiesesSync(query).map(
      (objects) => objects.length,
    );
  }

  baseInterfaceWithPropertiesesSync(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Filter>,
  ): purify.Either<Error, readonly BaseInterfaceWithProperties[]> {
    return this.$objectsSync<
      BaseInterfaceWithProperties,
      BaseInterfaceWithPropertiesStatic.$Filter,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >(
      {
        $filter: BaseInterfaceWithPropertiesStatic.$filter,
        $fromRdf: BaseInterfaceWithPropertiesStatic.$fromRdf,
        $fromRdfTypes: [
          BaseInterfaceWithPropertiesStatic.$fromRdfType,
          BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
          ConcreteParentInterfaceStatic.$fromRdfType,
          ConcreteChildInterface.$fromRdfType,
        ],
      },
      query,
    );
  }

  async blankNodeIdentifierClass(
    identifier: BlankNodeIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeIdentifierClass>> {
    return this.blankNodeIdentifierClassSync(identifier);
  }

  blankNodeIdentifierClassSync(
    identifier: BlankNodeIdentifierClass.$Identifier,
  ): purify.Either<Error, BlankNodeIdentifierClass> {
    return this.blankNodeIdentifierClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async blankNodeIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<BlankNodeIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeIdentifierClass.$Identifier[]>
  > {
    return this.blankNodeIdentifierClassIdentifiersSync(query);
  }

  blankNodeIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<BlankNodeIdentifierClass.$Filter>,
  ): purify.Either<Error, readonly BlankNodeIdentifierClass.$Identifier[]> {
    return this.blankNodeIdentifierClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async blankNodeIdentifierClasses(
    query?: $ObjectSet.Query<BlankNodeIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly BlankNodeIdentifierClass[]>> {
    return this.blankNodeIdentifierClassesSync(query);
  }

  async blankNodeIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<BlankNodeIdentifierClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.blankNodeIdentifierClassesCountSync(query);
  }

  blankNodeIdentifierClassesCountSync(
    query?: Pick<$ObjectSet.Query<BlankNodeIdentifierClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.blankNodeIdentifierClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  blankNodeIdentifierClassesSync(
    query?: $ObjectSet.Query<BlankNodeIdentifierClass.$Filter>,
  ): purify.Either<Error, readonly BlankNodeIdentifierClass[]> {
    return this.$objectsSync<
      BlankNodeIdentifierClass,
      BlankNodeIdentifierClass.$Filter,
      BlankNodeIdentifierClass.$Identifier
    >(
      {
        $filter: BlankNodeIdentifierClass.$filter,
        $fromRdf: BlankNodeIdentifierClass.$fromRdf,
        $fromRdfTypes: [BlankNodeIdentifierClass.$fromRdfType],
      },
      query,
    );
  }

  async blankNodeIdentifierInterface(
    identifier: BlankNodeIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeIdentifierInterface>> {
    return this.blankNodeIdentifierInterfaceSync(identifier);
  }

  blankNodeIdentifierInterfaceSync(
    identifier: BlankNodeIdentifierInterface.$Identifier,
  ): purify.Either<Error, BlankNodeIdentifierInterface> {
    return this.blankNodeIdentifierInterfacesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async blankNodeIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<BlankNodeIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeIdentifierInterface.$Identifier[]>
  > {
    return this.blankNodeIdentifierInterfaceIdentifiersSync(query);
  }

  blankNodeIdentifierInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<BlankNodeIdentifierInterface.$Filter>,
  ): purify.Either<Error, readonly BlankNodeIdentifierInterface.$Identifier[]> {
    return this.blankNodeIdentifierInterfacesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async blankNodeIdentifierInterfaces(
    query?: $ObjectSet.Query<BlankNodeIdentifierInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly BlankNodeIdentifierInterface[]>> {
    return this.blankNodeIdentifierInterfacesSync(query);
  }

  async blankNodeIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<BlankNodeIdentifierInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.blankNodeIdentifierInterfacesCountSync(query);
  }

  blankNodeIdentifierInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<BlankNodeIdentifierInterface.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.blankNodeIdentifierInterfacesSync(query).map(
      (objects) => objects.length,
    );
  }

  blankNodeIdentifierInterfacesSync(
    query?: $ObjectSet.Query<BlankNodeIdentifierInterface.$Filter>,
  ): purify.Either<Error, readonly BlankNodeIdentifierInterface[]> {
    return this.$objectsSync<
      BlankNodeIdentifierInterface,
      BlankNodeIdentifierInterface.$Filter,
      BlankNodeIdentifierInterface.$Identifier
    >(
      {
        $filter: BlankNodeIdentifierInterface.$filter,
        $fromRdf: BlankNodeIdentifierInterface.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async blankNodeOrIriIdentifierClass(
    identifier: BlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeOrIriIdentifierClass>> {
    return this.blankNodeOrIriIdentifierClassSync(identifier);
  }

  blankNodeOrIriIdentifierClassSync(
    identifier: BlankNodeOrIriIdentifierClass.$Identifier,
  ): purify.Either<Error, BlankNodeOrIriIdentifierClass> {
    return this.blankNodeOrIriIdentifierClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async blankNodeOrIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeOrIriIdentifierClass.$Identifier[]>
  > {
    return this.blankNodeOrIriIdentifierClassIdentifiersSync(query);
  }

  blankNodeOrIriIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Filter>,
  ): purify.Either<
    Error,
    readonly BlankNodeOrIriIdentifierClass.$Identifier[]
  > {
    return this.blankNodeOrIriIdentifierClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async blankNodeOrIriIdentifierClasses(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly BlankNodeOrIriIdentifierClass[]>> {
    return this.blankNodeOrIriIdentifierClassesSync(query);
  }

  async blankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.blankNodeOrIriIdentifierClassesCountSync(query);
  }

  blankNodeOrIriIdentifierClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.blankNodeOrIriIdentifierClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  blankNodeOrIriIdentifierClassesSync(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Filter>,
  ): purify.Either<Error, readonly BlankNodeOrIriIdentifierClass[]> {
    return this.$objectsSync<
      BlankNodeOrIriIdentifierClass,
      BlankNodeOrIriIdentifierClass.$Filter,
      BlankNodeOrIriIdentifierClass.$Identifier
    >(
      {
        $filter: BlankNodeOrIriIdentifierClass.$filter,
        $fromRdf: BlankNodeOrIriIdentifierClass.$fromRdf,
        $fromRdfTypes: [BlankNodeOrIriIdentifierClass.$fromRdfType],
      },
      query,
    );
  }

  async blankNodeOrIriIdentifierInterface(
    identifier: BlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeOrIriIdentifierInterface>> {
    return this.blankNodeOrIriIdentifierInterfaceSync(identifier);
  }

  blankNodeOrIriIdentifierInterfaceSync(
    identifier: BlankNodeOrIriIdentifierInterface.$Identifier,
  ): purify.Either<Error, BlankNodeOrIriIdentifierInterface> {
    return this.blankNodeOrIriIdentifierInterfacesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async blankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly BlankNodeOrIriIdentifierInterface.$Identifier[]
    >
  > {
    return this.blankNodeOrIriIdentifierInterfaceIdentifiersSync(query);
  }

  blankNodeOrIriIdentifierInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Filter>,
  ): purify.Either<
    Error,
    readonly BlankNodeOrIriIdentifierInterface.$Identifier[]
  > {
    return this.blankNodeOrIriIdentifierInterfacesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async blankNodeOrIriIdentifierInterfaces(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeOrIriIdentifierInterface[]>
  > {
    return this.blankNodeOrIriIdentifierInterfacesSync(query);
  }

  async blankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.blankNodeOrIriIdentifierInterfacesCountSync(query);
  }

  blankNodeOrIriIdentifierInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.blankNodeOrIriIdentifierInterfacesSync(query).map(
      (objects) => objects.length,
    );
  }

  blankNodeOrIriIdentifierInterfacesSync(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Filter>,
  ): purify.Either<Error, readonly BlankNodeOrIriIdentifierInterface[]> {
    return this.$objectsSync<
      BlankNodeOrIriIdentifierInterface,
      BlankNodeOrIriIdentifierInterface.$Filter,
      BlankNodeOrIriIdentifierInterface.$Identifier
    >(
      {
        $filter: BlankNodeOrIriIdentifierInterface.$filter,
        $fromRdf: BlankNodeOrIriIdentifierInterface.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async classUnionMember1(
    identifier: ClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember1>> {
    return this.classUnionMember1Sync(identifier);
  }

  classUnionMember1Sync(
    identifier: ClassUnionMember1.$Identifier,
  ): purify.Either<Error, ClassUnionMember1> {
    return this.classUnionMember1sSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async classUnionMember1Identifiers(
    query?: $ObjectSet.Query<ClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1.$Identifier[]>> {
    return this.classUnionMember1IdentifiersSync(query);
  }

  classUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<ClassUnionMember1.$Filter>,
  ): purify.Either<Error, readonly ClassUnionMember1.$Identifier[]> {
    return this.classUnionMember1sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async classUnionMember1s(
    query?: $ObjectSet.Query<ClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1[]>> {
    return this.classUnionMember1sSync(query);
  }

  async classUnionMember1sCount(
    query?: Pick<$ObjectSet.Query<ClassUnionMember1.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.classUnionMember1sCountSync(query);
  }

  classUnionMember1sCountSync(
    query?: Pick<$ObjectSet.Query<ClassUnionMember1.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.classUnionMember1sSync(query).map((objects) => objects.length);
  }

  classUnionMember1sSync(
    query?: $ObjectSet.Query<ClassUnionMember1.$Filter>,
  ): purify.Either<Error, readonly ClassUnionMember1[]> {
    return this.$objectsSync<
      ClassUnionMember1,
      ClassUnionMember1.$Filter,
      ClassUnionMember1.$Identifier
    >(
      {
        $filter: ClassUnionMember1.$filter,
        $fromRdf: ClassUnionMember1.$fromRdf,
        $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
      },
      query,
    );
  }

  async classUnionMember2(
    identifier: ClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember2>> {
    return this.classUnionMember2Sync(identifier);
  }

  classUnionMember2Sync(
    identifier: ClassUnionMember2.$Identifier,
  ): purify.Either<Error, ClassUnionMember2> {
    return this.classUnionMember2sSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async classUnionMember2Identifiers(
    query?: $ObjectSet.Query<ClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2.$Identifier[]>> {
    return this.classUnionMember2IdentifiersSync(query);
  }

  classUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<ClassUnionMember2.$Filter>,
  ): purify.Either<Error, readonly ClassUnionMember2.$Identifier[]> {
    return this.classUnionMember2sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async classUnionMember2s(
    query?: $ObjectSet.Query<ClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2[]>> {
    return this.classUnionMember2sSync(query);
  }

  async classUnionMember2sCount(
    query?: Pick<$ObjectSet.Query<ClassUnionMember2.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.classUnionMember2sCountSync(query);
  }

  classUnionMember2sCountSync(
    query?: Pick<$ObjectSet.Query<ClassUnionMember2.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.classUnionMember2sSync(query).map((objects) => objects.length);
  }

  classUnionMember2sSync(
    query?: $ObjectSet.Query<ClassUnionMember2.$Filter>,
  ): purify.Either<Error, readonly ClassUnionMember2[]> {
    return this.$objectsSync<
      ClassUnionMember2,
      ClassUnionMember2.$Filter,
      ClassUnionMember2.$Identifier
    >(
      {
        $filter: ClassUnionMember2.$filter,
        $fromRdf: ClassUnionMember2.$fromRdf,
        $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
      },
      query,
    );
  }

  async concreteChildClass(
    identifier: ConcreteChildClass.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildClass>> {
    return this.concreteChildClassSync(identifier);
  }

  concreteChildClassSync(
    identifier: ConcreteChildClass.$Identifier,
  ): purify.Either<Error, ConcreteChildClass> {
    return this.concreteChildClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async concreteChildClassIdentifiers(
    query?: $ObjectSet.Query<ConcreteChildClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass.$Identifier[]>> {
    return this.concreteChildClassIdentifiersSync(query);
  }

  concreteChildClassIdentifiersSync(
    query?: $ObjectSet.Query<ConcreteChildClass.$Filter>,
  ): purify.Either<Error, readonly ConcreteChildClass.$Identifier[]> {
    return this.concreteChildClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async concreteChildClasses(
    query?: $ObjectSet.Query<ConcreteChildClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass[]>> {
    return this.concreteChildClassesSync(query);
  }

  async concreteChildClassesCount(
    query?: Pick<$ObjectSet.Query<ConcreteChildClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.concreteChildClassesCountSync(query);
  }

  concreteChildClassesCountSync(
    query?: Pick<$ObjectSet.Query<ConcreteChildClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.concreteChildClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  concreteChildClassesSync(
    query?: $ObjectSet.Query<ConcreteChildClass.$Filter>,
  ): purify.Either<Error, readonly ConcreteChildClass[]> {
    return this.$objectsSync<
      ConcreteChildClass,
      ConcreteChildClass.$Filter,
      ConcreteChildClass.$Identifier
    >(
      {
        $filter: ConcreteChildClass.$filter,
        $fromRdf: ConcreteChildClass.$fromRdf,
        $fromRdfTypes: [ConcreteChildClass.$fromRdfType],
      },
      query,
    );
  }

  async concreteChildInterface(
    identifier: ConcreteChildInterface.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildInterface>> {
    return this.concreteChildInterfaceSync(identifier);
  }

  concreteChildInterfaceSync(
    identifier: ConcreteChildInterface.$Identifier,
  ): purify.Either<Error, ConcreteChildInterface> {
    return this.concreteChildInterfacesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async concreteChildInterfaceIdentifiers(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ConcreteChildInterface.$Identifier[]>
  > {
    return this.concreteChildInterfaceIdentifiersSync(query);
  }

  concreteChildInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Filter>,
  ): purify.Either<Error, readonly ConcreteChildInterface.$Identifier[]> {
    return this.concreteChildInterfacesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async concreteChildInterfaces(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly ConcreteChildInterface[]>> {
    return this.concreteChildInterfacesSync(query);
  }

  async concreteChildInterfacesCount(
    query?: Pick<$ObjectSet.Query<ConcreteChildInterface.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.concreteChildInterfacesCountSync(query);
  }

  concreteChildInterfacesCountSync(
    query?: Pick<$ObjectSet.Query<ConcreteChildInterface.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.concreteChildInterfacesSync(query).map(
      (objects) => objects.length,
    );
  }

  concreteChildInterfacesSync(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Filter>,
  ): purify.Either<Error, readonly ConcreteChildInterface[]> {
    return this.$objectsSync<
      ConcreteChildInterface,
      ConcreteChildInterface.$Filter,
      ConcreteChildInterface.$Identifier
    >(
      {
        $filter: ConcreteChildInterface.$filter,
        $fromRdf: ConcreteChildInterface.$fromRdf,
        $fromRdfTypes: [ConcreteChildInterface.$fromRdfType],
      },
      query,
    );
  }

  async concreteParentClass(
    identifier: ConcreteParentClassStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentClass>> {
    return this.concreteParentClassSync(identifier);
  }

  concreteParentClassSync(
    identifier: ConcreteParentClassStatic.$Identifier,
  ): purify.Either<Error, ConcreteParentClass> {
    return this.concreteParentClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async concreteParentClassIdentifiers(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentClassStatic.$Identifier[]>
  > {
    return this.concreteParentClassIdentifiersSync(query);
  }

  concreteParentClassIdentifiersSync(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Filter>,
  ): purify.Either<Error, readonly ConcreteParentClassStatic.$Identifier[]> {
    return this.concreteParentClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async concreteParentClasses(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly ConcreteParentClass[]>> {
    return this.concreteParentClassesSync(query);
  }

  async concreteParentClassesCount(
    query?: Pick<$ObjectSet.Query<ConcreteParentClassStatic.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.concreteParentClassesCountSync(query);
  }

  concreteParentClassesCountSync(
    query?: Pick<$ObjectSet.Query<ConcreteParentClassStatic.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.concreteParentClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  concreteParentClassesSync(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Filter>,
  ): purify.Either<Error, readonly ConcreteParentClass[]> {
    return this.$objectsSync<
      ConcreteParentClass,
      ConcreteParentClassStatic.$Filter,
      ConcreteParentClassStatic.$Identifier
    >(
      {
        $filter: ConcreteParentClassStatic.$filter,
        $fromRdf: ConcreteParentClassStatic.$fromRdf,
        $fromRdfTypes: [
          ConcreteParentClassStatic.$fromRdfType,
          ConcreteChildClass.$fromRdfType,
        ],
      },
      query,
    );
  }

  async concreteParentInterface(
    identifier: ConcreteParentInterfaceStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentInterface>> {
    return this.concreteParentInterfaceSync(identifier);
  }

  concreteParentInterfaceSync(
    identifier: ConcreteParentInterfaceStatic.$Identifier,
  ): purify.Either<Error, ConcreteParentInterface> {
    return this.concreteParentInterfacesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async concreteParentInterfaceIdentifiers(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentInterfaceStatic.$Identifier[]>
  > {
    return this.concreteParentInterfaceIdentifiersSync(query);
  }

  concreteParentInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Filter>,
  ): purify.Either<
    Error,
    readonly ConcreteParentInterfaceStatic.$Identifier[]
  > {
    return this.concreteParentInterfacesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async concreteParentInterfaces(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly ConcreteParentInterface[]>> {
    return this.concreteParentInterfacesSync(query);
  }

  async concreteParentInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<ConcreteParentInterfaceStatic.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.concreteParentInterfacesCountSync(query);
  }

  concreteParentInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<ConcreteParentInterfaceStatic.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.concreteParentInterfacesSync(query).map(
      (objects) => objects.length,
    );
  }

  concreteParentInterfacesSync(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Filter>,
  ): purify.Either<Error, readonly ConcreteParentInterface[]> {
    return this.$objectsSync<
      ConcreteParentInterface,
      ConcreteParentInterfaceStatic.$Filter,
      ConcreteParentInterfaceStatic.$Identifier
    >(
      {
        $filter: ConcreteParentInterfaceStatic.$filter,
        $fromRdf: ConcreteParentInterfaceStatic.$fromRdf,
        $fromRdfTypes: [
          ConcreteParentInterfaceStatic.$fromRdfType,
          ConcreteChildInterface.$fromRdfType,
        ],
      },
      query,
    );
  }

  async convertibleTypePropertiesClass(
    identifier: ConvertibleTypePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ConvertibleTypePropertiesClass>> {
    return this.convertibleTypePropertiesClassSync(identifier);
  }

  convertibleTypePropertiesClassSync(
    identifier: ConvertibleTypePropertiesClass.$Identifier,
  ): purify.Either<Error, ConvertibleTypePropertiesClass> {
    return this.convertibleTypePropertiesClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async convertibleTypePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ConvertibleTypePropertiesClass.$Identifier[]>
  > {
    return this.convertibleTypePropertiesClassIdentifiersSync(query);
  }

  convertibleTypePropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Filter>,
  ): purify.Either<
    Error,
    readonly ConvertibleTypePropertiesClass.$Identifier[]
  > {
    return this.convertibleTypePropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async convertibleTypePropertiesClasses(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ConvertibleTypePropertiesClass[]>> {
    return this.convertibleTypePropertiesClassesSync(query);
  }

  async convertibleTypePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<ConvertibleTypePropertiesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.convertibleTypePropertiesClassesCountSync(query);
  }

  convertibleTypePropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<ConvertibleTypePropertiesClass.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.convertibleTypePropertiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  convertibleTypePropertiesClassesSync(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Filter>,
  ): purify.Either<Error, readonly ConvertibleTypePropertiesClass[]> {
    return this.$objectsSync<
      ConvertibleTypePropertiesClass,
      ConvertibleTypePropertiesClass.$Filter,
      ConvertibleTypePropertiesClass.$Identifier
    >(
      {
        $filter: ConvertibleTypePropertiesClass.$filter,
        $fromRdf: ConvertibleTypePropertiesClass.$fromRdf,
        $fromRdfTypes: [ConvertibleTypePropertiesClass.$fromRdfType],
      },
      query,
    );
  }

  async dateUnionPropertiesClass(
    identifier: DateUnionPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, DateUnionPropertiesClass>> {
    return this.dateUnionPropertiesClassSync(identifier);
  }

  dateUnionPropertiesClassSync(
    identifier: DateUnionPropertiesClass.$Identifier,
  ): purify.Either<Error, DateUnionPropertiesClass> {
    return this.dateUnionPropertiesClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async dateUnionPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<DateUnionPropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly DateUnionPropertiesClass.$Identifier[]>
  > {
    return this.dateUnionPropertiesClassIdentifiersSync(query);
  }

  dateUnionPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<DateUnionPropertiesClass.$Filter>,
  ): purify.Either<Error, readonly DateUnionPropertiesClass.$Identifier[]> {
    return this.dateUnionPropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async dateUnionPropertiesClasses(
    query?: $ObjectSet.Query<DateUnionPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly DateUnionPropertiesClass[]>> {
    return this.dateUnionPropertiesClassesSync(query);
  }

  async dateUnionPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<DateUnionPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.dateUnionPropertiesClassesCountSync(query);
  }

  dateUnionPropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<DateUnionPropertiesClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.dateUnionPropertiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  dateUnionPropertiesClassesSync(
    query?: $ObjectSet.Query<DateUnionPropertiesClass.$Filter>,
  ): purify.Either<Error, readonly DateUnionPropertiesClass[]> {
    return this.$objectsSync<
      DateUnionPropertiesClass,
      DateUnionPropertiesClass.$Filter,
      DateUnionPropertiesClass.$Identifier
    >(
      {
        $filter: DateUnionPropertiesClass.$filter,
        $fromRdf: DateUnionPropertiesClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async defaultValuePropertiesClass(
    identifier: DefaultValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, DefaultValuePropertiesClass>> {
    return this.defaultValuePropertiesClassSync(identifier);
  }

  defaultValuePropertiesClassSync(
    identifier: DefaultValuePropertiesClass.$Identifier,
  ): purify.Either<Error, DefaultValuePropertiesClass> {
    return this.defaultValuePropertiesClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async defaultValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly DefaultValuePropertiesClass.$Identifier[]>
  > {
    return this.defaultValuePropertiesClassIdentifiersSync(query);
  }

  defaultValuePropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Filter>,
  ): purify.Either<Error, readonly DefaultValuePropertiesClass.$Identifier[]> {
    return this.defaultValuePropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async defaultValuePropertiesClasses(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly DefaultValuePropertiesClass[]>> {
    return this.defaultValuePropertiesClassesSync(query);
  }

  async defaultValuePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<DefaultValuePropertiesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.defaultValuePropertiesClassesCountSync(query);
  }

  defaultValuePropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<DefaultValuePropertiesClass.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.defaultValuePropertiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  defaultValuePropertiesClassesSync(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Filter>,
  ): purify.Either<Error, readonly DefaultValuePropertiesClass[]> {
    return this.$objectsSync<
      DefaultValuePropertiesClass,
      DefaultValuePropertiesClass.$Filter,
      DefaultValuePropertiesClass.$Identifier
    >(
      {
        $filter: DefaultValuePropertiesClass.$filter,
        $fromRdf: DefaultValuePropertiesClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async directRecursiveClass(
    identifier: DirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, DirectRecursiveClass>> {
    return this.directRecursiveClassSync(identifier);
  }

  directRecursiveClassSync(
    identifier: DirectRecursiveClass.$Identifier,
  ): purify.Either<Error, DirectRecursiveClass> {
    return this.directRecursiveClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async directRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly DirectRecursiveClass.$Identifier[]>
  > {
    return this.directRecursiveClassIdentifiersSync(query);
  }

  directRecursiveClassIdentifiersSync(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Filter>,
  ): purify.Either<Error, readonly DirectRecursiveClass.$Identifier[]> {
    return this.directRecursiveClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async directRecursiveClasses(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Filter>,
  ): Promise<purify.Either<Error, readonly DirectRecursiveClass[]>> {
    return this.directRecursiveClassesSync(query);
  }

  async directRecursiveClassesCount(
    query?: Pick<$ObjectSet.Query<DirectRecursiveClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.directRecursiveClassesCountSync(query);
  }

  directRecursiveClassesCountSync(
    query?: Pick<$ObjectSet.Query<DirectRecursiveClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.directRecursiveClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  directRecursiveClassesSync(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Filter>,
  ): purify.Either<Error, readonly DirectRecursiveClass[]> {
    return this.$objectsSync<
      DirectRecursiveClass,
      DirectRecursiveClass.$Filter,
      DirectRecursiveClass.$Identifier
    >(
      {
        $filter: DirectRecursiveClass.$filter,
        $fromRdf: DirectRecursiveClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async explicitFromToRdfTypesClass(
    identifier: ExplicitFromToRdfTypesClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitFromToRdfTypesClass>> {
    return this.explicitFromToRdfTypesClassSync(identifier);
  }

  explicitFromToRdfTypesClassSync(
    identifier: ExplicitFromToRdfTypesClass.$Identifier,
  ): purify.Either<Error, ExplicitFromToRdfTypesClass> {
    return this.explicitFromToRdfTypesClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async explicitFromToRdfTypesClassIdentifiers(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ExplicitFromToRdfTypesClass.$Identifier[]>
  > {
    return this.explicitFromToRdfTypesClassIdentifiersSync(query);
  }

  explicitFromToRdfTypesClassIdentifiersSync(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Filter>,
  ): purify.Either<Error, readonly ExplicitFromToRdfTypesClass.$Identifier[]> {
    return this.explicitFromToRdfTypesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async explicitFromToRdfTypesClasses(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ExplicitFromToRdfTypesClass[]>> {
    return this.explicitFromToRdfTypesClassesSync(query);
  }

  async explicitFromToRdfTypesClassesCount(
    query?: Pick<
      $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.explicitFromToRdfTypesClassesCountSync(query);
  }

  explicitFromToRdfTypesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.explicitFromToRdfTypesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  explicitFromToRdfTypesClassesSync(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Filter>,
  ): purify.Either<Error, readonly ExplicitFromToRdfTypesClass[]> {
    return this.$objectsSync<
      ExplicitFromToRdfTypesClass,
      ExplicitFromToRdfTypesClass.$Filter,
      ExplicitFromToRdfTypesClass.$Identifier
    >(
      {
        $filter: ExplicitFromToRdfTypesClass.$filter,
        $fromRdf: ExplicitFromToRdfTypesClass.$fromRdf,
        $fromRdfTypes: [ExplicitFromToRdfTypesClass.$fromRdfType],
      },
      query,
    );
  }

  async explicitRdfTypeClass(
    identifier: ExplicitRdfTypeClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitRdfTypeClass>> {
    return this.explicitRdfTypeClassSync(identifier);
  }

  explicitRdfTypeClassSync(
    identifier: ExplicitRdfTypeClass.$Identifier,
  ): purify.Either<Error, ExplicitRdfTypeClass> {
    return this.explicitRdfTypeClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async explicitRdfTypeClassIdentifiers(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ExplicitRdfTypeClass.$Identifier[]>
  > {
    return this.explicitRdfTypeClassIdentifiersSync(query);
  }

  explicitRdfTypeClassIdentifiersSync(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Filter>,
  ): purify.Either<Error, readonly ExplicitRdfTypeClass.$Identifier[]> {
    return this.explicitRdfTypeClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async explicitRdfTypeClasses(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ExplicitRdfTypeClass[]>> {
    return this.explicitRdfTypeClassesSync(query);
  }

  async explicitRdfTypeClassesCount(
    query?: Pick<$ObjectSet.Query<ExplicitRdfTypeClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.explicitRdfTypeClassesCountSync(query);
  }

  explicitRdfTypeClassesCountSync(
    query?: Pick<$ObjectSet.Query<ExplicitRdfTypeClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.explicitRdfTypeClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  explicitRdfTypeClassesSync(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Filter>,
  ): purify.Either<Error, readonly ExplicitRdfTypeClass[]> {
    return this.$objectsSync<
      ExplicitRdfTypeClass,
      ExplicitRdfTypeClass.$Filter,
      ExplicitRdfTypeClass.$Identifier
    >(
      {
        $filter: ExplicitRdfTypeClass.$filter,
        $fromRdf: ExplicitRdfTypeClass.$fromRdf,
        $fromRdfTypes: [ExplicitRdfTypeClass.$fromRdfType],
      },
      query,
    );
  }

  async externClassPropertyClass(
    identifier: ExternClassPropertyClass.$Identifier,
  ): Promise<purify.Either<Error, ExternClassPropertyClass>> {
    return this.externClassPropertyClassSync(identifier);
  }

  externClassPropertyClassSync(
    identifier: ExternClassPropertyClass.$Identifier,
  ): purify.Either<Error, ExternClassPropertyClass> {
    return this.externClassPropertyClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async externClassPropertyClassIdentifiers(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ExternClassPropertyClass.$Identifier[]>
  > {
    return this.externClassPropertyClassIdentifiersSync(query);
  }

  externClassPropertyClassIdentifiersSync(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Filter>,
  ): purify.Either<Error, readonly ExternClassPropertyClass.$Identifier[]> {
    return this.externClassPropertyClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async externClassPropertyClasses(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ExternClassPropertyClass[]>> {
    return this.externClassPropertyClassesSync(query);
  }

  async externClassPropertyClassesCount(
    query?: Pick<$ObjectSet.Query<ExternClassPropertyClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.externClassPropertyClassesCountSync(query);
  }

  externClassPropertyClassesCountSync(
    query?: Pick<$ObjectSet.Query<ExternClassPropertyClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.externClassPropertyClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  externClassPropertyClassesSync(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Filter>,
  ): purify.Either<Error, readonly ExternClassPropertyClass[]> {
    return this.$objectsSync<
      ExternClassPropertyClass,
      ExternClassPropertyClass.$Filter,
      ExternClassPropertyClass.$Identifier
    >(
      {
        $filter: ExternClassPropertyClass.$filter,
        $fromRdf: ExternClassPropertyClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async flattenClassUnionMember3(
    identifier: FlattenClassUnionMember3.$Identifier,
  ): Promise<purify.Either<Error, FlattenClassUnionMember3>> {
    return this.flattenClassUnionMember3Sync(identifier);
  }

  flattenClassUnionMember3Sync(
    identifier: FlattenClassUnionMember3.$Identifier,
  ): purify.Either<Error, FlattenClassUnionMember3> {
    return this.flattenClassUnionMember3sSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async flattenClassUnionMember3Identifiers(
    query?: $ObjectSet.Query<FlattenClassUnionMember3.$Filter>,
  ): Promise<
    purify.Either<Error, readonly FlattenClassUnionMember3.$Identifier[]>
  > {
    return this.flattenClassUnionMember3IdentifiersSync(query);
  }

  flattenClassUnionMember3IdentifiersSync(
    query?: $ObjectSet.Query<FlattenClassUnionMember3.$Filter>,
  ): purify.Either<Error, readonly FlattenClassUnionMember3.$Identifier[]> {
    return this.flattenClassUnionMember3sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async flattenClassUnionMember3s(
    query?: $ObjectSet.Query<FlattenClassUnionMember3.$Filter>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnionMember3[]>> {
    return this.flattenClassUnionMember3sSync(query);
  }

  async flattenClassUnionMember3sCount(
    query?: Pick<$ObjectSet.Query<FlattenClassUnionMember3.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.flattenClassUnionMember3sCountSync(query);
  }

  flattenClassUnionMember3sCountSync(
    query?: Pick<$ObjectSet.Query<FlattenClassUnionMember3.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.flattenClassUnionMember3sSync(query).map(
      (objects) => objects.length,
    );
  }

  flattenClassUnionMember3sSync(
    query?: $ObjectSet.Query<FlattenClassUnionMember3.$Filter>,
  ): purify.Either<Error, readonly FlattenClassUnionMember3[]> {
    return this.$objectsSync<
      FlattenClassUnionMember3,
      FlattenClassUnionMember3.$Filter,
      FlattenClassUnionMember3.$Identifier
    >(
      {
        $filter: FlattenClassUnionMember3.$filter,
        $fromRdf: FlattenClassUnionMember3.$fromRdf,
        $fromRdfTypes: [FlattenClassUnionMember3.$fromRdfType],
      },
      query,
    );
  }

  async hasValuePropertiesClass(
    identifier: HasValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, HasValuePropertiesClass>> {
    return this.hasValuePropertiesClassSync(identifier);
  }

  hasValuePropertiesClassSync(
    identifier: HasValuePropertiesClass.$Identifier,
  ): purify.Either<Error, HasValuePropertiesClass> {
    return this.hasValuePropertiesClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async hasValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly HasValuePropertiesClass.$Identifier[]>
  > {
    return this.hasValuePropertiesClassIdentifiersSync(query);
  }

  hasValuePropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Filter>,
  ): purify.Either<Error, readonly HasValuePropertiesClass.$Identifier[]> {
    return this.hasValuePropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async hasValuePropertiesClasses(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly HasValuePropertiesClass[]>> {
    return this.hasValuePropertiesClassesSync(query);
  }

  async hasValuePropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<HasValuePropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.hasValuePropertiesClassesCountSync(query);
  }

  hasValuePropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<HasValuePropertiesClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.hasValuePropertiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  hasValuePropertiesClassesSync(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Filter>,
  ): purify.Either<Error, readonly HasValuePropertiesClass[]> {
    return this.$objectsSync<
      HasValuePropertiesClass,
      HasValuePropertiesClass.$Filter,
      HasValuePropertiesClass.$Identifier
    >(
      {
        $filter: HasValuePropertiesClass.$filter,
        $fromRdf: HasValuePropertiesClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async identifierOverride3Class(
    identifier: IdentifierOverride3ClassStatic.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride3Class>> {
    return this.identifierOverride3ClassSync(identifier);
  }

  identifierOverride3ClassSync(
    identifier: IdentifierOverride3ClassStatic.$Identifier,
  ): purify.Either<Error, IdentifierOverride3Class> {
    return this.identifierOverride3ClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async identifierOverride3ClassIdentifiers(
    query?: $ObjectSet.Query<IdentifierOverride3ClassStatic.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride3ClassStatic.$Identifier[]>
  > {
    return this.identifierOverride3ClassIdentifiersSync(query);
  }

  identifierOverride3ClassIdentifiersSync(
    query?: $ObjectSet.Query<IdentifierOverride3ClassStatic.$Filter>,
  ): purify.Either<
    Error,
    readonly IdentifierOverride3ClassStatic.$Identifier[]
  > {
    return this.identifierOverride3ClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async identifierOverride3Classes(
    query?: $ObjectSet.Query<IdentifierOverride3ClassStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride3Class[]>> {
    return this.identifierOverride3ClassesSync(query);
  }

  async identifierOverride3ClassesCount(
    query?: Pick<
      $ObjectSet.Query<IdentifierOverride3ClassStatic.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.identifierOverride3ClassesCountSync(query);
  }

  identifierOverride3ClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<IdentifierOverride3ClassStatic.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.identifierOverride3ClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  identifierOverride3ClassesSync(
    query?: $ObjectSet.Query<IdentifierOverride3ClassStatic.$Filter>,
  ): purify.Either<Error, readonly IdentifierOverride3Class[]> {
    return this.$objectsSync<
      IdentifierOverride3Class,
      IdentifierOverride3ClassStatic.$Filter,
      IdentifierOverride3ClassStatic.$Identifier
    >(
      {
        $filter: IdentifierOverride3ClassStatic.$filter,
        $fromRdf: IdentifierOverride3ClassStatic.$fromRdf,
        $fromRdfTypes: [
          IdentifierOverride3ClassStatic.$fromRdfType,
          IdentifierOverride4ClassStatic.$fromRdfType,
          IdentifierOverride5Class.$fromRdfType,
        ],
      },
      query,
    );
  }

  async identifierOverride4Class(
    identifier: IdentifierOverride4ClassStatic.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride4Class>> {
    return this.identifierOverride4ClassSync(identifier);
  }

  identifierOverride4ClassSync(
    identifier: IdentifierOverride4ClassStatic.$Identifier,
  ): purify.Either<Error, IdentifierOverride4Class> {
    return this.identifierOverride4ClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async identifierOverride4ClassIdentifiers(
    query?: $ObjectSet.Query<IdentifierOverride4ClassStatic.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride4ClassStatic.$Identifier[]>
  > {
    return this.identifierOverride4ClassIdentifiersSync(query);
  }

  identifierOverride4ClassIdentifiersSync(
    query?: $ObjectSet.Query<IdentifierOverride4ClassStatic.$Filter>,
  ): purify.Either<
    Error,
    readonly IdentifierOverride4ClassStatic.$Identifier[]
  > {
    return this.identifierOverride4ClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async identifierOverride4Classes(
    query?: $ObjectSet.Query<IdentifierOverride4ClassStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride4Class[]>> {
    return this.identifierOverride4ClassesSync(query);
  }

  async identifierOverride4ClassesCount(
    query?: Pick<
      $ObjectSet.Query<IdentifierOverride4ClassStatic.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.identifierOverride4ClassesCountSync(query);
  }

  identifierOverride4ClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<IdentifierOverride4ClassStatic.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.identifierOverride4ClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  identifierOverride4ClassesSync(
    query?: $ObjectSet.Query<IdentifierOverride4ClassStatic.$Filter>,
  ): purify.Either<Error, readonly IdentifierOverride4Class[]> {
    return this.$objectsSync<
      IdentifierOverride4Class,
      IdentifierOverride4ClassStatic.$Filter,
      IdentifierOverride4ClassStatic.$Identifier
    >(
      {
        $filter: IdentifierOverride4ClassStatic.$filter,
        $fromRdf: IdentifierOverride4ClassStatic.$fromRdf,
        $fromRdfTypes: [
          IdentifierOverride4ClassStatic.$fromRdfType,
          IdentifierOverride5Class.$fromRdfType,
        ],
      },
      query,
    );
  }

  async identifierOverride5Class(
    identifier: IdentifierOverride5Class.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride5Class>> {
    return this.identifierOverride5ClassSync(identifier);
  }

  identifierOverride5ClassSync(
    identifier: IdentifierOverride5Class.$Identifier,
  ): purify.Either<Error, IdentifierOverride5Class> {
    return this.identifierOverride5ClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async identifierOverride5ClassIdentifiers(
    query?: $ObjectSet.Query<IdentifierOverride5Class.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride5Class.$Identifier[]>
  > {
    return this.identifierOverride5ClassIdentifiersSync(query);
  }

  identifierOverride5ClassIdentifiersSync(
    query?: $ObjectSet.Query<IdentifierOverride5Class.$Filter>,
  ): purify.Either<Error, readonly IdentifierOverride5Class.$Identifier[]> {
    return this.identifierOverride5ClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async identifierOverride5Classes(
    query?: $ObjectSet.Query<IdentifierOverride5Class.$Filter>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride5Class[]>> {
    return this.identifierOverride5ClassesSync(query);
  }

  async identifierOverride5ClassesCount(
    query?: Pick<$ObjectSet.Query<IdentifierOverride5Class.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.identifierOverride5ClassesCountSync(query);
  }

  identifierOverride5ClassesCountSync(
    query?: Pick<$ObjectSet.Query<IdentifierOverride5Class.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.identifierOverride5ClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  identifierOverride5ClassesSync(
    query?: $ObjectSet.Query<IdentifierOverride5Class.$Filter>,
  ): purify.Either<Error, readonly IdentifierOverride5Class[]> {
    return this.$objectsSync<
      IdentifierOverride5Class,
      IdentifierOverride5Class.$Filter,
      IdentifierOverride5Class.$Identifier
    >(
      {
        $filter: IdentifierOverride5Class.$filter,
        $fromRdf: IdentifierOverride5Class.$fromRdf,
        $fromRdfTypes: [IdentifierOverride5Class.$fromRdfType],
      },
      query,
    );
  }

  async indirectRecursiveClass(
    identifier: IndirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveClass>> {
    return this.indirectRecursiveClassSync(identifier);
  }

  indirectRecursiveClassSync(
    identifier: IndirectRecursiveClass.$Identifier,
  ): purify.Either<Error, IndirectRecursiveClass> {
    return this.indirectRecursiveClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async indirectRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveClass.$Identifier[]>
  > {
    return this.indirectRecursiveClassIdentifiersSync(query);
  }

  indirectRecursiveClassIdentifiersSync(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Filter>,
  ): purify.Either<Error, readonly IndirectRecursiveClass.$Identifier[]> {
    return this.indirectRecursiveClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async indirectRecursiveClasses(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Filter>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveClass[]>> {
    return this.indirectRecursiveClassesSync(query);
  }

  async indirectRecursiveClassesCount(
    query?: Pick<$ObjectSet.Query<IndirectRecursiveClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.indirectRecursiveClassesCountSync(query);
  }

  indirectRecursiveClassesCountSync(
    query?: Pick<$ObjectSet.Query<IndirectRecursiveClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.indirectRecursiveClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  indirectRecursiveClassesSync(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Filter>,
  ): purify.Either<Error, readonly IndirectRecursiveClass[]> {
    return this.$objectsSync<
      IndirectRecursiveClass,
      IndirectRecursiveClass.$Filter,
      IndirectRecursiveClass.$Identifier
    >(
      {
        $filter: IndirectRecursiveClass.$filter,
        $fromRdf: IndirectRecursiveClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async indirectRecursiveHelperClass(
    identifier: IndirectRecursiveHelperClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveHelperClass>> {
    return this.indirectRecursiveHelperClassSync(identifier);
  }

  indirectRecursiveHelperClassSync(
    identifier: IndirectRecursiveHelperClass.$Identifier,
  ): purify.Either<Error, IndirectRecursiveHelperClass> {
    return this.indirectRecursiveHelperClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async indirectRecursiveHelperClassIdentifiers(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveHelperClass.$Identifier[]>
  > {
    return this.indirectRecursiveHelperClassIdentifiersSync(query);
  }

  indirectRecursiveHelperClassIdentifiersSync(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Filter>,
  ): purify.Either<Error, readonly IndirectRecursiveHelperClass.$Identifier[]> {
    return this.indirectRecursiveHelperClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async indirectRecursiveHelperClasses(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Filter>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveHelperClass[]>> {
    return this.indirectRecursiveHelperClassesSync(query);
  }

  async indirectRecursiveHelperClassesCount(
    query?: Pick<
      $ObjectSet.Query<IndirectRecursiveHelperClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.indirectRecursiveHelperClassesCountSync(query);
  }

  indirectRecursiveHelperClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<IndirectRecursiveHelperClass.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.indirectRecursiveHelperClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  indirectRecursiveHelperClassesSync(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Filter>,
  ): purify.Either<Error, readonly IndirectRecursiveHelperClass[]> {
    return this.$objectsSync<
      IndirectRecursiveHelperClass,
      IndirectRecursiveHelperClass.$Filter,
      IndirectRecursiveHelperClass.$Identifier
    >(
      {
        $filter: IndirectRecursiveHelperClass.$filter,
        $fromRdf: IndirectRecursiveHelperClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async inIdentifierClass(
    identifier: InIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, InIdentifierClass>> {
    return this.inIdentifierClassSync(identifier);
  }

  inIdentifierClassSync(
    identifier: InIdentifierClass.$Identifier,
  ): purify.Either<Error, InIdentifierClass> {
    return this.inIdentifierClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async inIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<InIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass.$Identifier[]>> {
    return this.inIdentifierClassIdentifiersSync(query);
  }

  inIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<InIdentifierClass.$Filter>,
  ): purify.Either<Error, readonly InIdentifierClass.$Identifier[]> {
    return this.inIdentifierClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async inIdentifierClasses(
    query?: $ObjectSet.Query<InIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass[]>> {
    return this.inIdentifierClassesSync(query);
  }

  async inIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<InIdentifierClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.inIdentifierClassesCountSync(query);
  }

  inIdentifierClassesCountSync(
    query?: Pick<$ObjectSet.Query<InIdentifierClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.inIdentifierClassesSync(query).map((objects) => objects.length);
  }

  inIdentifierClassesSync(
    query?: $ObjectSet.Query<InIdentifierClass.$Filter>,
  ): purify.Either<Error, readonly InIdentifierClass[]> {
    return this.$objectsSync<
      InIdentifierClass,
      InIdentifierClass.$Filter,
      InIdentifierClass.$Identifier
    >(
      {
        $filter: InIdentifierClass.$filter,
        $fromRdf: InIdentifierClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async inPropertiesClass(
    identifier: InPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, InPropertiesClass>> {
    return this.inPropertiesClassSync(identifier);
  }

  inPropertiesClassSync(
    identifier: InPropertiesClass.$Identifier,
  ): purify.Either<Error, InPropertiesClass> {
    return this.inPropertiesClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async inPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<InPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass.$Identifier[]>> {
    return this.inPropertiesClassIdentifiersSync(query);
  }

  inPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<InPropertiesClass.$Filter>,
  ): purify.Either<Error, readonly InPropertiesClass.$Identifier[]> {
    return this.inPropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async inPropertiesClasses(
    query?: $ObjectSet.Query<InPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass[]>> {
    return this.inPropertiesClassesSync(query);
  }

  async inPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<InPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.inPropertiesClassesCountSync(query);
  }

  inPropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<InPropertiesClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.inPropertiesClassesSync(query).map((objects) => objects.length);
  }

  inPropertiesClassesSync(
    query?: $ObjectSet.Query<InPropertiesClass.$Filter>,
  ): purify.Either<Error, readonly InPropertiesClass[]> {
    return this.$objectsSync<
      InPropertiesClass,
      InPropertiesClass.$Filter,
      InPropertiesClass.$Identifier
    >(
      {
        $filter: InPropertiesClass.$filter,
        $fromRdf: InPropertiesClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async interface(
    identifier: Interface.$Identifier,
  ): Promise<purify.Either<Error, Interface>> {
    return this.interfaceSync(identifier);
  }

  interfaceSync(
    identifier: Interface.$Identifier,
  ): purify.Either<Error, Interface> {
    return this.interfacesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async interfaceIdentifiers(
    query?: $ObjectSet.Query<Interface.$Filter>,
  ): Promise<purify.Either<Error, readonly Interface.$Identifier[]>> {
    return this.interfaceIdentifiersSync(query);
  }

  interfaceIdentifiersSync(
    query?: $ObjectSet.Query<Interface.$Filter>,
  ): purify.Either<Error, readonly Interface.$Identifier[]> {
    return this.interfacesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async interfaces(
    query?: $ObjectSet.Query<Interface.$Filter>,
  ): Promise<purify.Either<Error, readonly Interface[]>> {
    return this.interfacesSync(query);
  }

  async interfacesCount(
    query?: Pick<$ObjectSet.Query<Interface.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.interfacesCountSync(query);
  }

  interfacesCountSync(
    query?: Pick<$ObjectSet.Query<Interface.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.interfacesSync(query).map((objects) => objects.length);
  }

  interfacesSync(
    query?: $ObjectSet.Query<Interface.$Filter>,
  ): purify.Either<Error, readonly Interface[]> {
    return this.$objectsSync<
      Interface,
      Interface.$Filter,
      Interface.$Identifier
    >(
      {
        $filter: Interface.$filter,
        $fromRdf: Interface.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async interfaceUnionMember1(
    identifier: InterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember1>> {
    return this.interfaceUnionMember1Sync(identifier);
  }

  interfaceUnionMember1Sync(
    identifier: InterfaceUnionMember1.$Identifier,
  ): purify.Either<Error, InterfaceUnionMember1> {
    return this.interfaceUnionMember1sSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async interfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember1.$Identifier[]>
  > {
    return this.interfaceUnionMember1IdentifiersSync(query);
  }

  interfaceUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Filter>,
  ): purify.Either<Error, readonly InterfaceUnionMember1.$Identifier[]> {
    return this.interfaceUnionMember1sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async interfaceUnionMember1s(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember1[]>> {
    return this.interfaceUnionMember1sSync(query);
  }

  async interfaceUnionMember1sCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember1.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.interfaceUnionMember1sCountSync(query);
  }

  interfaceUnionMember1sCountSync(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember1.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.interfaceUnionMember1sSync(query).map(
      (objects) => objects.length,
    );
  }

  interfaceUnionMember1sSync(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Filter>,
  ): purify.Either<Error, readonly InterfaceUnionMember1[]> {
    return this.$objectsSync<
      InterfaceUnionMember1,
      InterfaceUnionMember1.$Filter,
      InterfaceUnionMember1.$Identifier
    >(
      {
        $filter: InterfaceUnionMember1.$filter,
        $fromRdf: InterfaceUnionMember1.$fromRdf,
        $fromRdfTypes: [InterfaceUnionMember1.$fromRdfType],
      },
      query,
    );
  }

  async interfaceUnionMember2(
    identifier: InterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember2>> {
    return this.interfaceUnionMember2Sync(identifier);
  }

  interfaceUnionMember2Sync(
    identifier: InterfaceUnionMember2.$Identifier,
  ): purify.Either<Error, InterfaceUnionMember2> {
    return this.interfaceUnionMember2sSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async interfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember2.$Identifier[]>
  > {
    return this.interfaceUnionMember2IdentifiersSync(query);
  }

  interfaceUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Filter>,
  ): purify.Either<Error, readonly InterfaceUnionMember2.$Identifier[]> {
    return this.interfaceUnionMember2sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async interfaceUnionMember2s(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember2[]>> {
    return this.interfaceUnionMember2sSync(query);
  }

  async interfaceUnionMember2sCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember2.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.interfaceUnionMember2sCountSync(query);
  }

  interfaceUnionMember2sCountSync(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember2.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.interfaceUnionMember2sSync(query).map(
      (objects) => objects.length,
    );
  }

  interfaceUnionMember2sSync(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Filter>,
  ): purify.Either<Error, readonly InterfaceUnionMember2[]> {
    return this.$objectsSync<
      InterfaceUnionMember2,
      InterfaceUnionMember2.$Filter,
      InterfaceUnionMember2.$Identifier
    >(
      {
        $filter: InterfaceUnionMember2.$filter,
        $fromRdf: InterfaceUnionMember2.$fromRdf,
        $fromRdfTypes: [InterfaceUnionMember2.$fromRdfType],
      },
      query,
    );
  }

  async iriIdentifierClass(
    identifier: IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, IriIdentifierClass>> {
    return this.iriIdentifierClassSync(identifier);
  }

  iriIdentifierClassSync(
    identifier: IriIdentifierClass.$Identifier,
  ): purify.Either<Error, IriIdentifierClass> {
    return this.iriIdentifierClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async iriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<IriIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly IriIdentifierClass.$Identifier[]>> {
    return this.iriIdentifierClassIdentifiersSync(query);
  }

  iriIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<IriIdentifierClass.$Filter>,
  ): purify.Either<Error, readonly IriIdentifierClass.$Identifier[]> {
    return this.iriIdentifierClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async iriIdentifierClasses(
    query?: $ObjectSet.Query<IriIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly IriIdentifierClass[]>> {
    return this.iriIdentifierClassesSync(query);
  }

  async iriIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<IriIdentifierClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.iriIdentifierClassesCountSync(query);
  }

  iriIdentifierClassesCountSync(
    query?: Pick<$ObjectSet.Query<IriIdentifierClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.iriIdentifierClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  iriIdentifierClassesSync(
    query?: $ObjectSet.Query<IriIdentifierClass.$Filter>,
  ): purify.Either<Error, readonly IriIdentifierClass[]> {
    return this.$objectsSync<
      IriIdentifierClass,
      IriIdentifierClass.$Filter,
      IriIdentifierClass.$Identifier
    >(
      {
        $filter: IriIdentifierClass.$filter,
        $fromRdf: IriIdentifierClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async iriIdentifierInterface(
    identifier: IriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, IriIdentifierInterface>> {
    return this.iriIdentifierInterfaceSync(identifier);
  }

  iriIdentifierInterfaceSync(
    identifier: IriIdentifierInterface.$Identifier,
  ): purify.Either<Error, IriIdentifierInterface> {
    return this.iriIdentifierInterfacesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async iriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<IriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IriIdentifierInterface.$Identifier[]>
  > {
    return this.iriIdentifierInterfaceIdentifiersSync(query);
  }

  iriIdentifierInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<IriIdentifierInterface.$Filter>,
  ): purify.Either<Error, readonly IriIdentifierInterface.$Identifier[]> {
    return this.iriIdentifierInterfacesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async iriIdentifierInterfaces(
    query?: $ObjectSet.Query<IriIdentifierInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly IriIdentifierInterface[]>> {
    return this.iriIdentifierInterfacesSync(query);
  }

  async iriIdentifierInterfacesCount(
    query?: Pick<$ObjectSet.Query<IriIdentifierInterface.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.iriIdentifierInterfacesCountSync(query);
  }

  iriIdentifierInterfacesCountSync(
    query?: Pick<$ObjectSet.Query<IriIdentifierInterface.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.iriIdentifierInterfacesSync(query).map(
      (objects) => objects.length,
    );
  }

  iriIdentifierInterfacesSync(
    query?: $ObjectSet.Query<IriIdentifierInterface.$Filter>,
  ): purify.Either<Error, readonly IriIdentifierInterface[]> {
    return this.$objectsSync<
      IriIdentifierInterface,
      IriIdentifierInterface.$Filter,
      IriIdentifierInterface.$Identifier
    >(
      {
        $filter: IriIdentifierInterface.$filter,
        $fromRdf: IriIdentifierInterface.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async jsPrimitiveUnionPropertyClass(
    identifier: JsPrimitiveUnionPropertyClass.$Identifier,
  ): Promise<purify.Either<Error, JsPrimitiveUnionPropertyClass>> {
    return this.jsPrimitiveUnionPropertyClassSync(identifier);
  }

  jsPrimitiveUnionPropertyClassSync(
    identifier: JsPrimitiveUnionPropertyClass.$Identifier,
  ): purify.Either<Error, JsPrimitiveUnionPropertyClass> {
    return this.jsPrimitiveUnionPropertyClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async jsPrimitiveUnionPropertyClassIdentifiers(
    query?: $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly JsPrimitiveUnionPropertyClass.$Identifier[]>
  > {
    return this.jsPrimitiveUnionPropertyClassIdentifiersSync(query);
  }

  jsPrimitiveUnionPropertyClassIdentifiersSync(
    query?: $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Filter>,
  ): purify.Either<
    Error,
    readonly JsPrimitiveUnionPropertyClass.$Identifier[]
  > {
    return this.jsPrimitiveUnionPropertyClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async jsPrimitiveUnionPropertyClasses(
    query?: $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Filter>,
  ): Promise<purify.Either<Error, readonly JsPrimitiveUnionPropertyClass[]>> {
    return this.jsPrimitiveUnionPropertyClassesSync(query);
  }

  async jsPrimitiveUnionPropertyClassesCount(
    query?: Pick<
      $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.jsPrimitiveUnionPropertyClassesCountSync(query);
  }

  jsPrimitiveUnionPropertyClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.jsPrimitiveUnionPropertyClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  jsPrimitiveUnionPropertyClassesSync(
    query?: $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Filter>,
  ): purify.Either<Error, readonly JsPrimitiveUnionPropertyClass[]> {
    return this.$objectsSync<
      JsPrimitiveUnionPropertyClass,
      JsPrimitiveUnionPropertyClass.$Filter,
      JsPrimitiveUnionPropertyClass.$Identifier
    >(
      {
        $filter: JsPrimitiveUnionPropertyClass.$filter,
        $fromRdf: JsPrimitiveUnionPropertyClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async languageInPropertiesClass(
    identifier: LanguageInPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LanguageInPropertiesClass>> {
    return this.languageInPropertiesClassSync(identifier);
  }

  languageInPropertiesClassSync(
    identifier: LanguageInPropertiesClass.$Identifier,
  ): purify.Either<Error, LanguageInPropertiesClass> {
    return this.languageInPropertiesClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async languageInPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LanguageInPropertiesClass.$Identifier[]>
  > {
    return this.languageInPropertiesClassIdentifiersSync(query);
  }

  languageInPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Filter>,
  ): purify.Either<Error, readonly LanguageInPropertiesClass.$Identifier[]> {
    return this.languageInPropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async languageInPropertiesClasses(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly LanguageInPropertiesClass[]>> {
    return this.languageInPropertiesClassesSync(query);
  }

  async languageInPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<LanguageInPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.languageInPropertiesClassesCountSync(query);
  }

  languageInPropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<LanguageInPropertiesClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.languageInPropertiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  languageInPropertiesClassesSync(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Filter>,
  ): purify.Either<Error, readonly LanguageInPropertiesClass[]> {
    return this.$objectsSync<
      LanguageInPropertiesClass,
      LanguageInPropertiesClass.$Filter,
      LanguageInPropertiesClass.$Identifier
    >(
      {
        $filter: LanguageInPropertiesClass.$filter,
        $fromRdf: LanguageInPropertiesClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClass(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<
    purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierClass>
  > {
    return this.lazilyResolvedBlankNodeOrIriIdentifierClassSync(identifier);
  }

  lazilyResolvedBlankNodeOrIriIdentifierClassSync(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
  ): purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierClass> {
    return this.lazilyResolvedBlankNodeOrIriIdentifierClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier[]
    >
  > {
    return this.lazilyResolvedBlankNodeOrIriIdentifierClassIdentifiersSync(
      query,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier[]
  > {
    return this.lazilyResolvedBlankNodeOrIriIdentifierClassesSync(query).map(
      (objects) => objects.map((object) => object.$identifier),
    );
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClasses(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedBlankNodeOrIriIdentifierClass[]>
  > {
    return this.lazilyResolvedBlankNodeOrIriIdentifierClassesSync(query);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedBlankNodeOrIriIdentifierClassesCountSync(query);
  }

  lazilyResolvedBlankNodeOrIriIdentifierClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.lazilyResolvedBlankNodeOrIriIdentifierClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierClassesSync(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedBlankNodeOrIriIdentifierClass[]
  > {
    return this.$objectsSync<
      LazilyResolvedBlankNodeOrIriIdentifierClass,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
    >(
      {
        $filter: LazilyResolvedBlankNodeOrIriIdentifierClass.$filter,
        $fromRdf: LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdf,
        $fromRdfTypes: [
          LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdfType,
        ],
      },
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterface(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<
    purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierInterface>
  > {
    return this.lazilyResolvedBlankNodeOrIriIdentifierInterfaceSync(identifier);
  }

  lazilyResolvedBlankNodeOrIriIdentifierInterfaceSync(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
  ): purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierInterface> {
    return this.lazilyResolvedBlankNodeOrIriIdentifierInterfacesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier[]
    >
  > {
    return this.lazilyResolvedBlankNodeOrIriIdentifierInterfaceIdentifiersSync(
      query,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier[]
  > {
    return this.lazilyResolvedBlankNodeOrIriIdentifierInterfacesSync(query).map(
      (objects) => objects.map((object) => object.$identifier),
    );
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterfaces(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[]
    >
  > {
    return this.lazilyResolvedBlankNodeOrIriIdentifierInterfacesSync(query);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedBlankNodeOrIriIdentifierInterfacesCountSync(
      query,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.lazilyResolvedBlankNodeOrIriIdentifierInterfacesSync(query).map(
      (objects) => objects.length,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierInterfacesSync(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[]
  > {
    return this.$objectsSync<
      LazilyResolvedBlankNodeOrIriIdentifierInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
    >(
      {
        $filter: LazilyResolvedBlankNodeOrIriIdentifierInterface.$filter,
        $fromRdf: LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdf,
        $fromRdfTypes: [
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdfType,
        ],
      },
      query,
    );
  }

  async lazilyResolvedClassUnionMember1(
    identifier: LazilyResolvedClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember1>> {
    return this.lazilyResolvedClassUnionMember1Sync(identifier);
  }

  lazilyResolvedClassUnionMember1Sync(
    identifier: LazilyResolvedClassUnionMember1.$Identifier,
  ): purify.Either<Error, LazilyResolvedClassUnionMember1> {
    return this.lazilyResolvedClassUnionMember1sSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember1.$Identifier[]>
  > {
    return this.lazilyResolvedClassUnionMember1IdentifiersSync(query);
  }

  lazilyResolvedClassUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Filter>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedClassUnionMember1.$Identifier[]
  > {
    return this.lazilyResolvedClassUnionMember1sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async lazilyResolvedClassUnionMember1s(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember1[]>> {
    return this.lazilyResolvedClassUnionMember1sSync(query);
  }

  async lazilyResolvedClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedClassUnionMember1sCountSync(query);
  }

  lazilyResolvedClassUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.lazilyResolvedClassUnionMember1sSync(query).map(
      (objects) => objects.length,
    );
  }

  lazilyResolvedClassUnionMember1sSync(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Filter>,
  ): purify.Either<Error, readonly LazilyResolvedClassUnionMember1[]> {
    return this.$objectsSync<
      LazilyResolvedClassUnionMember1,
      LazilyResolvedClassUnionMember1.$Filter,
      LazilyResolvedClassUnionMember1.$Identifier
    >(
      {
        $filter: LazilyResolvedClassUnionMember1.$filter,
        $fromRdf: LazilyResolvedClassUnionMember1.$fromRdf,
        $fromRdfTypes: [LazilyResolvedClassUnionMember1.$fromRdfType],
      },
      query,
    );
  }

  async lazilyResolvedClassUnionMember2(
    identifier: LazilyResolvedClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember2>> {
    return this.lazilyResolvedClassUnionMember2Sync(identifier);
  }

  lazilyResolvedClassUnionMember2Sync(
    identifier: LazilyResolvedClassUnionMember2.$Identifier,
  ): purify.Either<Error, LazilyResolvedClassUnionMember2> {
    return this.lazilyResolvedClassUnionMember2sSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember2.$Identifier[]>
  > {
    return this.lazilyResolvedClassUnionMember2IdentifiersSync(query);
  }

  lazilyResolvedClassUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Filter>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedClassUnionMember2.$Identifier[]
  > {
    return this.lazilyResolvedClassUnionMember2sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async lazilyResolvedClassUnionMember2s(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember2[]>> {
    return this.lazilyResolvedClassUnionMember2sSync(query);
  }

  async lazilyResolvedClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedClassUnionMember2sCountSync(query);
  }

  lazilyResolvedClassUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.lazilyResolvedClassUnionMember2sSync(query).map(
      (objects) => objects.length,
    );
  }

  lazilyResolvedClassUnionMember2sSync(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Filter>,
  ): purify.Either<Error, readonly LazilyResolvedClassUnionMember2[]> {
    return this.$objectsSync<
      LazilyResolvedClassUnionMember2,
      LazilyResolvedClassUnionMember2.$Filter,
      LazilyResolvedClassUnionMember2.$Identifier
    >(
      {
        $filter: LazilyResolvedClassUnionMember2.$filter,
        $fromRdf: LazilyResolvedClassUnionMember2.$fromRdf,
        $fromRdfTypes: [LazilyResolvedClassUnionMember2.$fromRdfType],
      },
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember1(
    identifier: LazilyResolvedInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember1>> {
    return this.lazilyResolvedInterfaceUnionMember1Sync(identifier);
  }

  lazilyResolvedInterfaceUnionMember1Sync(
    identifier: LazilyResolvedInterfaceUnionMember1.$Identifier,
  ): purify.Either<Error, LazilyResolvedInterfaceUnionMember1> {
    return this.lazilyResolvedInterfaceUnionMember1sSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember1.$Identifier[]
    >
  > {
    return this.lazilyResolvedInterfaceUnionMember1IdentifiersSync(query);
  }

  lazilyResolvedInterfaceUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Filter>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedInterfaceUnionMember1.$Identifier[]
  > {
    return this.lazilyResolvedInterfaceUnionMember1sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async lazilyResolvedInterfaceUnionMember1s(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember1[]>
  > {
    return this.lazilyResolvedInterfaceUnionMember1sSync(query);
  }

  async lazilyResolvedInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedInterfaceUnionMember1sCountSync(query);
  }

  lazilyResolvedInterfaceUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.lazilyResolvedInterfaceUnionMember1sSync(query).map(
      (objects) => objects.length,
    );
  }

  lazilyResolvedInterfaceUnionMember1sSync(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Filter>,
  ): purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember1[]> {
    return this.$objectsSync<
      LazilyResolvedInterfaceUnionMember1,
      LazilyResolvedInterfaceUnionMember1.$Filter,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >(
      {
        $filter: LazilyResolvedInterfaceUnionMember1.$filter,
        $fromRdf: LazilyResolvedInterfaceUnionMember1.$fromRdf,
        $fromRdfTypes: [LazilyResolvedInterfaceUnionMember1.$fromRdfType],
      },
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember2(
    identifier: LazilyResolvedInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember2>> {
    return this.lazilyResolvedInterfaceUnionMember2Sync(identifier);
  }

  lazilyResolvedInterfaceUnionMember2Sync(
    identifier: LazilyResolvedInterfaceUnionMember2.$Identifier,
  ): purify.Either<Error, LazilyResolvedInterfaceUnionMember2> {
    return this.lazilyResolvedInterfaceUnionMember2sSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember2.$Identifier[]
    >
  > {
    return this.lazilyResolvedInterfaceUnionMember2IdentifiersSync(query);
  }

  lazilyResolvedInterfaceUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Filter>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedInterfaceUnionMember2.$Identifier[]
  > {
    return this.lazilyResolvedInterfaceUnionMember2sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async lazilyResolvedInterfaceUnionMember2s(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember2[]>
  > {
    return this.lazilyResolvedInterfaceUnionMember2sSync(query);
  }

  async lazilyResolvedInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedInterfaceUnionMember2sCountSync(query);
  }

  lazilyResolvedInterfaceUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.lazilyResolvedInterfaceUnionMember2sSync(query).map(
      (objects) => objects.length,
    );
  }

  lazilyResolvedInterfaceUnionMember2sSync(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Filter>,
  ): purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember2[]> {
    return this.$objectsSync<
      LazilyResolvedInterfaceUnionMember2,
      LazilyResolvedInterfaceUnionMember2.$Filter,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >(
      {
        $filter: LazilyResolvedInterfaceUnionMember2.$filter,
        $fromRdf: LazilyResolvedInterfaceUnionMember2.$fromRdf,
        $fromRdfTypes: [LazilyResolvedInterfaceUnionMember2.$fromRdfType],
      },
      query,
    );
  }

  async lazilyResolvedIriIdentifierClass(
    identifier: LazilyResolvedIriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriIdentifierClass>> {
    return this.lazilyResolvedIriIdentifierClassSync(identifier);
  }

  lazilyResolvedIriIdentifierClassSync(
    identifier: LazilyResolvedIriIdentifierClass.$Identifier,
  ): purify.Either<Error, LazilyResolvedIriIdentifierClass> {
    return this.lazilyResolvedIriIdentifierClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedIriIdentifierClass.$Identifier[]
    >
  > {
    return this.lazilyResolvedIriIdentifierClassIdentifiersSync(query);
  }

  lazilyResolvedIriIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Filter>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedIriIdentifierClass.$Identifier[]
  > {
    return this.lazilyResolvedIriIdentifierClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async lazilyResolvedIriIdentifierClasses(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriIdentifierClass[]>
  > {
    return this.lazilyResolvedIriIdentifierClassesSync(query);
  }

  async lazilyResolvedIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedIriIdentifierClassesCountSync(query);
  }

  lazilyResolvedIriIdentifierClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.lazilyResolvedIriIdentifierClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  lazilyResolvedIriIdentifierClassesSync(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Filter>,
  ): purify.Either<Error, readonly LazilyResolvedIriIdentifierClass[]> {
    return this.$objectsSync<
      LazilyResolvedIriIdentifierClass,
      LazilyResolvedIriIdentifierClass.$Filter,
      LazilyResolvedIriIdentifierClass.$Identifier
    >(
      {
        $filter: LazilyResolvedIriIdentifierClass.$filter,
        $fromRdf: LazilyResolvedIriIdentifierClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async lazilyResolvedIriIdentifierInterface(
    identifier: LazilyResolvedIriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriIdentifierInterface>> {
    return this.lazilyResolvedIriIdentifierInterfaceSync(identifier);
  }

  lazilyResolvedIriIdentifierInterfaceSync(
    identifier: LazilyResolvedIriIdentifierInterface.$Identifier,
  ): purify.Either<Error, LazilyResolvedIriIdentifierInterface> {
    return this.lazilyResolvedIriIdentifierInterfacesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedIriIdentifierInterface.$Identifier[]
    >
  > {
    return this.lazilyResolvedIriIdentifierInterfaceIdentifiersSync(query);
  }

  lazilyResolvedIriIdentifierInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Filter>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedIriIdentifierInterface.$Identifier[]
  > {
    return this.lazilyResolvedIriIdentifierInterfacesSync(query).map(
      (objects) => objects.map((object) => object.$identifier),
    );
  }

  async lazilyResolvedIriIdentifierInterfaces(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriIdentifierInterface[]>
  > {
    return this.lazilyResolvedIriIdentifierInterfacesSync(query);
  }

  async lazilyResolvedIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedIriIdentifierInterfacesCountSync(query);
  }

  lazilyResolvedIriIdentifierInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.lazilyResolvedIriIdentifierInterfacesSync(query).map(
      (objects) => objects.length,
    );
  }

  lazilyResolvedIriIdentifierInterfacesSync(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Filter>,
  ): purify.Either<Error, readonly LazilyResolvedIriIdentifierInterface[]> {
    return this.$objectsSync<
      LazilyResolvedIriIdentifierInterface,
      LazilyResolvedIriIdentifierInterface.$Filter,
      LazilyResolvedIriIdentifierInterface.$Identifier
    >(
      {
        $filter: LazilyResolvedIriIdentifierInterface.$filter,
        $fromRdf: LazilyResolvedIriIdentifierInterface.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async lazyPropertiesClass(
    identifier: LazyPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesClass>> {
    return this.lazyPropertiesClassSync(identifier);
  }

  lazyPropertiesClassSync(
    identifier: LazyPropertiesClass.$Identifier,
  ): purify.Either<Error, LazyPropertiesClass> {
    return this.lazyPropertiesClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async lazyPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass.$Identifier[]>> {
    return this.lazyPropertiesClassIdentifiersSync(query);
  }

  lazyPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Filter>,
  ): purify.Either<Error, readonly LazyPropertiesClass.$Identifier[]> {
    return this.lazyPropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async lazyPropertiesClasses(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass[]>> {
    return this.lazyPropertiesClassesSync(query);
  }

  async lazyPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<LazyPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.lazyPropertiesClassesCountSync(query);
  }

  lazyPropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<LazyPropertiesClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.lazyPropertiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  lazyPropertiesClassesSync(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Filter>,
  ): purify.Either<Error, readonly LazyPropertiesClass[]> {
    return this.$objectsSync<
      LazyPropertiesClass,
      LazyPropertiesClass.$Filter,
      LazyPropertiesClass.$Identifier
    >(
      {
        $filter: LazyPropertiesClass.$filter,
        $fromRdf: LazyPropertiesClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async lazyPropertiesInterface(
    identifier: LazyPropertiesInterface.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesInterface>> {
    return this.lazyPropertiesInterfaceSync(identifier);
  }

  lazyPropertiesInterfaceSync(
    identifier: LazyPropertiesInterface.$Identifier,
  ): purify.Either<Error, LazyPropertiesInterface> {
    return this.lazyPropertiesInterfacesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async lazyPropertiesInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazyPropertiesInterface.$Identifier[]>
  > {
    return this.lazyPropertiesInterfaceIdentifiersSync(query);
  }

  lazyPropertiesInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Filter>,
  ): purify.Either<Error, readonly LazyPropertiesInterface.$Identifier[]> {
    return this.lazyPropertiesInterfacesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async lazyPropertiesInterfaces(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesInterface[]>> {
    return this.lazyPropertiesInterfacesSync(query);
  }

  async lazyPropertiesInterfacesCount(
    query?: Pick<$ObjectSet.Query<LazyPropertiesInterface.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.lazyPropertiesInterfacesCountSync(query);
  }

  lazyPropertiesInterfacesCountSync(
    query?: Pick<$ObjectSet.Query<LazyPropertiesInterface.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.lazyPropertiesInterfacesSync(query).map(
      (objects) => objects.length,
    );
  }

  lazyPropertiesInterfacesSync(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Filter>,
  ): purify.Either<Error, readonly LazyPropertiesInterface[]> {
    return this.$objectsSync<
      LazyPropertiesInterface,
      LazyPropertiesInterface.$Filter,
      LazyPropertiesInterface.$Identifier
    >(
      {
        $filter: LazyPropertiesInterface.$filter,
        $fromRdf: LazyPropertiesInterface.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async listPropertiesClass(
    identifier: ListPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ListPropertiesClass>> {
    return this.listPropertiesClassSync(identifier);
  }

  listPropertiesClassSync(
    identifier: ListPropertiesClass.$Identifier,
  ): purify.Either<Error, ListPropertiesClass> {
    return this.listPropertiesClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async listPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<ListPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass.$Identifier[]>> {
    return this.listPropertiesClassIdentifiersSync(query);
  }

  listPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<ListPropertiesClass.$Filter>,
  ): purify.Either<Error, readonly ListPropertiesClass.$Identifier[]> {
    return this.listPropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async listPropertiesClasses(
    query?: $ObjectSet.Query<ListPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass[]>> {
    return this.listPropertiesClassesSync(query);
  }

  async listPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<ListPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.listPropertiesClassesCountSync(query);
  }

  listPropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<ListPropertiesClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.listPropertiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  listPropertiesClassesSync(
    query?: $ObjectSet.Query<ListPropertiesClass.$Filter>,
  ): purify.Either<Error, readonly ListPropertiesClass[]> {
    return this.$objectsSync<
      ListPropertiesClass,
      ListPropertiesClass.$Filter,
      ListPropertiesClass.$Identifier
    >(
      {
        $filter: ListPropertiesClass.$filter,
        $fromRdf: ListPropertiesClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async mutablePropertiesClass(
    identifier: MutablePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, MutablePropertiesClass>> {
    return this.mutablePropertiesClassSync(identifier);
  }

  mutablePropertiesClassSync(
    identifier: MutablePropertiesClass.$Identifier,
  ): purify.Either<Error, MutablePropertiesClass> {
    return this.mutablePropertiesClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async mutablePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly MutablePropertiesClass.$Identifier[]>
  > {
    return this.mutablePropertiesClassIdentifiersSync(query);
  }

  mutablePropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Filter>,
  ): purify.Either<Error, readonly MutablePropertiesClass.$Identifier[]> {
    return this.mutablePropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async mutablePropertiesClasses(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly MutablePropertiesClass[]>> {
    return this.mutablePropertiesClassesSync(query);
  }

  async mutablePropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<MutablePropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.mutablePropertiesClassesCountSync(query);
  }

  mutablePropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<MutablePropertiesClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.mutablePropertiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  mutablePropertiesClassesSync(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Filter>,
  ): purify.Either<Error, readonly MutablePropertiesClass[]> {
    return this.$objectsSync<
      MutablePropertiesClass,
      MutablePropertiesClass.$Filter,
      MutablePropertiesClass.$Identifier
    >(
      {
        $filter: MutablePropertiesClass.$filter,
        $fromRdf: MutablePropertiesClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async nonClass(
    identifier: NonClass.$Identifier,
  ): Promise<purify.Either<Error, NonClass>> {
    return this.nonClassSync(identifier);
  }

  nonClassSync(
    identifier: NonClass.$Identifier,
  ): purify.Either<Error, NonClass> {
    return this.nonClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async nonClassIdentifiers(
    query?: $ObjectSet.Query<NonClass.$Filter>,
  ): Promise<purify.Either<Error, readonly NonClass.$Identifier[]>> {
    return this.nonClassIdentifiersSync(query);
  }

  nonClassIdentifiersSync(
    query?: $ObjectSet.Query<NonClass.$Filter>,
  ): purify.Either<Error, readonly NonClass.$Identifier[]> {
    return this.nonClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async nonClasses(
    query?: $ObjectSet.Query<NonClass.$Filter>,
  ): Promise<purify.Either<Error, readonly NonClass[]>> {
    return this.nonClassesSync(query);
  }

  async nonClassesCount(
    query?: Pick<$ObjectSet.Query<NonClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.nonClassesCountSync(query);
  }

  nonClassesCountSync(
    query?: Pick<$ObjectSet.Query<NonClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.nonClassesSync(query).map((objects) => objects.length);
  }

  nonClassesSync(
    query?: $ObjectSet.Query<NonClass.$Filter>,
  ): purify.Either<Error, readonly NonClass[]> {
    return this.$objectsSync<NonClass, NonClass.$Filter, NonClass.$Identifier>(
      {
        $filter: NonClass.$filter,
        $fromRdf: NonClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async noRdfTypeClassUnionMember1(
    identifier: NoRdfTypeClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnionMember1>> {
    return this.noRdfTypeClassUnionMember1Sync(identifier);
  }

  noRdfTypeClassUnionMember1Sync(
    identifier: NoRdfTypeClassUnionMember1.$Identifier,
  ): purify.Either<Error, NoRdfTypeClassUnionMember1> {
    return this.noRdfTypeClassUnionMember1sSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async noRdfTypeClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly NoRdfTypeClassUnionMember1.$Identifier[]>
  > {
    return this.noRdfTypeClassUnionMember1IdentifiersSync(query);
  }

  noRdfTypeClassUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Filter>,
  ): purify.Either<Error, readonly NoRdfTypeClassUnionMember1.$Identifier[]> {
    return this.noRdfTypeClassUnionMember1sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async noRdfTypeClassUnionMember1s(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnionMember1[]>> {
    return this.noRdfTypeClassUnionMember1sSync(query);
  }

  async noRdfTypeClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.noRdfTypeClassUnionMember1sCountSync(query);
  }

  noRdfTypeClassUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.noRdfTypeClassUnionMember1sSync(query).map(
      (objects) => objects.length,
    );
  }

  noRdfTypeClassUnionMember1sSync(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Filter>,
  ): purify.Either<Error, readonly NoRdfTypeClassUnionMember1[]> {
    return this.$objectsSync<
      NoRdfTypeClassUnionMember1,
      NoRdfTypeClassUnionMember1.$Filter,
      NoRdfTypeClassUnionMember1.$Identifier
    >(
      {
        $filter: NoRdfTypeClassUnionMember1.$filter,
        $fromRdf: NoRdfTypeClassUnionMember1.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async noRdfTypeClassUnionMember2(
    identifier: NoRdfTypeClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnionMember2>> {
    return this.noRdfTypeClassUnionMember2Sync(identifier);
  }

  noRdfTypeClassUnionMember2Sync(
    identifier: NoRdfTypeClassUnionMember2.$Identifier,
  ): purify.Either<Error, NoRdfTypeClassUnionMember2> {
    return this.noRdfTypeClassUnionMember2sSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async noRdfTypeClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly NoRdfTypeClassUnionMember2.$Identifier[]>
  > {
    return this.noRdfTypeClassUnionMember2IdentifiersSync(query);
  }

  noRdfTypeClassUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Filter>,
  ): purify.Either<Error, readonly NoRdfTypeClassUnionMember2.$Identifier[]> {
    return this.noRdfTypeClassUnionMember2sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async noRdfTypeClassUnionMember2s(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnionMember2[]>> {
    return this.noRdfTypeClassUnionMember2sSync(query);
  }

  async noRdfTypeClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.noRdfTypeClassUnionMember2sCountSync(query);
  }

  noRdfTypeClassUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.noRdfTypeClassUnionMember2sSync(query).map(
      (objects) => objects.length,
    );
  }

  noRdfTypeClassUnionMember2sSync(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Filter>,
  ): purify.Either<Error, readonly NoRdfTypeClassUnionMember2[]> {
    return this.$objectsSync<
      NoRdfTypeClassUnionMember2,
      NoRdfTypeClassUnionMember2.$Filter,
      NoRdfTypeClassUnionMember2.$Identifier
    >(
      {
        $filter: NoRdfTypeClassUnionMember2.$filter,
        $fromRdf: NoRdfTypeClassUnionMember2.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async orderedPropertiesClass(
    identifier: OrderedPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, OrderedPropertiesClass>> {
    return this.orderedPropertiesClassSync(identifier);
  }

  orderedPropertiesClassSync(
    identifier: OrderedPropertiesClass.$Identifier,
  ): purify.Either<Error, OrderedPropertiesClass> {
    return this.orderedPropertiesClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async orderedPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly OrderedPropertiesClass.$Identifier[]>
  > {
    return this.orderedPropertiesClassIdentifiersSync(query);
  }

  orderedPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Filter>,
  ): purify.Either<Error, readonly OrderedPropertiesClass.$Identifier[]> {
    return this.orderedPropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async orderedPropertiesClasses(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly OrderedPropertiesClass[]>> {
    return this.orderedPropertiesClassesSync(query);
  }

  async orderedPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<OrderedPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.orderedPropertiesClassesCountSync(query);
  }

  orderedPropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<OrderedPropertiesClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.orderedPropertiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  orderedPropertiesClassesSync(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Filter>,
  ): purify.Either<Error, readonly OrderedPropertiesClass[]> {
    return this.$objectsSync<
      OrderedPropertiesClass,
      OrderedPropertiesClass.$Filter,
      OrderedPropertiesClass.$Identifier
    >(
      {
        $filter: OrderedPropertiesClass.$filter,
        $fromRdf: OrderedPropertiesClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async partialClass(
    identifier: PartialClass.$Identifier,
  ): Promise<purify.Either<Error, PartialClass>> {
    return this.partialClassSync(identifier);
  }

  partialClassSync(
    identifier: PartialClass.$Identifier,
  ): purify.Either<Error, PartialClass> {
    return this.partialClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async partialClassIdentifiers(
    query?: $ObjectSet.Query<PartialClass.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClass.$Identifier[]>> {
    return this.partialClassIdentifiersSync(query);
  }

  partialClassIdentifiersSync(
    query?: $ObjectSet.Query<PartialClass.$Filter>,
  ): purify.Either<Error, readonly PartialClass.$Identifier[]> {
    return this.partialClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async partialClasses(
    query?: $ObjectSet.Query<PartialClass.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClass[]>> {
    return this.partialClassesSync(query);
  }

  async partialClassesCount(
    query?: Pick<$ObjectSet.Query<PartialClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.partialClassesCountSync(query);
  }

  partialClassesCountSync(
    query?: Pick<$ObjectSet.Query<PartialClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.partialClassesSync(query).map((objects) => objects.length);
  }

  partialClassesSync(
    query?: $ObjectSet.Query<PartialClass.$Filter>,
  ): purify.Either<Error, readonly PartialClass[]> {
    return this.$objectsSync<
      PartialClass,
      PartialClass.$Filter,
      PartialClass.$Identifier
    >(
      {
        $filter: PartialClass.$filter,
        $fromRdf: PartialClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async partialClassUnionMember1(
    identifier: PartialClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember1>> {
    return this.partialClassUnionMember1Sync(identifier);
  }

  partialClassUnionMember1Sync(
    identifier: PartialClassUnionMember1.$Identifier,
  ): purify.Either<Error, PartialClassUnionMember1> {
    return this.partialClassUnionMember1sSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async partialClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember1.$Identifier[]>
  > {
    return this.partialClassUnionMember1IdentifiersSync(query);
  }

  partialClassUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Filter>,
  ): purify.Either<Error, readonly PartialClassUnionMember1.$Identifier[]> {
    return this.partialClassUnionMember1sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async partialClassUnionMember1s(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember1[]>> {
    return this.partialClassUnionMember1sSync(query);
  }

  async partialClassUnionMember1sCount(
    query?: Pick<$ObjectSet.Query<PartialClassUnionMember1.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.partialClassUnionMember1sCountSync(query);
  }

  partialClassUnionMember1sCountSync(
    query?: Pick<$ObjectSet.Query<PartialClassUnionMember1.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.partialClassUnionMember1sSync(query).map(
      (objects) => objects.length,
    );
  }

  partialClassUnionMember1sSync(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Filter>,
  ): purify.Either<Error, readonly PartialClassUnionMember1[]> {
    return this.$objectsSync<
      PartialClassUnionMember1,
      PartialClassUnionMember1.$Filter,
      PartialClassUnionMember1.$Identifier
    >(
      {
        $filter: PartialClassUnionMember1.$filter,
        $fromRdf: PartialClassUnionMember1.$fromRdf,
        $fromRdfTypes: [PartialClassUnionMember1.$fromRdfType],
      },
      query,
    );
  }

  async partialClassUnionMember2(
    identifier: PartialClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember2>> {
    return this.partialClassUnionMember2Sync(identifier);
  }

  partialClassUnionMember2Sync(
    identifier: PartialClassUnionMember2.$Identifier,
  ): purify.Either<Error, PartialClassUnionMember2> {
    return this.partialClassUnionMember2sSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async partialClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember2.$Identifier[]>
  > {
    return this.partialClassUnionMember2IdentifiersSync(query);
  }

  partialClassUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Filter>,
  ): purify.Either<Error, readonly PartialClassUnionMember2.$Identifier[]> {
    return this.partialClassUnionMember2sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async partialClassUnionMember2s(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember2[]>> {
    return this.partialClassUnionMember2sSync(query);
  }

  async partialClassUnionMember2sCount(
    query?: Pick<$ObjectSet.Query<PartialClassUnionMember2.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.partialClassUnionMember2sCountSync(query);
  }

  partialClassUnionMember2sCountSync(
    query?: Pick<$ObjectSet.Query<PartialClassUnionMember2.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.partialClassUnionMember2sSync(query).map(
      (objects) => objects.length,
    );
  }

  partialClassUnionMember2sSync(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Filter>,
  ): purify.Either<Error, readonly PartialClassUnionMember2[]> {
    return this.$objectsSync<
      PartialClassUnionMember2,
      PartialClassUnionMember2.$Filter,
      PartialClassUnionMember2.$Identifier
    >(
      {
        $filter: PartialClassUnionMember2.$filter,
        $fromRdf: PartialClassUnionMember2.$fromRdf,
        $fromRdfTypes: [PartialClassUnionMember2.$fromRdfType],
      },
      query,
    );
  }

  async partialInterface(
    identifier: PartialInterface.$Identifier,
  ): Promise<purify.Either<Error, PartialInterface>> {
    return this.partialInterfaceSync(identifier);
  }

  partialInterfaceSync(
    identifier: PartialInterface.$Identifier,
  ): purify.Either<Error, PartialInterface> {
    return this.partialInterfacesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async partialInterfaceIdentifiers(
    query?: $ObjectSet.Query<PartialInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialInterface.$Identifier[]>> {
    return this.partialInterfaceIdentifiersSync(query);
  }

  partialInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<PartialInterface.$Filter>,
  ): purify.Either<Error, readonly PartialInterface.$Identifier[]> {
    return this.partialInterfacesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async partialInterfaces(
    query?: $ObjectSet.Query<PartialInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialInterface[]>> {
    return this.partialInterfacesSync(query);
  }

  async partialInterfacesCount(
    query?: Pick<$ObjectSet.Query<PartialInterface.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.partialInterfacesCountSync(query);
  }

  partialInterfacesCountSync(
    query?: Pick<$ObjectSet.Query<PartialInterface.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.partialInterfacesSync(query).map((objects) => objects.length);
  }

  partialInterfacesSync(
    query?: $ObjectSet.Query<PartialInterface.$Filter>,
  ): purify.Either<Error, readonly PartialInterface[]> {
    return this.$objectsSync<
      PartialInterface,
      PartialInterface.$Filter,
      PartialInterface.$Identifier
    >(
      {
        $filter: PartialInterface.$filter,
        $fromRdf: PartialInterface.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async partialInterfaceUnionMember1(
    identifier: PartialInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember1>> {
    return this.partialInterfaceUnionMember1Sync(identifier);
  }

  partialInterfaceUnionMember1Sync(
    identifier: PartialInterfaceUnionMember1.$Identifier,
  ): purify.Either<Error, PartialInterfaceUnionMember1> {
    return this.partialInterfaceUnionMember1sSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async partialInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember1.$Identifier[]>
  > {
    return this.partialInterfaceUnionMember1IdentifiersSync(query);
  }

  partialInterfaceUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Filter>,
  ): purify.Either<Error, readonly PartialInterfaceUnionMember1.$Identifier[]> {
    return this.partialInterfaceUnionMember1sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async partialInterfaceUnionMember1s(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember1[]>> {
    return this.partialInterfaceUnionMember1sSync(query);
  }

  async partialInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.partialInterfaceUnionMember1sCountSync(query);
  }

  partialInterfaceUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember1.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.partialInterfaceUnionMember1sSync(query).map(
      (objects) => objects.length,
    );
  }

  partialInterfaceUnionMember1sSync(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Filter>,
  ): purify.Either<Error, readonly PartialInterfaceUnionMember1[]> {
    return this.$objectsSync<
      PartialInterfaceUnionMember1,
      PartialInterfaceUnionMember1.$Filter,
      PartialInterfaceUnionMember1.$Identifier
    >(
      {
        $filter: PartialInterfaceUnionMember1.$filter,
        $fromRdf: PartialInterfaceUnionMember1.$fromRdf,
        $fromRdfTypes: [PartialInterfaceUnionMember1.$fromRdfType],
      },
      query,
    );
  }

  async partialInterfaceUnionMember2(
    identifier: PartialInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember2>> {
    return this.partialInterfaceUnionMember2Sync(identifier);
  }

  partialInterfaceUnionMember2Sync(
    identifier: PartialInterfaceUnionMember2.$Identifier,
  ): purify.Either<Error, PartialInterfaceUnionMember2> {
    return this.partialInterfaceUnionMember2sSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async partialInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember2.$Identifier[]>
  > {
    return this.partialInterfaceUnionMember2IdentifiersSync(query);
  }

  partialInterfaceUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Filter>,
  ): purify.Either<Error, readonly PartialInterfaceUnionMember2.$Identifier[]> {
    return this.partialInterfaceUnionMember2sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async partialInterfaceUnionMember2s(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember2[]>> {
    return this.partialInterfaceUnionMember2sSync(query);
  }

  async partialInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.partialInterfaceUnionMember2sCountSync(query);
  }

  partialInterfaceUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember2.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.partialInterfaceUnionMember2sSync(query).map(
      (objects) => objects.length,
    );
  }

  partialInterfaceUnionMember2sSync(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Filter>,
  ): purify.Either<Error, readonly PartialInterfaceUnionMember2[]> {
    return this.$objectsSync<
      PartialInterfaceUnionMember2,
      PartialInterfaceUnionMember2.$Filter,
      PartialInterfaceUnionMember2.$Identifier
    >(
      {
        $filter: PartialInterfaceUnionMember2.$filter,
        $fromRdf: PartialInterfaceUnionMember2.$fromRdf,
        $fromRdfTypes: [PartialInterfaceUnionMember2.$fromRdfType],
      },
      query,
    );
  }

  async propertyCardinalitiesClass(
    identifier: PropertyCardinalitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyCardinalitiesClass>> {
    return this.propertyCardinalitiesClassSync(identifier);
  }

  propertyCardinalitiesClassSync(
    identifier: PropertyCardinalitiesClass.$Identifier,
  ): purify.Either<Error, PropertyCardinalitiesClass> {
    return this.propertyCardinalitiesClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async propertyCardinalitiesClassIdentifiers(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PropertyCardinalitiesClass.$Identifier[]>
  > {
    return this.propertyCardinalitiesClassIdentifiersSync(query);
  }

  propertyCardinalitiesClassIdentifiersSync(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Filter>,
  ): purify.Either<Error, readonly PropertyCardinalitiesClass.$Identifier[]> {
    return this.propertyCardinalitiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async propertyCardinalitiesClasses(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly PropertyCardinalitiesClass[]>> {
    return this.propertyCardinalitiesClassesSync(query);
  }

  async propertyCardinalitiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<PropertyCardinalitiesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.propertyCardinalitiesClassesCountSync(query);
  }

  propertyCardinalitiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<PropertyCardinalitiesClass.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.propertyCardinalitiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  propertyCardinalitiesClassesSync(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Filter>,
  ): purify.Either<Error, readonly PropertyCardinalitiesClass[]> {
    return this.$objectsSync<
      PropertyCardinalitiesClass,
      PropertyCardinalitiesClass.$Filter,
      PropertyCardinalitiesClass.$Identifier
    >(
      {
        $filter: PropertyCardinalitiesClass.$filter,
        $fromRdf: PropertyCardinalitiesClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async propertyVisibilitiesClass(
    identifier: PropertyVisibilitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyVisibilitiesClass>> {
    return this.propertyVisibilitiesClassSync(identifier);
  }

  propertyVisibilitiesClassSync(
    identifier: PropertyVisibilitiesClass.$Identifier,
  ): purify.Either<Error, PropertyVisibilitiesClass> {
    return this.propertyVisibilitiesClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async propertyVisibilitiesClassIdentifiers(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PropertyVisibilitiesClass.$Identifier[]>
  > {
    return this.propertyVisibilitiesClassIdentifiersSync(query);
  }

  propertyVisibilitiesClassIdentifiersSync(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Filter>,
  ): purify.Either<Error, readonly PropertyVisibilitiesClass.$Identifier[]> {
    return this.propertyVisibilitiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async propertyVisibilitiesClasses(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly PropertyVisibilitiesClass[]>> {
    return this.propertyVisibilitiesClassesSync(query);
  }

  async propertyVisibilitiesClassesCount(
    query?: Pick<$ObjectSet.Query<PropertyVisibilitiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.propertyVisibilitiesClassesCountSync(query);
  }

  propertyVisibilitiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<PropertyVisibilitiesClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.propertyVisibilitiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  propertyVisibilitiesClassesSync(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Filter>,
  ): purify.Either<Error, readonly PropertyVisibilitiesClass[]> {
    return this.$objectsSync<
      PropertyVisibilitiesClass,
      PropertyVisibilitiesClass.$Filter,
      PropertyVisibilitiesClass.$Identifier
    >(
      {
        $filter: PropertyVisibilitiesClass.$filter,
        $fromRdf: PropertyVisibilitiesClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async recursiveClassUnionMember1(
    identifier: RecursiveClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember1>> {
    return this.recursiveClassUnionMember1Sync(identifier);
  }

  recursiveClassUnionMember1Sync(
    identifier: RecursiveClassUnionMember1.$Identifier,
  ): purify.Either<Error, RecursiveClassUnionMember1> {
    return this.recursiveClassUnionMember1sSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async recursiveClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember1.$Identifier[]>
  > {
    return this.recursiveClassUnionMember1IdentifiersSync(query);
  }

  recursiveClassUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Filter>,
  ): purify.Either<Error, readonly RecursiveClassUnionMember1.$Identifier[]> {
    return this.recursiveClassUnionMember1sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async recursiveClassUnionMember1s(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember1[]>> {
    return this.recursiveClassUnionMember1sSync(query);
  }

  async recursiveClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.recursiveClassUnionMember1sCountSync(query);
  }

  recursiveClassUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember1.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.recursiveClassUnionMember1sSync(query).map(
      (objects) => objects.length,
    );
  }

  recursiveClassUnionMember1sSync(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Filter>,
  ): purify.Either<Error, readonly RecursiveClassUnionMember1[]> {
    return this.$objectsSync<
      RecursiveClassUnionMember1,
      RecursiveClassUnionMember1.$Filter,
      RecursiveClassUnionMember1.$Identifier
    >(
      {
        $filter: RecursiveClassUnionMember1.$filter,
        $fromRdf: RecursiveClassUnionMember1.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async recursiveClassUnionMember2(
    identifier: RecursiveClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember2>> {
    return this.recursiveClassUnionMember2Sync(identifier);
  }

  recursiveClassUnionMember2Sync(
    identifier: RecursiveClassUnionMember2.$Identifier,
  ): purify.Either<Error, RecursiveClassUnionMember2> {
    return this.recursiveClassUnionMember2sSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async recursiveClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember2.$Identifier[]>
  > {
    return this.recursiveClassUnionMember2IdentifiersSync(query);
  }

  recursiveClassUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Filter>,
  ): purify.Either<Error, readonly RecursiveClassUnionMember2.$Identifier[]> {
    return this.recursiveClassUnionMember2sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async recursiveClassUnionMember2s(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember2[]>> {
    return this.recursiveClassUnionMember2sSync(query);
  }

  async recursiveClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.recursiveClassUnionMember2sCountSync(query);
  }

  recursiveClassUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember2.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.recursiveClassUnionMember2sSync(query).map(
      (objects) => objects.length,
    );
  }

  recursiveClassUnionMember2sSync(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Filter>,
  ): purify.Either<Error, readonly RecursiveClassUnionMember2[]> {
    return this.$objectsSync<
      RecursiveClassUnionMember2,
      RecursiveClassUnionMember2.$Filter,
      RecursiveClassUnionMember2.$Identifier
    >(
      {
        $filter: RecursiveClassUnionMember2.$filter,
        $fromRdf: RecursiveClassUnionMember2.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async sha256IriIdentifierClass(
    identifier: Sha256IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, Sha256IriIdentifierClass>> {
    return this.sha256IriIdentifierClassSync(identifier);
  }

  sha256IriIdentifierClassSync(
    identifier: Sha256IriIdentifierClass.$Identifier,
  ): purify.Either<Error, Sha256IriIdentifierClass> {
    return this.sha256IriIdentifierClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async sha256IriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<Sha256IriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly Sha256IriIdentifierClass.$Identifier[]>
  > {
    return this.sha256IriIdentifierClassIdentifiersSync(query);
  }

  sha256IriIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<Sha256IriIdentifierClass.$Filter>,
  ): purify.Either<Error, readonly Sha256IriIdentifierClass.$Identifier[]> {
    return this.sha256IriIdentifierClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async sha256IriIdentifierClasses(
    query?: $ObjectSet.Query<Sha256IriIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly Sha256IriIdentifierClass[]>> {
    return this.sha256IriIdentifierClassesSync(query);
  }

  async sha256IriIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<Sha256IriIdentifierClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.sha256IriIdentifierClassesCountSync(query);
  }

  sha256IriIdentifierClassesCountSync(
    query?: Pick<$ObjectSet.Query<Sha256IriIdentifierClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.sha256IriIdentifierClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  sha256IriIdentifierClassesSync(
    query?: $ObjectSet.Query<Sha256IriIdentifierClass.$Filter>,
  ): purify.Either<Error, readonly Sha256IriIdentifierClass[]> {
    return this.$objectsSync<
      Sha256IriIdentifierClass,
      Sha256IriIdentifierClass.$Filter,
      Sha256IriIdentifierClass.$Identifier
    >(
      {
        $filter: Sha256IriIdentifierClass.$filter,
        $fromRdf: Sha256IriIdentifierClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async termPropertiesClass(
    identifier: TermPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, TermPropertiesClass>> {
    return this.termPropertiesClassSync(identifier);
  }

  termPropertiesClassSync(
    identifier: TermPropertiesClass.$Identifier,
  ): purify.Either<Error, TermPropertiesClass> {
    return this.termPropertiesClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async termPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<TermPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass.$Identifier[]>> {
    return this.termPropertiesClassIdentifiersSync(query);
  }

  termPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<TermPropertiesClass.$Filter>,
  ): purify.Either<Error, readonly TermPropertiesClass.$Identifier[]> {
    return this.termPropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async termPropertiesClasses(
    query?: $ObjectSet.Query<TermPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass[]>> {
    return this.termPropertiesClassesSync(query);
  }

  async termPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<TermPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.termPropertiesClassesCountSync(query);
  }

  termPropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<TermPropertiesClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.termPropertiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  termPropertiesClassesSync(
    query?: $ObjectSet.Query<TermPropertiesClass.$Filter>,
  ): purify.Either<Error, readonly TermPropertiesClass[]> {
    return this.$objectsSync<
      TermPropertiesClass,
      TermPropertiesClass.$Filter,
      TermPropertiesClass.$Identifier
    >(
      {
        $filter: TermPropertiesClass.$filter,
        $fromRdf: TermPropertiesClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async unionDiscriminantsClass(
    identifier: UnionDiscriminantsClass.$Identifier,
  ): Promise<purify.Either<Error, UnionDiscriminantsClass>> {
    return this.unionDiscriminantsClassSync(identifier);
  }

  unionDiscriminantsClassSync(
    identifier: UnionDiscriminantsClass.$Identifier,
  ): purify.Either<Error, UnionDiscriminantsClass> {
    return this.unionDiscriminantsClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async unionDiscriminantsClassIdentifiers(
    query?: $ObjectSet.Query<UnionDiscriminantsClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly UnionDiscriminantsClass.$Identifier[]>
  > {
    return this.unionDiscriminantsClassIdentifiersSync(query);
  }

  unionDiscriminantsClassIdentifiersSync(
    query?: $ObjectSet.Query<UnionDiscriminantsClass.$Filter>,
  ): purify.Either<Error, readonly UnionDiscriminantsClass.$Identifier[]> {
    return this.unionDiscriminantsClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async unionDiscriminantsClasses(
    query?: $ObjectSet.Query<UnionDiscriminantsClass.$Filter>,
  ): Promise<purify.Either<Error, readonly UnionDiscriminantsClass[]>> {
    return this.unionDiscriminantsClassesSync(query);
  }

  async unionDiscriminantsClassesCount(
    query?: Pick<$ObjectSet.Query<UnionDiscriminantsClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.unionDiscriminantsClassesCountSync(query);
  }

  unionDiscriminantsClassesCountSync(
    query?: Pick<$ObjectSet.Query<UnionDiscriminantsClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.unionDiscriminantsClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  unionDiscriminantsClassesSync(
    query?: $ObjectSet.Query<UnionDiscriminantsClass.$Filter>,
  ): purify.Either<Error, readonly UnionDiscriminantsClass[]> {
    return this.$objectsSync<
      UnionDiscriminantsClass,
      UnionDiscriminantsClass.$Filter,
      UnionDiscriminantsClass.$Identifier
    >(
      {
        $filter: UnionDiscriminantsClass.$filter,
        $fromRdf: UnionDiscriminantsClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async uuidV4IriIdentifierClass(
    identifier: UuidV4IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriIdentifierClass>> {
    return this.uuidV4IriIdentifierClassSync(identifier);
  }

  uuidV4IriIdentifierClassSync(
    identifier: UuidV4IriIdentifierClass.$Identifier,
  ): purify.Either<Error, UuidV4IriIdentifierClass> {
    return this.uuidV4IriIdentifierClassesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async uuidV4IriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<UuidV4IriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly UuidV4IriIdentifierClass.$Identifier[]>
  > {
    return this.uuidV4IriIdentifierClassIdentifiersSync(query);
  }

  uuidV4IriIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<UuidV4IriIdentifierClass.$Filter>,
  ): purify.Either<Error, readonly UuidV4IriIdentifierClass.$Identifier[]> {
    return this.uuidV4IriIdentifierClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async uuidV4IriIdentifierClasses(
    query?: $ObjectSet.Query<UuidV4IriIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly UuidV4IriIdentifierClass[]>> {
    return this.uuidV4IriIdentifierClassesSync(query);
  }

  async uuidV4IriIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<UuidV4IriIdentifierClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.uuidV4IriIdentifierClassesCountSync(query);
  }

  uuidV4IriIdentifierClassesCountSync(
    query?: Pick<$ObjectSet.Query<UuidV4IriIdentifierClass.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.uuidV4IriIdentifierClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  uuidV4IriIdentifierClassesSync(
    query?: $ObjectSet.Query<UuidV4IriIdentifierClass.$Filter>,
  ): purify.Either<Error, readonly UuidV4IriIdentifierClass[]> {
    return this.$objectsSync<
      UuidV4IriIdentifierClass,
      UuidV4IriIdentifierClass.$Filter,
      UuidV4IriIdentifierClass.$Identifier
    >(
      {
        $filter: UuidV4IriIdentifierClass.$filter,
        $fromRdf: UuidV4IriIdentifierClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async uuidV4IriIdentifierInterface(
    identifier: UuidV4IriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriIdentifierInterface>> {
    return this.uuidV4IriIdentifierInterfaceSync(identifier);
  }

  uuidV4IriIdentifierInterfaceSync(
    identifier: UuidV4IriIdentifierInterface.$Identifier,
  ): purify.Either<Error, UuidV4IriIdentifierInterface> {
    return this.uuidV4IriIdentifierInterfacesSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async uuidV4IriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<UuidV4IriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly UuidV4IriIdentifierInterface.$Identifier[]>
  > {
    return this.uuidV4IriIdentifierInterfaceIdentifiersSync(query);
  }

  uuidV4IriIdentifierInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<UuidV4IriIdentifierInterface.$Filter>,
  ): purify.Either<Error, readonly UuidV4IriIdentifierInterface.$Identifier[]> {
    return this.uuidV4IriIdentifierInterfacesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async uuidV4IriIdentifierInterfaces(
    query?: $ObjectSet.Query<UuidV4IriIdentifierInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly UuidV4IriIdentifierInterface[]>> {
    return this.uuidV4IriIdentifierInterfacesSync(query);
  }

  async uuidV4IriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<UuidV4IriIdentifierInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.uuidV4IriIdentifierInterfacesCountSync(query);
  }

  uuidV4IriIdentifierInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<UuidV4IriIdentifierInterface.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.uuidV4IriIdentifierInterfacesSync(query).map(
      (objects) => objects.length,
    );
  }

  uuidV4IriIdentifierInterfacesSync(
    query?: $ObjectSet.Query<UuidV4IriIdentifierInterface.$Filter>,
  ): purify.Either<Error, readonly UuidV4IriIdentifierInterface[]> {
    return this.$objectsSync<
      UuidV4IriIdentifierInterface,
      UuidV4IriIdentifierInterface.$Filter,
      UuidV4IriIdentifierInterface.$Identifier
    >(
      {
        $filter: UuidV4IriIdentifierInterface.$filter,
        $fromRdf: UuidV4IriIdentifierInterface.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async classUnion(
    identifier: ClassUnion.$Identifier,
  ): Promise<purify.Either<Error, ClassUnion>> {
    return this.classUnionSync(identifier);
  }

  classUnionSync(
    identifier: ClassUnion.$Identifier,
  ): purify.Either<Error, ClassUnion> {
    return this.classUnionsSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async classUnionIdentifiers(
    query?: $ObjectSet.Query<ClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnion.$Identifier[]>> {
    return this.classUnionIdentifiersSync(query);
  }

  classUnionIdentifiersSync(
    query?: $ObjectSet.Query<ClassUnion.$Filter>,
  ): purify.Either<Error, readonly ClassUnion.$Identifier[]> {
    return this.classUnionsSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async classUnions(
    query?: $ObjectSet.Query<ClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnion[]>> {
    return this.classUnionsSync(query);
  }

  async classUnionsCount(
    query?: Pick<$ObjectSet.Query<ClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.classUnionsCountSync(query);
  }

  classUnionsCountSync(
    query?: Pick<$ObjectSet.Query<ClassUnion.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.classUnionsSync(query).map((objects) => objects.length);
  }

  classUnionsSync(
    query?: $ObjectSet.Query<ClassUnion.$Filter>,
  ): purify.Either<Error, readonly ClassUnion[]> {
    return this.$objectUnionsSync<
      ClassUnion,
      ClassUnion.$Filter,
      ClassUnion.$Identifier
    >(
      [
        {
          $filter: ClassUnion.$filter,
          $fromRdf: ClassUnionMember1.$fromRdf,
          $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
        },
        {
          $filter: ClassUnion.$filter,
          $fromRdf: ClassUnionMember2.$fromRdf,
          $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async flattenClassUnion(
    identifier: FlattenClassUnion.$Identifier,
  ): Promise<purify.Either<Error, FlattenClassUnion>> {
    return this.flattenClassUnionSync(identifier);
  }

  flattenClassUnionSync(
    identifier: FlattenClassUnion.$Identifier,
  ): purify.Either<Error, FlattenClassUnion> {
    return this.flattenClassUnionsSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async flattenClassUnionIdentifiers(
    query?: $ObjectSet.Query<FlattenClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnion.$Identifier[]>> {
    return this.flattenClassUnionIdentifiersSync(query);
  }

  flattenClassUnionIdentifiersSync(
    query?: $ObjectSet.Query<FlattenClassUnion.$Filter>,
  ): purify.Either<Error, readonly FlattenClassUnion.$Identifier[]> {
    return this.flattenClassUnionsSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async flattenClassUnions(
    query?: $ObjectSet.Query<FlattenClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnion[]>> {
    return this.flattenClassUnionsSync(query);
  }

  async flattenClassUnionsCount(
    query?: Pick<$ObjectSet.Query<FlattenClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.flattenClassUnionsCountSync(query);
  }

  flattenClassUnionsCountSync(
    query?: Pick<$ObjectSet.Query<FlattenClassUnion.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.flattenClassUnionsSync(query).map((objects) => objects.length);
  }

  flattenClassUnionsSync(
    query?: $ObjectSet.Query<FlattenClassUnion.$Filter>,
  ): purify.Either<Error, readonly FlattenClassUnion[]> {
    return this.$objectUnionsSync<
      FlattenClassUnion,
      FlattenClassUnion.$Filter,
      FlattenClassUnion.$Identifier
    >(
      [
        {
          $filter: FlattenClassUnion.$filter,
          $fromRdf: ClassUnionMember1.$fromRdf,
          $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
        },
        {
          $filter: FlattenClassUnion.$filter,
          $fromRdf: ClassUnionMember2.$fromRdf,
          $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
        },
        {
          $filter: FlattenClassUnion.$filter,
          $fromRdf: FlattenClassUnionMember3.$fromRdf,
          $fromRdfTypes: [FlattenClassUnionMember3.$fromRdfType],
        },
      ],
      query,
    );
  }

  async interfaceUnion(
    identifier: InterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnion>> {
    return this.interfaceUnionSync(identifier);
  }

  interfaceUnionSync(
    identifier: InterfaceUnion.$Identifier,
  ): purify.Either<Error, InterfaceUnion> {
    return this.interfaceUnionsSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async interfaceUnionIdentifiers(
    query?: $ObjectSet.Query<InterfaceUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion.$Identifier[]>> {
    return this.interfaceUnionIdentifiersSync(query);
  }

  interfaceUnionIdentifiersSync(
    query?: $ObjectSet.Query<InterfaceUnion.$Filter>,
  ): purify.Either<Error, readonly InterfaceUnion.$Identifier[]> {
    return this.interfaceUnionsSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async interfaceUnions(
    query?: $ObjectSet.Query<InterfaceUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion[]>> {
    return this.interfaceUnionsSync(query);
  }

  async interfaceUnionsCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.interfaceUnionsCountSync(query);
  }

  interfaceUnionsCountSync(
    query?: Pick<$ObjectSet.Query<InterfaceUnion.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.interfaceUnionsSync(query).map((objects) => objects.length);
  }

  interfaceUnionsSync(
    query?: $ObjectSet.Query<InterfaceUnion.$Filter>,
  ): purify.Either<Error, readonly InterfaceUnion[]> {
    return this.$objectUnionsSync<
      InterfaceUnion,
      InterfaceUnion.$Filter,
      InterfaceUnion.$Identifier
    >(
      [
        {
          $filter: InterfaceUnion.$filter,
          $fromRdf: InterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [InterfaceUnionMember1.$fromRdfType],
        },
        {
          $filter: InterfaceUnion.$filter,
          $fromRdf: InterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [InterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedClassUnion(
    identifier: LazilyResolvedClassUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnion>> {
    return this.lazilyResolvedClassUnionSync(identifier);
  }

  lazilyResolvedClassUnionSync(
    identifier: LazilyResolvedClassUnion.$Identifier,
  ): purify.Either<Error, LazilyResolvedClassUnion> {
    return this.lazilyResolvedClassUnionsSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnion.$Identifier[]>
  > {
    return this.lazilyResolvedClassUnionIdentifiersSync(query);
  }

  lazilyResolvedClassUnionIdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Filter>,
  ): purify.Either<Error, readonly LazilyResolvedClassUnion.$Identifier[]> {
    return this.lazilyResolvedClassUnionsSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async lazilyResolvedClassUnions(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnion[]>> {
    return this.lazilyResolvedClassUnionsSync(query);
  }

  async lazilyResolvedClassUnionsCount(
    query?: Pick<$ObjectSet.Query<LazilyResolvedClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedClassUnionsCountSync(query);
  }

  lazilyResolvedClassUnionsCountSync(
    query?: Pick<$ObjectSet.Query<LazilyResolvedClassUnion.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.lazilyResolvedClassUnionsSync(query).map(
      (objects) => objects.length,
    );
  }

  lazilyResolvedClassUnionsSync(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Filter>,
  ): purify.Either<Error, readonly LazilyResolvedClassUnion[]> {
    return this.$objectUnionsSync<
      LazilyResolvedClassUnion,
      LazilyResolvedClassUnion.$Filter,
      LazilyResolvedClassUnion.$Identifier
    >(
      [
        {
          $filter: LazilyResolvedClassUnion.$filter,
          $fromRdf: LazilyResolvedClassUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember1.$fromRdfType],
        },
        {
          $filter: LazilyResolvedClassUnion.$filter,
          $fromRdf: LazilyResolvedClassUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedInterfaceUnion(
    identifier: LazilyResolvedInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnion>> {
    return this.lazilyResolvedInterfaceUnionSync(identifier);
  }

  lazilyResolvedInterfaceUnionSync(
    identifier: LazilyResolvedInterfaceUnion.$Identifier,
  ): purify.Either<Error, LazilyResolvedInterfaceUnion> {
    return this.lazilyResolvedInterfaceUnionsSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnion.$Identifier[]>
  > {
    return this.lazilyResolvedInterfaceUnionIdentifiersSync(query);
  }

  lazilyResolvedInterfaceUnionIdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Filter>,
  ): purify.Either<Error, readonly LazilyResolvedInterfaceUnion.$Identifier[]> {
    return this.lazilyResolvedInterfaceUnionsSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async lazilyResolvedInterfaceUnions(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedInterfaceUnion[]>> {
    return this.lazilyResolvedInterfaceUnionsSync(query);
  }

  async lazilyResolvedInterfaceUnionsCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedInterfaceUnionsCountSync(query);
  }

  lazilyResolvedInterfaceUnionsCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Filter>,
      "filter"
    >,
  ): purify.Either<Error, number> {
    return this.lazilyResolvedInterfaceUnionsSync(query).map(
      (objects) => objects.length,
    );
  }

  lazilyResolvedInterfaceUnionsSync(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Filter>,
  ): purify.Either<Error, readonly LazilyResolvedInterfaceUnion[]> {
    return this.$objectUnionsSync<
      LazilyResolvedInterfaceUnion,
      LazilyResolvedInterfaceUnion.$Filter,
      LazilyResolvedInterfaceUnion.$Identifier
    >(
      [
        {
          $filter: LazilyResolvedInterfaceUnion.$filter,
          $fromRdf: LazilyResolvedInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember1.$fromRdfType],
        },
        {
          $filter: LazilyResolvedInterfaceUnion.$filter,
          $fromRdf: LazilyResolvedInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async noRdfTypeClassUnion(
    identifier: NoRdfTypeClassUnion.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnion>> {
    return this.noRdfTypeClassUnionSync(identifier);
  }

  noRdfTypeClassUnionSync(
    identifier: NoRdfTypeClassUnion.$Identifier,
  ): purify.Either<Error, NoRdfTypeClassUnion> {
    return this.noRdfTypeClassUnionsSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async noRdfTypeClassUnionIdentifiers(
    query?: $ObjectSet.Query<NoRdfTypeClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnion.$Identifier[]>> {
    return this.noRdfTypeClassUnionIdentifiersSync(query);
  }

  noRdfTypeClassUnionIdentifiersSync(
    query?: $ObjectSet.Query<NoRdfTypeClassUnion.$Filter>,
  ): purify.Either<Error, readonly NoRdfTypeClassUnion.$Identifier[]> {
    return this.noRdfTypeClassUnionsSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async noRdfTypeClassUnions(
    query?: $ObjectSet.Query<NoRdfTypeClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnion[]>> {
    return this.noRdfTypeClassUnionsSync(query);
  }

  async noRdfTypeClassUnionsCount(
    query?: Pick<$ObjectSet.Query<NoRdfTypeClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.noRdfTypeClassUnionsCountSync(query);
  }

  noRdfTypeClassUnionsCountSync(
    query?: Pick<$ObjectSet.Query<NoRdfTypeClassUnion.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.noRdfTypeClassUnionsSync(query).map(
      (objects) => objects.length,
    );
  }

  noRdfTypeClassUnionsSync(
    query?: $ObjectSet.Query<NoRdfTypeClassUnion.$Filter>,
  ): purify.Either<Error, readonly NoRdfTypeClassUnion[]> {
    return this.$objectUnionsSync<
      NoRdfTypeClassUnion,
      NoRdfTypeClassUnion.$Filter,
      NoRdfTypeClassUnion.$Identifier
    >(
      [
        {
          $filter: NoRdfTypeClassUnion.$filter,
          $fromRdf: NoRdfTypeClassUnionMember1.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: NoRdfTypeClassUnion.$filter,
          $fromRdf: NoRdfTypeClassUnionMember2.$fromRdf,
          $fromRdfTypes: [],
        },
      ],
      query,
    );
  }

  async partialClassUnion(
    identifier: PartialClassUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnion>> {
    return this.partialClassUnionSync(identifier);
  }

  partialClassUnionSync(
    identifier: PartialClassUnion.$Identifier,
  ): purify.Either<Error, PartialClassUnion> {
    return this.partialClassUnionsSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async partialClassUnionIdentifiers(
    query?: $ObjectSet.Query<PartialClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion.$Identifier[]>> {
    return this.partialClassUnionIdentifiersSync(query);
  }

  partialClassUnionIdentifiersSync(
    query?: $ObjectSet.Query<PartialClassUnion.$Filter>,
  ): purify.Either<Error, readonly PartialClassUnion.$Identifier[]> {
    return this.partialClassUnionsSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async partialClassUnions(
    query?: $ObjectSet.Query<PartialClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion[]>> {
    return this.partialClassUnionsSync(query);
  }

  async partialClassUnionsCount(
    query?: Pick<$ObjectSet.Query<PartialClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.partialClassUnionsCountSync(query);
  }

  partialClassUnionsCountSync(
    query?: Pick<$ObjectSet.Query<PartialClassUnion.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.partialClassUnionsSync(query).map((objects) => objects.length);
  }

  partialClassUnionsSync(
    query?: $ObjectSet.Query<PartialClassUnion.$Filter>,
  ): purify.Either<Error, readonly PartialClassUnion[]> {
    return this.$objectUnionsSync<
      PartialClassUnion,
      PartialClassUnion.$Filter,
      PartialClassUnion.$Identifier
    >(
      [
        {
          $filter: PartialClassUnion.$filter,
          $fromRdf: PartialClassUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember1.$fromRdfType],
        },
        {
          $filter: PartialClassUnion.$filter,
          $fromRdf: PartialClassUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialInterfaceUnion(
    identifier: PartialInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnion>> {
    return this.partialInterfaceUnionSync(identifier);
  }

  partialInterfaceUnionSync(
    identifier: PartialInterfaceUnion.$Identifier,
  ): purify.Either<Error, PartialInterfaceUnion> {
    return this.partialInterfaceUnionsSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async partialInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnion.$Identifier[]>
  > {
    return this.partialInterfaceUnionIdentifiersSync(query);
  }

  partialInterfaceUnionIdentifiersSync(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Filter>,
  ): purify.Either<Error, readonly PartialInterfaceUnion.$Identifier[]> {
    return this.partialInterfaceUnionsSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async partialInterfaceUnions(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnion[]>> {
    return this.partialInterfaceUnionsSync(query);
  }

  async partialInterfaceUnionsCount(
    query?: Pick<$ObjectSet.Query<PartialInterfaceUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.partialInterfaceUnionsCountSync(query);
  }

  partialInterfaceUnionsCountSync(
    query?: Pick<$ObjectSet.Query<PartialInterfaceUnion.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.partialInterfaceUnionsSync(query).map(
      (objects) => objects.length,
    );
  }

  partialInterfaceUnionsSync(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Filter>,
  ): purify.Either<Error, readonly PartialInterfaceUnion[]> {
    return this.$objectUnionsSync<
      PartialInterfaceUnion,
      PartialInterfaceUnion.$Filter,
      PartialInterfaceUnion.$Identifier
    >(
      [
        {
          $filter: PartialInterfaceUnion.$filter,
          $fromRdf: PartialInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember1.$fromRdfType],
        },
        {
          $filter: PartialInterfaceUnion.$filter,
          $fromRdf: PartialInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async recursiveClassUnion(
    identifier: RecursiveClassUnion.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnion>> {
    return this.recursiveClassUnionSync(identifier);
  }

  recursiveClassUnionSync(
    identifier: RecursiveClassUnion.$Identifier,
  ): purify.Either<Error, RecursiveClassUnion> {
    return this.recursiveClassUnionsSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async recursiveClassUnionIdentifiers(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion.$Identifier[]>> {
    return this.recursiveClassUnionIdentifiersSync(query);
  }

  recursiveClassUnionIdentifiersSync(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Filter>,
  ): purify.Either<Error, readonly RecursiveClassUnion.$Identifier[]> {
    return this.recursiveClassUnionsSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async recursiveClassUnions(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion[]>> {
    return this.recursiveClassUnionsSync(query);
  }

  async recursiveClassUnionsCount(
    query?: Pick<$ObjectSet.Query<RecursiveClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.recursiveClassUnionsCountSync(query);
  }

  recursiveClassUnionsCountSync(
    query?: Pick<$ObjectSet.Query<RecursiveClassUnion.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.recursiveClassUnionsSync(query).map(
      (objects) => objects.length,
    );
  }

  recursiveClassUnionsSync(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Filter>,
  ): purify.Either<Error, readonly RecursiveClassUnion[]> {
    return this.$objectUnionsSync<
      RecursiveClassUnion,
      RecursiveClassUnion.$Filter,
      RecursiveClassUnion.$Identifier
    >(
      [
        {
          $filter: RecursiveClassUnion.$filter,
          $fromRdf: RecursiveClassUnionMember1.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: RecursiveClassUnion.$filter,
          $fromRdf: RecursiveClassUnionMember2.$fromRdf,
          $fromRdfTypes: [],
        },
      ],
      query,
    );
  }

  async object(
    identifier: $Object.$Identifier,
  ): Promise<purify.Either<Error, $Object>> {
    return this.objectSync(identifier);
  }

  objectSync(identifier: $Object.$Identifier): purify.Either<Error, $Object> {
    return this.objectsSync({
      filter: { $identifier: { in: [identifier] } },
    }).map((objects) => objects[0]);
  }

  async objectIdentifiers(
    query?: $ObjectSet.Query<$Object.$Filter>,
  ): Promise<purify.Either<Error, readonly $Object.$Identifier[]>> {
    return this.objectIdentifiersSync(query);
  }

  objectIdentifiersSync(
    query?: $ObjectSet.Query<$Object.$Filter>,
  ): purify.Either<Error, readonly $Object.$Identifier[]> {
    return this.objectsSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async objects(
    query?: $ObjectSet.Query<$Object.$Filter>,
  ): Promise<purify.Either<Error, readonly $Object[]>> {
    return this.objectsSync(query);
  }

  async objectsCount(
    query?: Pick<$ObjectSet.Query<$Object.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.objectsCountSync(query);
  }

  objectsCountSync(
    query?: Pick<$ObjectSet.Query<$Object.$Filter>, "filter">,
  ): purify.Either<Error, number> {
    return this.objectsSync(query).map((objects) => objects.length);
  }

  objectsSync(
    query?: $ObjectSet.Query<$Object.$Filter>,
  ): purify.Either<Error, readonly $Object[]> {
    return this.$objectUnionsSync<
      $Object,
      $Object.$Filter,
      $Object.$Identifier
    >(
      [
        {
          $filter: $Object.$filter,
          $fromRdf: BlankNodeIdentifierClass.$fromRdf,
          $fromRdfTypes: [BlankNodeIdentifierClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: BlankNodeIdentifierInterface.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: BlankNodeOrIriIdentifierClass.$fromRdf,
          $fromRdfTypes: [BlankNodeOrIriIdentifierClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: BlankNodeOrIriIdentifierInterface.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ClassUnionMember1.$fromRdf,
          $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ClassUnionMember2.$fromRdf,
          $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ConcreteChildClass.$fromRdf,
          $fromRdfTypes: [ConcreteChildClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ConcreteParentClassStatic.$fromRdf,
          $fromRdfTypes: [
            ConcreteParentClassStatic.$fromRdfType,
            ConcreteChildClass.$fromRdfType,
          ],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ConcreteChildInterface.$fromRdf,
          $fromRdfTypes: [ConcreteChildInterface.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ConcreteParentInterfaceStatic.$fromRdf,
          $fromRdfTypes: [
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: BaseInterfaceWithoutPropertiesStatic.$fromRdf,
          $fromRdfTypes: [
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: BaseInterfaceWithPropertiesStatic.$fromRdf,
          $fromRdfTypes: [
            BaseInterfaceWithPropertiesStatic.$fromRdfType,
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ConvertibleTypePropertiesClass.$fromRdf,
          $fromRdfTypes: [ConvertibleTypePropertiesClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: DateUnionPropertiesClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: DefaultValuePropertiesClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: DirectRecursiveClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ExplicitFromToRdfTypesClass.$fromRdf,
          $fromRdfTypes: [ExplicitFromToRdfTypesClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ExplicitRdfTypeClass.$fromRdf,
          $fromRdfTypes: [ExplicitRdfTypeClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ExternClass.$fromRdf,
          $fromRdfTypes: [ExternClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ExternClassPropertyClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: FlattenClassUnionMember3.$fromRdf,
          $fromRdfTypes: [FlattenClassUnionMember3.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: HasValuePropertiesClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: IdentifierOverride5Class.$fromRdf,
          $fromRdfTypes: [IdentifierOverride5Class.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: IdentifierOverride4ClassStatic.$fromRdf,
          $fromRdfTypes: [
            IdentifierOverride4ClassStatic.$fromRdfType,
            IdentifierOverride5Class.$fromRdfType,
          ],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: IdentifierOverride3ClassStatic.$fromRdf,
          $fromRdfTypes: [
            IdentifierOverride3ClassStatic.$fromRdfType,
            IdentifierOverride4ClassStatic.$fromRdfType,
            IdentifierOverride5Class.$fromRdfType,
          ],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: InIdentifierClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: InPropertiesClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: IndirectRecursiveClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: IndirectRecursiveHelperClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: Interface.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: InterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [InterfaceUnionMember1.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: InterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [InterfaceUnionMember2.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: IriIdentifierClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: IriIdentifierInterface.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: JsPrimitiveUnionPropertyClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LanguageInPropertiesClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdf,
          $fromRdfTypes: [
            LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdfType,
          ],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdf,
          $fromRdfTypes: [
            LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdfType,
          ],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LazilyResolvedClassUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember1.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LazilyResolvedClassUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember2.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LazilyResolvedInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember1.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LazilyResolvedInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember2.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LazilyResolvedIriIdentifierClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LazilyResolvedIriIdentifierInterface.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LazyPropertiesClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: PartialClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LazyPropertiesInterface.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: PartialInterface.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ListPropertiesClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: MutablePropertiesClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: NoRdfTypeClassUnionMember1.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: NoRdfTypeClassUnionMember2.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: NonClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: OrderedPropertiesClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: PartialClassUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember1.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: PartialClassUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember2.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: PartialInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember1.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: PartialInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember2.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: PropertyCardinalitiesClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: PropertyVisibilitiesClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: RecursiveClassUnionMember1.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: RecursiveClassUnionMember2.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: Sha256IriIdentifierClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: TermPropertiesClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: UnionDiscriminantsClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: UuidV4IriIdentifierClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: UuidV4IriIdentifierInterface.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: $DefaultPartial.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: $NamedDefaultPartial.$fromRdf,
          $fromRdfTypes: [],
        },
      ],
      query,
    );
  }

  protected $objectsSync<
    ObjectT extends { readonly $identifier: ObjectIdentifierT },
    ObjectFilterT extends {
      readonly $identifier?: {
        readonly in?: readonly (rdfjs.BlankNode | rdfjs.NamedNode)[];
      };
    },
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectType: {
      $filter: (filter: ObjectFilterT, value: ObjectT) => boolean;
      $fromRdf: (
        resource: rdfjsResource.Resource,
        options: { objectSet: $ObjectSet },
      ) => purify.Either<Error, ObjectT>;
      $fromRdfTypes: readonly rdfjs.NamedNode[];
    },
    query?: $ObjectSet.Query<ObjectFilterT>,
  ): purify.Either<Error, readonly ObjectT[]> {
    const limit = query?.limit ?? Number.MAX_SAFE_INTEGER;
    if (limit <= 0) {
      return purify.Either.of([]);
    }

    let offset = query?.offset ?? 0;
    if (offset < 0) {
      offset = 0;
    }

    let resources: { object?: ObjectT; resource: rdfjsResource.Resource }[];
    let sortResources: boolean;
    if (query?.filter?.$identifier?.in) {
      resources = query.filter.$identifier.in.map((identifier) => ({
        resource: this.resourceSet.resource(identifier),
      }));
      sortResources = false;
    } else if (objectType.$fromRdfTypes.length > 0) {
      const identifierSet = new $IdentifierSet();
      resources = [];
      sortResources = true;
      for (const fromRdfType of objectType.$fromRdfTypes) {
        for (const resource of this.resourceSet.instancesOf(fromRdfType)) {
          if (!identifierSet.has(resource.identifier)) {
            identifierSet.add(resource.identifier);
            resources.push({ resource });
          }
        }
      }
    } else {
      const identifierSet = new $IdentifierSet();
      resources = [];
      sortResources = true;
      for (const quad of this.resourceSet.dataset) {
        switch (quad.subject.termType) {
          case "BlankNode":
          case "NamedNode":
            break;
          default:
            continue;
        }

        if (identifierSet.has(quad.subject)) {
          continue;
        }
        identifierSet.add(quad.subject);
        const resource = this.resourceSet.resource(quad.subject);
        // Eagerly eliminate the majority of resources that won't match the object type
        objectType.$fromRdf(resource, { objectSet: this }).ifRight((object) => {
          resources.push({ object, resource });
        });
      }
    }

    if (sortResources) {
      // Sort resources by identifier so limit and offset are deterministic
      resources.sort((left, right) =>
        left.resource.identifier.value.localeCompare(
          right.resource.identifier.value,
        ),
      );
    }

    let objectI = 0;
    const objects: ObjectT[] = [];
    for (let { object, resource } of resources) {
      if (!object) {
        const objectEither = objectType.$fromRdf(resource, { objectSet: this });
        if (objectEither.isLeft()) {
          return objectEither;
        }
        object = objectEither.unsafeCoerce();
      }

      if (query?.filter && !objectType.$filter(query.filter, object)) {
        continue;
      }

      if (objectI++ >= offset) {
        objects.push(object);
        if (objects.length === limit) {
          return purify.Either.of(objects);
        }
      }
    }
    return purify.Either.of(objects);
  }

  protected $objectUnionsSync<
    ObjectT extends { readonly $identifier: ObjectIdentifierT },
    ObjectFilterT extends {
      readonly $identifier?: {
        readonly in?: readonly (rdfjs.BlankNode | rdfjs.NamedNode)[];
      };
    },
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectTypes: readonly {
      $filter: (filter: ObjectFilterT, value: ObjectT) => boolean;
      $fromRdf: (
        resource: rdfjsResource.Resource,
        options: { objectSet: $ObjectSet },
      ) => purify.Either<Error, ObjectT>;
      $fromRdfTypes: readonly rdfjs.NamedNode[];
    }[],
    query?: $ObjectSet.Query<ObjectFilterT>,
  ): purify.Either<Error, readonly ObjectT[]> {
    const limit = query?.limit ?? Number.MAX_SAFE_INTEGER;
    if (limit <= 0) {
      return purify.Either.of([]);
    }

    let offset = query?.offset ?? 0;
    if (offset < 0) {
      offset = 0;
    }

    let resources: {
      object?: ObjectT;
      objectType?: {
        $filter: (filter: ObjectFilterT, value: ObjectT) => boolean;
        $fromRdf: (
          resource: rdfjsResource.Resource,
          options: { objectSet: $ObjectSet },
        ) => purify.Either<Error, ObjectT>;
        $fromRdfTypes: readonly rdfjs.NamedNode[];
      };
      resource: rdfjsResource.Resource;
    }[];
    let sortResources: boolean;
    if (query?.filter?.$identifier?.in) {
      resources = query.filter.$identifier.in.map((identifier) => ({
        resource: this.resourceSet.resource(identifier),
      }));
      sortResources = false;
    } else if (
      objectTypes.every((objectType) => objectType.$fromRdfTypes.length > 0)
    ) {
      const identifierSet = new $IdentifierSet();
      resources = [];
      sortResources = true;
      for (const objectType of objectTypes) {
        for (const fromRdfType of objectType.$fromRdfTypes) {
          for (const resource of this.resourceSet.instancesOf(fromRdfType)) {
            if (!identifierSet.has(resource.identifier)) {
              identifierSet.add(resource.identifier);
              resources.push({ objectType, resource });
            }
          }
        }
      }
    } else {
      const identifierSet = new $IdentifierSet();
      resources = [];
      sortResources = true;
      for (const quad of this.resourceSet.dataset) {
        switch (quad.subject.termType) {
          case "BlankNode":
          case "NamedNode":
            break;
          default:
            continue;
        }

        if (identifierSet.has(quad.subject)) {
          continue;
        }
        identifierSet.add(quad.subject);
        // Eagerly eliminate the majority of resources that won't match the object types
        const resource = this.resourceSet.resource(quad.subject);
        for (const objectType of objectTypes) {
          if (
            objectType
              .$fromRdf(resource, { objectSet: this })
              .ifRight((object) => {
                resources.push({ object, objectType, resource });
              })
              .isRight()
          ) {
            break;
          }
        }
      }
    }

    if (sortResources) {
      // Sort resources by identifier so limit and offset are deterministic
      resources.sort((left, right) =>
        left.resource.identifier.value.localeCompare(
          right.resource.identifier.value,
        ),
      );
    }

    let objectI = 0;
    const objects: ObjectT[] = [];
    for (let { object, objectType, resource } of resources) {
      if (!object) {
        let objectEither: purify.Either<Error, ObjectT>;
        if (objectType) {
          objectEither = objectType.$fromRdf(resource, { objectSet: this });
        } else {
          objectEither = purify.Left(new Error("no object types"));
          for (const tryObjectType of objectTypes) {
            objectEither = tryObjectType.$fromRdf(resource, {
              objectSet: this,
            });
            if (objectEither.isRight()) {
              objectType = tryObjectType;
              break;
            }
          }
        }
        if (objectEither.isLeft()) {
          return objectEither;
        }
        object = objectEither.unsafeCoerce();
      }
      if (!objectType) {
        throw new Error("objectType should be set here");
      }

      if (query?.filter && !objectType.$filter(query.filter, object)) {
        continue;
      }

      if (objectI++ >= offset) {
        objects.push(object);
        if (objects.length === limit) {
          return purify.Either.of(objects);
        }
      }
    }
    return purify.Either.of(objects);
  }
}

export class $SparqlObjectSet implements $ObjectSet {
  protected readonly $countVariable = dataFactory.variable!("count");
  protected readonly $objectVariable = dataFactory.variable!("object");
  protected readonly $sparqlClient: {
    queryBindings: (
      query: string,
    ) => Promise<
      readonly Record<
        string,
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
      >[]
    >;
    queryQuads: (query: string) => Promise<readonly rdfjs.Quad[]>;
  };
  protected readonly $sparqlGenerator = new sparqljs.Generator();

  constructor({
    sparqlClient,
  }: { sparqlClient: $SparqlObjectSet["$sparqlClient"] }) {
    this.$sparqlClient = sparqlClient;
  }

  async baseInterfaceWithoutProperties(
    identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithoutProperties>> {
    return (
      await this.baseInterfaceWithoutPropertieses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async baseInterfaceWithoutPropertiesIdentifiers(
    query?: $SparqlObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithoutPropertiesStatic.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<
      BaseInterfaceWithoutPropertiesStatic.$Filter,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >(BaseInterfaceWithoutPropertiesStatic, query);
  }

  async baseInterfaceWithoutPropertieses(
    query?: $SparqlObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithoutProperties[]>> {
    return this.$objects<
      BaseInterfaceWithoutProperties,
      BaseInterfaceWithoutPropertiesStatic.$Filter,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >(BaseInterfaceWithoutPropertiesStatic, query);
  }

  async baseInterfaceWithoutPropertiesesCount(
    query?: Pick<
      $SparqlObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<BaseInterfaceWithoutPropertiesStatic.$Filter>(
      BaseInterfaceWithoutPropertiesStatic,
      query,
    );
  }

  async baseInterfaceWithProperties(
    identifier: BaseInterfaceWithPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithProperties>> {
    return (
      await this.baseInterfaceWithPropertieses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async baseInterfaceWithPropertiesIdentifiers(
    query?: $SparqlObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithPropertiesStatic.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<
      BaseInterfaceWithPropertiesStatic.$Filter,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >(BaseInterfaceWithPropertiesStatic, query);
  }

  async baseInterfaceWithPropertieses(
    query?: $SparqlObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithProperties[]>> {
    return this.$objects<
      BaseInterfaceWithProperties,
      BaseInterfaceWithPropertiesStatic.$Filter,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >(BaseInterfaceWithPropertiesStatic, query);
  }

  async baseInterfaceWithPropertiesesCount(
    query?: Pick<
      $SparqlObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<BaseInterfaceWithPropertiesStatic.$Filter>(
      BaseInterfaceWithPropertiesStatic,
      query,
    );
  }

  async blankNodeIdentifierClass(
    identifier: BlankNodeIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeIdentifierClass>> {
    return (
      await this.blankNodeIdentifierClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async blankNodeIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<BlankNodeIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeIdentifierClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      BlankNodeIdentifierClass.$Filter,
      BlankNodeIdentifierClass.$Identifier
    >(BlankNodeIdentifierClass, query);
  }

  async blankNodeIdentifierClasses(
    query?: $SparqlObjectSet.Query<BlankNodeIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly BlankNodeIdentifierClass[]>> {
    return this.$objects<
      BlankNodeIdentifierClass,
      BlankNodeIdentifierClass.$Filter,
      BlankNodeIdentifierClass.$Identifier
    >(BlankNodeIdentifierClass, query);
  }

  async blankNodeIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<BlankNodeIdentifierClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<BlankNodeIdentifierClass.$Filter>(
      BlankNodeIdentifierClass,
      query,
    );
  }

  async blankNodeIdentifierInterface(
    identifier: BlankNodeIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeIdentifierInterface>> {
    return (
      await this.blankNodeIdentifierInterfaces({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async blankNodeIdentifierInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<BlankNodeIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeIdentifierInterface.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      BlankNodeIdentifierInterface.$Filter,
      BlankNodeIdentifierInterface.$Identifier
    >(BlankNodeIdentifierInterface, query);
  }

  async blankNodeIdentifierInterfaces(
    query?: $SparqlObjectSet.Query<BlankNodeIdentifierInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly BlankNodeIdentifierInterface[]>> {
    return this.$objects<
      BlankNodeIdentifierInterface,
      BlankNodeIdentifierInterface.$Filter,
      BlankNodeIdentifierInterface.$Identifier
    >(BlankNodeIdentifierInterface, query);
  }

  async blankNodeIdentifierInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<BlankNodeIdentifierInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<BlankNodeIdentifierInterface.$Filter>(
      BlankNodeIdentifierInterface,
      query,
    );
  }

  async blankNodeOrIriIdentifierClass(
    identifier: BlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeOrIriIdentifierClass>> {
    return (
      await this.blankNodeOrIriIdentifierClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async blankNodeOrIriIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<BlankNodeOrIriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeOrIriIdentifierClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      BlankNodeOrIriIdentifierClass.$Filter,
      BlankNodeOrIriIdentifierClass.$Identifier
    >(BlankNodeOrIriIdentifierClass, query);
  }

  async blankNodeOrIriIdentifierClasses(
    query?: $SparqlObjectSet.Query<BlankNodeOrIriIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly BlankNodeOrIriIdentifierClass[]>> {
    return this.$objects<
      BlankNodeOrIriIdentifierClass,
      BlankNodeOrIriIdentifierClass.$Filter,
      BlankNodeOrIriIdentifierClass.$Identifier
    >(BlankNodeOrIriIdentifierClass, query);
  }

  async blankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<BlankNodeOrIriIdentifierClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<BlankNodeOrIriIdentifierClass.$Filter>(
      BlankNodeOrIriIdentifierClass,
      query,
    );
  }

  async blankNodeOrIriIdentifierInterface(
    identifier: BlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeOrIriIdentifierInterface>> {
    return (
      await this.blankNodeOrIriIdentifierInterfaces({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async blankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly BlankNodeOrIriIdentifierInterface.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<
      BlankNodeOrIriIdentifierInterface.$Filter,
      BlankNodeOrIriIdentifierInterface.$Identifier
    >(BlankNodeOrIriIdentifierInterface, query);
  }

  async blankNodeOrIriIdentifierInterfaces(
    query?: $SparqlObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeOrIriIdentifierInterface[]>
  > {
    return this.$objects<
      BlankNodeOrIriIdentifierInterface,
      BlankNodeOrIriIdentifierInterface.$Filter,
      BlankNodeOrIriIdentifierInterface.$Identifier
    >(BlankNodeOrIriIdentifierInterface, query);
  }

  async blankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<BlankNodeOrIriIdentifierInterface.$Filter>(
      BlankNodeOrIriIdentifierInterface,
      query,
    );
  }

  async classUnionMember1(
    identifier: ClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember1>> {
    return (
      await this.classUnionMember1s({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async classUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<ClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1.$Identifier[]>> {
    return this.$objectIdentifiers<
      ClassUnionMember1.$Filter,
      ClassUnionMember1.$Identifier
    >(ClassUnionMember1, query);
  }

  async classUnionMember1s(
    query?: $SparqlObjectSet.Query<ClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1[]>> {
    return this.$objects<
      ClassUnionMember1,
      ClassUnionMember1.$Filter,
      ClassUnionMember1.$Identifier
    >(ClassUnionMember1, query);
  }

  async classUnionMember1sCount(
    query?: Pick<$SparqlObjectSet.Query<ClassUnionMember1.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ClassUnionMember1.$Filter>(
      ClassUnionMember1,
      query,
    );
  }

  async classUnionMember2(
    identifier: ClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember2>> {
    return (
      await this.classUnionMember2s({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async classUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<ClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2.$Identifier[]>> {
    return this.$objectIdentifiers<
      ClassUnionMember2.$Filter,
      ClassUnionMember2.$Identifier
    >(ClassUnionMember2, query);
  }

  async classUnionMember2s(
    query?: $SparqlObjectSet.Query<ClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2[]>> {
    return this.$objects<
      ClassUnionMember2,
      ClassUnionMember2.$Filter,
      ClassUnionMember2.$Identifier
    >(ClassUnionMember2, query);
  }

  async classUnionMember2sCount(
    query?: Pick<$SparqlObjectSet.Query<ClassUnionMember2.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ClassUnionMember2.$Filter>(
      ClassUnionMember2,
      query,
    );
  }

  async concreteChildClass(
    identifier: ConcreteChildClass.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildClass>> {
    return (
      await this.concreteChildClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async concreteChildClassIdentifiers(
    query?: $SparqlObjectSet.Query<ConcreteChildClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      ConcreteChildClass.$Filter,
      ConcreteChildClass.$Identifier
    >(ConcreteChildClass, query);
  }

  async concreteChildClasses(
    query?: $SparqlObjectSet.Query<ConcreteChildClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass[]>> {
    return this.$objects<
      ConcreteChildClass,
      ConcreteChildClass.$Filter,
      ConcreteChildClass.$Identifier
    >(ConcreteChildClass, query);
  }

  async concreteChildClassesCount(
    query?: Pick<$SparqlObjectSet.Query<ConcreteChildClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ConcreteChildClass.$Filter>(
      ConcreteChildClass,
      query,
    );
  }

  async concreteChildInterface(
    identifier: ConcreteChildInterface.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildInterface>> {
    return (
      await this.concreteChildInterfaces({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async concreteChildInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<ConcreteChildInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ConcreteChildInterface.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      ConcreteChildInterface.$Filter,
      ConcreteChildInterface.$Identifier
    >(ConcreteChildInterface, query);
  }

  async concreteChildInterfaces(
    query?: $SparqlObjectSet.Query<ConcreteChildInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly ConcreteChildInterface[]>> {
    return this.$objects<
      ConcreteChildInterface,
      ConcreteChildInterface.$Filter,
      ConcreteChildInterface.$Identifier
    >(ConcreteChildInterface, query);
  }

  async concreteChildInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ConcreteChildInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ConcreteChildInterface.$Filter>(
      ConcreteChildInterface,
      query,
    );
  }

  async concreteParentClass(
    identifier: ConcreteParentClassStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentClass>> {
    return (
      await this.concreteParentClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async concreteParentClassIdentifiers(
    query?: $SparqlObjectSet.Query<ConcreteParentClassStatic.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentClassStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      ConcreteParentClassStatic.$Filter,
      ConcreteParentClassStatic.$Identifier
    >(ConcreteParentClassStatic, query);
  }

  async concreteParentClasses(
    query?: $SparqlObjectSet.Query<ConcreteParentClassStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly ConcreteParentClass[]>> {
    return this.$objects<
      ConcreteParentClass,
      ConcreteParentClassStatic.$Filter,
      ConcreteParentClassStatic.$Identifier
    >(ConcreteParentClassStatic, query);
  }

  async concreteParentClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ConcreteParentClassStatic.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ConcreteParentClassStatic.$Filter>(
      ConcreteParentClassStatic,
      query,
    );
  }

  async concreteParentInterface(
    identifier: ConcreteParentInterfaceStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentInterface>> {
    return (
      await this.concreteParentInterfaces({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async concreteParentInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<ConcreteParentInterfaceStatic.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentInterfaceStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      ConcreteParentInterfaceStatic.$Filter,
      ConcreteParentInterfaceStatic.$Identifier
    >(ConcreteParentInterfaceStatic, query);
  }

  async concreteParentInterfaces(
    query?: $SparqlObjectSet.Query<ConcreteParentInterfaceStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly ConcreteParentInterface[]>> {
    return this.$objects<
      ConcreteParentInterface,
      ConcreteParentInterfaceStatic.$Filter,
      ConcreteParentInterfaceStatic.$Identifier
    >(ConcreteParentInterfaceStatic, query);
  }

  async concreteParentInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ConcreteParentInterfaceStatic.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ConcreteParentInterfaceStatic.$Filter>(
      ConcreteParentInterfaceStatic,
      query,
    );
  }

  async convertibleTypePropertiesClass(
    identifier: ConvertibleTypePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ConvertibleTypePropertiesClass>> {
    return (
      await this.convertibleTypePropertiesClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async convertibleTypePropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<ConvertibleTypePropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ConvertibleTypePropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      ConvertibleTypePropertiesClass.$Filter,
      ConvertibleTypePropertiesClass.$Identifier
    >(ConvertibleTypePropertiesClass, query);
  }

  async convertibleTypePropertiesClasses(
    query?: $SparqlObjectSet.Query<ConvertibleTypePropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ConvertibleTypePropertiesClass[]>> {
    return this.$objects<
      ConvertibleTypePropertiesClass,
      ConvertibleTypePropertiesClass.$Filter,
      ConvertibleTypePropertiesClass.$Identifier
    >(ConvertibleTypePropertiesClass, query);
  }

  async convertibleTypePropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ConvertibleTypePropertiesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ConvertibleTypePropertiesClass.$Filter>(
      ConvertibleTypePropertiesClass,
      query,
    );
  }

  async dateUnionPropertiesClass(
    identifier: DateUnionPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, DateUnionPropertiesClass>> {
    return (
      await this.dateUnionPropertiesClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async dateUnionPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<DateUnionPropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly DateUnionPropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      DateUnionPropertiesClass.$Filter,
      DateUnionPropertiesClass.$Identifier
    >(DateUnionPropertiesClass, query);
  }

  async dateUnionPropertiesClasses(
    query?: $SparqlObjectSet.Query<DateUnionPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly DateUnionPropertiesClass[]>> {
    return this.$objects<
      DateUnionPropertiesClass,
      DateUnionPropertiesClass.$Filter,
      DateUnionPropertiesClass.$Identifier
    >(DateUnionPropertiesClass, query);
  }

  async dateUnionPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<DateUnionPropertiesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<DateUnionPropertiesClass.$Filter>(
      DateUnionPropertiesClass,
      query,
    );
  }

  async defaultValuePropertiesClass(
    identifier: DefaultValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, DefaultValuePropertiesClass>> {
    return (
      await this.defaultValuePropertiesClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async defaultValuePropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<DefaultValuePropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly DefaultValuePropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      DefaultValuePropertiesClass.$Filter,
      DefaultValuePropertiesClass.$Identifier
    >(DefaultValuePropertiesClass, query);
  }

  async defaultValuePropertiesClasses(
    query?: $SparqlObjectSet.Query<DefaultValuePropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly DefaultValuePropertiesClass[]>> {
    return this.$objects<
      DefaultValuePropertiesClass,
      DefaultValuePropertiesClass.$Filter,
      DefaultValuePropertiesClass.$Identifier
    >(DefaultValuePropertiesClass, query);
  }

  async defaultValuePropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<DefaultValuePropertiesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<DefaultValuePropertiesClass.$Filter>(
      DefaultValuePropertiesClass,
      query,
    );
  }

  async directRecursiveClass(
    identifier: DirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, DirectRecursiveClass>> {
    return (
      await this.directRecursiveClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async directRecursiveClassIdentifiers(
    query?: $SparqlObjectSet.Query<DirectRecursiveClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly DirectRecursiveClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      DirectRecursiveClass.$Filter,
      DirectRecursiveClass.$Identifier
    >(DirectRecursiveClass, query);
  }

  async directRecursiveClasses(
    query?: $SparqlObjectSet.Query<DirectRecursiveClass.$Filter>,
  ): Promise<purify.Either<Error, readonly DirectRecursiveClass[]>> {
    return this.$objects<
      DirectRecursiveClass,
      DirectRecursiveClass.$Filter,
      DirectRecursiveClass.$Identifier
    >(DirectRecursiveClass, query);
  }

  async directRecursiveClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<DirectRecursiveClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<DirectRecursiveClass.$Filter>(
      DirectRecursiveClass,
      query,
    );
  }

  async explicitFromToRdfTypesClass(
    identifier: ExplicitFromToRdfTypesClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitFromToRdfTypesClass>> {
    return (
      await this.explicitFromToRdfTypesClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async explicitFromToRdfTypesClassIdentifiers(
    query?: $SparqlObjectSet.Query<ExplicitFromToRdfTypesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ExplicitFromToRdfTypesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      ExplicitFromToRdfTypesClass.$Filter,
      ExplicitFromToRdfTypesClass.$Identifier
    >(ExplicitFromToRdfTypesClass, query);
  }

  async explicitFromToRdfTypesClasses(
    query?: $SparqlObjectSet.Query<ExplicitFromToRdfTypesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ExplicitFromToRdfTypesClass[]>> {
    return this.$objects<
      ExplicitFromToRdfTypesClass,
      ExplicitFromToRdfTypesClass.$Filter,
      ExplicitFromToRdfTypesClass.$Identifier
    >(ExplicitFromToRdfTypesClass, query);
  }

  async explicitFromToRdfTypesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ExplicitFromToRdfTypesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ExplicitFromToRdfTypesClass.$Filter>(
      ExplicitFromToRdfTypesClass,
      query,
    );
  }

  async explicitRdfTypeClass(
    identifier: ExplicitRdfTypeClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitRdfTypeClass>> {
    return (
      await this.explicitRdfTypeClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async explicitRdfTypeClassIdentifiers(
    query?: $SparqlObjectSet.Query<ExplicitRdfTypeClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ExplicitRdfTypeClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      ExplicitRdfTypeClass.$Filter,
      ExplicitRdfTypeClass.$Identifier
    >(ExplicitRdfTypeClass, query);
  }

  async explicitRdfTypeClasses(
    query?: $SparqlObjectSet.Query<ExplicitRdfTypeClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ExplicitRdfTypeClass[]>> {
    return this.$objects<
      ExplicitRdfTypeClass,
      ExplicitRdfTypeClass.$Filter,
      ExplicitRdfTypeClass.$Identifier
    >(ExplicitRdfTypeClass, query);
  }

  async explicitRdfTypeClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ExplicitRdfTypeClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ExplicitRdfTypeClass.$Filter>(
      ExplicitRdfTypeClass,
      query,
    );
  }

  async externClassPropertyClass(
    identifier: ExternClassPropertyClass.$Identifier,
  ): Promise<purify.Either<Error, ExternClassPropertyClass>> {
    return (
      await this.externClassPropertyClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async externClassPropertyClassIdentifiers(
    query?: $SparqlObjectSet.Query<ExternClassPropertyClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly ExternClassPropertyClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      ExternClassPropertyClass.$Filter,
      ExternClassPropertyClass.$Identifier
    >(ExternClassPropertyClass, query);
  }

  async externClassPropertyClasses(
    query?: $SparqlObjectSet.Query<ExternClassPropertyClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ExternClassPropertyClass[]>> {
    return this.$objects<
      ExternClassPropertyClass,
      ExternClassPropertyClass.$Filter,
      ExternClassPropertyClass.$Identifier
    >(ExternClassPropertyClass, query);
  }

  async externClassPropertyClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ExternClassPropertyClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ExternClassPropertyClass.$Filter>(
      ExternClassPropertyClass,
      query,
    );
  }

  async flattenClassUnionMember3(
    identifier: FlattenClassUnionMember3.$Identifier,
  ): Promise<purify.Either<Error, FlattenClassUnionMember3>> {
    return (
      await this.flattenClassUnionMember3s({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async flattenClassUnionMember3Identifiers(
    query?: $SparqlObjectSet.Query<FlattenClassUnionMember3.$Filter>,
  ): Promise<
    purify.Either<Error, readonly FlattenClassUnionMember3.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      FlattenClassUnionMember3.$Filter,
      FlattenClassUnionMember3.$Identifier
    >(FlattenClassUnionMember3, query);
  }

  async flattenClassUnionMember3s(
    query?: $SparqlObjectSet.Query<FlattenClassUnionMember3.$Filter>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnionMember3[]>> {
    return this.$objects<
      FlattenClassUnionMember3,
      FlattenClassUnionMember3.$Filter,
      FlattenClassUnionMember3.$Identifier
    >(FlattenClassUnionMember3, query);
  }

  async flattenClassUnionMember3sCount(
    query?: Pick<
      $SparqlObjectSet.Query<FlattenClassUnionMember3.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<FlattenClassUnionMember3.$Filter>(
      FlattenClassUnionMember3,
      query,
    );
  }

  async hasValuePropertiesClass(
    identifier: HasValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, HasValuePropertiesClass>> {
    return (
      await this.hasValuePropertiesClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async hasValuePropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<HasValuePropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly HasValuePropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      HasValuePropertiesClass.$Filter,
      HasValuePropertiesClass.$Identifier
    >(HasValuePropertiesClass, query);
  }

  async hasValuePropertiesClasses(
    query?: $SparqlObjectSet.Query<HasValuePropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly HasValuePropertiesClass[]>> {
    return this.$objects<
      HasValuePropertiesClass,
      HasValuePropertiesClass.$Filter,
      HasValuePropertiesClass.$Identifier
    >(HasValuePropertiesClass, query);
  }

  async hasValuePropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<HasValuePropertiesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<HasValuePropertiesClass.$Filter>(
      HasValuePropertiesClass,
      query,
    );
  }

  async identifierOverride3Class(
    identifier: IdentifierOverride3ClassStatic.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride3Class>> {
    return (
      await this.identifierOverride3Classes({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async identifierOverride3ClassIdentifiers(
    query?: $SparqlObjectSet.Query<IdentifierOverride3ClassStatic.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride3ClassStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      IdentifierOverride3ClassStatic.$Filter,
      IdentifierOverride3ClassStatic.$Identifier
    >(IdentifierOverride3ClassStatic, query);
  }

  async identifierOverride3Classes(
    query?: $SparqlObjectSet.Query<IdentifierOverride3ClassStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride3Class[]>> {
    return this.$objects<
      IdentifierOverride3Class,
      IdentifierOverride3ClassStatic.$Filter,
      IdentifierOverride3ClassStatic.$Identifier
    >(IdentifierOverride3ClassStatic, query);
  }

  async identifierOverride3ClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<IdentifierOverride3ClassStatic.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<IdentifierOverride3ClassStatic.$Filter>(
      IdentifierOverride3ClassStatic,
      query,
    );
  }

  async identifierOverride4Class(
    identifier: IdentifierOverride4ClassStatic.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride4Class>> {
    return (
      await this.identifierOverride4Classes({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async identifierOverride4ClassIdentifiers(
    query?: $SparqlObjectSet.Query<IdentifierOverride4ClassStatic.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride4ClassStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      IdentifierOverride4ClassStatic.$Filter,
      IdentifierOverride4ClassStatic.$Identifier
    >(IdentifierOverride4ClassStatic, query);
  }

  async identifierOverride4Classes(
    query?: $SparqlObjectSet.Query<IdentifierOverride4ClassStatic.$Filter>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride4Class[]>> {
    return this.$objects<
      IdentifierOverride4Class,
      IdentifierOverride4ClassStatic.$Filter,
      IdentifierOverride4ClassStatic.$Identifier
    >(IdentifierOverride4ClassStatic, query);
  }

  async identifierOverride4ClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<IdentifierOverride4ClassStatic.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<IdentifierOverride4ClassStatic.$Filter>(
      IdentifierOverride4ClassStatic,
      query,
    );
  }

  async identifierOverride5Class(
    identifier: IdentifierOverride5Class.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride5Class>> {
    return (
      await this.identifierOverride5Classes({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async identifierOverride5ClassIdentifiers(
    query?: $SparqlObjectSet.Query<IdentifierOverride5Class.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride5Class.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      IdentifierOverride5Class.$Filter,
      IdentifierOverride5Class.$Identifier
    >(IdentifierOverride5Class, query);
  }

  async identifierOverride5Classes(
    query?: $SparqlObjectSet.Query<IdentifierOverride5Class.$Filter>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride5Class[]>> {
    return this.$objects<
      IdentifierOverride5Class,
      IdentifierOverride5Class.$Filter,
      IdentifierOverride5Class.$Identifier
    >(IdentifierOverride5Class, query);
  }

  async identifierOverride5ClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<IdentifierOverride5Class.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<IdentifierOverride5Class.$Filter>(
      IdentifierOverride5Class,
      query,
    );
  }

  async indirectRecursiveClass(
    identifier: IndirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveClass>> {
    return (
      await this.indirectRecursiveClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async indirectRecursiveClassIdentifiers(
    query?: $SparqlObjectSet.Query<IndirectRecursiveClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      IndirectRecursiveClass.$Filter,
      IndirectRecursiveClass.$Identifier
    >(IndirectRecursiveClass, query);
  }

  async indirectRecursiveClasses(
    query?: $SparqlObjectSet.Query<IndirectRecursiveClass.$Filter>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveClass[]>> {
    return this.$objects<
      IndirectRecursiveClass,
      IndirectRecursiveClass.$Filter,
      IndirectRecursiveClass.$Identifier
    >(IndirectRecursiveClass, query);
  }

  async indirectRecursiveClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<IndirectRecursiveClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<IndirectRecursiveClass.$Filter>(
      IndirectRecursiveClass,
      query,
    );
  }

  async indirectRecursiveHelperClass(
    identifier: IndirectRecursiveHelperClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveHelperClass>> {
    return (
      await this.indirectRecursiveHelperClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async indirectRecursiveHelperClassIdentifiers(
    query?: $SparqlObjectSet.Query<IndirectRecursiveHelperClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveHelperClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      IndirectRecursiveHelperClass.$Filter,
      IndirectRecursiveHelperClass.$Identifier
    >(IndirectRecursiveHelperClass, query);
  }

  async indirectRecursiveHelperClasses(
    query?: $SparqlObjectSet.Query<IndirectRecursiveHelperClass.$Filter>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveHelperClass[]>> {
    return this.$objects<
      IndirectRecursiveHelperClass,
      IndirectRecursiveHelperClass.$Filter,
      IndirectRecursiveHelperClass.$Identifier
    >(IndirectRecursiveHelperClass, query);
  }

  async indirectRecursiveHelperClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<IndirectRecursiveHelperClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<IndirectRecursiveHelperClass.$Filter>(
      IndirectRecursiveHelperClass,
      query,
    );
  }

  async inIdentifierClass(
    identifier: InIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, InIdentifierClass>> {
    return (
      await this.inIdentifierClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async inIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<InIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      InIdentifierClass.$Filter,
      InIdentifierClass.$Identifier
    >(InIdentifierClass, query);
  }

  async inIdentifierClasses(
    query?: $SparqlObjectSet.Query<InIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass[]>> {
    return this.$objects<
      InIdentifierClass,
      InIdentifierClass.$Filter,
      InIdentifierClass.$Identifier
    >(InIdentifierClass, query);
  }

  async inIdentifierClassesCount(
    query?: Pick<$SparqlObjectSet.Query<InIdentifierClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<InIdentifierClass.$Filter>(
      InIdentifierClass,
      query,
    );
  }

  async inPropertiesClass(
    identifier: InPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, InPropertiesClass>> {
    return (
      await this.inPropertiesClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async inPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<InPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      InPropertiesClass.$Filter,
      InPropertiesClass.$Identifier
    >(InPropertiesClass, query);
  }

  async inPropertiesClasses(
    query?: $SparqlObjectSet.Query<InPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass[]>> {
    return this.$objects<
      InPropertiesClass,
      InPropertiesClass.$Filter,
      InPropertiesClass.$Identifier
    >(InPropertiesClass, query);
  }

  async inPropertiesClassesCount(
    query?: Pick<$SparqlObjectSet.Query<InPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<InPropertiesClass.$Filter>(
      InPropertiesClass,
      query,
    );
  }

  async interface(
    identifier: Interface.$Identifier,
  ): Promise<purify.Either<Error, Interface>> {
    return (
      await this.interfaces({ filter: { $identifier: { in: [identifier] } } })
    ).map((objects) => objects[0]);
  }

  async interfaceIdentifiers(
    query?: $SparqlObjectSet.Query<Interface.$Filter>,
  ): Promise<purify.Either<Error, readonly Interface.$Identifier[]>> {
    return this.$objectIdentifiers<Interface.$Filter, Interface.$Identifier>(
      Interface,
      query,
    );
  }

  async interfaces(
    query?: $SparqlObjectSet.Query<Interface.$Filter>,
  ): Promise<purify.Either<Error, readonly Interface[]>> {
    return this.$objects<Interface, Interface.$Filter, Interface.$Identifier>(
      Interface,
      query,
    );
  }

  async interfacesCount(
    query?: Pick<$SparqlObjectSet.Query<Interface.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<Interface.$Filter>(Interface, query);
  }

  async interfaceUnionMember1(
    identifier: InterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember1>> {
    return (
      await this.interfaceUnionMember1s({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async interfaceUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<InterfaceUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember1.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      InterfaceUnionMember1.$Filter,
      InterfaceUnionMember1.$Identifier
    >(InterfaceUnionMember1, query);
  }

  async interfaceUnionMember1s(
    query?: $SparqlObjectSet.Query<InterfaceUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember1[]>> {
    return this.$objects<
      InterfaceUnionMember1,
      InterfaceUnionMember1.$Filter,
      InterfaceUnionMember1.$Identifier
    >(InterfaceUnionMember1, query);
  }

  async interfaceUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<InterfaceUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<InterfaceUnionMember1.$Filter>(
      InterfaceUnionMember1,
      query,
    );
  }

  async interfaceUnionMember2(
    identifier: InterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember2>> {
    return (
      await this.interfaceUnionMember2s({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async interfaceUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<InterfaceUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember2.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      InterfaceUnionMember2.$Filter,
      InterfaceUnionMember2.$Identifier
    >(InterfaceUnionMember2, query);
  }

  async interfaceUnionMember2s(
    query?: $SparqlObjectSet.Query<InterfaceUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember2[]>> {
    return this.$objects<
      InterfaceUnionMember2,
      InterfaceUnionMember2.$Filter,
      InterfaceUnionMember2.$Identifier
    >(InterfaceUnionMember2, query);
  }

  async interfaceUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<InterfaceUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<InterfaceUnionMember2.$Filter>(
      InterfaceUnionMember2,
      query,
    );
  }

  async iriIdentifierClass(
    identifier: IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, IriIdentifierClass>> {
    return (
      await this.iriIdentifierClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async iriIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<IriIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly IriIdentifierClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      IriIdentifierClass.$Filter,
      IriIdentifierClass.$Identifier
    >(IriIdentifierClass, query);
  }

  async iriIdentifierClasses(
    query?: $SparqlObjectSet.Query<IriIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly IriIdentifierClass[]>> {
    return this.$objects<
      IriIdentifierClass,
      IriIdentifierClass.$Filter,
      IriIdentifierClass.$Identifier
    >(IriIdentifierClass, query);
  }

  async iriIdentifierClassesCount(
    query?: Pick<$SparqlObjectSet.Query<IriIdentifierClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<IriIdentifierClass.$Filter>(
      IriIdentifierClass,
      query,
    );
  }

  async iriIdentifierInterface(
    identifier: IriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, IriIdentifierInterface>> {
    return (
      await this.iriIdentifierInterfaces({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async iriIdentifierInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<IriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly IriIdentifierInterface.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      IriIdentifierInterface.$Filter,
      IriIdentifierInterface.$Identifier
    >(IriIdentifierInterface, query);
  }

  async iriIdentifierInterfaces(
    query?: $SparqlObjectSet.Query<IriIdentifierInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly IriIdentifierInterface[]>> {
    return this.$objects<
      IriIdentifierInterface,
      IriIdentifierInterface.$Filter,
      IriIdentifierInterface.$Identifier
    >(IriIdentifierInterface, query);
  }

  async iriIdentifierInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<IriIdentifierInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<IriIdentifierInterface.$Filter>(
      IriIdentifierInterface,
      query,
    );
  }

  async jsPrimitiveUnionPropertyClass(
    identifier: JsPrimitiveUnionPropertyClass.$Identifier,
  ): Promise<purify.Either<Error, JsPrimitiveUnionPropertyClass>> {
    return (
      await this.jsPrimitiveUnionPropertyClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async jsPrimitiveUnionPropertyClassIdentifiers(
    query?: $SparqlObjectSet.Query<JsPrimitiveUnionPropertyClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly JsPrimitiveUnionPropertyClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      JsPrimitiveUnionPropertyClass.$Filter,
      JsPrimitiveUnionPropertyClass.$Identifier
    >(JsPrimitiveUnionPropertyClass, query);
  }

  async jsPrimitiveUnionPropertyClasses(
    query?: $SparqlObjectSet.Query<JsPrimitiveUnionPropertyClass.$Filter>,
  ): Promise<purify.Either<Error, readonly JsPrimitiveUnionPropertyClass[]>> {
    return this.$objects<
      JsPrimitiveUnionPropertyClass,
      JsPrimitiveUnionPropertyClass.$Filter,
      JsPrimitiveUnionPropertyClass.$Identifier
    >(JsPrimitiveUnionPropertyClass, query);
  }

  async jsPrimitiveUnionPropertyClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<JsPrimitiveUnionPropertyClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<JsPrimitiveUnionPropertyClass.$Filter>(
      JsPrimitiveUnionPropertyClass,
      query,
    );
  }

  async languageInPropertiesClass(
    identifier: LanguageInPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LanguageInPropertiesClass>> {
    return (
      await this.languageInPropertiesClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async languageInPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<LanguageInPropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LanguageInPropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      LanguageInPropertiesClass.$Filter,
      LanguageInPropertiesClass.$Identifier
    >(LanguageInPropertiesClass, query);
  }

  async languageInPropertiesClasses(
    query?: $SparqlObjectSet.Query<LanguageInPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly LanguageInPropertiesClass[]>> {
    return this.$objects<
      LanguageInPropertiesClass,
      LanguageInPropertiesClass.$Filter,
      LanguageInPropertiesClass.$Identifier
    >(LanguageInPropertiesClass, query);
  }

  async languageInPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<LanguageInPropertiesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LanguageInPropertiesClass.$Filter>(
      LanguageInPropertiesClass,
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClass(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<
    purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierClass>
  > {
    return (
      await this.lazilyResolvedBlankNodeOrIriIdentifierClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
    >(LazilyResolvedBlankNodeOrIriIdentifierClass, query);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClasses(
    query?: $SparqlObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedBlankNodeOrIriIdentifierClass[]>
  > {
    return this.$objects<
      LazilyResolvedBlankNodeOrIriIdentifierClass,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
    >(LazilyResolvedBlankNodeOrIriIdentifierClass, query);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter>(
      LazilyResolvedBlankNodeOrIriIdentifierClass,
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterface(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<
    purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierInterface>
  > {
    return (
      await this.lazilyResolvedBlankNodeOrIriIdentifierInterfaces({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
    >(LazilyResolvedBlankNodeOrIriIdentifierInterface, query);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterfaces(
    query?: $SparqlObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[]
    >
  > {
    return this.$objects<
      LazilyResolvedBlankNodeOrIriIdentifierInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
    >(LazilyResolvedBlankNodeOrIriIdentifierInterface, query);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter>(
      LazilyResolvedBlankNodeOrIriIdentifierInterface,
      query,
    );
  }

  async lazilyResolvedClassUnionMember1(
    identifier: LazilyResolvedClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember1>> {
    return (
      await this.lazilyResolvedClassUnionMember1s({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedClassUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember1.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      LazilyResolvedClassUnionMember1.$Filter,
      LazilyResolvedClassUnionMember1.$Identifier
    >(LazilyResolvedClassUnionMember1, query);
  }

  async lazilyResolvedClassUnionMember1s(
    query?: $SparqlObjectSet.Query<LazilyResolvedClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember1[]>> {
    return this.$objects<
      LazilyResolvedClassUnionMember1,
      LazilyResolvedClassUnionMember1.$Filter,
      LazilyResolvedClassUnionMember1.$Identifier
    >(LazilyResolvedClassUnionMember1, query);
  }

  async lazilyResolvedClassUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedClassUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedClassUnionMember1.$Filter>(
      LazilyResolvedClassUnionMember1,
      query,
    );
  }

  async lazilyResolvedClassUnionMember2(
    identifier: LazilyResolvedClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember2>> {
    return (
      await this.lazilyResolvedClassUnionMember2s({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedClassUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember2.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      LazilyResolvedClassUnionMember2.$Filter,
      LazilyResolvedClassUnionMember2.$Identifier
    >(LazilyResolvedClassUnionMember2, query);
  }

  async lazilyResolvedClassUnionMember2s(
    query?: $SparqlObjectSet.Query<LazilyResolvedClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember2[]>> {
    return this.$objects<
      LazilyResolvedClassUnionMember2,
      LazilyResolvedClassUnionMember2.$Filter,
      LazilyResolvedClassUnionMember2.$Identifier
    >(LazilyResolvedClassUnionMember2, query);
  }

  async lazilyResolvedClassUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedClassUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedClassUnionMember2.$Filter>(
      LazilyResolvedClassUnionMember2,
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember1(
    identifier: LazilyResolvedInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember1>> {
    return (
      await this.lazilyResolvedInterfaceUnionMember1s({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember1.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<
      LazilyResolvedInterfaceUnionMember1.$Filter,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >(LazilyResolvedInterfaceUnionMember1, query);
  }

  async lazilyResolvedInterfaceUnionMember1s(
    query?: $SparqlObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember1[]>
  > {
    return this.$objects<
      LazilyResolvedInterfaceUnionMember1,
      LazilyResolvedInterfaceUnionMember1.$Filter,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >(LazilyResolvedInterfaceUnionMember1, query);
  }

  async lazilyResolvedInterfaceUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedInterfaceUnionMember1.$Filter>(
      LazilyResolvedInterfaceUnionMember1,
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember2(
    identifier: LazilyResolvedInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember2>> {
    return (
      await this.lazilyResolvedInterfaceUnionMember2s({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember2.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<
      LazilyResolvedInterfaceUnionMember2.$Filter,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >(LazilyResolvedInterfaceUnionMember2, query);
  }

  async lazilyResolvedInterfaceUnionMember2s(
    query?: $SparqlObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember2[]>
  > {
    return this.$objects<
      LazilyResolvedInterfaceUnionMember2,
      LazilyResolvedInterfaceUnionMember2.$Filter,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >(LazilyResolvedInterfaceUnionMember2, query);
  }

  async lazilyResolvedInterfaceUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedInterfaceUnionMember2.$Filter>(
      LazilyResolvedInterfaceUnionMember2,
      query,
    );
  }

  async lazilyResolvedIriIdentifierClass(
    identifier: LazilyResolvedIriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriIdentifierClass>> {
    return (
      await this.lazilyResolvedIriIdentifierClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedIriIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedIriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedIriIdentifierClass.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<
      LazilyResolvedIriIdentifierClass.$Filter,
      LazilyResolvedIriIdentifierClass.$Identifier
    >(LazilyResolvedIriIdentifierClass, query);
  }

  async lazilyResolvedIriIdentifierClasses(
    query?: $SparqlObjectSet.Query<LazilyResolvedIriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriIdentifierClass[]>
  > {
    return this.$objects<
      LazilyResolvedIriIdentifierClass,
      LazilyResolvedIriIdentifierClass.$Filter,
      LazilyResolvedIriIdentifierClass.$Identifier
    >(LazilyResolvedIriIdentifierClass, query);
  }

  async lazilyResolvedIriIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedIriIdentifierClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedIriIdentifierClass.$Filter>(
      LazilyResolvedIriIdentifierClass,
      query,
    );
  }

  async lazilyResolvedIriIdentifierInterface(
    identifier: LazilyResolvedIriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriIdentifierInterface>> {
    return (
      await this.lazilyResolvedIriIdentifierInterfaces({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedIriIdentifierInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedIriIdentifierInterface.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<
      LazilyResolvedIriIdentifierInterface.$Filter,
      LazilyResolvedIriIdentifierInterface.$Identifier
    >(LazilyResolvedIriIdentifierInterface, query);
  }

  async lazilyResolvedIriIdentifierInterfaces(
    query?: $SparqlObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriIdentifierInterface[]>
  > {
    return this.$objects<
      LazilyResolvedIriIdentifierInterface,
      LazilyResolvedIriIdentifierInterface.$Filter,
      LazilyResolvedIriIdentifierInterface.$Identifier
    >(LazilyResolvedIriIdentifierInterface, query);
  }

  async lazilyResolvedIriIdentifierInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedIriIdentifierInterface.$Filter>(
      LazilyResolvedIriIdentifierInterface,
      query,
    );
  }

  async lazyPropertiesClass(
    identifier: LazyPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesClass>> {
    return (
      await this.lazyPropertiesClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async lazyPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<LazyPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      LazyPropertiesClass.$Filter,
      LazyPropertiesClass.$Identifier
    >(LazyPropertiesClass, query);
  }

  async lazyPropertiesClasses(
    query?: $SparqlObjectSet.Query<LazyPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass[]>> {
    return this.$objects<
      LazyPropertiesClass,
      LazyPropertiesClass.$Filter,
      LazyPropertiesClass.$Identifier
    >(LazyPropertiesClass, query);
  }

  async lazyPropertiesClassesCount(
    query?: Pick<$SparqlObjectSet.Query<LazyPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazyPropertiesClass.$Filter>(
      LazyPropertiesClass,
      query,
    );
  }

  async lazyPropertiesInterface(
    identifier: LazyPropertiesInterface.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesInterface>> {
    return (
      await this.lazyPropertiesInterfaces({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async lazyPropertiesInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<LazyPropertiesInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazyPropertiesInterface.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      LazyPropertiesInterface.$Filter,
      LazyPropertiesInterface.$Identifier
    >(LazyPropertiesInterface, query);
  }

  async lazyPropertiesInterfaces(
    query?: $SparqlObjectSet.Query<LazyPropertiesInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesInterface[]>> {
    return this.$objects<
      LazyPropertiesInterface,
      LazyPropertiesInterface.$Filter,
      LazyPropertiesInterface.$Identifier
    >(LazyPropertiesInterface, query);
  }

  async lazyPropertiesInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazyPropertiesInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazyPropertiesInterface.$Filter>(
      LazyPropertiesInterface,
      query,
    );
  }

  async listPropertiesClass(
    identifier: ListPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ListPropertiesClass>> {
    return (
      await this.listPropertiesClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async listPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<ListPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      ListPropertiesClass.$Filter,
      ListPropertiesClass.$Identifier
    >(ListPropertiesClass, query);
  }

  async listPropertiesClasses(
    query?: $SparqlObjectSet.Query<ListPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass[]>> {
    return this.$objects<
      ListPropertiesClass,
      ListPropertiesClass.$Filter,
      ListPropertiesClass.$Identifier
    >(ListPropertiesClass, query);
  }

  async listPropertiesClassesCount(
    query?: Pick<$SparqlObjectSet.Query<ListPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ListPropertiesClass.$Filter>(
      ListPropertiesClass,
      query,
    );
  }

  async mutablePropertiesClass(
    identifier: MutablePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, MutablePropertiesClass>> {
    return (
      await this.mutablePropertiesClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async mutablePropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<MutablePropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly MutablePropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      MutablePropertiesClass.$Filter,
      MutablePropertiesClass.$Identifier
    >(MutablePropertiesClass, query);
  }

  async mutablePropertiesClasses(
    query?: $SparqlObjectSet.Query<MutablePropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly MutablePropertiesClass[]>> {
    return this.$objects<
      MutablePropertiesClass,
      MutablePropertiesClass.$Filter,
      MutablePropertiesClass.$Identifier
    >(MutablePropertiesClass, query);
  }

  async mutablePropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<MutablePropertiesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<MutablePropertiesClass.$Filter>(
      MutablePropertiesClass,
      query,
    );
  }

  async nonClass(
    identifier: NonClass.$Identifier,
  ): Promise<purify.Either<Error, NonClass>> {
    return (
      await this.nonClasses({ filter: { $identifier: { in: [identifier] } } })
    ).map((objects) => objects[0]);
  }

  async nonClassIdentifiers(
    query?: $SparqlObjectSet.Query<NonClass.$Filter>,
  ): Promise<purify.Either<Error, readonly NonClass.$Identifier[]>> {
    return this.$objectIdentifiers<NonClass.$Filter, NonClass.$Identifier>(
      NonClass,
      query,
    );
  }

  async nonClasses(
    query?: $SparqlObjectSet.Query<NonClass.$Filter>,
  ): Promise<purify.Either<Error, readonly NonClass[]>> {
    return this.$objects<NonClass, NonClass.$Filter, NonClass.$Identifier>(
      NonClass,
      query,
    );
  }

  async nonClassesCount(
    query?: Pick<$SparqlObjectSet.Query<NonClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<NonClass.$Filter>(NonClass, query);
  }

  async noRdfTypeClassUnionMember1(
    identifier: NoRdfTypeClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnionMember1>> {
    return (
      await this.noRdfTypeClassUnionMember1s({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async noRdfTypeClassUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<NoRdfTypeClassUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly NoRdfTypeClassUnionMember1.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      NoRdfTypeClassUnionMember1.$Filter,
      NoRdfTypeClassUnionMember1.$Identifier
    >(NoRdfTypeClassUnionMember1, query);
  }

  async noRdfTypeClassUnionMember1s(
    query?: $SparqlObjectSet.Query<NoRdfTypeClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnionMember1[]>> {
    return this.$objects<
      NoRdfTypeClassUnionMember1,
      NoRdfTypeClassUnionMember1.$Filter,
      NoRdfTypeClassUnionMember1.$Identifier
    >(NoRdfTypeClassUnionMember1, query);
  }

  async noRdfTypeClassUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<NoRdfTypeClassUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<NoRdfTypeClassUnionMember1.$Filter>(
      NoRdfTypeClassUnionMember1,
      query,
    );
  }

  async noRdfTypeClassUnionMember2(
    identifier: NoRdfTypeClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnionMember2>> {
    return (
      await this.noRdfTypeClassUnionMember2s({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async noRdfTypeClassUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<NoRdfTypeClassUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly NoRdfTypeClassUnionMember2.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      NoRdfTypeClassUnionMember2.$Filter,
      NoRdfTypeClassUnionMember2.$Identifier
    >(NoRdfTypeClassUnionMember2, query);
  }

  async noRdfTypeClassUnionMember2s(
    query?: $SparqlObjectSet.Query<NoRdfTypeClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnionMember2[]>> {
    return this.$objects<
      NoRdfTypeClassUnionMember2,
      NoRdfTypeClassUnionMember2.$Filter,
      NoRdfTypeClassUnionMember2.$Identifier
    >(NoRdfTypeClassUnionMember2, query);
  }

  async noRdfTypeClassUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<NoRdfTypeClassUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<NoRdfTypeClassUnionMember2.$Filter>(
      NoRdfTypeClassUnionMember2,
      query,
    );
  }

  async orderedPropertiesClass(
    identifier: OrderedPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, OrderedPropertiesClass>> {
    return (
      await this.orderedPropertiesClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async orderedPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<OrderedPropertiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly OrderedPropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      OrderedPropertiesClass.$Filter,
      OrderedPropertiesClass.$Identifier
    >(OrderedPropertiesClass, query);
  }

  async orderedPropertiesClasses(
    query?: $SparqlObjectSet.Query<OrderedPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly OrderedPropertiesClass[]>> {
    return this.$objects<
      OrderedPropertiesClass,
      OrderedPropertiesClass.$Filter,
      OrderedPropertiesClass.$Identifier
    >(OrderedPropertiesClass, query);
  }

  async orderedPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<OrderedPropertiesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<OrderedPropertiesClass.$Filter>(
      OrderedPropertiesClass,
      query,
    );
  }

  async partialClass(
    identifier: PartialClass.$Identifier,
  ): Promise<purify.Either<Error, PartialClass>> {
    return (
      await this.partialClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async partialClassIdentifiers(
    query?: $SparqlObjectSet.Query<PartialClass.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      PartialClass.$Filter,
      PartialClass.$Identifier
    >(PartialClass, query);
  }

  async partialClasses(
    query?: $SparqlObjectSet.Query<PartialClass.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClass[]>> {
    return this.$objects<
      PartialClass,
      PartialClass.$Filter,
      PartialClass.$Identifier
    >(PartialClass, query);
  }

  async partialClassesCount(
    query?: Pick<$SparqlObjectSet.Query<PartialClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialClass.$Filter>(PartialClass, query);
  }

  async partialClassUnionMember1(
    identifier: PartialClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember1>> {
    return (
      await this.partialClassUnionMember1s({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async partialClassUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<PartialClassUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember1.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      PartialClassUnionMember1.$Filter,
      PartialClassUnionMember1.$Identifier
    >(PartialClassUnionMember1, query);
  }

  async partialClassUnionMember1s(
    query?: $SparqlObjectSet.Query<PartialClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember1[]>> {
    return this.$objects<
      PartialClassUnionMember1,
      PartialClassUnionMember1.$Filter,
      PartialClassUnionMember1.$Identifier
    >(PartialClassUnionMember1, query);
  }

  async partialClassUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<PartialClassUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialClassUnionMember1.$Filter>(
      PartialClassUnionMember1,
      query,
    );
  }

  async partialClassUnionMember2(
    identifier: PartialClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember2>> {
    return (
      await this.partialClassUnionMember2s({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async partialClassUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<PartialClassUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember2.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      PartialClassUnionMember2.$Filter,
      PartialClassUnionMember2.$Identifier
    >(PartialClassUnionMember2, query);
  }

  async partialClassUnionMember2s(
    query?: $SparqlObjectSet.Query<PartialClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember2[]>> {
    return this.$objects<
      PartialClassUnionMember2,
      PartialClassUnionMember2.$Filter,
      PartialClassUnionMember2.$Identifier
    >(PartialClassUnionMember2, query);
  }

  async partialClassUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<PartialClassUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialClassUnionMember2.$Filter>(
      PartialClassUnionMember2,
      query,
    );
  }

  async partialInterface(
    identifier: PartialInterface.$Identifier,
  ): Promise<purify.Either<Error, PartialInterface>> {
    return (
      await this.partialInterfaces({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async partialInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<PartialInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialInterface.$Identifier[]>> {
    return this.$objectIdentifiers<
      PartialInterface.$Filter,
      PartialInterface.$Identifier
    >(PartialInterface, query);
  }

  async partialInterfaces(
    query?: $SparqlObjectSet.Query<PartialInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialInterface[]>> {
    return this.$objects<
      PartialInterface,
      PartialInterface.$Filter,
      PartialInterface.$Identifier
    >(PartialInterface, query);
  }

  async partialInterfacesCount(
    query?: Pick<$SparqlObjectSet.Query<PartialInterface.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialInterface.$Filter>(
      PartialInterface,
      query,
    );
  }

  async partialInterfaceUnionMember1(
    identifier: PartialInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember1>> {
    return (
      await this.partialInterfaceUnionMember1s({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async partialInterfaceUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<PartialInterfaceUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember1.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      PartialInterfaceUnionMember1.$Filter,
      PartialInterfaceUnionMember1.$Identifier
    >(PartialInterfaceUnionMember1, query);
  }

  async partialInterfaceUnionMember1s(
    query?: $SparqlObjectSet.Query<PartialInterfaceUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember1[]>> {
    return this.$objects<
      PartialInterfaceUnionMember1,
      PartialInterfaceUnionMember1.$Filter,
      PartialInterfaceUnionMember1.$Identifier
    >(PartialInterfaceUnionMember1, query);
  }

  async partialInterfaceUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<PartialInterfaceUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialInterfaceUnionMember1.$Filter>(
      PartialInterfaceUnionMember1,
      query,
    );
  }

  async partialInterfaceUnionMember2(
    identifier: PartialInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember2>> {
    return (
      await this.partialInterfaceUnionMember2s({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async partialInterfaceUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<PartialInterfaceUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember2.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      PartialInterfaceUnionMember2.$Filter,
      PartialInterfaceUnionMember2.$Identifier
    >(PartialInterfaceUnionMember2, query);
  }

  async partialInterfaceUnionMember2s(
    query?: $SparqlObjectSet.Query<PartialInterfaceUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember2[]>> {
    return this.$objects<
      PartialInterfaceUnionMember2,
      PartialInterfaceUnionMember2.$Filter,
      PartialInterfaceUnionMember2.$Identifier
    >(PartialInterfaceUnionMember2, query);
  }

  async partialInterfaceUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<PartialInterfaceUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialInterfaceUnionMember2.$Filter>(
      PartialInterfaceUnionMember2,
      query,
    );
  }

  async propertyCardinalitiesClass(
    identifier: PropertyCardinalitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyCardinalitiesClass>> {
    return (
      await this.propertyCardinalitiesClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async propertyCardinalitiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<PropertyCardinalitiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PropertyCardinalitiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      PropertyCardinalitiesClass.$Filter,
      PropertyCardinalitiesClass.$Identifier
    >(PropertyCardinalitiesClass, query);
  }

  async propertyCardinalitiesClasses(
    query?: $SparqlObjectSet.Query<PropertyCardinalitiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly PropertyCardinalitiesClass[]>> {
    return this.$objects<
      PropertyCardinalitiesClass,
      PropertyCardinalitiesClass.$Filter,
      PropertyCardinalitiesClass.$Identifier
    >(PropertyCardinalitiesClass, query);
  }

  async propertyCardinalitiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<PropertyCardinalitiesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PropertyCardinalitiesClass.$Filter>(
      PropertyCardinalitiesClass,
      query,
    );
  }

  async propertyVisibilitiesClass(
    identifier: PropertyVisibilitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyVisibilitiesClass>> {
    return (
      await this.propertyVisibilitiesClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async propertyVisibilitiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<PropertyVisibilitiesClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PropertyVisibilitiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      PropertyVisibilitiesClass.$Filter,
      PropertyVisibilitiesClass.$Identifier
    >(PropertyVisibilitiesClass, query);
  }

  async propertyVisibilitiesClasses(
    query?: $SparqlObjectSet.Query<PropertyVisibilitiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly PropertyVisibilitiesClass[]>> {
    return this.$objects<
      PropertyVisibilitiesClass,
      PropertyVisibilitiesClass.$Filter,
      PropertyVisibilitiesClass.$Identifier
    >(PropertyVisibilitiesClass, query);
  }

  async propertyVisibilitiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<PropertyVisibilitiesClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PropertyVisibilitiesClass.$Filter>(
      PropertyVisibilitiesClass,
      query,
    );
  }

  async recursiveClassUnionMember1(
    identifier: RecursiveClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember1>> {
    return (
      await this.recursiveClassUnionMember1s({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async recursiveClassUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<RecursiveClassUnionMember1.$Filter>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember1.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      RecursiveClassUnionMember1.$Filter,
      RecursiveClassUnionMember1.$Identifier
    >(RecursiveClassUnionMember1, query);
  }

  async recursiveClassUnionMember1s(
    query?: $SparqlObjectSet.Query<RecursiveClassUnionMember1.$Filter>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember1[]>> {
    return this.$objects<
      RecursiveClassUnionMember1,
      RecursiveClassUnionMember1.$Filter,
      RecursiveClassUnionMember1.$Identifier
    >(RecursiveClassUnionMember1, query);
  }

  async recursiveClassUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<RecursiveClassUnionMember1.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<RecursiveClassUnionMember1.$Filter>(
      RecursiveClassUnionMember1,
      query,
    );
  }

  async recursiveClassUnionMember2(
    identifier: RecursiveClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember2>> {
    return (
      await this.recursiveClassUnionMember2s({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async recursiveClassUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<RecursiveClassUnionMember2.$Filter>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember2.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      RecursiveClassUnionMember2.$Filter,
      RecursiveClassUnionMember2.$Identifier
    >(RecursiveClassUnionMember2, query);
  }

  async recursiveClassUnionMember2s(
    query?: $SparqlObjectSet.Query<RecursiveClassUnionMember2.$Filter>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember2[]>> {
    return this.$objects<
      RecursiveClassUnionMember2,
      RecursiveClassUnionMember2.$Filter,
      RecursiveClassUnionMember2.$Identifier
    >(RecursiveClassUnionMember2, query);
  }

  async recursiveClassUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<RecursiveClassUnionMember2.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<RecursiveClassUnionMember2.$Filter>(
      RecursiveClassUnionMember2,
      query,
    );
  }

  async sha256IriIdentifierClass(
    identifier: Sha256IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, Sha256IriIdentifierClass>> {
    return (
      await this.sha256IriIdentifierClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async sha256IriIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<Sha256IriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly Sha256IriIdentifierClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      Sha256IriIdentifierClass.$Filter,
      Sha256IriIdentifierClass.$Identifier
    >(Sha256IriIdentifierClass, query);
  }

  async sha256IriIdentifierClasses(
    query?: $SparqlObjectSet.Query<Sha256IriIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly Sha256IriIdentifierClass[]>> {
    return this.$objects<
      Sha256IriIdentifierClass,
      Sha256IriIdentifierClass.$Filter,
      Sha256IriIdentifierClass.$Identifier
    >(Sha256IriIdentifierClass, query);
  }

  async sha256IriIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<Sha256IriIdentifierClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<Sha256IriIdentifierClass.$Filter>(
      Sha256IriIdentifierClass,
      query,
    );
  }

  async termPropertiesClass(
    identifier: TermPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, TermPropertiesClass>> {
    return (
      await this.termPropertiesClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async termPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<TermPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      TermPropertiesClass.$Filter,
      TermPropertiesClass.$Identifier
    >(TermPropertiesClass, query);
  }

  async termPropertiesClasses(
    query?: $SparqlObjectSet.Query<TermPropertiesClass.$Filter>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass[]>> {
    return this.$objects<
      TermPropertiesClass,
      TermPropertiesClass.$Filter,
      TermPropertiesClass.$Identifier
    >(TermPropertiesClass, query);
  }

  async termPropertiesClassesCount(
    query?: Pick<$SparqlObjectSet.Query<TermPropertiesClass.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<TermPropertiesClass.$Filter>(
      TermPropertiesClass,
      query,
    );
  }

  async unionDiscriminantsClass(
    identifier: UnionDiscriminantsClass.$Identifier,
  ): Promise<purify.Either<Error, UnionDiscriminantsClass>> {
    return (
      await this.unionDiscriminantsClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async unionDiscriminantsClassIdentifiers(
    query?: $SparqlObjectSet.Query<UnionDiscriminantsClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly UnionDiscriminantsClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      UnionDiscriminantsClass.$Filter,
      UnionDiscriminantsClass.$Identifier
    >(UnionDiscriminantsClass, query);
  }

  async unionDiscriminantsClasses(
    query?: $SparqlObjectSet.Query<UnionDiscriminantsClass.$Filter>,
  ): Promise<purify.Either<Error, readonly UnionDiscriminantsClass[]>> {
    return this.$objects<
      UnionDiscriminantsClass,
      UnionDiscriminantsClass.$Filter,
      UnionDiscriminantsClass.$Identifier
    >(UnionDiscriminantsClass, query);
  }

  async unionDiscriminantsClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<UnionDiscriminantsClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<UnionDiscriminantsClass.$Filter>(
      UnionDiscriminantsClass,
      query,
    );
  }

  async uuidV4IriIdentifierClass(
    identifier: UuidV4IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriIdentifierClass>> {
    return (
      await this.uuidV4IriIdentifierClasses({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async uuidV4IriIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<UuidV4IriIdentifierClass.$Filter>,
  ): Promise<
    purify.Either<Error, readonly UuidV4IriIdentifierClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      UuidV4IriIdentifierClass.$Filter,
      UuidV4IriIdentifierClass.$Identifier
    >(UuidV4IriIdentifierClass, query);
  }

  async uuidV4IriIdentifierClasses(
    query?: $SparqlObjectSet.Query<UuidV4IriIdentifierClass.$Filter>,
  ): Promise<purify.Either<Error, readonly UuidV4IriIdentifierClass[]>> {
    return this.$objects<
      UuidV4IriIdentifierClass,
      UuidV4IriIdentifierClass.$Filter,
      UuidV4IriIdentifierClass.$Identifier
    >(UuidV4IriIdentifierClass, query);
  }

  async uuidV4IriIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<UuidV4IriIdentifierClass.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<UuidV4IriIdentifierClass.$Filter>(
      UuidV4IriIdentifierClass,
      query,
    );
  }

  async uuidV4IriIdentifierInterface(
    identifier: UuidV4IriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriIdentifierInterface>> {
    return (
      await this.uuidV4IriIdentifierInterfaces({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async uuidV4IriIdentifierInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<UuidV4IriIdentifierInterface.$Filter>,
  ): Promise<
    purify.Either<Error, readonly UuidV4IriIdentifierInterface.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      UuidV4IriIdentifierInterface.$Filter,
      UuidV4IriIdentifierInterface.$Identifier
    >(UuidV4IriIdentifierInterface, query);
  }

  async uuidV4IriIdentifierInterfaces(
    query?: $SparqlObjectSet.Query<UuidV4IriIdentifierInterface.$Filter>,
  ): Promise<purify.Either<Error, readonly UuidV4IriIdentifierInterface[]>> {
    return this.$objects<
      UuidV4IriIdentifierInterface,
      UuidV4IriIdentifierInterface.$Filter,
      UuidV4IriIdentifierInterface.$Identifier
    >(UuidV4IriIdentifierInterface, query);
  }

  async uuidV4IriIdentifierInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<UuidV4IriIdentifierInterface.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<UuidV4IriIdentifierInterface.$Filter>(
      UuidV4IriIdentifierInterface,
      query,
    );
  }

  async classUnion(
    identifier: ClassUnion.$Identifier,
  ): Promise<purify.Either<Error, ClassUnion>> {
    return (
      await this.classUnions({ filter: { $identifier: { in: [identifier] } } })
    ).map((objects) => objects[0]);
  }

  async classUnionIdentifiers(
    query?: $SparqlObjectSet.Query<ClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnion.$Identifier[]>> {
    return this.$objectIdentifiers<ClassUnion.$Filter, ClassUnion.$Identifier>(
      ClassUnion,
      query,
    );
  }

  async classUnions(
    query?: $SparqlObjectSet.Query<ClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly ClassUnion[]>> {
    return this.$objects<
      ClassUnion,
      ClassUnion.$Filter,
      ClassUnion.$Identifier
    >(ClassUnion, query);
  }

  async classUnionsCount(
    query?: Pick<$SparqlObjectSet.Query<ClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ClassUnion.$Filter>(ClassUnion, query);
  }

  async flattenClassUnion(
    identifier: FlattenClassUnion.$Identifier,
  ): Promise<purify.Either<Error, FlattenClassUnion>> {
    return (
      await this.flattenClassUnions({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async flattenClassUnionIdentifiers(
    query?: $SparqlObjectSet.Query<FlattenClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnion.$Identifier[]>> {
    return this.$objectIdentifiers<
      FlattenClassUnion.$Filter,
      FlattenClassUnion.$Identifier
    >(FlattenClassUnion, query);
  }

  async flattenClassUnions(
    query?: $SparqlObjectSet.Query<FlattenClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnion[]>> {
    return this.$objects<
      FlattenClassUnion,
      FlattenClassUnion.$Filter,
      FlattenClassUnion.$Identifier
    >(FlattenClassUnion, query);
  }

  async flattenClassUnionsCount(
    query?: Pick<$SparqlObjectSet.Query<FlattenClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<FlattenClassUnion.$Filter>(
      FlattenClassUnion,
      query,
    );
  }

  async interfaceUnion(
    identifier: InterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnion>> {
    return (
      await this.interfaceUnions({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async interfaceUnionIdentifiers(
    query?: $SparqlObjectSet.Query<InterfaceUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion.$Identifier[]>> {
    return this.$objectIdentifiers<
      InterfaceUnion.$Filter,
      InterfaceUnion.$Identifier
    >(InterfaceUnion, query);
  }

  async interfaceUnions(
    query?: $SparqlObjectSet.Query<InterfaceUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion[]>> {
    return this.$objects<
      InterfaceUnion,
      InterfaceUnion.$Filter,
      InterfaceUnion.$Identifier
    >(InterfaceUnion, query);
  }

  async interfaceUnionsCount(
    query?: Pick<$SparqlObjectSet.Query<InterfaceUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<InterfaceUnion.$Filter>(InterfaceUnion, query);
  }

  async lazilyResolvedClassUnion(
    identifier: LazilyResolvedClassUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnion>> {
    return (
      await this.lazilyResolvedClassUnions({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionIdentifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedClassUnion.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnion.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      LazilyResolvedClassUnion.$Filter,
      LazilyResolvedClassUnion.$Identifier
    >(LazilyResolvedClassUnion, query);
  }

  async lazilyResolvedClassUnions(
    query?: $SparqlObjectSet.Query<LazilyResolvedClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnion[]>> {
    return this.$objects<
      LazilyResolvedClassUnion,
      LazilyResolvedClassUnion.$Filter,
      LazilyResolvedClassUnion.$Identifier
    >(LazilyResolvedClassUnion, query);
  }

  async lazilyResolvedClassUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedClassUnion.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedClassUnion.$Filter>(
      LazilyResolvedClassUnion,
      query,
    );
  }

  async lazilyResolvedInterfaceUnion(
    identifier: LazilyResolvedInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnion>> {
    return (
      await this.lazilyResolvedInterfaceUnions({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionIdentifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedInterfaceUnion.$Filter>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnion.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      LazilyResolvedInterfaceUnion.$Filter,
      LazilyResolvedInterfaceUnion.$Identifier
    >(LazilyResolvedInterfaceUnion, query);
  }

  async lazilyResolvedInterfaceUnions(
    query?: $SparqlObjectSet.Query<LazilyResolvedInterfaceUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedInterfaceUnion[]>> {
    return this.$objects<
      LazilyResolvedInterfaceUnion,
      LazilyResolvedInterfaceUnion.$Filter,
      LazilyResolvedInterfaceUnion.$Identifier
    >(LazilyResolvedInterfaceUnion, query);
  }

  async lazilyResolvedInterfaceUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedInterfaceUnion.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedInterfaceUnion.$Filter>(
      LazilyResolvedInterfaceUnion,
      query,
    );
  }

  async noRdfTypeClassUnion(
    identifier: NoRdfTypeClassUnion.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnion>> {
    return (
      await this.noRdfTypeClassUnions({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async noRdfTypeClassUnionIdentifiers(
    query?: $SparqlObjectSet.Query<NoRdfTypeClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnion.$Identifier[]>> {
    return this.$objectIdentifiers<
      NoRdfTypeClassUnion.$Filter,
      NoRdfTypeClassUnion.$Identifier
    >(NoRdfTypeClassUnion, query);
  }

  async noRdfTypeClassUnions(
    query?: $SparqlObjectSet.Query<NoRdfTypeClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnion[]>> {
    return this.$objects<
      NoRdfTypeClassUnion,
      NoRdfTypeClassUnion.$Filter,
      NoRdfTypeClassUnion.$Identifier
    >(NoRdfTypeClassUnion, query);
  }

  async noRdfTypeClassUnionsCount(
    query?: Pick<$SparqlObjectSet.Query<NoRdfTypeClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<NoRdfTypeClassUnion.$Filter>(
      NoRdfTypeClassUnion,
      query,
    );
  }

  async partialClassUnion(
    identifier: PartialClassUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnion>> {
    return (
      await this.partialClassUnions({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async partialClassUnionIdentifiers(
    query?: $SparqlObjectSet.Query<PartialClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion.$Identifier[]>> {
    return this.$objectIdentifiers<
      PartialClassUnion.$Filter,
      PartialClassUnion.$Identifier
    >(PartialClassUnion, query);
  }

  async partialClassUnions(
    query?: $SparqlObjectSet.Query<PartialClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion[]>> {
    return this.$objects<
      PartialClassUnion,
      PartialClassUnion.$Filter,
      PartialClassUnion.$Identifier
    >(PartialClassUnion, query);
  }

  async partialClassUnionsCount(
    query?: Pick<$SparqlObjectSet.Query<PartialClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialClassUnion.$Filter>(
      PartialClassUnion,
      query,
    );
  }

  async partialInterfaceUnion(
    identifier: PartialInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnion>> {
    return (
      await this.partialInterfaceUnions({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async partialInterfaceUnionIdentifiers(
    query?: $SparqlObjectSet.Query<PartialInterfaceUnion.$Filter>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnion.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      PartialInterfaceUnion.$Filter,
      PartialInterfaceUnion.$Identifier
    >(PartialInterfaceUnion, query);
  }

  async partialInterfaceUnions(
    query?: $SparqlObjectSet.Query<PartialInterfaceUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnion[]>> {
    return this.$objects<
      PartialInterfaceUnion,
      PartialInterfaceUnion.$Filter,
      PartialInterfaceUnion.$Identifier
    >(PartialInterfaceUnion, query);
  }

  async partialInterfaceUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<PartialInterfaceUnion.$Filter>,
      "filter"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialInterfaceUnion.$Filter>(
      PartialInterfaceUnion,
      query,
    );
  }

  async recursiveClassUnion(
    identifier: RecursiveClassUnion.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnion>> {
    return (
      await this.recursiveClassUnions({
        filter: { $identifier: { in: [identifier] } },
      })
    ).map((objects) => objects[0]);
  }

  async recursiveClassUnionIdentifiers(
    query?: $SparqlObjectSet.Query<RecursiveClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion.$Identifier[]>> {
    return this.$objectIdentifiers<
      RecursiveClassUnion.$Filter,
      RecursiveClassUnion.$Identifier
    >(RecursiveClassUnion, query);
  }

  async recursiveClassUnions(
    query?: $SparqlObjectSet.Query<RecursiveClassUnion.$Filter>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion[]>> {
    return this.$objects<
      RecursiveClassUnion,
      RecursiveClassUnion.$Filter,
      RecursiveClassUnion.$Identifier
    >(RecursiveClassUnion, query);
  }

  async recursiveClassUnionsCount(
    query?: Pick<$SparqlObjectSet.Query<RecursiveClassUnion.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<RecursiveClassUnion.$Filter>(
      RecursiveClassUnion,
      query,
    );
  }

  async object(
    identifier: $Object.$Identifier,
  ): Promise<purify.Either<Error, $Object>> {
    return (
      await this.objects({ filter: { $identifier: { in: [identifier] } } })
    ).map((objects) => objects[0]);
  }

  async objectIdentifiers(
    query?: $SparqlObjectSet.Query<$Object.$Filter>,
  ): Promise<purify.Either<Error, readonly $Object.$Identifier[]>> {
    return this.$objectIdentifiers<$Object.$Filter, $Object.$Identifier>(
      $Object,
      query,
    );
  }

  async objects(
    query?: $SparqlObjectSet.Query<$Object.$Filter>,
  ): Promise<purify.Either<Error, readonly $Object[]>> {
    return this.$objects<$Object, $Object.$Filter, $Object.$Identifier>(
      $Object,
      query,
    );
  }

  async objectsCount(
    query?: Pick<$SparqlObjectSet.Query<$Object.$Filter>, "filter">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<$Object.$Filter>($Object, query);
  }

  protected $mapBindingsToCount(
    bindings: readonly Record<
      string,
      rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
    >[],
    variable: string,
  ): purify.Either<Error, number> {
    if (bindings.length === 0) {
      return purify.Left(new Error("empty result rows"));
    }
    if (bindings.length > 1) {
      return purify.Left(new Error("more than one result row"));
    }
    const count = bindings[0][variable];
    if (typeof count === "undefined") {
      return purify.Left(new Error("no 'count' variable in result row"));
    }
    if (count.termType !== "Literal") {
      return purify.Left(new Error("'count' variable is not a Literal"));
    }
    const parsedCount = Number.parseInt(count.value, 10);
    if (Number.isNaN(parsedCount)) {
      return purify.Left(new Error("'count' variable is NaN"));
    }
    return purify.Either.of(parsedCount);
  }

  protected $mapBindingsToIdentifiers(
    bindings: readonly Record<
      string,
      rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
    >[],
    variable: string,
  ): readonly rdfjs.NamedNode[] {
    const identifiers: rdfjs.NamedNode[] = [];
    for (const bindings_ of bindings) {
      const identifier = bindings_[variable];
      if (
        typeof identifier !== "undefined" &&
        identifier.termType === "NamedNode"
      ) {
        identifiers.push(identifier);
      }
    }
    return identifiers;
  }

  protected async $objectIdentifiers<
    ObjectFilterT extends {
      readonly $identifier?: {
        readonly in?: readonly (rdfjs.BlankNode | rdfjs.NamedNode)[];
      };
    },
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectType: {
      $sparqlWherePatterns: (parameters?: {
        filter?: ObjectFilterT;
        subject?: sparqljs.Triple["subject"];
      }) => readonly sparqljs.Pattern[];
    },
    query?: $SparqlObjectSet.Query<ObjectFilterT>,
  ): Promise<purify.Either<Error, readonly ObjectIdentifierT[]>> {
    const limit = query?.limit ?? Number.MAX_SAFE_INTEGER;
    if (limit <= 0) {
      return purify.Either.of([]);
    }

    let offset = query?.offset ?? 0;
    if (offset < 0) {
      offset = 0;
    }

    const wherePatterns = this.$wherePatterns(objectType, query).filter(
      (pattern) => pattern.type !== "optional",
    );
    if (wherePatterns.length === 0) {
      return purify.Left(
        new Error("no required SPARQL WHERE patterns for identifiers"),
      );
    }

    const selectQueryString = this.$sparqlGenerator.stringify({
      distinct: true,
      limit: limit < Number.MAX_SAFE_INTEGER ? limit : undefined,
      offset,
      order: query?.order
        ? query.order(this.$objectVariable).concat()
        : [{ expression: this.$objectVariable }],
      prefixes: {},
      queryType: "SELECT",
      type: "query",
      variables: [this.$objectVariable],
      where: wherePatterns.concat(),
    });

    return purify.EitherAsync(
      async () =>
        this.$mapBindingsToIdentifiers(
          await this.$sparqlClient.queryBindings(selectQueryString),
          this.$objectVariable.value,
        ) as readonly ObjectIdentifierT[],
    );
  }

  async $objects<
    ObjectT,
    ObjectFilterT extends {
      readonly $identifier?: {
        readonly in?: readonly (rdfjs.BlankNode | rdfjs.NamedNode)[];
      };
    },
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectType: {
      $fromRdf: (
        resource: rdfjsResource.Resource,
        options: { objectSet: $ObjectSet },
      ) => purify.Either<Error, ObjectT>;
      $sparqlConstructQueryString: (
        parameters?: {
          filter?: ObjectFilterT;
          subject?: sparqljs.Triple["subject"];
        } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
          sparqljs.GeneratorOptions,
      ) => string;
      $sparqlWherePatterns: (parameters?: {
        filter?: ObjectFilterT;
        subject?: sparqljs.Triple["subject"];
      }) => readonly sparqljs.Pattern[];
    },
    query?: $SparqlObjectSet.Query<ObjectFilterT>,
  ): Promise<purify.Either<Error, readonly ObjectT[]>> {
    return purify.EitherAsync(async ({ liftEither }) => {
      const identifiers = await liftEither(
        await this.$objectIdentifiers<ObjectFilterT, ObjectIdentifierT>(
          objectType,
          query,
        ),
      );
      if (identifiers.length === 0) {
        return [];
      }

      const constructQueryString = objectType.$sparqlConstructQueryString({
        subject: this.$objectVariable,
        where: [
          {
            type: "values" as const,
            values: identifiers.map((identifier) => {
              const valuePatternRow: sparqljs.ValuePatternRow = {};
              valuePatternRow["?object"] = identifier as rdfjs.NamedNode;
              return valuePatternRow;
            }),
          },
        ],
      });

      const quads = await this.$sparqlClient.queryQuads(constructQueryString);

      const dataset = datasetFactory.dataset(quads.concat());
      const objects: ObjectT[] = [];
      for (const identifier of identifiers) {
        objects.push(
          await liftEither(
            objectType.$fromRdf(
              new rdfjsResource.Resource<rdfjs.NamedNode>({
                dataset,
                identifier: identifier as rdfjs.NamedNode,
              }),
              { objectSet: this },
            ),
          ),
        );
      }
      return objects;
    });
  }

  protected async $objectsCount<
    ObjectFilterT extends {
      readonly $identifier?: {
        readonly in?: readonly (rdfjs.BlankNode | rdfjs.NamedNode)[];
      };
    },
  >(
    objectType: {
      $sparqlWherePatterns: (parameters?: {
        filter?: ObjectFilterT;
        subject?: sparqljs.Triple["subject"];
      }) => readonly sparqljs.Pattern[];
    },
    query?: $SparqlObjectSet.Query<ObjectFilterT>,
  ): Promise<purify.Either<Error, number>> {
    const wherePatterns = this.$wherePatterns(objectType, query).filter(
      (pattern) => pattern.type !== "optional",
    );
    if (wherePatterns.length === 0) {
      return purify.Left(
        new Error("no required SPARQL WHERE patterns for count"),
      );
    }

    const selectQueryString = this.$sparqlGenerator.stringify({
      prefixes: {},
      queryType: "SELECT",
      type: "query",
      variables: [
        {
          expression: {
            aggregation: "COUNT",
            distinct: true,
            expression: this.$objectVariable,
            type: "aggregate",
          },
          variable: this.$countVariable,
        },
      ],
      where: wherePatterns,
    });

    return purify.EitherAsync(async ({ liftEither }) =>
      liftEither(
        this.$mapBindingsToCount(
          await this.$sparqlClient.queryBindings(selectQueryString),
          this.$countVariable.value,
        ),
      ),
    );
  }

  protected $wherePatterns<
    ObjectFilterT extends {
      readonly $identifier?: {
        readonly in?: readonly (rdfjs.BlankNode | rdfjs.NamedNode)[];
      };
    },
  >(
    objectType: {
      $sparqlWherePatterns: (parameters?: {
        filter?: ObjectFilterT;
        subject?: sparqljs.Triple["subject"];
      }) => readonly sparqljs.Pattern[];
    },
    query?: $SparqlObjectSet.Query<ObjectFilterT>,
  ): readonly sparqljs.Pattern[] {
    // Patterns should be most to least specific.
    const patterns: sparqljs.Pattern[] = [];

    if (query?.where) {
      patterns.push(...query.where(this.$objectVariable));
    }

    patterns.push(
      ...objectType.$sparqlWherePatterns({
        filter: query?.filter,
        subject: this.$objectVariable,
      }),
    );

    return $insertSeedSparqlWherePattern(
      $optimizeSparqlWherePatterns(patterns),
    );
  }
}

export namespace $SparqlObjectSet {
  export type Query<
    ObjectFilterT extends {
      readonly $identifier?: {
        readonly in?: readonly (rdfjs.BlankNode | rdfjs.NamedNode)[];
      };
    },
  > = $ObjectSet.Query<ObjectFilterT> & {
    readonly order?: (
      objectVariable: rdfjs.Variable,
    ) => readonly sparqljs.Ordering[];
    readonly where?: (
      objectVariable: rdfjs.Variable,
    ) => readonly sparqljs.Pattern[];
  };
}
