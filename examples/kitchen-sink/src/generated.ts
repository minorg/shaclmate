import { StoreFactory as _DatasetFactory } from "n3";
const datasetFactory = new _DatasetFactory();
import type * as rdfjs from "@rdfjs/types";
import { sha256 } from "js-sha256";
import { DataFactory as dataFactory } from "n3";
import * as purify from "purify-ts";
import * as rdfLiteral from "rdf-literal";
import * as rdfjsResource from "rdfjs-resource";
import * as sparqljs from "sparqljs";
import * as uuid from "uuid";
import { z as zod } from "zod";
import { ExternClass } from "./ExternClass.js";
export type $EqualsResult = purify.Either<$EqualsResult.Unequal, true>;

export namespace $EqualsResult {
  export const Equal: $EqualsResult = purify.Either.of<Unequal, true>(true);

  export function fromBooleanEqualsResult(
    left: any,
    right: any,
    equalsResult: boolean | $EqualsResult,
  ): $EqualsResult {
    if (typeof equalsResult !== "boolean") {
      return equalsResult;
    }

    if (equalsResult) {
      return Equal;
    }

    return purify.Left({ left, right, type: "BooleanEquals" });
  }

  export type Unequal =
    | {
        readonly left: {
          readonly array: readonly any[];
          readonly element: any;
          readonly elementIndex: number;
        };
        readonly right: {
          readonly array: readonly any[];
          readonly unequals: readonly Unequal[];
        };
        readonly type: "ArrayElement";
      }
    | {
        readonly left: readonly any[];
        readonly right: readonly any[];
        readonly type: "ArrayLength";
      }
    | {
        readonly left: any;
        readonly right: any;
        readonly type: "BooleanEquals";
      }
    | {
        readonly left: any;
        readonly right: any;
        readonly type: "LeftError";
      }
    | {
        readonly right: any;
        readonly type: "LeftNull";
      }
    | {
        readonly left: bigint | boolean | number | string;
        readonly right: bigint | boolean | number | string;
        readonly type: "Primitive";
      }
    | {
        readonly left: any;
        readonly right: any;
        readonly propertyName: string;
        readonly propertyValuesUnequal: Unequal;
        readonly type: "Property";
      }
    | {
        readonly left: any;
        readonly right: any;
        readonly type: "RightError";
      }
    | {
        readonly left: any;
        readonly type: "RightNull";
      };
}
export namespace $RdfVocabularies {
  export namespace rdf {
    export const first = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
    );
    export const nil = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil",
    );
    export const rest = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
    );
    export const subject = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#subject",
    );
    export const type = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    );
  }

  export namespace rdfs {
    export const subClassOf = dataFactory.namedNode(
      "http://www.w3.org/2000/01/rdf-schema#subClassOf",
    );
  }

  export namespace xsd {
    export const boolean = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#boolean",
    );
    export const date = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#date",
    );
    export const dateTime = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#dateTime",
    );
    export const integer = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#integer",
    );
  }
}
/**
 * Compare two objects with equals(other: T): boolean methods and return an $EqualsResult.
 */
export function $booleanEquals<T extends { equals: (other: T) => boolean }>(
  left: T,
  right: T,
): $EqualsResult {
  return $EqualsResult.fromBooleanEqualsResult(left, right, left.equals(right));
}
/**
 * Compare two values for strict equality (===), returning an $EqualsResult rather than a boolean.
 */
export function $strictEquals<T extends bigint | boolean | number | string>(
  left: T,
  right: T,
): $EqualsResult {
  return $EqualsResult.fromBooleanEqualsResult(left, right, left === right);
}
export function $maybeEquals<T>(
  leftMaybe: purify.Maybe<T>,
  rightMaybe: purify.Maybe<T>,
  valueEquals: (left: T, right: T) => boolean | $EqualsResult,
): $EqualsResult {
  if (leftMaybe.isJust()) {
    if (rightMaybe.isJust()) {
      return $EqualsResult.fromBooleanEqualsResult(
        leftMaybe,
        rightMaybe,
        valueEquals(leftMaybe.unsafeCoerce(), rightMaybe.unsafeCoerce()),
      );
    }
    return purify.Left({
      left: leftMaybe.unsafeCoerce(),
      type: "RightNull",
    });
  }

  if (rightMaybe.isJust()) {
    return purify.Left({
      right: rightMaybe.unsafeCoerce(),
      type: "LeftNull",
    });
  }

  return $EqualsResult.Equal;
}
/**
 * Compare two Dates and return an $EqualsResult.
 */
export function $dateEquals(left: Date, right: Date): $EqualsResult {
  return $EqualsResult.fromBooleanEqualsResult(
    left,
    right,
    left.getTime() === right.getTime(),
  );
}
/**
 * Compare two arrays element-wise with the provided elementEquals function.
 */
export function $arrayEquals<T>(
  leftArray: readonly T[],
  rightArray: readonly T[],
  elementEquals: (left: T, right: T) => boolean | $EqualsResult,
): $EqualsResult {
  if (leftArray.length !== rightArray.length) {
    return purify.Left({
      left: leftArray,
      right: rightArray,
      type: "ArrayLength",
    });
  }

  for (
    let leftElementIndex = 0;
    leftElementIndex < leftArray.length;
    leftElementIndex++
  ) {
    const leftElement = leftArray[leftElementIndex];

    const rightUnequals: $EqualsResult.Unequal[] = [];
    for (
      let rightElementIndex = 0;
      rightElementIndex < rightArray.length;
      rightElementIndex++
    ) {
      const rightElement = rightArray[rightElementIndex];

      const leftElementEqualsRightElement =
        $EqualsResult.fromBooleanEqualsResult(
          leftElement,
          rightElement,
          elementEquals(leftElement, rightElement),
        );
      if (leftElementEqualsRightElement.isRight()) {
        break; // left element === right element, break out of the right iteration
      }
      rightUnequals.push(
        leftElementEqualsRightElement.extract() as $EqualsResult.Unequal,
      );
    }

    if (rightUnequals.length === rightArray.length) {
      // All right elements were unequal to the left element
      return purify.Left({
        left: {
          array: leftArray,
          element: leftElement,
          elementIndex: leftElementIndex,
        },
        right: {
          array: rightArray,
          unequals: rightUnequals,
        },
        type: "ArrayElement",
      });
    }
    // Else there was a right element equal to the left element, continue to the next left element
  }

  return $EqualsResult.Equal;
}
/**
 * A sparqljs.Pattern that's the equivalent of ?subject rdf:type/rdfs:subClassOf* ?rdfType .
 */
export function $sparqlInstancesOfPattern({
  rdfType,
  subject,
}: {
  rdfType: rdfjs.NamedNode | rdfjs.Variable;
  subject: sparqljs.Triple["subject"];
}): sparqljs.Pattern {
  return {
    triples: [
      {
        subject,
        predicate: {
          items: [
            $RdfVocabularies.rdf.type,
            {
              items: [$RdfVocabularies.rdfs.subClassOf],
              pathType: "*",
              type: "path",
            },
          ],
          pathType: "/",
          type: "path",
        },
        object: rdfType,
      },
    ],
    type: "bgp",
  };
}
type $UnwrapR<T> = T extends purify.Either<any, infer R> ? R : never;
function $isReadonlyObjectArray(x: unknown): x is readonly object[] {
  return Array.isArray(x) && x.every((z) => typeof z === "object");
}
function $isReadonlyStringArray(x: unknown): x is readonly string[] {
  return Array.isArray(x) && x.every((z) => typeof z === "string");
}
/**
 * Type of lazy properties that return a single optional object. This is a class instead of an interface so it can be instanceof'd elsewhere.
 */
export class $LazyOptionalObject<
  ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  PartialObjectT extends { $identifier: ObjectIdentifierT },
  ResolvedObjectT extends { $identifier: ObjectIdentifierT },
> {
  readonly partial: purify.Maybe<PartialObjectT>;
  private readonly resolver: (
    identifier: ObjectIdentifierT,
  ) => Promise<purify.Either<Error, ResolvedObjectT>>;

  constructor({
    partial,
    resolver,
  }: {
    partial: purify.Maybe<PartialObjectT>;
    resolver: (
      identifier: ObjectIdentifierT,
    ) => Promise<purify.Either<Error, ResolvedObjectT>>;
  }) {
    this.partial = partial;
    this.resolver = resolver;
  }

  async resolve(): Promise<
    purify.Either<Error, purify.Maybe<ResolvedObjectT>>
  > {
    if (this.partial.isNothing()) {
      return purify.Either.of(purify.Maybe.empty());
    }
    return (await this.resolver(this.partial.unsafeCoerce().$identifier)).map(
      purify.Maybe.of,
    );
  }
}
/**
 * Type of lazy properties that return a single required object. This is a class instead of an interface so it can be instanceof'd elsewhere.
 */
export class $LazyRequiredObject<
  ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  PartialObjectT extends { $identifier: ObjectIdentifierT },
  ResolvedObjectT extends { $identifier: ObjectIdentifierT },
> {
  readonly partial: PartialObjectT;
  private readonly resolver: (
    identifier: ObjectIdentifierT,
  ) => Promise<purify.Either<Error, ResolvedObjectT>>;

  constructor({
    partial,
    resolver,
  }: {
    partial: PartialObjectT;
    resolver: (
      identifier: ObjectIdentifierT,
    ) => Promise<purify.Either<Error, ResolvedObjectT>>;
  }) {
    this.partial = partial;
    this.resolver = resolver;
  }

  resolve(): Promise<purify.Either<Error, ResolvedObjectT>> {
    return this.resolver(this.partial.$identifier);
  }
}
/**
 * Type of lazy properties that return a set of objects. This is a class instead of an interface so it can be instanceof'd elsewhere.
 */
export class $LazyObjectSet<
  ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  PartialObjectT extends { $identifier: ObjectIdentifierT },
  ResolvedObjectT extends { $identifier: ObjectIdentifierT },
> {
  readonly partials: readonly PartialObjectT[];
  private readonly resolver: (
    identifiers: readonly ObjectIdentifierT[],
  ) => Promise<purify.Either<Error, readonly ResolvedObjectT[]>>;

  constructor({
    partials,
    resolver,
  }: {
    partials: readonly PartialObjectT[];
    resolver: (
      identifiers: readonly ObjectIdentifierT[],
    ) => Promise<purify.Either<Error, readonly ResolvedObjectT[]>>;
  }) {
    this.partials = partials;
    this.resolver = resolver;
  }

  get length(): number {
    return this.partials.length;
  }

  async resolve(options?: { limit?: number; offset?: number }): Promise<
    purify.Either<Error, readonly ResolvedObjectT[]>
  > {
    if (this.partials.length === 0) {
      return purify.Either.of([]);
    }

    const limit = options?.limit ?? Number.MAX_SAFE_INTEGER;
    if (limit <= 0) {
      return purify.Either.of([]);
    }

    let offset = options?.offset ?? 0;
    if (offset < 0) {
      offset = 0;
    }

    return await this.resolver(
      this.partials
        .slice(offset, offset + limit)
        .map((partial) => partial.$identifier),
    );
  }
}
export function $arrayIntersection<T>(
  left: readonly T[],
  right: readonly T[],
): readonly T[] {
  if (left.length === 0) {
    return right;
  }
  if (right.length === 0) {
    return left;
  }

  const intersection = new Set<T>();
  if (left.length <= right.length) {
    const rightSet = new Set(right);
    for (const leftElement of left) {
      if (rightSet.has(leftElement)) {
        intersection.add(leftElement);
      }
    }
  } else {
    const leftSet = new Set(left);
    for (const rightElement of right) {
      if (leftSet.has(rightElement)) {
        intersection.add(rightElement);
      }
    }
  }
  return [...intersection];
}
function $isReadonlyBooleanArray(x: unknown): x is readonly boolean[] {
  return Array.isArray(x) && x.every((z) => typeof z === "boolean");
}
function $isReadonlyNumberArray(x: unknown): x is readonly number[] {
  return Array.isArray(x) && x.every((z) => typeof z === "number");
}
export class $NamedDefaultPartial {
  readonly $identifier: $NamedDefaultPartial.$Identifier;
  readonly $type = "$NamedDefaultPartial";

  constructor(parameters: { readonly $identifier: rdfjs.NamedNode | string }) {
    if (typeof parameters.$identifier === "object") {
      this.$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this.$identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      this.$identifier = parameters.$identifier satisfies never;
    }
  }

  $equals(other: $NamedDefaultPartial): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    return _hasher;
  }

  $toJson(): $NamedDefaultPartial.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
      } satisfies $NamedDefaultPartial.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(this.$identifier, {
      mutateGraph,
    });
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace $NamedDefaultPartial {
  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "$NamedDefaultPartial";
  };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<zod.ZodError, { $identifier: rdfjs.NamedNode }> {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    return purify.Either.of({ $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, $NamedDefaultPartial> {
    return $propertiesFromJson(json).map(
      (properties) => new $NamedDefaultPartial(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "$NamedDefaultPartial" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "$NamedDefaultPartial",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("$NamedDefaultPartial"),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, $NamedDefaultPartial> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return $NamedDefaultPartial
      .$propertiesFromRdf({
        ...context,
        ignoreRdfType,
        objectSet,
        preferredLanguages,
        resource,
      })
      .map((properties) => new $NamedDefaultPartial(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<Error, { $identifier: rdfjs.NamedNode }> {
    if ($resource.identifier.termType !== "NamedNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedValueError({
          actualValue: $resource.identifier,
          expectedValueType: "(rdfjs.NamedNode)",
          focusResource: $resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: $NamedDefaultPartial.$Identifier = $resource.identifier;
    return purify.Either.of({ $identifier });
  }

  export const $properties = {};

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        $NamedDefaultPartial.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $NamedDefaultPartial.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      $NamedDefaultPartial.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(_parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [];
  }
}
export class $DefaultPartial {
  readonly $identifier: $DefaultPartial.$Identifier;
  readonly $type = "$DefaultPartial";

  constructor(parameters: {
    readonly $identifier: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this.$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this.$identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      this.$identifier = parameters.$identifier satisfies never;
    }
  }

  $equals(other: $DefaultPartial): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    return _hasher;
  }

  $toJson(): $DefaultPartial.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
      } satisfies $DefaultPartial.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace $DefaultPartial {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "$DefaultPartial";
  };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    return purify.Either.of({ $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, $DefaultPartial> {
    return $propertiesFromJson(json).map(
      (properties) => new $DefaultPartial(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "$DefaultPartial" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "$DefaultPartial",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("$DefaultPartial"),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, $DefaultPartial> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return $DefaultPartial
      .$propertiesFromRdf({
        ...context,
        ignoreRdfType,
        objectSet,
        preferredLanguages,
        resource,
      })
      .map((properties) => new $DefaultPartial(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<Error, { $identifier: rdfjs.BlankNode | rdfjs.NamedNode }> {
    const $identifier: $DefaultPartial.$Identifier = $resource.identifier;
    return purify.Either.of({ $identifier });
  }

  export const $properties = {};

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        $DefaultPartial.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $DefaultPartial.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      $DefaultPartial.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(_parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [];
  }
}
/**
 * A node shape that mints its identifier by generating a v4 UUID, if no identifier is supplied.
 */
export interface UuidV4IriInterface {
  readonly $identifier: UuidV4IriInterface.$Identifier;
  readonly $type: "UuidV4IriInterface";
  readonly uuidV4IriProperty: string;
}

export namespace UuidV4IriInterface {
  export function $create(parameters: {
    readonly $identifier?: rdfjs.NamedNode | string;
    readonly $identifierPrefix?: string;
    readonly uuidV4IriProperty: string;
  }): Omit<UuidV4IriInterface, "$identifierPrefix"> {
    let $identifier: UuidV4IriInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.namedNode(
        `${parameters.$identifierPrefix ?? "urn:shaclmate:UuidV4IriInterface:"}${uuid.v4()}`,
      );
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "UuidV4IriInterface" as const;
    const uuidV4IriProperty = parameters.uuidV4IriProperty;
    return { $identifier, $type, uuidV4IriProperty };
  }

  export function $equals(
    left: UuidV4IriInterface,
    right: UuidV4IriInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(left.uuidV4IriProperty, right.uuidV4IriProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "uuidV4IriProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "UuidV4IriInterface";
    readonly uuidV4IriProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.NamedNode;
      $type: "UuidV4IriInterface";
      uuidV4IriProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const $type = "UuidV4IriInterface" as const;
    const uuidV4IriProperty = $jsonObject["uuidV4IriProperty"];
    return purify.Either.of({ $identifier, $type, uuidV4IriProperty });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, UuidV4IriInterface> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "UuidV4IriInterface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/uuidV4IriProperty`,
          type: "Control",
        },
      ],
      label: "UuidV4IriInterface",
      type: "Group",
    };
  }

  export function $toJson(
    _uuidV4IriInterface: UuidV4IriInterface,
  ): UuidV4IriInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": _uuidV4IriInterface.$identifier.value,
        $type: _uuidV4IriInterface.$type,
        uuidV4IriProperty: _uuidV4IriInterface.uuidV4IriProperty,
      } satisfies UuidV4IriInterface.$Json),
    );
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("UuidV4IriInterface"),
      uuidV4IriProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_uuidV4IriInterface: UuidV4IriInterface, _hasher: HasherT): HasherT {
    _hasher.update(_uuidV4IriInterface.$identifier.value);
    _hasher.update(_uuidV4IriInterface.$type);
    UuidV4IriInterface.$hashShaclProperties(_uuidV4IriInterface, _hasher);
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_uuidV4IriInterface: UuidV4IriInterface, _hasher: HasherT): HasherT {
    _hasher.update(_uuidV4IriInterface.uuidV4IriProperty);
    return _hasher;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, UuidV4IriInterface> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return UuidV4IriInterface.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.NamedNode;
      $type: "UuidV4IriInterface";
      uuidV4IriProperty: string;
    }
  > {
    if ($resource.identifier.termType !== "NamedNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedValueError({
          actualValue: $resource.identifier,
          expectedValueType: "(rdfjs.NamedNode)",
          focusResource: $resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: UuidV4IriInterface.$Identifier = $resource.identifier;
    const $type = "UuidV4IriInterface" as const;
    const _uuidV4IriPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.uuidV4IriProperty["identifier"], {
          unique: true,
        }),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    UuidV4IriInterface.$properties.uuidV4IriProperty[
                      "identifier"
                    ],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_uuidV4IriPropertyEither.isLeft()) {
      return _uuidV4IriPropertyEither;
    }

    const uuidV4IriProperty = _uuidV4IriPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, $type, uuidV4IriProperty });
  }

  export function $toRdf(
    _uuidV4IriInterface: UuidV4IriInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(
      _uuidV4IriInterface.$identifier,
      { mutateGraph },
    );
    resource.add(
      UuidV4IriInterface.$properties.uuidV4IriProperty["identifier"],
      ...[_uuidV4IriInterface.uuidV4IriProperty],
    );
    return resource;
  }

  export const $properties = {
    uuidV4IriProperty: {
      identifier: dataFactory.namedNode("http://example.com/uuidV4IriProperty"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        UuidV4IriInterface.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        UuidV4IriInterface.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      UuidV4IriInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("uuidV4IriInterface");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "uuidV4IriInterface");
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}UuidV4IriProperty`),
      predicate: UuidV4IriInterface.$properties.uuidV4IriProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("uuidV4IriInterface");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "uuidV4IriInterface");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}UuidV4IriProperty`),
            predicate:
              UuidV4IriInterface.$properties.uuidV4IriProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(`${variablePrefix}UuidV4IriProperty`),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * A node shape that mints its identifier by generating a v4 UUID, if no identifier is supplied.
 */
export class UuidV4IriClass {
  private _$identifier?: UuidV4IriClass.$Identifier;
  protected readonly _$identifierPrefix?: string;
  readonly $type = "UuidV4IriClass";
  readonly uuidV4IriProperty: string;

  constructor(parameters: {
    readonly $identifier?: rdfjs.NamedNode | string;
    readonly $identifierPrefix?: string;
    readonly uuidV4IriProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this._$identifierPrefix = parameters.$identifierPrefix;
    this.uuidV4IriProperty = parameters.uuidV4IriProperty;
  }

  get $identifier(): UuidV4IriClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${uuid.v4()}`,
      );
    }
    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  $equals(other: UuidV4IriClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$identifierPrefix, other.$identifierPrefix).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$identifierPrefix",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.uuidV4IriProperty, other.uuidV4IriProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "uuidV4IriProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.uuidV4IriProperty);
    return _hasher;
  }

  $toJson(): UuidV4IriClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
        uuidV4IriProperty: this.uuidV4IriProperty,
      } satisfies UuidV4IriClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      UuidV4IriClass.$properties.uuidV4IriProperty["identifier"],
      ...[this.uuidV4IriProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace UuidV4IriClass {
  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "UuidV4IriClass";
    readonly uuidV4IriProperty: string;
  };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.NamedNode; uuidV4IriProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const uuidV4IriProperty = $jsonObject["uuidV4IriProperty"];
    return purify.Either.of({ $identifier, uuidV4IriProperty });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, UuidV4IriClass> {
    return $propertiesFromJson(json).map(
      (properties) => new UuidV4IriClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "UuidV4IriClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/uuidV4IriProperty`,
          type: "Control",
        },
      ],
      label: "UuidV4IriClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("UuidV4IriClass"),
      uuidV4IriProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, UuidV4IriClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return UuidV4IriClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new UuidV4IriClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.NamedNode; uuidV4IriProperty: string }
  > {
    if ($resource.identifier.termType !== "NamedNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedValueError({
          actualValue: $resource.identifier,
          expectedValueType: "(rdfjs.NamedNode)",
          focusResource: $resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: UuidV4IriClass.$Identifier = $resource.identifier;
    const _uuidV4IriPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.uuidV4IriProperty["identifier"], {
          unique: true,
        }),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    UuidV4IriClass.$properties.uuidV4IriProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_uuidV4IriPropertyEither.isLeft()) {
      return _uuidV4IriPropertyEither;
    }

    const uuidV4IriProperty = _uuidV4IriPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, uuidV4IriProperty });
  }

  export const $properties = {
    uuidV4IriProperty: {
      identifier: dataFactory.namedNode("http://example.com/uuidV4IriProperty"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        UuidV4IriClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        UuidV4IriClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      UuidV4IriClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("uuidV4IriClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "uuidV4IriClass");
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}UuidV4IriProperty`),
      predicate: UuidV4IriClass.$properties.uuidV4IriProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("uuidV4IriClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "uuidV4IriClass");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}UuidV4IriProperty`),
            predicate:
              UuidV4IriClass.$properties.uuidV4IriProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(`${variablePrefix}UuidV4IriProperty`),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Shape with sh:xone properties.
 */
export class UnionPropertiesClass {
  private _$identifier?: UnionPropertiesClass.$Identifier;
  readonly $type = "UnionPropertiesClass";
  readonly narrowLiteralsProperty: purify.Maybe<number | string>;
  readonly unrelatedTypesProperty: purify.Maybe<number | NonClass>;
  readonly widenedLiteralsProperty: purify.Maybe<rdfjs.Literal>;
  readonly widenedTermsProperty: purify.Maybe<rdfjs.Literal | rdfjs.NamedNode>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly narrowLiteralsProperty?:
      | number
      | purify.Maybe<number | string>
      | string;
    readonly unrelatedTypesProperty?:
      | NonClass
      | number
      | purify.Maybe<number | NonClass>;
    readonly widenedLiteralsProperty?:
      | rdfjs.Literal
      | Date
      | boolean
      | number
      | purify.Maybe<rdfjs.Literal>
      | string;
    readonly widenedTermsProperty?:
      | (rdfjs.Literal | rdfjs.NamedNode)
      | Date
      | boolean
      | number
      | purify.Maybe<rdfjs.Literal | rdfjs.NamedNode>
      | string;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.narrowLiteralsProperty)) {
      this.narrowLiteralsProperty = parameters?.narrowLiteralsProperty;
    } else if (typeof parameters?.narrowLiteralsProperty === "number") {
      this.narrowLiteralsProperty = purify.Maybe.of(
        parameters?.narrowLiteralsProperty,
      );
    } else if (typeof parameters?.narrowLiteralsProperty === "string") {
      this.narrowLiteralsProperty = purify.Maybe.of(
        parameters?.narrowLiteralsProperty,
      );
    } else if (typeof parameters?.narrowLiteralsProperty === "undefined") {
      this.narrowLiteralsProperty = purify.Maybe.empty();
    } else {
      this.narrowLiteralsProperty =
        parameters?.narrowLiteralsProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.unrelatedTypesProperty)) {
      this.unrelatedTypesProperty = parameters?.unrelatedTypesProperty;
    } else if (typeof parameters?.unrelatedTypesProperty === "number") {
      this.unrelatedTypesProperty = purify.Maybe.of(
        parameters?.unrelatedTypesProperty,
      );
    } else if (typeof parameters?.unrelatedTypesProperty === "object") {
      this.unrelatedTypesProperty = purify.Maybe.of(
        parameters?.unrelatedTypesProperty,
      );
    } else if (typeof parameters?.unrelatedTypesProperty === "undefined") {
      this.unrelatedTypesProperty = purify.Maybe.empty();
    } else {
      this.unrelatedTypesProperty =
        parameters?.unrelatedTypesProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.widenedLiteralsProperty)) {
      this.widenedLiteralsProperty = parameters?.widenedLiteralsProperty;
    } else if (typeof parameters?.widenedLiteralsProperty === "boolean") {
      this.widenedLiteralsProperty = purify.Maybe.of(
        rdfLiteral.toRdf(parameters?.widenedLiteralsProperty, { dataFactory }),
      );
    } else if (
      typeof parameters?.widenedLiteralsProperty === "object" &&
      parameters?.widenedLiteralsProperty instanceof Date
    ) {
      this.widenedLiteralsProperty = purify.Maybe.of(
        rdfLiteral.toRdf(parameters?.widenedLiteralsProperty, { dataFactory }),
      );
    } else if (typeof parameters?.widenedLiteralsProperty === "number") {
      this.widenedLiteralsProperty = purify.Maybe.of(
        rdfLiteral.toRdf(parameters?.widenedLiteralsProperty, { dataFactory }),
      );
    } else if (typeof parameters?.widenedLiteralsProperty === "string") {
      this.widenedLiteralsProperty = purify.Maybe.of(
        dataFactory.literal(parameters?.widenedLiteralsProperty),
      );
    } else if (typeof parameters?.widenedLiteralsProperty === "object") {
      this.widenedLiteralsProperty = purify.Maybe.of(
        parameters?.widenedLiteralsProperty,
      );
    } else if (typeof parameters?.widenedLiteralsProperty === "undefined") {
      this.widenedLiteralsProperty = purify.Maybe.empty();
    } else {
      this.widenedLiteralsProperty =
        parameters?.widenedLiteralsProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.widenedTermsProperty)) {
      this.widenedTermsProperty = parameters?.widenedTermsProperty;
    } else if (typeof parameters?.widenedTermsProperty === "boolean") {
      this.widenedTermsProperty = purify.Maybe.of(
        rdfLiteral.toRdf(parameters?.widenedTermsProperty, { dataFactory }),
      );
    } else if (
      typeof parameters?.widenedTermsProperty === "object" &&
      parameters?.widenedTermsProperty instanceof Date
    ) {
      this.widenedTermsProperty = purify.Maybe.of(
        rdfLiteral.toRdf(parameters?.widenedTermsProperty, { dataFactory }),
      );
    } else if (typeof parameters?.widenedTermsProperty === "number") {
      this.widenedTermsProperty = purify.Maybe.of(
        rdfLiteral.toRdf(parameters?.widenedTermsProperty, { dataFactory }),
      );
    } else if (typeof parameters?.widenedTermsProperty === "string") {
      this.widenedTermsProperty = purify.Maybe.of(
        dataFactory.literal(parameters?.widenedTermsProperty),
      );
    } else if (typeof parameters?.widenedTermsProperty === "object") {
      this.widenedTermsProperty = purify.Maybe.of(
        parameters?.widenedTermsProperty,
      );
    } else if (typeof parameters?.widenedTermsProperty === "undefined") {
      this.widenedTermsProperty = purify.Maybe.empty();
    } else {
      this.widenedTermsProperty =
        parameters?.widenedTermsProperty satisfies never;
    }
  }

  get $identifier(): UnionPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: UnionPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (left: number | string, right: number | string) => {
              if (typeof left === "number" && typeof right === "number") {
                return $strictEquals(left, right);
              }
              if (typeof left === "string" && typeof right === "string") {
                return $strictEquals(left, right);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(this.narrowLiteralsProperty, other.narrowLiteralsProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "narrowLiteralsProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (left: number | NonClass, right: number | NonClass) => {
              if (typeof left === "number" && typeof right === "number") {
                return $strictEquals(left, right);
              }
              if (typeof left === "object" && typeof right === "object") {
                return ((left, right) => left.$equals(right))(left, right);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(this.unrelatedTypesProperty, other.unrelatedTypesProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "unrelatedTypesProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.widenedLiteralsProperty,
          other.widenedLiteralsProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "widenedLiteralsProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.widenedTermsProperty,
          other.widenedTermsProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "widenedTermsProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.narrowLiteralsProperty.ifJust((value0) => {
      switch (typeof value0) {
        case "number": {
          _hasher.update(value0.toString());
          break;
        }
        case "string": {
          _hasher.update(value0);
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    this.unrelatedTypesProperty.ifJust((value0) => {
      switch (typeof value0) {
        case "number": {
          _hasher.update(value0.toString());
          break;
        }
        case "object": {
          value0.$hash(_hasher);
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    this.widenedLiteralsProperty.ifJust((value0) => {
      _hasher.update(value0.datatype.value);
      _hasher.update(value0.language);
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    this.widenedTermsProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    return _hasher;
  }

  $toJson(): UnionPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        narrowLiteralsProperty: this.narrowLiteralsProperty
          .map((item) => item)
          .extract(),
        unrelatedTypesProperty: this.unrelatedTypesProperty
          .map((item) => (typeof item === "object" ? item.$toJson() : item))
          .extract(),
        widenedLiteralsProperty: this.widenedLiteralsProperty
          .map((item) => ({
            "@language": item.language.length > 0 ? item.language : undefined,
            "@type":
              item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? item.datatype.value
                : undefined,
            "@value": item.value,
          }))
          .extract(),
        widenedTermsProperty: this.widenedTermsProperty
          .map((item) =>
            item.termType === "NamedNode"
              ? { "@id": item.value, termType: "NamedNode" as const }
              : {
                  "@language":
                    item.language.length > 0 ? item.language : undefined,
                  "@type":
                    item.datatype.value !==
                    "http://www.w3.org/2001/XMLSchema#string"
                      ? item.datatype.value
                      : undefined,
                  "@value": item.value,
                  termType: "Literal" as const,
                },
          )
          .extract(),
      } satisfies UnionPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      UnionPropertiesClass.$properties.narrowLiteralsProperty["identifier"],
      ...this.narrowLiteralsProperty
        .toList()
        .flatMap(
          (value) =>
            [value] as readonly Parameters<
              rdfjsResource.MutableResource["add"]
            >[1][],
        ),
    );
    resource.add(
      UnionPropertiesClass.$properties.unrelatedTypesProperty["identifier"],
      ...this.unrelatedTypesProperty.toList().flatMap((value) =>
        typeof value === "object"
          ? ([
              value.$toRdf({
                mutateGraph: mutateGraph,
                resourceSet: resourceSet,
              }).identifier,
            ] as readonly Parameters<rdfjsResource.MutableResource["add"]>[1][])
          : ([value] as readonly Parameters<
              rdfjsResource.MutableResource["add"]
            >[1][]),
      ),
    );
    resource.add(
      UnionPropertiesClass.$properties.widenedLiteralsProperty["identifier"],
      ...this.widenedLiteralsProperty.toList(),
    );
    resource.add(
      UnionPropertiesClass.$properties.widenedTermsProperty["identifier"],
      ...this.widenedTermsProperty.toList(),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace UnionPropertiesClass {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "UnionPropertiesClass";
    readonly narrowLiteralsProperty?: number | string;
    readonly unrelatedTypesProperty?: number | NonClass.$Json;
    readonly widenedLiteralsProperty?: {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    };
    readonly widenedTermsProperty?:
      | { readonly "@id": string; readonly termType: "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly "@type"?: string;
          readonly "@value": string;
          readonly termType: "Literal";
        };
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      narrowLiteralsProperty: purify.Maybe<number | string>;
      unrelatedTypesProperty: purify.Maybe<number | NonClass>;
      widenedLiteralsProperty: purify.Maybe<rdfjs.Literal>;
      widenedTermsProperty: purify.Maybe<rdfjs.Literal | rdfjs.NamedNode>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const narrowLiteralsProperty = purify.Maybe.fromNullable(
      $jsonObject["narrowLiteralsProperty"],
    );
    const unrelatedTypesProperty = purify.Maybe.fromNullable(
      $jsonObject["unrelatedTypesProperty"],
    ).map((item) =>
      typeof item === "object" ? NonClass.$fromJson(item).unsafeCoerce() : item,
    );
    const widenedLiteralsProperty = purify.Maybe.fromNullable(
      $jsonObject["widenedLiteralsProperty"],
    ).map((item) =>
      dataFactory.literal(
        item["@value"],
        typeof item["@language"] !== "undefined"
          ? item["@language"]
          : typeof item["@type"] !== "undefined"
            ? dataFactory.namedNode(item["@type"])
            : undefined,
      ),
    );
    const widenedTermsProperty = purify.Maybe.fromNullable(
      $jsonObject["widenedTermsProperty"],
    ).map((item) =>
      item.termType === "NamedNode"
        ? dataFactory.namedNode(item["@id"])
        : dataFactory.literal(
            item["@value"],
            typeof item["@language"] !== "undefined"
              ? item["@language"]
              : typeof item["@type"] !== "undefined"
                ? dataFactory.namedNode(item["@type"])
                : undefined,
          ),
    );
    return purify.Either.of({
      $identifier,
      narrowLiteralsProperty,
      unrelatedTypesProperty,
      widenedLiteralsProperty,
      widenedTermsProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, UnionPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new UnionPropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "UnionPropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/narrowLiteralsProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/unrelatedTypesProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/widenedLiteralsProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/widenedTermsProperty`,
          type: "Control",
        },
      ],
      label: "UnionPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("UnionPropertiesClass"),
      narrowLiteralsProperty: zod
        .union([zod.number(), zod.string()])
        .optional(),
      unrelatedTypesProperty: zod
        .union([zod.number(), NonClass.$jsonZodSchema()])
        .optional(),
      widenedLiteralsProperty: zod
        .object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
        })
        .optional(),
      widenedTermsProperty: zod
        .discriminatedUnion("termType", [
          zod.object({
            "@language": zod.string().optional(),
            "@type": zod.string().optional(),
            "@value": zod.string(),
            termType: zod.literal("Literal"),
          }),
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("NamedNode"),
          }),
        ])
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, UnionPropertiesClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return UnionPropertiesClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new UnionPropertiesClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      narrowLiteralsProperty: purify.Maybe<number | string>;
      unrelatedTypesProperty: purify.Maybe<number | NonClass>;
      widenedLiteralsProperty: purify.Maybe<rdfjs.Literal>;
      widenedTermsProperty: purify.Maybe<rdfjs.Literal | rdfjs.NamedNode>;
    }
  > {
    const $identifier: UnionPropertiesClass.$Identifier = $resource.identifier;
    const _narrowLiteralsPropertyEither: purify.Either<
      Error,
      purify.Maybe<number | string>
    > = (
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.narrowLiteralsProperty["identifier"], {
          unique: true,
        }),
      ).chain((values) =>
        values.chainMap((value) => value.toNumber()),
      ) as purify.Either<Error, rdfjsResource.Resource.Values<number | string>>
    )
      .altLazy(
        () =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            $resource.values($properties.narrowLiteralsProperty["identifier"], {
              unique: true,
            }),
          )
            .chain((values) => {
              if (!$preferredLanguages || $preferredLanguages.length === 0) {
                return purify.Either.of<
                  Error,
                  rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
                >(values);
              }

              const literalValuesEither = values.chainMap((value) =>
                value.toLiteral(),
              );
              if (literalValuesEither.isLeft()) {
                return literalValuesEither;
              }
              const literalValues = literalValuesEither.unsafeCoerce();

              // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
              // Within a preferredLanguage the literals may be in any order.
              let filteredLiteralValues:
                | rdfjsResource.Resource.Values<rdfjs.Literal>
                | undefined;
              for (const preferredLanguage of $preferredLanguages) {
                if (!filteredLiteralValues) {
                  filteredLiteralValues = literalValues.filter(
                    (value) => value.language === preferredLanguage,
                  );
                } else {
                  filteredLiteralValues = filteredLiteralValues.concat(
                    ...literalValues
                      .filter((value) => value.language === preferredLanguage)
                      .toArray(),
                  );
                }
              }

              return purify.Either.of<
                Error,
                rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
              >(
                filteredLiteralValues!.map(
                  (literalValue) =>
                    new rdfjsResource.Resource.Value({
                      object: literalValue,
                      predicate:
                        UnionPropertiesClass.$properties.narrowLiteralsProperty[
                          "identifier"
                        ],
                      subject: $resource,
                    }),
                ),
              );
            })
            .chain((values) =>
              values.chainMap((value) => value.toString()),
            ) as purify.Either<
            Error,
            rdfjsResource.Resource.Values<number | string>
          >,
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<number | string>
            >({
              object: purify.Maybe.empty(),
              predicate:
                UnionPropertiesClass.$properties.narrowLiteralsProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_narrowLiteralsPropertyEither.isLeft()) {
      return _narrowLiteralsPropertyEither;
    }

    const narrowLiteralsProperty = _narrowLiteralsPropertyEither.unsafeCoerce();
    const _unrelatedTypesPropertyEither: purify.Either<
      Error,
      purify.Maybe<number | NonClass>
    > = (
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.unrelatedTypesProperty["identifier"], {
          unique: true,
        }),
      ).chain((values) =>
        values.chainMap((value) => value.toNumber()),
      ) as purify.Either<
        Error,
        rdfjsResource.Resource.Values<number | NonClass>
      >
    )
      .altLazy(
        () =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            $resource.values($properties.unrelatedTypesProperty["identifier"], {
              unique: true,
            }),
          ).chain((values) =>
            values.chainMap((value) =>
              value.toResource().chain((resource) =>
                NonClass.$fromRdf(resource, {
                  ...$context,
                  objectSet: $objectSet,
                  preferredLanguages: $preferredLanguages,
                }),
              ),
            ),
          ) as purify.Either<
            Error,
            rdfjsResource.Resource.Values<number | NonClass>
          >,
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<number | NonClass>
            >({
              object: purify.Maybe.empty(),
              predicate:
                UnionPropertiesClass.$properties.unrelatedTypesProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_unrelatedTypesPropertyEither.isLeft()) {
      return _unrelatedTypesPropertyEither;
    }

    const unrelatedTypesProperty = _unrelatedTypesPropertyEither.unsafeCoerce();
    const _widenedLiteralsPropertyEither: purify.Either<
      Error,
      purify.Maybe<rdfjs.Literal>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.widenedLiteralsProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => {
        if (!$preferredLanguages || $preferredLanguages.length === 0) {
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(values);
        }

        const literalValuesEither = values.chainMap((value) =>
          value.toLiteral(),
        );
        if (literalValuesEither.isLeft()) {
          return literalValuesEither;
        }
        const literalValues = literalValuesEither.unsafeCoerce();

        // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
        // Within a preferredLanguage the literals may be in any order.
        let filteredLiteralValues:
          | rdfjsResource.Resource.Values<rdfjs.Literal>
          | undefined;
        for (const preferredLanguage of $preferredLanguages) {
          if (!filteredLiteralValues) {
            filteredLiteralValues = literalValues.filter(
              (value) => value.language === preferredLanguage,
            );
          } else {
            filteredLiteralValues = filteredLiteralValues.concat(
              ...literalValues
                .filter((value) => value.language === preferredLanguage)
                .toArray(),
            );
          }
        }

        return purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
        >(
          filteredLiteralValues!.map(
            (literalValue) =>
              new rdfjsResource.Resource.Value({
                object: literalValue,
                predicate:
                  UnionPropertiesClass.$properties.widenedLiteralsProperty[
                    "identifier"
                  ],
                subject: $resource,
              }),
          ),
        );
      })
      .chain((values) => values.chainMap((value) => value.toLiteral()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<rdfjs.Literal>
            >({
              object: purify.Maybe.empty(),
              predicate:
                UnionPropertiesClass.$properties.widenedLiteralsProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_widenedLiteralsPropertyEither.isLeft()) {
      return _widenedLiteralsPropertyEither;
    }

    const widenedLiteralsProperty =
      _widenedLiteralsPropertyEither.unsafeCoerce();
    const _widenedTermsPropertyEither: purify.Either<
      Error,
      purify.Maybe<rdfjs.Literal | rdfjs.NamedNode>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.widenedTermsProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) =>
        values.chainMap((value) =>
          purify.Either.of<
            Error,
            rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
          >(value.toTerm()).chain((term) => {
            switch (term.termType) {
              case "Literal":
              case "NamedNode":
                return purify.Either.of<Error, rdfjs.Literal | rdfjs.NamedNode>(
                  term,
                );
              default:
                return purify.Left<Error, rdfjs.Literal | rdfjs.NamedNode>(
                  new rdfjsResource.Resource.MistypedValueError({
                    actualValue: term,
                    expectedValueType: "(rdfjs.Literal | rdfjs.NamedNode)",
                    focusResource: $resource,
                    predicate:
                      UnionPropertiesClass.$properties.widenedTermsProperty[
                        "identifier"
                      ],
                  }),
                );
            }
          }),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<rdfjs.Literal | rdfjs.NamedNode>
            >({
              object: purify.Maybe.empty(),
              predicate:
                UnionPropertiesClass.$properties.widenedTermsProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_widenedTermsPropertyEither.isLeft()) {
      return _widenedTermsPropertyEither;
    }

    const widenedTermsProperty = _widenedTermsPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      narrowLiteralsProperty,
      unrelatedTypesProperty,
      widenedLiteralsProperty,
      widenedTermsProperty,
    });
  }

  export const $properties = {
    narrowLiteralsProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/narrowLiteralsProperty",
      ),
    },
    unrelatedTypesProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/unrelatedTypesProperty",
      ),
    },
    widenedLiteralsProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/widenedLiteralsProperty",
      ),
    },
    widenedTermsProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/widenedTermsProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        UnionPropertiesClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        UnionPropertiesClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      UnionPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("unionPropertiesClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "unionPropertiesClass");
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}NarrowLiteralsProperty`),
      predicate:
        UnionPropertiesClass.$properties.narrowLiteralsProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}UnrelatedTypesProperty`),
      predicate:
        UnionPropertiesClass.$properties.unrelatedTypesProperty["identifier"],
      subject,
    });
    triples.push(
      ...NonClass.$sparqlConstructTemplateTriples({
        subject: dataFactory.variable!(
          `${variablePrefix}UnrelatedTypesProperty`,
        ),
        variablePrefix: `${variablePrefix}UnrelatedTypesProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}WidenedLiteralsProperty`),
      predicate:
        UnionPropertiesClass.$properties.widenedLiteralsProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}WidenedTermsProperty`),
      predicate:
        UnionPropertiesClass.$properties.widenedTermsProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("unionPropertiesClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "unionPropertiesClass");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            patterns: [
              {
                patterns: [
                  {
                    triples: [
                      {
                        object: dataFactory.variable!(
                          `${variablePrefix}NarrowLiteralsProperty`,
                        ),
                        predicate:
                          UnionPropertiesClass.$properties
                            .narrowLiteralsProperty["identifier"],
                        subject,
                      },
                    ],
                    type: "bgp",
                  },
                ],
                type: "group",
              },
              {
                patterns: [
                  {
                    triples: [
                      {
                        object: dataFactory.variable!(
                          `${variablePrefix}NarrowLiteralsProperty`,
                        ),
                        predicate:
                          UnionPropertiesClass.$properties
                            .narrowLiteralsProperty["identifier"],
                        subject,
                      },
                    ],
                    type: "bgp",
                  },
                  ...[parameters?.preferredLanguages ?? []]
                    .filter((languages) => languages.length > 0)
                    .map((languages) =>
                      languages.map((language) => ({
                        type: "operation" as const,
                        operator: "=",
                        args: [
                          {
                            type: "operation" as const,
                            operator: "lang",
                            args: [
                              dataFactory.variable!(
                                `${variablePrefix}NarrowLiteralsProperty`,
                              ),
                            ],
                          },
                          dataFactory.literal(language),
                        ],
                      })),
                    )
                    .map((langEqualsExpressions) => ({
                      type: "filter" as const,
                      expression: langEqualsExpressions.reduce(
                        (reducedExpression, langEqualsExpression) => {
                          if (reducedExpression === null) {
                            return langEqualsExpression;
                          }
                          return {
                            type: "operation" as const,
                            operator: "||",
                            args: [reducedExpression, langEqualsExpression],
                          };
                        },
                        null as sparqljs.Expression | null,
                      ) as sparqljs.Expression,
                    })),
                ],
                type: "group",
              },
            ],
            type: "union",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            patterns: [
              {
                patterns: [
                  {
                    triples: [
                      {
                        object: dataFactory.variable!(
                          `${variablePrefix}UnrelatedTypesProperty`,
                        ),
                        predicate:
                          UnionPropertiesClass.$properties
                            .unrelatedTypesProperty["identifier"],
                        subject,
                      },
                    ],
                    type: "bgp",
                  },
                ],
                type: "group",
              },
              {
                patterns: [
                  {
                    triples: [
                      {
                        object: dataFactory.variable!(
                          `${variablePrefix}UnrelatedTypesProperty`,
                        ),
                        predicate:
                          UnionPropertiesClass.$properties
                            .unrelatedTypesProperty["identifier"],
                        subject,
                      },
                    ],
                    type: "bgp",
                  },
                  ...NonClass.$sparqlWherePatterns({
                    preferredLanguages: parameters?.preferredLanguages,
                    subject: dataFactory.variable!(
                      `${variablePrefix}UnrelatedTypesProperty`,
                    ),
                    variablePrefix: `${variablePrefix}UnrelatedTypesProperty`,
                  }),
                ],
                type: "group",
              },
            ],
            type: "union",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}WidenedLiteralsProperty`,
                ),
                predicate:
                  UnionPropertiesClass.$properties.widenedLiteralsProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
          ...[parameters?.preferredLanguages ?? []]
            .filter((languages) => languages.length > 0)
            .map((languages) =>
              languages.map((language) => ({
                type: "operation" as const,
                operator: "=",
                args: [
                  {
                    type: "operation" as const,
                    operator: "lang",
                    args: [
                      dataFactory.variable!(
                        `${variablePrefix}WidenedLiteralsProperty`,
                      ),
                    ],
                  },
                  dataFactory.literal(language),
                ],
              })),
            )
            .map((langEqualsExpressions) => ({
              type: "filter" as const,
              expression: langEqualsExpressions.reduce(
                (reducedExpression, langEqualsExpression) => {
                  if (reducedExpression === null) {
                    return langEqualsExpression;
                  }
                  return {
                    type: "operation" as const,
                    operator: "||",
                    args: [reducedExpression, langEqualsExpression],
                  };
                },
                null as sparqljs.Expression | null,
              ) as sparqljs.Expression,
            })),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}WidenedTermsProperty`,
                ),
                predicate:
                  UnionPropertiesClass.$properties.widenedTermsProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Shape with properties that are not nested objects
 */
export class TermPropertiesClass {
  private _$identifier?: TermPropertiesClass.$Identifier;
  readonly $type = "TermPropertiesClass";
  readonly booleanTermProperty: purify.Maybe<boolean>;
  readonly dateTermProperty: purify.Maybe<Date>;
  readonly dateTimeTermProperty: purify.Maybe<Date>;
  readonly iriTermProperty: purify.Maybe<rdfjs.NamedNode>;
  readonly literalTermProperty: purify.Maybe<rdfjs.Literal>;
  readonly numberTermProperty: purify.Maybe<number>;
  readonly stringTermProperty: purify.Maybe<string>;
  readonly termProperty: purify.Maybe<
    rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal
  >;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly booleanTermProperty?: boolean | purify.Maybe<boolean>;
    readonly dateTermProperty?: Date | purify.Maybe<Date>;
    readonly dateTimeTermProperty?: Date | purify.Maybe<Date>;
    readonly iriTermProperty?:
      | rdfjs.NamedNode
      | purify.Maybe<rdfjs.NamedNode>
      | string;
    readonly literalTermProperty?:
      | rdfjs.Literal
      | Date
      | boolean
      | number
      | purify.Maybe<rdfjs.Literal>
      | string;
    readonly numberTermProperty?: number | purify.Maybe<number>;
    readonly stringTermProperty?: purify.Maybe<string> | string;
    readonly termProperty?:
      | (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)
      | Date
      | boolean
      | number
      | purify.Maybe<rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal>
      | string;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.booleanTermProperty)) {
      this.booleanTermProperty = parameters?.booleanTermProperty;
    } else if (typeof parameters?.booleanTermProperty === "boolean") {
      this.booleanTermProperty = purify.Maybe.of(
        parameters?.booleanTermProperty,
      );
    } else if (typeof parameters?.booleanTermProperty === "undefined") {
      this.booleanTermProperty = purify.Maybe.empty();
    } else {
      this.booleanTermProperty =
        parameters?.booleanTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.dateTermProperty)) {
      this.dateTermProperty = parameters?.dateTermProperty;
    } else if (
      typeof parameters?.dateTermProperty === "object" &&
      parameters?.dateTermProperty instanceof Date
    ) {
      this.dateTermProperty = purify.Maybe.of(parameters?.dateTermProperty);
    } else if (typeof parameters?.dateTermProperty === "undefined") {
      this.dateTermProperty = purify.Maybe.empty();
    } else {
      this.dateTermProperty = parameters?.dateTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.dateTimeTermProperty)) {
      this.dateTimeTermProperty = parameters?.dateTimeTermProperty;
    } else if (
      typeof parameters?.dateTimeTermProperty === "object" &&
      parameters?.dateTimeTermProperty instanceof Date
    ) {
      this.dateTimeTermProperty = purify.Maybe.of(
        parameters?.dateTimeTermProperty,
      );
    } else if (typeof parameters?.dateTimeTermProperty === "undefined") {
      this.dateTimeTermProperty = purify.Maybe.empty();
    } else {
      this.dateTimeTermProperty =
        parameters?.dateTimeTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.iriTermProperty)) {
      this.iriTermProperty = parameters?.iriTermProperty;
    } else if (typeof parameters?.iriTermProperty === "object") {
      this.iriTermProperty = purify.Maybe.of(parameters?.iriTermProperty);
    } else if (typeof parameters?.iriTermProperty === "string") {
      this.iriTermProperty = purify.Maybe.of(
        dataFactory.namedNode(parameters?.iriTermProperty),
      );
    } else if (typeof parameters?.iriTermProperty === "undefined") {
      this.iriTermProperty = purify.Maybe.empty();
    } else {
      this.iriTermProperty = parameters?.iriTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.literalTermProperty)) {
      this.literalTermProperty = parameters?.literalTermProperty;
    } else if (typeof parameters?.literalTermProperty === "boolean") {
      this.literalTermProperty = purify.Maybe.of(
        rdfLiteral.toRdf(parameters?.literalTermProperty, { dataFactory }),
      );
    } else if (
      typeof parameters?.literalTermProperty === "object" &&
      parameters?.literalTermProperty instanceof Date
    ) {
      this.literalTermProperty = purify.Maybe.of(
        rdfLiteral.toRdf(parameters?.literalTermProperty, { dataFactory }),
      );
    } else if (typeof parameters?.literalTermProperty === "number") {
      this.literalTermProperty = purify.Maybe.of(
        rdfLiteral.toRdf(parameters?.literalTermProperty, { dataFactory }),
      );
    } else if (typeof parameters?.literalTermProperty === "string") {
      this.literalTermProperty = purify.Maybe.of(
        dataFactory.literal(parameters?.literalTermProperty),
      );
    } else if (typeof parameters?.literalTermProperty === "object") {
      this.literalTermProperty = purify.Maybe.of(
        parameters?.literalTermProperty,
      );
    } else if (typeof parameters?.literalTermProperty === "undefined") {
      this.literalTermProperty = purify.Maybe.empty();
    } else {
      this.literalTermProperty =
        parameters?.literalTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.numberTermProperty)) {
      this.numberTermProperty = parameters?.numberTermProperty;
    } else if (typeof parameters?.numberTermProperty === "number") {
      this.numberTermProperty = purify.Maybe.of(parameters?.numberTermProperty);
    } else if (typeof parameters?.numberTermProperty === "undefined") {
      this.numberTermProperty = purify.Maybe.empty();
    } else {
      this.numberTermProperty = parameters?.numberTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.stringTermProperty)) {
      this.stringTermProperty = parameters?.stringTermProperty;
    } else if (typeof parameters?.stringTermProperty === "string") {
      this.stringTermProperty = purify.Maybe.of(parameters?.stringTermProperty);
    } else if (typeof parameters?.stringTermProperty === "undefined") {
      this.stringTermProperty = purify.Maybe.empty();
    } else {
      this.stringTermProperty = parameters?.stringTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.termProperty)) {
      this.termProperty = parameters?.termProperty;
    } else if (typeof parameters?.termProperty === "boolean") {
      this.termProperty = purify.Maybe.of(
        rdfLiteral.toRdf(parameters?.termProperty, { dataFactory }),
      );
    } else if (
      typeof parameters?.termProperty === "object" &&
      parameters?.termProperty instanceof Date
    ) {
      this.termProperty = purify.Maybe.of(
        rdfLiteral.toRdf(parameters?.termProperty, { dataFactory }),
      );
    } else if (typeof parameters?.termProperty === "number") {
      this.termProperty = purify.Maybe.of(
        rdfLiteral.toRdf(parameters?.termProperty, { dataFactory }),
      );
    } else if (typeof parameters?.termProperty === "string") {
      this.termProperty = purify.Maybe.of(
        dataFactory.literal(parameters?.termProperty),
      );
    } else if (typeof parameters?.termProperty === "object") {
      this.termProperty = purify.Maybe.of(parameters?.termProperty);
    } else if (typeof parameters?.termProperty === "undefined") {
      this.termProperty = purify.Maybe.empty();
    } else {
      this.termProperty = parameters?.termProperty satisfies never;
    }
  }

  get $identifier(): TermPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: TermPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.booleanTermProperty,
          other.booleanTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "booleanTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.dateTermProperty,
          other.dateTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "dateTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.dateTimeTermProperty,
          other.dateTimeTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "dateTimeTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.iriTermProperty,
          other.iriTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "iriTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.literalTermProperty,
          other.literalTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "literalTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.numberTermProperty,
          other.numberTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "numberTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.stringTermProperty,
          other.stringTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "stringTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.termProperty,
          other.termProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "termProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.booleanTermProperty.ifJust((value0) => {
      _hasher.update(value0.toString());
    });
    this.dateTermProperty.ifJust((value0) => {
      _hasher.update(value0.toISOString());
    });
    this.dateTimeTermProperty.ifJust((value0) => {
      _hasher.update(value0.toISOString());
    });
    this.iriTermProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    this.literalTermProperty.ifJust((value0) => {
      _hasher.update(value0.datatype.value);
      _hasher.update(value0.language);
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    this.numberTermProperty.ifJust((value0) => {
      _hasher.update(value0.toString());
    });
    this.stringTermProperty.ifJust((value0) => {
      _hasher.update(value0);
    });
    this.termProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    return _hasher;
  }

  $toJson(): TermPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        booleanTermProperty: this.booleanTermProperty
          .map((item) => item)
          .extract(),
        dateTermProperty: this.dateTermProperty
          .map((item) => item.toISOString().replace(/T.*$/, ""))
          .extract(),
        dateTimeTermProperty: this.dateTimeTermProperty
          .map((item) => item.toISOString())
          .extract(),
        iriTermProperty: this.iriTermProperty
          .map((item) => ({ "@id": item.value }))
          .extract(),
        literalTermProperty: this.literalTermProperty
          .map((item) => ({
            "@language": item.language.length > 0 ? item.language : undefined,
            "@type":
              item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? item.datatype.value
                : undefined,
            "@value": item.value,
          }))
          .extract(),
        numberTermProperty: this.numberTermProperty
          .map((item) => item)
          .extract(),
        stringTermProperty: this.stringTermProperty
          .map((item) => item)
          .extract(),
        termProperty: this.termProperty
          .map((item) =>
            item.termType === "Literal"
              ? {
                  "@language":
                    item.language.length > 0 ? item.language : undefined,
                  "@type":
                    item.datatype.value !==
                    "http://www.w3.org/2001/XMLSchema#string"
                      ? item.datatype.value
                      : undefined,
                  "@value": item.value,
                  termType: "Literal" as const,
                }
              : item.termType === "NamedNode"
                ? { "@id": item.value, termType: "NamedNode" as const }
                : { "@id": `_:${item.value}`, termType: "BlankNode" as const },
          )
          .extract(),
      } satisfies TermPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      TermPropertiesClass.$properties.booleanTermProperty["identifier"],
      ...this.booleanTermProperty.toList().flat(),
    );
    resource.add(
      TermPropertiesClass.$properties.dateTermProperty["identifier"],
      ...this.dateTermProperty.toList().flatMap((value) => [
        rdfLiteral.toRdf(value, {
          dataFactory,
          datatype: $RdfVocabularies.xsd.date,
        }),
      ]),
    );
    resource.add(
      TermPropertiesClass.$properties.dateTimeTermProperty["identifier"],
      ...this.dateTimeTermProperty.toList().flatMap((value) => [
        rdfLiteral.toRdf(value, {
          dataFactory,
          datatype: $RdfVocabularies.xsd.dateTime,
        }),
      ]),
    );
    resource.add(
      TermPropertiesClass.$properties.iriTermProperty["identifier"],
      ...this.iriTermProperty.toList(),
    );
    resource.add(
      TermPropertiesClass.$properties.literalTermProperty["identifier"],
      ...this.literalTermProperty.toList(),
    );
    resource.add(
      TermPropertiesClass.$properties.numberTermProperty["identifier"],
      ...this.numberTermProperty.toList(),
    );
    resource.add(
      TermPropertiesClass.$properties.stringTermProperty["identifier"],
      ...this.stringTermProperty.toList(),
    );
    resource.add(
      TermPropertiesClass.$properties.termProperty["identifier"],
      ...this.termProperty.toList(),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace TermPropertiesClass {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "TermPropertiesClass";
    readonly booleanTermProperty?: boolean;
    readonly dateTermProperty?: string;
    readonly dateTimeTermProperty?: string;
    readonly iriTermProperty?: { readonly "@id": string };
    readonly literalTermProperty?: {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    };
    readonly numberTermProperty?: number;
    readonly stringTermProperty?: string;
    readonly termProperty?:
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly "@type"?: string;
          readonly "@value": string;
          readonly termType: "Literal";
        };
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      booleanTermProperty: purify.Maybe<boolean>;
      dateTermProperty: purify.Maybe<Date>;
      dateTimeTermProperty: purify.Maybe<Date>;
      iriTermProperty: purify.Maybe<rdfjs.NamedNode>;
      literalTermProperty: purify.Maybe<rdfjs.Literal>;
      numberTermProperty: purify.Maybe<number>;
      stringTermProperty: purify.Maybe<string>;
      termProperty: purify.Maybe<
        rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal
      >;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const booleanTermProperty = purify.Maybe.fromNullable(
      $jsonObject["booleanTermProperty"],
    );
    const dateTermProperty = purify.Maybe.fromNullable(
      $jsonObject["dateTermProperty"],
    ).map((item) => new Date(item));
    const dateTimeTermProperty = purify.Maybe.fromNullable(
      $jsonObject["dateTimeTermProperty"],
    ).map((item) => new Date(item));
    const iriTermProperty = purify.Maybe.fromNullable(
      $jsonObject["iriTermProperty"],
    ).map((item) => dataFactory.namedNode(item["@id"]));
    const literalTermProperty = purify.Maybe.fromNullable(
      $jsonObject["literalTermProperty"],
    ).map((item) =>
      dataFactory.literal(
        item["@value"],
        typeof item["@language"] !== "undefined"
          ? item["@language"]
          : typeof item["@type"] !== "undefined"
            ? dataFactory.namedNode(item["@type"])
            : undefined,
      ),
    );
    const numberTermProperty = purify.Maybe.fromNullable(
      $jsonObject["numberTermProperty"],
    );
    const stringTermProperty = purify.Maybe.fromNullable(
      $jsonObject["stringTermProperty"],
    );
    const termProperty = purify.Maybe.fromNullable(
      $jsonObject["termProperty"],
    ).map((item) =>
      item.termType === "Literal"
        ? dataFactory.literal(
            item["@value"],
            typeof item["@language"] !== "undefined"
              ? item["@language"]
              : typeof item["@type"] !== "undefined"
                ? dataFactory.namedNode(item["@type"])
                : undefined,
          )
        : item.termType === "NamedNode"
          ? dataFactory.namedNode(item["@id"])
          : dataFactory.blankNode(item["@id"].substring(2)),
    );
    return purify.Either.of({
      $identifier,
      booleanTermProperty,
      dateTermProperty,
      dateTimeTermProperty,
      iriTermProperty,
      literalTermProperty,
      numberTermProperty,
      stringTermProperty,
      termProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, TermPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new TermPropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "TermPropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/booleanTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateTimeTermProperty`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/iriTermProperty`, type: "Control" },
        {
          scope: `${scopePrefix}/properties/literalTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/numberTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/stringTermProperty`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/termProperty`, type: "Control" },
      ],
      label: "TermPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("TermPropertiesClass"),
      booleanTermProperty: zod.boolean().optional(),
      dateTermProperty: zod.string().date().optional(),
      dateTimeTermProperty: zod.string().datetime().optional(),
      iriTermProperty: zod.object({ "@id": zod.string().min(1) }).optional(),
      literalTermProperty: zod
        .object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
        })
        .optional(),
      numberTermProperty: zod.number().optional(),
      stringTermProperty: zod.string().optional(),
      termProperty: zod
        .discriminatedUnion("termType", [
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("BlankNode"),
          }),
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("NamedNode"),
          }),
          zod.object({
            "@language": zod.string().optional(),
            "@type": zod.string().optional(),
            "@value": zod.string(),
            termType: zod.literal("Literal"),
          }),
        ])
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, TermPropertiesClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return TermPropertiesClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new TermPropertiesClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      booleanTermProperty: purify.Maybe<boolean>;
      dateTermProperty: purify.Maybe<Date>;
      dateTimeTermProperty: purify.Maybe<Date>;
      iriTermProperty: purify.Maybe<rdfjs.NamedNode>;
      literalTermProperty: purify.Maybe<rdfjs.Literal>;
      numberTermProperty: purify.Maybe<number>;
      stringTermProperty: purify.Maybe<string>;
      termProperty: purify.Maybe<
        rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal
      >;
    }
  > {
    const $identifier: TermPropertiesClass.$Identifier = $resource.identifier;
    const _booleanTermPropertyEither: purify.Either<
      Error,
      purify.Maybe<boolean>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.booleanTermProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => values.chainMap((value) => value.toBoolean()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<boolean>>({
              object: purify.Maybe.empty(),
              predicate:
                TermPropertiesClass.$properties.booleanTermProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_booleanTermPropertyEither.isLeft()) {
      return _booleanTermPropertyEither;
    }

    const booleanTermProperty = _booleanTermPropertyEither.unsafeCoerce();
    const _dateTermPropertyEither: purify.Either<
      Error,
      purify.Maybe<Date>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.dateTermProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => values.chainMap((value) => value.toDate()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<Date>>({
              object: purify.Maybe.empty(),
              predicate:
                TermPropertiesClass.$properties.dateTermProperty["identifier"],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_dateTermPropertyEither.isLeft()) {
      return _dateTermPropertyEither;
    }

    const dateTermProperty = _dateTermPropertyEither.unsafeCoerce();
    const _dateTimeTermPropertyEither: purify.Either<
      Error,
      purify.Maybe<Date>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.dateTimeTermProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => values.chainMap((value) => value.toDate()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<Date>>({
              object: purify.Maybe.empty(),
              predicate:
                TermPropertiesClass.$properties.dateTimeTermProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_dateTimeTermPropertyEither.isLeft()) {
      return _dateTimeTermPropertyEither;
    }

    const dateTimeTermProperty = _dateTimeTermPropertyEither.unsafeCoerce();
    const _iriTermPropertyEither: purify.Either<
      Error,
      purify.Maybe<rdfjs.NamedNode>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.iriTermProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => values.chainMap((value) => value.toIri()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<rdfjs.NamedNode>
            >({
              object: purify.Maybe.empty(),
              predicate:
                TermPropertiesClass.$properties.iriTermProperty["identifier"],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_iriTermPropertyEither.isLeft()) {
      return _iriTermPropertyEither;
    }

    const iriTermProperty = _iriTermPropertyEither.unsafeCoerce();
    const _literalTermPropertyEither: purify.Either<
      Error,
      purify.Maybe<rdfjs.Literal>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.literalTermProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => {
        if (!$preferredLanguages || $preferredLanguages.length === 0) {
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(values);
        }

        const literalValuesEither = values.chainMap((value) =>
          value.toLiteral(),
        );
        if (literalValuesEither.isLeft()) {
          return literalValuesEither;
        }
        const literalValues = literalValuesEither.unsafeCoerce();

        // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
        // Within a preferredLanguage the literals may be in any order.
        let filteredLiteralValues:
          | rdfjsResource.Resource.Values<rdfjs.Literal>
          | undefined;
        for (const preferredLanguage of $preferredLanguages) {
          if (!filteredLiteralValues) {
            filteredLiteralValues = literalValues.filter(
              (value) => value.language === preferredLanguage,
            );
          } else {
            filteredLiteralValues = filteredLiteralValues.concat(
              ...literalValues
                .filter((value) => value.language === preferredLanguage)
                .toArray(),
            );
          }
        }

        return purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
        >(
          filteredLiteralValues!.map(
            (literalValue) =>
              new rdfjsResource.Resource.Value({
                object: literalValue,
                predicate:
                  TermPropertiesClass.$properties.literalTermProperty[
                    "identifier"
                  ],
                subject: $resource,
              }),
          ),
        );
      })
      .chain((values) => values.chainMap((value) => value.toLiteral()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<rdfjs.Literal>
            >({
              object: purify.Maybe.empty(),
              predicate:
                TermPropertiesClass.$properties.literalTermProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_literalTermPropertyEither.isLeft()) {
      return _literalTermPropertyEither;
    }

    const literalTermProperty = _literalTermPropertyEither.unsafeCoerce();
    const _numberTermPropertyEither: purify.Either<
      Error,
      purify.Maybe<number>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.numberTermProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => values.chainMap((value) => value.toNumber()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<number>>({
              object: purify.Maybe.empty(),
              predicate:
                TermPropertiesClass.$properties.numberTermProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_numberTermPropertyEither.isLeft()) {
      return _numberTermPropertyEither;
    }

    const numberTermProperty = _numberTermPropertyEither.unsafeCoerce();
    const _stringTermPropertyEither: purify.Either<
      Error,
      purify.Maybe<string>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.stringTermProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => {
        if (!$preferredLanguages || $preferredLanguages.length === 0) {
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(values);
        }

        const literalValuesEither = values.chainMap((value) =>
          value.toLiteral(),
        );
        if (literalValuesEither.isLeft()) {
          return literalValuesEither;
        }
        const literalValues = literalValuesEither.unsafeCoerce();

        // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
        // Within a preferredLanguage the literals may be in any order.
        let filteredLiteralValues:
          | rdfjsResource.Resource.Values<rdfjs.Literal>
          | undefined;
        for (const preferredLanguage of $preferredLanguages) {
          if (!filteredLiteralValues) {
            filteredLiteralValues = literalValues.filter(
              (value) => value.language === preferredLanguage,
            );
          } else {
            filteredLiteralValues = filteredLiteralValues.concat(
              ...literalValues
                .filter((value) => value.language === preferredLanguage)
                .toArray(),
            );
          }
        }

        return purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
        >(
          filteredLiteralValues!.map(
            (literalValue) =>
              new rdfjsResource.Resource.Value({
                object: literalValue,
                predicate:
                  TermPropertiesClass.$properties.stringTermProperty[
                    "identifier"
                  ],
                subject: $resource,
              }),
          ),
        );
      })
      .chain((values) => values.chainMap((value) => value.toString()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<string>>({
              object: purify.Maybe.empty(),
              predicate:
                TermPropertiesClass.$properties.stringTermProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_stringTermPropertyEither.isLeft()) {
      return _stringTermPropertyEither;
    }

    const stringTermProperty = _stringTermPropertyEither.unsafeCoerce();
    const _termPropertyEither: purify.Either<
      Error,
      purify.Maybe<rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.termProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) =>
        values.chainMap((value) =>
          purify.Either.of<
            Error,
            rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
          >(value.toTerm()),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal>
            >({
              object: purify.Maybe.empty(),
              predicate:
                TermPropertiesClass.$properties.termProperty["identifier"],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_termPropertyEither.isLeft()) {
      return _termPropertyEither;
    }

    const termProperty = _termPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      booleanTermProperty,
      dateTermProperty,
      dateTimeTermProperty,
      iriTermProperty,
      literalTermProperty,
      numberTermProperty,
      stringTermProperty,
      termProperty,
    });
  }

  export const $properties = {
    booleanTermProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/booleanTermProperty",
      ),
    },
    dateTermProperty: {
      identifier: dataFactory.namedNode("http://example.com/dateTermProperty"),
    },
    dateTimeTermProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/dateTimeTermProperty",
      ),
    },
    iriTermProperty: {
      identifier: dataFactory.namedNode("http://example.com/iriTermProperty"),
    },
    literalTermProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/literalTermProperty",
      ),
    },
    numberTermProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/numberTermProperty",
      ),
    },
    stringTermProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/stringTermProperty",
      ),
    },
    termProperty: {
      identifier: dataFactory.namedNode("http://example.com/termProperty"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        TermPropertiesClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        TermPropertiesClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      TermPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("termPropertiesClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "termPropertiesClass");
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}BooleanTermProperty`),
      predicate:
        TermPropertiesClass.$properties.booleanTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}DateTermProperty`),
      predicate: TermPropertiesClass.$properties.dateTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}DateTimeTermProperty`),
      predicate:
        TermPropertiesClass.$properties.dateTimeTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}IriTermProperty`),
      predicate: TermPropertiesClass.$properties.iriTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}LiteralTermProperty`),
      predicate:
        TermPropertiesClass.$properties.literalTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}NumberTermProperty`),
      predicate:
        TermPropertiesClass.$properties.numberTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}StringTermProperty`),
      predicate:
        TermPropertiesClass.$properties.stringTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}TermProperty`),
      predicate: TermPropertiesClass.$properties.termProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("termPropertiesClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "termPropertiesClass");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}BooleanTermProperty`,
                ),
                predicate:
                  TermPropertiesClass.$properties.booleanTermProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}DateTermProperty`,
                ),
                predicate:
                  TermPropertiesClass.$properties.dateTermProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}DateTimeTermProperty`,
                ),
                predicate:
                  TermPropertiesClass.$properties.dateTimeTermProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}IriTermProperty`,
                ),
                predicate:
                  TermPropertiesClass.$properties.iriTermProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}LiteralTermProperty`,
                ),
                predicate:
                  TermPropertiesClass.$properties.literalTermProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
          ...[parameters?.preferredLanguages ?? []]
            .filter((languages) => languages.length > 0)
            .map((languages) =>
              languages.map((language) => ({
                type: "operation" as const,
                operator: "=",
                args: [
                  {
                    type: "operation" as const,
                    operator: "lang",
                    args: [
                      dataFactory.variable!(
                        `${variablePrefix}LiteralTermProperty`,
                      ),
                    ],
                  },
                  dataFactory.literal(language),
                ],
              })),
            )
            .map((langEqualsExpressions) => ({
              type: "filter" as const,
              expression: langEqualsExpressions.reduce(
                (reducedExpression, langEqualsExpression) => {
                  if (reducedExpression === null) {
                    return langEqualsExpression;
                  }
                  return {
                    type: "operation" as const,
                    operator: "||",
                    args: [reducedExpression, langEqualsExpression],
                  };
                },
                null as sparqljs.Expression | null,
              ) as sparqljs.Expression,
            })),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}NumberTermProperty`,
                ),
                predicate:
                  TermPropertiesClass.$properties.numberTermProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}StringTermProperty`,
                ),
                predicate:
                  TermPropertiesClass.$properties.stringTermProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
          ...[parameters?.preferredLanguages ?? []]
            .filter((languages) => languages.length > 0)
            .map((languages) =>
              languages.map((language) => ({
                type: "operation" as const,
                operator: "=",
                args: [
                  {
                    type: "operation" as const,
                    operator: "lang",
                    args: [
                      dataFactory.variable!(
                        `${variablePrefix}StringTermProperty`,
                      ),
                    ],
                  },
                  dataFactory.literal(language),
                ],
              })),
            )
            .map((langEqualsExpressions) => ({
              type: "filter" as const,
              expression: langEqualsExpressions.reduce(
                (reducedExpression, langEqualsExpression) => {
                  if (reducedExpression === null) {
                    return langEqualsExpression;
                  }
                  return {
                    type: "operation" as const,
                    operator: "||",
                    args: [reducedExpression, langEqualsExpression],
                  };
                },
                null as sparqljs.Expression | null,
              ) as sparqljs.Expression,
            })),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}TermProperty`),
                predicate:
                  TermPropertiesClass.$properties.termProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * A node shape that mints its identifier by hashing (other) contents, if no identifier is supplied.
 */
export class Sha256IriClass {
  private _$identifier?: Sha256IriClass.$Identifier;
  protected readonly _$identifierPrefix?: string;
  readonly $type = "Sha256IriClass";
  readonly sha256IriProperty: string;

  constructor(parameters: {
    readonly $identifier?: rdfjs.NamedNode | string;
    readonly $identifierPrefix?: string;
    readonly sha256IriProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this._$identifierPrefix = parameters.$identifierPrefix;
    this.sha256IriProperty = parameters.sha256IriProperty;
  }

  get $identifier(): Sha256IriClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }
    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  $equals(other: Sha256IriClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$identifierPrefix, other.$identifierPrefix).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$identifierPrefix",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.sha256IriProperty, other.sha256IriProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "sha256IriProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.sha256IriProperty);
    return _hasher;
  }

  $toJson(): Sha256IriClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
        sha256IriProperty: this.sha256IriProperty,
      } satisfies Sha256IriClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      Sha256IriClass.$properties.sha256IriProperty["identifier"],
      ...[this.sha256IriProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace Sha256IriClass {
  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "Sha256IriClass";
    readonly sha256IriProperty: string;
  };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.NamedNode; sha256IriProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const sha256IriProperty = $jsonObject["sha256IriProperty"];
    return purify.Either.of({ $identifier, sha256IriProperty });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Sha256IriClass> {
    return $propertiesFromJson(json).map(
      (properties) => new Sha256IriClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "Sha256IriClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/sha256IriProperty`,
          type: "Control",
        },
      ],
      label: "Sha256IriClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("Sha256IriClass"),
      sha256IriProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, Sha256IriClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return Sha256IriClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new Sha256IriClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.NamedNode; sha256IriProperty: string }
  > {
    if ($resource.identifier.termType !== "NamedNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedValueError({
          actualValue: $resource.identifier,
          expectedValueType: "(rdfjs.NamedNode)",
          focusResource: $resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: Sha256IriClass.$Identifier = $resource.identifier;
    const _sha256IriPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.sha256IriProperty["identifier"], {
          unique: true,
        }),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    Sha256IriClass.$properties.sha256IriProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_sha256IriPropertyEither.isLeft()) {
      return _sha256IriPropertyEither;
    }

    const sha256IriProperty = _sha256IriPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, sha256IriProperty });
  }

  export const $properties = {
    sha256IriProperty: {
      identifier: dataFactory.namedNode("http://example.com/sha256IriProperty"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Sha256IriClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Sha256IriClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Sha256IriClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("sha256IriClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "sha256IriClass");
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Sha256IriProperty`),
      predicate: Sha256IriClass.$properties.sha256IriProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("sha256IriClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "sha256IriClass");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Sha256IriProperty`),
            predicate:
              Sha256IriClass.$properties.sha256IriProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(`${variablePrefix}Sha256IriProperty`),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class RecursiveClassUnionMember2 {
  private _$identifier?: RecursiveClassUnionMember2.$Identifier;
  readonly $type = "RecursiveClassUnionMember2";
  readonly recursiveClassUnionMember2Property: purify.Maybe<RecursiveClassUnion>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly recursiveClassUnionMember2Property?:
      | RecursiveClassUnion
      | purify.Maybe<RecursiveClassUnion>;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.recursiveClassUnionMember2Property)) {
      this.recursiveClassUnionMember2Property =
        parameters?.recursiveClassUnionMember2Property;
    } else if (
      typeof parameters?.recursiveClassUnionMember2Property === "object"
    ) {
      this.recursiveClassUnionMember2Property = purify.Maybe.of(
        parameters?.recursiveClassUnionMember2Property,
      );
    } else if (
      typeof parameters?.recursiveClassUnionMember2Property === "undefined"
    ) {
      this.recursiveClassUnionMember2Property = purify.Maybe.empty();
    } else {
      this.recursiveClassUnionMember2Property =
        parameters?.recursiveClassUnionMember2Property satisfies never;
    }
  }

  get $identifier(): RecursiveClassUnionMember2.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: RecursiveClassUnionMember2): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, RecursiveClassUnion.$equals))(
          this.recursiveClassUnionMember2Property,
          other.recursiveClassUnionMember2Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "recursiveClassUnionMember2Property",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.recursiveClassUnionMember2Property.ifJust((value0) => {
      value0.$hash(_hasher);
    });
    return _hasher;
  }

  $toJson(): RecursiveClassUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        recursiveClassUnionMember2Property:
          this.recursiveClassUnionMember2Property
            .map((item) => item.$toJson())
            .extract(),
      } satisfies RecursiveClassUnionMember2.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      RecursiveClassUnionMember2.$properties.recursiveClassUnionMember2Property[
        "identifier"
      ],
      ...this.recursiveClassUnionMember2Property
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace RecursiveClassUnionMember2 {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "RecursiveClassUnionMember2";
    readonly recursiveClassUnionMember2Property?:
      | RecursiveClassUnionMember1.$Json
      | RecursiveClassUnionMember2.$Json;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      recursiveClassUnionMember2Property: purify.Maybe<RecursiveClassUnion>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const recursiveClassUnionMember2Property = purify.Maybe.fromNullable(
      $jsonObject["recursiveClassUnionMember2Property"],
    ).map((item) => RecursiveClassUnion.$fromJson(item).unsafeCoerce());
    return purify.Either.of({
      $identifier,
      recursiveClassUnionMember2Property,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, RecursiveClassUnionMember2> {
    return $propertiesFromJson(json).map(
      (properties) => new RecursiveClassUnionMember2(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "RecursiveClassUnionMember2" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/recursiveClassUnionMember2Property`,
          type: "Control",
        },
      ],
      label: "RecursiveClassUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("RecursiveClassUnionMember2"),
      recursiveClassUnionMember2Property: zod
        .lazy(
          (): zod.ZodType<RecursiveClassUnion.$Json> =>
            RecursiveClassUnion.$jsonZodSchema(),
        )
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, RecursiveClassUnionMember2> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return RecursiveClassUnionMember2.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new RecursiveClassUnionMember2(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      recursiveClassUnionMember2Property: purify.Maybe<RecursiveClassUnion>;
    }
  > {
    const $identifier: RecursiveClassUnionMember2.$Identifier =
      $resource.identifier;
    const _recursiveClassUnionMember2PropertyEither: purify.Either<
      Error,
      purify.Maybe<RecursiveClassUnion>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.recursiveClassUnionMember2Property["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            RecursiveClassUnion.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: false,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<RecursiveClassUnion>
            >({
              object: purify.Maybe.empty(),
              predicate:
                RecursiveClassUnionMember2.$properties
                  .recursiveClassUnionMember2Property["identifier"],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_recursiveClassUnionMember2PropertyEither.isLeft()) {
      return _recursiveClassUnionMember2PropertyEither;
    }

    const recursiveClassUnionMember2Property =
      _recursiveClassUnionMember2PropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      recursiveClassUnionMember2Property,
    });
  }

  export const $properties = {
    recursiveClassUnionMember2Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/recursiveClassUnionMember2Property",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        RecursiveClassUnionMember2.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        RecursiveClassUnionMember2.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      RecursiveClassUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(_parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [];
  }
}
export class RecursiveClassUnionMember1 {
  private _$identifier?: RecursiveClassUnionMember1.$Identifier;
  readonly $type = "RecursiveClassUnionMember1";
  readonly recursiveClassUnionMember1Property: purify.Maybe<RecursiveClassUnion>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly recursiveClassUnionMember1Property?:
      | RecursiveClassUnion
      | purify.Maybe<RecursiveClassUnion>;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.recursiveClassUnionMember1Property)) {
      this.recursiveClassUnionMember1Property =
        parameters?.recursiveClassUnionMember1Property;
    } else if (
      typeof parameters?.recursiveClassUnionMember1Property === "object"
    ) {
      this.recursiveClassUnionMember1Property = purify.Maybe.of(
        parameters?.recursiveClassUnionMember1Property,
      );
    } else if (
      typeof parameters?.recursiveClassUnionMember1Property === "undefined"
    ) {
      this.recursiveClassUnionMember1Property = purify.Maybe.empty();
    } else {
      this.recursiveClassUnionMember1Property =
        parameters?.recursiveClassUnionMember1Property satisfies never;
    }
  }

  get $identifier(): RecursiveClassUnionMember1.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: RecursiveClassUnionMember1): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, RecursiveClassUnion.$equals))(
          this.recursiveClassUnionMember1Property,
          other.recursiveClassUnionMember1Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "recursiveClassUnionMember1Property",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.recursiveClassUnionMember1Property.ifJust((value0) => {
      value0.$hash(_hasher);
    });
    return _hasher;
  }

  $toJson(): RecursiveClassUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        recursiveClassUnionMember1Property:
          this.recursiveClassUnionMember1Property
            .map((item) => item.$toJson())
            .extract(),
      } satisfies RecursiveClassUnionMember1.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      RecursiveClassUnionMember1.$properties.recursiveClassUnionMember1Property[
        "identifier"
      ],
      ...this.recursiveClassUnionMember1Property
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace RecursiveClassUnionMember1 {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "RecursiveClassUnionMember1";
    readonly recursiveClassUnionMember1Property?:
      | RecursiveClassUnionMember1.$Json
      | RecursiveClassUnionMember2.$Json;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      recursiveClassUnionMember1Property: purify.Maybe<RecursiveClassUnion>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const recursiveClassUnionMember1Property = purify.Maybe.fromNullable(
      $jsonObject["recursiveClassUnionMember1Property"],
    ).map((item) => RecursiveClassUnion.$fromJson(item).unsafeCoerce());
    return purify.Either.of({
      $identifier,
      recursiveClassUnionMember1Property,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, RecursiveClassUnionMember1> {
    return $propertiesFromJson(json).map(
      (properties) => new RecursiveClassUnionMember1(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "RecursiveClassUnionMember1" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/recursiveClassUnionMember1Property`,
          type: "Control",
        },
      ],
      label: "RecursiveClassUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("RecursiveClassUnionMember1"),
      recursiveClassUnionMember1Property: zod
        .lazy(
          (): zod.ZodType<RecursiveClassUnion.$Json> =>
            RecursiveClassUnion.$jsonZodSchema(),
        )
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, RecursiveClassUnionMember1> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return RecursiveClassUnionMember1.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new RecursiveClassUnionMember1(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      recursiveClassUnionMember1Property: purify.Maybe<RecursiveClassUnion>;
    }
  > {
    const $identifier: RecursiveClassUnionMember1.$Identifier =
      $resource.identifier;
    const _recursiveClassUnionMember1PropertyEither: purify.Either<
      Error,
      purify.Maybe<RecursiveClassUnion>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.recursiveClassUnionMember1Property["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            RecursiveClassUnion.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: false,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<RecursiveClassUnion>
            >({
              object: purify.Maybe.empty(),
              predicate:
                RecursiveClassUnionMember1.$properties
                  .recursiveClassUnionMember1Property["identifier"],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_recursiveClassUnionMember1PropertyEither.isLeft()) {
      return _recursiveClassUnionMember1PropertyEither;
    }

    const recursiveClassUnionMember1Property =
      _recursiveClassUnionMember1PropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      recursiveClassUnionMember1Property,
    });
  }

  export const $properties = {
    recursiveClassUnionMember1Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/recursiveClassUnionMember1Property",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        RecursiveClassUnionMember1.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        RecursiveClassUnionMember1.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      RecursiveClassUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(_parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [];
  }
}
/**
 * Shape with properties that have visibility modifiers (private, protected, public)
 */
export class PropertyVisibilitiesClass {
  private _$identifier?: PropertyVisibilitiesClass.$Identifier;
  readonly $type = "PropertyVisibilitiesClass";
  private readonly privateProperty: string;
  protected readonly protectedProperty: string;
  readonly publicProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly privateProperty: string;
    readonly protectedProperty: string;
    readonly publicProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.privateProperty = parameters.privateProperty;
    this.protectedProperty = parameters.protectedProperty;
    this.publicProperty = parameters.publicProperty;
  }

  get $identifier(): PropertyVisibilitiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: PropertyVisibilitiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.privateProperty, other.privateProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "privateProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.protectedProperty, other.protectedProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "protectedProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.publicProperty, other.publicProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "publicProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.privateProperty);
    _hasher.update(this.protectedProperty);
    _hasher.update(this.publicProperty);
    return _hasher;
  }

  $toJson(): PropertyVisibilitiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        privateProperty: this.privateProperty,
        protectedProperty: this.protectedProperty,
        publicProperty: this.publicProperty,
      } satisfies PropertyVisibilitiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      PropertyVisibilitiesClass.$properties.privateProperty["identifier"],
      ...[this.privateProperty],
    );
    resource.add(
      PropertyVisibilitiesClass.$properties.protectedProperty["identifier"],
      ...[this.protectedProperty],
    );
    resource.add(
      PropertyVisibilitiesClass.$properties.publicProperty["identifier"],
      ...[this.publicProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PropertyVisibilitiesClass {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PropertyVisibilitiesClass";
    readonly privateProperty: string;
    readonly protectedProperty: string;
    readonly publicProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      privateProperty: string;
      protectedProperty: string;
      publicProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const privateProperty = $jsonObject["privateProperty"];
    const protectedProperty = $jsonObject["protectedProperty"];
    const publicProperty = $jsonObject["publicProperty"];
    return purify.Either.of({
      $identifier,
      privateProperty,
      protectedProperty,
      publicProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PropertyVisibilitiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new PropertyVisibilitiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PropertyVisibilitiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/privateProperty`, type: "Control" },
        {
          scope: `${scopePrefix}/properties/protectedProperty`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/publicProperty`, type: "Control" },
      ],
      label: "PropertyVisibilitiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PropertyVisibilitiesClass"),
      privateProperty: zod.string(),
      protectedProperty: zod.string(),
      publicProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PropertyVisibilitiesClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PropertyVisibilitiesClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new PropertyVisibilitiesClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      privateProperty: string;
      protectedProperty: string;
      publicProperty: string;
    }
  > {
    const $identifier: PropertyVisibilitiesClass.$Identifier =
      $resource.identifier;
    const _privatePropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.privateProperty["identifier"], {
          unique: true,
        }),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    PropertyVisibilitiesClass.$properties.privateProperty[
                      "identifier"
                    ],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_privatePropertyEither.isLeft()) {
      return _privatePropertyEither;
    }

    const privateProperty = _privatePropertyEither.unsafeCoerce();
    const _protectedPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.protectedProperty["identifier"], {
          unique: true,
        }),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    PropertyVisibilitiesClass.$properties.protectedProperty[
                      "identifier"
                    ],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_protectedPropertyEither.isLeft()) {
      return _protectedPropertyEither;
    }

    const protectedProperty = _protectedPropertyEither.unsafeCoerce();
    const _publicPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.publicProperty["identifier"], {
          unique: true,
        }),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    PropertyVisibilitiesClass.$properties.publicProperty[
                      "identifier"
                    ],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_publicPropertyEither.isLeft()) {
      return _publicPropertyEither;
    }

    const publicProperty = _publicPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      privateProperty,
      protectedProperty,
      publicProperty,
    });
  }

  export const $properties = {
    privateProperty: {
      identifier: dataFactory.namedNode("http://example.com/privateProperty"),
    },
    protectedProperty: {
      identifier: dataFactory.namedNode("http://example.com/protectedProperty"),
    },
    publicProperty: {
      identifier: dataFactory.namedNode("http://example.com/publicProperty"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PropertyVisibilitiesClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PropertyVisibilitiesClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PropertyVisibilitiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("propertyVisibilitiesClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "propertyVisibilitiesClass");
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}PrivateProperty`),
      predicate:
        PropertyVisibilitiesClass.$properties.privateProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}ProtectedProperty`),
      predicate:
        PropertyVisibilitiesClass.$properties.protectedProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}PublicProperty`),
      predicate:
        PropertyVisibilitiesClass.$properties.publicProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("propertyVisibilitiesClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "propertyVisibilitiesClass");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}PrivateProperty`),
            predicate:
              PropertyVisibilitiesClass.$properties.privateProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(`${variablePrefix}PrivateProperty`),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}ProtectedProperty`),
            predicate:
              PropertyVisibilitiesClass.$properties.protectedProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(`${variablePrefix}ProtectedProperty`),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}PublicProperty`),
            predicate:
              PropertyVisibilitiesClass.$properties.publicProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(`${variablePrefix}PublicProperty`),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Shape that has properties with different cardinalities
 */
export class PropertyCardinalitiesClass {
  private _$identifier?: PropertyCardinalitiesClass.$Identifier;
  readonly $type = "PropertyCardinalitiesClass";
  /**
   * Set: minCount implicitly=0, no maxCount
   */
  readonly emptyStringSetProperty: readonly string[];
  /**
   * Set: minCount=1, no maxCount
   */
  readonly nonEmptyStringSetProperty: purify.NonEmptyList<string>;
  /**
   * Option: maxCount=1, minCount=0
   */
  readonly optionalStringProperty: purify.Maybe<string>;
  /**
   * Required: maxCount=minCount=1
   */
  readonly requiredStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly emptyStringSetProperty?: readonly string[];
    readonly nonEmptyStringSetProperty: purify.NonEmptyList<string>;
    readonly optionalStringProperty?: purify.Maybe<string> | string;
    readonly requiredStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    if (typeof parameters.emptyStringSetProperty === "undefined") {
      this.emptyStringSetProperty = [];
    } else if (typeof parameters.emptyStringSetProperty === "object") {
      this.emptyStringSetProperty = parameters.emptyStringSetProperty;
    } else {
      this.emptyStringSetProperty =
        parameters.emptyStringSetProperty satisfies never;
    }

    this.nonEmptyStringSetProperty = parameters.nonEmptyStringSetProperty;
    if (purify.Maybe.isMaybe(parameters.optionalStringProperty)) {
      this.optionalStringProperty = parameters.optionalStringProperty;
    } else if (typeof parameters.optionalStringProperty === "string") {
      this.optionalStringProperty = purify.Maybe.of(
        parameters.optionalStringProperty,
      );
    } else if (typeof parameters.optionalStringProperty === "undefined") {
      this.optionalStringProperty = purify.Maybe.empty();
    } else {
      this.optionalStringProperty =
        parameters.optionalStringProperty satisfies never;
    }

    this.requiredStringProperty = parameters.requiredStringProperty;
  }

  get $identifier(): PropertyCardinalitiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: PropertyCardinalitiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $strictEquals))(
          this.emptyStringSetProperty,
          other.emptyStringSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "emptyStringSetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $strictEquals))(
          this.nonEmptyStringSetProperty,
          other.nonEmptyStringSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "nonEmptyStringSetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.optionalStringProperty,
          other.optionalStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.requiredStringProperty,
          other.requiredStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "requiredStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    for (const item0 of this.emptyStringSetProperty) {
      _hasher.update(item0);
    }

    for (const item0 of this.nonEmptyStringSetProperty) {
      _hasher.update(item0);
    }

    this.optionalStringProperty.ifJust((value0) => {
      _hasher.update(value0);
    });
    _hasher.update(this.requiredStringProperty);
    return _hasher;
  }

  $toJson(): PropertyCardinalitiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        emptyStringSetProperty: this.emptyStringSetProperty.map((item) => item),
        nonEmptyStringSetProperty: this.nonEmptyStringSetProperty.map(
          (item) => item,
        ),
        optionalStringProperty: this.optionalStringProperty
          .map((item) => item)
          .extract(),
        requiredStringProperty: this.requiredStringProperty,
      } satisfies PropertyCardinalitiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      PropertyCardinalitiesClass.$properties.emptyStringSetProperty[
        "identifier"
      ],
      ...this.emptyStringSetProperty.flatMap((item) => [item]),
    );
    resource.add(
      PropertyCardinalitiesClass.$properties.nonEmptyStringSetProperty[
        "identifier"
      ],
      ...this.nonEmptyStringSetProperty.flatMap((item) => [item]),
    );
    resource.add(
      PropertyCardinalitiesClass.$properties.optionalStringProperty[
        "identifier"
      ],
      ...this.optionalStringProperty.toList(),
    );
    resource.add(
      PropertyCardinalitiesClass.$properties.requiredStringProperty[
        "identifier"
      ],
      ...[this.requiredStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PropertyCardinalitiesClass {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PropertyCardinalitiesClass";
    readonly emptyStringSetProperty?: readonly string[];
    readonly nonEmptyStringSetProperty: readonly string[];
    readonly optionalStringProperty?: string;
    readonly requiredStringProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      emptyStringSetProperty: readonly string[];
      nonEmptyStringSetProperty: purify.NonEmptyList<string>;
      optionalStringProperty: purify.Maybe<string>;
      requiredStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const emptyStringSetProperty = $jsonObject["emptyStringSetProperty"];
    const nonEmptyStringSetProperty = purify.NonEmptyList.fromArray(
      $jsonObject["nonEmptyStringSetProperty"],
    ).unsafeCoerce();
    const optionalStringProperty = purify.Maybe.fromNullable(
      $jsonObject["optionalStringProperty"],
    );
    const requiredStringProperty = $jsonObject["requiredStringProperty"];
    return purify.Either.of({
      $identifier,
      emptyStringSetProperty,
      nonEmptyStringSetProperty,
      optionalStringProperty,
      requiredStringProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PropertyCardinalitiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new PropertyCardinalitiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PropertyCardinalitiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/emptyStringSetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/nonEmptyStringSetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/optionalStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/requiredStringProperty`,
          type: "Control",
        },
      ],
      label: "PropertyCardinalitiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PropertyCardinalitiesClass"),
      emptyStringSetProperty: zod
        .string()
        .array()
        .default(() => [])
        .describe("Set: minCount implicitly=0, no maxCount"),
      nonEmptyStringSetProperty: zod
        .string()
        .array()
        .nonempty()
        .min(1)
        .describe("Set: minCount=1, no maxCount"),
      optionalStringProperty: zod
        .string()
        .optional()
        .describe("Option: maxCount=1, minCount=0"),
      requiredStringProperty: zod
        .string()
        .describe("Required: maxCount=minCount=1"),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PropertyCardinalitiesClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PropertyCardinalitiesClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new PropertyCardinalitiesClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      emptyStringSetProperty: readonly string[];
      nonEmptyStringSetProperty: purify.NonEmptyList<string>;
      optionalStringProperty: purify.Maybe<string>;
      requiredStringProperty: string;
    }
  > {
    const $identifier: PropertyCardinalitiesClass.$Identifier =
      $resource.identifier;
    const _emptyStringSetPropertyEither: purify.Either<
      Error,
      readonly string[]
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.emptyStringSetProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => {
        if (!$preferredLanguages || $preferredLanguages.length === 0) {
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(values);
        }

        const literalValuesEither = values.chainMap((value) =>
          value.toLiteral(),
        );
        if (literalValuesEither.isLeft()) {
          return literalValuesEither;
        }
        const literalValues = literalValuesEither.unsafeCoerce();

        // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
        // Within a preferredLanguage the literals may be in any order.
        let filteredLiteralValues:
          | rdfjsResource.Resource.Values<rdfjs.Literal>
          | undefined;
        for (const preferredLanguage of $preferredLanguages) {
          if (!filteredLiteralValues) {
            filteredLiteralValues = literalValues.filter(
              (value) => value.language === preferredLanguage,
            );
          } else {
            filteredLiteralValues = filteredLiteralValues.concat(
              ...literalValues
                .filter((value) => value.language === preferredLanguage)
                .toArray(),
            );
          }
        }

        return purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
        >(
          filteredLiteralValues!.map(
            (literalValue) =>
              new rdfjsResource.Resource.Value({
                object: literalValue,
                predicate:
                  PropertyCardinalitiesClass.$properties.emptyStringSetProperty[
                    "identifier"
                  ],
                subject: $resource,
              }),
          ),
        );
      })
      .chain((values) => values.chainMap((value) => value.toString()))
      .map((values) => values.toArray())
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          object: valuesArray,
          predicate:
            PropertyCardinalitiesClass.$properties.emptyStringSetProperty[
              "identifier"
            ],
          subject: $resource,
        }),
      )
      .chain((values) => values.head());
    if (_emptyStringSetPropertyEither.isLeft()) {
      return _emptyStringSetPropertyEither;
    }

    const emptyStringSetProperty = _emptyStringSetPropertyEither.unsafeCoerce();
    const _nonEmptyStringSetPropertyEither: purify.Either<
      Error,
      purify.NonEmptyList<string>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.nonEmptyStringSetProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => {
        if (!$preferredLanguages || $preferredLanguages.length === 0) {
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(values);
        }

        const literalValuesEither = values.chainMap((value) =>
          value.toLiteral(),
        );
        if (literalValuesEither.isLeft()) {
          return literalValuesEither;
        }
        const literalValues = literalValuesEither.unsafeCoerce();

        // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
        // Within a preferredLanguage the literals may be in any order.
        let filteredLiteralValues:
          | rdfjsResource.Resource.Values<rdfjs.Literal>
          | undefined;
        for (const preferredLanguage of $preferredLanguages) {
          if (!filteredLiteralValues) {
            filteredLiteralValues = literalValues.filter(
              (value) => value.language === preferredLanguage,
            );
          } else {
            filteredLiteralValues = filteredLiteralValues.concat(
              ...literalValues
                .filter((value) => value.language === preferredLanguage)
                .toArray(),
            );
          }
        }

        return purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
        >(
          filteredLiteralValues!.map(
            (literalValue) =>
              new rdfjsResource.Resource.Value({
                object: literalValue,
                predicate:
                  PropertyCardinalitiesClass.$properties
                    .nonEmptyStringSetProperty["identifier"],
                subject: $resource,
              }),
          ),
        );
      })
      .chain((values) => values.chainMap((value) => value.toString()))
      .chain((values) =>
        purify.NonEmptyList.fromArray(values.toArray()).toEither(
          new Error(
            `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} is an empty set`,
          ),
        ),
      )
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          object: valuesArray,
          predicate:
            PropertyCardinalitiesClass.$properties.nonEmptyStringSetProperty[
              "identifier"
            ],
          subject: $resource,
        }),
      )
      .chain((values) => values.head());
    if (_nonEmptyStringSetPropertyEither.isLeft()) {
      return _nonEmptyStringSetPropertyEither;
    }

    const nonEmptyStringSetProperty =
      _nonEmptyStringSetPropertyEither.unsafeCoerce();
    const _optionalStringPropertyEither: purify.Either<
      Error,
      purify.Maybe<string>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.optionalStringProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => {
        if (!$preferredLanguages || $preferredLanguages.length === 0) {
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(values);
        }

        const literalValuesEither = values.chainMap((value) =>
          value.toLiteral(),
        );
        if (literalValuesEither.isLeft()) {
          return literalValuesEither;
        }
        const literalValues = literalValuesEither.unsafeCoerce();

        // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
        // Within a preferredLanguage the literals may be in any order.
        let filteredLiteralValues:
          | rdfjsResource.Resource.Values<rdfjs.Literal>
          | undefined;
        for (const preferredLanguage of $preferredLanguages) {
          if (!filteredLiteralValues) {
            filteredLiteralValues = literalValues.filter(
              (value) => value.language === preferredLanguage,
            );
          } else {
            filteredLiteralValues = filteredLiteralValues.concat(
              ...literalValues
                .filter((value) => value.language === preferredLanguage)
                .toArray(),
            );
          }
        }

        return purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
        >(
          filteredLiteralValues!.map(
            (literalValue) =>
              new rdfjsResource.Resource.Value({
                object: literalValue,
                predicate:
                  PropertyCardinalitiesClass.$properties.optionalStringProperty[
                    "identifier"
                  ],
                subject: $resource,
              }),
          ),
        );
      })
      .chain((values) => values.chainMap((value) => value.toString()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<string>>({
              object: purify.Maybe.empty(),
              predicate:
                PropertyCardinalitiesClass.$properties.optionalStringProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_optionalStringPropertyEither.isLeft()) {
      return _optionalStringPropertyEither;
    }

    const optionalStringProperty = _optionalStringPropertyEither.unsafeCoerce();
    const _requiredStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.requiredStringProperty["identifier"], {
          unique: true,
        }),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    PropertyCardinalitiesClass.$properties
                      .requiredStringProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_requiredStringPropertyEither.isLeft()) {
      return _requiredStringPropertyEither;
    }

    const requiredStringProperty = _requiredStringPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      emptyStringSetProperty,
      nonEmptyStringSetProperty,
      optionalStringProperty,
      requiredStringProperty,
    });
  }

  export const $properties = {
    emptyStringSetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/emptyStringSetProperty",
      ),
    },
    nonEmptyStringSetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/nonEmptyStringSetProperty",
      ),
    },
    optionalStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalStringProperty",
      ),
    },
    requiredStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/requiredStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PropertyCardinalitiesClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PropertyCardinalitiesClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PropertyCardinalitiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("propertyCardinalitiesClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "propertyCardinalitiesClass");
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}EmptyStringSetProperty`),
      predicate:
        PropertyCardinalitiesClass.$properties.emptyStringSetProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}NonEmptyStringSetProperty`,
      ),
      predicate:
        PropertyCardinalitiesClass.$properties.nonEmptyStringSetProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}OptionalStringProperty`),
      predicate:
        PropertyCardinalitiesClass.$properties.optionalStringProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}RequiredStringProperty`),
      predicate:
        PropertyCardinalitiesClass.$properties.requiredStringProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("propertyCardinalitiesClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "propertyCardinalitiesClass");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}EmptyStringSetProperty`,
                ),
                predicate:
                  PropertyCardinalitiesClass.$properties.emptyStringSetProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
          ...[parameters?.preferredLanguages ?? []]
            .filter((languages) => languages.length > 0)
            .map((languages) =>
              languages.map((language) => ({
                type: "operation" as const,
                operator: "=",
                args: [
                  {
                    type: "operation" as const,
                    operator: "lang",
                    args: [
                      dataFactory.variable!(
                        `${variablePrefix}EmptyStringSetProperty`,
                      ),
                    ],
                  },
                  dataFactory.literal(language),
                ],
              })),
            )
            .map((langEqualsExpressions) => ({
              type: "filter" as const,
              expression: langEqualsExpressions.reduce(
                (reducedExpression, langEqualsExpression) => {
                  if (reducedExpression === null) {
                    return langEqualsExpression;
                  }
                  return {
                    type: "operation" as const,
                    operator: "||",
                    args: [reducedExpression, langEqualsExpression],
                  };
                },
                null as sparqljs.Expression | null,
              ) as sparqljs.Expression,
            })),
        ],
        type: "optional",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}NonEmptyStringSetProperty`,
            ),
            predicate:
              PropertyCardinalitiesClass.$properties.nonEmptyStringSetProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}NonEmptyStringSetProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}OptionalStringProperty`,
                ),
                predicate:
                  PropertyCardinalitiesClass.$properties.optionalStringProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
          ...[parameters?.preferredLanguages ?? []]
            .filter((languages) => languages.length > 0)
            .map((languages) =>
              languages.map((language) => ({
                type: "operation" as const,
                operator: "=",
                args: [
                  {
                    type: "operation" as const,
                    operator: "lang",
                    args: [
                      dataFactory.variable!(
                        `${variablePrefix}OptionalStringProperty`,
                      ),
                    ],
                  },
                  dataFactory.literal(language),
                ],
              })),
            )
            .map((langEqualsExpressions) => ({
              type: "filter" as const,
              expression: langEqualsExpressions.reduce(
                (reducedExpression, langEqualsExpression) => {
                  if (reducedExpression === null) {
                    return langEqualsExpression;
                  }
                  return {
                    type: "operation" as const,
                    operator: "||",
                    args: [reducedExpression, langEqualsExpression],
                  };
                },
                null as sparqljs.Expression | null,
              ) as sparqljs.Expression,
            })),
        ],
        type: "optional",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}RequiredStringProperty`,
            ),
            predicate:
              PropertyCardinalitiesClass.$properties.requiredStringProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}RequiredStringProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export interface PartialInterfaceUnionMember2 {
  readonly $identifier: PartialInterfaceUnionMember2.$Identifier;
  readonly $type: "PartialInterfaceUnionMember2";
  readonly lazilyResolvedStringProperty: string;
}

export namespace PartialInterfaceUnionMember2 {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): PartialInterfaceUnionMember2 {
    let $identifier: PartialInterfaceUnionMember2.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "PartialInterfaceUnionMember2" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: PartialInterfaceUnionMember2,
    right: PartialInterfaceUnionMember2,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/PartialInterfaceUnionMember2",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialInterfaceUnionMember2";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "PartialInterfaceUnionMember2";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "PartialInterfaceUnionMember2" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialInterfaceUnionMember2> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialInterfaceUnionMember2" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialInterfaceUnionMember2",
      type: "Group",
    };
  }

  export function $toJson(
    _partialInterfaceUnionMember2: PartialInterfaceUnionMember2,
  ): PartialInterfaceUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _partialInterfaceUnionMember2.$identifier.termType === "BlankNode"
            ? `_:${_partialInterfaceUnionMember2.$identifier.value}`
            : _partialInterfaceUnionMember2.$identifier.value,
        $type: _partialInterfaceUnionMember2.$type,
        lazilyResolvedStringProperty:
          _partialInterfaceUnionMember2.lazilyResolvedStringProperty,
      } satisfies PartialInterfaceUnionMember2.$Json),
    );
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PartialInterfaceUnionMember2"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _partialInterfaceUnionMember2: PartialInterfaceUnionMember2,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_partialInterfaceUnionMember2.$identifier.value);
    _hasher.update(_partialInterfaceUnionMember2.$type);
    PartialInterfaceUnionMember2.$hashShaclProperties(
      _partialInterfaceUnionMember2,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _partialInterfaceUnionMember2: PartialInterfaceUnionMember2,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_partialInterfaceUnionMember2.lazilyResolvedStringProperty);
    return _hasher;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialInterfaceUnionMember2> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PartialInterfaceUnionMember2.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "PartialInterfaceUnionMember2";
      lazilyResolvedStringProperty: string;
    }
  > {
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/PartialInterfaceUnionMember2":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $resource.isInstanceOf(PartialInterfaceUnionMember2.$fromRdfType)
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/PartialInterfaceUnionMember2)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: PartialInterfaceUnionMember2.$Identifier =
      $resource.identifier;
    const $type = "PartialInterfaceUnionMember2" as const;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    PartialInterfaceUnionMember2.$properties
                      .lazilyResolvedStringProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $toRdf(
    _partialInterfaceUnionMember2: PartialInterfaceUnionMember2,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _partialInterfaceUnionMember2.$identifier,
      { mutateGraph },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/PartialInterfaceUnionMember2",
        ),
      );
    }

    resource.add(
      PartialInterfaceUnionMember2.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[_partialInterfaceUnionMember2.lazilyResolvedStringProperty],
    );
    return resource;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialInterfaceUnionMember2.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PartialInterfaceUnionMember2.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialInterfaceUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("partialInterfaceUnionMember2");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "partialInterfaceUnionMember2");
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}LazilyResolvedStringProperty`,
      ),
      predicate:
        PartialInterfaceUnionMember2.$properties.lazilyResolvedStringProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("partialInterfaceUnionMember2");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "partialInterfaceUnionMember2");
    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({
          rdfType: PartialInterfaceUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}LazilyResolvedStringProperty`,
            ),
            predicate:
              PartialInterfaceUnionMember2.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}LazilyResolvedStringProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export interface PartialInterfaceUnionMember1 {
  readonly $identifier: PartialInterfaceUnionMember1.$Identifier;
  readonly $type: "PartialInterfaceUnionMember1";
  readonly lazilyResolvedStringProperty: string;
}

export namespace PartialInterfaceUnionMember1 {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): PartialInterfaceUnionMember1 {
    let $identifier: PartialInterfaceUnionMember1.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "PartialInterfaceUnionMember1" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: PartialInterfaceUnionMember1,
    right: PartialInterfaceUnionMember1,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/PartialInterfaceUnionMember1",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialInterfaceUnionMember1";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "PartialInterfaceUnionMember1";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "PartialInterfaceUnionMember1" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialInterfaceUnionMember1> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialInterfaceUnionMember1" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialInterfaceUnionMember1",
      type: "Group",
    };
  }

  export function $toJson(
    _partialInterfaceUnionMember1: PartialInterfaceUnionMember1,
  ): PartialInterfaceUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _partialInterfaceUnionMember1.$identifier.termType === "BlankNode"
            ? `_:${_partialInterfaceUnionMember1.$identifier.value}`
            : _partialInterfaceUnionMember1.$identifier.value,
        $type: _partialInterfaceUnionMember1.$type,
        lazilyResolvedStringProperty:
          _partialInterfaceUnionMember1.lazilyResolvedStringProperty,
      } satisfies PartialInterfaceUnionMember1.$Json),
    );
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PartialInterfaceUnionMember1"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _partialInterfaceUnionMember1: PartialInterfaceUnionMember1,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_partialInterfaceUnionMember1.$identifier.value);
    _hasher.update(_partialInterfaceUnionMember1.$type);
    PartialInterfaceUnionMember1.$hashShaclProperties(
      _partialInterfaceUnionMember1,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _partialInterfaceUnionMember1: PartialInterfaceUnionMember1,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_partialInterfaceUnionMember1.lazilyResolvedStringProperty);
    return _hasher;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialInterfaceUnionMember1> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PartialInterfaceUnionMember1.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "PartialInterfaceUnionMember1";
      lazilyResolvedStringProperty: string;
    }
  > {
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/PartialInterfaceUnionMember1":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $resource.isInstanceOf(PartialInterfaceUnionMember1.$fromRdfType)
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/PartialInterfaceUnionMember1)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: PartialInterfaceUnionMember1.$Identifier =
      $resource.identifier;
    const $type = "PartialInterfaceUnionMember1" as const;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    PartialInterfaceUnionMember1.$properties
                      .lazilyResolvedStringProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $toRdf(
    _partialInterfaceUnionMember1: PartialInterfaceUnionMember1,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _partialInterfaceUnionMember1.$identifier,
      { mutateGraph },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/PartialInterfaceUnionMember1",
        ),
      );
    }

    resource.add(
      PartialInterfaceUnionMember1.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[_partialInterfaceUnionMember1.lazilyResolvedStringProperty],
    );
    return resource;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialInterfaceUnionMember1.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PartialInterfaceUnionMember1.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialInterfaceUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("partialInterfaceUnionMember1");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "partialInterfaceUnionMember1");
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}LazilyResolvedStringProperty`,
      ),
      predicate:
        PartialInterfaceUnionMember1.$properties.lazilyResolvedStringProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("partialInterfaceUnionMember1");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "partialInterfaceUnionMember1");
    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({
          rdfType: PartialInterfaceUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}LazilyResolvedStringProperty`,
            ),
            predicate:
              PartialInterfaceUnionMember1.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}LazilyResolvedStringProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class PartialClassUnionMember2 {
  private _$identifier?: PartialClassUnionMember2.$Identifier;
  readonly $type = "PartialClassUnionMember2";
  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): PartialClassUnionMember2.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: PartialClassUnionMember2): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): PartialClassUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies PartialClassUnionMember2.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/PartialClassUnionMember2",
        ),
      );
    }

    resource.add(
      PartialClassUnionMember2.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[this.lazilyResolvedStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PartialClassUnionMember2 {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/PartialClassUnionMember2",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialClassUnionMember2";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialClassUnionMember2> {
    return $propertiesFromJson(json).map(
      (properties) => new PartialClassUnionMember2(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialClassUnionMember2" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialClassUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PartialClassUnionMember2"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialClassUnionMember2> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PartialClassUnionMember2.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new PartialClassUnionMember2(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/PartialClassUnionMember2":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if ($resource.isInstanceOf(PartialClassUnionMember2.$fromRdfType)) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/PartialClassUnionMember2)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: PartialClassUnionMember2.$Identifier =
      $resource.identifier;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    PartialClassUnionMember2.$properties
                      .lazilyResolvedStringProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialClassUnionMember2.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PartialClassUnionMember2.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialClassUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClassUnionMember2");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "partialClassUnionMember2");
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}LazilyResolvedStringProperty`,
      ),
      predicate:
        PartialClassUnionMember2.$properties.lazilyResolvedStringProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClassUnionMember2");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "partialClassUnionMember2");
    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({
          rdfType: PartialClassUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}LazilyResolvedStringProperty`,
            ),
            predicate:
              PartialClassUnionMember2.$properties.lazilyResolvedStringProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}LazilyResolvedStringProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class PartialClassUnionMember1 {
  private _$identifier?: PartialClassUnionMember1.$Identifier;
  readonly $type = "PartialClassUnionMember1";
  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): PartialClassUnionMember1.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: PartialClassUnionMember1): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): PartialClassUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies PartialClassUnionMember1.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/PartialClassUnionMember1",
        ),
      );
    }

    resource.add(
      PartialClassUnionMember1.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[this.lazilyResolvedStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PartialClassUnionMember1 {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/PartialClassUnionMember1",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialClassUnionMember1";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialClassUnionMember1> {
    return $propertiesFromJson(json).map(
      (properties) => new PartialClassUnionMember1(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialClassUnionMember1" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialClassUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PartialClassUnionMember1"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialClassUnionMember1> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PartialClassUnionMember1.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new PartialClassUnionMember1(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/PartialClassUnionMember1":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if ($resource.isInstanceOf(PartialClassUnionMember1.$fromRdfType)) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/PartialClassUnionMember1)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: PartialClassUnionMember1.$Identifier =
      $resource.identifier;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    PartialClassUnionMember1.$properties
                      .lazilyResolvedStringProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialClassUnionMember1.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PartialClassUnionMember1.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialClassUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClassUnionMember1");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "partialClassUnionMember1");
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}LazilyResolvedStringProperty`,
      ),
      predicate:
        PartialClassUnionMember1.$properties.lazilyResolvedStringProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClassUnionMember1");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "partialClassUnionMember1");
    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({
          rdfType: PartialClassUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}LazilyResolvedStringProperty`,
            ),
            predicate:
              PartialClassUnionMember1.$properties.lazilyResolvedStringProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}LazilyResolvedStringProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Shape whose sh:properties have sh:order's. The compiler should order them C, A, B based on sh:order instead of on the declaration or lexicographic orders.
 */
export class OrderedPropertiesClass {
  private _$identifier?: OrderedPropertiesClass.$Identifier;
  readonly $type = "OrderedPropertiesClass";
  readonly orderedPropertyC: string;
  readonly orderedPropertyB: string;
  readonly orderedPropertyA: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly orderedPropertyC: string;
    readonly orderedPropertyB: string;
    readonly orderedPropertyA: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.orderedPropertyC = parameters.orderedPropertyC;
    this.orderedPropertyB = parameters.orderedPropertyB;
    this.orderedPropertyA = parameters.orderedPropertyA;
  }

  get $identifier(): OrderedPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: OrderedPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.orderedPropertyC, other.orderedPropertyC).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "orderedPropertyC",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.orderedPropertyB, other.orderedPropertyB).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "orderedPropertyB",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.orderedPropertyA, other.orderedPropertyA).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "orderedPropertyA",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.orderedPropertyC);
    _hasher.update(this.orderedPropertyB);
    _hasher.update(this.orderedPropertyA);
    return _hasher;
  }

  $toJson(): OrderedPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        orderedPropertyC: this.orderedPropertyC,
        orderedPropertyB: this.orderedPropertyB,
        orderedPropertyA: this.orderedPropertyA,
      } satisfies OrderedPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      OrderedPropertiesClass.$properties.orderedPropertyC["identifier"],
      ...[this.orderedPropertyC],
    );
    resource.add(
      OrderedPropertiesClass.$properties.orderedPropertyB["identifier"],
      ...[this.orderedPropertyB],
    );
    resource.add(
      OrderedPropertiesClass.$properties.orderedPropertyA["identifier"],
      ...[this.orderedPropertyA],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace OrderedPropertiesClass {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "OrderedPropertiesClass";
    readonly orderedPropertyC: string;
    readonly orderedPropertyB: string;
    readonly orderedPropertyA: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      orderedPropertyC: string;
      orderedPropertyB: string;
      orderedPropertyA: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const orderedPropertyC = $jsonObject["orderedPropertyC"];
    const orderedPropertyB = $jsonObject["orderedPropertyB"];
    const orderedPropertyA = $jsonObject["orderedPropertyA"];
    return purify.Either.of({
      $identifier,
      orderedPropertyC,
      orderedPropertyB,
      orderedPropertyA,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, OrderedPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new OrderedPropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "OrderedPropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/orderedPropertyC`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/orderedPropertyB`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/orderedPropertyA`,
          type: "Control",
        },
      ],
      label: "OrderedPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("OrderedPropertiesClass"),
      orderedPropertyC: zod.string(),
      orderedPropertyB: zod.string(),
      orderedPropertyA: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, OrderedPropertiesClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return OrderedPropertiesClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new OrderedPropertiesClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      orderedPropertyC: string;
      orderedPropertyB: string;
      orderedPropertyA: string;
    }
  > {
    const $identifier: OrderedPropertiesClass.$Identifier =
      $resource.identifier;
    const _orderedPropertyCEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.orderedPropertyC["identifier"], {
          unique: true,
        }),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    OrderedPropertiesClass.$properties.orderedPropertyC[
                      "identifier"
                    ],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_orderedPropertyCEither.isLeft()) {
      return _orderedPropertyCEither;
    }

    const orderedPropertyC = _orderedPropertyCEither.unsafeCoerce();
    const _orderedPropertyBEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.orderedPropertyB["identifier"], {
          unique: true,
        }),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    OrderedPropertiesClass.$properties.orderedPropertyB[
                      "identifier"
                    ],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_orderedPropertyBEither.isLeft()) {
      return _orderedPropertyBEither;
    }

    const orderedPropertyB = _orderedPropertyBEither.unsafeCoerce();
    const _orderedPropertyAEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.orderedPropertyA["identifier"], {
          unique: true,
        }),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    OrderedPropertiesClass.$properties.orderedPropertyA[
                      "identifier"
                    ],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_orderedPropertyAEither.isLeft()) {
      return _orderedPropertyAEither;
    }

    const orderedPropertyA = _orderedPropertyAEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      orderedPropertyC,
      orderedPropertyB,
      orderedPropertyA,
    });
  }

  export const $properties = {
    orderedPropertyC: {
      identifier: dataFactory.namedNode("http://example.com/orderedPropertyC"),
    },
    orderedPropertyB: {
      identifier: dataFactory.namedNode("http://example.com/orderedPropertyB"),
    },
    orderedPropertyA: {
      identifier: dataFactory.namedNode("http://example.com/orderedPropertyA"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        OrderedPropertiesClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        OrderedPropertiesClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      OrderedPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("orderedPropertiesClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "orderedPropertiesClass");
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}OrderedPropertyC`),
      predicate:
        OrderedPropertiesClass.$properties.orderedPropertyC["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}OrderedPropertyB`),
      predicate:
        OrderedPropertiesClass.$properties.orderedPropertyB["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}OrderedPropertyA`),
      predicate:
        OrderedPropertiesClass.$properties.orderedPropertyA["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("orderedPropertiesClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "orderedPropertiesClass");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}OrderedPropertyC`),
            predicate:
              OrderedPropertiesClass.$properties.orderedPropertyC["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(`${variablePrefix}OrderedPropertyC`),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}OrderedPropertyB`),
            predicate:
              OrderedPropertiesClass.$properties.orderedPropertyB["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(`${variablePrefix}OrderedPropertyB`),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}OrderedPropertyA`),
            predicate:
              OrderedPropertiesClass.$properties.orderedPropertyA["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(`${variablePrefix}OrderedPropertyA`),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Node shape that isn't an rdfs:Class.
 */
export class NonClass {
  private _$identifier?: NonClass.$Identifier;
  readonly $type = "NonClass";
  readonly nonClassProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly nonClassProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.nonClassProperty = parameters.nonClassProperty;
  }

  get $identifier(): NonClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: NonClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.nonClassProperty, other.nonClassProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "nonClassProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.nonClassProperty);
    return _hasher;
  }

  $toJson(): NonClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        nonClassProperty: this.nonClassProperty,
      } satisfies NonClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      NonClass.$properties.nonClassProperty["identifier"],
      ...[this.nonClassProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace NonClass {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "NonClass";
    readonly nonClassProperty: string;
  };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode; nonClassProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const nonClassProperty = $jsonObject["nonClassProperty"];
    return purify.Either.of({ $identifier, nonClassProperty });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, NonClass> {
    return $propertiesFromJson(json).map(
      (properties) => new NonClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "NonClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/nonClassProperty`,
          type: "Control",
        },
      ],
      label: "NonClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("NonClass"),
      nonClassProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, NonClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return NonClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new NonClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode; nonClassProperty: string }
  > {
    const $identifier: NonClass.$Identifier = $resource.identifier;
    const _nonClassPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.nonClassProperty["identifier"], {
          unique: true,
        }),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    NonClass.$properties.nonClassProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_nonClassPropertyEither.isLeft()) {
      return _nonClassPropertyEither;
    }

    const nonClassProperty = _nonClassPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, nonClassProperty });
  }

  export const $properties = {
    nonClassProperty: {
      identifier: dataFactory.namedNode("http://example.com/nonClassProperty"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        NonClass.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        NonClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      NonClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("nonClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "nonClass");
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}NonClassProperty`),
      predicate: NonClass.$properties.nonClassProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("nonClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "nonClass");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}NonClassProperty`),
            predicate: NonClass.$properties.nonClassProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(`${variablePrefix}NonClassProperty`),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Node shape whose identifier can be a blank or a named node; subclassed by NarrowedIdentifierClass
 */
export class WideIdentifierClass {
  protected _$identifier?: WideIdentifierClassStatic.$Identifier;
  readonly $type: "WideIdentifierClass" | "NarrowedIdentifierClass" =
    "WideIdentifierClass";

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }
  }

  get $identifier(): WideIdentifierClassStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: WideIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    return _hasher;
  }

  $toJson(): WideIdentifierClassStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
      } satisfies WideIdentifierClassStatic.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/WideIdentifierClass",
        ),
      );
    }

    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace WideIdentifierClassStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/WideIdentifierClass",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "WideIdentifierClass" | "NarrowedIdentifierClass";
  };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    return purify.Either.of({ $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, WideIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new WideIdentifierClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "WideIdentifierClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "WideIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.enum(["WideIdentifierClass", "NarrowedIdentifierClass"]),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, WideIdentifierClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return WideIdentifierClassStatic.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new WideIdentifierClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<Error, { $identifier: rdfjs.BlankNode | rdfjs.NamedNode }> {
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/WideIdentifierClass":
            case "http://example.com/NarrowedIdentifierClass":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if ($resource.isInstanceOf(WideIdentifierClassStatic.$fromRdfType)) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/WideIdentifierClass)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: WideIdentifierClassStatic.$Identifier =
      $resource.identifier;
    return purify.Either.of({ $identifier });
  }

  export const $properties = {};

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        WideIdentifierClassStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        WideIdentifierClassStatic.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      WideIdentifierClassStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("wideIdentifierClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "wideIdentifierClass");
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("wideIdentifierClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "wideIdentifierClass");
    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        {
          type: "values" as const,
          values: [
            WideIdentifierClassStatic.$fromRdfType,
            NarrowedIdentifierClass.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[`?${variablePrefix}FromRdfType`] =
              identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(`${variablePrefix}FromRdfType`),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class NarrowedIdentifierClass extends WideIdentifierClass {
  override readonly $type = "NarrowedIdentifierClass";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof WideIdentifierClass>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): NarrowedIdentifierClass.$Identifier {
    return super.$identifier as NarrowedIdentifierClass.$Identifier;
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/NarrowedIdentifierClass",
        ),
      );
    }

    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace NarrowedIdentifierClass {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/NarrowedIdentifierClass",
  );
  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = WideIdentifierClassStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof WideIdentifierClassStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      WideIdentifierClassStatic.$propertiesFromJson($jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, NarrowedIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new NarrowedIdentifierClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [WideIdentifierClassStatic.$jsonUiSchema({ scopePrefix })],
      label: "NarrowedIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return WideIdentifierClassStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("NarrowedIdentifierClass"),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, NarrowedIdentifierClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return NarrowedIdentifierClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new NarrowedIdentifierClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof WideIdentifierClassStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = WideIdentifierClassStatic.$propertiesFromRdf({
      ...$context,
      ignoreRdfType: true,
      objectSet: $objectSet,
      preferredLanguages: $preferredLanguages,
      resource: $resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/NarrowedIdentifierClass":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if ($resource.isInstanceOf(NarrowedIdentifierClass.$fromRdfType)) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/NarrowedIdentifierClass)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    if ($resource.identifier.termType !== "NamedNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedValueError({
          actualValue: $resource.identifier,
          expectedValueType: "(rdfjs.NamedNode)",
          focusResource: $resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: NarrowedIdentifierClass.$Identifier =
      $resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export const $properties = { ...WideIdentifierClassStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        NarrowedIdentifierClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        NarrowedIdentifierClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      NarrowedIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("narrowedIdentifierClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "narrowedIdentifierClass");
    triples.push(
      ...WideIdentifierClassStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("narrowedIdentifierClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "narrowedIdentifierClass");
    for (const pattern of WideIdentifierClassStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({
          rdfType: NarrowedIdentifierClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Shape with shaclmate:mutable properties.
 */
export class MutablePropertiesClass {
  private _$identifier?: MutablePropertiesClass.$Identifier;
  protected readonly _$identifierPrefix?: string;
  readonly $type = "MutablePropertiesClass";
  /**
   * List-valued property that can't be reassigned but whose value can be mutated
   */
  readonly mutableListProperty: purify.Maybe<string[]>;
  /**
   * Set-valued property that can't be reassigned but whose value can be mutated
   */
  mutableSetProperty: string[];
  /**
   * String-valued property that can be re-assigned
   */
  mutableStringProperty: purify.Maybe<string>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly $identifierPrefix?: string;
    readonly mutableListProperty?: purify.Maybe<string[]> | readonly string[];
    readonly mutableSetProperty?: readonly string[];
    readonly mutableStringProperty?: purify.Maybe<string> | string;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    this._$identifierPrefix = parameters?.$identifierPrefix;
    if (purify.Maybe.isMaybe(parameters?.mutableListProperty)) {
      this.mutableListProperty = parameters?.mutableListProperty;
    } else if (typeof parameters?.mutableListProperty === "undefined") {
      this.mutableListProperty = purify.Maybe.of([]);
    } else if (typeof parameters?.mutableListProperty === "object") {
      this.mutableListProperty = purify.Maybe.of(
        parameters?.mutableListProperty.concat(),
      );
    } else {
      this.mutableListProperty =
        parameters?.mutableListProperty satisfies never;
    }

    if (typeof parameters?.mutableSetProperty === "undefined") {
      this.mutableSetProperty = [];
    } else if (typeof parameters?.mutableSetProperty === "object") {
      this.mutableSetProperty = parameters?.mutableSetProperty.concat();
    } else {
      this.mutableSetProperty = parameters?.mutableSetProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.mutableStringProperty)) {
      this.mutableStringProperty = parameters?.mutableStringProperty;
    } else if (typeof parameters?.mutableStringProperty === "string") {
      this.mutableStringProperty = purify.Maybe.of(
        parameters?.mutableStringProperty,
      );
    } else if (typeof parameters?.mutableStringProperty === "undefined") {
      this.mutableStringProperty = purify.Maybe.empty();
    } else {
      this.mutableStringProperty =
        parameters?.mutableStringProperty satisfies never;
    }
  }

  get $identifier(): MutablePropertiesClass.$Identifier {
    return typeof this._$identifier !== "undefined"
      ? this._$identifier
      : dataFactory.namedNode(
          `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
        );
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  $equals(other: MutablePropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$identifierPrefix, other.$identifierPrefix).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$identifierPrefix",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) =>
            $arrayEquals(left, right, $strictEquals),
          ))(this.mutableListProperty, other.mutableListProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "mutableListProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $strictEquals))(
          this.mutableSetProperty,
          other.mutableSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "mutableSetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.mutableStringProperty,
          other.mutableStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "mutableStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.mutableListProperty.ifJust((value0) => {
      for (const item1 of value0) {
        _hasher.update(item1);
      }
    });
    for (const item0 of this.mutableSetProperty) {
      _hasher.update(item0);
    }

    this.mutableStringProperty.ifJust((value0) => {
      _hasher.update(value0);
    });
    return _hasher;
  }

  $toJson(): MutablePropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        mutableListProperty: this.mutableListProperty
          .map((item) => item.map((item) => item))
          .extract(),
        mutableSetProperty: this.mutableSetProperty.map((item) => item),
        mutableStringProperty: this.mutableStringProperty
          .map((item) => item)
          .extract(),
      } satisfies MutablePropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      MutablePropertiesClass.$properties.mutableListProperty["identifier"],
      ...this.mutableListProperty.toList().flatMap((value) => [
        value.length > 0
          ? value.reduce(
              (
                { currentSubListResource, listResource },
                item,
                itemIndex,
                list,
              ) => {
                if (itemIndex === 0) {
                  currentSubListResource = listResource;
                } else {
                  const newSubListResource = resourceSet.mutableResource(
                    dataFactory.blankNode(),
                    { mutateGraph },
                  );
                  currentSubListResource!.add(
                    $RdfVocabularies.rdf.rest,
                    newSubListResource.identifier,
                  );
                  currentSubListResource = newSubListResource;
                }

                currentSubListResource.add(
                  $RdfVocabularies.rdf.first,
                  ...[item],
                );

                if (itemIndex + 1 === list.length) {
                  currentSubListResource.add(
                    $RdfVocabularies.rdf.rest,
                    $RdfVocabularies.rdf.nil,
                  );
                }

                return { currentSubListResource, listResource };
              },
              {
                currentSubListResource: null,
                listResource: resourceSet.mutableResource(
                  dataFactory.blankNode(),
                  { mutateGraph },
                ),
              } as {
                currentSubListResource: rdfjsResource.MutableResource | null;
                listResource: rdfjsResource.MutableResource;
              },
            ).listResource.identifier
          : $RdfVocabularies.rdf.nil,
      ]),
    );
    resource.add(
      MutablePropertiesClass.$properties.mutableSetProperty["identifier"],
      ...this.mutableSetProperty.flatMap((item) => [item]),
    );
    resource.add(
      MutablePropertiesClass.$properties.mutableStringProperty["identifier"],
      ...this.mutableStringProperty.toList(),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace MutablePropertiesClass {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "MutablePropertiesClass";
    readonly mutableListProperty?: readonly string[];
    readonly mutableSetProperty?: readonly string[];
    readonly mutableStringProperty?: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      mutableListProperty: purify.Maybe<string[]>;
      mutableSetProperty: string[];
      mutableStringProperty: purify.Maybe<string>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const mutableListProperty = purify.Maybe.fromNullable(
      $jsonObject["mutableListProperty"],
    );
    const mutableSetProperty = $jsonObject["mutableSetProperty"];
    const mutableStringProperty = purify.Maybe.fromNullable(
      $jsonObject["mutableStringProperty"],
    );
    return purify.Either.of({
      $identifier,
      mutableListProperty,
      mutableSetProperty,
      mutableStringProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, MutablePropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new MutablePropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "MutablePropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/mutableListProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/mutableSetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/mutableStringProperty`,
          type: "Control",
        },
      ],
      label: "MutablePropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("MutablePropertiesClass"),
      mutableListProperty: zod
        .string()
        .array()
        .default(() => [])
        .optional()
        .describe(
          "List-valued property that can't be reassigned but whose value can be mutated",
        ),
      mutableSetProperty: zod
        .string()
        .array()
        .default(() => [])
        .describe(
          "Set-valued property that can't be reassigned but whose value can be mutated",
        ),
      mutableStringProperty: zod
        .string()
        .optional()
        .describe("String-valued property that can be re-assigned"),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, MutablePropertiesClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return MutablePropertiesClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new MutablePropertiesClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      mutableListProperty: purify.Maybe<string[]>;
      mutableSetProperty: string[];
      mutableStringProperty: purify.Maybe<string>;
    }
  > {
    const $identifier: MutablePropertiesClass.$Identifier =
      $resource.identifier;
    const _mutableListPropertyEither: purify.Either<
      Error,
      purify.Maybe<string[]>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.mutableListProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => values.chainMap((value) => value.toList()))
      .chain((valueLists) =>
        valueLists.chainMap((valueList) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            rdfjsResource.Resource.Values.fromArray({
              objects: valueList,
              predicate:
                MutablePropertiesClass.$properties.mutableListProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
          )
            .chain((values) => {
              if (!$preferredLanguages || $preferredLanguages.length === 0) {
                return purify.Either.of<
                  Error,
                  rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
                >(values);
              }

              const literalValuesEither = values.chainMap((value) =>
                value.toLiteral(),
              );
              if (literalValuesEither.isLeft()) {
                return literalValuesEither;
              }
              const literalValues = literalValuesEither.unsafeCoerce();

              // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
              // Within a preferredLanguage the literals may be in any order.
              let filteredLiteralValues:
                | rdfjsResource.Resource.Values<rdfjs.Literal>
                | undefined;
              for (const preferredLanguage of $preferredLanguages) {
                if (!filteredLiteralValues) {
                  filteredLiteralValues = literalValues.filter(
                    (value) => value.language === preferredLanguage,
                  );
                } else {
                  filteredLiteralValues = filteredLiteralValues.concat(
                    ...literalValues
                      .filter((value) => value.language === preferredLanguage)
                      .toArray(),
                  );
                }
              }

              return purify.Either.of<
                Error,
                rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
              >(
                filteredLiteralValues!.map(
                  (literalValue) =>
                    new rdfjsResource.Resource.Value({
                      object: literalValue,
                      predicate:
                        MutablePropertiesClass.$properties.mutableListProperty[
                          "identifier"
                        ],
                      subject: $resource,
                    }),
                ),
              );
            })
            .chain((values) => values.chainMap((value) => value.toString())),
        ),
      )
      .map((valueLists) =>
        valueLists.map((valueList) => valueList.toArray().concat()),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<string[]>>({
              object: purify.Maybe.empty(),
              predicate:
                MutablePropertiesClass.$properties.mutableListProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_mutableListPropertyEither.isLeft()) {
      return _mutableListPropertyEither;
    }

    const mutableListProperty = _mutableListPropertyEither.unsafeCoerce();
    const _mutableSetPropertyEither: purify.Either<Error, string[]> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.mutableSetProperty["identifier"], {
          unique: true,
        }),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    MutablePropertiesClass.$properties.mutableSetProperty[
                      "identifier"
                    ],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .map((values) => values.toArray().concat())
        .map((valuesArray) =>
          rdfjsResource.Resource.Values.fromValue({
            object: valuesArray,
            predicate:
              MutablePropertiesClass.$properties.mutableSetProperty[
                "identifier"
              ],
            subject: $resource,
          }),
        )
        .chain((values) => values.head());
    if (_mutableSetPropertyEither.isLeft()) {
      return _mutableSetPropertyEither;
    }

    const mutableSetProperty = _mutableSetPropertyEither.unsafeCoerce();
    const _mutableStringPropertyEither: purify.Either<
      Error,
      purify.Maybe<string>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.mutableStringProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => {
        if (!$preferredLanguages || $preferredLanguages.length === 0) {
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(values);
        }

        const literalValuesEither = values.chainMap((value) =>
          value.toLiteral(),
        );
        if (literalValuesEither.isLeft()) {
          return literalValuesEither;
        }
        const literalValues = literalValuesEither.unsafeCoerce();

        // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
        // Within a preferredLanguage the literals may be in any order.
        let filteredLiteralValues:
          | rdfjsResource.Resource.Values<rdfjs.Literal>
          | undefined;
        for (const preferredLanguage of $preferredLanguages) {
          if (!filteredLiteralValues) {
            filteredLiteralValues = literalValues.filter(
              (value) => value.language === preferredLanguage,
            );
          } else {
            filteredLiteralValues = filteredLiteralValues.concat(
              ...literalValues
                .filter((value) => value.language === preferredLanguage)
                .toArray(),
            );
          }
        }

        return purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
        >(
          filteredLiteralValues!.map(
            (literalValue) =>
              new rdfjsResource.Resource.Value({
                object: literalValue,
                predicate:
                  MutablePropertiesClass.$properties.mutableStringProperty[
                    "identifier"
                  ],
                subject: $resource,
              }),
          ),
        );
      })
      .chain((values) => values.chainMap((value) => value.toString()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<string>>({
              object: purify.Maybe.empty(),
              predicate:
                MutablePropertiesClass.$properties.mutableStringProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_mutableStringPropertyEither.isLeft()) {
      return _mutableStringPropertyEither;
    }

    const mutableStringProperty = _mutableStringPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      mutableListProperty,
      mutableSetProperty,
      mutableStringProperty,
    });
  }

  export const $properties = {
    mutableListProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/mutableListProperty",
      ),
    },
    mutableSetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/mutableSetProperty",
      ),
    },
    mutableStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/mutableStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        MutablePropertiesClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        MutablePropertiesClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      MutablePropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("mutablePropertiesClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "mutablePropertiesClass");
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}MutableListProperty`),
      predicate:
        MutablePropertiesClass.$properties.mutableListProperty["identifier"],
      subject,
    });
    triples.push({
      subject: dataFactory.variable!(`${variablePrefix}MutableListProperty`),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${variablePrefix}MutableListProperty`}Item0`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(`${variablePrefix}MutableListProperty`),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${variablePrefix}MutableListProperty`}Rest0`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${`${variablePrefix}MutableListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${variablePrefix}MutableListProperty`}ItemN`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${`${variablePrefix}MutableListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${variablePrefix}MutableListProperty`}RestNBasic`,
      ),
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}MutableSetProperty`),
      predicate:
        MutablePropertiesClass.$properties.mutableSetProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}MutableStringProperty`),
      predicate:
        MutablePropertiesClass.$properties.mutableStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("mutablePropertiesClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "mutablePropertiesClass");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}MutableListProperty`,
                ),
                predicate:
                  MutablePropertiesClass.$properties.mutableListProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
          {
            type: "optional",
            patterns: [
              {
                type: "bgp",
                triples: [
                  {
                    subject: dataFactory.variable!(
                      `${variablePrefix}MutableListProperty`,
                    ),
                    predicate: $RdfVocabularies.rdf.first,
                    object: dataFactory.variable!(
                      `${`${variablePrefix}MutableListProperty`}Item0`,
                    ),
                  },
                ],
              },
              {
                type: "bgp",
                triples: [
                  {
                    subject: dataFactory.variable!(
                      `${variablePrefix}MutableListProperty`,
                    ),
                    predicate: $RdfVocabularies.rdf.rest,
                    object: dataFactory.variable!(
                      `${`${variablePrefix}MutableListProperty`}Rest0`,
                    ),
                  },
                ],
              },
              {
                type: "optional",
                patterns: [
                  {
                    type: "bgp",
                    triples: [
                      {
                        subject: dataFactory.variable!(
                          `${variablePrefix}MutableListProperty`,
                        ),
                        predicate: {
                          type: "path",
                          pathType: "*",
                          items: [$RdfVocabularies.rdf.rest],
                        },
                        object: dataFactory.variable!(
                          `${`${variablePrefix}MutableListProperty`}RestN`,
                        ),
                      },
                    ],
                  },
                  {
                    type: "bgp",
                    triples: [
                      {
                        subject: dataFactory.variable!(
                          `${`${variablePrefix}MutableListProperty`}RestN`,
                        ),
                        predicate: $RdfVocabularies.rdf.first,
                        object: dataFactory.variable!(
                          `${`${variablePrefix}MutableListProperty`}ItemN`,
                        ),
                      },
                    ],
                  },
                  {
                    type: "bgp",
                    triples: [
                      {
                        subject: dataFactory.variable!(
                          `${`${variablePrefix}MutableListProperty`}RestN`,
                        ),
                        predicate: $RdfVocabularies.rdf.rest,
                        object: dataFactory.variable!(
                          `${`${variablePrefix}MutableListProperty`}RestNBasic`,
                        ),
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}MutableSetProperty`,
                ),
                predicate:
                  MutablePropertiesClass.$properties.mutableSetProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
          ...[parameters?.preferredLanguages ?? []]
            .filter((languages) => languages.length > 0)
            .map((languages) =>
              languages.map((language) => ({
                type: "operation" as const,
                operator: "=",
                args: [
                  {
                    type: "operation" as const,
                    operator: "lang",
                    args: [
                      dataFactory.variable!(
                        `${variablePrefix}MutableSetProperty`,
                      ),
                    ],
                  },
                  dataFactory.literal(language),
                ],
              })),
            )
            .map((langEqualsExpressions) => ({
              type: "filter" as const,
              expression: langEqualsExpressions.reduce(
                (reducedExpression, langEqualsExpression) => {
                  if (reducedExpression === null) {
                    return langEqualsExpression;
                  }
                  return {
                    type: "operation" as const,
                    operator: "||",
                    args: [reducedExpression, langEqualsExpression],
                  };
                },
                null as sparqljs.Expression | null,
              ) as sparqljs.Expression,
            })),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}MutableStringProperty`,
                ),
                predicate:
                  MutablePropertiesClass.$properties.mutableStringProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
          ...[parameters?.preferredLanguages ?? []]
            .filter((languages) => languages.length > 0)
            .map((languages) =>
              languages.map((language) => ({
                type: "operation" as const,
                operator: "=",
                args: [
                  {
                    type: "operation" as const,
                    operator: "lang",
                    args: [
                      dataFactory.variable!(
                        `${variablePrefix}MutableStringProperty`,
                      ),
                    ],
                  },
                  dataFactory.literal(language),
                ],
              })),
            )
            .map((langEqualsExpressions) => ({
              type: "filter" as const,
              expression: langEqualsExpressions.reduce(
                (reducedExpression, langEqualsExpression) => {
                  if (reducedExpression === null) {
                    return langEqualsExpression;
                  }
                  return {
                    type: "operation" as const,
                    operator: "||",
                    args: [reducedExpression, langEqualsExpression],
                  };
                },
                null as sparqljs.Expression | null,
              ) as sparqljs.Expression,
            })),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Shape that uses the list shapes in properties.
 */
export class ListPropertiesClass {
  private _$identifier?: ListPropertiesClass.$Identifier;
  readonly $type = "ListPropertiesClass";
  readonly iriListProperty: purify.Maybe<readonly rdfjs.NamedNode[]>;
  readonly objectListProperty: purify.Maybe<readonly NonClass[]>;
  readonly stringListProperty: purify.Maybe<readonly string[]>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly iriListProperty?:
      | purify.Maybe<readonly rdfjs.NamedNode[]>
      | readonly rdfjs.NamedNode[]
      | readonly string[];
    readonly objectListProperty?:
      | purify.Maybe<readonly NonClass[]>
      | readonly NonClass[];
    readonly stringListProperty?:
      | purify.Maybe<readonly string[]>
      | readonly string[];
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.iriListProperty)) {
      this.iriListProperty = parameters?.iriListProperty;
    } else if (typeof parameters?.iriListProperty === "undefined") {
      this.iriListProperty = purify.Maybe.of([]);
    } else if ($isReadonlyObjectArray(parameters?.iriListProperty)) {
      this.iriListProperty = purify.Maybe.of(parameters?.iriListProperty);
    } else if ($isReadonlyStringArray(parameters?.iriListProperty)) {
      this.iriListProperty = purify.Maybe.of(
        parameters?.iriListProperty.map((item) => dataFactory.namedNode(item)),
      );
    } else {
      this.iriListProperty = parameters?.iriListProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.objectListProperty)) {
      this.objectListProperty = parameters?.objectListProperty;
    } else if (typeof parameters?.objectListProperty === "undefined") {
      this.objectListProperty = purify.Maybe.of([]);
    } else if (typeof parameters?.objectListProperty === "object") {
      this.objectListProperty = purify.Maybe.of(parameters?.objectListProperty);
    } else {
      this.objectListProperty = parameters?.objectListProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.stringListProperty)) {
      this.stringListProperty = parameters?.stringListProperty;
    } else if (typeof parameters?.stringListProperty === "undefined") {
      this.stringListProperty = purify.Maybe.of([]);
    } else if (typeof parameters?.stringListProperty === "object") {
      this.stringListProperty = purify.Maybe.of(parameters?.stringListProperty);
    } else {
      this.stringListProperty = parameters?.stringListProperty satisfies never;
    }
  }

  get $identifier(): ListPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: ListPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) =>
            $arrayEquals(left, right, $booleanEquals),
          ))(this.iriListProperty, other.iriListProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "iriListProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) =>
            $arrayEquals(left, right, (left, right) => left.$equals(right)),
          ))(this.objectListProperty, other.objectListProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "objectListProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) =>
            $arrayEquals(left, right, $strictEquals),
          ))(this.stringListProperty, other.stringListProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "stringListProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.iriListProperty.ifJust((value0) => {
      for (const item1 of value0) {
        _hasher.update(item1.termType);
        _hasher.update(item1.value);
      }
    });
    this.objectListProperty.ifJust((value0) => {
      for (const item1 of value0) {
        item1.$hash(_hasher);
      }
    });
    this.stringListProperty.ifJust((value0) => {
      for (const item1 of value0) {
        _hasher.update(item1);
      }
    });
    return _hasher;
  }

  $toJson(): ListPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        iriListProperty: this.iriListProperty
          .map((item) => item.map((item) => ({ "@id": item.value })))
          .extract(),
        objectListProperty: this.objectListProperty
          .map((item) => item.map((item) => item.$toJson()))
          .extract(),
        stringListProperty: this.stringListProperty
          .map((item) => item.map((item) => item))
          .extract(),
      } satisfies ListPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      ListPropertiesClass.$properties.iriListProperty["identifier"],
      ...this.iriListProperty.toList().flatMap((value) => [
        value.length > 0
          ? value.reduce(
              (
                { currentSubListResource, listResource },
                item,
                itemIndex,
                list,
              ) => {
                if (itemIndex === 0) {
                  currentSubListResource = listResource;
                } else {
                  const newSubListResource = resourceSet.mutableResource(
                    dataFactory.blankNode(),
                    { mutateGraph },
                  );
                  currentSubListResource!.add(
                    $RdfVocabularies.rdf.rest,
                    newSubListResource.identifier,
                  );
                  currentSubListResource = newSubListResource;
                }

                currentSubListResource.add(
                  $RdfVocabularies.rdf.first,
                  ...[item],
                );

                if (itemIndex + 1 === list.length) {
                  currentSubListResource.add(
                    $RdfVocabularies.rdf.rest,
                    $RdfVocabularies.rdf.nil,
                  );
                }

                return { currentSubListResource, listResource };
              },
              {
                currentSubListResource: null,
                listResource: resourceSet.mutableResource(
                  dataFactory.blankNode(),
                  { mutateGraph },
                ),
              } as {
                currentSubListResource: rdfjsResource.MutableResource | null;
                listResource: rdfjsResource.MutableResource;
              },
            ).listResource.identifier
          : $RdfVocabularies.rdf.nil,
      ]),
    );
    resource.add(
      ListPropertiesClass.$properties.objectListProperty["identifier"],
      ...this.objectListProperty.toList().flatMap((value) => [
        value.length > 0
          ? value.reduce(
              (
                { currentSubListResource, listResource },
                item,
                itemIndex,
                list,
              ) => {
                if (itemIndex === 0) {
                  currentSubListResource = listResource;
                } else {
                  const newSubListResource = resourceSet.mutableResource(
                    dataFactory.blankNode(),
                    { mutateGraph },
                  );
                  currentSubListResource!.add(
                    $RdfVocabularies.rdf.rest,
                    newSubListResource.identifier,
                  );
                  currentSubListResource = newSubListResource;
                }

                currentSubListResource.add(
                  $RdfVocabularies.rdf.first,
                  ...[
                    item.$toRdf({
                      mutateGraph: mutateGraph,
                      resourceSet: resourceSet,
                    }).identifier,
                  ],
                );

                if (itemIndex + 1 === list.length) {
                  currentSubListResource.add(
                    $RdfVocabularies.rdf.rest,
                    $RdfVocabularies.rdf.nil,
                  );
                }

                return { currentSubListResource, listResource };
              },
              {
                currentSubListResource: null,
                listResource: resourceSet.mutableResource(
                  dataFactory.blankNode(),
                  { mutateGraph },
                ),
              } as {
                currentSubListResource: rdfjsResource.MutableResource | null;
                listResource: rdfjsResource.MutableResource;
              },
            ).listResource.identifier
          : $RdfVocabularies.rdf.nil,
      ]),
    );
    resource.add(
      ListPropertiesClass.$properties.stringListProperty["identifier"],
      ...this.stringListProperty.toList().flatMap((value) => [
        value.length > 0
          ? value.reduce(
              (
                { currentSubListResource, listResource },
                item,
                itemIndex,
                list,
              ) => {
                if (itemIndex === 0) {
                  currentSubListResource = listResource;
                } else {
                  const newSubListResource = resourceSet.mutableResource(
                    dataFactory.blankNode(),
                    { mutateGraph },
                  );
                  currentSubListResource!.add(
                    $RdfVocabularies.rdf.rest,
                    newSubListResource.identifier,
                  );
                  currentSubListResource = newSubListResource;
                }

                currentSubListResource.add(
                  $RdfVocabularies.rdf.first,
                  ...[item],
                );

                if (itemIndex + 1 === list.length) {
                  currentSubListResource.add(
                    $RdfVocabularies.rdf.rest,
                    $RdfVocabularies.rdf.nil,
                  );
                }

                return { currentSubListResource, listResource };
              },
              {
                currentSubListResource: null,
                listResource: resourceSet.mutableResource(
                  dataFactory.blankNode(),
                  { mutateGraph },
                ),
              } as {
                currentSubListResource: rdfjsResource.MutableResource | null;
                listResource: rdfjsResource.MutableResource;
              },
            ).listResource.identifier
          : $RdfVocabularies.rdf.nil,
      ]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ListPropertiesClass {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ListPropertiesClass";
    readonly iriListProperty?: readonly { readonly "@id": string }[];
    readonly objectListProperty?: readonly NonClass.$Json[];
    readonly stringListProperty?: readonly string[];
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      iriListProperty: purify.Maybe<readonly rdfjs.NamedNode[]>;
      objectListProperty: purify.Maybe<readonly NonClass[]>;
      stringListProperty: purify.Maybe<readonly string[]>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const iriListProperty = purify.Maybe.fromNullable(
      $jsonObject["iriListProperty"],
    ).map((item) => item.map((item) => dataFactory.namedNode(item["@id"])));
    const objectListProperty = purify.Maybe.fromNullable(
      $jsonObject["objectListProperty"],
    ).map((item) =>
      item.map((item) => NonClass.$fromJson(item).unsafeCoerce()),
    );
    const stringListProperty = purify.Maybe.fromNullable(
      $jsonObject["stringListProperty"],
    );
    return purify.Either.of({
      $identifier,
      iriListProperty,
      objectListProperty,
      stringListProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ListPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ListPropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ListPropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/iriListProperty`, type: "Control" },
        NonClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/objectListProperty`,
        }),
        {
          scope: `${scopePrefix}/properties/stringListProperty`,
          type: "Control",
        },
      ],
      label: "ListPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("ListPropertiesClass"),
      iriListProperty: zod
        .object({ "@id": zod.string().min(1) })
        .array()
        .default(() => [])
        .optional(),
      objectListProperty: NonClass.$jsonZodSchema()
        .array()
        .default(() => [])
        .optional(),
      stringListProperty: zod
        .string()
        .array()
        .default(() => [])
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ListPropertiesClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ListPropertiesClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ListPropertiesClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      iriListProperty: purify.Maybe<readonly rdfjs.NamedNode[]>;
      objectListProperty: purify.Maybe<readonly NonClass[]>;
      stringListProperty: purify.Maybe<readonly string[]>;
    }
  > {
    const $identifier: ListPropertiesClass.$Identifier = $resource.identifier;
    const _iriListPropertyEither: purify.Either<
      Error,
      purify.Maybe<readonly rdfjs.NamedNode[]>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.iriListProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => values.chainMap((value) => value.toList()))
      .chain((valueLists) =>
        valueLists.chainMap((valueList) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            rdfjsResource.Resource.Values.fromArray({
              objects: valueList,
              predicate:
                ListPropertiesClass.$properties.iriListProperty["identifier"],
              subject: $resource,
            }),
          ).chain((values) => values.chainMap((value) => value.toIri())),
        ),
      )
      .map((valueLists) => valueLists.map((valueList) => valueList.toArray()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<readonly rdfjs.NamedNode[]>
            >({
              object: purify.Maybe.empty(),
              predicate:
                ListPropertiesClass.$properties.iriListProperty["identifier"],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_iriListPropertyEither.isLeft()) {
      return _iriListPropertyEither;
    }

    const iriListProperty = _iriListPropertyEither.unsafeCoerce();
    const _objectListPropertyEither: purify.Either<
      Error,
      purify.Maybe<readonly NonClass[]>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.objectListProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => values.chainMap((value) => value.toList()))
      .chain((valueLists) =>
        valueLists.chainMap((valueList) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            rdfjsResource.Resource.Values.fromArray({
              objects: valueList,
              predicate:
                ListPropertiesClass.$properties.objectListProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
          ).chain((values) =>
            values.chainMap((value) =>
              value.toResource().chain((resource) =>
                NonClass.$fromRdf(resource, {
                  ...$context,
                  ignoreRdfType: true,
                  objectSet: $objectSet,
                  preferredLanguages: $preferredLanguages,
                }),
              ),
            ),
          ),
        ),
      )
      .map((valueLists) => valueLists.map((valueList) => valueList.toArray()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<readonly NonClass[]>
            >({
              object: purify.Maybe.empty(),
              predicate:
                ListPropertiesClass.$properties.objectListProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_objectListPropertyEither.isLeft()) {
      return _objectListPropertyEither;
    }

    const objectListProperty = _objectListPropertyEither.unsafeCoerce();
    const _stringListPropertyEither: purify.Either<
      Error,
      purify.Maybe<readonly string[]>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.stringListProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => values.chainMap((value) => value.toList()))
      .chain((valueLists) =>
        valueLists.chainMap((valueList) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            rdfjsResource.Resource.Values.fromArray({
              objects: valueList,
              predicate:
                ListPropertiesClass.$properties.stringListProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
          )
            .chain((values) => {
              if (!$preferredLanguages || $preferredLanguages.length === 0) {
                return purify.Either.of<
                  Error,
                  rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
                >(values);
              }

              const literalValuesEither = values.chainMap((value) =>
                value.toLiteral(),
              );
              if (literalValuesEither.isLeft()) {
                return literalValuesEither;
              }
              const literalValues = literalValuesEither.unsafeCoerce();

              // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
              // Within a preferredLanguage the literals may be in any order.
              let filteredLiteralValues:
                | rdfjsResource.Resource.Values<rdfjs.Literal>
                | undefined;
              for (const preferredLanguage of $preferredLanguages) {
                if (!filteredLiteralValues) {
                  filteredLiteralValues = literalValues.filter(
                    (value) => value.language === preferredLanguage,
                  );
                } else {
                  filteredLiteralValues = filteredLiteralValues.concat(
                    ...literalValues
                      .filter((value) => value.language === preferredLanguage)
                      .toArray(),
                  );
                }
              }

              return purify.Either.of<
                Error,
                rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
              >(
                filteredLiteralValues!.map(
                  (literalValue) =>
                    new rdfjsResource.Resource.Value({
                      object: literalValue,
                      predicate:
                        ListPropertiesClass.$properties.stringListProperty[
                          "identifier"
                        ],
                      subject: $resource,
                    }),
                ),
              );
            })
            .chain((values) => values.chainMap((value) => value.toString())),
        ),
      )
      .map((valueLists) => valueLists.map((valueList) => valueList.toArray()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<readonly string[]>
            >({
              object: purify.Maybe.empty(),
              predicate:
                ListPropertiesClass.$properties.stringListProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_stringListPropertyEither.isLeft()) {
      return _stringListPropertyEither;
    }

    const stringListProperty = _stringListPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      iriListProperty,
      objectListProperty,
      stringListProperty,
    });
  }

  export const $properties = {
    iriListProperty: {
      identifier: dataFactory.namedNode("http://example.com/iriListProperty"),
    },
    objectListProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/objectListProperty",
      ),
    },
    stringListProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/stringListProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ListPropertiesClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ListPropertiesClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ListPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("listPropertiesClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "listPropertiesClass");
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}IriListProperty`),
      predicate: ListPropertiesClass.$properties.iriListProperty["identifier"],
      subject,
    });
    triples.push({
      subject: dataFactory.variable!(`${variablePrefix}IriListProperty`),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${variablePrefix}IriListProperty`}Item0`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(`${variablePrefix}IriListProperty`),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${variablePrefix}IriListProperty`}Rest0`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${`${variablePrefix}IriListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${variablePrefix}IriListProperty`}ItemN`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${`${variablePrefix}IriListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${variablePrefix}IriListProperty`}RestNBasic`,
      ),
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}ObjectListProperty`),
      predicate:
        ListPropertiesClass.$properties.objectListProperty["identifier"],
      subject,
    });
    triples.push({
      subject: dataFactory.variable!(`${variablePrefix}ObjectListProperty`),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${variablePrefix}ObjectListProperty`}Item0`,
      ),
    });
    triples.push(
      ...NonClass.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${`${variablePrefix}ObjectListProperty`}Item0`,
        ),
        variablePrefix: `${`${variablePrefix}ObjectListProperty`}Item0`,
      }),
    );
    triples.push({
      subject: dataFactory.variable!(`${variablePrefix}ObjectListProperty`),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${variablePrefix}ObjectListProperty`}Rest0`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${`${variablePrefix}ObjectListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${variablePrefix}ObjectListProperty`}ItemN`,
      ),
    });
    triples.push(
      ...NonClass.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${`${variablePrefix}ObjectListProperty`}ItemN`,
        ),
        variablePrefix: `${`${variablePrefix}ObjectListProperty`}ItemN`,
      }),
    );
    triples.push({
      subject: dataFactory.variable!(
        `${`${variablePrefix}ObjectListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${variablePrefix}ObjectListProperty`}RestNBasic`,
      ),
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}StringListProperty`),
      predicate:
        ListPropertiesClass.$properties.stringListProperty["identifier"],
      subject,
    });
    triples.push({
      subject: dataFactory.variable!(`${variablePrefix}StringListProperty`),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${variablePrefix}StringListProperty`}Item0`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(`${variablePrefix}StringListProperty`),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${variablePrefix}StringListProperty`}Rest0`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${`${variablePrefix}StringListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${variablePrefix}StringListProperty`}ItemN`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${`${variablePrefix}StringListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${variablePrefix}StringListProperty`}RestNBasic`,
      ),
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("listPropertiesClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "listPropertiesClass");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}IriListProperty`,
                ),
                predicate:
                  ListPropertiesClass.$properties.iriListProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          {
            type: "optional",
            patterns: [
              {
                type: "bgp",
                triples: [
                  {
                    subject: dataFactory.variable!(
                      `${variablePrefix}IriListProperty`,
                    ),
                    predicate: $RdfVocabularies.rdf.first,
                    object: dataFactory.variable!(
                      `${`${variablePrefix}IriListProperty`}Item0`,
                    ),
                  },
                ],
              },
              {
                type: "bgp",
                triples: [
                  {
                    subject: dataFactory.variable!(
                      `${variablePrefix}IriListProperty`,
                    ),
                    predicate: $RdfVocabularies.rdf.rest,
                    object: dataFactory.variable!(
                      `${`${variablePrefix}IriListProperty`}Rest0`,
                    ),
                  },
                ],
              },
              {
                type: "optional",
                patterns: [
                  {
                    type: "bgp",
                    triples: [
                      {
                        subject: dataFactory.variable!(
                          `${variablePrefix}IriListProperty`,
                        ),
                        predicate: {
                          type: "path",
                          pathType: "*",
                          items: [$RdfVocabularies.rdf.rest],
                        },
                        object: dataFactory.variable!(
                          `${`${variablePrefix}IriListProperty`}RestN`,
                        ),
                      },
                    ],
                  },
                  {
                    type: "bgp",
                    triples: [
                      {
                        subject: dataFactory.variable!(
                          `${`${variablePrefix}IriListProperty`}RestN`,
                        ),
                        predicate: $RdfVocabularies.rdf.first,
                        object: dataFactory.variable!(
                          `${`${variablePrefix}IriListProperty`}ItemN`,
                        ),
                      },
                    ],
                  },
                  {
                    type: "bgp",
                    triples: [
                      {
                        subject: dataFactory.variable!(
                          `${`${variablePrefix}IriListProperty`}RestN`,
                        ),
                        predicate: $RdfVocabularies.rdf.rest,
                        object: dataFactory.variable!(
                          `${`${variablePrefix}IriListProperty`}RestNBasic`,
                        ),
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}ObjectListProperty`,
                ),
                predicate:
                  ListPropertiesClass.$properties.objectListProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
          {
            type: "optional",
            patterns: [
              {
                type: "bgp",
                triples: [
                  {
                    subject: dataFactory.variable!(
                      `${variablePrefix}ObjectListProperty`,
                    ),
                    predicate: $RdfVocabularies.rdf.first,
                    object: dataFactory.variable!(
                      `${`${variablePrefix}ObjectListProperty`}Item0`,
                    ),
                  },
                ],
              },
              ...NonClass.$sparqlWherePatterns({
                ignoreRdfType: true,
                preferredLanguages: parameters?.preferredLanguages,
                subject: dataFactory.variable!(
                  `${`${variablePrefix}ObjectListProperty`}Item0`,
                ),
                variablePrefix: `${`${variablePrefix}ObjectListProperty`}Item0`,
              }),
              {
                type: "bgp",
                triples: [
                  {
                    subject: dataFactory.variable!(
                      `${variablePrefix}ObjectListProperty`,
                    ),
                    predicate: $RdfVocabularies.rdf.rest,
                    object: dataFactory.variable!(
                      `${`${variablePrefix}ObjectListProperty`}Rest0`,
                    ),
                  },
                ],
              },
              {
                type: "optional",
                patterns: [
                  {
                    type: "bgp",
                    triples: [
                      {
                        subject: dataFactory.variable!(
                          `${variablePrefix}ObjectListProperty`,
                        ),
                        predicate: {
                          type: "path",
                          pathType: "*",
                          items: [$RdfVocabularies.rdf.rest],
                        },
                        object: dataFactory.variable!(
                          `${`${variablePrefix}ObjectListProperty`}RestN`,
                        ),
                      },
                    ],
                  },
                  {
                    type: "bgp",
                    triples: [
                      {
                        subject: dataFactory.variable!(
                          `${`${variablePrefix}ObjectListProperty`}RestN`,
                        ),
                        predicate: $RdfVocabularies.rdf.first,
                        object: dataFactory.variable!(
                          `${`${variablePrefix}ObjectListProperty`}ItemN`,
                        ),
                      },
                    ],
                  },
                  ...NonClass.$sparqlWherePatterns({
                    ignoreRdfType: true,
                    preferredLanguages: parameters?.preferredLanguages,
                    subject: dataFactory.variable!(
                      `${`${variablePrefix}ObjectListProperty`}ItemN`,
                    ),
                    variablePrefix: `${`${variablePrefix}ObjectListProperty`}ItemN`,
                  }),
                  {
                    type: "bgp",
                    triples: [
                      {
                        subject: dataFactory.variable!(
                          `${`${variablePrefix}ObjectListProperty`}RestN`,
                        ),
                        predicate: $RdfVocabularies.rdf.rest,
                        object: dataFactory.variable!(
                          `${`${variablePrefix}ObjectListProperty`}RestNBasic`,
                        ),
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}StringListProperty`,
                ),
                predicate:
                  ListPropertiesClass.$properties.stringListProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
          {
            type: "optional",
            patterns: [
              {
                type: "bgp",
                triples: [
                  {
                    subject: dataFactory.variable!(
                      `${variablePrefix}StringListProperty`,
                    ),
                    predicate: $RdfVocabularies.rdf.first,
                    object: dataFactory.variable!(
                      `${`${variablePrefix}StringListProperty`}Item0`,
                    ),
                  },
                ],
              },
              {
                type: "bgp",
                triples: [
                  {
                    subject: dataFactory.variable!(
                      `${variablePrefix}StringListProperty`,
                    ),
                    predicate: $RdfVocabularies.rdf.rest,
                    object: dataFactory.variable!(
                      `${`${variablePrefix}StringListProperty`}Rest0`,
                    ),
                  },
                ],
              },
              {
                type: "optional",
                patterns: [
                  {
                    type: "bgp",
                    triples: [
                      {
                        subject: dataFactory.variable!(
                          `${variablePrefix}StringListProperty`,
                        ),
                        predicate: {
                          type: "path",
                          pathType: "*",
                          items: [$RdfVocabularies.rdf.rest],
                        },
                        object: dataFactory.variable!(
                          `${`${variablePrefix}StringListProperty`}RestN`,
                        ),
                      },
                    ],
                  },
                  {
                    type: "bgp",
                    triples: [
                      {
                        subject: dataFactory.variable!(
                          `${`${variablePrefix}StringListProperty`}RestN`,
                        ),
                        predicate: $RdfVocabularies.rdf.first,
                        object: dataFactory.variable!(
                          `${`${variablePrefix}StringListProperty`}ItemN`,
                        ),
                      },
                    ],
                  },
                  {
                    type: "bgp",
                    triples: [
                      {
                        subject: dataFactory.variable!(
                          `${`${variablePrefix}StringListProperty`}RestN`,
                        ),
                        predicate: $RdfVocabularies.rdf.rest,
                        object: dataFactory.variable!(
                          `${`${variablePrefix}StringListProperty`}RestNBasic`,
                        ),
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Node shape used as a partial by LazyPropertiesInterface
 */
export interface PartialInterface {
  readonly $identifier: PartialInterface.$Identifier;
  readonly $type: "PartialInterface";
  readonly lazilyResolvedStringProperty: string;
}

export namespace PartialInterface {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): PartialInterface {
    let $identifier: PartialInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "PartialInterface" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: PartialInterface,
    right: PartialInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialInterface";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "PartialInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "PartialInterface" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialInterface> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialInterface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialInterface",
      type: "Group",
    };
  }

  export function $toJson(
    _partialInterface: PartialInterface,
  ): PartialInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _partialInterface.$identifier.termType === "BlankNode"
            ? `_:${_partialInterface.$identifier.value}`
            : _partialInterface.$identifier.value,
        $type: _partialInterface.$type,
        lazilyResolvedStringProperty:
          _partialInterface.lazilyResolvedStringProperty,
      } satisfies PartialInterface.$Json),
    );
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PartialInterface"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_partialInterface: PartialInterface, _hasher: HasherT): HasherT {
    _hasher.update(_partialInterface.$identifier.value);
    _hasher.update(_partialInterface.$type);
    PartialInterface.$hashShaclProperties(_partialInterface, _hasher);
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_partialInterface: PartialInterface, _hasher: HasherT): HasherT {
    _hasher.update(_partialInterface.lazilyResolvedStringProperty);
    return _hasher;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialInterface> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PartialInterface.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "PartialInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $identifier: PartialInterface.$Identifier = $resource.identifier;
    const $type = "PartialInterface" as const;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    PartialInterface.$properties.lazilyResolvedStringProperty[
                      "identifier"
                    ],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $toRdf(
    _partialInterface: PartialInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _partialInterface.$identifier,
      { mutateGraph },
    );
    resource.add(
      PartialInterface.$properties.lazilyResolvedStringProperty["identifier"],
      ...[_partialInterface.lazilyResolvedStringProperty],
    );
    return resource;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialInterface.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PartialInterface.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialInterface");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "partialInterface");
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}LazilyResolvedStringProperty`,
      ),
      predicate:
        PartialInterface.$properties.lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialInterface");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "partialInterface");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}LazilyResolvedStringProperty`,
            ),
            predicate:
              PartialInterface.$properties.lazilyResolvedStringProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}LazilyResolvedStringProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Node shape that has lazy properties.
 */
export interface LazyPropertiesInterface {
  readonly $identifier: LazyPropertiesInterface.$Identifier;
  readonly $type: "LazyPropertiesInterface";
  readonly optionalLazyToResolvedInterfaceProperty: $LazyOptionalObject<
    LazilyResolvedBlankNodeOrIriInterface.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriInterface
  >;
  readonly optionalLazyToResolvedInterfaceUnionProperty: $LazyOptionalObject<
    LazilyResolvedInterfaceUnion.$Identifier,
    $DefaultPartial,
    LazilyResolvedInterfaceUnion
  >;
  readonly optionalLazyToResolvedIriInterfaceProperty: $LazyOptionalObject<
    LazilyResolvedIriInterface.$Identifier,
    $NamedDefaultPartial,
    LazilyResolvedIriInterface
  >;
  readonly optionalPartialInterfaceToResolvedInterfaceProperty: $LazyOptionalObject<
    LazilyResolvedBlankNodeOrIriInterface.$Identifier,
    PartialInterface,
    LazilyResolvedBlankNodeOrIriInterface
  >;
  readonly optionalPartialInterfaceToResolvedInterfaceUnionProperty: $LazyOptionalObject<
    LazilyResolvedInterfaceUnion.$Identifier,
    PartialInterface,
    LazilyResolvedInterfaceUnion
  >;
  readonly optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty: $LazyOptionalObject<
    LazilyResolvedInterfaceUnion.$Identifier,
    PartialInterfaceUnion,
    LazilyResolvedInterfaceUnion
  >;
  readonly requiredLazyToResolvedInterfaceProperty: $LazyRequiredObject<
    LazilyResolvedBlankNodeOrIriInterface.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriInterface
  >;
  readonly requiredPartialInterfaceToResolvedInterfaceProperty: $LazyRequiredObject<
    LazilyResolvedBlankNodeOrIriInterface.$Identifier,
    PartialInterface,
    LazilyResolvedBlankNodeOrIriInterface
  >;
  readonly setLazyToResolvedInterfaceProperty: $LazyObjectSet<
    LazilyResolvedBlankNodeOrIriInterface.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriInterface
  >;
  readonly setPartialInterfaceToResolvedInterfaceProperty: $LazyObjectSet<
    LazilyResolvedBlankNodeOrIriInterface.$Identifier,
    PartialInterface,
    LazilyResolvedBlankNodeOrIriInterface
  >;
}

export namespace LazyPropertiesInterface {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly optionalLazyToResolvedInterfaceProperty?:
      | $LazyOptionalObject<
          LazilyResolvedBlankNodeOrIriInterface.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriInterface
        >
      | LazilyResolvedBlankNodeOrIriInterface
      | purify.Maybe<LazilyResolvedBlankNodeOrIriInterface>;
    readonly optionalLazyToResolvedInterfaceUnionProperty?:
      | $LazyOptionalObject<
          LazilyResolvedInterfaceUnion.$Identifier,
          $DefaultPartial,
          LazilyResolvedInterfaceUnion
        >
      | LazilyResolvedInterfaceUnion
      | purify.Maybe<LazilyResolvedInterfaceUnion>;
    readonly optionalLazyToResolvedIriInterfaceProperty?:
      | $LazyOptionalObject<
          LazilyResolvedIriInterface.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriInterface
        >
      | LazilyResolvedIriInterface
      | purify.Maybe<LazilyResolvedIriInterface>;
    readonly optionalPartialInterfaceToResolvedInterfaceProperty?:
      | $LazyOptionalObject<
          LazilyResolvedBlankNodeOrIriInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriInterface
        >
      | LazilyResolvedBlankNodeOrIriInterface
      | purify.Maybe<LazilyResolvedBlankNodeOrIriInterface>;
    readonly optionalPartialInterfaceToResolvedInterfaceUnionProperty?:
      | $LazyOptionalObject<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterface,
          LazilyResolvedInterfaceUnion
        >
      | LazilyResolvedInterfaceUnion
      | purify.Maybe<LazilyResolvedInterfaceUnion>;
    readonly optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty?:
      | $LazyOptionalObject<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterfaceUnion,
          LazilyResolvedInterfaceUnion
        >
      | LazilyResolvedInterfaceUnion
      | purify.Maybe<LazilyResolvedInterfaceUnion>;
    readonly requiredLazyToResolvedInterfaceProperty:
      | $LazyRequiredObject<
          LazilyResolvedBlankNodeOrIriInterface.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriInterface
        >
      | LazilyResolvedBlankNodeOrIriInterface;
    readonly requiredPartialInterfaceToResolvedInterfaceProperty:
      | $LazyRequiredObject<
          LazilyResolvedBlankNodeOrIriInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriInterface
        >
      | LazilyResolvedBlankNodeOrIriInterface;
    readonly setLazyToResolvedInterfaceProperty?:
      | $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriInterface.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriInterface
        >
      | readonly LazilyResolvedBlankNodeOrIriInterface[];
    readonly setPartialInterfaceToResolvedInterfaceProperty?:
      | $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriInterface
        >
      | readonly LazilyResolvedBlankNodeOrIriInterface[];
  }): LazyPropertiesInterface {
    let $identifier: LazyPropertiesInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "LazyPropertiesInterface" as const;
    let optionalLazyToResolvedInterfaceProperty: $LazyOptionalObject<
      LazilyResolvedBlankNodeOrIriInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriInterface
    >;
    if (
      typeof parameters.optionalLazyToResolvedInterfaceProperty === "object" &&
      parameters.optionalLazyToResolvedInterfaceProperty instanceof
        $LazyOptionalObject
    ) {
      optionalLazyToResolvedInterfaceProperty =
        parameters.optionalLazyToResolvedInterfaceProperty;
    } else if (
      purify.Maybe.isMaybe(parameters.optionalLazyToResolvedInterfaceProperty)
    ) {
      optionalLazyToResolvedInterfaceProperty = new $LazyOptionalObject<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriInterface
      >({
        partial: parameters.optionalLazyToResolvedInterfaceProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          purify.Either.of(
            (
              parameters.optionalLazyToResolvedInterfaceProperty as purify.Maybe<LazilyResolvedBlankNodeOrIriInterface>
            ).unsafeCoerce(),
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedInterfaceProperty === "object"
    ) {
      optionalLazyToResolvedInterfaceProperty = new $LazyOptionalObject<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriInterface
      >({
        partial: purify.Maybe.of(
          new $DefaultPartial(
            parameters.optionalLazyToResolvedInterfaceProperty,
          ),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.optionalLazyToResolvedInterfaceProperty as LazilyResolvedBlankNodeOrIriInterface,
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedInterfaceProperty === "undefined"
    ) {
      optionalLazyToResolvedInterfaceProperty = new $LazyOptionalObject<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriInterface
      >({
        partial: purify.Maybe.empty(),
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      optionalLazyToResolvedInterfaceProperty =
        parameters.optionalLazyToResolvedInterfaceProperty satisfies never;
    }

    let optionalLazyToResolvedInterfaceUnionProperty: $LazyOptionalObject<
      LazilyResolvedInterfaceUnion.$Identifier,
      $DefaultPartial,
      LazilyResolvedInterfaceUnion
    >;
    if (
      typeof parameters.optionalLazyToResolvedInterfaceUnionProperty ===
        "object" &&
      parameters.optionalLazyToResolvedInterfaceUnionProperty instanceof
        $LazyOptionalObject
    ) {
      optionalLazyToResolvedInterfaceUnionProperty =
        parameters.optionalLazyToResolvedInterfaceUnionProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalLazyToResolvedInterfaceUnionProperty,
      )
    ) {
      optionalLazyToResolvedInterfaceUnionProperty = new $LazyOptionalObject<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >({
        partial: parameters.optionalLazyToResolvedInterfaceUnionProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          purify.Either.of(
            (
              parameters.optionalLazyToResolvedInterfaceUnionProperty as purify.Maybe<LazilyResolvedInterfaceUnion>
            ).unsafeCoerce(),
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedInterfaceUnionProperty ===
      "object"
    ) {
      optionalLazyToResolvedInterfaceUnionProperty = new $LazyOptionalObject<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >({
        partial: purify.Maybe.of(
          new $DefaultPartial(
            parameters.optionalLazyToResolvedInterfaceUnionProperty,
          ),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.optionalLazyToResolvedInterfaceUnionProperty as LazilyResolvedInterfaceUnion,
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedInterfaceUnionProperty ===
      "undefined"
    ) {
      optionalLazyToResolvedInterfaceUnionProperty = new $LazyOptionalObject<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >({
        partial: purify.Maybe.empty(),
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      optionalLazyToResolvedInterfaceUnionProperty =
        parameters.optionalLazyToResolvedInterfaceUnionProperty satisfies never;
    }

    let optionalLazyToResolvedIriInterfaceProperty: $LazyOptionalObject<
      LazilyResolvedIriInterface.$Identifier,
      $NamedDefaultPartial,
      LazilyResolvedIriInterface
    >;
    if (
      typeof parameters.optionalLazyToResolvedIriInterfaceProperty ===
        "object" &&
      parameters.optionalLazyToResolvedIriInterfaceProperty instanceof
        $LazyOptionalObject
    ) {
      optionalLazyToResolvedIriInterfaceProperty =
        parameters.optionalLazyToResolvedIriInterfaceProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalLazyToResolvedIriInterfaceProperty,
      )
    ) {
      optionalLazyToResolvedIriInterfaceProperty = new $LazyOptionalObject<
        LazilyResolvedIriInterface.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriInterface
      >({
        partial: parameters.optionalLazyToResolvedIriInterfaceProperty.map(
          (object) => new $NamedDefaultPartial(object),
        ),
        resolver: async () =>
          purify.Either.of(
            (
              parameters.optionalLazyToResolvedIriInterfaceProperty as purify.Maybe<LazilyResolvedIriInterface>
            ).unsafeCoerce(),
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedIriInterfaceProperty === "object"
    ) {
      optionalLazyToResolvedIriInterfaceProperty = new $LazyOptionalObject<
        LazilyResolvedIriInterface.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriInterface
      >({
        partial: purify.Maybe.of(
          new $NamedDefaultPartial(
            parameters.optionalLazyToResolvedIriInterfaceProperty,
          ),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.optionalLazyToResolvedIriInterfaceProperty as LazilyResolvedIriInterface,
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedIriInterfaceProperty ===
      "undefined"
    ) {
      optionalLazyToResolvedIriInterfaceProperty = new $LazyOptionalObject<
        LazilyResolvedIriInterface.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriInterface
      >({
        partial: purify.Maybe.empty(),
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      optionalLazyToResolvedIriInterfaceProperty =
        parameters.optionalLazyToResolvedIriInterfaceProperty satisfies never;
    }

    let optionalPartialInterfaceToResolvedInterfaceProperty: $LazyOptionalObject<
      LazilyResolvedBlankNodeOrIriInterface.$Identifier,
      PartialInterface,
      LazilyResolvedBlankNodeOrIriInterface
    >;
    if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceProperty ===
        "object" &&
      parameters.optionalPartialInterfaceToResolvedInterfaceProperty instanceof
        $LazyOptionalObject
    ) {
      optionalPartialInterfaceToResolvedInterfaceProperty =
        parameters.optionalPartialInterfaceToResolvedInterfaceProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalPartialInterfaceToResolvedInterfaceProperty,
      )
    ) {
      optionalPartialInterfaceToResolvedInterfaceProperty =
        new $LazyOptionalObject<
          LazilyResolvedBlankNodeOrIriInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriInterface
        >({
          partial:
            parameters.optionalPartialInterfaceToResolvedInterfaceProperty.map(
              (object) => PartialInterface.$create(object),
            ),
          resolver: async () =>
            purify.Either.of(
              (
                parameters.optionalPartialInterfaceToResolvedInterfaceProperty as purify.Maybe<LazilyResolvedBlankNodeOrIriInterface>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceProperty ===
      "object"
    ) {
      optionalPartialInterfaceToResolvedInterfaceProperty =
        new $LazyOptionalObject<
          LazilyResolvedBlankNodeOrIriInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriInterface
        >({
          partial: purify.Maybe.of(
            PartialInterface.$create(
              parameters.optionalPartialInterfaceToResolvedInterfaceProperty,
            ),
          ),
          resolver: async () =>
            purify.Either.of(
              parameters.optionalPartialInterfaceToResolvedInterfaceProperty as LazilyResolvedBlankNodeOrIriInterface,
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceProperty ===
      "undefined"
    ) {
      optionalPartialInterfaceToResolvedInterfaceProperty =
        new $LazyOptionalObject<
          LazilyResolvedBlankNodeOrIriInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriInterface
        >({
          partial: purify.Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      optionalPartialInterfaceToResolvedInterfaceProperty =
        parameters.optionalPartialInterfaceToResolvedInterfaceProperty satisfies never;
    }

    let optionalPartialInterfaceToResolvedInterfaceUnionProperty: $LazyOptionalObject<
      LazilyResolvedInterfaceUnion.$Identifier,
      PartialInterface,
      LazilyResolvedInterfaceUnion
    >;
    if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty ===
        "object" &&
      parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty instanceof
        $LazyOptionalObject
    ) {
      optionalPartialInterfaceToResolvedInterfaceUnionProperty =
        parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
      )
    ) {
      optionalPartialInterfaceToResolvedInterfaceUnionProperty =
        new $LazyOptionalObject<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterface,
          LazilyResolvedInterfaceUnion
        >({
          partial:
            parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty.map(
              (object) => PartialInterface.$create(object),
            ),
          resolver: async () =>
            purify.Either.of(
              (
                parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty as purify.Maybe<LazilyResolvedInterfaceUnion>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty ===
      "object"
    ) {
      optionalPartialInterfaceToResolvedInterfaceUnionProperty =
        new $LazyOptionalObject<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterface,
          LazilyResolvedInterfaceUnion
        >({
          partial: purify.Maybe.of(
            PartialInterface.$create(
              parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
            ),
          ),
          resolver: async () =>
            purify.Either.of(
              parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty as LazilyResolvedInterfaceUnion,
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty ===
      "undefined"
    ) {
      optionalPartialInterfaceToResolvedInterfaceUnionProperty =
        new $LazyOptionalObject<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterface,
          LazilyResolvedInterfaceUnion
        >({
          partial: purify.Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      optionalPartialInterfaceToResolvedInterfaceUnionProperty =
        parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty satisfies never;
    }

    let optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty: $LazyOptionalObject<
      LazilyResolvedInterfaceUnion.$Identifier,
      PartialInterfaceUnion,
      LazilyResolvedInterfaceUnion
    >;
    if (
      typeof parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty ===
        "object" &&
      parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty instanceof
        $LazyOptionalObject
    ) {
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
        parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
      )
    ) {
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
        new $LazyOptionalObject<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterfaceUnion,
          LazilyResolvedInterfaceUnion
        >({
          partial:
            parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty.map(
              (object) => {
                switch (object.$type) {
                  case "LazilyResolvedInterfaceUnionMember1":
                    return PartialInterfaceUnionMember1.$create(object);
                  case "LazilyResolvedInterfaceUnionMember2":
                    return PartialInterfaceUnionMember2.$create(object);
                  default:
                    object satisfies never;
                    throw new Error("unrecognized type");
                }
              },
            ),
          resolver: async () =>
            purify.Either.of(
              (
                parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty as purify.Maybe<LazilyResolvedInterfaceUnion>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty ===
      "object"
    ) {
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
        new $LazyOptionalObject<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterfaceUnion,
          LazilyResolvedInterfaceUnion
        >({
          partial: purify.Maybe.of(
            parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
          ).map((object) => {
            switch (object.$type) {
              case "LazilyResolvedInterfaceUnionMember1":
                return PartialInterfaceUnionMember1.$create(object);
              case "LazilyResolvedInterfaceUnionMember2":
                return PartialInterfaceUnionMember2.$create(object);
              default:
                object satisfies never;
                throw new Error("unrecognized type");
            }
          }),
          resolver: async () =>
            purify.Either.of(
              parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty as LazilyResolvedInterfaceUnion,
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty ===
      "undefined"
    ) {
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
        new $LazyOptionalObject<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterfaceUnion,
          LazilyResolvedInterfaceUnion
        >({
          partial: purify.Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
        parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty satisfies never;
    }

    let requiredLazyToResolvedInterfaceProperty: $LazyRequiredObject<
      LazilyResolvedBlankNodeOrIriInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriInterface
    >;
    if (
      typeof parameters.requiredLazyToResolvedInterfaceProperty === "object" &&
      parameters.requiredLazyToResolvedInterfaceProperty instanceof
        $LazyRequiredObject
    ) {
      requiredLazyToResolvedInterfaceProperty =
        parameters.requiredLazyToResolvedInterfaceProperty;
    } else if (
      typeof parameters.requiredLazyToResolvedInterfaceProperty === "object"
    ) {
      requiredLazyToResolvedInterfaceProperty = new $LazyRequiredObject<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriInterface
      >({
        partial: new $DefaultPartial(
          parameters.requiredLazyToResolvedInterfaceProperty,
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.requiredLazyToResolvedInterfaceProperty as LazilyResolvedBlankNodeOrIriInterface,
          ),
      });
    } else {
      requiredLazyToResolvedInterfaceProperty =
        parameters.requiredLazyToResolvedInterfaceProperty satisfies never;
    }

    let requiredPartialInterfaceToResolvedInterfaceProperty: $LazyRequiredObject<
      LazilyResolvedBlankNodeOrIriInterface.$Identifier,
      PartialInterface,
      LazilyResolvedBlankNodeOrIriInterface
    >;
    if (
      typeof parameters.requiredPartialInterfaceToResolvedInterfaceProperty ===
        "object" &&
      parameters.requiredPartialInterfaceToResolvedInterfaceProperty instanceof
        $LazyRequiredObject
    ) {
      requiredPartialInterfaceToResolvedInterfaceProperty =
        parameters.requiredPartialInterfaceToResolvedInterfaceProperty;
    } else if (
      typeof parameters.requiredPartialInterfaceToResolvedInterfaceProperty ===
      "object"
    ) {
      requiredPartialInterfaceToResolvedInterfaceProperty =
        new $LazyRequiredObject<
          LazilyResolvedBlankNodeOrIriInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriInterface
        >({
          partial: PartialInterface.$create(
            parameters.requiredPartialInterfaceToResolvedInterfaceProperty,
          ),
          resolver: async () =>
            purify.Either.of(
              parameters.requiredPartialInterfaceToResolvedInterfaceProperty as LazilyResolvedBlankNodeOrIriInterface,
            ),
        });
    } else {
      requiredPartialInterfaceToResolvedInterfaceProperty =
        parameters.requiredPartialInterfaceToResolvedInterfaceProperty satisfies never;
    }

    let setLazyToResolvedInterfaceProperty: $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriInterface
    >;
    if (
      typeof parameters.setLazyToResolvedInterfaceProperty === "object" &&
      parameters.setLazyToResolvedInterfaceProperty instanceof $LazyObjectSet
    ) {
      setLazyToResolvedInterfaceProperty =
        parameters.setLazyToResolvedInterfaceProperty;
    } else if (
      typeof parameters.setLazyToResolvedInterfaceProperty === "object"
    ) {
      setLazyToResolvedInterfaceProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriInterface
      >({
        partials: parameters.setLazyToResolvedInterfaceProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.setLazyToResolvedInterfaceProperty as readonly LazilyResolvedBlankNodeOrIriInterface[],
          ),
      });
    } else if (
      typeof parameters.setLazyToResolvedInterfaceProperty === "undefined"
    ) {
      setLazyToResolvedInterfaceProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriInterface
      >({
        partials: [],
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      setLazyToResolvedInterfaceProperty =
        parameters.setLazyToResolvedInterfaceProperty satisfies never;
    }

    let setPartialInterfaceToResolvedInterfaceProperty: $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriInterface.$Identifier,
      PartialInterface,
      LazilyResolvedBlankNodeOrIriInterface
    >;
    if (
      typeof parameters.setPartialInterfaceToResolvedInterfaceProperty ===
        "object" &&
      parameters.setPartialInterfaceToResolvedInterfaceProperty instanceof
        $LazyObjectSet
    ) {
      setPartialInterfaceToResolvedInterfaceProperty =
        parameters.setPartialInterfaceToResolvedInterfaceProperty;
    } else if (
      typeof parameters.setPartialInterfaceToResolvedInterfaceProperty ===
      "object"
    ) {
      setPartialInterfaceToResolvedInterfaceProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriInterface
      >({
        partials: parameters.setPartialInterfaceToResolvedInterfaceProperty.map(
          (object) => PartialInterface.$create(object),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.setPartialInterfaceToResolvedInterfaceProperty as readonly LazilyResolvedBlankNodeOrIriInterface[],
          ),
      });
    } else if (
      typeof parameters.setPartialInterfaceToResolvedInterfaceProperty ===
      "undefined"
    ) {
      setPartialInterfaceToResolvedInterfaceProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriInterface
      >({
        partials: [],
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      setPartialInterfaceToResolvedInterfaceProperty =
        parameters.setPartialInterfaceToResolvedInterfaceProperty satisfies never;
    }

    return {
      $identifier,
      $type,
      optionalLazyToResolvedInterfaceProperty,
      optionalLazyToResolvedInterfaceUnionProperty,
      optionalLazyToResolvedIriInterfaceProperty,
      optionalPartialInterfaceToResolvedInterfaceProperty,
      optionalPartialInterfaceToResolvedInterfaceUnionProperty,
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
      requiredLazyToResolvedInterfaceProperty,
      requiredPartialInterfaceToResolvedInterfaceProperty,
      setLazyToResolvedInterfaceProperty,
      setPartialInterfaceToResolvedInterfaceProperty,
    };
  }

  export function $equals(
    left: LazyPropertiesInterface,
    right: LazyPropertiesInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          left.optionalLazyToResolvedInterfaceProperty,
          right.optionalLazyToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "optionalLazyToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          left.optionalLazyToResolvedInterfaceUnionProperty,
          right.optionalLazyToResolvedInterfaceUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "optionalLazyToResolvedInterfaceUnionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          left.optionalLazyToResolvedIriInterfaceProperty,
          right.optionalLazyToResolvedIriInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "optionalLazyToResolvedIriInterfaceProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, PartialInterface.$equals))(
            left.partial,
            right.partial,
          ))(
          left.optionalPartialInterfaceToResolvedInterfaceProperty,
          right.optionalPartialInterfaceToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "optionalPartialInterfaceToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, PartialInterface.$equals))(
            left.partial,
            right.partial,
          ))(
          left.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
          right.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName:
            "optionalPartialInterfaceToResolvedInterfaceUnionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, PartialInterfaceUnion.$equals))(
            left.partial,
            right.partial,
          ))(
          left.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
          right.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName:
            "optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) => left.$equals(right))(left.partial, right.partial))(
          left.requiredLazyToResolvedInterfaceProperty,
          right.requiredLazyToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "requiredLazyToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          PartialInterface.$equals(left.partial, right.partial))(
          left.requiredPartialInterfaceToResolvedInterfaceProperty,
          right.requiredPartialInterfaceToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "requiredPartialInterfaceToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $arrayEquals(left, right, (left, right) => left.$equals(right)))(
            left.partials,
            right.partials,
          ))(
          left.setLazyToResolvedInterfaceProperty,
          right.setLazyToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "setLazyToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $arrayEquals(left, right, PartialInterface.$equals))(
            left.partials,
            right.partials,
          ))(
          left.setPartialInterfaceToResolvedInterfaceProperty,
          right.setPartialInterfaceToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "setPartialInterfaceToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazyPropertiesInterface";
    readonly optionalLazyToResolvedInterfaceProperty?: $DefaultPartial.$Json;
    readonly optionalLazyToResolvedInterfaceUnionProperty?: $DefaultPartial.$Json;
    readonly optionalLazyToResolvedIriInterfaceProperty?: $NamedDefaultPartial.$Json;
    readonly optionalPartialInterfaceToResolvedInterfaceProperty?: PartialInterface.$Json;
    readonly optionalPartialInterfaceToResolvedInterfaceUnionProperty?: PartialInterface.$Json;
    readonly optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty?:
      | PartialInterfaceUnionMember1.$Json
      | PartialInterfaceUnionMember2.$Json;
    readonly requiredLazyToResolvedInterfaceProperty: $DefaultPartial.$Json;
    readonly requiredPartialInterfaceToResolvedInterfaceProperty: PartialInterface.$Json;
    readonly setLazyToResolvedInterfaceProperty?: readonly $DefaultPartial.$Json[];
    readonly setPartialInterfaceToResolvedInterfaceProperty?: readonly PartialInterface.$Json[];
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazyPropertiesInterface";
      optionalLazyToResolvedInterfaceProperty: $LazyOptionalObject<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriInterface
      >;
      optionalLazyToResolvedInterfaceUnionProperty: $LazyOptionalObject<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >;
      optionalLazyToResolvedIriInterfaceProperty: $LazyOptionalObject<
        LazilyResolvedIriInterface.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriInterface
      >;
      optionalPartialInterfaceToResolvedInterfaceProperty: $LazyOptionalObject<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriInterface
      >;
      optionalPartialInterfaceToResolvedInterfaceUnionProperty: $LazyOptionalObject<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterface,
        LazilyResolvedInterfaceUnion
      >;
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty: $LazyOptionalObject<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterfaceUnion,
        LazilyResolvedInterfaceUnion
      >;
      requiredLazyToResolvedInterfaceProperty: $LazyRequiredObject<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriInterface
      >;
      requiredPartialInterfaceToResolvedInterfaceProperty: $LazyRequiredObject<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriInterface
      >;
      setLazyToResolvedInterfaceProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriInterface
      >;
      setPartialInterfaceToResolvedInterfaceProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriInterface
      >;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "LazyPropertiesInterface" as const;
    const optionalLazyToResolvedInterfaceProperty = new $LazyOptionalObject<
      LazilyResolvedBlankNodeOrIriInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriInterface
    >({
      partial: purify.Maybe.fromNullable(
        $jsonObject["optionalLazyToResolvedInterfaceProperty"],
      ).map((item) => $DefaultPartial.$fromJson(item).unsafeCoerce()),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const optionalLazyToResolvedInterfaceUnionProperty =
      new $LazyOptionalObject<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >({
        partial: purify.Maybe.fromNullable(
          $jsonObject["optionalLazyToResolvedInterfaceUnionProperty"],
        ).map((item) => $DefaultPartial.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            purify.Left(
              new Error(
                `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const optionalLazyToResolvedIriInterfaceProperty = new $LazyOptionalObject<
      LazilyResolvedIriInterface.$Identifier,
      $NamedDefaultPartial,
      LazilyResolvedIriInterface
    >({
      partial: purify.Maybe.fromNullable(
        $jsonObject["optionalLazyToResolvedIriInterfaceProperty"],
      ).map((item) => $NamedDefaultPartial.$fromJson(item).unsafeCoerce()),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const optionalPartialInterfaceToResolvedInterfaceProperty =
      new $LazyOptionalObject<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriInterface
      >({
        partial: purify.Maybe.fromNullable(
          $jsonObject["optionalPartialInterfaceToResolvedInterfaceProperty"],
        ).map((item) => PartialInterface.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            purify.Left(
              new Error(
                `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const optionalPartialInterfaceToResolvedInterfaceUnionProperty =
      new $LazyOptionalObject<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterface,
        LazilyResolvedInterfaceUnion
      >({
        partial: purify.Maybe.fromNullable(
          $jsonObject[
            "optionalPartialInterfaceToResolvedInterfaceUnionProperty"
          ],
        ).map((item) => PartialInterface.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            purify.Left(
              new Error(
                `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
      new $LazyOptionalObject<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterfaceUnion,
        LazilyResolvedInterfaceUnion
      >({
        partial: purify.Maybe.fromNullable(
          $jsonObject[
            "optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty"
          ],
        ).map((item) => PartialInterfaceUnion.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            purify.Left(
              new Error(
                `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const requiredLazyToResolvedInterfaceProperty = new $LazyRequiredObject<
      LazilyResolvedBlankNodeOrIriInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriInterface
    >({
      partial: $DefaultPartial
        .$fromJson($jsonObject["requiredLazyToResolvedInterfaceProperty"])
        .unsafeCoerce(),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const requiredPartialInterfaceToResolvedInterfaceProperty =
      new $LazyRequiredObject<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriInterface
      >({
        partial: PartialInterface.$fromJson(
          $jsonObject["requiredPartialInterfaceToResolvedInterfaceProperty"],
        ).unsafeCoerce(),
        resolver: (identifier) =>
          Promise.resolve(
            purify.Left(
              new Error(
                `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const setLazyToResolvedInterfaceProperty = new $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriInterface
    >({
      partials: $jsonObject["setLazyToResolvedInterfaceProperty"].map((item) =>
        $DefaultPartial.$fromJson(item).unsafeCoerce(),
      ),
      resolver: () =>
        Promise.resolve(
          purify.Left(
            new Error("unable to resolve identifiers deserialized from JSON"),
          ),
        ),
    });
    const setPartialInterfaceToResolvedInterfaceProperty = new $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriInterface.$Identifier,
      PartialInterface,
      LazilyResolvedBlankNodeOrIriInterface
    >({
      partials: $jsonObject[
        "setPartialInterfaceToResolvedInterfaceProperty"
      ].map((item) => PartialInterface.$fromJson(item).unsafeCoerce()),
      resolver: () =>
        Promise.resolve(
          purify.Left(
            new Error("unable to resolve identifiers deserialized from JSON"),
          ),
        ),
    });
    return purify.Either.of({
      $identifier,
      $type,
      optionalLazyToResolvedInterfaceProperty,
      optionalLazyToResolvedInterfaceUnionProperty,
      optionalLazyToResolvedIriInterfaceProperty,
      optionalPartialInterfaceToResolvedInterfaceProperty,
      optionalPartialInterfaceToResolvedInterfaceUnionProperty,
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
      requiredLazyToResolvedInterfaceProperty,
      requiredPartialInterfaceToResolvedInterfaceProperty,
      setLazyToResolvedInterfaceProperty,
      setPartialInterfaceToResolvedInterfaceProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazyPropertiesInterface> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazyPropertiesInterface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedInterfaceProperty`,
        }),
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedInterfaceUnionProperty`,
        }),
        $NamedDefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedIriInterfaceProperty`,
        }),
        PartialInterface.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalPartialInterfaceToResolvedInterfaceProperty`,
        }),
        PartialInterface.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalPartialInterfaceToResolvedInterfaceUnionProperty`,
        }),
        {
          scope: `${scopePrefix}/properties/optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
          type: "Control",
        },
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/requiredLazyToResolvedInterfaceProperty`,
        }),
        PartialInterface.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/requiredPartialInterfaceToResolvedInterfaceProperty`,
        }),
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/setLazyToResolvedInterfaceProperty`,
        }),
        PartialInterface.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/setPartialInterfaceToResolvedInterfaceProperty`,
        }),
      ],
      label: "LazyPropertiesInterface",
      type: "Group",
    };
  }

  export function $toJson(
    _lazyPropertiesInterface: LazyPropertiesInterface,
  ): LazyPropertiesInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _lazyPropertiesInterface.$identifier.termType === "BlankNode"
            ? `_:${_lazyPropertiesInterface.$identifier.value}`
            : _lazyPropertiesInterface.$identifier.value,
        $type: _lazyPropertiesInterface.$type,
        optionalLazyToResolvedInterfaceProperty:
          _lazyPropertiesInterface.optionalLazyToResolvedInterfaceProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalLazyToResolvedInterfaceUnionProperty:
          _lazyPropertiesInterface.optionalLazyToResolvedInterfaceUnionProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalLazyToResolvedIriInterfaceProperty:
          _lazyPropertiesInterface.optionalLazyToResolvedIriInterfaceProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalPartialInterfaceToResolvedInterfaceProperty:
          _lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceProperty.partial
            .map((item) => PartialInterface.$toJson(item))
            .extract(),
        optionalPartialInterfaceToResolvedInterfaceUnionProperty:
          _lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceUnionProperty.partial
            .map((item) => PartialInterface.$toJson(item))
            .extract(),
        optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty:
          _lazyPropertiesInterface.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty.partial
            .map((item) => PartialInterfaceUnion.$toJson(item))
            .extract(),
        requiredLazyToResolvedInterfaceProperty:
          _lazyPropertiesInterface.requiredLazyToResolvedInterfaceProperty.partial.$toJson(),
        requiredPartialInterfaceToResolvedInterfaceProperty:
          PartialInterface.$toJson(
            _lazyPropertiesInterface
              .requiredPartialInterfaceToResolvedInterfaceProperty.partial,
          ),
        setLazyToResolvedInterfaceProperty:
          _lazyPropertiesInterface.setLazyToResolvedInterfaceProperty.partials.map(
            (item) => item.$toJson(),
          ),
        setPartialInterfaceToResolvedInterfaceProperty:
          _lazyPropertiesInterface.setPartialInterfaceToResolvedInterfaceProperty.partials.map(
            (item) => PartialInterface.$toJson(item),
          ),
      } satisfies LazyPropertiesInterface.$Json),
    );
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazyPropertiesInterface"),
      optionalLazyToResolvedInterfaceProperty: $DefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalLazyToResolvedInterfaceUnionProperty: $DefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalLazyToResolvedIriInterfaceProperty: $NamedDefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalPartialInterfaceToResolvedInterfaceProperty:
        PartialInterface.$jsonZodSchema().optional(),
      optionalPartialInterfaceToResolvedInterfaceUnionProperty:
        PartialInterface.$jsonZodSchema().optional(),
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty:
        PartialInterfaceUnion.$jsonZodSchema().optional(),
      requiredLazyToResolvedInterfaceProperty: $DefaultPartial.$jsonZodSchema(),
      requiredPartialInterfaceToResolvedInterfaceProperty:
        PartialInterface.$jsonZodSchema(),
      setLazyToResolvedInterfaceProperty: $DefaultPartial
        .$jsonZodSchema()
        .array()
        .default(() => []),
      setPartialInterfaceToResolvedInterfaceProperty:
        PartialInterface.$jsonZodSchema()
          .array()
          .default(() => []),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazyPropertiesInterface: LazyPropertiesInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_lazyPropertiesInterface.$identifier.value);
    _hasher.update(_lazyPropertiesInterface.$type);
    LazyPropertiesInterface.$hashShaclProperties(
      _lazyPropertiesInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazyPropertiesInterface: LazyPropertiesInterface,
    _hasher: HasherT,
  ): HasherT {
    _lazyPropertiesInterface.optionalLazyToResolvedInterfaceProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    _lazyPropertiesInterface.optionalLazyToResolvedInterfaceUnionProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    _lazyPropertiesInterface.optionalLazyToResolvedIriInterfaceProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    _lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceProperty.partial.ifJust(
      (value1) => {
        PartialInterface.$hash(value1, _hasher);
      },
    );
    _lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceUnionProperty.partial.ifJust(
      (value1) => {
        PartialInterface.$hash(value1, _hasher);
      },
    );
    _lazyPropertiesInterface.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty.partial.ifJust(
      (value1) => {
        PartialInterfaceUnion.$hash(value1, _hasher);
      },
    );
    _lazyPropertiesInterface.requiredLazyToResolvedInterfaceProperty.partial.$hash(
      _hasher,
    );
    PartialInterface.$hash(
      _lazyPropertiesInterface
        .requiredPartialInterfaceToResolvedInterfaceProperty.partial,
      _hasher,
    );
    for (const item1 of _lazyPropertiesInterface
      .setLazyToResolvedInterfaceProperty.partials) {
      item1.$hash(_hasher);
    }

    for (const item1 of _lazyPropertiesInterface
      .setPartialInterfaceToResolvedInterfaceProperty.partials) {
      PartialInterface.$hash(item1, _hasher);
    }

    return _hasher;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazyPropertiesInterface> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazyPropertiesInterface.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazyPropertiesInterface";
      optionalLazyToResolvedInterfaceProperty: $LazyOptionalObject<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriInterface
      >;
      optionalLazyToResolvedInterfaceUnionProperty: $LazyOptionalObject<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >;
      optionalLazyToResolvedIriInterfaceProperty: $LazyOptionalObject<
        LazilyResolvedIriInterface.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriInterface
      >;
      optionalPartialInterfaceToResolvedInterfaceProperty: $LazyOptionalObject<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriInterface
      >;
      optionalPartialInterfaceToResolvedInterfaceUnionProperty: $LazyOptionalObject<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterface,
        LazilyResolvedInterfaceUnion
      >;
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty: $LazyOptionalObject<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterfaceUnion,
        LazilyResolvedInterfaceUnion
      >;
      requiredLazyToResolvedInterfaceProperty: $LazyRequiredObject<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriInterface
      >;
      requiredPartialInterfaceToResolvedInterfaceProperty: $LazyRequiredObject<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriInterface
      >;
      setLazyToResolvedInterfaceProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriInterface
      >;
      setPartialInterfaceToResolvedInterfaceProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriInterface
      >;
    }
  > {
    const $identifier: LazyPropertiesInterface.$Identifier =
      $resource.identifier;
    const $type = "LazyPropertiesInterface" as const;
    const _optionalLazyToResolvedInterfacePropertyEither: purify.Either<
      Error,
      $LazyOptionalObject<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriInterface
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.optionalLazyToResolvedInterfaceProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            $DefaultPartial.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<$DefaultPartial>
            >({
              object: purify.Maybe.empty(),
              predicate:
                LazyPropertiesInterface.$properties
                  .optionalLazyToResolvedInterfaceProperty["identifier"],
              subject: $resource,
            }),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyOptionalObject<
              LazilyResolvedBlankNodeOrIriInterface.$Identifier,
              $DefaultPartial,
              LazilyResolvedBlankNodeOrIriInterface
            >({
              partial,
              resolver: (identifier) =>
                $objectSet.lazilyResolvedBlankNodeOrIriInterface(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_optionalLazyToResolvedInterfacePropertyEither.isLeft()) {
      return _optionalLazyToResolvedInterfacePropertyEither;
    }

    const optionalLazyToResolvedInterfaceProperty =
      _optionalLazyToResolvedInterfacePropertyEither.unsafeCoerce();
    const _optionalLazyToResolvedInterfaceUnionPropertyEither: purify.Either<
      Error,
      $LazyOptionalObject<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.optionalLazyToResolvedInterfaceUnionProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            $DefaultPartial.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<$DefaultPartial>
            >({
              object: purify.Maybe.empty(),
              predicate:
                LazyPropertiesInterface.$properties
                  .optionalLazyToResolvedInterfaceUnionProperty["identifier"],
              subject: $resource,
            }),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyOptionalObject<
              LazilyResolvedInterfaceUnion.$Identifier,
              $DefaultPartial,
              LazilyResolvedInterfaceUnion
            >({
              partial,
              resolver: (identifier) =>
                $objectSet.lazilyResolvedInterfaceUnion(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_optionalLazyToResolvedInterfaceUnionPropertyEither.isLeft()) {
      return _optionalLazyToResolvedInterfaceUnionPropertyEither;
    }

    const optionalLazyToResolvedInterfaceUnionProperty =
      _optionalLazyToResolvedInterfaceUnionPropertyEither.unsafeCoerce();
    const _optionalLazyToResolvedIriInterfacePropertyEither: purify.Either<
      Error,
      $LazyOptionalObject<
        LazilyResolvedIriInterface.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriInterface
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.optionalLazyToResolvedIriInterfaceProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            $NamedDefaultPartial.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<$NamedDefaultPartial>
            >({
              object: purify.Maybe.empty(),
              predicate:
                LazyPropertiesInterface.$properties
                  .optionalLazyToResolvedIriInterfaceProperty["identifier"],
              subject: $resource,
            }),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyOptionalObject<
              LazilyResolvedIriInterface.$Identifier,
              $NamedDefaultPartial,
              LazilyResolvedIriInterface
            >({
              partial,
              resolver: (identifier) =>
                $objectSet.lazilyResolvedIriInterface(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_optionalLazyToResolvedIriInterfacePropertyEither.isLeft()) {
      return _optionalLazyToResolvedIriInterfacePropertyEither;
    }

    const optionalLazyToResolvedIriInterfaceProperty =
      _optionalLazyToResolvedIriInterfacePropertyEither.unsafeCoerce();
    const _optionalPartialInterfaceToResolvedInterfacePropertyEither: purify.Either<
      Error,
      $LazyOptionalObject<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriInterface
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.optionalPartialInterfaceToResolvedInterfaceProperty[
          "identifier"
        ],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            PartialInterface.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<PartialInterface>
            >({
              object: purify.Maybe.empty(),
              predicate:
                LazyPropertiesInterface.$properties
                  .optionalPartialInterfaceToResolvedInterfaceProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyOptionalObject<
              LazilyResolvedBlankNodeOrIriInterface.$Identifier,
              PartialInterface,
              LazilyResolvedBlankNodeOrIriInterface
            >({
              partial,
              resolver: (identifier) =>
                $objectSet.lazilyResolvedBlankNodeOrIriInterface(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_optionalPartialInterfaceToResolvedInterfacePropertyEither.isLeft()) {
      return _optionalPartialInterfaceToResolvedInterfacePropertyEither;
    }

    const optionalPartialInterfaceToResolvedInterfaceProperty =
      _optionalPartialInterfaceToResolvedInterfacePropertyEither.unsafeCoerce();
    const _optionalPartialInterfaceToResolvedInterfaceUnionPropertyEither: purify.Either<
      Error,
      $LazyOptionalObject<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterface,
        LazilyResolvedInterfaceUnion
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.optionalPartialInterfaceToResolvedInterfaceUnionProperty[
          "identifier"
        ],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            PartialInterface.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<PartialInterface>
            >({
              object: purify.Maybe.empty(),
              predicate:
                LazyPropertiesInterface.$properties
                  .optionalPartialInterfaceToResolvedInterfaceUnionProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyOptionalObject<
              LazilyResolvedInterfaceUnion.$Identifier,
              PartialInterface,
              LazilyResolvedInterfaceUnion
            >({
              partial,
              resolver: (identifier) =>
                $objectSet.lazilyResolvedInterfaceUnion(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (
      _optionalPartialInterfaceToResolvedInterfaceUnionPropertyEither.isLeft()
    ) {
      return _optionalPartialInterfaceToResolvedInterfaceUnionPropertyEither;
    }

    const optionalPartialInterfaceToResolvedInterfaceUnionProperty =
      _optionalPartialInterfaceToResolvedInterfaceUnionPropertyEither.unsafeCoerce();
    const _optionalPartialInterfaceUnionToResolvedInterfaceUnionPropertyEither: purify.Either<
      Error,
      $LazyOptionalObject<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterfaceUnion,
        LazilyResolvedInterfaceUnion
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties
          .optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty[
          "identifier"
        ],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            PartialInterfaceUnion.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: false,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<PartialInterfaceUnion>
            >({
              object: purify.Maybe.empty(),
              predicate:
                LazyPropertiesInterface.$properties
                  .optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyOptionalObject<
              LazilyResolvedInterfaceUnion.$Identifier,
              PartialInterfaceUnion,
              LazilyResolvedInterfaceUnion
            >({
              partial,
              resolver: (identifier) =>
                $objectSet.lazilyResolvedInterfaceUnion(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (
      _optionalPartialInterfaceUnionToResolvedInterfaceUnionPropertyEither.isLeft()
    ) {
      return _optionalPartialInterfaceUnionToResolvedInterfaceUnionPropertyEither;
    }

    const optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
      _optionalPartialInterfaceUnionToResolvedInterfaceUnionPropertyEither.unsafeCoerce();
    const _requiredLazyToResolvedInterfacePropertyEither: purify.Either<
      Error,
      $LazyRequiredObject<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriInterface
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.requiredLazyToResolvedInterfaceProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            $DefaultPartial.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyRequiredObject<
              LazilyResolvedBlankNodeOrIriInterface.$Identifier,
              $DefaultPartial,
              LazilyResolvedBlankNodeOrIriInterface
            >({
              partial,
              resolver: (identifier) =>
                $objectSet.lazilyResolvedBlankNodeOrIriInterface(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_requiredLazyToResolvedInterfacePropertyEither.isLeft()) {
      return _requiredLazyToResolvedInterfacePropertyEither;
    }

    const requiredLazyToResolvedInterfaceProperty =
      _requiredLazyToResolvedInterfacePropertyEither.unsafeCoerce();
    const _requiredPartialInterfaceToResolvedInterfacePropertyEither: purify.Either<
      Error,
      $LazyRequiredObject<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriInterface
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.requiredPartialInterfaceToResolvedInterfaceProperty[
          "identifier"
        ],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            PartialInterface.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyRequiredObject<
              LazilyResolvedBlankNodeOrIriInterface.$Identifier,
              PartialInterface,
              LazilyResolvedBlankNodeOrIriInterface
            >({
              partial,
              resolver: (identifier) =>
                $objectSet.lazilyResolvedBlankNodeOrIriInterface(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_requiredPartialInterfaceToResolvedInterfacePropertyEither.isLeft()) {
      return _requiredPartialInterfaceToResolvedInterfacePropertyEither;
    }

    const requiredPartialInterfaceToResolvedInterfaceProperty =
      _requiredPartialInterfaceToResolvedInterfacePropertyEither.unsafeCoerce();
    const _setLazyToResolvedInterfacePropertyEither: purify.Either<
      Error,
      $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriInterface
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.setLazyToResolvedInterfaceProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            $DefaultPartial.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) => values.toArray())
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          object: valuesArray,
          predicate:
            LazyPropertiesInterface.$properties
              .setLazyToResolvedInterfaceProperty["identifier"],
          subject: $resource,
        }),
      )
      .map((values) =>
        values.map(
          (partials) =>
            new $LazyObjectSet<
              LazilyResolvedBlankNodeOrIriInterface.$Identifier,
              $DefaultPartial,
              LazilyResolvedBlankNodeOrIriInterface
            >({
              partials,
              resolver: (identifiers) =>
                $objectSet.lazilyResolvedBlankNodeOrIriInterfaces({
                  where: { identifiers, type: "identifiers" },
                }),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_setLazyToResolvedInterfacePropertyEither.isLeft()) {
      return _setLazyToResolvedInterfacePropertyEither;
    }

    const setLazyToResolvedInterfaceProperty =
      _setLazyToResolvedInterfacePropertyEither.unsafeCoerce();
    const _setPartialInterfaceToResolvedInterfacePropertyEither: purify.Either<
      Error,
      $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriInterface
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.setPartialInterfaceToResolvedInterfaceProperty[
          "identifier"
        ],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            PartialInterface.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) => values.toArray())
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          object: valuesArray,
          predicate:
            LazyPropertiesInterface.$properties
              .setPartialInterfaceToResolvedInterfaceProperty["identifier"],
          subject: $resource,
        }),
      )
      .map((values) =>
        values.map(
          (partials) =>
            new $LazyObjectSet<
              LazilyResolvedBlankNodeOrIriInterface.$Identifier,
              PartialInterface,
              LazilyResolvedBlankNodeOrIriInterface
            >({
              partials,
              resolver: (identifiers) =>
                $objectSet.lazilyResolvedBlankNodeOrIriInterfaces({
                  where: { identifiers, type: "identifiers" },
                }),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_setPartialInterfaceToResolvedInterfacePropertyEither.isLeft()) {
      return _setPartialInterfaceToResolvedInterfacePropertyEither;
    }

    const setPartialInterfaceToResolvedInterfaceProperty =
      _setPartialInterfaceToResolvedInterfacePropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      $type,
      optionalLazyToResolvedInterfaceProperty,
      optionalLazyToResolvedInterfaceUnionProperty,
      optionalLazyToResolvedIriInterfaceProperty,
      optionalPartialInterfaceToResolvedInterfaceProperty,
      optionalPartialInterfaceToResolvedInterfaceUnionProperty,
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
      requiredLazyToResolvedInterfaceProperty,
      requiredPartialInterfaceToResolvedInterfaceProperty,
      setLazyToResolvedInterfaceProperty,
      setPartialInterfaceToResolvedInterfaceProperty,
    });
  }

  export function $toRdf(
    _lazyPropertiesInterface: LazyPropertiesInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _lazyPropertiesInterface.$identifier,
      { mutateGraph },
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .optionalLazyToResolvedInterfaceProperty["identifier"],
      ..._lazyPropertiesInterface.optionalLazyToResolvedInterfaceProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .optionalLazyToResolvedInterfaceUnionProperty["identifier"],
      ..._lazyPropertiesInterface.optionalLazyToResolvedInterfaceUnionProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .optionalLazyToResolvedIriInterfaceProperty["identifier"],
      ..._lazyPropertiesInterface.optionalLazyToResolvedIriInterfaceProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .optionalPartialInterfaceToResolvedInterfaceProperty["identifier"],
      ..._lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceProperty.partial
        .toList()
        .flatMap((value) => [
          PartialInterface.$toRdf(value, {
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          }).identifier,
        ]),
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .optionalPartialInterfaceToResolvedInterfaceUnionProperty["identifier"],
      ..._lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceUnionProperty.partial
        .toList()
        .flatMap((value) => [
          PartialInterface.$toRdf(value, {
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          }).identifier,
        ]),
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty[
        "identifier"
      ],
      ..._lazyPropertiesInterface.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty.partial
        .toList()
        .flatMap((value) => [
          PartialInterfaceUnion.$toRdf(value, {
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          }).identifier,
        ]),
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .requiredLazyToResolvedInterfaceProperty["identifier"],
      ...[
        _lazyPropertiesInterface.requiredLazyToResolvedInterfaceProperty.partial.$toRdf(
          { mutateGraph: mutateGraph, resourceSet: resourceSet },
        ).identifier,
      ],
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .requiredPartialInterfaceToResolvedInterfaceProperty["identifier"],
      ...[
        PartialInterface.$toRdf(
          _lazyPropertiesInterface
            .requiredPartialInterfaceToResolvedInterfaceProperty.partial,
          { mutateGraph: mutateGraph, resourceSet: resourceSet },
        ).identifier,
      ],
    );
    resource.add(
      LazyPropertiesInterface.$properties.setLazyToResolvedInterfaceProperty[
        "identifier"
      ],
      ..._lazyPropertiesInterface.setLazyToResolvedInterfaceProperty.partials.flatMap(
        (item) => [
          item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ],
      ),
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .setPartialInterfaceToResolvedInterfaceProperty["identifier"],
      ..._lazyPropertiesInterface.setPartialInterfaceToResolvedInterfaceProperty.partials.flatMap(
        (item) => [
          PartialInterface.$toRdf(item, {
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          }).identifier,
        ],
      ),
    );
    return resource;
  }

  export const $properties = {
    optionalLazyToResolvedInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalLazyToResolvedInterfaceProperty",
      ),
    },
    optionalLazyToResolvedInterfaceUnionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalLazyToResolvedInterfaceUnionProperty",
      ),
    },
    optionalLazyToResolvedIriInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalLazyToResolvedIriInterfaceProperty",
      ),
    },
    optionalPartialInterfaceToResolvedInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalPartialInterfaceToResolvedInterfaceProperty",
      ),
    },
    optionalPartialInterfaceToResolvedInterfaceUnionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalPartialInterfaceToResolvedInterfaceUnionProperty",
      ),
    },
    optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty",
      ),
    },
    requiredLazyToResolvedInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/requiredLazyToResolvedInterfaceProperty",
      ),
    },
    requiredPartialInterfaceToResolvedInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/requiredPartialInterfaceToResolvedInterfaceProperty",
      ),
    },
    setLazyToResolvedInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/setLazyToResolvedInterfaceProperty",
      ),
    },
    setPartialInterfaceToResolvedInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/setPartialInterfaceToResolvedInterfaceProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazyPropertiesInterface.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        LazyPropertiesInterface.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazyPropertiesInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("lazyPropertiesInterface");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "lazyPropertiesInterface");
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}OptionalLazyToResolvedInterfaceProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .optionalLazyToResolvedInterfaceProperty["identifier"],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${variablePrefix}OptionalLazyToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${variablePrefix}OptionalLazyToResolvedInterfaceProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}OptionalLazyToResolvedInterfaceUnionProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .optionalLazyToResolvedInterfaceUnionProperty["identifier"],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${variablePrefix}OptionalLazyToResolvedInterfaceUnionProperty`,
        ),
        variablePrefix: `${variablePrefix}OptionalLazyToResolvedInterfaceUnionProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}OptionalLazyToResolvedIriInterfaceProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .optionalLazyToResolvedIriInterfaceProperty["identifier"],
      subject,
    });
    triples.push(
      ...$NamedDefaultPartial.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${variablePrefix}OptionalLazyToResolvedIriInterfaceProperty`,
        ),
        variablePrefix: `${variablePrefix}OptionalLazyToResolvedIriInterfaceProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}OptionalPartialInterfaceToResolvedInterfaceProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .optionalPartialInterfaceToResolvedInterfaceProperty["identifier"],
      subject,
    });
    triples.push(
      ...PartialInterface.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${variablePrefix}OptionalPartialInterfaceToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${variablePrefix}OptionalPartialInterfaceToResolvedInterfaceProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .optionalPartialInterfaceToResolvedInterfaceUnionProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...PartialInterface.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${variablePrefix}OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
        ),
        variablePrefix: `${variablePrefix}OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...PartialInterfaceUnion.$sparqlConstructTemplateTriples({
        subject: dataFactory.variable!(
          `${variablePrefix}OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
        ),
        variablePrefix: `${variablePrefix}OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}RequiredLazyToResolvedInterfaceProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .requiredLazyToResolvedInterfaceProperty["identifier"],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${variablePrefix}RequiredLazyToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${variablePrefix}RequiredLazyToResolvedInterfaceProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}RequiredPartialInterfaceToResolvedInterfaceProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .requiredPartialInterfaceToResolvedInterfaceProperty["identifier"],
      subject,
    });
    triples.push(
      ...PartialInterface.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${variablePrefix}RequiredPartialInterfaceToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${variablePrefix}RequiredPartialInterfaceToResolvedInterfaceProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}SetLazyToResolvedInterfaceProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties.setLazyToResolvedInterfaceProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${variablePrefix}SetLazyToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${variablePrefix}SetLazyToResolvedInterfaceProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}SetPartialInterfaceToResolvedInterfaceProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .setPartialInterfaceToResolvedInterfaceProperty["identifier"],
      subject,
    });
    triples.push(
      ...PartialInterface.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${variablePrefix}SetPartialInterfaceToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${variablePrefix}SetPartialInterfaceToResolvedInterfaceProperty`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("lazyPropertiesInterface");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "lazyPropertiesInterface");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}OptionalLazyToResolvedInterfaceProperty`,
                ),
                predicate:
                  LazyPropertiesInterface.$properties
                    .optionalLazyToResolvedInterfaceProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...$DefaultPartial.$sparqlWherePatterns({
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${variablePrefix}OptionalLazyToResolvedInterfaceProperty`,
            ),
            variablePrefix: `${variablePrefix}OptionalLazyToResolvedInterfaceProperty`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}OptionalLazyToResolvedInterfaceUnionProperty`,
                ),
                predicate:
                  LazyPropertiesInterface.$properties
                    .optionalLazyToResolvedInterfaceUnionProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...$DefaultPartial.$sparqlWherePatterns({
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${variablePrefix}OptionalLazyToResolvedInterfaceUnionProperty`,
            ),
            variablePrefix: `${variablePrefix}OptionalLazyToResolvedInterfaceUnionProperty`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}OptionalLazyToResolvedIriInterfaceProperty`,
                ),
                predicate:
                  LazyPropertiesInterface.$properties
                    .optionalLazyToResolvedIriInterfaceProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...$NamedDefaultPartial.$sparqlWherePatterns({
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${variablePrefix}OptionalLazyToResolvedIriInterfaceProperty`,
            ),
            variablePrefix: `${variablePrefix}OptionalLazyToResolvedIriInterfaceProperty`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}OptionalPartialInterfaceToResolvedInterfaceProperty`,
                ),
                predicate:
                  LazyPropertiesInterface.$properties
                    .optionalPartialInterfaceToResolvedInterfaceProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
          ...PartialInterface.$sparqlWherePatterns({
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${variablePrefix}OptionalPartialInterfaceToResolvedInterfaceProperty`,
            ),
            variablePrefix: `${variablePrefix}OptionalPartialInterfaceToResolvedInterfaceProperty`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
                ),
                predicate:
                  LazyPropertiesInterface.$properties
                    .optionalPartialInterfaceToResolvedInterfaceUnionProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
          ...PartialInterface.$sparqlWherePatterns({
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${variablePrefix}OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
            ),
            variablePrefix: `${variablePrefix}OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
                ),
                predicate:
                  LazyPropertiesInterface.$properties
                    .optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
          ...PartialInterfaceUnion.$sparqlWherePatterns({
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${variablePrefix}OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
            ),
            variablePrefix: `${variablePrefix}OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
          }),
        ],
        type: "optional",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}RequiredLazyToResolvedInterfaceProperty`,
            ),
            predicate:
              LazyPropertiesInterface.$properties
                .requiredLazyToResolvedInterfaceProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...$DefaultPartial.$sparqlWherePatterns({
        ignoreRdfType: true,
        preferredLanguages: parameters?.preferredLanguages,
        subject: dataFactory.variable!(
          `${variablePrefix}RequiredLazyToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${variablePrefix}RequiredLazyToResolvedInterfaceProperty`,
      }),
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}RequiredPartialInterfaceToResolvedInterfaceProperty`,
            ),
            predicate:
              LazyPropertiesInterface.$properties
                .requiredPartialInterfaceToResolvedInterfaceProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...PartialInterface.$sparqlWherePatterns({
        ignoreRdfType: true,
        preferredLanguages: parameters?.preferredLanguages,
        subject: dataFactory.variable!(
          `${variablePrefix}RequiredPartialInterfaceToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${variablePrefix}RequiredPartialInterfaceToResolvedInterfaceProperty`,
      }),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}SetLazyToResolvedInterfaceProperty`,
                ),
                predicate:
                  LazyPropertiesInterface.$properties
                    .setLazyToResolvedInterfaceProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...$DefaultPartial.$sparqlWherePatterns({
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${variablePrefix}SetLazyToResolvedInterfaceProperty`,
            ),
            variablePrefix: `${variablePrefix}SetLazyToResolvedInterfaceProperty`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}SetPartialInterfaceToResolvedInterfaceProperty`,
                ),
                predicate:
                  LazyPropertiesInterface.$properties
                    .setPartialInterfaceToResolvedInterfaceProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
          ...PartialInterface.$sparqlWherePatterns({
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${variablePrefix}SetPartialInterfaceToResolvedInterfaceProperty`,
            ),
            variablePrefix: `${variablePrefix}SetPartialInterfaceToResolvedInterfaceProperty`,
          }),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Node shape used as a partial by LazyPropertiesClass
 */
export class PartialClass {
  private _$identifier?: PartialClass.$Identifier;
  readonly $type = "PartialClass";
  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): PartialClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: PartialClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): PartialClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies PartialClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      PartialClass.$properties.lazilyResolvedStringProperty["identifier"],
      ...[this.lazilyResolvedStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PartialClass {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialClass";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialClass> {
    return $propertiesFromJson(json).map(
      (properties) => new PartialClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PartialClass"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PartialClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new PartialClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    const $identifier: PartialClass.$Identifier = $resource.identifier;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    PartialClass.$properties.lazilyResolvedStringProperty[
                      "identifier"
                    ],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PartialClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "partialClass");
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}LazilyResolvedStringProperty`,
      ),
      predicate:
        PartialClass.$properties.lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "partialClass");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}LazilyResolvedStringProperty`,
            ),
            predicate:
              PartialClass.$properties.lazilyResolvedStringProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}LazilyResolvedStringProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Node shape that has lazy properties.
 */
export class LazyPropertiesClass {
  private _$identifier?: LazyPropertiesClass.$Identifier;
  readonly $type = "LazyPropertiesClass";
  readonly optionalLazyToResolvedClassProperty: $LazyOptionalObject<
    LazilyResolvedBlankNodeOrIriClass.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriClass
  >;
  readonly optionalLazyToResolvedClassUnionProperty: $LazyOptionalObject<
    LazilyResolvedClassUnion.$Identifier,
    $DefaultPartial,
    LazilyResolvedClassUnion
  >;
  readonly optionalLazyToResolvedIriClassProperty: $LazyOptionalObject<
    LazilyResolvedIriClass.$Identifier,
    $NamedDefaultPartial,
    LazilyResolvedIriClass
  >;
  readonly optionalPartialClassToResolvedClassProperty: $LazyOptionalObject<
    LazilyResolvedBlankNodeOrIriClass.$Identifier,
    PartialClass,
    LazilyResolvedBlankNodeOrIriClass
  >;
  readonly optionalPartialClassToResolvedClassUnionProperty: $LazyOptionalObject<
    LazilyResolvedClassUnion.$Identifier,
    PartialClass,
    LazilyResolvedClassUnion
  >;
  readonly optionalPartialClassUnionToResolvedClassUnionProperty: $LazyOptionalObject<
    LazilyResolvedClassUnion.$Identifier,
    PartialClassUnion,
    LazilyResolvedClassUnion
  >;
  readonly requiredLazyToResolvedClassProperty: $LazyRequiredObject<
    LazilyResolvedBlankNodeOrIriClass.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriClass
  >;
  readonly requiredPartialClassToResolvedClassProperty: $LazyRequiredObject<
    LazilyResolvedBlankNodeOrIriClass.$Identifier,
    PartialClass,
    LazilyResolvedBlankNodeOrIriClass
  >;
  readonly setLazyToResolvedClassProperty: $LazyObjectSet<
    LazilyResolvedBlankNodeOrIriClass.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriClass
  >;
  readonly setPartialClassToResolvedClassProperty: $LazyObjectSet<
    LazilyResolvedBlankNodeOrIriClass.$Identifier,
    PartialClass,
    LazilyResolvedBlankNodeOrIriClass
  >;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly optionalLazyToResolvedClassProperty?:
      | $LazyOptionalObject<
          LazilyResolvedBlankNodeOrIriClass.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriClass
        >
      | LazilyResolvedBlankNodeOrIriClass
      | purify.Maybe<LazilyResolvedBlankNodeOrIriClass>;
    readonly optionalLazyToResolvedClassUnionProperty?:
      | $LazyOptionalObject<
          LazilyResolvedClassUnion.$Identifier,
          $DefaultPartial,
          LazilyResolvedClassUnion
        >
      | LazilyResolvedClassUnion
      | purify.Maybe<LazilyResolvedClassUnion>;
    readonly optionalLazyToResolvedIriClassProperty?:
      | $LazyOptionalObject<
          LazilyResolvedIriClass.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriClass
        >
      | LazilyResolvedIriClass
      | purify.Maybe<LazilyResolvedIriClass>;
    readonly optionalPartialClassToResolvedClassProperty?:
      | $LazyOptionalObject<
          LazilyResolvedBlankNodeOrIriClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriClass
        >
      | LazilyResolvedBlankNodeOrIriClass
      | purify.Maybe<LazilyResolvedBlankNodeOrIriClass>;
    readonly optionalPartialClassToResolvedClassUnionProperty?:
      | $LazyOptionalObject<
          LazilyResolvedClassUnion.$Identifier,
          PartialClass,
          LazilyResolvedClassUnion
        >
      | LazilyResolvedClassUnion
      | purify.Maybe<LazilyResolvedClassUnion>;
    readonly optionalPartialClassUnionToResolvedClassUnionProperty?:
      | $LazyOptionalObject<
          LazilyResolvedClassUnion.$Identifier,
          PartialClassUnion,
          LazilyResolvedClassUnion
        >
      | LazilyResolvedClassUnion
      | purify.Maybe<LazilyResolvedClassUnion>;
    readonly requiredLazyToResolvedClassProperty:
      | $LazyRequiredObject<
          LazilyResolvedBlankNodeOrIriClass.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriClass
        >
      | LazilyResolvedBlankNodeOrIriClass;
    readonly requiredPartialClassToResolvedClassProperty:
      | $LazyRequiredObject<
          LazilyResolvedBlankNodeOrIriClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriClass
        >
      | LazilyResolvedBlankNodeOrIriClass;
    readonly setLazyToResolvedClassProperty?:
      | $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriClass.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriClass
        >
      | readonly LazilyResolvedBlankNodeOrIriClass[];
    readonly setPartialClassToResolvedClassProperty?:
      | $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriClass
        >
      | readonly LazilyResolvedBlankNodeOrIriClass[];
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    if (
      typeof parameters.optionalLazyToResolvedClassProperty === "object" &&
      parameters.optionalLazyToResolvedClassProperty instanceof
        $LazyOptionalObject
    ) {
      this.optionalLazyToResolvedClassProperty =
        parameters.optionalLazyToResolvedClassProperty;
    } else if (
      purify.Maybe.isMaybe(parameters.optionalLazyToResolvedClassProperty)
    ) {
      this.optionalLazyToResolvedClassProperty = new $LazyOptionalObject<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriClass
      >({
        partial: parameters.optionalLazyToResolvedClassProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          purify.Either.of(
            (
              parameters.optionalLazyToResolvedClassProperty as purify.Maybe<LazilyResolvedBlankNodeOrIriClass>
            ).unsafeCoerce(),
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedClassProperty === "object"
    ) {
      this.optionalLazyToResolvedClassProperty = new $LazyOptionalObject<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriClass
      >({
        partial: purify.Maybe.of(
          new $DefaultPartial(parameters.optionalLazyToResolvedClassProperty),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.optionalLazyToResolvedClassProperty as LazilyResolvedBlankNodeOrIriClass,
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedClassProperty === "undefined"
    ) {
      this.optionalLazyToResolvedClassProperty = new $LazyOptionalObject<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriClass
      >({
        partial: purify.Maybe.empty(),
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      this.optionalLazyToResolvedClassProperty =
        parameters.optionalLazyToResolvedClassProperty satisfies never;
    }

    if (
      typeof parameters.optionalLazyToResolvedClassUnionProperty === "object" &&
      parameters.optionalLazyToResolvedClassUnionProperty instanceof
        $LazyOptionalObject
    ) {
      this.optionalLazyToResolvedClassUnionProperty =
        parameters.optionalLazyToResolvedClassUnionProperty;
    } else if (
      purify.Maybe.isMaybe(parameters.optionalLazyToResolvedClassUnionProperty)
    ) {
      this.optionalLazyToResolvedClassUnionProperty = new $LazyOptionalObject<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >({
        partial: parameters.optionalLazyToResolvedClassUnionProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          purify.Either.of(
            (
              parameters.optionalLazyToResolvedClassUnionProperty as purify.Maybe<LazilyResolvedClassUnion>
            ).unsafeCoerce(),
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedClassUnionProperty === "object"
    ) {
      this.optionalLazyToResolvedClassUnionProperty = new $LazyOptionalObject<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >({
        partial: purify.Maybe.of(
          new $DefaultPartial(
            parameters.optionalLazyToResolvedClassUnionProperty,
          ),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.optionalLazyToResolvedClassUnionProperty as LazilyResolvedClassUnion,
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedClassUnionProperty === "undefined"
    ) {
      this.optionalLazyToResolvedClassUnionProperty = new $LazyOptionalObject<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >({
        partial: purify.Maybe.empty(),
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      this.optionalLazyToResolvedClassUnionProperty =
        parameters.optionalLazyToResolvedClassUnionProperty satisfies never;
    }

    if (
      typeof parameters.optionalLazyToResolvedIriClassProperty === "object" &&
      parameters.optionalLazyToResolvedIriClassProperty instanceof
        $LazyOptionalObject
    ) {
      this.optionalLazyToResolvedIriClassProperty =
        parameters.optionalLazyToResolvedIriClassProperty;
    } else if (
      purify.Maybe.isMaybe(parameters.optionalLazyToResolvedIriClassProperty)
    ) {
      this.optionalLazyToResolvedIriClassProperty = new $LazyOptionalObject<
        LazilyResolvedIriClass.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriClass
      >({
        partial: parameters.optionalLazyToResolvedIriClassProperty.map(
          (object) => new $NamedDefaultPartial(object),
        ),
        resolver: async () =>
          purify.Either.of(
            (
              parameters.optionalLazyToResolvedIriClassProperty as purify.Maybe<LazilyResolvedIriClass>
            ).unsafeCoerce(),
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedIriClassProperty === "object"
    ) {
      this.optionalLazyToResolvedIriClassProperty = new $LazyOptionalObject<
        LazilyResolvedIriClass.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriClass
      >({
        partial: purify.Maybe.of(
          new $NamedDefaultPartial(
            parameters.optionalLazyToResolvedIriClassProperty,
          ),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.optionalLazyToResolvedIriClassProperty as LazilyResolvedIriClass,
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedIriClassProperty === "undefined"
    ) {
      this.optionalLazyToResolvedIriClassProperty = new $LazyOptionalObject<
        LazilyResolvedIriClass.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriClass
      >({
        partial: purify.Maybe.empty(),
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      this.optionalLazyToResolvedIriClassProperty =
        parameters.optionalLazyToResolvedIriClassProperty satisfies never;
    }

    if (
      typeof parameters.optionalPartialClassToResolvedClassProperty ===
        "object" &&
      parameters.optionalPartialClassToResolvedClassProperty instanceof
        $LazyOptionalObject
    ) {
      this.optionalPartialClassToResolvedClassProperty =
        parameters.optionalPartialClassToResolvedClassProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalPartialClassToResolvedClassProperty,
      )
    ) {
      this.optionalPartialClassToResolvedClassProperty =
        new $LazyOptionalObject<
          LazilyResolvedBlankNodeOrIriClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriClass
        >({
          partial: parameters.optionalPartialClassToResolvedClassProperty.map(
            (object) => new PartialClass(object),
          ),
          resolver: async () =>
            purify.Either.of(
              (
                parameters.optionalPartialClassToResolvedClassProperty as purify.Maybe<LazilyResolvedBlankNodeOrIriClass>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalPartialClassToResolvedClassProperty === "object"
    ) {
      this.optionalPartialClassToResolvedClassProperty =
        new $LazyOptionalObject<
          LazilyResolvedBlankNodeOrIriClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriClass
        >({
          partial: purify.Maybe.of(
            new PartialClass(
              parameters.optionalPartialClassToResolvedClassProperty,
            ),
          ),
          resolver: async () =>
            purify.Either.of(
              parameters.optionalPartialClassToResolvedClassProperty as LazilyResolvedBlankNodeOrIriClass,
            ),
        });
    } else if (
      typeof parameters.optionalPartialClassToResolvedClassProperty ===
      "undefined"
    ) {
      this.optionalPartialClassToResolvedClassProperty =
        new $LazyOptionalObject<
          LazilyResolvedBlankNodeOrIriClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriClass
        >({
          partial: purify.Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      this.optionalPartialClassToResolvedClassProperty =
        parameters.optionalPartialClassToResolvedClassProperty satisfies never;
    }

    if (
      typeof parameters.optionalPartialClassToResolvedClassUnionProperty ===
        "object" &&
      parameters.optionalPartialClassToResolvedClassUnionProperty instanceof
        $LazyOptionalObject
    ) {
      this.optionalPartialClassToResolvedClassUnionProperty =
        parameters.optionalPartialClassToResolvedClassUnionProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalPartialClassToResolvedClassUnionProperty,
      )
    ) {
      this.optionalPartialClassToResolvedClassUnionProperty =
        new $LazyOptionalObject<
          LazilyResolvedClassUnion.$Identifier,
          PartialClass,
          LazilyResolvedClassUnion
        >({
          partial:
            parameters.optionalPartialClassToResolvedClassUnionProperty.map(
              (object) => new PartialClass(object),
            ),
          resolver: async () =>
            purify.Either.of(
              (
                parameters.optionalPartialClassToResolvedClassUnionProperty as purify.Maybe<LazilyResolvedClassUnion>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalPartialClassToResolvedClassUnionProperty ===
      "object"
    ) {
      this.optionalPartialClassToResolvedClassUnionProperty =
        new $LazyOptionalObject<
          LazilyResolvedClassUnion.$Identifier,
          PartialClass,
          LazilyResolvedClassUnion
        >({
          partial: purify.Maybe.of(
            new PartialClass(
              parameters.optionalPartialClassToResolvedClassUnionProperty,
            ),
          ),
          resolver: async () =>
            purify.Either.of(
              parameters.optionalPartialClassToResolvedClassUnionProperty as LazilyResolvedClassUnion,
            ),
        });
    } else if (
      typeof parameters.optionalPartialClassToResolvedClassUnionProperty ===
      "undefined"
    ) {
      this.optionalPartialClassToResolvedClassUnionProperty =
        new $LazyOptionalObject<
          LazilyResolvedClassUnion.$Identifier,
          PartialClass,
          LazilyResolvedClassUnion
        >({
          partial: purify.Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      this.optionalPartialClassToResolvedClassUnionProperty =
        parameters.optionalPartialClassToResolvedClassUnionProperty satisfies never;
    }

    if (
      typeof parameters.optionalPartialClassUnionToResolvedClassUnionProperty ===
        "object" &&
      parameters.optionalPartialClassUnionToResolvedClassUnionProperty instanceof
        $LazyOptionalObject
    ) {
      this.optionalPartialClassUnionToResolvedClassUnionProperty =
        parameters.optionalPartialClassUnionToResolvedClassUnionProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalPartialClassUnionToResolvedClassUnionProperty,
      )
    ) {
      this.optionalPartialClassUnionToResolvedClassUnionProperty =
        new $LazyOptionalObject<
          LazilyResolvedClassUnion.$Identifier,
          PartialClassUnion,
          LazilyResolvedClassUnion
        >({
          partial:
            parameters.optionalPartialClassUnionToResolvedClassUnionProperty.map(
              (object) => {
                switch (object.$type) {
                  case "LazilyResolvedClassUnionMember1":
                    return new PartialClassUnionMember1(object);
                  case "LazilyResolvedClassUnionMember2":
                    return new PartialClassUnionMember2(object);
                  default:
                    object satisfies never;
                    throw new Error("unrecognized type");
                }
              },
            ),
          resolver: async () =>
            purify.Either.of(
              (
                parameters.optionalPartialClassUnionToResolvedClassUnionProperty as purify.Maybe<LazilyResolvedClassUnion>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalPartialClassUnionToResolvedClassUnionProperty ===
      "object"
    ) {
      this.optionalPartialClassUnionToResolvedClassUnionProperty =
        new $LazyOptionalObject<
          LazilyResolvedClassUnion.$Identifier,
          PartialClassUnion,
          LazilyResolvedClassUnion
        >({
          partial: purify.Maybe.of(
            parameters.optionalPartialClassUnionToResolvedClassUnionProperty,
          ).map((object) => {
            switch (object.$type) {
              case "LazilyResolvedClassUnionMember1":
                return new PartialClassUnionMember1(object);
              case "LazilyResolvedClassUnionMember2":
                return new PartialClassUnionMember2(object);
              default:
                object satisfies never;
                throw new Error("unrecognized type");
            }
          }),
          resolver: async () =>
            purify.Either.of(
              parameters.optionalPartialClassUnionToResolvedClassUnionProperty as LazilyResolvedClassUnion,
            ),
        });
    } else if (
      typeof parameters.optionalPartialClassUnionToResolvedClassUnionProperty ===
      "undefined"
    ) {
      this.optionalPartialClassUnionToResolvedClassUnionProperty =
        new $LazyOptionalObject<
          LazilyResolvedClassUnion.$Identifier,
          PartialClassUnion,
          LazilyResolvedClassUnion
        >({
          partial: purify.Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      this.optionalPartialClassUnionToResolvedClassUnionProperty =
        parameters.optionalPartialClassUnionToResolvedClassUnionProperty satisfies never;
    }

    if (
      typeof parameters.requiredLazyToResolvedClassProperty === "object" &&
      parameters.requiredLazyToResolvedClassProperty instanceof
        $LazyRequiredObject
    ) {
      this.requiredLazyToResolvedClassProperty =
        parameters.requiredLazyToResolvedClassProperty;
    } else if (
      typeof parameters.requiredLazyToResolvedClassProperty === "object"
    ) {
      this.requiredLazyToResolvedClassProperty = new $LazyRequiredObject<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriClass
      >({
        partial: new $DefaultPartial(
          parameters.requiredLazyToResolvedClassProperty,
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.requiredLazyToResolvedClassProperty as LazilyResolvedBlankNodeOrIriClass,
          ),
      });
    } else {
      this.requiredLazyToResolvedClassProperty =
        parameters.requiredLazyToResolvedClassProperty satisfies never;
    }

    if (
      typeof parameters.requiredPartialClassToResolvedClassProperty ===
        "object" &&
      parameters.requiredPartialClassToResolvedClassProperty instanceof
        $LazyRequiredObject
    ) {
      this.requiredPartialClassToResolvedClassProperty =
        parameters.requiredPartialClassToResolvedClassProperty;
    } else if (
      typeof parameters.requiredPartialClassToResolvedClassProperty === "object"
    ) {
      this.requiredPartialClassToResolvedClassProperty =
        new $LazyRequiredObject<
          LazilyResolvedBlankNodeOrIriClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriClass
        >({
          partial: new PartialClass(
            parameters.requiredPartialClassToResolvedClassProperty,
          ),
          resolver: async () =>
            purify.Either.of(
              parameters.requiredPartialClassToResolvedClassProperty as LazilyResolvedBlankNodeOrIriClass,
            ),
        });
    } else {
      this.requiredPartialClassToResolvedClassProperty =
        parameters.requiredPartialClassToResolvedClassProperty satisfies never;
    }

    if (
      typeof parameters.setLazyToResolvedClassProperty === "object" &&
      parameters.setLazyToResolvedClassProperty instanceof $LazyObjectSet
    ) {
      this.setLazyToResolvedClassProperty =
        parameters.setLazyToResolvedClassProperty;
    } else if (typeof parameters.setLazyToResolvedClassProperty === "object") {
      this.setLazyToResolvedClassProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriClass
      >({
        partials: parameters.setLazyToResolvedClassProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.setLazyToResolvedClassProperty as readonly LazilyResolvedBlankNodeOrIriClass[],
          ),
      });
    } else if (
      typeof parameters.setLazyToResolvedClassProperty === "undefined"
    ) {
      this.setLazyToResolvedClassProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriClass
      >({
        partials: [],
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      this.setLazyToResolvedClassProperty =
        parameters.setLazyToResolvedClassProperty satisfies never;
    }

    if (
      typeof parameters.setPartialClassToResolvedClassProperty === "object" &&
      parameters.setPartialClassToResolvedClassProperty instanceof
        $LazyObjectSet
    ) {
      this.setPartialClassToResolvedClassProperty =
        parameters.setPartialClassToResolvedClassProperty;
    } else if (
      typeof parameters.setPartialClassToResolvedClassProperty === "object"
    ) {
      this.setPartialClassToResolvedClassProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriClass
      >({
        partials: parameters.setPartialClassToResolvedClassProperty.map(
          (object) => new PartialClass(object),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.setPartialClassToResolvedClassProperty as readonly LazilyResolvedBlankNodeOrIriClass[],
          ),
      });
    } else if (
      typeof parameters.setPartialClassToResolvedClassProperty === "undefined"
    ) {
      this.setPartialClassToResolvedClassProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriClass
      >({
        partials: [],
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      this.setPartialClassToResolvedClassProperty =
        parameters.setPartialClassToResolvedClassProperty satisfies never;
    }
  }

  get $identifier(): LazyPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: LazyPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          this.optionalLazyToResolvedClassProperty,
          other.optionalLazyToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalLazyToResolvedClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          this.optionalLazyToResolvedClassUnionProperty,
          other.optionalLazyToResolvedClassUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalLazyToResolvedClassUnionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          this.optionalLazyToResolvedIriClassProperty,
          other.optionalLazyToResolvedIriClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalLazyToResolvedIriClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          this.optionalPartialClassToResolvedClassProperty,
          other.optionalPartialClassToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalPartialClassToResolvedClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          this.optionalPartialClassToResolvedClassUnionProperty,
          other.optionalPartialClassToResolvedClassUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalPartialClassToResolvedClassUnionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, PartialClassUnion.$equals))(
            left.partial,
            right.partial,
          ))(
          this.optionalPartialClassUnionToResolvedClassUnionProperty,
          other.optionalPartialClassUnionToResolvedClassUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalPartialClassUnionToResolvedClassUnionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) => left.$equals(right))(left.partial, right.partial))(
          this.requiredLazyToResolvedClassProperty,
          other.requiredLazyToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "requiredLazyToResolvedClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) => left.$equals(right))(left.partial, right.partial))(
          this.requiredPartialClassToResolvedClassProperty,
          other.requiredPartialClassToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "requiredPartialClassToResolvedClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $arrayEquals(left, right, (left, right) => left.$equals(right)))(
            left.partials,
            right.partials,
          ))(
          this.setLazyToResolvedClassProperty,
          other.setLazyToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "setLazyToResolvedClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $arrayEquals(left, right, (left, right) => left.$equals(right)))(
            left.partials,
            right.partials,
          ))(
          this.setPartialClassToResolvedClassProperty,
          other.setPartialClassToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "setPartialClassToResolvedClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.optionalLazyToResolvedClassProperty.partial.ifJust((value1) => {
      value1.$hash(_hasher);
    });
    this.optionalLazyToResolvedClassUnionProperty.partial.ifJust((value1) => {
      value1.$hash(_hasher);
    });
    this.optionalLazyToResolvedIriClassProperty.partial.ifJust((value1) => {
      value1.$hash(_hasher);
    });
    this.optionalPartialClassToResolvedClassProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    this.optionalPartialClassToResolvedClassUnionProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    this.optionalPartialClassUnionToResolvedClassUnionProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    this.requiredLazyToResolvedClassProperty.partial.$hash(_hasher);
    this.requiredPartialClassToResolvedClassProperty.partial.$hash(_hasher);
    for (const item1 of this.setLazyToResolvedClassProperty.partials) {
      item1.$hash(_hasher);
    }

    for (const item1 of this.setPartialClassToResolvedClassProperty.partials) {
      item1.$hash(_hasher);
    }

    return _hasher;
  }

  $toJson(): LazyPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        optionalLazyToResolvedClassProperty:
          this.optionalLazyToResolvedClassProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalLazyToResolvedClassUnionProperty:
          this.optionalLazyToResolvedClassUnionProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalLazyToResolvedIriClassProperty:
          this.optionalLazyToResolvedIriClassProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalPartialClassToResolvedClassProperty:
          this.optionalPartialClassToResolvedClassProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalPartialClassToResolvedClassUnionProperty:
          this.optionalPartialClassToResolvedClassUnionProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalPartialClassUnionToResolvedClassUnionProperty:
          this.optionalPartialClassUnionToResolvedClassUnionProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        requiredLazyToResolvedClassProperty:
          this.requiredLazyToResolvedClassProperty.partial.$toJson(),
        requiredPartialClassToResolvedClassProperty:
          this.requiredPartialClassToResolvedClassProperty.partial.$toJson(),
        setLazyToResolvedClassProperty:
          this.setLazyToResolvedClassProperty.partials.map((item) =>
            item.$toJson(),
          ),
        setPartialClassToResolvedClassProperty:
          this.setPartialClassToResolvedClassProperty.partials.map((item) =>
            item.$toJson(),
          ),
      } satisfies LazyPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      LazyPropertiesClass.$properties.optionalLazyToResolvedClassProperty[
        "identifier"
      ],
      ...this.optionalLazyToResolvedClassProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesClass.$properties.optionalLazyToResolvedClassUnionProperty[
        "identifier"
      ],
      ...this.optionalLazyToResolvedClassUnionProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesClass.$properties.optionalLazyToResolvedIriClassProperty[
        "identifier"
      ],
      ...this.optionalLazyToResolvedIriClassProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesClass.$properties
        .optionalPartialClassToResolvedClassProperty["identifier"],
      ...this.optionalPartialClassToResolvedClassProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesClass.$properties
        .optionalPartialClassToResolvedClassUnionProperty["identifier"],
      ...this.optionalPartialClassToResolvedClassUnionProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesClass.$properties
        .optionalPartialClassUnionToResolvedClassUnionProperty["identifier"],
      ...this.optionalPartialClassUnionToResolvedClassUnionProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesClass.$properties.requiredLazyToResolvedClassProperty[
        "identifier"
      ],
      ...[
        this.requiredLazyToResolvedClassProperty.partial.$toRdf({
          mutateGraph: mutateGraph,
          resourceSet: resourceSet,
        }).identifier,
      ],
    );
    resource.add(
      LazyPropertiesClass.$properties
        .requiredPartialClassToResolvedClassProperty["identifier"],
      ...[
        this.requiredPartialClassToResolvedClassProperty.partial.$toRdf({
          mutateGraph: mutateGraph,
          resourceSet: resourceSet,
        }).identifier,
      ],
    );
    resource.add(
      LazyPropertiesClass.$properties.setLazyToResolvedClassProperty[
        "identifier"
      ],
      ...this.setLazyToResolvedClassProperty.partials.flatMap((item) => [
        item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
          .identifier,
      ]),
    );
    resource.add(
      LazyPropertiesClass.$properties.setPartialClassToResolvedClassProperty[
        "identifier"
      ],
      ...this.setPartialClassToResolvedClassProperty.partials.flatMap(
        (item) => [
          item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ],
      ),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LazyPropertiesClass {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazyPropertiesClass";
    readonly optionalLazyToResolvedClassProperty?: $DefaultPartial.$Json;
    readonly optionalLazyToResolvedClassUnionProperty?: $DefaultPartial.$Json;
    readonly optionalLazyToResolvedIriClassProperty?: $NamedDefaultPartial.$Json;
    readonly optionalPartialClassToResolvedClassProperty?: PartialClass.$Json;
    readonly optionalPartialClassToResolvedClassUnionProperty?: PartialClass.$Json;
    readonly optionalPartialClassUnionToResolvedClassUnionProperty?:
      | PartialClassUnionMember1.$Json
      | PartialClassUnionMember2.$Json;
    readonly requiredLazyToResolvedClassProperty: $DefaultPartial.$Json;
    readonly requiredPartialClassToResolvedClassProperty: PartialClass.$Json;
    readonly setLazyToResolvedClassProperty?: readonly $DefaultPartial.$Json[];
    readonly setPartialClassToResolvedClassProperty?: readonly PartialClass.$Json[];
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      optionalLazyToResolvedClassProperty: $LazyOptionalObject<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriClass
      >;
      optionalLazyToResolvedClassUnionProperty: $LazyOptionalObject<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >;
      optionalLazyToResolvedIriClassProperty: $LazyOptionalObject<
        LazilyResolvedIriClass.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriClass
      >;
      optionalPartialClassToResolvedClassProperty: $LazyOptionalObject<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriClass
      >;
      optionalPartialClassToResolvedClassUnionProperty: $LazyOptionalObject<
        LazilyResolvedClassUnion.$Identifier,
        PartialClass,
        LazilyResolvedClassUnion
      >;
      optionalPartialClassUnionToResolvedClassUnionProperty: $LazyOptionalObject<
        LazilyResolvedClassUnion.$Identifier,
        PartialClassUnion,
        LazilyResolvedClassUnion
      >;
      requiredLazyToResolvedClassProperty: $LazyRequiredObject<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriClass
      >;
      requiredPartialClassToResolvedClassProperty: $LazyRequiredObject<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriClass
      >;
      setLazyToResolvedClassProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriClass
      >;
      setPartialClassToResolvedClassProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriClass
      >;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const optionalLazyToResolvedClassProperty = new $LazyOptionalObject<
      LazilyResolvedBlankNodeOrIriClass.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriClass
    >({
      partial: purify.Maybe.fromNullable(
        $jsonObject["optionalLazyToResolvedClassProperty"],
      ).map((item) => $DefaultPartial.$fromJson(item).unsafeCoerce()),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const optionalLazyToResolvedClassUnionProperty = new $LazyOptionalObject<
      LazilyResolvedClassUnion.$Identifier,
      $DefaultPartial,
      LazilyResolvedClassUnion
    >({
      partial: purify.Maybe.fromNullable(
        $jsonObject["optionalLazyToResolvedClassUnionProperty"],
      ).map((item) => $DefaultPartial.$fromJson(item).unsafeCoerce()),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const optionalLazyToResolvedIriClassProperty = new $LazyOptionalObject<
      LazilyResolvedIriClass.$Identifier,
      $NamedDefaultPartial,
      LazilyResolvedIriClass
    >({
      partial: purify.Maybe.fromNullable(
        $jsonObject["optionalLazyToResolvedIriClassProperty"],
      ).map((item) => $NamedDefaultPartial.$fromJson(item).unsafeCoerce()),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const optionalPartialClassToResolvedClassProperty = new $LazyOptionalObject<
      LazilyResolvedBlankNodeOrIriClass.$Identifier,
      PartialClass,
      LazilyResolvedBlankNodeOrIriClass
    >({
      partial: purify.Maybe.fromNullable(
        $jsonObject["optionalPartialClassToResolvedClassProperty"],
      ).map((item) => PartialClass.$fromJson(item).unsafeCoerce()),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const optionalPartialClassToResolvedClassUnionProperty =
      new $LazyOptionalObject<
        LazilyResolvedClassUnion.$Identifier,
        PartialClass,
        LazilyResolvedClassUnion
      >({
        partial: purify.Maybe.fromNullable(
          $jsonObject["optionalPartialClassToResolvedClassUnionProperty"],
        ).map((item) => PartialClass.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            purify.Left(
              new Error(
                `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const optionalPartialClassUnionToResolvedClassUnionProperty =
      new $LazyOptionalObject<
        LazilyResolvedClassUnion.$Identifier,
        PartialClassUnion,
        LazilyResolvedClassUnion
      >({
        partial: purify.Maybe.fromNullable(
          $jsonObject["optionalPartialClassUnionToResolvedClassUnionProperty"],
        ).map((item) => PartialClassUnion.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            purify.Left(
              new Error(
                `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const requiredLazyToResolvedClassProperty = new $LazyRequiredObject<
      LazilyResolvedBlankNodeOrIriClass.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriClass
    >({
      partial: $DefaultPartial
        .$fromJson($jsonObject["requiredLazyToResolvedClassProperty"])
        .unsafeCoerce(),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const requiredPartialClassToResolvedClassProperty = new $LazyRequiredObject<
      LazilyResolvedBlankNodeOrIriClass.$Identifier,
      PartialClass,
      LazilyResolvedBlankNodeOrIriClass
    >({
      partial: PartialClass.$fromJson(
        $jsonObject["requiredPartialClassToResolvedClassProperty"],
      ).unsafeCoerce(),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const setLazyToResolvedClassProperty = new $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriClass.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriClass
    >({
      partials: $jsonObject["setLazyToResolvedClassProperty"].map((item) =>
        $DefaultPartial.$fromJson(item).unsafeCoerce(),
      ),
      resolver: () =>
        Promise.resolve(
          purify.Left(
            new Error("unable to resolve identifiers deserialized from JSON"),
          ),
        ),
    });
    const setPartialClassToResolvedClassProperty = new $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriClass.$Identifier,
      PartialClass,
      LazilyResolvedBlankNodeOrIriClass
    >({
      partials: $jsonObject["setPartialClassToResolvedClassProperty"].map(
        (item) => PartialClass.$fromJson(item).unsafeCoerce(),
      ),
      resolver: () =>
        Promise.resolve(
          purify.Left(
            new Error("unable to resolve identifiers deserialized from JSON"),
          ),
        ),
    });
    return purify.Either.of({
      $identifier,
      optionalLazyToResolvedClassProperty,
      optionalLazyToResolvedClassUnionProperty,
      optionalLazyToResolvedIriClassProperty,
      optionalPartialClassToResolvedClassProperty,
      optionalPartialClassToResolvedClassUnionProperty,
      optionalPartialClassUnionToResolvedClassUnionProperty,
      requiredLazyToResolvedClassProperty,
      requiredPartialClassToResolvedClassProperty,
      setLazyToResolvedClassProperty,
      setPartialClassToResolvedClassProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazyPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new LazyPropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazyPropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedClassProperty`,
        }),
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedClassUnionProperty`,
        }),
        $NamedDefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedIriClassProperty`,
        }),
        PartialClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalPartialClassToResolvedClassProperty`,
        }),
        PartialClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalPartialClassToResolvedClassUnionProperty`,
        }),
        {
          scope: `${scopePrefix}/properties/optionalPartialClassUnionToResolvedClassUnionProperty`,
          type: "Control",
        },
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/requiredLazyToResolvedClassProperty`,
        }),
        PartialClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/requiredPartialClassToResolvedClassProperty`,
        }),
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/setLazyToResolvedClassProperty`,
        }),
        PartialClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/setPartialClassToResolvedClassProperty`,
        }),
      ],
      label: "LazyPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazyPropertiesClass"),
      optionalLazyToResolvedClassProperty: $DefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalLazyToResolvedClassUnionProperty: $DefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalLazyToResolvedIriClassProperty: $NamedDefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalPartialClassToResolvedClassProperty:
        PartialClass.$jsonZodSchema().optional(),
      optionalPartialClassToResolvedClassUnionProperty:
        PartialClass.$jsonZodSchema().optional(),
      optionalPartialClassUnionToResolvedClassUnionProperty:
        PartialClassUnion.$jsonZodSchema().optional(),
      requiredLazyToResolvedClassProperty: $DefaultPartial.$jsonZodSchema(),
      requiredPartialClassToResolvedClassProperty:
        PartialClass.$jsonZodSchema(),
      setLazyToResolvedClassProperty: $DefaultPartial
        .$jsonZodSchema()
        .array()
        .default(() => []),
      setPartialClassToResolvedClassProperty: PartialClass.$jsonZodSchema()
        .array()
        .default(() => []),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazyPropertiesClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazyPropertiesClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new LazyPropertiesClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      optionalLazyToResolvedClassProperty: $LazyOptionalObject<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriClass
      >;
      optionalLazyToResolvedClassUnionProperty: $LazyOptionalObject<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >;
      optionalLazyToResolvedIriClassProperty: $LazyOptionalObject<
        LazilyResolvedIriClass.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriClass
      >;
      optionalPartialClassToResolvedClassProperty: $LazyOptionalObject<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriClass
      >;
      optionalPartialClassToResolvedClassUnionProperty: $LazyOptionalObject<
        LazilyResolvedClassUnion.$Identifier,
        PartialClass,
        LazilyResolvedClassUnion
      >;
      optionalPartialClassUnionToResolvedClassUnionProperty: $LazyOptionalObject<
        LazilyResolvedClassUnion.$Identifier,
        PartialClassUnion,
        LazilyResolvedClassUnion
      >;
      requiredLazyToResolvedClassProperty: $LazyRequiredObject<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriClass
      >;
      requiredPartialClassToResolvedClassProperty: $LazyRequiredObject<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriClass
      >;
      setLazyToResolvedClassProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriClass
      >;
      setPartialClassToResolvedClassProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriClass
      >;
    }
  > {
    const $identifier: LazyPropertiesClass.$Identifier = $resource.identifier;
    const _optionalLazyToResolvedClassPropertyEither: purify.Either<
      Error,
      $LazyOptionalObject<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriClass
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.optionalLazyToResolvedClassProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            $DefaultPartial.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<$DefaultPartial>
            >({
              object: purify.Maybe.empty(),
              predicate:
                LazyPropertiesClass.$properties
                  .optionalLazyToResolvedClassProperty["identifier"],
              subject: $resource,
            }),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyOptionalObject<
              LazilyResolvedBlankNodeOrIriClass.$Identifier,
              $DefaultPartial,
              LazilyResolvedBlankNodeOrIriClass
            >({
              partial,
              resolver: (identifier) =>
                $objectSet.lazilyResolvedBlankNodeOrIriClass(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_optionalLazyToResolvedClassPropertyEither.isLeft()) {
      return _optionalLazyToResolvedClassPropertyEither;
    }

    const optionalLazyToResolvedClassProperty =
      _optionalLazyToResolvedClassPropertyEither.unsafeCoerce();
    const _optionalLazyToResolvedClassUnionPropertyEither: purify.Either<
      Error,
      $LazyOptionalObject<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.optionalLazyToResolvedClassUnionProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            $DefaultPartial.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<$DefaultPartial>
            >({
              object: purify.Maybe.empty(),
              predicate:
                LazyPropertiesClass.$properties
                  .optionalLazyToResolvedClassUnionProperty["identifier"],
              subject: $resource,
            }),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyOptionalObject<
              LazilyResolvedClassUnion.$Identifier,
              $DefaultPartial,
              LazilyResolvedClassUnion
            >({
              partial,
              resolver: (identifier) =>
                $objectSet.lazilyResolvedClassUnion(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_optionalLazyToResolvedClassUnionPropertyEither.isLeft()) {
      return _optionalLazyToResolvedClassUnionPropertyEither;
    }

    const optionalLazyToResolvedClassUnionProperty =
      _optionalLazyToResolvedClassUnionPropertyEither.unsafeCoerce();
    const _optionalLazyToResolvedIriClassPropertyEither: purify.Either<
      Error,
      $LazyOptionalObject<
        LazilyResolvedIriClass.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriClass
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.optionalLazyToResolvedIriClassProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            $NamedDefaultPartial.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<$NamedDefaultPartial>
            >({
              object: purify.Maybe.empty(),
              predicate:
                LazyPropertiesClass.$properties
                  .optionalLazyToResolvedIriClassProperty["identifier"],
              subject: $resource,
            }),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyOptionalObject<
              LazilyResolvedIriClass.$Identifier,
              $NamedDefaultPartial,
              LazilyResolvedIriClass
            >({
              partial,
              resolver: (identifier) =>
                $objectSet.lazilyResolvedIriClass(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_optionalLazyToResolvedIriClassPropertyEither.isLeft()) {
      return _optionalLazyToResolvedIriClassPropertyEither;
    }

    const optionalLazyToResolvedIriClassProperty =
      _optionalLazyToResolvedIriClassPropertyEither.unsafeCoerce();
    const _optionalPartialClassToResolvedClassPropertyEither: purify.Either<
      Error,
      $LazyOptionalObject<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriClass
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.optionalPartialClassToResolvedClassProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            PartialClass.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<PartialClass>>(
              {
                object: purify.Maybe.empty(),
                predicate:
                  LazyPropertiesClass.$properties
                    .optionalPartialClassToResolvedClassProperty["identifier"],
                subject: $resource,
              },
            ),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyOptionalObject<
              LazilyResolvedBlankNodeOrIriClass.$Identifier,
              PartialClass,
              LazilyResolvedBlankNodeOrIriClass
            >({
              partial,
              resolver: (identifier) =>
                $objectSet.lazilyResolvedBlankNodeOrIriClass(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_optionalPartialClassToResolvedClassPropertyEither.isLeft()) {
      return _optionalPartialClassToResolvedClassPropertyEither;
    }

    const optionalPartialClassToResolvedClassProperty =
      _optionalPartialClassToResolvedClassPropertyEither.unsafeCoerce();
    const _optionalPartialClassToResolvedClassUnionPropertyEither: purify.Either<
      Error,
      $LazyOptionalObject<
        LazilyResolvedClassUnion.$Identifier,
        PartialClass,
        LazilyResolvedClassUnion
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.optionalPartialClassToResolvedClassUnionProperty[
          "identifier"
        ],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            PartialClass.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<PartialClass>>(
              {
                object: purify.Maybe.empty(),
                predicate:
                  LazyPropertiesClass.$properties
                    .optionalPartialClassToResolvedClassUnionProperty[
                    "identifier"
                  ],
                subject: $resource,
              },
            ),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyOptionalObject<
              LazilyResolvedClassUnion.$Identifier,
              PartialClass,
              LazilyResolvedClassUnion
            >({
              partial,
              resolver: (identifier) =>
                $objectSet.lazilyResolvedClassUnion(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_optionalPartialClassToResolvedClassUnionPropertyEither.isLeft()) {
      return _optionalPartialClassToResolvedClassUnionPropertyEither;
    }

    const optionalPartialClassToResolvedClassUnionProperty =
      _optionalPartialClassToResolvedClassUnionPropertyEither.unsafeCoerce();
    const _optionalPartialClassUnionToResolvedClassUnionPropertyEither: purify.Either<
      Error,
      $LazyOptionalObject<
        LazilyResolvedClassUnion.$Identifier,
        PartialClassUnion,
        LazilyResolvedClassUnion
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.optionalPartialClassUnionToResolvedClassUnionProperty[
          "identifier"
        ],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            PartialClassUnion.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: false,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<PartialClassUnion>
            >({
              object: purify.Maybe.empty(),
              predicate:
                LazyPropertiesClass.$properties
                  .optionalPartialClassUnionToResolvedClassUnionProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyOptionalObject<
              LazilyResolvedClassUnion.$Identifier,
              PartialClassUnion,
              LazilyResolvedClassUnion
            >({
              partial,
              resolver: (identifier) =>
                $objectSet.lazilyResolvedClassUnion(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_optionalPartialClassUnionToResolvedClassUnionPropertyEither.isLeft()) {
      return _optionalPartialClassUnionToResolvedClassUnionPropertyEither;
    }

    const optionalPartialClassUnionToResolvedClassUnionProperty =
      _optionalPartialClassUnionToResolvedClassUnionPropertyEither.unsafeCoerce();
    const _requiredLazyToResolvedClassPropertyEither: purify.Either<
      Error,
      $LazyRequiredObject<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriClass
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.requiredLazyToResolvedClassProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            $DefaultPartial.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyRequiredObject<
              LazilyResolvedBlankNodeOrIriClass.$Identifier,
              $DefaultPartial,
              LazilyResolvedBlankNodeOrIriClass
            >({
              partial,
              resolver: (identifier) =>
                $objectSet.lazilyResolvedBlankNodeOrIriClass(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_requiredLazyToResolvedClassPropertyEither.isLeft()) {
      return _requiredLazyToResolvedClassPropertyEither;
    }

    const requiredLazyToResolvedClassProperty =
      _requiredLazyToResolvedClassPropertyEither.unsafeCoerce();
    const _requiredPartialClassToResolvedClassPropertyEither: purify.Either<
      Error,
      $LazyRequiredObject<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriClass
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.requiredPartialClassToResolvedClassProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            PartialClass.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyRequiredObject<
              LazilyResolvedBlankNodeOrIriClass.$Identifier,
              PartialClass,
              LazilyResolvedBlankNodeOrIriClass
            >({
              partial,
              resolver: (identifier) =>
                $objectSet.lazilyResolvedBlankNodeOrIriClass(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_requiredPartialClassToResolvedClassPropertyEither.isLeft()) {
      return _requiredPartialClassToResolvedClassPropertyEither;
    }

    const requiredPartialClassToResolvedClassProperty =
      _requiredPartialClassToResolvedClassPropertyEither.unsafeCoerce();
    const _setLazyToResolvedClassPropertyEither: purify.Either<
      Error,
      $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriClass
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.setLazyToResolvedClassProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            $DefaultPartial.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) => values.toArray())
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          object: valuesArray,
          predicate:
            LazyPropertiesClass.$properties.setLazyToResolvedClassProperty[
              "identifier"
            ],
          subject: $resource,
        }),
      )
      .map((values) =>
        values.map(
          (partials) =>
            new $LazyObjectSet<
              LazilyResolvedBlankNodeOrIriClass.$Identifier,
              $DefaultPartial,
              LazilyResolvedBlankNodeOrIriClass
            >({
              partials,
              resolver: (identifiers) =>
                $objectSet.lazilyResolvedBlankNodeOrIriClasses({
                  where: { identifiers, type: "identifiers" },
                }),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_setLazyToResolvedClassPropertyEither.isLeft()) {
      return _setLazyToResolvedClassPropertyEither;
    }

    const setLazyToResolvedClassProperty =
      _setLazyToResolvedClassPropertyEither.unsafeCoerce();
    const _setPartialClassToResolvedClassPropertyEither: purify.Either<
      Error,
      $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriClass
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.setPartialClassToResolvedClassProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            PartialClass.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) => values.toArray())
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          object: valuesArray,
          predicate:
            LazyPropertiesClass.$properties
              .setPartialClassToResolvedClassProperty["identifier"],
          subject: $resource,
        }),
      )
      .map((values) =>
        values.map(
          (partials) =>
            new $LazyObjectSet<
              LazilyResolvedBlankNodeOrIriClass.$Identifier,
              PartialClass,
              LazilyResolvedBlankNodeOrIriClass
            >({
              partials,
              resolver: (identifiers) =>
                $objectSet.lazilyResolvedBlankNodeOrIriClasses({
                  where: { identifiers, type: "identifiers" },
                }),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_setPartialClassToResolvedClassPropertyEither.isLeft()) {
      return _setPartialClassToResolvedClassPropertyEither;
    }

    const setPartialClassToResolvedClassProperty =
      _setPartialClassToResolvedClassPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      optionalLazyToResolvedClassProperty,
      optionalLazyToResolvedClassUnionProperty,
      optionalLazyToResolvedIriClassProperty,
      optionalPartialClassToResolvedClassProperty,
      optionalPartialClassToResolvedClassUnionProperty,
      optionalPartialClassUnionToResolvedClassUnionProperty,
      requiredLazyToResolvedClassProperty,
      requiredPartialClassToResolvedClassProperty,
      setLazyToResolvedClassProperty,
      setPartialClassToResolvedClassProperty,
    });
  }

  export const $properties = {
    optionalLazyToResolvedClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalLazyToResolvedClassProperty",
      ),
    },
    optionalLazyToResolvedClassUnionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalLazyToResolvedClassUnionProperty",
      ),
    },
    optionalLazyToResolvedIriClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalLazyToResolvedIriClassProperty",
      ),
    },
    optionalPartialClassToResolvedClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalPartialClassToResolvedClassProperty",
      ),
    },
    optionalPartialClassToResolvedClassUnionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalPartialClassToResolvedClassUnionProperty",
      ),
    },
    optionalPartialClassUnionToResolvedClassUnionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalPartialClassUnionToResolvedClassUnionProperty",
      ),
    },
    requiredLazyToResolvedClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/requiredLazyToResolvedClassProperty",
      ),
    },
    requiredPartialClassToResolvedClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/requiredPartialClassToResolvedClassProperty",
      ),
    },
    setLazyToResolvedClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/setLazyToResolvedClassProperty",
      ),
    },
    setPartialClassToResolvedClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/setPartialClassToResolvedClassProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazyPropertiesClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        LazyPropertiesClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazyPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("lazyPropertiesClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass");
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}OptionalLazyToResolvedClassProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties.optionalLazyToResolvedClassProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${variablePrefix}OptionalLazyToResolvedClassProperty`,
        ),
        variablePrefix: `${variablePrefix}OptionalLazyToResolvedClassProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}OptionalLazyToResolvedClassUnionProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties
          .optionalLazyToResolvedClassUnionProperty["identifier"],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${variablePrefix}OptionalLazyToResolvedClassUnionProperty`,
        ),
        variablePrefix: `${variablePrefix}OptionalLazyToResolvedClassUnionProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}OptionalLazyToResolvedIriClassProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties.optionalLazyToResolvedIriClassProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...$NamedDefaultPartial.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${variablePrefix}OptionalLazyToResolvedIriClassProperty`,
        ),
        variablePrefix: `${variablePrefix}OptionalLazyToResolvedIriClassProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}OptionalPartialClassToResolvedClassProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties
          .optionalPartialClassToResolvedClassProperty["identifier"],
      subject,
    });
    triples.push(
      ...PartialClass.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${variablePrefix}OptionalPartialClassToResolvedClassProperty`,
        ),
        variablePrefix: `${variablePrefix}OptionalPartialClassToResolvedClassProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}OptionalPartialClassToResolvedClassUnionProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties
          .optionalPartialClassToResolvedClassUnionProperty["identifier"],
      subject,
    });
    triples.push(
      ...PartialClass.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${variablePrefix}OptionalPartialClassToResolvedClassUnionProperty`,
        ),
        variablePrefix: `${variablePrefix}OptionalPartialClassToResolvedClassUnionProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}OptionalPartialClassUnionToResolvedClassUnionProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties
          .optionalPartialClassUnionToResolvedClassUnionProperty["identifier"],
      subject,
    });
    triples.push(
      ...PartialClassUnion.$sparqlConstructTemplateTriples({
        subject: dataFactory.variable!(
          `${variablePrefix}OptionalPartialClassUnionToResolvedClassUnionProperty`,
        ),
        variablePrefix: `${variablePrefix}OptionalPartialClassUnionToResolvedClassUnionProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}RequiredLazyToResolvedClassProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties.requiredLazyToResolvedClassProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${variablePrefix}RequiredLazyToResolvedClassProperty`,
        ),
        variablePrefix: `${variablePrefix}RequiredLazyToResolvedClassProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}RequiredPartialClassToResolvedClassProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties
          .requiredPartialClassToResolvedClassProperty["identifier"],
      subject,
    });
    triples.push(
      ...PartialClass.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${variablePrefix}RequiredPartialClassToResolvedClassProperty`,
        ),
        variablePrefix: `${variablePrefix}RequiredPartialClassToResolvedClassProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}SetLazyToResolvedClassProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties.setLazyToResolvedClassProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${variablePrefix}SetLazyToResolvedClassProperty`,
        ),
        variablePrefix: `${variablePrefix}SetLazyToResolvedClassProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}SetPartialClassToResolvedClassProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties.setPartialClassToResolvedClassProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...PartialClass.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${variablePrefix}SetPartialClassToResolvedClassProperty`,
        ),
        variablePrefix: `${variablePrefix}SetPartialClassToResolvedClassProperty`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("lazyPropertiesClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}OptionalLazyToResolvedClassProperty`,
                ),
                predicate:
                  LazyPropertiesClass.$properties
                    .optionalLazyToResolvedClassProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...$DefaultPartial.$sparqlWherePatterns({
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${variablePrefix}OptionalLazyToResolvedClassProperty`,
            ),
            variablePrefix: `${variablePrefix}OptionalLazyToResolvedClassProperty`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}OptionalLazyToResolvedClassUnionProperty`,
                ),
                predicate:
                  LazyPropertiesClass.$properties
                    .optionalLazyToResolvedClassUnionProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...$DefaultPartial.$sparqlWherePatterns({
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${variablePrefix}OptionalLazyToResolvedClassUnionProperty`,
            ),
            variablePrefix: `${variablePrefix}OptionalLazyToResolvedClassUnionProperty`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}OptionalLazyToResolvedIriClassProperty`,
                ),
                predicate:
                  LazyPropertiesClass.$properties
                    .optionalLazyToResolvedIriClassProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...$NamedDefaultPartial.$sparqlWherePatterns({
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${variablePrefix}OptionalLazyToResolvedIriClassProperty`,
            ),
            variablePrefix: `${variablePrefix}OptionalLazyToResolvedIriClassProperty`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}OptionalPartialClassToResolvedClassProperty`,
                ),
                predicate:
                  LazyPropertiesClass.$properties
                    .optionalPartialClassToResolvedClassProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...PartialClass.$sparqlWherePatterns({
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${variablePrefix}OptionalPartialClassToResolvedClassProperty`,
            ),
            variablePrefix: `${variablePrefix}OptionalPartialClassToResolvedClassProperty`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}OptionalPartialClassToResolvedClassUnionProperty`,
                ),
                predicate:
                  LazyPropertiesClass.$properties
                    .optionalPartialClassToResolvedClassUnionProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
          ...PartialClass.$sparqlWherePatterns({
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${variablePrefix}OptionalPartialClassToResolvedClassUnionProperty`,
            ),
            variablePrefix: `${variablePrefix}OptionalPartialClassToResolvedClassUnionProperty`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}OptionalPartialClassUnionToResolvedClassUnionProperty`,
                ),
                predicate:
                  LazyPropertiesClass.$properties
                    .optionalPartialClassUnionToResolvedClassUnionProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
          ...PartialClassUnion.$sparqlWherePatterns({
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${variablePrefix}OptionalPartialClassUnionToResolvedClassUnionProperty`,
            ),
            variablePrefix: `${variablePrefix}OptionalPartialClassUnionToResolvedClassUnionProperty`,
          }),
        ],
        type: "optional",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}RequiredLazyToResolvedClassProperty`,
            ),
            predicate:
              LazyPropertiesClass.$properties
                .requiredLazyToResolvedClassProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...$DefaultPartial.$sparqlWherePatterns({
        ignoreRdfType: true,
        preferredLanguages: parameters?.preferredLanguages,
        subject: dataFactory.variable!(
          `${variablePrefix}RequiredLazyToResolvedClassProperty`,
        ),
        variablePrefix: `${variablePrefix}RequiredLazyToResolvedClassProperty`,
      }),
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}RequiredPartialClassToResolvedClassProperty`,
            ),
            predicate:
              LazyPropertiesClass.$properties
                .requiredPartialClassToResolvedClassProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...PartialClass.$sparqlWherePatterns({
        ignoreRdfType: true,
        preferredLanguages: parameters?.preferredLanguages,
        subject: dataFactory.variable!(
          `${variablePrefix}RequiredPartialClassToResolvedClassProperty`,
        ),
        variablePrefix: `${variablePrefix}RequiredPartialClassToResolvedClassProperty`,
      }),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}SetLazyToResolvedClassProperty`,
                ),
                predicate:
                  LazyPropertiesClass.$properties
                    .setLazyToResolvedClassProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...$DefaultPartial.$sparqlWherePatterns({
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${variablePrefix}SetLazyToResolvedClassProperty`,
            ),
            variablePrefix: `${variablePrefix}SetLazyToResolvedClassProperty`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}SetPartialClassToResolvedClassProperty`,
                ),
                predicate:
                  LazyPropertiesClass.$properties
                    .setPartialClassToResolvedClassProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...PartialClass.$sparqlWherePatterns({
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${variablePrefix}SetPartialClassToResolvedClassProperty`,
            ),
            variablePrefix: `${variablePrefix}SetPartialClassToResolvedClassProperty`,
          }),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Node shape resolved by LazyPropertiesInterface
 */
export interface LazilyResolvedIriInterface {
  readonly $identifier: LazilyResolvedIriInterface.$Identifier;
  readonly $type: "LazilyResolvedIriInterface";
  readonly lazilyResolvedStringProperty: string;
}

export namespace LazilyResolvedIriInterface {
  export function $create(parameters: {
    readonly $identifier: rdfjs.NamedNode | string;
    readonly lazilyResolvedStringProperty: string;
  }): LazilyResolvedIriInterface {
    let $identifier: LazilyResolvedIriInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "LazilyResolvedIriInterface" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: LazilyResolvedIriInterface,
    right: LazilyResolvedIriInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedIriInterface";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.NamedNode;
      $type: "LazilyResolvedIriInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const $type = "LazilyResolvedIriInterface" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedIriInterface> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedIriInterface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedIriInterface",
      type: "Group",
    };
  }

  export function $toJson(
    _lazilyResolvedIriInterface: LazilyResolvedIriInterface,
  ): LazilyResolvedIriInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": _lazilyResolvedIriInterface.$identifier.value,
        $type: _lazilyResolvedIriInterface.$type,
        lazilyResolvedStringProperty:
          _lazilyResolvedIriInterface.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedIriInterface.$Json),
    );
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedIriInterface"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedIriInterface: LazilyResolvedIriInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_lazilyResolvedIriInterface.$identifier.value);
    _hasher.update(_lazilyResolvedIriInterface.$type);
    LazilyResolvedIriInterface.$hashShaclProperties(
      _lazilyResolvedIriInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedIriInterface: LazilyResolvedIriInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_lazilyResolvedIriInterface.lazilyResolvedStringProperty);
    return _hasher;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedIriInterface> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedIriInterface.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.NamedNode;
      $type: "LazilyResolvedIriInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    if ($resource.identifier.termType !== "NamedNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedValueError({
          actualValue: $resource.identifier,
          expectedValueType: "(rdfjs.NamedNode)",
          focusResource: $resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: LazilyResolvedIriInterface.$Identifier =
      $resource.identifier;
    const $type = "LazilyResolvedIriInterface" as const;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    LazilyResolvedIriInterface.$properties
                      .lazilyResolvedStringProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $toRdf(
    _lazilyResolvedIriInterface: LazilyResolvedIriInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(
      _lazilyResolvedIriInterface.$identifier,
      { mutateGraph },
    );
    resource.add(
      LazilyResolvedIriInterface.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[_lazilyResolvedIriInterface.lazilyResolvedStringProperty],
    );
    return resource;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedIriInterface.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        LazilyResolvedIriInterface.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedIriInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedIriInterface");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "lazilyResolvedIriInterface");
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedIriInterface.$properties.lazilyResolvedStringProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedIriInterface");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "lazilyResolvedIriInterface");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedIriInterface.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}LazilyResolvedStringProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Node shape resolved by LazyPropertiesClass
 */
export class LazilyResolvedIriClass {
  readonly $identifier: LazilyResolvedIriClass.$Identifier;
  readonly $type = "LazilyResolvedIriClass";
  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier: rdfjs.NamedNode | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this.$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this.$identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      this.$identifier = parameters.$identifier satisfies never;
    }

    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  $equals(other: LazilyResolvedIriClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): LazilyResolvedIriClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedIriClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      LazilyResolvedIriClass.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[this.lazilyResolvedStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LazilyResolvedIriClass {
  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedIriClass";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.NamedNode; lazilyResolvedStringProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedIriClass> {
    return $propertiesFromJson(json).map(
      (properties) => new LazilyResolvedIriClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedIriClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedIriClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedIriClass"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedIriClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedIriClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new LazilyResolvedIriClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.NamedNode; lazilyResolvedStringProperty: string }
  > {
    if ($resource.identifier.termType !== "NamedNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedValueError({
          actualValue: $resource.identifier,
          expectedValueType: "(rdfjs.NamedNode)",
          focusResource: $resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: LazilyResolvedIriClass.$Identifier =
      $resource.identifier;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    LazilyResolvedIriClass.$properties
                      .lazilyResolvedStringProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedIriClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        LazilyResolvedIriClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedIriClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("lazilyResolvedIriClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "lazilyResolvedIriClass");
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedIriClass.$properties.lazilyResolvedStringProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("lazilyResolvedIriClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "lazilyResolvedIriClass");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedIriClass.$properties.lazilyResolvedStringProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}LazilyResolvedStringProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export interface LazilyResolvedInterfaceUnionMember2 {
  readonly $identifier: LazilyResolvedInterfaceUnionMember2.$Identifier;
  readonly $type: "LazilyResolvedInterfaceUnionMember2";
  readonly lazilyResolvedStringProperty: string;
}

export namespace LazilyResolvedInterfaceUnionMember2 {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): LazilyResolvedInterfaceUnionMember2 {
    let $identifier: LazilyResolvedInterfaceUnionMember2.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "LazilyResolvedInterfaceUnionMember2" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: LazilyResolvedInterfaceUnionMember2,
    right: LazilyResolvedInterfaceUnionMember2,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedInterfaceUnionMember2",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedInterfaceUnionMember2";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazilyResolvedInterfaceUnionMember2";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "LazilyResolvedInterfaceUnionMember2" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedInterfaceUnionMember2> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedInterfaceUnionMember2" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedInterfaceUnionMember2",
      type: "Group",
    };
  }

  export function $toJson(
    _lazilyResolvedInterfaceUnionMember2: LazilyResolvedInterfaceUnionMember2,
  ): LazilyResolvedInterfaceUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _lazilyResolvedInterfaceUnionMember2.$identifier.termType ===
          "BlankNode"
            ? `_:${_lazilyResolvedInterfaceUnionMember2.$identifier.value}`
            : _lazilyResolvedInterfaceUnionMember2.$identifier.value,
        $type: _lazilyResolvedInterfaceUnionMember2.$type,
        lazilyResolvedStringProperty:
          _lazilyResolvedInterfaceUnionMember2.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedInterfaceUnionMember2.$Json),
    );
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedInterfaceUnionMember2"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedInterfaceUnionMember2: LazilyResolvedInterfaceUnionMember2,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_lazilyResolvedInterfaceUnionMember2.$identifier.value);
    _hasher.update(_lazilyResolvedInterfaceUnionMember2.$type);
    LazilyResolvedInterfaceUnionMember2.$hashShaclProperties(
      _lazilyResolvedInterfaceUnionMember2,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedInterfaceUnionMember2: LazilyResolvedInterfaceUnionMember2,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _lazilyResolvedInterfaceUnionMember2.lazilyResolvedStringProperty,
    );
    return _hasher;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedInterfaceUnionMember2> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedInterfaceUnionMember2.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazilyResolvedInterfaceUnionMember2";
      lazilyResolvedStringProperty: string;
    }
  > {
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/LazilyResolvedInterfaceUnionMember2":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $resource.isInstanceOf(
              LazilyResolvedInterfaceUnionMember2.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedInterfaceUnionMember2)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: LazilyResolvedInterfaceUnionMember2.$Identifier =
      $resource.identifier;
    const $type = "LazilyResolvedInterfaceUnionMember2" as const;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    LazilyResolvedInterfaceUnionMember2.$properties
                      .lazilyResolvedStringProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $toRdf(
    _lazilyResolvedInterfaceUnionMember2: LazilyResolvedInterfaceUnionMember2,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _lazilyResolvedInterfaceUnionMember2.$identifier,
      { mutateGraph },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/LazilyResolvedInterfaceUnionMember2",
        ),
      );
    }

    resource.add(
      LazilyResolvedInterfaceUnionMember2.$properties
        .lazilyResolvedStringProperty["identifier"],
      ...[_lazilyResolvedInterfaceUnionMember2.lazilyResolvedStringProperty],
    );
    return resource;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedInterfaceUnionMember2.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        LazilyResolvedInterfaceUnionMember2.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedInterfaceUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedInterfaceUnionMember2");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "lazilyResolvedInterfaceUnionMember2");
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedInterfaceUnionMember2.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedInterfaceUnionMember2");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "lazilyResolvedInterfaceUnionMember2");
    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedInterfaceUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedInterfaceUnionMember2.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}LazilyResolvedStringProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export interface LazilyResolvedInterfaceUnionMember1 {
  readonly $identifier: LazilyResolvedInterfaceUnionMember1.$Identifier;
  readonly $type: "LazilyResolvedInterfaceUnionMember1";
  readonly lazilyResolvedStringProperty: string;
}

export namespace LazilyResolvedInterfaceUnionMember1 {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): LazilyResolvedInterfaceUnionMember1 {
    let $identifier: LazilyResolvedInterfaceUnionMember1.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "LazilyResolvedInterfaceUnionMember1" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: LazilyResolvedInterfaceUnionMember1,
    right: LazilyResolvedInterfaceUnionMember1,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedInterfaceUnionMember1",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedInterfaceUnionMember1";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazilyResolvedInterfaceUnionMember1";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "LazilyResolvedInterfaceUnionMember1" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedInterfaceUnionMember1> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedInterfaceUnionMember1" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedInterfaceUnionMember1",
      type: "Group",
    };
  }

  export function $toJson(
    _lazilyResolvedInterfaceUnionMember1: LazilyResolvedInterfaceUnionMember1,
  ): LazilyResolvedInterfaceUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _lazilyResolvedInterfaceUnionMember1.$identifier.termType ===
          "BlankNode"
            ? `_:${_lazilyResolvedInterfaceUnionMember1.$identifier.value}`
            : _lazilyResolvedInterfaceUnionMember1.$identifier.value,
        $type: _lazilyResolvedInterfaceUnionMember1.$type,
        lazilyResolvedStringProperty:
          _lazilyResolvedInterfaceUnionMember1.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedInterfaceUnionMember1.$Json),
    );
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedInterfaceUnionMember1"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedInterfaceUnionMember1: LazilyResolvedInterfaceUnionMember1,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_lazilyResolvedInterfaceUnionMember1.$identifier.value);
    _hasher.update(_lazilyResolvedInterfaceUnionMember1.$type);
    LazilyResolvedInterfaceUnionMember1.$hashShaclProperties(
      _lazilyResolvedInterfaceUnionMember1,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedInterfaceUnionMember1: LazilyResolvedInterfaceUnionMember1,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _lazilyResolvedInterfaceUnionMember1.lazilyResolvedStringProperty,
    );
    return _hasher;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedInterfaceUnionMember1> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedInterfaceUnionMember1.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazilyResolvedInterfaceUnionMember1";
      lazilyResolvedStringProperty: string;
    }
  > {
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/LazilyResolvedInterfaceUnionMember1":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $resource.isInstanceOf(
              LazilyResolvedInterfaceUnionMember1.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedInterfaceUnionMember1)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: LazilyResolvedInterfaceUnionMember1.$Identifier =
      $resource.identifier;
    const $type = "LazilyResolvedInterfaceUnionMember1" as const;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    LazilyResolvedInterfaceUnionMember1.$properties
                      .lazilyResolvedStringProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $toRdf(
    _lazilyResolvedInterfaceUnionMember1: LazilyResolvedInterfaceUnionMember1,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _lazilyResolvedInterfaceUnionMember1.$identifier,
      { mutateGraph },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/LazilyResolvedInterfaceUnionMember1",
        ),
      );
    }

    resource.add(
      LazilyResolvedInterfaceUnionMember1.$properties
        .lazilyResolvedStringProperty["identifier"],
      ...[_lazilyResolvedInterfaceUnionMember1.lazilyResolvedStringProperty],
    );
    return resource;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedInterfaceUnionMember1.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        LazilyResolvedInterfaceUnionMember1.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedInterfaceUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedInterfaceUnionMember1");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "lazilyResolvedInterfaceUnionMember1");
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedInterfaceUnionMember1.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedInterfaceUnionMember1");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "lazilyResolvedInterfaceUnionMember1");
    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedInterfaceUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedInterfaceUnionMember1.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}LazilyResolvedStringProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class LazilyResolvedClassUnionMember2 {
  private _$identifier?: LazilyResolvedClassUnionMember2.$Identifier;
  readonly $type = "LazilyResolvedClassUnionMember2";
  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): LazilyResolvedClassUnionMember2.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: LazilyResolvedClassUnionMember2): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): LazilyResolvedClassUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedClassUnionMember2.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/LazilyResolvedClassUnionMember2",
        ),
      );
    }

    resource.add(
      LazilyResolvedClassUnionMember2.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[this.lazilyResolvedStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LazilyResolvedClassUnionMember2 {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedClassUnionMember2",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedClassUnionMember2";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedClassUnionMember2> {
    return $propertiesFromJson(json).map(
      (properties) => new LazilyResolvedClassUnionMember2(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedClassUnionMember2" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedClassUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedClassUnionMember2"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedClassUnionMember2> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedClassUnionMember2.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new LazilyResolvedClassUnionMember2(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/LazilyResolvedClassUnionMember2":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $resource.isInstanceOf(LazilyResolvedClassUnionMember2.$fromRdfType)
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedClassUnionMember2)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: LazilyResolvedClassUnionMember2.$Identifier =
      $resource.identifier;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    LazilyResolvedClassUnionMember2.$properties
                      .lazilyResolvedStringProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedClassUnionMember2.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        LazilyResolvedClassUnionMember2.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedClassUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedClassUnionMember2");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "lazilyResolvedClassUnionMember2");
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedClassUnionMember2.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedClassUnionMember2");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "lazilyResolvedClassUnionMember2");
    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedClassUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedClassUnionMember2.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}LazilyResolvedStringProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class LazilyResolvedClassUnionMember1 {
  private _$identifier?: LazilyResolvedClassUnionMember1.$Identifier;
  readonly $type = "LazilyResolvedClassUnionMember1";
  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): LazilyResolvedClassUnionMember1.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: LazilyResolvedClassUnionMember1): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): LazilyResolvedClassUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedClassUnionMember1.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/LazilyResolvedClassUnionMember1",
        ),
      );
    }

    resource.add(
      LazilyResolvedClassUnionMember1.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[this.lazilyResolvedStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LazilyResolvedClassUnionMember1 {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedClassUnionMember1",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedClassUnionMember1";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedClassUnionMember1> {
    return $propertiesFromJson(json).map(
      (properties) => new LazilyResolvedClassUnionMember1(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedClassUnionMember1" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedClassUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedClassUnionMember1"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedClassUnionMember1> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedClassUnionMember1.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new LazilyResolvedClassUnionMember1(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/LazilyResolvedClassUnionMember1":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $resource.isInstanceOf(LazilyResolvedClassUnionMember1.$fromRdfType)
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedClassUnionMember1)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: LazilyResolvedClassUnionMember1.$Identifier =
      $resource.identifier;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    LazilyResolvedClassUnionMember1.$properties
                      .lazilyResolvedStringProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedClassUnionMember1.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        LazilyResolvedClassUnionMember1.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedClassUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedClassUnionMember1");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "lazilyResolvedClassUnionMember1");
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedClassUnionMember1.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedClassUnionMember1");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "lazilyResolvedClassUnionMember1");
    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedClassUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedClassUnionMember1.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}LazilyResolvedStringProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Node shape resolved by LazyPropertiesInterface
 */
export interface LazilyResolvedBlankNodeOrIriInterface {
  readonly $identifier: LazilyResolvedBlankNodeOrIriInterface.$Identifier;
  readonly $type: "LazilyResolvedBlankNodeOrIriInterface";
  readonly lazilyResolvedStringProperty: string;
}

export namespace LazilyResolvedBlankNodeOrIriInterface {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): LazilyResolvedBlankNodeOrIriInterface {
    let $identifier: LazilyResolvedBlankNodeOrIriInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "LazilyResolvedBlankNodeOrIriInterface" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: LazilyResolvedBlankNodeOrIriInterface,
    right: LazilyResolvedBlankNodeOrIriInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedBlankNodeOrIriInterface",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedBlankNodeOrIriInterface";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazilyResolvedBlankNodeOrIriInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "LazilyResolvedBlankNodeOrIriInterface" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedBlankNodeOrIriInterface> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedBlankNodeOrIriInterface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedBlankNodeOrIriInterface",
      type: "Group",
    };
  }

  export function $toJson(
    _lazilyResolvedBlankNodeOrIriInterface: LazilyResolvedBlankNodeOrIriInterface,
  ): LazilyResolvedBlankNodeOrIriInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _lazilyResolvedBlankNodeOrIriInterface.$identifier.termType ===
          "BlankNode"
            ? `_:${_lazilyResolvedBlankNodeOrIriInterface.$identifier.value}`
            : _lazilyResolvedBlankNodeOrIriInterface.$identifier.value,
        $type: _lazilyResolvedBlankNodeOrIriInterface.$type,
        lazilyResolvedStringProperty:
          _lazilyResolvedBlankNodeOrIriInterface.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedBlankNodeOrIriInterface.$Json),
    );
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedBlankNodeOrIriInterface"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedBlankNodeOrIriInterface: LazilyResolvedBlankNodeOrIriInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_lazilyResolvedBlankNodeOrIriInterface.$identifier.value);
    _hasher.update(_lazilyResolvedBlankNodeOrIriInterface.$type);
    LazilyResolvedBlankNodeOrIriInterface.$hashShaclProperties(
      _lazilyResolvedBlankNodeOrIriInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedBlankNodeOrIriInterface: LazilyResolvedBlankNodeOrIriInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _lazilyResolvedBlankNodeOrIriInterface.lazilyResolvedStringProperty,
    );
    return _hasher;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedBlankNodeOrIriInterface> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedBlankNodeOrIriInterface.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazilyResolvedBlankNodeOrIriInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/LazilyResolvedBlankNodeOrIriInterface":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $resource.isInstanceOf(
              LazilyResolvedBlankNodeOrIriInterface.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedBlankNodeOrIriInterface)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: LazilyResolvedBlankNodeOrIriInterface.$Identifier =
      $resource.identifier;
    const $type = "LazilyResolvedBlankNodeOrIriInterface" as const;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    LazilyResolvedBlankNodeOrIriInterface.$properties
                      .lazilyResolvedStringProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $toRdf(
    _lazilyResolvedBlankNodeOrIriInterface: LazilyResolvedBlankNodeOrIriInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _lazilyResolvedBlankNodeOrIriInterface.$identifier,
      { mutateGraph },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/LazilyResolvedBlankNodeOrIriInterface",
        ),
      );
    }

    resource.add(
      LazilyResolvedBlankNodeOrIriInterface.$properties
        .lazilyResolvedStringProperty["identifier"],
      ...[_lazilyResolvedBlankNodeOrIriInterface.lazilyResolvedStringProperty],
    );
    return resource;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedBlankNodeOrIriInterface.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        LazilyResolvedBlankNodeOrIriInterface.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedBlankNodeOrIriInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedBlankNodeOrIriInterface");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "lazilyResolvedBlankNodeOrIriInterface");
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedBlankNodeOrIriInterface.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedBlankNodeOrIriInterface");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "lazilyResolvedBlankNodeOrIriInterface");
    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedBlankNodeOrIriInterface.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedBlankNodeOrIriInterface.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}LazilyResolvedStringProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Node shape resolved by LazyPropertiesClass
 */
export class LazilyResolvedBlankNodeOrIriClass {
  private _$identifier?: LazilyResolvedBlankNodeOrIriClass.$Identifier;
  readonly $type = "LazilyResolvedBlankNodeOrIriClass";
  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): LazilyResolvedBlankNodeOrIriClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: LazilyResolvedBlankNodeOrIriClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): LazilyResolvedBlankNodeOrIriClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedBlankNodeOrIriClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/LazilyResolvedBlankNodeOrIriClass",
        ),
      );
    }

    resource.add(
      LazilyResolvedBlankNodeOrIriClass.$properties
        .lazilyResolvedStringProperty["identifier"],
      ...[this.lazilyResolvedStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LazilyResolvedBlankNodeOrIriClass {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedBlankNodeOrIriClass",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedBlankNodeOrIriClass";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedBlankNodeOrIriClass> {
    return $propertiesFromJson(json).map(
      (properties) => new LazilyResolvedBlankNodeOrIriClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedBlankNodeOrIriClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedBlankNodeOrIriClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedBlankNodeOrIriClass"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedBlankNodeOrIriClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedBlankNodeOrIriClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new LazilyResolvedBlankNodeOrIriClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/LazilyResolvedBlankNodeOrIriClass":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $resource.isInstanceOf(
              LazilyResolvedBlankNodeOrIriClass.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedBlankNodeOrIriClass)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: LazilyResolvedBlankNodeOrIriClass.$Identifier =
      $resource.identifier;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    LazilyResolvedBlankNodeOrIriClass.$properties
                      .lazilyResolvedStringProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedBlankNodeOrIriClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        LazilyResolvedBlankNodeOrIriClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedBlankNodeOrIriClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedBlankNodeOrIriClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "lazilyResolvedBlankNodeOrIriClass");
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedBlankNodeOrIriClass.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedBlankNodeOrIriClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "lazilyResolvedBlankNodeOrIriClass");
    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedBlankNodeOrIriClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedBlankNodeOrIriClass.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}LazilyResolvedStringProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Shape that uses the StringList in a property.
 */
export class LanguageInPropertiesClass {
  private _$identifier?: LanguageInPropertiesClass.$Identifier;
  readonly $type = "LanguageInPropertiesClass";
  /**
   * literal property for testing languageIn
   */
  readonly languageInLiteralProperty: purify.NonEmptyList<rdfjs.Literal>;
  /**
   * string property for testing languageIn; must have '' as an acceptable languageIn since that's how it will be serialized to RDF
   */
  readonly languageInStringProperty: purify.NonEmptyList<string>;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly languageInLiteralProperty: purify.NonEmptyList<rdfjs.Literal>;
    readonly languageInStringProperty: purify.NonEmptyList<string>;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.languageInLiteralProperty = parameters.languageInLiteralProperty;
    this.languageInStringProperty = parameters.languageInStringProperty;
  }

  get $identifier(): LanguageInPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: LanguageInPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.languageInLiteralProperty,
          other.languageInLiteralProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "languageInLiteralProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $strictEquals))(
          this.languageInStringProperty,
          other.languageInStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "languageInStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    for (const item0 of this.languageInLiteralProperty) {
      _hasher.update(item0.datatype.value);
      _hasher.update(item0.language);
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }

    for (const item0 of this.languageInStringProperty) {
      _hasher.update(item0);
    }

    return _hasher;
  }

  $toJson(): LanguageInPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        languageInLiteralProperty: this.languageInLiteralProperty.map(
          (item) => ({
            "@language": item.language.length > 0 ? item.language : undefined,
            "@type":
              item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? item.datatype.value
                : undefined,
            "@value": item.value,
          }),
        ),
        languageInStringProperty: this.languageInStringProperty.map(
          (item) => item,
        ),
      } satisfies LanguageInPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      LanguageInPropertiesClass.$properties.languageInLiteralProperty[
        "identifier"
      ],
      ...this.languageInLiteralProperty.flatMap((item) => [item]),
    );
    resource.add(
      LanguageInPropertiesClass.$properties.languageInStringProperty[
        "identifier"
      ],
      ...this.languageInStringProperty.flatMap((item) => [item]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LanguageInPropertiesClass {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LanguageInPropertiesClass";
    readonly languageInLiteralProperty: readonly {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    }[];
    readonly languageInStringProperty: readonly string[];
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      languageInLiteralProperty: purify.NonEmptyList<rdfjs.Literal>;
      languageInStringProperty: purify.NonEmptyList<string>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const languageInLiteralProperty = purify.NonEmptyList.fromArray(
      $jsonObject["languageInLiteralProperty"],
    )
      .unsafeCoerce()
      .map((item) =>
        dataFactory.literal(
          item["@value"],
          typeof item["@language"] !== "undefined"
            ? item["@language"]
            : typeof item["@type"] !== "undefined"
              ? dataFactory.namedNode(item["@type"])
              : undefined,
        ),
      );
    const languageInStringProperty = purify.NonEmptyList.fromArray(
      $jsonObject["languageInStringProperty"],
    ).unsafeCoerce();
    return purify.Either.of({
      $identifier,
      languageInLiteralProperty,
      languageInStringProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LanguageInPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new LanguageInPropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LanguageInPropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/languageInLiteralProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/languageInStringProperty`,
          type: "Control",
        },
      ],
      label: "LanguageInPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LanguageInPropertiesClass"),
      languageInLiteralProperty: zod
        .object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
        })
        .array()
        .nonempty()
        .min(1)
        .describe("literal property for testing languageIn"),
      languageInStringProperty: zod
        .string()
        .array()
        .nonempty()
        .min(1)
        .describe(
          "string property for testing languageIn; must have '' as an acceptable languageIn since that's how it will be serialized to RDF",
        ),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LanguageInPropertiesClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LanguageInPropertiesClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new LanguageInPropertiesClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      languageInLiteralProperty: purify.NonEmptyList<rdfjs.Literal>;
      languageInStringProperty: purify.NonEmptyList<string>;
    }
  > {
    const $identifier: LanguageInPropertiesClass.$Identifier =
      $resource.identifier;
    const _languageInLiteralPropertyEither: purify.Either<
      Error,
      purify.NonEmptyList<rdfjs.Literal>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.languageInLiteralProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toLiteral().chain((literalValue) => {
            switch (literalValue.language) {
              case "en":
              case "fr":
                return purify.Either.of(value);
              default:
                return purify.Left(
                  new rdfjsResource.Resource.MistypedValueError({
                    actualValue: literalValue,
                    expectedValueType: "(rdfjs.Literal)",
                    focusResource: $resource,
                    predicate:
                      LanguageInPropertiesClass.$properties
                        .languageInLiteralProperty["identifier"],
                  }),
                );
            }
          }),
        ),
      )
      .chain((values) => {
        if (!$preferredLanguages || $preferredLanguages.length === 0) {
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(values);
        }

        const literalValuesEither = values.chainMap((value) =>
          value.toLiteral(),
        );
        if (literalValuesEither.isLeft()) {
          return literalValuesEither;
        }
        const literalValues = literalValuesEither.unsafeCoerce();

        // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
        // Within a preferredLanguage the literals may be in any order.
        let filteredLiteralValues:
          | rdfjsResource.Resource.Values<rdfjs.Literal>
          | undefined;
        for (const preferredLanguage of $preferredLanguages) {
          if (!filteredLiteralValues) {
            filteredLiteralValues = literalValues.filter(
              (value) => value.language === preferredLanguage,
            );
          } else {
            filteredLiteralValues = filteredLiteralValues.concat(
              ...literalValues
                .filter((value) => value.language === preferredLanguage)
                .toArray(),
            );
          }
        }

        return purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
        >(
          filteredLiteralValues!.map(
            (literalValue) =>
              new rdfjsResource.Resource.Value({
                object: literalValue,
                predicate:
                  LanguageInPropertiesClass.$properties
                    .languageInLiteralProperty["identifier"],
                subject: $resource,
              }),
          ),
        );
      })
      .chain((values) => values.chainMap((value) => value.toLiteral()))
      .chain((values) =>
        purify.NonEmptyList.fromArray(values.toArray()).toEither(
          new Error(
            `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} is an empty set`,
          ),
        ),
      )
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          object: valuesArray,
          predicate:
            LanguageInPropertiesClass.$properties.languageInLiteralProperty[
              "identifier"
            ],
          subject: $resource,
        }),
      )
      .chain((values) => values.head());
    if (_languageInLiteralPropertyEither.isLeft()) {
      return _languageInLiteralPropertyEither;
    }

    const languageInLiteralProperty =
      _languageInLiteralPropertyEither.unsafeCoerce();
    const _languageInStringPropertyEither: purify.Either<
      Error,
      purify.NonEmptyList<string>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.languageInStringProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toLiteral().chain((literalValue) => {
            switch (literalValue.language) {
              case "":
              case "en":
              case "fr":
                return purify.Either.of(value);
              default:
                return purify.Left(
                  new rdfjsResource.Resource.MistypedValueError({
                    actualValue: literalValue,
                    expectedValueType: "string",
                    focusResource: $resource,
                    predicate:
                      LanguageInPropertiesClass.$properties
                        .languageInStringProperty["identifier"],
                  }),
                );
            }
          }),
        ),
      )
      .chain((values) => {
        if (!$preferredLanguages || $preferredLanguages.length === 0) {
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(values);
        }

        const literalValuesEither = values.chainMap((value) =>
          value.toLiteral(),
        );
        if (literalValuesEither.isLeft()) {
          return literalValuesEither;
        }
        const literalValues = literalValuesEither.unsafeCoerce();

        // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
        // Within a preferredLanguage the literals may be in any order.
        let filteredLiteralValues:
          | rdfjsResource.Resource.Values<rdfjs.Literal>
          | undefined;
        for (const preferredLanguage of $preferredLanguages) {
          if (!filteredLiteralValues) {
            filteredLiteralValues = literalValues.filter(
              (value) => value.language === preferredLanguage,
            );
          } else {
            filteredLiteralValues = filteredLiteralValues.concat(
              ...literalValues
                .filter((value) => value.language === preferredLanguage)
                .toArray(),
            );
          }
        }

        return purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
        >(
          filteredLiteralValues!.map(
            (literalValue) =>
              new rdfjsResource.Resource.Value({
                object: literalValue,
                predicate:
                  LanguageInPropertiesClass.$properties
                    .languageInStringProperty["identifier"],
                subject: $resource,
              }),
          ),
        );
      })
      .chain((values) => values.chainMap((value) => value.toString()))
      .chain((values) =>
        purify.NonEmptyList.fromArray(values.toArray()).toEither(
          new Error(
            `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} is an empty set`,
          ),
        ),
      )
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          object: valuesArray,
          predicate:
            LanguageInPropertiesClass.$properties.languageInStringProperty[
              "identifier"
            ],
          subject: $resource,
        }),
      )
      .chain((values) => values.head());
    if (_languageInStringPropertyEither.isLeft()) {
      return _languageInStringPropertyEither;
    }

    const languageInStringProperty =
      _languageInStringPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      languageInLiteralProperty,
      languageInStringProperty,
    });
  }

  export const $properties = {
    languageInLiteralProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/languageInLiteralProperty",
      ),
    },
    languageInStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/languageInStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LanguageInPropertiesClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        LanguageInPropertiesClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LanguageInPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("languageInPropertiesClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "languageInPropertiesClass");
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}LanguageInLiteralProperty`,
      ),
      predicate:
        LanguageInPropertiesClass.$properties.languageInLiteralProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}LanguageInStringProperty`,
      ),
      predicate:
        LanguageInPropertiesClass.$properties.languageInStringProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("languageInPropertiesClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "languageInPropertiesClass");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}LanguageInLiteralProperty`,
            ),
            predicate:
              LanguageInPropertiesClass.$properties.languageInLiteralProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[
        [
          ...$arrayIntersection(
            ["en", "fr"],
            parameters?.preferredLanguages ?? [],
          ),
        ],
      ]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}LanguageInLiteralProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}LanguageInStringProperty`,
            ),
            predicate:
              LanguageInPropertiesClass.$properties.languageInStringProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[
        [
          ...$arrayIntersection(
            ["", "en", "fr"],
            parameters?.preferredLanguages ?? [],
          ),
        ],
      ]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}LanguageInStringProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * A node shape that only allows IRI identifiers.
 */
export class IriClass {
  readonly $identifier: IriClass.$Identifier;
  readonly $type = "IriClass";

  constructor(parameters: { readonly $identifier: rdfjs.NamedNode | string }) {
    if (typeof parameters.$identifier === "object") {
      this.$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this.$identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      this.$identifier = parameters.$identifier satisfies never;
    }
  }

  $equals(other: IriClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    return _hasher;
  }

  $toJson(): IriClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
      } satisfies IriClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(this.$identifier, {
      mutateGraph,
    });
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IriClass {
  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = { readonly "@id": string; readonly $type: "IriClass" };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<zod.ZodError, { $identifier: rdfjs.NamedNode }> {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    return purify.Either.of({ $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, IriClass> {
    return $propertiesFromJson(json).map(
      (properties) => new IriClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "IriClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "IriClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("IriClass"),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, IriClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return IriClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new IriClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<Error, { $identifier: rdfjs.NamedNode }> {
    if ($resource.identifier.termType !== "NamedNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedValueError({
          actualValue: $resource.identifier,
          expectedValueType: "(rdfjs.NamedNode)",
          focusResource: $resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: IriClass.$Identifier = $resource.identifier;
    return purify.Either.of({ $identifier });
  }

  export const $properties = {};

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IriClass.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        IriClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IriClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(_parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [];
  }
}
export interface InterfaceUnionMember2b {
  readonly $identifier: InterfaceUnionMember2b.$Identifier;
  readonly $type: "InterfaceUnionMember2b";
  readonly interfaceUnionMember2bProperty: string;
}

export namespace InterfaceUnionMember2b {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly interfaceUnionMember2bProperty: string;
  }): InterfaceUnionMember2b {
    let $identifier: InterfaceUnionMember2b.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "InterfaceUnionMember2b" as const;
    const interfaceUnionMember2bProperty =
      parameters.interfaceUnionMember2bProperty;
    return { $identifier, $type, interfaceUnionMember2bProperty };
  }

  export function $equals(
    left: InterfaceUnionMember2b,
    right: InterfaceUnionMember2b,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.interfaceUnionMember2bProperty,
          right.interfaceUnionMember2bProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "interfaceUnionMember2bProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "InterfaceUnionMember2b";
    readonly interfaceUnionMember2bProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "InterfaceUnionMember2b";
      interfaceUnionMember2bProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "InterfaceUnionMember2b" as const;
    const interfaceUnionMember2bProperty =
      $jsonObject["interfaceUnionMember2bProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      interfaceUnionMember2bProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, InterfaceUnionMember2b> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "InterfaceUnionMember2b" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/interfaceUnionMember2bProperty`,
          type: "Control",
        },
      ],
      label: "InterfaceUnionMember2b",
      type: "Group",
    };
  }

  export function $toJson(
    _interfaceUnionMember2b: InterfaceUnionMember2b,
  ): InterfaceUnionMember2b.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _interfaceUnionMember2b.$identifier.termType === "BlankNode"
            ? `_:${_interfaceUnionMember2b.$identifier.value}`
            : _interfaceUnionMember2b.$identifier.value,
        $type: _interfaceUnionMember2b.$type,
        interfaceUnionMember2bProperty:
          _interfaceUnionMember2b.interfaceUnionMember2bProperty,
      } satisfies InterfaceUnionMember2b.$Json),
    );
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("InterfaceUnionMember2b"),
      interfaceUnionMember2bProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _interfaceUnionMember2b: InterfaceUnionMember2b,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_interfaceUnionMember2b.$identifier.value);
    _hasher.update(_interfaceUnionMember2b.$type);
    InterfaceUnionMember2b.$hashShaclProperties(
      _interfaceUnionMember2b,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _interfaceUnionMember2b: InterfaceUnionMember2b,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_interfaceUnionMember2b.interfaceUnionMember2bProperty);
    return _hasher;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, InterfaceUnionMember2b> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return InterfaceUnionMember2b.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "InterfaceUnionMember2b";
      interfaceUnionMember2bProperty: string;
    }
  > {
    const $identifier: InterfaceUnionMember2b.$Identifier =
      $resource.identifier;
    const $type = "InterfaceUnionMember2b" as const;
    const _interfaceUnionMember2bPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.interfaceUnionMember2bProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    InterfaceUnionMember2b.$properties
                      .interfaceUnionMember2bProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_interfaceUnionMember2bPropertyEither.isLeft()) {
      return _interfaceUnionMember2bPropertyEither;
    }

    const interfaceUnionMember2bProperty =
      _interfaceUnionMember2bPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      $type,
      interfaceUnionMember2bProperty,
    });
  }

  export function $toRdf(
    _interfaceUnionMember2b: InterfaceUnionMember2b,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _interfaceUnionMember2b.$identifier,
      { mutateGraph },
    );
    resource.add(
      InterfaceUnionMember2b.$properties.interfaceUnionMember2bProperty[
        "identifier"
      ],
      ...[_interfaceUnionMember2b.interfaceUnionMember2bProperty],
    );
    return resource;
  }

  export const $properties = {
    interfaceUnionMember2bProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/interfaceUnionMember2bProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InterfaceUnionMember2b.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        InterfaceUnionMember2b.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InterfaceUnionMember2b.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("interfaceUnionMember2b");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "interfaceUnionMember2b");
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}InterfaceUnionMember2bProperty`,
      ),
      predicate:
        InterfaceUnionMember2b.$properties.interfaceUnionMember2bProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("interfaceUnionMember2b");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "interfaceUnionMember2b");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}InterfaceUnionMember2bProperty`,
            ),
            predicate:
              InterfaceUnionMember2b.$properties.interfaceUnionMember2bProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}InterfaceUnionMember2bProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export interface InterfaceUnionMember2a {
  readonly $identifier: InterfaceUnionMember2a.$Identifier;
  readonly $type: "InterfaceUnionMember2a";
  readonly interfaceUnionMember2aProperty: string;
}

export namespace InterfaceUnionMember2a {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly interfaceUnionMember2aProperty: string;
  }): InterfaceUnionMember2a {
    let $identifier: InterfaceUnionMember2a.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "InterfaceUnionMember2a" as const;
    const interfaceUnionMember2aProperty =
      parameters.interfaceUnionMember2aProperty;
    return { $identifier, $type, interfaceUnionMember2aProperty };
  }

  export function $equals(
    left: InterfaceUnionMember2a,
    right: InterfaceUnionMember2a,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.interfaceUnionMember2aProperty,
          right.interfaceUnionMember2aProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "interfaceUnionMember2aProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "InterfaceUnionMember2a";
    readonly interfaceUnionMember2aProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "InterfaceUnionMember2a";
      interfaceUnionMember2aProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "InterfaceUnionMember2a" as const;
    const interfaceUnionMember2aProperty =
      $jsonObject["interfaceUnionMember2aProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      interfaceUnionMember2aProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, InterfaceUnionMember2a> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "InterfaceUnionMember2a" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/interfaceUnionMember2aProperty`,
          type: "Control",
        },
      ],
      label: "InterfaceUnionMember2a",
      type: "Group",
    };
  }

  export function $toJson(
    _interfaceUnionMember2a: InterfaceUnionMember2a,
  ): InterfaceUnionMember2a.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _interfaceUnionMember2a.$identifier.termType === "BlankNode"
            ? `_:${_interfaceUnionMember2a.$identifier.value}`
            : _interfaceUnionMember2a.$identifier.value,
        $type: _interfaceUnionMember2a.$type,
        interfaceUnionMember2aProperty:
          _interfaceUnionMember2a.interfaceUnionMember2aProperty,
      } satisfies InterfaceUnionMember2a.$Json),
    );
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("InterfaceUnionMember2a"),
      interfaceUnionMember2aProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _interfaceUnionMember2a: InterfaceUnionMember2a,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_interfaceUnionMember2a.$identifier.value);
    _hasher.update(_interfaceUnionMember2a.$type);
    InterfaceUnionMember2a.$hashShaclProperties(
      _interfaceUnionMember2a,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _interfaceUnionMember2a: InterfaceUnionMember2a,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_interfaceUnionMember2a.interfaceUnionMember2aProperty);
    return _hasher;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, InterfaceUnionMember2a> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return InterfaceUnionMember2a.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "InterfaceUnionMember2a";
      interfaceUnionMember2aProperty: string;
    }
  > {
    const $identifier: InterfaceUnionMember2a.$Identifier =
      $resource.identifier;
    const $type = "InterfaceUnionMember2a" as const;
    const _interfaceUnionMember2aPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.interfaceUnionMember2aProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    InterfaceUnionMember2a.$properties
                      .interfaceUnionMember2aProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_interfaceUnionMember2aPropertyEither.isLeft()) {
      return _interfaceUnionMember2aPropertyEither;
    }

    const interfaceUnionMember2aProperty =
      _interfaceUnionMember2aPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      $type,
      interfaceUnionMember2aProperty,
    });
  }

  export function $toRdf(
    _interfaceUnionMember2a: InterfaceUnionMember2a,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _interfaceUnionMember2a.$identifier,
      { mutateGraph },
    );
    resource.add(
      InterfaceUnionMember2a.$properties.interfaceUnionMember2aProperty[
        "identifier"
      ],
      ...[_interfaceUnionMember2a.interfaceUnionMember2aProperty],
    );
    return resource;
  }

  export const $properties = {
    interfaceUnionMember2aProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/interfaceUnionMember2aProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InterfaceUnionMember2a.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        InterfaceUnionMember2a.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InterfaceUnionMember2a.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("interfaceUnionMember2a");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "interfaceUnionMember2a");
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}InterfaceUnionMember2aProperty`,
      ),
      predicate:
        InterfaceUnionMember2a.$properties.interfaceUnionMember2aProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("interfaceUnionMember2a");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "interfaceUnionMember2a");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}InterfaceUnionMember2aProperty`,
            ),
            predicate:
              InterfaceUnionMember2a.$properties.interfaceUnionMember2aProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}InterfaceUnionMember2aProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export interface InterfaceUnionMember1 {
  readonly $identifier: InterfaceUnionMember1.$Identifier;
  readonly $type: "InterfaceUnionMember1";
  readonly interfaceUnionMember1Property: string;
}

export namespace InterfaceUnionMember1 {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly interfaceUnionMember1Property: string;
  }): InterfaceUnionMember1 {
    let $identifier: InterfaceUnionMember1.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "InterfaceUnionMember1" as const;
    const interfaceUnionMember1Property =
      parameters.interfaceUnionMember1Property;
    return { $identifier, $type, interfaceUnionMember1Property };
  }

  export function $equals(
    left: InterfaceUnionMember1,
    right: InterfaceUnionMember1,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.interfaceUnionMember1Property,
          right.interfaceUnionMember1Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "interfaceUnionMember1Property",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "InterfaceUnionMember1";
    readonly interfaceUnionMember1Property: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "InterfaceUnionMember1";
      interfaceUnionMember1Property: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "InterfaceUnionMember1" as const;
    const interfaceUnionMember1Property =
      $jsonObject["interfaceUnionMember1Property"];
    return purify.Either.of({
      $identifier,
      $type,
      interfaceUnionMember1Property,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, InterfaceUnionMember1> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "InterfaceUnionMember1" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/interfaceUnionMember1Property`,
          type: "Control",
        },
      ],
      label: "InterfaceUnionMember1",
      type: "Group",
    };
  }

  export function $toJson(
    _interfaceUnionMember1: InterfaceUnionMember1,
  ): InterfaceUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _interfaceUnionMember1.$identifier.termType === "BlankNode"
            ? `_:${_interfaceUnionMember1.$identifier.value}`
            : _interfaceUnionMember1.$identifier.value,
        $type: _interfaceUnionMember1.$type,
        interfaceUnionMember1Property:
          _interfaceUnionMember1.interfaceUnionMember1Property,
      } satisfies InterfaceUnionMember1.$Json),
    );
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("InterfaceUnionMember1"),
      interfaceUnionMember1Property: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_interfaceUnionMember1: InterfaceUnionMember1, _hasher: HasherT): HasherT {
    _hasher.update(_interfaceUnionMember1.$identifier.value);
    _hasher.update(_interfaceUnionMember1.$type);
    InterfaceUnionMember1.$hashShaclProperties(_interfaceUnionMember1, _hasher);
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_interfaceUnionMember1: InterfaceUnionMember1, _hasher: HasherT): HasherT {
    _hasher.update(_interfaceUnionMember1.interfaceUnionMember1Property);
    return _hasher;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, InterfaceUnionMember1> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return InterfaceUnionMember1.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "InterfaceUnionMember1";
      interfaceUnionMember1Property: string;
    }
  > {
    const $identifier: InterfaceUnionMember1.$Identifier = $resource.identifier;
    const $type = "InterfaceUnionMember1" as const;
    const _interfaceUnionMember1PropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.interfaceUnionMember1Property["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    InterfaceUnionMember1.$properties
                      .interfaceUnionMember1Property["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_interfaceUnionMember1PropertyEither.isLeft()) {
      return _interfaceUnionMember1PropertyEither;
    }

    const interfaceUnionMember1Property =
      _interfaceUnionMember1PropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      $type,
      interfaceUnionMember1Property,
    });
  }

  export function $toRdf(
    _interfaceUnionMember1: InterfaceUnionMember1,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _interfaceUnionMember1.$identifier,
      { mutateGraph },
    );
    resource.add(
      InterfaceUnionMember1.$properties.interfaceUnionMember1Property[
        "identifier"
      ],
      ...[_interfaceUnionMember1.interfaceUnionMember1Property],
    );
    return resource;
  }

  export const $properties = {
    interfaceUnionMember1Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/interfaceUnionMember1Property",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InterfaceUnionMember1.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        InterfaceUnionMember1.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InterfaceUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("interfaceUnionMember1");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "interfaceUnionMember1");
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}InterfaceUnionMember1Property`,
      ),
      predicate:
        InterfaceUnionMember1.$properties.interfaceUnionMember1Property[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("interfaceUnionMember1");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "interfaceUnionMember1");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}InterfaceUnionMember1Property`,
            ),
            predicate:
              InterfaceUnionMember1.$properties.interfaceUnionMember1Property[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}InterfaceUnionMember1Property`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * A node shape that's generated as a TypeScript interface instead of a class.
 */
export interface Interface {
  readonly $identifier: Interface.$Identifier;
  readonly $type: "Interface";
  readonly interfaceProperty: string;
}

export namespace Interface {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly interfaceProperty: string;
  }): Interface {
    let $identifier: Interface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "Interface" as const;
    const interfaceProperty = parameters.interfaceProperty;
    return { $identifier, $type, interfaceProperty };
  }

  export function $equals(left: Interface, right: Interface): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(left.interfaceProperty, right.interfaceProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "interfaceProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "Interface";
    readonly interfaceProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "Interface";
      interfaceProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "Interface" as const;
    const interfaceProperty = $jsonObject["interfaceProperty"];
    return purify.Either.of({ $identifier, $type, interfaceProperty });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Interface> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "Interface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/interfaceProperty`,
          type: "Control",
        },
      ],
      label: "Interface",
      type: "Group",
    };
  }

  export function $toJson(_interface: Interface): Interface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _interface.$identifier.termType === "BlankNode"
            ? `_:${_interface.$identifier.value}`
            : _interface.$identifier.value,
        $type: _interface.$type,
        interfaceProperty: _interface.interfaceProperty,
      } satisfies Interface.$Json),
    );
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("Interface"),
      interfaceProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_interface: Interface, _hasher: HasherT): HasherT {
    _hasher.update(_interface.$identifier.value);
    _hasher.update(_interface.$type);
    Interface.$hashShaclProperties(_interface, _hasher);
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_interface: Interface, _hasher: HasherT): HasherT {
    _hasher.update(_interface.interfaceProperty);
    return _hasher;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, Interface> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return Interface.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "Interface";
      interfaceProperty: string;
    }
  > {
    const $identifier: Interface.$Identifier = $resource.identifier;
    const $type = "Interface" as const;
    const _interfacePropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.interfaceProperty["identifier"], {
          unique: true,
        }),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    Interface.$properties.interfaceProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_interfacePropertyEither.isLeft()) {
      return _interfacePropertyEither;
    }

    const interfaceProperty = _interfacePropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, $type, interfaceProperty });
  }

  export function $toRdf(
    _interface: Interface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(_interface.$identifier, {
      mutateGraph,
    });
    resource.add(
      Interface.$properties.interfaceProperty["identifier"],
      ...[_interface.interfaceProperty],
    );
    return resource;
  }

  export const $properties = {
    interfaceProperty: {
      identifier: dataFactory.namedNode("http://example.com/interfaceProperty"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Interface.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Interface.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Interface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("interface");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "interface");
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}InterfaceProperty`),
      predicate: Interface.$properties.interfaceProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("interface");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "interface");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}InterfaceProperty`),
            predicate: Interface.$properties.interfaceProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(`${variablePrefix}InterfaceProperty`),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class IndirectRecursiveHelperClass {
  private _$identifier?: IndirectRecursiveHelperClass.$Identifier;
  readonly $type = "IndirectRecursiveHelperClass";
  readonly indirectRecursiveProperty: purify.Maybe<IndirectRecursiveClass>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly indirectRecursiveProperty?:
      | IndirectRecursiveClass
      | purify.Maybe<IndirectRecursiveClass>;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.indirectRecursiveProperty)) {
      this.indirectRecursiveProperty = parameters?.indirectRecursiveProperty;
    } else if (
      typeof parameters?.indirectRecursiveProperty === "object" &&
      parameters?.indirectRecursiveProperty instanceof IndirectRecursiveClass
    ) {
      this.indirectRecursiveProperty = purify.Maybe.of(
        parameters?.indirectRecursiveProperty,
      );
    } else if (typeof parameters?.indirectRecursiveProperty === "undefined") {
      this.indirectRecursiveProperty = purify.Maybe.empty();
    } else {
      this.indirectRecursiveProperty =
        parameters?.indirectRecursiveProperty satisfies never;
    }
  }

  get $identifier(): IndirectRecursiveHelperClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: IndirectRecursiveHelperClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.indirectRecursiveProperty,
          other.indirectRecursiveProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "indirectRecursiveProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.indirectRecursiveProperty.ifJust((value0) => {
      value0.$hash(_hasher);
    });
    return _hasher;
  }

  $toJson(): IndirectRecursiveHelperClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        indirectRecursiveProperty: this.indirectRecursiveProperty
          .map((item) => item.$toJson())
          .extract(),
      } satisfies IndirectRecursiveHelperClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      IndirectRecursiveHelperClass.$properties.indirectRecursiveProperty[
        "identifier"
      ],
      ...this.indirectRecursiveProperty
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IndirectRecursiveHelperClass {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "IndirectRecursiveHelperClass";
    readonly indirectRecursiveProperty?: IndirectRecursiveClass.$Json;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      indirectRecursiveProperty: purify.Maybe<IndirectRecursiveClass>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const indirectRecursiveProperty = purify.Maybe.fromNullable(
      $jsonObject["indirectRecursiveProperty"],
    ).map((item) => IndirectRecursiveClass.$fromJson(item).unsafeCoerce());
    return purify.Either.of({ $identifier, indirectRecursiveProperty });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, IndirectRecursiveHelperClass> {
    return $propertiesFromJson(json).map(
      (properties) => new IndirectRecursiveHelperClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "IndirectRecursiveHelperClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        IndirectRecursiveClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/indirectRecursiveProperty`,
        }),
      ],
      label: "IndirectRecursiveHelperClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("IndirectRecursiveHelperClass"),
      indirectRecursiveProperty: zod
        .lazy(
          (): zod.ZodType<IndirectRecursiveClass.$Json> =>
            IndirectRecursiveClass.$jsonZodSchema(),
        )
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, IndirectRecursiveHelperClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return IndirectRecursiveHelperClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new IndirectRecursiveHelperClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      indirectRecursiveProperty: purify.Maybe<IndirectRecursiveClass>;
    }
  > {
    const $identifier: IndirectRecursiveHelperClass.$Identifier =
      $resource.identifier;
    const _indirectRecursivePropertyEither: purify.Either<
      Error,
      purify.Maybe<IndirectRecursiveClass>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.indirectRecursiveProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            IndirectRecursiveClass.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<IndirectRecursiveClass>
            >({
              object: purify.Maybe.empty(),
              predicate:
                IndirectRecursiveHelperClass.$properties
                  .indirectRecursiveProperty["identifier"],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_indirectRecursivePropertyEither.isLeft()) {
      return _indirectRecursivePropertyEither;
    }

    const indirectRecursiveProperty =
      _indirectRecursivePropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, indirectRecursiveProperty });
  }

  export const $properties = {
    indirectRecursiveProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/indirectRecursiveProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IndirectRecursiveHelperClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        IndirectRecursiveHelperClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IndirectRecursiveHelperClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(_parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [];
  }
}
export class IndirectRecursiveClass {
  private _$identifier?: IndirectRecursiveClass.$Identifier;
  readonly $type = "IndirectRecursiveClass";
  readonly indirectRecursiveHelperProperty: purify.Maybe<IndirectRecursiveHelperClass>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly indirectRecursiveHelperProperty?:
      | IndirectRecursiveHelperClass
      | purify.Maybe<IndirectRecursiveHelperClass>;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.indirectRecursiveHelperProperty)) {
      this.indirectRecursiveHelperProperty =
        parameters?.indirectRecursiveHelperProperty;
    } else if (
      typeof parameters?.indirectRecursiveHelperProperty === "object" &&
      parameters?.indirectRecursiveHelperProperty instanceof
        IndirectRecursiveHelperClass
    ) {
      this.indirectRecursiveHelperProperty = purify.Maybe.of(
        parameters?.indirectRecursiveHelperProperty,
      );
    } else if (
      typeof parameters?.indirectRecursiveHelperProperty === "undefined"
    ) {
      this.indirectRecursiveHelperProperty = purify.Maybe.empty();
    } else {
      this.indirectRecursiveHelperProperty =
        parameters?.indirectRecursiveHelperProperty satisfies never;
    }
  }

  get $identifier(): IndirectRecursiveClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: IndirectRecursiveClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.indirectRecursiveHelperProperty,
          other.indirectRecursiveHelperProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "indirectRecursiveHelperProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.indirectRecursiveHelperProperty.ifJust((value0) => {
      value0.$hash(_hasher);
    });
    return _hasher;
  }

  $toJson(): IndirectRecursiveClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        indirectRecursiveHelperProperty: this.indirectRecursiveHelperProperty
          .map((item) => item.$toJson())
          .extract(),
      } satisfies IndirectRecursiveClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      IndirectRecursiveClass.$properties.indirectRecursiveHelperProperty[
        "identifier"
      ],
      ...this.indirectRecursiveHelperProperty
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IndirectRecursiveClass {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "IndirectRecursiveClass";
    readonly indirectRecursiveHelperProperty?: IndirectRecursiveHelperClass.$Json;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      indirectRecursiveHelperProperty: purify.Maybe<IndirectRecursiveHelperClass>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const indirectRecursiveHelperProperty = purify.Maybe.fromNullable(
      $jsonObject["indirectRecursiveHelperProperty"],
    ).map((item) =>
      IndirectRecursiveHelperClass.$fromJson(item).unsafeCoerce(),
    );
    return purify.Either.of({ $identifier, indirectRecursiveHelperProperty });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, IndirectRecursiveClass> {
    return $propertiesFromJson(json).map(
      (properties) => new IndirectRecursiveClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "IndirectRecursiveClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        IndirectRecursiveHelperClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/indirectRecursiveHelperProperty`,
        }),
      ],
      label: "IndirectRecursiveClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("IndirectRecursiveClass"),
      indirectRecursiveHelperProperty: zod
        .lazy(
          (): zod.ZodType<IndirectRecursiveHelperClass.$Json> =>
            IndirectRecursiveHelperClass.$jsonZodSchema(),
        )
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, IndirectRecursiveClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return IndirectRecursiveClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new IndirectRecursiveClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      indirectRecursiveHelperProperty: purify.Maybe<IndirectRecursiveHelperClass>;
    }
  > {
    const $identifier: IndirectRecursiveClass.$Identifier =
      $resource.identifier;
    const _indirectRecursiveHelperPropertyEither: purify.Either<
      Error,
      purify.Maybe<IndirectRecursiveHelperClass>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.indirectRecursiveHelperProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            IndirectRecursiveHelperClass.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<IndirectRecursiveHelperClass>
            >({
              object: purify.Maybe.empty(),
              predicate:
                IndirectRecursiveClass.$properties
                  .indirectRecursiveHelperProperty["identifier"],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_indirectRecursiveHelperPropertyEither.isLeft()) {
      return _indirectRecursiveHelperPropertyEither;
    }

    const indirectRecursiveHelperProperty =
      _indirectRecursiveHelperPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, indirectRecursiveHelperProperty });
  }

  export const $properties = {
    indirectRecursiveHelperProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/indirectRecursiveHelperProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IndirectRecursiveClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        IndirectRecursiveClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IndirectRecursiveClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(_parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [];
  }
}
/**
 * Shape with sh:in properties.
 */
export class InPropertiesClass {
  private _$identifier?: InPropertiesClass.$Identifier;
  readonly $type = "InPropertiesClass";
  readonly inBooleansProperty: purify.Maybe<true>;
  readonly inDateTimesProperty: purify.Maybe<Date>;
  readonly inIrisProperty: purify.Maybe<
    rdfjs.NamedNode<
      | "http://example.com/InPropertiesIri1"
      | "http://example.com/InPropertiesIri2"
    >
  >;
  readonly inNumbersProperty: purify.Maybe<1 | 2>;
  readonly inStringsProperty: purify.Maybe<"text" | "html">;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly inBooleansProperty?: purify.Maybe<true> | true;
    readonly inDateTimesProperty?: Date | purify.Maybe<Date>;
    readonly inIrisProperty?:
      | "http://example.com/InPropertiesIri1"
      | "http://example.com/InPropertiesIri2"
      | purify.Maybe<
          rdfjs.NamedNode<
            | "http://example.com/InPropertiesIri1"
            | "http://example.com/InPropertiesIri2"
          >
        >
      | rdfjs.NamedNode<
          | "http://example.com/InPropertiesIri1"
          | "http://example.com/InPropertiesIri2"
        >;
    readonly inNumbersProperty?: 1 | 2 | purify.Maybe<1 | 2>;
    readonly inStringsProperty?:
      | "text"
      | "html"
      | purify.Maybe<"text" | "html">;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.inBooleansProperty)) {
      this.inBooleansProperty = parameters?.inBooleansProperty;
    } else if (typeof parameters?.inBooleansProperty === "boolean") {
      this.inBooleansProperty = purify.Maybe.of(parameters?.inBooleansProperty);
    } else if (typeof parameters?.inBooleansProperty === "undefined") {
      this.inBooleansProperty = purify.Maybe.empty();
    } else {
      this.inBooleansProperty = parameters?.inBooleansProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.inDateTimesProperty)) {
      this.inDateTimesProperty = parameters?.inDateTimesProperty;
    } else if (
      typeof parameters?.inDateTimesProperty === "object" &&
      parameters?.inDateTimesProperty instanceof Date
    ) {
      this.inDateTimesProperty = purify.Maybe.of(
        parameters?.inDateTimesProperty,
      );
    } else if (typeof parameters?.inDateTimesProperty === "undefined") {
      this.inDateTimesProperty = purify.Maybe.empty();
    } else {
      this.inDateTimesProperty =
        parameters?.inDateTimesProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.inIrisProperty)) {
      this.inIrisProperty = parameters?.inIrisProperty;
    } else if (typeof parameters?.inIrisProperty === "object") {
      this.inIrisProperty = purify.Maybe.of(parameters?.inIrisProperty);
    } else if (typeof parameters?.inIrisProperty === "string") {
      this.inIrisProperty = purify.Maybe.of(
        dataFactory.namedNode(parameters?.inIrisProperty),
      );
    } else if (typeof parameters?.inIrisProperty === "undefined") {
      this.inIrisProperty = purify.Maybe.empty();
    } else {
      this.inIrisProperty = parameters?.inIrisProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.inNumbersProperty)) {
      this.inNumbersProperty = parameters?.inNumbersProperty;
    } else if (typeof parameters?.inNumbersProperty === "number") {
      this.inNumbersProperty = purify.Maybe.of(parameters?.inNumbersProperty);
    } else if (typeof parameters?.inNumbersProperty === "undefined") {
      this.inNumbersProperty = purify.Maybe.empty();
    } else {
      this.inNumbersProperty = parameters?.inNumbersProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.inStringsProperty)) {
      this.inStringsProperty = parameters?.inStringsProperty;
    } else if (typeof parameters?.inStringsProperty === "string") {
      this.inStringsProperty = purify.Maybe.of(parameters?.inStringsProperty);
    } else if (typeof parameters?.inStringsProperty === "undefined") {
      this.inStringsProperty = purify.Maybe.empty();
    } else {
      this.inStringsProperty = parameters?.inStringsProperty satisfies never;
    }
  }

  get $identifier(): InPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: InPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.inBooleansProperty,
          other.inBooleansProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inBooleansProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.inDateTimesProperty,
          other.inDateTimesProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inDateTimesProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.inIrisProperty,
          other.inIrisProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inIrisProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.inNumbersProperty,
          other.inNumbersProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inNumbersProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.inStringsProperty,
          other.inStringsProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inStringsProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.inBooleansProperty.ifJust((value0) => {
      _hasher.update(value0.toString());
    });
    this.inDateTimesProperty.ifJust((value0) => {
      _hasher.update(value0.toISOString());
    });
    this.inIrisProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    this.inNumbersProperty.ifJust((value0) => {
      _hasher.update(value0.toString());
    });
    this.inStringsProperty.ifJust((value0) => {
      _hasher.update(value0);
    });
    return _hasher;
  }

  $toJson(): InPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        inBooleansProperty: this.inBooleansProperty
          .map((item) => item)
          .extract(),
        inDateTimesProperty: this.inDateTimesProperty
          .map((item) => item.toISOString())
          .extract(),
        inIrisProperty: this.inIrisProperty
          .map((item) => ({ "@id": item.value }))
          .extract(),
        inNumbersProperty: this.inNumbersProperty.map((item) => item).extract(),
        inStringsProperty: this.inStringsProperty.map((item) => item).extract(),
      } satisfies InPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      InPropertiesClass.$properties.inBooleansProperty["identifier"],
      ...this.inBooleansProperty.toList().flat(),
    );
    resource.add(
      InPropertiesClass.$properties.inDateTimesProperty["identifier"],
      ...this.inDateTimesProperty.toList().flatMap((value) => [
        rdfLiteral.toRdf(value, {
          dataFactory,
          datatype: $RdfVocabularies.xsd.dateTime,
        }),
      ]),
    );
    resource.add(
      InPropertiesClass.$properties.inIrisProperty["identifier"],
      ...this.inIrisProperty.toList(),
    );
    resource.add(
      InPropertiesClass.$properties.inNumbersProperty["identifier"],
      ...this.inNumbersProperty.toList(),
    );
    resource.add(
      InPropertiesClass.$properties.inStringsProperty["identifier"],
      ...this.inStringsProperty.toList(),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace InPropertiesClass {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "InPropertiesClass";
    readonly inBooleansProperty?: true;
    readonly inDateTimesProperty?: string;
    readonly inIrisProperty?: {
      readonly "@id":
        | "http://example.com/InPropertiesIri1"
        | "http://example.com/InPropertiesIri2";
    };
    readonly inNumbersProperty?: 1 | 2;
    readonly inStringsProperty?: "text" | "html";
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      inBooleansProperty: purify.Maybe<true>;
      inDateTimesProperty: purify.Maybe<Date>;
      inIrisProperty: purify.Maybe<
        rdfjs.NamedNode<
          | "http://example.com/InPropertiesIri1"
          | "http://example.com/InPropertiesIri2"
        >
      >;
      inNumbersProperty: purify.Maybe<1 | 2>;
      inStringsProperty: purify.Maybe<"text" | "html">;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const inBooleansProperty = purify.Maybe.fromNullable(
      $jsonObject["inBooleansProperty"],
    );
    const inDateTimesProperty = purify.Maybe.fromNullable(
      $jsonObject["inDateTimesProperty"],
    ).map((item) => new Date(item));
    const inIrisProperty = purify.Maybe.fromNullable(
      $jsonObject["inIrisProperty"],
    ).map((item) => dataFactory.namedNode(item["@id"]));
    const inNumbersProperty = purify.Maybe.fromNullable(
      $jsonObject["inNumbersProperty"],
    );
    const inStringsProperty = purify.Maybe.fromNullable(
      $jsonObject["inStringsProperty"],
    );
    return purify.Either.of({
      $identifier,
      inBooleansProperty,
      inDateTimesProperty,
      inIrisProperty,
      inNumbersProperty,
      inStringsProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, InPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new InPropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "InPropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/inBooleansProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/inDateTimesProperty`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/inIrisProperty`, type: "Control" },
        {
          scope: `${scopePrefix}/properties/inNumbersProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/inStringsProperty`,
          type: "Control",
        },
      ],
      label: "InPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("InPropertiesClass"),
      inBooleansProperty: zod.literal(true).optional(),
      inDateTimesProperty: zod.string().datetime().optional(),
      inIrisProperty: zod
        .object({
          "@id": zod.enum([
            "http://example.com/InPropertiesIri1",
            "http://example.com/InPropertiesIri2",
          ]),
        })
        .optional(),
      inNumbersProperty: zod.union([zod.literal(1), zod.literal(2)]).optional(),
      inStringsProperty: zod.enum(["text", "html"]).optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, InPropertiesClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return InPropertiesClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new InPropertiesClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      inBooleansProperty: purify.Maybe<true>;
      inDateTimesProperty: purify.Maybe<Date>;
      inIrisProperty: purify.Maybe<
        rdfjs.NamedNode<
          | "http://example.com/InPropertiesIri1"
          | "http://example.com/InPropertiesIri2"
        >
      >;
      inNumbersProperty: purify.Maybe<1 | 2>;
      inStringsProperty: purify.Maybe<"text" | "html">;
    }
  > {
    const $identifier: InPropertiesClass.$Identifier = $resource.identifier;
    const _inBooleansPropertyEither: purify.Either<
      Error,
      purify.Maybe<true>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.inBooleansProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toBoolean().chain((value) =>
            value === true
              ? purify.Either.of<Error, true>(value)
              : purify.Left<Error, true>(
                  new rdfjsResource.Resource.MistypedValueError({
                    actualValue: rdfLiteral.toRdf(value),
                    expectedValueType: "true",
                    focusResource: $resource,
                    predicate:
                      InPropertiesClass.$properties.inBooleansProperty[
                        "identifier"
                      ],
                  }),
                ),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<true>>({
              object: purify.Maybe.empty(),
              predicate:
                InPropertiesClass.$properties.inBooleansProperty["identifier"],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_inBooleansPropertyEither.isLeft()) {
      return _inBooleansPropertyEither;
    }

    const inBooleansProperty = _inBooleansPropertyEither.unsafeCoerce();
    const _inDateTimesPropertyEither: purify.Either<
      Error,
      purify.Maybe<Date>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.inDateTimesProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toDate().chain((value) => {
            if (value.getTime() === 1523268000000) {
              return purify.Either.of<Error, Date>(value);
            }
            return purify.Left<Error, Date>(
              new rdfjsResource.Resource.MistypedValueError({
                actualValue: rdfLiteral.toRdf(value, {
                  dataFactory,
                  datatype: $RdfVocabularies.xsd.dateTime,
                }),
                expectedValueType: "Date",
                focusResource: $resource,
                predicate:
                  InPropertiesClass.$properties.inDateTimesProperty[
                    "identifier"
                  ],
              }),
            );
          }),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<Date>>({
              object: purify.Maybe.empty(),
              predicate:
                InPropertiesClass.$properties.inDateTimesProperty["identifier"],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_inDateTimesPropertyEither.isLeft()) {
      return _inDateTimesPropertyEither;
    }

    const inDateTimesProperty = _inDateTimesPropertyEither.unsafeCoerce();
    const _inIrisPropertyEither: purify.Either<
      Error,
      purify.Maybe<
        rdfjs.NamedNode<
          | "http://example.com/InPropertiesIri1"
          | "http://example.com/InPropertiesIri2"
        >
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.inIrisProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toIri().chain((iri) => {
            switch (iri.value) {
              case "http://example.com/InPropertiesIri1":
                return purify.Either.of<
                  Error,
                  rdfjs.NamedNode<
                    | "http://example.com/InPropertiesIri1"
                    | "http://example.com/InPropertiesIri2"
                  >
                >(
                  iri as rdfjs.NamedNode<"http://example.com/InPropertiesIri1">,
                );
              case "http://example.com/InPropertiesIri2":
                return purify.Either.of<
                  Error,
                  rdfjs.NamedNode<
                    | "http://example.com/InPropertiesIri1"
                    | "http://example.com/InPropertiesIri2"
                  >
                >(
                  iri as rdfjs.NamedNode<"http://example.com/InPropertiesIri2">,
                );
              default:
                return purify.Left<
                  Error,
                  rdfjs.NamedNode<
                    | "http://example.com/InPropertiesIri1"
                    | "http://example.com/InPropertiesIri2"
                  >
                >(
                  new rdfjsResource.Resource.MistypedValueError({
                    actualValue: iri,
                    expectedValueType:
                      'rdfjs.NamedNode<"http://example.com/InPropertiesIri1" | "http://example.com/InPropertiesIri2">',
                    focusResource: $resource,
                    predicate:
                      InPropertiesClass.$properties.inIrisProperty[
                        "identifier"
                      ],
                  }),
                );
            }
          }),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<
                rdfjs.NamedNode<
                  | "http://example.com/InPropertiesIri1"
                  | "http://example.com/InPropertiesIri2"
                >
              >
            >({
              object: purify.Maybe.empty(),
              predicate:
                InPropertiesClass.$properties.inIrisProperty["identifier"],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_inIrisPropertyEither.isLeft()) {
      return _inIrisPropertyEither;
    }

    const inIrisProperty = _inIrisPropertyEither.unsafeCoerce();
    const _inNumbersPropertyEither: purify.Either<
      Error,
      purify.Maybe<1 | 2>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.inNumbersProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toNumber().chain((value) => {
            switch (value) {
              case 1:
              case 2:
                return purify.Either.of<Error, 1 | 2>(value);
              default:
                return purify.Left<Error, 1 | 2>(
                  new rdfjsResource.Resource.MistypedValueError({
                    actualValue: rdfLiteral.toRdf(value),
                    expectedValueType: "1 | 2",
                    focusResource: $resource,
                    predicate:
                      InPropertiesClass.$properties.inNumbersProperty[
                        "identifier"
                      ],
                  }),
                );
            }
          }),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<1 | 2>>({
              object: purify.Maybe.empty(),
              predicate:
                InPropertiesClass.$properties.inNumbersProperty["identifier"],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_inNumbersPropertyEither.isLeft()) {
      return _inNumbersPropertyEither;
    }

    const inNumbersProperty = _inNumbersPropertyEither.unsafeCoerce();
    const _inStringsPropertyEither: purify.Either<
      Error,
      purify.Maybe<"text" | "html">
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.inStringsProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => {
        if (!$preferredLanguages || $preferredLanguages.length === 0) {
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(values);
        }

        const literalValuesEither = values.chainMap((value) =>
          value.toLiteral(),
        );
        if (literalValuesEither.isLeft()) {
          return literalValuesEither;
        }
        const literalValues = literalValuesEither.unsafeCoerce();

        // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
        // Within a preferredLanguage the literals may be in any order.
        let filteredLiteralValues:
          | rdfjsResource.Resource.Values<rdfjs.Literal>
          | undefined;
        for (const preferredLanguage of $preferredLanguages) {
          if (!filteredLiteralValues) {
            filteredLiteralValues = literalValues.filter(
              (value) => value.language === preferredLanguage,
            );
          } else {
            filteredLiteralValues = filteredLiteralValues.concat(
              ...literalValues
                .filter((value) => value.language === preferredLanguage)
                .toArray(),
            );
          }
        }

        return purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
        >(
          filteredLiteralValues!.map(
            (literalValue) =>
              new rdfjsResource.Resource.Value({
                object: literalValue,
                predicate:
                  InPropertiesClass.$properties.inStringsProperty["identifier"],
                subject: $resource,
              }),
          ),
        );
      })
      .chain((values) =>
        values.chainMap((value) =>
          value.toString().chain((string_) => {
            switch (string_) {
              case "text":
              case "html":
                return purify.Either.of<Error, "text" | "html">(string_);
              default:
                return purify.Left<Error, "text" | "html">(
                  new rdfjsResource.Resource.MistypedValueError({
                    actualValue: value.toTerm(),
                    expectedValueType: '"text" | "html"',
                    focusResource: $resource,
                    predicate:
                      InPropertiesClass.$properties.inStringsProperty[
                        "identifier"
                      ],
                  }),
                );
            }
          }),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<"text" | "html">
            >({
              object: purify.Maybe.empty(),
              predicate:
                InPropertiesClass.$properties.inStringsProperty["identifier"],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_inStringsPropertyEither.isLeft()) {
      return _inStringsPropertyEither;
    }

    const inStringsProperty = _inStringsPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      inBooleansProperty,
      inDateTimesProperty,
      inIrisProperty,
      inNumbersProperty,
      inStringsProperty,
    });
  }

  export const $properties = {
    inBooleansProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/inBooleansProperty",
      ),
    },
    inDateTimesProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/inDateTimesProperty",
      ),
    },
    inIrisProperty: {
      identifier: dataFactory.namedNode("http://example.com/inIrisProperty"),
    },
    inNumbersProperty: {
      identifier: dataFactory.namedNode("http://example.com/inNumbersProperty"),
    },
    inStringsProperty: {
      identifier: dataFactory.namedNode("http://example.com/inStringsProperty"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InPropertiesClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        InPropertiesClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("inPropertiesClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "inPropertiesClass");
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}InBooleansProperty`),
      predicate: InPropertiesClass.$properties.inBooleansProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}InDateTimesProperty`),
      predicate:
        InPropertiesClass.$properties.inDateTimesProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}InIrisProperty`),
      predicate: InPropertiesClass.$properties.inIrisProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}InNumbersProperty`),
      predicate: InPropertiesClass.$properties.inNumbersProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}InStringsProperty`),
      predicate: InPropertiesClass.$properties.inStringsProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("inPropertiesClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "inPropertiesClass");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}InBooleansProperty`,
                ),
                predicate:
                  InPropertiesClass.$properties.inBooleansProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}InDateTimesProperty`,
                ),
                predicate:
                  InPropertiesClass.$properties.inDateTimesProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}InIrisProperty`,
                ),
                predicate:
                  InPropertiesClass.$properties.inIrisProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}InNumbersProperty`,
                ),
                predicate:
                  InPropertiesClass.$properties.inNumbersProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}InStringsProperty`,
                ),
                predicate:
                  InPropertiesClass.$properties.inStringsProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...[parameters?.preferredLanguages ?? []]
            .filter((languages) => languages.length > 0)
            .map((languages) =>
              languages.map((language) => ({
                type: "operation" as const,
                operator: "=",
                args: [
                  {
                    type: "operation" as const,
                    operator: "lang",
                    args: [
                      dataFactory.variable!(
                        `${variablePrefix}InStringsProperty`,
                      ),
                    ],
                  },
                  dataFactory.literal(language),
                ],
              })),
            )
            .map((langEqualsExpressions) => ({
              type: "filter" as const,
              expression: langEqualsExpressions.reduce(
                (reducedExpression, langEqualsExpression) => {
                  if (reducedExpression === null) {
                    return langEqualsExpression;
                  }
                  return {
                    type: "operation" as const,
                    operator: "||",
                    args: [reducedExpression, langEqualsExpression],
                  };
                },
                null as sparqljs.Expression | null,
              ) as sparqljs.Expression,
            })),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Shape with sh:in constraining its identifier.
 */
export class InIdentifierClass {
  readonly $identifier: InIdentifierClass.$Identifier;
  readonly $type = "InIdentifierClass";
  readonly inIdentifierProperty: purify.Maybe<string>;

  constructor(parameters: {
    readonly $identifier:
      | "http://example.com/InIdentifierInstance1"
      | "http://example.com/InIdentifierInstance2"
      | rdfjs.NamedNode<
          | "http://example.com/InIdentifierInstance1"
          | "http://example.com/InIdentifierInstance2"
        >;
    readonly inIdentifierProperty?: purify.Maybe<string> | string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this.$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this.$identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      this.$identifier = parameters.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.inIdentifierProperty)) {
      this.inIdentifierProperty = parameters.inIdentifierProperty;
    } else if (typeof parameters.inIdentifierProperty === "string") {
      this.inIdentifierProperty = purify.Maybe.of(
        parameters.inIdentifierProperty,
      );
    } else if (typeof parameters.inIdentifierProperty === "undefined") {
      this.inIdentifierProperty = purify.Maybe.empty();
    } else {
      this.inIdentifierProperty =
        parameters.inIdentifierProperty satisfies never;
    }
  }

  $equals(other: InIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.inIdentifierProperty,
          other.inIdentifierProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inIdentifierProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.inIdentifierProperty.ifJust((value0) => {
      _hasher.update(value0);
    });
    return _hasher;
  }

  $toJson(): InIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
        inIdentifierProperty: this.inIdentifierProperty
          .map((item) => item)
          .extract(),
      } satisfies InIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      InIdentifierClass.$properties.inIdentifierProperty["identifier"],
      ...this.inIdentifierProperty.toList(),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace InIdentifierClass {
  export type $Identifier = rdfjs.NamedNode<
    | "http://example.com/InIdentifierInstance1"
    | "http://example.com/InIdentifierInstance2"
  >;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<
      Error,
      rdfjs.NamedNode<
        | "http://example.com/InIdentifierInstance1"
        | "http://example.com/InIdentifierInstance2"
      >
    > {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      )
        .chain((identifier) =>
          identifier.termType === "NamedNode"
            ? purify.Either.of(identifier)
            : purify.Left(new Error("expected identifier to be NamedNode")),
        )
        .chain((identifier) => {
          switch (identifier.value) {
            case "http://example.com/InIdentifierInstance1":
              return purify.Either.of(
                identifier as rdfjs.NamedNode<"http://example.com/InIdentifierInstance1">,
              );
            case "http://example.com/InIdentifierInstance2":
              return purify.Either.of(
                identifier as rdfjs.NamedNode<"http://example.com/InIdentifierInstance2">,
              );
            default:
              return purify.Left(
                new Error(
                  "expected NamedNode identifier to be one of http://example.com/InIdentifierInstance1 http://example.com/InIdentifierInstance2",
                ),
              );
          }
        }) as purify.Either<
        Error,
        rdfjs.NamedNode<
          | "http://example.com/InIdentifierInstance1"
          | "http://example.com/InIdentifierInstance2"
        >
      >;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "InIdentifierClass";
    readonly inIdentifierProperty?: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.NamedNode<
        | "http://example.com/InIdentifierInstance1"
        | "http://example.com/InIdentifierInstance2"
      >;
      inIdentifierProperty: purify.Maybe<string>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const inIdentifierProperty = purify.Maybe.fromNullable(
      $jsonObject["inIdentifierProperty"],
    );
    return purify.Either.of({ $identifier, inIdentifierProperty });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, InIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new InIdentifierClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "InIdentifierClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/inIdentifierProperty`,
          type: "Control",
        },
      ],
      label: "InIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.enum([
        "http://example.com/InIdentifierInstance1",
        "http://example.com/InIdentifierInstance2",
      ]),
      $type: zod.literal("InIdentifierClass"),
      inIdentifierProperty: zod.string().optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, InIdentifierClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return InIdentifierClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new InIdentifierClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.NamedNode<
        | "http://example.com/InIdentifierInstance1"
        | "http://example.com/InIdentifierInstance2"
      >;
      inIdentifierProperty: purify.Maybe<string>;
    }
  > {
    let $identifier: InIdentifierClass.$Identifier;
    switch ($resource.identifier.value) {
      case "http://example.com/InIdentifierInstance1":
        $identifier = dataFactory.namedNode(
          "http://example.com/InIdentifierInstance1",
        );
        break;
      case "http://example.com/InIdentifierInstance2":
        $identifier = dataFactory.namedNode(
          "http://example.com/InIdentifierInstance2",
        );
        break;
      default:
        return purify.Left(
          new rdfjsResource.Resource.MistypedValueError({
            actualValue: $resource.identifier,
            expectedValueType:
              'rdfjs.NamedNode<"http://example.com/InIdentifierInstance1" | "http://example.com/InIdentifierInstance2">',
            focusResource: $resource,
            predicate: $RdfVocabularies.rdf.subject,
          }),
        );
    }

    const _inIdentifierPropertyEither: purify.Either<
      Error,
      purify.Maybe<string>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.inIdentifierProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => {
        if (!$preferredLanguages || $preferredLanguages.length === 0) {
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(values);
        }

        const literalValuesEither = values.chainMap((value) =>
          value.toLiteral(),
        );
        if (literalValuesEither.isLeft()) {
          return literalValuesEither;
        }
        const literalValues = literalValuesEither.unsafeCoerce();

        // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
        // Within a preferredLanguage the literals may be in any order.
        let filteredLiteralValues:
          | rdfjsResource.Resource.Values<rdfjs.Literal>
          | undefined;
        for (const preferredLanguage of $preferredLanguages) {
          if (!filteredLiteralValues) {
            filteredLiteralValues = literalValues.filter(
              (value) => value.language === preferredLanguage,
            );
          } else {
            filteredLiteralValues = filteredLiteralValues.concat(
              ...literalValues
                .filter((value) => value.language === preferredLanguage)
                .toArray(),
            );
          }
        }

        return purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
        >(
          filteredLiteralValues!.map(
            (literalValue) =>
              new rdfjsResource.Resource.Value({
                object: literalValue,
                predicate:
                  InIdentifierClass.$properties.inIdentifierProperty[
                    "identifier"
                  ],
                subject: $resource,
              }),
          ),
        );
      })
      .chain((values) => values.chainMap((value) => value.toString()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<string>>({
              object: purify.Maybe.empty(),
              predicate:
                InIdentifierClass.$properties.inIdentifierProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_inIdentifierPropertyEither.isLeft()) {
      return _inIdentifierPropertyEither;
    }

    const inIdentifierProperty = _inIdentifierPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, inIdentifierProperty });
  }

  export const $properties = {
    inIdentifierProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/inIdentifierProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InIdentifierClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        InIdentifierClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("inIdentifierClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "inIdentifierClass");
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}InIdentifierProperty`),
      predicate:
        InIdentifierClass.$properties.inIdentifierProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("inIdentifierClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "inIdentifierClass");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}InIdentifierProperty`,
                ),
                predicate:
                  InIdentifierClass.$properties.inIdentifierProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
          ...[parameters?.preferredLanguages ?? []]
            .filter((languages) => languages.length > 0)
            .map((languages) =>
              languages.map((language) => ({
                type: "operation" as const,
                operator: "=",
                args: [
                  {
                    type: "operation" as const,
                    operator: "lang",
                    args: [
                      dataFactory.variable!(
                        `${variablePrefix}InIdentifierProperty`,
                      ),
                    ],
                  },
                  dataFactory.literal(language),
                ],
              })),
            )
            .map((langEqualsExpressions) => ({
              type: "filter" as const,
              expression: langEqualsExpressions.reduce(
                (reducedExpression, langEqualsExpression) => {
                  if (reducedExpression === null) {
                    return langEqualsExpression;
                  }
                  return {
                    type: "operation" as const,
                    operator: "||",
                    args: [reducedExpression, langEqualsExpression],
                  };
                },
                null as sparqljs.Expression | null,
              ) as sparqljs.Expression,
            })),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Shape with sh:hasValue properties.
 */
export class HasValuePropertiesClass {
  private _$identifier?: HasValuePropertiesClass.$Identifier;
  readonly $type = "HasValuePropertiesClass";
  readonly hasIriValueProperty: rdfjs.NamedNode;
  readonly hasLiteralValueProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly hasIriValueProperty: rdfjs.NamedNode | string;
    readonly hasLiteralValueProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    if (typeof parameters.hasIriValueProperty === "object") {
      this.hasIriValueProperty = parameters.hasIriValueProperty;
    } else if (typeof parameters.hasIriValueProperty === "string") {
      this.hasIriValueProperty = dataFactory.namedNode(
        parameters.hasIriValueProperty,
      );
    } else {
      this.hasIriValueProperty = parameters.hasIriValueProperty satisfies never;
    }

    this.hasLiteralValueProperty = parameters.hasLiteralValueProperty;
  }

  get $identifier(): HasValuePropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: HasValuePropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $booleanEquals(
          this.hasIriValueProperty,
          other.hasIriValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "hasIriValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.hasLiteralValueProperty,
          other.hasLiteralValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "hasLiteralValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.hasIriValueProperty.termType);
    _hasher.update(this.hasIriValueProperty.value);
    _hasher.update(this.hasLiteralValueProperty);
    return _hasher;
  }

  $toJson(): HasValuePropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        hasIriValueProperty: { "@id": this.hasIriValueProperty.value },
        hasLiteralValueProperty: this.hasLiteralValueProperty,
      } satisfies HasValuePropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      HasValuePropertiesClass.$properties.hasIriValueProperty["identifier"],
      ...[this.hasIriValueProperty],
    );
    resource.add(
      HasValuePropertiesClass.$properties.hasLiteralValueProperty["identifier"],
      ...[this.hasLiteralValueProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace HasValuePropertiesClass {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "HasValuePropertiesClass";
    readonly hasIriValueProperty: { readonly "@id": string };
    readonly hasLiteralValueProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      hasIriValueProperty: rdfjs.NamedNode;
      hasLiteralValueProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const hasIriValueProperty = dataFactory.namedNode(
      $jsonObject["hasIriValueProperty"]["@id"],
    );
    const hasLiteralValueProperty = $jsonObject["hasLiteralValueProperty"];
    return purify.Either.of({
      $identifier,
      hasIriValueProperty,
      hasLiteralValueProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, HasValuePropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new HasValuePropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "HasValuePropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/hasIriValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/hasLiteralValueProperty`,
          type: "Control",
        },
      ],
      label: "HasValuePropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("HasValuePropertiesClass"),
      hasIriValueProperty: zod.object({ "@id": zod.string().min(1) }),
      hasLiteralValueProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, HasValuePropertiesClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return HasValuePropertiesClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new HasValuePropertiesClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      hasIriValueProperty: rdfjs.NamedNode;
      hasLiteralValueProperty: string;
    }
  > {
    const $identifier: HasValuePropertiesClass.$Identifier =
      $resource.identifier;
    const _hasIriValuePropertyEither: purify.Either<Error, rdfjs.NamedNode> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.hasIriValueProperty["identifier"], {
          unique: true,
        }),
      )
        .chain((values) => {
          for (const hasValue of [
            dataFactory.namedNode(
              "http://example.com/HasValuePropertiesClassIri1",
            ),
          ]) {
            const findResult = values.find((value) =>
              value.toTerm().equals(hasValue),
            );
            if (findResult.isLeft()) {
              return findResult;
            }
          }
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(values);
        })
        .chain((values) => values.chainMap((value) => value.toIri()))
        .chain((values) => values.head());
    if (_hasIriValuePropertyEither.isLeft()) {
      return _hasIriValuePropertyEither;
    }

    const hasIriValueProperty = _hasIriValuePropertyEither.unsafeCoerce();
    const _hasLiteralValuePropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.hasLiteralValueProperty["identifier"], {
          unique: true,
        }),
      )
        .chain((values) => {
          for (const hasValue of [dataFactory.literal("test")]) {
            const findResult = values.find((value) =>
              value.toTerm().equals(hasValue),
            );
            if (findResult.isLeft()) {
              return findResult;
            }
          }
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(values);
        })
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    HasValuePropertiesClass.$properties.hasLiteralValueProperty[
                      "identifier"
                    ],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_hasLiteralValuePropertyEither.isLeft()) {
      return _hasLiteralValuePropertyEither;
    }

    const hasLiteralValueProperty =
      _hasLiteralValuePropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      hasIriValueProperty,
      hasLiteralValueProperty,
    });
  }

  export const $properties = {
    hasIriValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/hasIriValueProperty",
      ),
    },
    hasLiteralValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/hasLiteralValueProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        HasValuePropertiesClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        HasValuePropertiesClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      HasValuePropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("hasValuePropertiesClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "hasValuePropertiesClass");
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}HasIriValueProperty`),
      predicate:
        HasValuePropertiesClass.$properties.hasIriValueProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}HasLiteralValueProperty`),
      predicate:
        HasValuePropertiesClass.$properties.hasLiteralValueProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("hasValuePropertiesClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "hasValuePropertiesClass");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}HasIriValueProperty`,
            ),
            predicate:
              HasValuePropertiesClass.$properties.hasIriValueProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}HasLiteralValueProperty`,
            ),
            predicate:
              HasValuePropertiesClass.$properties.hasLiteralValueProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}HasLiteralValueProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Node shape that references the ExternClass in a property.
 */
export class ExternClassPropertyClass {
  private _$identifier?: ExternClassPropertyClass.$Identifier;
  readonly $type = "ExternClassPropertyClass";
  readonly externClassProperty: purify.Maybe<ExternClass>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly externClassProperty?: ExternClass | purify.Maybe<ExternClass>;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.externClassProperty)) {
      this.externClassProperty = parameters?.externClassProperty;
    } else if (
      typeof parameters?.externClassProperty === "object" &&
      parameters?.externClassProperty instanceof ExternClass
    ) {
      this.externClassProperty = purify.Maybe.of(
        parameters?.externClassProperty,
      );
    } else if (typeof parameters?.externClassProperty === "undefined") {
      this.externClassProperty = purify.Maybe.empty();
    } else {
      this.externClassProperty =
        parameters?.externClassProperty satisfies never;
    }
  }

  get $identifier(): ExternClassPropertyClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: ExternClassPropertyClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.externClassProperty,
          other.externClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "externClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.externClassProperty.ifJust((value0) => {
      value0.$hash(_hasher);
    });
    return _hasher;
  }

  $toJson(): ExternClassPropertyClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        externClassProperty: this.externClassProperty
          .map((item) => item.$toJson())
          .extract(),
      } satisfies ExternClassPropertyClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      ExternClassPropertyClass.$properties.externClassProperty["identifier"],
      ...this.externClassProperty
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ExternClassPropertyClass {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ExternClassPropertyClass";
    readonly externClassProperty?: ExternClass.$Json;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      externClassProperty: purify.Maybe<ExternClass>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const externClassProperty = purify.Maybe.fromNullable(
      $jsonObject["externClassProperty"],
    ).map((item) => ExternClass.$fromJson(item).unsafeCoerce());
    return purify.Either.of({ $identifier, externClassProperty });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ExternClassPropertyClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ExternClassPropertyClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ExternClassPropertyClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        ExternClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/externClassProperty`,
        }),
      ],
      label: "ExternClassPropertyClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("ExternClassPropertyClass"),
      externClassProperty: ExternClass.$jsonZodSchema().optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ExternClassPropertyClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ExternClassPropertyClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ExternClassPropertyClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      externClassProperty: purify.Maybe<ExternClass>;
    }
  > {
    const $identifier: ExternClassPropertyClass.$Identifier =
      $resource.identifier;
    const _externClassPropertyEither: purify.Either<
      Error,
      purify.Maybe<ExternClass>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.externClassProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            ExternClass.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<ExternClass>>({
              object: purify.Maybe.empty(),
              predicate:
                ExternClassPropertyClass.$properties.externClassProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_externClassPropertyEither.isLeft()) {
      return _externClassPropertyEither;
    }

    const externClassProperty = _externClassPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, externClassProperty });
  }

  export const $properties = {
    externClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/externClassProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ExternClassPropertyClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ExternClassPropertyClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ExternClassPropertyClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("externClassPropertyClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "externClassPropertyClass");
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}ExternClassProperty`),
      predicate:
        ExternClassPropertyClass.$properties.externClassProperty["identifier"],
      subject,
    });
    triples.push(
      ...ExternClass.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}ExternClassProperty`),
        variablePrefix: `${variablePrefix}ExternClassProperty`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("externClassPropertyClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "externClassPropertyClass");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}ExternClassProperty`,
                ),
                predicate:
                  ExternClassPropertyClass.$properties.externClassProperty[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
          ...ExternClass.$sparqlWherePatterns({
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${variablePrefix}ExternClassProperty`,
            ),
            variablePrefix: `${variablePrefix}ExternClassProperty`,
          }),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Shape with custom rdf:type's.
 *
 * The shaclmate:rdfType is expected on deserialization and added on serialization.
 */
export class ExplicitRdfTypeClass {
  private _$identifier?: ExplicitRdfTypeClass.$Identifier;
  readonly $type = "ExplicitRdfTypeClass";
  readonly explicitRdfTypeProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly explicitRdfTypeProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.explicitRdfTypeProperty = parameters.explicitRdfTypeProperty;
  }

  get $identifier(): ExplicitRdfTypeClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: ExplicitRdfTypeClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.explicitRdfTypeProperty,
          other.explicitRdfTypeProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "explicitRdfTypeProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.explicitRdfTypeProperty);
    return _hasher;
  }

  $toJson(): ExplicitRdfTypeClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        explicitRdfTypeProperty: this.explicitRdfTypeProperty,
      } satisfies ExplicitRdfTypeClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode("http://example.com/RdfType"),
      );
    }

    resource.add(
      ExplicitRdfTypeClass.$properties.explicitRdfTypeProperty["identifier"],
      ...[this.explicitRdfTypeProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ExplicitRdfTypeClass {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/RdfType",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ExplicitRdfTypeClass";
    readonly explicitRdfTypeProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      explicitRdfTypeProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const explicitRdfTypeProperty = $jsonObject["explicitRdfTypeProperty"];
    return purify.Either.of({ $identifier, explicitRdfTypeProperty });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ExplicitRdfTypeClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ExplicitRdfTypeClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ExplicitRdfTypeClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/explicitRdfTypeProperty`,
          type: "Control",
        },
      ],
      label: "ExplicitRdfTypeClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("ExplicitRdfTypeClass"),
      explicitRdfTypeProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ExplicitRdfTypeClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ExplicitRdfTypeClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ExplicitRdfTypeClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      explicitRdfTypeProperty: string;
    }
  > {
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/RdfType":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if ($resource.isInstanceOf(ExplicitRdfTypeClass.$fromRdfType)) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/RdfType)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: ExplicitRdfTypeClass.$Identifier = $resource.identifier;
    const _explicitRdfTypePropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.explicitRdfTypeProperty["identifier"], {
          unique: true,
        }),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    ExplicitRdfTypeClass.$properties.explicitRdfTypeProperty[
                      "identifier"
                    ],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_explicitRdfTypePropertyEither.isLeft()) {
      return _explicitRdfTypePropertyEither;
    }

    const explicitRdfTypeProperty =
      _explicitRdfTypePropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, explicitRdfTypeProperty });
  }

  export const $properties = {
    explicitRdfTypeProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/explicitRdfTypeProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ExplicitRdfTypeClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ExplicitRdfTypeClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ExplicitRdfTypeClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("explicitRdfTypeClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "explicitRdfTypeClass");
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}ExplicitRdfTypeProperty`),
      predicate:
        ExplicitRdfTypeClass.$properties.explicitRdfTypeProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("explicitRdfTypeClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "explicitRdfTypeClass");
    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ExplicitRdfTypeClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}ExplicitRdfTypeProperty`,
            ),
            predicate:
              ExplicitRdfTypeClass.$properties.explicitRdfTypeProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}ExplicitRdfTypeProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Shape with custom rdf:type's.
 *
 * The shaclmate:fromRdfType is expected on deserialization.
 * shaclmate:toRdfType's are added an serialization.
 */
export class ExplicitFromToRdfTypesClass {
  private _$identifier?: ExplicitFromToRdfTypesClass.$Identifier;
  readonly $type = "ExplicitFromToRdfTypesClass";
  readonly explicitFromToRdfTypesProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly explicitFromToRdfTypesProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.explicitFromToRdfTypesProperty =
      parameters.explicitFromToRdfTypesProperty;
  }

  get $identifier(): ExplicitFromToRdfTypesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: ExplicitFromToRdfTypesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.explicitFromToRdfTypesProperty,
          other.explicitFromToRdfTypesProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "explicitFromToRdfTypesProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.explicitFromToRdfTypesProperty);
    return _hasher;
  }

  $toJson(): ExplicitFromToRdfTypesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        explicitFromToRdfTypesProperty: this.explicitFromToRdfTypesProperty,
      } satisfies ExplicitFromToRdfTypesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode("http://example.com/ToRdfType"),
      );
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode("http://example.com/FromRdfType"),
      );
    }

    resource.add(
      ExplicitFromToRdfTypesClass.$properties.explicitFromToRdfTypesProperty[
        "identifier"
      ],
      ...[this.explicitFromToRdfTypesProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ExplicitFromToRdfTypesClass {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/FromRdfType",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ExplicitFromToRdfTypesClass";
    readonly explicitFromToRdfTypesProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      explicitFromToRdfTypesProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const explicitFromToRdfTypesProperty =
      $jsonObject["explicitFromToRdfTypesProperty"];
    return purify.Either.of({ $identifier, explicitFromToRdfTypesProperty });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ExplicitFromToRdfTypesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ExplicitFromToRdfTypesClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ExplicitFromToRdfTypesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/explicitFromToRdfTypesProperty`,
          type: "Control",
        },
      ],
      label: "ExplicitFromToRdfTypesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("ExplicitFromToRdfTypesClass"),
      explicitFromToRdfTypesProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ExplicitFromToRdfTypesClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ExplicitFromToRdfTypesClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ExplicitFromToRdfTypesClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      explicitFromToRdfTypesProperty: string;
    }
  > {
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/FromRdfType":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $resource.isInstanceOf(ExplicitFromToRdfTypesClass.$fromRdfType)
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/FromRdfType)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: ExplicitFromToRdfTypesClass.$Identifier =
      $resource.identifier;
    const _explicitFromToRdfTypesPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.explicitFromToRdfTypesProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    ExplicitFromToRdfTypesClass.$properties
                      .explicitFromToRdfTypesProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_explicitFromToRdfTypesPropertyEither.isLeft()) {
      return _explicitFromToRdfTypesPropertyEither;
    }

    const explicitFromToRdfTypesProperty =
      _explicitFromToRdfTypesPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, explicitFromToRdfTypesProperty });
  }

  export const $properties = {
    explicitFromToRdfTypesProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/explicitFromToRdfTypesProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ExplicitFromToRdfTypesClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ExplicitFromToRdfTypesClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ExplicitFromToRdfTypesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("explicitFromToRdfTypesClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "explicitFromToRdfTypesClass");
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}ExplicitFromToRdfTypesProperty`,
      ),
      predicate:
        ExplicitFromToRdfTypesClass.$properties.explicitFromToRdfTypesProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("explicitFromToRdfTypesClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "explicitFromToRdfTypesClass");
    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ExplicitFromToRdfTypesClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}ExplicitFromToRdfTypesProperty`,
            ),
            predicate:
              ExplicitFromToRdfTypesClass.$properties
                .explicitFromToRdfTypesProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}ExplicitFromToRdfTypesProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class DirectRecursiveClass {
  private _$identifier?: DirectRecursiveClass.$Identifier;
  readonly $type = "DirectRecursiveClass";
  readonly directRecursiveProperty: purify.Maybe<DirectRecursiveClass>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly directRecursiveProperty?:
      | DirectRecursiveClass
      | purify.Maybe<DirectRecursiveClass>;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.directRecursiveProperty)) {
      this.directRecursiveProperty = parameters?.directRecursiveProperty;
    } else if (
      typeof parameters?.directRecursiveProperty === "object" &&
      parameters?.directRecursiveProperty instanceof DirectRecursiveClass
    ) {
      this.directRecursiveProperty = purify.Maybe.of(
        parameters?.directRecursiveProperty,
      );
    } else if (typeof parameters?.directRecursiveProperty === "undefined") {
      this.directRecursiveProperty = purify.Maybe.empty();
    } else {
      this.directRecursiveProperty =
        parameters?.directRecursiveProperty satisfies never;
    }
  }

  get $identifier(): DirectRecursiveClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: DirectRecursiveClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.directRecursiveProperty,
          other.directRecursiveProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "directRecursiveProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.directRecursiveProperty.ifJust((value0) => {
      value0.$hash(_hasher);
    });
    return _hasher;
  }

  $toJson(): DirectRecursiveClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        directRecursiveProperty: this.directRecursiveProperty
          .map((item) => item.$toJson())
          .extract(),
      } satisfies DirectRecursiveClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      DirectRecursiveClass.$properties.directRecursiveProperty["identifier"],
      ...this.directRecursiveProperty
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace DirectRecursiveClass {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "DirectRecursiveClass";
    readonly directRecursiveProperty?: DirectRecursiveClass.$Json;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      directRecursiveProperty: purify.Maybe<DirectRecursiveClass>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const directRecursiveProperty = purify.Maybe.fromNullable(
      $jsonObject["directRecursiveProperty"],
    ).map((item) => DirectRecursiveClass.$fromJson(item).unsafeCoerce());
    return purify.Either.of({ $identifier, directRecursiveProperty });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, DirectRecursiveClass> {
    return $propertiesFromJson(json).map(
      (properties) => new DirectRecursiveClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "DirectRecursiveClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        DirectRecursiveClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/directRecursiveProperty`,
        }),
      ],
      label: "DirectRecursiveClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("DirectRecursiveClass"),
      directRecursiveProperty: zod
        .lazy(
          (): zod.ZodType<DirectRecursiveClass.$Json> =>
            DirectRecursiveClass.$jsonZodSchema(),
        )
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, DirectRecursiveClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return DirectRecursiveClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new DirectRecursiveClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      directRecursiveProperty: purify.Maybe<DirectRecursiveClass>;
    }
  > {
    const $identifier: DirectRecursiveClass.$Identifier = $resource.identifier;
    const _directRecursivePropertyEither: purify.Either<
      Error,
      purify.Maybe<DirectRecursiveClass>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.directRecursiveProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            DirectRecursiveClass.$fromRdf(resource, {
              ...$context,
              ignoreRdfType: true,
              objectSet: $objectSet,
              preferredLanguages: $preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<DirectRecursiveClass>
            >({
              object: purify.Maybe.empty(),
              predicate:
                DirectRecursiveClass.$properties.directRecursiveProperty[
                  "identifier"
                ],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_directRecursivePropertyEither.isLeft()) {
      return _directRecursivePropertyEither;
    }

    const directRecursiveProperty =
      _directRecursivePropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, directRecursiveProperty });
  }

  export const $properties = {
    directRecursiveProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/directRecursiveProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        DirectRecursiveClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        DirectRecursiveClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      DirectRecursiveClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(_parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [];
  }
}
/**
 * Shape with sh:defaultValue properties.
 */
export class DefaultValuePropertiesClass {
  private _$identifier?: DefaultValuePropertiesClass.$Identifier;
  protected readonly _$identifierPrefix?: string;
  readonly $type = "DefaultValuePropertiesClass";
  readonly dateDefaultValueProperty: Date;
  readonly dateTimeDefaultValueProperty: Date;
  readonly falseBooleanDefaultValueProperty: boolean;
  readonly numberDefaultValueProperty: number;
  readonly stringDefaultValueProperty: string;
  readonly trueBooleanDefaultValueProperty: boolean;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly $identifierPrefix?: string;
    readonly dateDefaultValueProperty?: Date;
    readonly dateTimeDefaultValueProperty?: Date;
    readonly falseBooleanDefaultValueProperty?: boolean;
    readonly numberDefaultValueProperty?: number;
    readonly stringDefaultValueProperty?: string;
    readonly trueBooleanDefaultValueProperty?: boolean;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    this._$identifierPrefix = parameters?.$identifierPrefix;
    if (
      typeof parameters?.dateDefaultValueProperty === "object" &&
      parameters?.dateDefaultValueProperty instanceof Date
    ) {
      this.dateDefaultValueProperty = parameters?.dateDefaultValueProperty;
    } else if (typeof parameters?.dateDefaultValueProperty === "undefined") {
      this.dateDefaultValueProperty = new Date("2018-04-09T00:00:00.000Z");
    } else {
      this.dateDefaultValueProperty =
        parameters?.dateDefaultValueProperty satisfies never;
    }

    if (
      typeof parameters?.dateTimeDefaultValueProperty === "object" &&
      parameters?.dateTimeDefaultValueProperty instanceof Date
    ) {
      this.dateTimeDefaultValueProperty =
        parameters?.dateTimeDefaultValueProperty;
    } else if (
      typeof parameters?.dateTimeDefaultValueProperty === "undefined"
    ) {
      this.dateTimeDefaultValueProperty = new Date("2018-04-09T10:00:00.000Z");
    } else {
      this.dateTimeDefaultValueProperty =
        parameters?.dateTimeDefaultValueProperty satisfies never;
    }

    if (typeof parameters?.falseBooleanDefaultValueProperty === "boolean") {
      this.falseBooleanDefaultValueProperty =
        parameters?.falseBooleanDefaultValueProperty;
    } else if (
      typeof parameters?.falseBooleanDefaultValueProperty === "undefined"
    ) {
      this.falseBooleanDefaultValueProperty = false;
    } else {
      this.falseBooleanDefaultValueProperty =
        parameters?.falseBooleanDefaultValueProperty satisfies never;
    }

    if (typeof parameters?.numberDefaultValueProperty === "number") {
      this.numberDefaultValueProperty = parameters?.numberDefaultValueProperty;
    } else if (typeof parameters?.numberDefaultValueProperty === "undefined") {
      this.numberDefaultValueProperty = 0;
    } else {
      this.numberDefaultValueProperty =
        parameters?.numberDefaultValueProperty satisfies never;
    }

    if (typeof parameters?.stringDefaultValueProperty === "string") {
      this.stringDefaultValueProperty = parameters?.stringDefaultValueProperty;
    } else if (typeof parameters?.stringDefaultValueProperty === "undefined") {
      this.stringDefaultValueProperty = "";
    } else {
      this.stringDefaultValueProperty =
        parameters?.stringDefaultValueProperty satisfies never;
    }

    if (typeof parameters?.trueBooleanDefaultValueProperty === "boolean") {
      this.trueBooleanDefaultValueProperty =
        parameters?.trueBooleanDefaultValueProperty;
    } else if (
      typeof parameters?.trueBooleanDefaultValueProperty === "undefined"
    ) {
      this.trueBooleanDefaultValueProperty = true;
    } else {
      this.trueBooleanDefaultValueProperty =
        parameters?.trueBooleanDefaultValueProperty satisfies never;
    }
  }

  get $identifier(): DefaultValuePropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }
    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  $equals(other: DefaultValuePropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$identifierPrefix, other.$identifierPrefix).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$identifierPrefix",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $dateEquals(
          this.dateDefaultValueProperty,
          other.dateDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "dateDefaultValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $dateEquals(
          this.dateTimeDefaultValueProperty,
          other.dateTimeDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "dateTimeDefaultValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.falseBooleanDefaultValueProperty,
          other.falseBooleanDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "falseBooleanDefaultValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.numberDefaultValueProperty,
          other.numberDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "numberDefaultValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.stringDefaultValueProperty,
          other.stringDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "stringDefaultValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.trueBooleanDefaultValueProperty,
          other.trueBooleanDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "trueBooleanDefaultValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.dateDefaultValueProperty.toISOString());
    _hasher.update(this.dateTimeDefaultValueProperty.toISOString());
    _hasher.update(this.falseBooleanDefaultValueProperty.toString());
    _hasher.update(this.numberDefaultValueProperty.toString());
    _hasher.update(this.stringDefaultValueProperty);
    _hasher.update(this.trueBooleanDefaultValueProperty.toString());
    return _hasher;
  }

  $toJson(): DefaultValuePropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        dateDefaultValueProperty: this.dateDefaultValueProperty
          .toISOString()
          .replace(/T.*$/, ""),
        dateTimeDefaultValueProperty:
          this.dateTimeDefaultValueProperty.toISOString(),
        falseBooleanDefaultValueProperty: this.falseBooleanDefaultValueProperty,
        numberDefaultValueProperty: this.numberDefaultValueProperty,
        stringDefaultValueProperty: this.stringDefaultValueProperty,
        trueBooleanDefaultValueProperty: this.trueBooleanDefaultValueProperty,
      } satisfies DefaultValuePropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      DefaultValuePropertiesClass.$properties.dateDefaultValueProperty[
        "identifier"
      ],
      ...(this.dateDefaultValueProperty.getTime() !== 1523232000000
        ? [
            rdfLiteral.toRdf(this.dateDefaultValueProperty, {
              dataFactory,
              datatype: $RdfVocabularies.xsd.date,
            }),
          ]
        : []),
    );
    resource.add(
      DefaultValuePropertiesClass.$properties.dateTimeDefaultValueProperty[
        "identifier"
      ],
      ...(this.dateTimeDefaultValueProperty.getTime() !== 1523268000000
        ? [
            rdfLiteral.toRdf(this.dateTimeDefaultValueProperty, {
              dataFactory,
              datatype: $RdfVocabularies.xsd.dateTime,
            }),
          ]
        : []),
    );
    resource.add(
      DefaultValuePropertiesClass.$properties.falseBooleanDefaultValueProperty[
        "identifier"
      ],
      ...(this.falseBooleanDefaultValueProperty ? [true] : []),
    );
    resource.add(
      DefaultValuePropertiesClass.$properties.numberDefaultValueProperty[
        "identifier"
      ],
      ...(this.numberDefaultValueProperty !== 0
        ? [this.numberDefaultValueProperty]
        : []),
    );
    resource.add(
      DefaultValuePropertiesClass.$properties.stringDefaultValueProperty[
        "identifier"
      ],
      ...(this.stringDefaultValueProperty !== ""
        ? [this.stringDefaultValueProperty]
        : []),
    );
    resource.add(
      DefaultValuePropertiesClass.$properties.trueBooleanDefaultValueProperty[
        "identifier"
      ],
      ...(!this.trueBooleanDefaultValueProperty ? [false] : []),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace DefaultValuePropertiesClass {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "DefaultValuePropertiesClass";
    readonly dateDefaultValueProperty: string;
    readonly dateTimeDefaultValueProperty: string;
    readonly falseBooleanDefaultValueProperty: boolean;
    readonly numberDefaultValueProperty: number;
    readonly stringDefaultValueProperty: string;
    readonly trueBooleanDefaultValueProperty: boolean;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      dateDefaultValueProperty: Date;
      dateTimeDefaultValueProperty: Date;
      falseBooleanDefaultValueProperty: boolean;
      numberDefaultValueProperty: number;
      stringDefaultValueProperty: string;
      trueBooleanDefaultValueProperty: boolean;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const dateDefaultValueProperty = new Date(
      $jsonObject["dateDefaultValueProperty"],
    );
    const dateTimeDefaultValueProperty = new Date(
      $jsonObject["dateTimeDefaultValueProperty"],
    );
    const falseBooleanDefaultValueProperty =
      $jsonObject["falseBooleanDefaultValueProperty"];
    const numberDefaultValueProperty =
      $jsonObject["numberDefaultValueProperty"];
    const stringDefaultValueProperty =
      $jsonObject["stringDefaultValueProperty"];
    const trueBooleanDefaultValueProperty =
      $jsonObject["trueBooleanDefaultValueProperty"];
    return purify.Either.of({
      $identifier,
      dateDefaultValueProperty,
      dateTimeDefaultValueProperty,
      falseBooleanDefaultValueProperty,
      numberDefaultValueProperty,
      stringDefaultValueProperty,
      trueBooleanDefaultValueProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, DefaultValuePropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new DefaultValuePropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "DefaultValuePropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateDefaultValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateTimeDefaultValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/falseBooleanDefaultValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/numberDefaultValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/stringDefaultValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/trueBooleanDefaultValueProperty`,
          type: "Control",
        },
      ],
      label: "DefaultValuePropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("DefaultValuePropertiesClass"),
      dateDefaultValueProperty: zod.string().date(),
      dateTimeDefaultValueProperty: zod.string().datetime(),
      falseBooleanDefaultValueProperty: zod.boolean(),
      numberDefaultValueProperty: zod.number(),
      stringDefaultValueProperty: zod.string(),
      trueBooleanDefaultValueProperty: zod.boolean(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, DefaultValuePropertiesClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return DefaultValuePropertiesClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new DefaultValuePropertiesClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      dateDefaultValueProperty: Date;
      dateTimeDefaultValueProperty: Date;
      falseBooleanDefaultValueProperty: boolean;
      numberDefaultValueProperty: number;
      stringDefaultValueProperty: string;
      trueBooleanDefaultValueProperty: boolean;
    }
  > {
    const $identifier: DefaultValuePropertiesClass.$Identifier =
      $resource.identifier;
    const _dateDefaultValuePropertyEither: purify.Either<Error, Date> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.dateDefaultValueProperty["identifier"], {
          unique: true,
        }),
      )
        .map((values) =>
          values.length > 0
            ? values
            : new rdfjsResource.Resource.Value({
                subject: $resource,
                predicate:
                  DefaultValuePropertiesClass.$properties
                    .dateDefaultValueProperty["identifier"],
                object: dataFactory.literal(
                  "2018-04-09",
                  $RdfVocabularies.xsd.date,
                ),
              }).toValues(),
        )
        .chain((values) => values.chainMap((value) => value.toDate()))
        .chain((values) => values.head());
    if (_dateDefaultValuePropertyEither.isLeft()) {
      return _dateDefaultValuePropertyEither;
    }

    const dateDefaultValueProperty =
      _dateDefaultValuePropertyEither.unsafeCoerce();
    const _dateTimeDefaultValuePropertyEither: purify.Either<Error, Date> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.dateTimeDefaultValueProperty["identifier"],
          { unique: true },
        ),
      )
        .map((values) =>
          values.length > 0
            ? values
            : new rdfjsResource.Resource.Value({
                subject: $resource,
                predicate:
                  DefaultValuePropertiesClass.$properties
                    .dateTimeDefaultValueProperty["identifier"],
                object: dataFactory.literal(
                  "2018-04-09T10:00:00Z",
                  $RdfVocabularies.xsd.dateTime,
                ),
              }).toValues(),
        )
        .chain((values) => values.chainMap((value) => value.toDate()))
        .chain((values) => values.head());
    if (_dateTimeDefaultValuePropertyEither.isLeft()) {
      return _dateTimeDefaultValuePropertyEither;
    }

    const dateTimeDefaultValueProperty =
      _dateTimeDefaultValuePropertyEither.unsafeCoerce();
    const _falseBooleanDefaultValuePropertyEither: purify.Either<
      Error,
      boolean
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.falseBooleanDefaultValueProperty["identifier"],
        { unique: true },
      ),
    )
      .map((values) =>
        values.length > 0
          ? values
          : new rdfjsResource.Resource.Value({
              subject: $resource,
              predicate:
                DefaultValuePropertiesClass.$properties
                  .falseBooleanDefaultValueProperty["identifier"],
              object: dataFactory.literal(
                "false",
                $RdfVocabularies.xsd.boolean,
              ),
            }).toValues(),
      )
      .chain((values) => values.chainMap((value) => value.toBoolean()))
      .chain((values) => values.head());
    if (_falseBooleanDefaultValuePropertyEither.isLeft()) {
      return _falseBooleanDefaultValuePropertyEither;
    }

    const falseBooleanDefaultValueProperty =
      _falseBooleanDefaultValuePropertyEither.unsafeCoerce();
    const _numberDefaultValuePropertyEither: purify.Either<Error, number> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.numberDefaultValueProperty["identifier"], {
          unique: true,
        }),
      )
        .map((values) =>
          values.length > 0
            ? values
            : new rdfjsResource.Resource.Value({
                subject: $resource,
                predicate:
                  DefaultValuePropertiesClass.$properties
                    .numberDefaultValueProperty["identifier"],
                object: dataFactory.literal("0", $RdfVocabularies.xsd.integer),
              }).toValues(),
        )
        .chain((values) => values.chainMap((value) => value.toNumber()))
        .chain((values) => values.head());
    if (_numberDefaultValuePropertyEither.isLeft()) {
      return _numberDefaultValuePropertyEither;
    }

    const numberDefaultValueProperty =
      _numberDefaultValuePropertyEither.unsafeCoerce();
    const _stringDefaultValuePropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.stringDefaultValueProperty["identifier"], {
          unique: true,
        }),
      )
        .map((values) =>
          values.length > 0
            ? values
            : new rdfjsResource.Resource.Value({
                subject: $resource,
                predicate:
                  DefaultValuePropertiesClass.$properties
                    .stringDefaultValueProperty["identifier"],
                object: dataFactory.literal(""),
              }).toValues(),
        )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    DefaultValuePropertiesClass.$properties
                      .stringDefaultValueProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_stringDefaultValuePropertyEither.isLeft()) {
      return _stringDefaultValuePropertyEither;
    }

    const stringDefaultValueProperty =
      _stringDefaultValuePropertyEither.unsafeCoerce();
    const _trueBooleanDefaultValuePropertyEither: purify.Either<
      Error,
      boolean
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.trueBooleanDefaultValueProperty["identifier"],
        { unique: true },
      ),
    )
      .map((values) =>
        values.length > 0
          ? values
          : new rdfjsResource.Resource.Value({
              subject: $resource,
              predicate:
                DefaultValuePropertiesClass.$properties
                  .trueBooleanDefaultValueProperty["identifier"],
              object: dataFactory.literal("true", $RdfVocabularies.xsd.boolean),
            }).toValues(),
      )
      .chain((values) => values.chainMap((value) => value.toBoolean()))
      .chain((values) => values.head());
    if (_trueBooleanDefaultValuePropertyEither.isLeft()) {
      return _trueBooleanDefaultValuePropertyEither;
    }

    const trueBooleanDefaultValueProperty =
      _trueBooleanDefaultValuePropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      dateDefaultValueProperty,
      dateTimeDefaultValueProperty,
      falseBooleanDefaultValueProperty,
      numberDefaultValueProperty,
      stringDefaultValueProperty,
      trueBooleanDefaultValueProperty,
    });
  }

  export const $properties = {
    dateDefaultValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/dateDefaultValueProperty",
      ),
    },
    dateTimeDefaultValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/dateTimeDefaultValueProperty",
      ),
    },
    falseBooleanDefaultValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/falseBooleanDefaultValueProperty",
      ),
    },
    numberDefaultValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/numberDefaultValueProperty",
      ),
    },
    stringDefaultValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/stringDefaultValueProperty",
      ),
    },
    trueBooleanDefaultValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/trueBooleanDefaultValueProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        DefaultValuePropertiesClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        DefaultValuePropertiesClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      DefaultValuePropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("defaultValuePropertiesClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "defaultValuePropertiesClass");
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}DateDefaultValueProperty`,
      ),
      predicate:
        DefaultValuePropertiesClass.$properties.dateDefaultValueProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}DateTimeDefaultValueProperty`,
      ),
      predicate:
        DefaultValuePropertiesClass.$properties.dateTimeDefaultValueProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}FalseBooleanDefaultValueProperty`,
      ),
      predicate:
        DefaultValuePropertiesClass.$properties
          .falseBooleanDefaultValueProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}NumberDefaultValueProperty`,
      ),
      predicate:
        DefaultValuePropertiesClass.$properties.numberDefaultValueProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}StringDefaultValueProperty`,
      ),
      predicate:
        DefaultValuePropertiesClass.$properties.stringDefaultValueProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}TrueBooleanDefaultValueProperty`,
      ),
      predicate:
        DefaultValuePropertiesClass.$properties.trueBooleanDefaultValueProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("defaultValuePropertiesClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "defaultValuePropertiesClass");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}DateDefaultValueProperty`,
                ),
                predicate:
                  DefaultValuePropertiesClass.$properties
                    .dateDefaultValueProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}DateTimeDefaultValueProperty`,
                ),
                predicate:
                  DefaultValuePropertiesClass.$properties
                    .dateTimeDefaultValueProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}FalseBooleanDefaultValueProperty`,
                ),
                predicate:
                  DefaultValuePropertiesClass.$properties
                    .falseBooleanDefaultValueProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}NumberDefaultValueProperty`,
                ),
                predicate:
                  DefaultValuePropertiesClass.$properties
                    .numberDefaultValueProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}StringDefaultValueProperty`,
                ),
                predicate:
                  DefaultValuePropertiesClass.$properties
                    .stringDefaultValueProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}StringDefaultValueProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}TrueBooleanDefaultValueProperty`,
                ),
                predicate:
                  DefaultValuePropertiesClass.$properties
                    .trueBooleanDefaultValueProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Node shape with properties whose types are convertible from other types on construction e.g., string to IRI.
 */
export class ConvertibleTypePropertiesClass {
  private _$identifier?: ConvertibleTypePropertiesClass.$Identifier;
  readonly $type = "ConvertibleTypePropertiesClass";
  readonly convertibleIriNonEmptySetProperty: purify.NonEmptyList<rdfjs.NamedNode>;
  readonly convertibleIriOptionProperty: purify.Maybe<rdfjs.NamedNode>;
  readonly convertibleIriProperty: rdfjs.NamedNode;
  readonly convertibleIriSetProperty: readonly rdfjs.NamedNode[];
  readonly convertibleLiteralNonEmptySetProperty: purify.NonEmptyList<rdfjs.Literal>;
  readonly convertibleLiteralOptionProperty: purify.Maybe<rdfjs.Literal>;
  readonly convertibleLiteralProperty: rdfjs.Literal;
  readonly convertibleLiteralSetProperty: readonly rdfjs.Literal[];
  readonly convertibleTermNonEmptySetProperty: purify.NonEmptyList<
    rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal
  >;
  readonly convertibleTermOptionProperty: purify.Maybe<
    rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal
  >;
  readonly convertibleTermProperty:
    | rdfjs.BlankNode
    | rdfjs.NamedNode
    | rdfjs.Literal;
  readonly convertibleTermSetProperty: readonly (
    | rdfjs.BlankNode
    | rdfjs.NamedNode
    | rdfjs.Literal
  )[];

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly convertibleIriNonEmptySetProperty: purify.NonEmptyList<rdfjs.NamedNode>;
    readonly convertibleIriOptionProperty?:
      | rdfjs.NamedNode
      | purify.Maybe<rdfjs.NamedNode>
      | string;
    readonly convertibleIriProperty: rdfjs.NamedNode | string;
    readonly convertibleIriSetProperty?:
      | readonly rdfjs.NamedNode[]
      | readonly string[];
    readonly convertibleLiteralNonEmptySetProperty: purify.NonEmptyList<rdfjs.Literal>;
    readonly convertibleLiteralOptionProperty?:
      | rdfjs.Literal
      | Date
      | boolean
      | number
      | purify.Maybe<rdfjs.Literal>
      | string;
    readonly convertibleLiteralProperty:
      | rdfjs.Literal
      | Date
      | boolean
      | number
      | string;
    readonly convertibleLiteralSetProperty?:
      | readonly rdfjs.Literal[]
      | readonly boolean[]
      | readonly number[]
      | readonly string[];
    readonly convertibleTermNonEmptySetProperty: purify.NonEmptyList<
      rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal
    >;
    readonly convertibleTermOptionProperty?:
      | (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)
      | Date
      | boolean
      | number
      | purify.Maybe<rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal>
      | string;
    readonly convertibleTermProperty:
      | (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)
      | Date
      | boolean
      | number
      | string;
    readonly convertibleTermSetProperty?:
      | readonly (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)[]
      | readonly boolean[]
      | readonly number[]
      | readonly string[];
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.convertibleIriNonEmptySetProperty =
      parameters.convertibleIriNonEmptySetProperty;
    if (purify.Maybe.isMaybe(parameters.convertibleIriOptionProperty)) {
      this.convertibleIriOptionProperty =
        parameters.convertibleIriOptionProperty;
    } else if (typeof parameters.convertibleIriOptionProperty === "object") {
      this.convertibleIriOptionProperty = purify.Maybe.of(
        parameters.convertibleIriOptionProperty,
      );
    } else if (typeof parameters.convertibleIriOptionProperty === "string") {
      this.convertibleIriOptionProperty = purify.Maybe.of(
        dataFactory.namedNode(parameters.convertibleIriOptionProperty),
      );
    } else if (typeof parameters.convertibleIriOptionProperty === "undefined") {
      this.convertibleIriOptionProperty = purify.Maybe.empty();
    } else {
      this.convertibleIriOptionProperty =
        parameters.convertibleIriOptionProperty satisfies never;
    }

    if (typeof parameters.convertibleIriProperty === "object") {
      this.convertibleIriProperty = parameters.convertibleIriProperty;
    } else if (typeof parameters.convertibleIriProperty === "string") {
      this.convertibleIriProperty = dataFactory.namedNode(
        parameters.convertibleIriProperty,
      );
    } else {
      this.convertibleIriProperty =
        parameters.convertibleIriProperty satisfies never;
    }

    if (typeof parameters.convertibleIriSetProperty === "undefined") {
      this.convertibleIriSetProperty = [];
    } else if ($isReadonlyObjectArray(parameters.convertibleIriSetProperty)) {
      this.convertibleIriSetProperty = parameters.convertibleIriSetProperty;
    } else if ($isReadonlyStringArray(parameters.convertibleIriSetProperty)) {
      this.convertibleIriSetProperty = parameters.convertibleIriSetProperty.map(
        (item) => dataFactory.namedNode(item),
      );
    } else {
      this.convertibleIriSetProperty =
        parameters.convertibleIriSetProperty satisfies never;
    }

    this.convertibleLiteralNonEmptySetProperty =
      parameters.convertibleLiteralNonEmptySetProperty;
    if (purify.Maybe.isMaybe(parameters.convertibleLiteralOptionProperty)) {
      this.convertibleLiteralOptionProperty =
        parameters.convertibleLiteralOptionProperty;
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "boolean"
    ) {
      this.convertibleLiteralOptionProperty = purify.Maybe.of(
        rdfLiteral.toRdf(parameters.convertibleLiteralOptionProperty, {
          dataFactory,
        }),
      );
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "object" &&
      parameters.convertibleLiteralOptionProperty instanceof Date
    ) {
      this.convertibleLiteralOptionProperty = purify.Maybe.of(
        rdfLiteral.toRdf(parameters.convertibleLiteralOptionProperty, {
          dataFactory,
        }),
      );
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "number"
    ) {
      this.convertibleLiteralOptionProperty = purify.Maybe.of(
        rdfLiteral.toRdf(parameters.convertibleLiteralOptionProperty, {
          dataFactory,
        }),
      );
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "string"
    ) {
      this.convertibleLiteralOptionProperty = purify.Maybe.of(
        dataFactory.literal(parameters.convertibleLiteralOptionProperty),
      );
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "object"
    ) {
      this.convertibleLiteralOptionProperty = purify.Maybe.of(
        parameters.convertibleLiteralOptionProperty,
      );
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "undefined"
    ) {
      this.convertibleLiteralOptionProperty = purify.Maybe.empty();
    } else {
      this.convertibleLiteralOptionProperty =
        parameters.convertibleLiteralOptionProperty satisfies never;
    }

    if (typeof parameters.convertibleLiteralProperty === "boolean") {
      this.convertibleLiteralProperty = rdfLiteral.toRdf(
        parameters.convertibleLiteralProperty,
        { dataFactory },
      );
    } else if (
      typeof parameters.convertibleLiteralProperty === "object" &&
      parameters.convertibleLiteralProperty instanceof Date
    ) {
      this.convertibleLiteralProperty = rdfLiteral.toRdf(
        parameters.convertibleLiteralProperty,
        { dataFactory },
      );
    } else if (typeof parameters.convertibleLiteralProperty === "number") {
      this.convertibleLiteralProperty = rdfLiteral.toRdf(
        parameters.convertibleLiteralProperty,
        { dataFactory },
      );
    } else if (typeof parameters.convertibleLiteralProperty === "string") {
      this.convertibleLiteralProperty = dataFactory.literal(
        parameters.convertibleLiteralProperty,
      );
    } else if (typeof parameters.convertibleLiteralProperty === "object") {
      this.convertibleLiteralProperty = parameters.convertibleLiteralProperty;
    } else {
      this.convertibleLiteralProperty =
        parameters.convertibleLiteralProperty satisfies never;
    }

    if (typeof parameters.convertibleLiteralSetProperty === "undefined") {
      this.convertibleLiteralSetProperty = [];
    } else if (
      $isReadonlyObjectArray(parameters.convertibleLiteralSetProperty)
    ) {
      this.convertibleLiteralSetProperty =
        parameters.convertibleLiteralSetProperty;
    } else if (
      $isReadonlyBooleanArray(parameters.convertibleLiteralSetProperty)
    ) {
      this.convertibleLiteralSetProperty =
        parameters.convertibleLiteralSetProperty.map((item) =>
          rdfLiteral.toRdf(item, { dataFactory }),
        );
    } else if (
      $isReadonlyNumberArray(parameters.convertibleLiteralSetProperty)
    ) {
      this.convertibleLiteralSetProperty =
        parameters.convertibleLiteralSetProperty.map((item) =>
          rdfLiteral.toRdf(item, { dataFactory }),
        );
    } else if (
      $isReadonlyStringArray(parameters.convertibleLiteralSetProperty)
    ) {
      this.convertibleLiteralSetProperty =
        parameters.convertibleLiteralSetProperty.map((item) =>
          dataFactory.literal(item),
        );
    } else {
      this.convertibleLiteralSetProperty =
        parameters.convertibleLiteralSetProperty satisfies never;
    }

    this.convertibleTermNonEmptySetProperty =
      parameters.convertibleTermNonEmptySetProperty;
    if (purify.Maybe.isMaybe(parameters.convertibleTermOptionProperty)) {
      this.convertibleTermOptionProperty =
        parameters.convertibleTermOptionProperty;
    } else if (typeof parameters.convertibleTermOptionProperty === "boolean") {
      this.convertibleTermOptionProperty = purify.Maybe.of(
        rdfLiteral.toRdf(parameters.convertibleTermOptionProperty, {
          dataFactory,
        }),
      );
    } else if (
      typeof parameters.convertibleTermOptionProperty === "object" &&
      parameters.convertibleTermOptionProperty instanceof Date
    ) {
      this.convertibleTermOptionProperty = purify.Maybe.of(
        rdfLiteral.toRdf(parameters.convertibleTermOptionProperty, {
          dataFactory,
        }),
      );
    } else if (typeof parameters.convertibleTermOptionProperty === "number") {
      this.convertibleTermOptionProperty = purify.Maybe.of(
        rdfLiteral.toRdf(parameters.convertibleTermOptionProperty, {
          dataFactory,
        }),
      );
    } else if (typeof parameters.convertibleTermOptionProperty === "string") {
      this.convertibleTermOptionProperty = purify.Maybe.of(
        dataFactory.literal(parameters.convertibleTermOptionProperty),
      );
    } else if (typeof parameters.convertibleTermOptionProperty === "object") {
      this.convertibleTermOptionProperty = purify.Maybe.of(
        parameters.convertibleTermOptionProperty,
      );
    } else if (
      typeof parameters.convertibleTermOptionProperty === "undefined"
    ) {
      this.convertibleTermOptionProperty = purify.Maybe.empty();
    } else {
      this.convertibleTermOptionProperty =
        parameters.convertibleTermOptionProperty satisfies never;
    }

    if (typeof parameters.convertibleTermProperty === "boolean") {
      this.convertibleTermProperty = rdfLiteral.toRdf(
        parameters.convertibleTermProperty,
        { dataFactory },
      );
    } else if (
      typeof parameters.convertibleTermProperty === "object" &&
      parameters.convertibleTermProperty instanceof Date
    ) {
      this.convertibleTermProperty = rdfLiteral.toRdf(
        parameters.convertibleTermProperty,
        { dataFactory },
      );
    } else if (typeof parameters.convertibleTermProperty === "number") {
      this.convertibleTermProperty = rdfLiteral.toRdf(
        parameters.convertibleTermProperty,
        { dataFactory },
      );
    } else if (typeof parameters.convertibleTermProperty === "string") {
      this.convertibleTermProperty = dataFactory.literal(
        parameters.convertibleTermProperty,
      );
    } else if (typeof parameters.convertibleTermProperty === "object") {
      this.convertibleTermProperty = parameters.convertibleTermProperty;
    } else {
      this.convertibleTermProperty =
        parameters.convertibleTermProperty satisfies never;
    }

    if (typeof parameters.convertibleTermSetProperty === "undefined") {
      this.convertibleTermSetProperty = [];
    } else if ($isReadonlyObjectArray(parameters.convertibleTermSetProperty)) {
      this.convertibleTermSetProperty = parameters.convertibleTermSetProperty;
    } else if ($isReadonlyBooleanArray(parameters.convertibleTermSetProperty)) {
      this.convertibleTermSetProperty =
        parameters.convertibleTermSetProperty.map((item) =>
          rdfLiteral.toRdf(item, { dataFactory }),
        );
    } else if ($isReadonlyNumberArray(parameters.convertibleTermSetProperty)) {
      this.convertibleTermSetProperty =
        parameters.convertibleTermSetProperty.map((item) =>
          rdfLiteral.toRdf(item, { dataFactory }),
        );
    } else if ($isReadonlyStringArray(parameters.convertibleTermSetProperty)) {
      this.convertibleTermSetProperty =
        parameters.convertibleTermSetProperty.map((item) =>
          dataFactory.literal(item),
        );
    } else {
      this.convertibleTermSetProperty =
        parameters.convertibleTermSetProperty satisfies never;
    }
  }

  get $identifier(): ConvertibleTypePropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: ConvertibleTypePropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleIriNonEmptySetProperty,
          other.convertibleIriNonEmptySetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleIriNonEmptySetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.convertibleIriOptionProperty,
          other.convertibleIriOptionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleIriOptionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $booleanEquals(
          this.convertibleIriProperty,
          other.convertibleIriProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleIriProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleIriSetProperty,
          other.convertibleIriSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleIriSetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleLiteralNonEmptySetProperty,
          other.convertibleLiteralNonEmptySetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleLiteralNonEmptySetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.convertibleLiteralOptionProperty,
          other.convertibleLiteralOptionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleLiteralOptionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $booleanEquals(
          this.convertibleLiteralProperty,
          other.convertibleLiteralProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleLiteralProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleLiteralSetProperty,
          other.convertibleLiteralSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleLiteralSetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleTermNonEmptySetProperty,
          other.convertibleTermNonEmptySetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleTermNonEmptySetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.convertibleTermOptionProperty,
          other.convertibleTermOptionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleTermOptionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $booleanEquals(
          this.convertibleTermProperty,
          other.convertibleTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleTermSetProperty,
          other.convertibleTermSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleTermSetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    for (const item0 of this.convertibleIriNonEmptySetProperty) {
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }

    this.convertibleIriOptionProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    _hasher.update(this.convertibleIriProperty.termType);
    _hasher.update(this.convertibleIriProperty.value);
    for (const item0 of this.convertibleIriSetProperty) {
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }

    for (const item0 of this.convertibleLiteralNonEmptySetProperty) {
      _hasher.update(item0.datatype.value);
      _hasher.update(item0.language);
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }

    this.convertibleLiteralOptionProperty.ifJust((value0) => {
      _hasher.update(value0.datatype.value);
      _hasher.update(value0.language);
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    _hasher.update(this.convertibleLiteralProperty.datatype.value);
    _hasher.update(this.convertibleLiteralProperty.language);
    _hasher.update(this.convertibleLiteralProperty.termType);
    _hasher.update(this.convertibleLiteralProperty.value);
    for (const item0 of this.convertibleLiteralSetProperty) {
      _hasher.update(item0.datatype.value);
      _hasher.update(item0.language);
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }

    for (const item0 of this.convertibleTermNonEmptySetProperty) {
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }

    this.convertibleTermOptionProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    _hasher.update(this.convertibleTermProperty.termType);
    _hasher.update(this.convertibleTermProperty.value);
    for (const item0 of this.convertibleTermSetProperty) {
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }

    return _hasher;
  }

  $toJson(): ConvertibleTypePropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        convertibleIriNonEmptySetProperty:
          this.convertibleIriNonEmptySetProperty.map((item) => ({
            "@id": item.value,
          })),
        convertibleIriOptionProperty: this.convertibleIriOptionProperty
          .map((item) => ({ "@id": item.value }))
          .extract(),
        convertibleIriProperty: { "@id": this.convertibleIriProperty.value },
        convertibleIriSetProperty: this.convertibleIriSetProperty.map(
          (item) => ({ "@id": item.value }),
        ),
        convertibleLiteralNonEmptySetProperty:
          this.convertibleLiteralNonEmptySetProperty.map((item) => ({
            "@language": item.language.length > 0 ? item.language : undefined,
            "@type":
              item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? item.datatype.value
                : undefined,
            "@value": item.value,
          })),
        convertibleLiteralOptionProperty: this.convertibleLiteralOptionProperty
          .map((item) => ({
            "@language": item.language.length > 0 ? item.language : undefined,
            "@type":
              item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? item.datatype.value
                : undefined,
            "@value": item.value,
          }))
          .extract(),
        convertibleLiteralProperty: {
          "@language":
            this.convertibleLiteralProperty.language.length > 0
              ? this.convertibleLiteralProperty.language
              : undefined,
          "@type":
            this.convertibleLiteralProperty.datatype.value !==
            "http://www.w3.org/2001/XMLSchema#string"
              ? this.convertibleLiteralProperty.datatype.value
              : undefined,
          "@value": this.convertibleLiteralProperty.value,
        },
        convertibleLiteralSetProperty: this.convertibleLiteralSetProperty.map(
          (item) => ({
            "@language": item.language.length > 0 ? item.language : undefined,
            "@type":
              item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? item.datatype.value
                : undefined,
            "@value": item.value,
          }),
        ),
        convertibleTermNonEmptySetProperty:
          this.convertibleTermNonEmptySetProperty.map((item) =>
            item.termType === "Literal"
              ? {
                  "@language":
                    item.language.length > 0 ? item.language : undefined,
                  "@type":
                    item.datatype.value !==
                    "http://www.w3.org/2001/XMLSchema#string"
                      ? item.datatype.value
                      : undefined,
                  "@value": item.value,
                  termType: "Literal" as const,
                }
              : item.termType === "NamedNode"
                ? { "@id": item.value, termType: "NamedNode" as const }
                : { "@id": `_:${item.value}`, termType: "BlankNode" as const },
          ),
        convertibleTermOptionProperty: this.convertibleTermOptionProperty
          .map((item) =>
            item.termType === "Literal"
              ? {
                  "@language":
                    item.language.length > 0 ? item.language : undefined,
                  "@type":
                    item.datatype.value !==
                    "http://www.w3.org/2001/XMLSchema#string"
                      ? item.datatype.value
                      : undefined,
                  "@value": item.value,
                  termType: "Literal" as const,
                }
              : item.termType === "NamedNode"
                ? { "@id": item.value, termType: "NamedNode" as const }
                : { "@id": `_:${item.value}`, termType: "BlankNode" as const },
          )
          .extract(),
        convertibleTermProperty:
          this.convertibleTermProperty.termType === "Literal"
            ? {
                "@language":
                  this.convertibleTermProperty.language.length > 0
                    ? this.convertibleTermProperty.language
                    : undefined,
                "@type":
                  this.convertibleTermProperty.datatype.value !==
                  "http://www.w3.org/2001/XMLSchema#string"
                    ? this.convertibleTermProperty.datatype.value
                    : undefined,
                "@value": this.convertibleTermProperty.value,
                termType: "Literal" as const,
              }
            : this.convertibleTermProperty.termType === "NamedNode"
              ? {
                  "@id": this.convertibleTermProperty.value,
                  termType: "NamedNode" as const,
                }
              : {
                  "@id": `_:${this.convertibleTermProperty.value}`,
                  termType: "BlankNode" as const,
                },
        convertibleTermSetProperty: this.convertibleTermSetProperty.map(
          (item) =>
            item.termType === "Literal"
              ? {
                  "@language":
                    item.language.length > 0 ? item.language : undefined,
                  "@type":
                    item.datatype.value !==
                    "http://www.w3.org/2001/XMLSchema#string"
                      ? item.datatype.value
                      : undefined,
                  "@value": item.value,
                  termType: "Literal" as const,
                }
              : item.termType === "NamedNode"
                ? { "@id": item.value, termType: "NamedNode" as const }
                : { "@id": `_:${item.value}`, termType: "BlankNode" as const },
        ),
      } satisfies ConvertibleTypePropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/ConvertibleTypePropertiesClass",
        ),
      );
    }

    resource.add(
      ConvertibleTypePropertiesClass.$properties
        .convertibleIriNonEmptySetProperty["identifier"],
      ...this.convertibleIriNonEmptySetProperty.flatMap((item) => [item]),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleIriOptionProperty[
        "identifier"
      ],
      ...this.convertibleIriOptionProperty.toList(),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleIriProperty[
        "identifier"
      ],
      ...[this.convertibleIriProperty],
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleIriSetProperty[
        "identifier"
      ],
      ...this.convertibleIriSetProperty.flatMap((item) => [item]),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties
        .convertibleLiteralNonEmptySetProperty["identifier"],
      ...this.convertibleLiteralNonEmptySetProperty.flatMap((item) => [item]),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties
        .convertibleLiteralOptionProperty["identifier"],
      ...this.convertibleLiteralOptionProperty.toList(),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleLiteralProperty[
        "identifier"
      ],
      ...[this.convertibleLiteralProperty],
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleLiteralSetProperty[
        "identifier"
      ],
      ...this.convertibleLiteralSetProperty.flatMap((item) => [item]),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties
        .convertibleTermNonEmptySetProperty["identifier"],
      ...this.convertibleTermNonEmptySetProperty.flatMap((item) => [item]),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleTermOptionProperty[
        "identifier"
      ],
      ...this.convertibleTermOptionProperty.toList(),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleTermProperty[
        "identifier"
      ],
      ...[this.convertibleTermProperty],
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleTermSetProperty[
        "identifier"
      ],
      ...this.convertibleTermSetProperty.flatMap((item) => [item]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ConvertibleTypePropertiesClass {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ConvertibleTypePropertiesClass",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ConvertibleTypePropertiesClass";
    readonly convertibleIriNonEmptySetProperty: readonly {
      readonly "@id": string;
    }[];
    readonly convertibleIriOptionProperty?: { readonly "@id": string };
    readonly convertibleIriProperty: { readonly "@id": string };
    readonly convertibleIriSetProperty?: readonly { readonly "@id": string }[];
    readonly convertibleLiteralNonEmptySetProperty: readonly {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    }[];
    readonly convertibleLiteralOptionProperty?: {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    };
    readonly convertibleLiteralProperty: {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    };
    readonly convertibleLiteralSetProperty?: readonly {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    }[];
    readonly convertibleTermNonEmptySetProperty: readonly (
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly "@type"?: string;
          readonly "@value": string;
          readonly termType: "Literal";
        }
    )[];
    readonly convertibleTermOptionProperty?:
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly "@type"?: string;
          readonly "@value": string;
          readonly termType: "Literal";
        };
    readonly convertibleTermProperty:
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly "@type"?: string;
          readonly "@value": string;
          readonly termType: "Literal";
        };
    readonly convertibleTermSetProperty?: readonly (
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly "@type"?: string;
          readonly "@value": string;
          readonly termType: "Literal";
        }
    )[];
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      convertibleIriNonEmptySetProperty: purify.NonEmptyList<rdfjs.NamedNode>;
      convertibleIriOptionProperty: purify.Maybe<rdfjs.NamedNode>;
      convertibleIriProperty: rdfjs.NamedNode;
      convertibleIriSetProperty: readonly rdfjs.NamedNode[];
      convertibleLiteralNonEmptySetProperty: purify.NonEmptyList<rdfjs.Literal>;
      convertibleLiteralOptionProperty: purify.Maybe<rdfjs.Literal>;
      convertibleLiteralProperty: rdfjs.Literal;
      convertibleLiteralSetProperty: readonly rdfjs.Literal[];
      convertibleTermNonEmptySetProperty: purify.NonEmptyList<
        rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal
      >;
      convertibleTermOptionProperty: purify.Maybe<
        rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal
      >;
      convertibleTermProperty:
        | rdfjs.BlankNode
        | rdfjs.NamedNode
        | rdfjs.Literal;
      convertibleTermSetProperty: readonly (
        | rdfjs.BlankNode
        | rdfjs.NamedNode
        | rdfjs.Literal
      )[];
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const convertibleIriNonEmptySetProperty = purify.NonEmptyList.fromArray(
      $jsonObject["convertibleIriNonEmptySetProperty"],
    )
      .unsafeCoerce()
      .map((item) => dataFactory.namedNode(item["@id"]));
    const convertibleIriOptionProperty = purify.Maybe.fromNullable(
      $jsonObject["convertibleIriOptionProperty"],
    ).map((item) => dataFactory.namedNode(item["@id"]));
    const convertibleIriProperty = dataFactory.namedNode(
      $jsonObject["convertibleIriProperty"]["@id"],
    );
    const convertibleIriSetProperty = $jsonObject[
      "convertibleIriSetProperty"
    ].map((item) => dataFactory.namedNode(item["@id"]));
    const convertibleLiteralNonEmptySetProperty = purify.NonEmptyList.fromArray(
      $jsonObject["convertibleLiteralNonEmptySetProperty"],
    )
      .unsafeCoerce()
      .map((item) =>
        dataFactory.literal(
          item["@value"],
          typeof item["@language"] !== "undefined"
            ? item["@language"]
            : typeof item["@type"] !== "undefined"
              ? dataFactory.namedNode(item["@type"])
              : undefined,
        ),
      );
    const convertibleLiteralOptionProperty = purify.Maybe.fromNullable(
      $jsonObject["convertibleLiteralOptionProperty"],
    ).map((item) =>
      dataFactory.literal(
        item["@value"],
        typeof item["@language"] !== "undefined"
          ? item["@language"]
          : typeof item["@type"] !== "undefined"
            ? dataFactory.namedNode(item["@type"])
            : undefined,
      ),
    );
    const convertibleLiteralProperty = dataFactory.literal(
      $jsonObject["convertibleLiteralProperty"]["@value"],
      typeof $jsonObject["convertibleLiteralProperty"]["@language"] !==
        "undefined"
        ? $jsonObject["convertibleLiteralProperty"]["@language"]
        : typeof $jsonObject["convertibleLiteralProperty"]["@type"] !==
            "undefined"
          ? dataFactory.namedNode(
              $jsonObject["convertibleLiteralProperty"]["@type"],
            )
          : undefined,
    );
    const convertibleLiteralSetProperty = $jsonObject[
      "convertibleLiteralSetProperty"
    ].map((item) =>
      dataFactory.literal(
        item["@value"],
        typeof item["@language"] !== "undefined"
          ? item["@language"]
          : typeof item["@type"] !== "undefined"
            ? dataFactory.namedNode(item["@type"])
            : undefined,
      ),
    );
    const convertibleTermNonEmptySetProperty = purify.NonEmptyList.fromArray(
      $jsonObject["convertibleTermNonEmptySetProperty"],
    )
      .unsafeCoerce()
      .map((item) =>
        item.termType === "Literal"
          ? dataFactory.literal(
              item["@value"],
              typeof item["@language"] !== "undefined"
                ? item["@language"]
                : typeof item["@type"] !== "undefined"
                  ? dataFactory.namedNode(item["@type"])
                  : undefined,
            )
          : item.termType === "NamedNode"
            ? dataFactory.namedNode(item["@id"])
            : dataFactory.blankNode(item["@id"].substring(2)),
      );
    const convertibleTermOptionProperty = purify.Maybe.fromNullable(
      $jsonObject["convertibleTermOptionProperty"],
    ).map((item) =>
      item.termType === "Literal"
        ? dataFactory.literal(
            item["@value"],
            typeof item["@language"] !== "undefined"
              ? item["@language"]
              : typeof item["@type"] !== "undefined"
                ? dataFactory.namedNode(item["@type"])
                : undefined,
          )
        : item.termType === "NamedNode"
          ? dataFactory.namedNode(item["@id"])
          : dataFactory.blankNode(item["@id"].substring(2)),
    );
    const convertibleTermProperty =
      $jsonObject["convertibleTermProperty"].termType === "Literal"
        ? dataFactory.literal(
            $jsonObject["convertibleTermProperty"]["@value"],
            typeof $jsonObject["convertibleTermProperty"]["@language"] !==
              "undefined"
              ? $jsonObject["convertibleTermProperty"]["@language"]
              : typeof $jsonObject["convertibleTermProperty"]["@type"] !==
                  "undefined"
                ? dataFactory.namedNode(
                    $jsonObject["convertibleTermProperty"]["@type"],
                  )
                : undefined,
          )
        : $jsonObject["convertibleTermProperty"].termType === "NamedNode"
          ? dataFactory.namedNode($jsonObject["convertibleTermProperty"]["@id"])
          : dataFactory.blankNode(
              $jsonObject["convertibleTermProperty"]["@id"].substring(2),
            );
    const convertibleTermSetProperty = $jsonObject[
      "convertibleTermSetProperty"
    ].map((item) =>
      item.termType === "Literal"
        ? dataFactory.literal(
            item["@value"],
            typeof item["@language"] !== "undefined"
              ? item["@language"]
              : typeof item["@type"] !== "undefined"
                ? dataFactory.namedNode(item["@type"])
                : undefined,
          )
        : item.termType === "NamedNode"
          ? dataFactory.namedNode(item["@id"])
          : dataFactory.blankNode(item["@id"].substring(2)),
    );
    return purify.Either.of({
      $identifier,
      convertibleIriNonEmptySetProperty,
      convertibleIriOptionProperty,
      convertibleIriProperty,
      convertibleIriSetProperty,
      convertibleLiteralNonEmptySetProperty,
      convertibleLiteralOptionProperty,
      convertibleLiteralProperty,
      convertibleLiteralSetProperty,
      convertibleTermNonEmptySetProperty,
      convertibleTermOptionProperty,
      convertibleTermProperty,
      convertibleTermSetProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ConvertibleTypePropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ConvertibleTypePropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ConvertibleTypePropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleIriNonEmptySetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleIriOptionProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleIriProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleIriSetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleLiteralNonEmptySetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleLiteralOptionProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleLiteralProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleLiteralSetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleTermNonEmptySetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleTermOptionProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleTermSetProperty`,
          type: "Control",
        },
      ],
      label: "ConvertibleTypePropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("ConvertibleTypePropertiesClass"),
      convertibleIriNonEmptySetProperty: zod
        .object({ "@id": zod.string().min(1) })
        .array()
        .nonempty()
        .min(1),
      convertibleIriOptionProperty: zod
        .object({ "@id": zod.string().min(1) })
        .optional(),
      convertibleIriProperty: zod.object({ "@id": zod.string().min(1) }),
      convertibleIriSetProperty: zod
        .object({ "@id": zod.string().min(1) })
        .array()
        .default(() => []),
      convertibleLiteralNonEmptySetProperty: zod
        .object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
        })
        .array()
        .nonempty()
        .min(1),
      convertibleLiteralOptionProperty: zod
        .object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
        })
        .optional(),
      convertibleLiteralProperty: zod.object({
        "@language": zod.string().optional(),
        "@type": zod.string().optional(),
        "@value": zod.string(),
      }),
      convertibleLiteralSetProperty: zod
        .object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
        })
        .array()
        .default(() => []),
      convertibleTermNonEmptySetProperty: zod
        .discriminatedUnion("termType", [
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("BlankNode"),
          }),
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("NamedNode"),
          }),
          zod.object({
            "@language": zod.string().optional(),
            "@type": zod.string().optional(),
            "@value": zod.string(),
            termType: zod.literal("Literal"),
          }),
        ])
        .array()
        .nonempty()
        .min(1),
      convertibleTermOptionProperty: zod
        .discriminatedUnion("termType", [
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("BlankNode"),
          }),
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("NamedNode"),
          }),
          zod.object({
            "@language": zod.string().optional(),
            "@type": zod.string().optional(),
            "@value": zod.string(),
            termType: zod.literal("Literal"),
          }),
        ])
        .optional(),
      convertibleTermProperty: zod.discriminatedUnion("termType", [
        zod.object({
          "@id": zod.string().min(1),
          termType: zod.literal("BlankNode"),
        }),
        zod.object({
          "@id": zod.string().min(1),
          termType: zod.literal("NamedNode"),
        }),
        zod.object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
          termType: zod.literal("Literal"),
        }),
      ]),
      convertibleTermSetProperty: zod
        .discriminatedUnion("termType", [
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("BlankNode"),
          }),
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("NamedNode"),
          }),
          zod.object({
            "@language": zod.string().optional(),
            "@type": zod.string().optional(),
            "@value": zod.string(),
            termType: zod.literal("Literal"),
          }),
        ])
        .array()
        .default(() => []),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ConvertibleTypePropertiesClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ConvertibleTypePropertiesClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ConvertibleTypePropertiesClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      convertibleIriNonEmptySetProperty: purify.NonEmptyList<rdfjs.NamedNode>;
      convertibleIriOptionProperty: purify.Maybe<rdfjs.NamedNode>;
      convertibleIriProperty: rdfjs.NamedNode;
      convertibleIriSetProperty: readonly rdfjs.NamedNode[];
      convertibleLiteralNonEmptySetProperty: purify.NonEmptyList<rdfjs.Literal>;
      convertibleLiteralOptionProperty: purify.Maybe<rdfjs.Literal>;
      convertibleLiteralProperty: rdfjs.Literal;
      convertibleLiteralSetProperty: readonly rdfjs.Literal[];
      convertibleTermNonEmptySetProperty: purify.NonEmptyList<
        rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal
      >;
      convertibleTermOptionProperty: purify.Maybe<
        rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal
      >;
      convertibleTermProperty:
        | rdfjs.BlankNode
        | rdfjs.NamedNode
        | rdfjs.Literal;
      convertibleTermSetProperty: readonly (
        | rdfjs.BlankNode
        | rdfjs.NamedNode
        | rdfjs.Literal
      )[];
    }
  > {
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/ConvertibleTypePropertiesClass":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $resource.isInstanceOf(ConvertibleTypePropertiesClass.$fromRdfType)
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ConvertibleTypePropertiesClass)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: ConvertibleTypePropertiesClass.$Identifier =
      $resource.identifier;
    const _convertibleIriNonEmptySetPropertyEither: purify.Either<
      Error,
      purify.NonEmptyList<rdfjs.NamedNode>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.convertibleIriNonEmptySetProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) => values.chainMap((value) => value.toIri()))
      .chain((values) =>
        purify.NonEmptyList.fromArray(values.toArray()).toEither(
          new Error(
            `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} is an empty set`,
          ),
        ),
      )
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          object: valuesArray,
          predicate:
            ConvertibleTypePropertiesClass.$properties
              .convertibleIriNonEmptySetProperty["identifier"],
          subject: $resource,
        }),
      )
      .chain((values) => values.head());
    if (_convertibleIriNonEmptySetPropertyEither.isLeft()) {
      return _convertibleIriNonEmptySetPropertyEither;
    }

    const convertibleIriNonEmptySetProperty =
      _convertibleIriNonEmptySetPropertyEither.unsafeCoerce();
    const _convertibleIriOptionPropertyEither: purify.Either<
      Error,
      purify.Maybe<rdfjs.NamedNode>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.convertibleIriOptionProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => values.chainMap((value) => value.toIri()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<rdfjs.NamedNode>
            >({
              object: purify.Maybe.empty(),
              predicate:
                ConvertibleTypePropertiesClass.$properties
                  .convertibleIriOptionProperty["identifier"],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_convertibleIriOptionPropertyEither.isLeft()) {
      return _convertibleIriOptionPropertyEither;
    }

    const convertibleIriOptionProperty =
      _convertibleIriOptionPropertyEither.unsafeCoerce();
    const _convertibleIriPropertyEither: purify.Either<Error, rdfjs.NamedNode> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.convertibleIriProperty["identifier"], {
          unique: true,
        }),
      )
        .chain((values) => values.chainMap((value) => value.toIri()))
        .chain((values) => values.head());
    if (_convertibleIriPropertyEither.isLeft()) {
      return _convertibleIriPropertyEither;
    }

    const convertibleIriProperty = _convertibleIriPropertyEither.unsafeCoerce();
    const _convertibleIriSetPropertyEither: purify.Either<
      Error,
      readonly rdfjs.NamedNode[]
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.convertibleIriSetProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => values.chainMap((value) => value.toIri()))
      .map((values) => values.toArray())
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          object: valuesArray,
          predicate:
            ConvertibleTypePropertiesClass.$properties
              .convertibleIriSetProperty["identifier"],
          subject: $resource,
        }),
      )
      .chain((values) => values.head());
    if (_convertibleIriSetPropertyEither.isLeft()) {
      return _convertibleIriSetPropertyEither;
    }

    const convertibleIriSetProperty =
      _convertibleIriSetPropertyEither.unsafeCoerce();
    const _convertibleLiteralNonEmptySetPropertyEither: purify.Either<
      Error,
      purify.NonEmptyList<rdfjs.Literal>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.convertibleLiteralNonEmptySetProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) => {
        if (!$preferredLanguages || $preferredLanguages.length === 0) {
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(values);
        }

        const literalValuesEither = values.chainMap((value) =>
          value.toLiteral(),
        );
        if (literalValuesEither.isLeft()) {
          return literalValuesEither;
        }
        const literalValues = literalValuesEither.unsafeCoerce();

        // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
        // Within a preferredLanguage the literals may be in any order.
        let filteredLiteralValues:
          | rdfjsResource.Resource.Values<rdfjs.Literal>
          | undefined;
        for (const preferredLanguage of $preferredLanguages) {
          if (!filteredLiteralValues) {
            filteredLiteralValues = literalValues.filter(
              (value) => value.language === preferredLanguage,
            );
          } else {
            filteredLiteralValues = filteredLiteralValues.concat(
              ...literalValues
                .filter((value) => value.language === preferredLanguage)
                .toArray(),
            );
          }
        }

        return purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
        >(
          filteredLiteralValues!.map(
            (literalValue) =>
              new rdfjsResource.Resource.Value({
                object: literalValue,
                predicate:
                  ConvertibleTypePropertiesClass.$properties
                    .convertibleLiteralNonEmptySetProperty["identifier"],
                subject: $resource,
              }),
          ),
        );
      })
      .chain((values) => values.chainMap((value) => value.toLiteral()))
      .chain((values) =>
        purify.NonEmptyList.fromArray(values.toArray()).toEither(
          new Error(
            `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} is an empty set`,
          ),
        ),
      )
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          object: valuesArray,
          predicate:
            ConvertibleTypePropertiesClass.$properties
              .convertibleLiteralNonEmptySetProperty["identifier"],
          subject: $resource,
        }),
      )
      .chain((values) => values.head());
    if (_convertibleLiteralNonEmptySetPropertyEither.isLeft()) {
      return _convertibleLiteralNonEmptySetPropertyEither;
    }

    const convertibleLiteralNonEmptySetProperty =
      _convertibleLiteralNonEmptySetPropertyEither.unsafeCoerce();
    const _convertibleLiteralOptionPropertyEither: purify.Either<
      Error,
      purify.Maybe<rdfjs.Literal>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.convertibleLiteralOptionProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) => {
        if (!$preferredLanguages || $preferredLanguages.length === 0) {
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(values);
        }

        const literalValuesEither = values.chainMap((value) =>
          value.toLiteral(),
        );
        if (literalValuesEither.isLeft()) {
          return literalValuesEither;
        }
        const literalValues = literalValuesEither.unsafeCoerce();

        // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
        // Within a preferredLanguage the literals may be in any order.
        let filteredLiteralValues:
          | rdfjsResource.Resource.Values<rdfjs.Literal>
          | undefined;
        for (const preferredLanguage of $preferredLanguages) {
          if (!filteredLiteralValues) {
            filteredLiteralValues = literalValues.filter(
              (value) => value.language === preferredLanguage,
            );
          } else {
            filteredLiteralValues = filteredLiteralValues.concat(
              ...literalValues
                .filter((value) => value.language === preferredLanguage)
                .toArray(),
            );
          }
        }

        return purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
        >(
          filteredLiteralValues!.map(
            (literalValue) =>
              new rdfjsResource.Resource.Value({
                object: literalValue,
                predicate:
                  ConvertibleTypePropertiesClass.$properties
                    .convertibleLiteralOptionProperty["identifier"],
                subject: $resource,
              }),
          ),
        );
      })
      .chain((values) => values.chainMap((value) => value.toLiteral()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<rdfjs.Literal>
            >({
              object: purify.Maybe.empty(),
              predicate:
                ConvertibleTypePropertiesClass.$properties
                  .convertibleLiteralOptionProperty["identifier"],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_convertibleLiteralOptionPropertyEither.isLeft()) {
      return _convertibleLiteralOptionPropertyEither;
    }

    const convertibleLiteralOptionProperty =
      _convertibleLiteralOptionPropertyEither.unsafeCoerce();
    const _convertibleLiteralPropertyEither: purify.Either<
      Error,
      rdfjs.Literal
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.convertibleLiteralProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => {
        if (!$preferredLanguages || $preferredLanguages.length === 0) {
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(values);
        }

        const literalValuesEither = values.chainMap((value) =>
          value.toLiteral(),
        );
        if (literalValuesEither.isLeft()) {
          return literalValuesEither;
        }
        const literalValues = literalValuesEither.unsafeCoerce();

        // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
        // Within a preferredLanguage the literals may be in any order.
        let filteredLiteralValues:
          | rdfjsResource.Resource.Values<rdfjs.Literal>
          | undefined;
        for (const preferredLanguage of $preferredLanguages) {
          if (!filteredLiteralValues) {
            filteredLiteralValues = literalValues.filter(
              (value) => value.language === preferredLanguage,
            );
          } else {
            filteredLiteralValues = filteredLiteralValues.concat(
              ...literalValues
                .filter((value) => value.language === preferredLanguage)
                .toArray(),
            );
          }
        }

        return purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
        >(
          filteredLiteralValues!.map(
            (literalValue) =>
              new rdfjsResource.Resource.Value({
                object: literalValue,
                predicate:
                  ConvertibleTypePropertiesClass.$properties
                    .convertibleLiteralProperty["identifier"],
                subject: $resource,
              }),
          ),
        );
      })
      .chain((values) => values.chainMap((value) => value.toLiteral()))
      .chain((values) => values.head());
    if (_convertibleLiteralPropertyEither.isLeft()) {
      return _convertibleLiteralPropertyEither;
    }

    const convertibleLiteralProperty =
      _convertibleLiteralPropertyEither.unsafeCoerce();
    const _convertibleLiteralSetPropertyEither: purify.Either<
      Error,
      readonly rdfjs.Literal[]
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.convertibleLiteralSetProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) => {
        if (!$preferredLanguages || $preferredLanguages.length === 0) {
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(values);
        }

        const literalValuesEither = values.chainMap((value) =>
          value.toLiteral(),
        );
        if (literalValuesEither.isLeft()) {
          return literalValuesEither;
        }
        const literalValues = literalValuesEither.unsafeCoerce();

        // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
        // Within a preferredLanguage the literals may be in any order.
        let filteredLiteralValues:
          | rdfjsResource.Resource.Values<rdfjs.Literal>
          | undefined;
        for (const preferredLanguage of $preferredLanguages) {
          if (!filteredLiteralValues) {
            filteredLiteralValues = literalValues.filter(
              (value) => value.language === preferredLanguage,
            );
          } else {
            filteredLiteralValues = filteredLiteralValues.concat(
              ...literalValues
                .filter((value) => value.language === preferredLanguage)
                .toArray(),
            );
          }
        }

        return purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
        >(
          filteredLiteralValues!.map(
            (literalValue) =>
              new rdfjsResource.Resource.Value({
                object: literalValue,
                predicate:
                  ConvertibleTypePropertiesClass.$properties
                    .convertibleLiteralSetProperty["identifier"],
                subject: $resource,
              }),
          ),
        );
      })
      .chain((values) => values.chainMap((value) => value.toLiteral()))
      .map((values) => values.toArray())
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          object: valuesArray,
          predicate:
            ConvertibleTypePropertiesClass.$properties
              .convertibleLiteralSetProperty["identifier"],
          subject: $resource,
        }),
      )
      .chain((values) => values.head());
    if (_convertibleLiteralSetPropertyEither.isLeft()) {
      return _convertibleLiteralSetPropertyEither;
    }

    const convertibleLiteralSetProperty =
      _convertibleLiteralSetPropertyEither.unsafeCoerce();
    const _convertibleTermNonEmptySetPropertyEither: purify.Either<
      Error,
      purify.NonEmptyList<rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.convertibleTermNonEmptySetProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          purify.Either.of<
            Error,
            rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
          >(value.toTerm()),
        ),
      )
      .chain((values) =>
        purify.NonEmptyList.fromArray(values.toArray()).toEither(
          new Error(
            `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} is an empty set`,
          ),
        ),
      )
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          object: valuesArray,
          predicate:
            ConvertibleTypePropertiesClass.$properties
              .convertibleTermNonEmptySetProperty["identifier"],
          subject: $resource,
        }),
      )
      .chain((values) => values.head());
    if (_convertibleTermNonEmptySetPropertyEither.isLeft()) {
      return _convertibleTermNonEmptySetPropertyEither;
    }

    const convertibleTermNonEmptySetProperty =
      _convertibleTermNonEmptySetPropertyEither.unsafeCoerce();
    const _convertibleTermOptionPropertyEither: purify.Either<
      Error,
      purify.Maybe<rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.convertibleTermOptionProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          purify.Either.of<
            Error,
            rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
          >(value.toTerm()),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal>
            >({
              object: purify.Maybe.empty(),
              predicate:
                ConvertibleTypePropertiesClass.$properties
                  .convertibleTermOptionProperty["identifier"],
              subject: $resource,
            }),
      )
      .chain((values) => values.head());
    if (_convertibleTermOptionPropertyEither.isLeft()) {
      return _convertibleTermOptionPropertyEither;
    }

    const convertibleTermOptionProperty =
      _convertibleTermOptionPropertyEither.unsafeCoerce();
    const _convertibleTermPropertyEither: purify.Either<
      Error,
      rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.convertibleTermProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) =>
        values.chainMap((value) =>
          purify.Either.of<
            Error,
            rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
          >(value.toTerm()),
        ),
      )
      .chain((values) => values.head());
    if (_convertibleTermPropertyEither.isLeft()) {
      return _convertibleTermPropertyEither;
    }

    const convertibleTermProperty =
      _convertibleTermPropertyEither.unsafeCoerce();
    const _convertibleTermSetPropertyEither: purify.Either<
      Error,
      readonly (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)[]
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values($properties.convertibleTermSetProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) =>
        values.chainMap((value) =>
          purify.Either.of<
            Error,
            rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
          >(value.toTerm()),
        ),
      )
      .map((values) => values.toArray())
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          object: valuesArray,
          predicate:
            ConvertibleTypePropertiesClass.$properties
              .convertibleTermSetProperty["identifier"],
          subject: $resource,
        }),
      )
      .chain((values) => values.head());
    if (_convertibleTermSetPropertyEither.isLeft()) {
      return _convertibleTermSetPropertyEither;
    }

    const convertibleTermSetProperty =
      _convertibleTermSetPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      convertibleIriNonEmptySetProperty,
      convertibleIriOptionProperty,
      convertibleIriProperty,
      convertibleIriSetProperty,
      convertibleLiteralNonEmptySetProperty,
      convertibleLiteralOptionProperty,
      convertibleLiteralProperty,
      convertibleLiteralSetProperty,
      convertibleTermNonEmptySetProperty,
      convertibleTermOptionProperty,
      convertibleTermProperty,
      convertibleTermSetProperty,
    });
  }

  export const $properties = {
    convertibleIriNonEmptySetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleIriNonEmptySetProperty",
      ),
    },
    convertibleIriOptionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleIriOptionProperty",
      ),
    },
    convertibleIriProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleIriProperty",
      ),
    },
    convertibleIriSetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleIriSetProperty",
      ),
    },
    convertibleLiteralNonEmptySetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleLiteralNonEmptySetProperty",
      ),
    },
    convertibleLiteralOptionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleLiteralOptionProperty",
      ),
    },
    convertibleLiteralProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleLiteralProperty",
      ),
    },
    convertibleLiteralSetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleLiteralSetProperty",
      ),
    },
    convertibleTermNonEmptySetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleTermNonEmptySetProperty",
      ),
    },
    convertibleTermOptionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleTermOptionProperty",
      ),
    },
    convertibleTermProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleTermProperty",
      ),
    },
    convertibleTermSetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleTermSetProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConvertibleTypePropertiesClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ConvertibleTypePropertiesClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConvertibleTypePropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("convertibleTypePropertiesClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "convertibleTypePropertiesClass");
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}ConvertibleIriNonEmptySetProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties
          .convertibleIriNonEmptySetProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}ConvertibleIriOptionProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties.convertibleIriOptionProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}ConvertibleIriProperty`),
      predicate:
        ConvertibleTypePropertiesClass.$properties.convertibleIriProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}ConvertibleIriSetProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties.convertibleIriSetProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}ConvertibleLiteralNonEmptySetProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties
          .convertibleLiteralNonEmptySetProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}ConvertibleLiteralOptionProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties
          .convertibleLiteralOptionProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}ConvertibleLiteralProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties.convertibleLiteralProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}ConvertibleLiteralSetProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties
          .convertibleLiteralSetProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}ConvertibleTermNonEmptySetProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties
          .convertibleTermNonEmptySetProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}ConvertibleTermOptionProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties
          .convertibleTermOptionProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}ConvertibleTermProperty`),
      predicate:
        ConvertibleTypePropertiesClass.$properties.convertibleTermProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}ConvertibleTermSetProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties.convertibleTermSetProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("convertibleTypePropertiesClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "convertibleTypePropertiesClass");
    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ConvertibleTypePropertiesClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}ConvertibleIriNonEmptySetProperty`,
            ),
            predicate:
              ConvertibleTypePropertiesClass.$properties
                .convertibleIriNonEmptySetProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}ConvertibleIriOptionProperty`,
                ),
                predicate:
                  ConvertibleTypePropertiesClass.$properties
                    .convertibleIriOptionProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}ConvertibleIriProperty`,
            ),
            predicate:
              ConvertibleTypePropertiesClass.$properties.convertibleIriProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}ConvertibleIriSetProperty`,
                ),
                predicate:
                  ConvertibleTypePropertiesClass.$properties
                    .convertibleIriSetProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}ConvertibleLiteralNonEmptySetProperty`,
            ),
            predicate:
              ConvertibleTypePropertiesClass.$properties
                .convertibleLiteralNonEmptySetProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}ConvertibleLiteralNonEmptySetProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}ConvertibleLiteralOptionProperty`,
                ),
                predicate:
                  ConvertibleTypePropertiesClass.$properties
                    .convertibleLiteralOptionProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...[parameters?.preferredLanguages ?? []]
            .filter((languages) => languages.length > 0)
            .map((languages) =>
              languages.map((language) => ({
                type: "operation" as const,
                operator: "=",
                args: [
                  {
                    type: "operation" as const,
                    operator: "lang",
                    args: [
                      dataFactory.variable!(
                        `${variablePrefix}ConvertibleLiteralOptionProperty`,
                      ),
                    ],
                  },
                  dataFactory.literal(language),
                ],
              })),
            )
            .map((langEqualsExpressions) => ({
              type: "filter" as const,
              expression: langEqualsExpressions.reduce(
                (reducedExpression, langEqualsExpression) => {
                  if (reducedExpression === null) {
                    return langEqualsExpression;
                  }
                  return {
                    type: "operation" as const,
                    operator: "||",
                    args: [reducedExpression, langEqualsExpression],
                  };
                },
                null as sparqljs.Expression | null,
              ) as sparqljs.Expression,
            })),
        ],
        type: "optional",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}ConvertibleLiteralProperty`,
            ),
            predicate:
              ConvertibleTypePropertiesClass.$properties
                .convertibleLiteralProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}ConvertibleLiteralProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}ConvertibleLiteralSetProperty`,
                ),
                predicate:
                  ConvertibleTypePropertiesClass.$properties
                    .convertibleLiteralSetProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...[parameters?.preferredLanguages ?? []]
            .filter((languages) => languages.length > 0)
            .map((languages) =>
              languages.map((language) => ({
                type: "operation" as const,
                operator: "=",
                args: [
                  {
                    type: "operation" as const,
                    operator: "lang",
                    args: [
                      dataFactory.variable!(
                        `${variablePrefix}ConvertibleLiteralSetProperty`,
                      ),
                    ],
                  },
                  dataFactory.literal(language),
                ],
              })),
            )
            .map((langEqualsExpressions) => ({
              type: "filter" as const,
              expression: langEqualsExpressions.reduce(
                (reducedExpression, langEqualsExpression) => {
                  if (reducedExpression === null) {
                    return langEqualsExpression;
                  }
                  return {
                    type: "operation" as const,
                    operator: "||",
                    args: [reducedExpression, langEqualsExpression],
                  };
                },
                null as sparqljs.Expression | null,
              ) as sparqljs.Expression,
            })),
        ],
        type: "optional",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}ConvertibleTermNonEmptySetProperty`,
            ),
            predicate:
              ConvertibleTypePropertiesClass.$properties
                .convertibleTermNonEmptySetProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}ConvertibleTermOptionProperty`,
                ),
                predicate:
                  ConvertibleTypePropertiesClass.$properties
                    .convertibleTermOptionProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}ConvertibleTermProperty`,
            ),
            predicate:
              ConvertibleTypePropertiesClass.$properties
                .convertibleTermProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}ConvertibleTermSetProperty`,
                ),
                predicate:
                  ConvertibleTypePropertiesClass.$properties
                    .convertibleTermSetProperty["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Base interface for other node shapes.
 */
export interface BaseInterfaceWithProperties {
  readonly $identifier: BaseInterfaceWithPropertiesStatic.$Identifier;
  readonly $type:
    | "BaseInterfaceWithProperties"
    | "BaseInterfaceWithoutProperties"
    | "ConcreteChildInterface"
    | "ConcreteParentInterface";
  readonly baseInterfaceWithPropertiesProperty: string;
}

export namespace BaseInterfaceWithPropertiesStatic {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly baseInterfaceWithPropertiesProperty: string;
  }): BaseInterfaceWithProperties {
    let $identifier: BaseInterfaceWithPropertiesStatic.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "BaseInterfaceWithProperties" as const;
    const baseInterfaceWithPropertiesProperty =
      parameters.baseInterfaceWithPropertiesProperty;
    return { $identifier, $type, baseInterfaceWithPropertiesProperty };
  }

  export function $equals(
    left: BaseInterfaceWithProperties,
    right: BaseInterfaceWithProperties,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.baseInterfaceWithPropertiesProperty,
          right.baseInterfaceWithPropertiesProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "baseInterfaceWithPropertiesProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/BaseInterfaceWithProperties",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type:
      | "BaseInterfaceWithProperties"
      | "BaseInterfaceWithoutProperties"
      | "ConcreteChildInterface"
      | "ConcreteParentInterface";
    readonly baseInterfaceWithPropertiesProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type:
        | "BaseInterfaceWithProperties"
        | "BaseInterfaceWithoutProperties"
        | "ConcreteChildInterface"
        | "ConcreteParentInterface";
      baseInterfaceWithPropertiesProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "BaseInterfaceWithProperties" as const;
    const baseInterfaceWithPropertiesProperty =
      $jsonObject["baseInterfaceWithPropertiesProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      baseInterfaceWithPropertiesProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, BaseInterfaceWithProperties> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "BaseInterfaceWithProperties" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/baseInterfaceWithPropertiesProperty`,
          type: "Control",
        },
      ],
      label: "BaseInterfaceWithProperties",
      type: "Group",
    };
  }

  export function $toJson(
    _baseInterfaceWithProperties: BaseInterfaceWithProperties,
  ): BaseInterfaceWithPropertiesStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _baseInterfaceWithProperties.$identifier.termType === "BlankNode"
            ? `_:${_baseInterfaceWithProperties.$identifier.value}`
            : _baseInterfaceWithProperties.$identifier.value,
        $type: _baseInterfaceWithProperties.$type,
        baseInterfaceWithPropertiesProperty:
          _baseInterfaceWithProperties.baseInterfaceWithPropertiesProperty,
      } satisfies BaseInterfaceWithPropertiesStatic.$Json),
    );
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.enum([
        "BaseInterfaceWithProperties",
        "BaseInterfaceWithoutProperties",
        "ConcreteChildInterface",
        "ConcreteParentInterface",
      ]),
      baseInterfaceWithPropertiesProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _baseInterfaceWithProperties: BaseInterfaceWithProperties,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_baseInterfaceWithProperties.$identifier.value);
    _hasher.update(_baseInterfaceWithProperties.$type);
    BaseInterfaceWithPropertiesStatic.$hashShaclProperties(
      _baseInterfaceWithProperties,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _baseInterfaceWithProperties: BaseInterfaceWithProperties,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _baseInterfaceWithProperties.baseInterfaceWithPropertiesProperty,
    );
    return _hasher;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, BaseInterfaceWithProperties> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return BaseInterfaceWithPropertiesStatic.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type:
        | "BaseInterfaceWithProperties"
        | "BaseInterfaceWithoutProperties"
        | "ConcreteChildInterface"
        | "ConcreteParentInterface";
      baseInterfaceWithPropertiesProperty: string;
    }
  > {
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/BaseInterfaceWithProperties":
            case "http://example.com/BaseInterfaceWithoutProperties":
            case "http://example.com/ConcreteParentInterface":
            case "http://example.com/ConcreteChildInterface":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $resource.isInstanceOf(
              BaseInterfaceWithPropertiesStatic.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/BaseInterfaceWithProperties)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: BaseInterfaceWithPropertiesStatic.$Identifier =
      $resource.identifier;
    const $type = "BaseInterfaceWithProperties" as const;
    const _baseInterfaceWithPropertiesPropertyEither: purify.Either<
      Error,
      string
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.baseInterfaceWithPropertiesProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) => {
        if (!$preferredLanguages || $preferredLanguages.length === 0) {
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(values);
        }

        const literalValuesEither = values.chainMap((value) =>
          value.toLiteral(),
        );
        if (literalValuesEither.isLeft()) {
          return literalValuesEither;
        }
        const literalValues = literalValuesEither.unsafeCoerce();

        // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
        // Within a preferredLanguage the literals may be in any order.
        let filteredLiteralValues:
          | rdfjsResource.Resource.Values<rdfjs.Literal>
          | undefined;
        for (const preferredLanguage of $preferredLanguages) {
          if (!filteredLiteralValues) {
            filteredLiteralValues = literalValues.filter(
              (value) => value.language === preferredLanguage,
            );
          } else {
            filteredLiteralValues = filteredLiteralValues.concat(
              ...literalValues
                .filter((value) => value.language === preferredLanguage)
                .toArray(),
            );
          }
        }

        return purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
        >(
          filteredLiteralValues!.map(
            (literalValue) =>
              new rdfjsResource.Resource.Value({
                object: literalValue,
                predicate:
                  BaseInterfaceWithPropertiesStatic.$properties
                    .baseInterfaceWithPropertiesProperty["identifier"],
                subject: $resource,
              }),
          ),
        );
      })
      .chain((values) => values.chainMap((value) => value.toString()))
      .chain((values) => values.head());
    if (_baseInterfaceWithPropertiesPropertyEither.isLeft()) {
      return _baseInterfaceWithPropertiesPropertyEither;
    }

    const baseInterfaceWithPropertiesProperty =
      _baseInterfaceWithPropertiesPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      $type,
      baseInterfaceWithPropertiesProperty,
    });
  }

  export function $toRdf(
    _baseInterfaceWithProperties: BaseInterfaceWithProperties,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _baseInterfaceWithProperties.$identifier,
      { mutateGraph },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/BaseInterfaceWithProperties",
        ),
      );
    }

    resource.add(
      BaseInterfaceWithPropertiesStatic.$properties
        .baseInterfaceWithPropertiesProperty["identifier"],
      ...[_baseInterfaceWithProperties.baseInterfaceWithPropertiesProperty],
    );
    return resource;
  }

  export const $properties = {
    baseInterfaceWithPropertiesProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/baseInterfaceWithPropertiesProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BaseInterfaceWithPropertiesStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        BaseInterfaceWithPropertiesStatic.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BaseInterfaceWithPropertiesStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("baseInterfaceWithProperties");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "baseInterfaceWithProperties");
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}BaseInterfaceWithPropertiesProperty`,
      ),
      predicate:
        BaseInterfaceWithPropertiesStatic.$properties
          .baseInterfaceWithPropertiesProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("baseInterfaceWithProperties");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "baseInterfaceWithProperties");
    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        {
          type: "values" as const,
          values: [
            BaseInterfaceWithPropertiesStatic.$fromRdfType,
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[`?${variablePrefix}FromRdfType`] =
              identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(`${variablePrefix}FromRdfType`),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}BaseInterfaceWithPropertiesProperty`,
            ),
            predicate:
              BaseInterfaceWithPropertiesStatic.$properties
                .baseInterfaceWithPropertiesProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}BaseInterfaceWithPropertiesProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Base interface for other node shapes. Put the base interface with properties above the base interface without.
 */
export interface BaseInterfaceWithoutProperties
  extends BaseInterfaceWithProperties {
  readonly $identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier;
  readonly $type:
    | "BaseInterfaceWithoutProperties"
    | "ConcreteChildInterface"
    | "ConcreteParentInterface";
}

export namespace BaseInterfaceWithoutPropertiesStatic {
  export function $create(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & Parameters<typeof BaseInterfaceWithPropertiesStatic.$create>[0],
  ): BaseInterfaceWithoutProperties {
    let $identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "BaseInterfaceWithoutProperties" as const;
    return {
      ...BaseInterfaceWithPropertiesStatic.$create(parameters),
      $identifier,
      $type,
    };
  }

  export function $equals(
    left: BaseInterfaceWithoutProperties,
    right: BaseInterfaceWithoutProperties,
  ): $EqualsResult {
    return BaseInterfaceWithPropertiesStatic.$equals(left, right);
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/BaseInterfaceWithoutProperties",
  );
  export type $Identifier = BaseInterfaceWithPropertiesStatic.$Identifier;
  export const $Identifier = BaseInterfaceWithPropertiesStatic.$Identifier;
  export type $Json = BaseInterfaceWithPropertiesStatic.$Json;

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type:
        | "BaseInterfaceWithoutProperties"
        | "ConcreteChildInterface"
        | "ConcreteParentInterface";
    } & $UnwrapR<
      ReturnType<typeof BaseInterfaceWithPropertiesStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      BaseInterfaceWithPropertiesStatic.$propertiesFromJson($jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "BaseInterfaceWithoutProperties" as const;
    return purify.Either.of({ ...$super0, $identifier, $type });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, BaseInterfaceWithoutProperties> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseInterfaceWithPropertiesStatic.$jsonUiSchema({ scopePrefix }),
      ],
      label: "BaseInterfaceWithoutProperties",
      type: "Group",
    };
  }

  export function $toJson(
    _baseInterfaceWithoutProperties: BaseInterfaceWithoutProperties,
  ): BaseInterfaceWithoutPropertiesStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...BaseInterfaceWithPropertiesStatic.$toJson(
          _baseInterfaceWithoutProperties,
        ),
      } satisfies BaseInterfaceWithoutPropertiesStatic.$Json),
    );
  }

  export function $jsonZodSchema() {
    return BaseInterfaceWithPropertiesStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "BaseInterfaceWithoutProperties",
          "ConcreteChildInterface",
          "ConcreteParentInterface",
        ]),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _baseInterfaceWithoutProperties: BaseInterfaceWithoutProperties,
    _hasher: HasherT,
  ): HasherT {
    BaseInterfaceWithoutPropertiesStatic.$hashShaclProperties(
      _baseInterfaceWithoutProperties,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _baseInterfaceWithoutProperties: BaseInterfaceWithoutProperties,
    _hasher: HasherT,
  ): HasherT {
    BaseInterfaceWithPropertiesStatic.$hashShaclProperties(
      _baseInterfaceWithoutProperties,
      _hasher,
    );
    return _hasher;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, BaseInterfaceWithoutProperties> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return BaseInterfaceWithoutPropertiesStatic.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type:
        | "BaseInterfaceWithoutProperties"
        | "ConcreteChildInterface"
        | "ConcreteParentInterface";
    } & $UnwrapR<
      ReturnType<typeof BaseInterfaceWithPropertiesStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = BaseInterfaceWithPropertiesStatic.$propertiesFromRdf({
      ...$context,
      ignoreRdfType: true,
      objectSet: $objectSet,
      preferredLanguages: $preferredLanguages,
      resource: $resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/BaseInterfaceWithoutProperties":
            case "http://example.com/ConcreteParentInterface":
            case "http://example.com/ConcreteChildInterface":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $resource.isInstanceOf(
              BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/BaseInterfaceWithoutProperties)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier =
      $resource.identifier;
    const $type = "BaseInterfaceWithoutProperties" as const;
    return purify.Either.of({ ...$super0, $identifier, $type });
  }

  export function $toRdf(
    _baseInterfaceWithoutProperties: BaseInterfaceWithoutProperties,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = BaseInterfaceWithPropertiesStatic.$toRdf(
      _baseInterfaceWithoutProperties,
      { ignoreRdfType: true, mutateGraph, resourceSet },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/BaseInterfaceWithoutProperties",
        ),
      );
    }

    return resource;
  }

  export const $properties = {
    ...BaseInterfaceWithPropertiesStatic.$properties,
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BaseInterfaceWithoutPropertiesStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        BaseInterfaceWithoutPropertiesStatic.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BaseInterfaceWithoutPropertiesStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("baseInterfaceWithoutProperties");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "baseInterfaceWithoutProperties");
    triples.push(
      ...BaseInterfaceWithPropertiesStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("baseInterfaceWithoutProperties");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "baseInterfaceWithoutProperties");
    for (const pattern of BaseInterfaceWithPropertiesStatic.$sparqlWherePatterns(
      { ignoreRdfType: true, subject, variablePrefix },
    )) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        {
          type: "values" as const,
          values: [
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[`?${variablePrefix}FromRdfType`] =
              identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(`${variablePrefix}FromRdfType`),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Interface node shape that inherits the base interface and is the parent of the ConcreteChildInterface.
 */
export interface ConcreteParentInterface
  extends BaseInterfaceWithoutProperties {
  readonly $identifier: ConcreteParentInterfaceStatic.$Identifier;
  readonly $type: "ConcreteParentInterface" | "ConcreteChildInterface";
  readonly concreteParentInterfaceProperty: string;
}

export namespace ConcreteParentInterfaceStatic {
  export function $create(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly concreteParentInterfaceProperty: string;
    } & Parameters<typeof BaseInterfaceWithoutPropertiesStatic.$create>[0],
  ): ConcreteParentInterface {
    let $identifier: ConcreteParentInterfaceStatic.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "ConcreteParentInterface" as const;
    const concreteParentInterfaceProperty =
      parameters.concreteParentInterfaceProperty;
    return {
      ...BaseInterfaceWithoutPropertiesStatic.$create(parameters),
      $identifier,
      $type,
      concreteParentInterfaceProperty,
    };
  }

  export function $equals(
    left: ConcreteParentInterface,
    right: ConcreteParentInterface,
  ): $EqualsResult {
    return BaseInterfaceWithoutPropertiesStatic.$equals(left, right).chain(() =>
      $strictEquals(
        left.concreteParentInterfaceProperty,
        right.concreteParentInterfaceProperty,
      ).mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "concreteParentInterfaceProperty",
        propertyValuesUnequal,
        type: "Property" as const,
      })),
    );
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ConcreteParentInterface",
  );
  export type $Identifier = BaseInterfaceWithoutPropertiesStatic.$Identifier;
  export const $Identifier = BaseInterfaceWithoutPropertiesStatic.$Identifier;
  export type $Json = {
    readonly concreteParentInterfaceProperty: string;
  } & BaseInterfaceWithoutPropertiesStatic.$Json;

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "ConcreteParentInterface" | "ConcreteChildInterface";
      concreteParentInterfaceProperty: string;
    } & $UnwrapR<
      ReturnType<
        typeof BaseInterfaceWithoutPropertiesStatic.$propertiesFromJson
      >
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      BaseInterfaceWithoutPropertiesStatic.$propertiesFromJson($jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "ConcreteParentInterface" as const;
    const concreteParentInterfaceProperty =
      $jsonObject["concreteParentInterfaceProperty"];
    return purify.Either.of({
      ...$super0,
      $identifier,
      $type,
      concreteParentInterfaceProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ConcreteParentInterface> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseInterfaceWithoutPropertiesStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/concreteParentInterfaceProperty`,
          type: "Control",
        },
      ],
      label: "ConcreteParentInterface",
      type: "Group",
    };
  }

  export function $toJson(
    _concreteParentInterface: ConcreteParentInterface,
  ): ConcreteParentInterfaceStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...BaseInterfaceWithoutPropertiesStatic.$toJson(
          _concreteParentInterface,
        ),
        concreteParentInterfaceProperty:
          _concreteParentInterface.concreteParentInterfaceProperty,
      } satisfies ConcreteParentInterfaceStatic.$Json),
    );
  }

  export function $jsonZodSchema() {
    return BaseInterfaceWithoutPropertiesStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["ConcreteParentInterface", "ConcreteChildInterface"]),
        concreteParentInterfaceProperty: zod.string(),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _concreteParentInterface: ConcreteParentInterface,
    _hasher: HasherT,
  ): HasherT {
    ConcreteParentInterfaceStatic.$hashShaclProperties(
      _concreteParentInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _concreteParentInterface: ConcreteParentInterface,
    _hasher: HasherT,
  ): HasherT {
    BaseInterfaceWithoutPropertiesStatic.$hashShaclProperties(
      _concreteParentInterface,
      _hasher,
    );
    _hasher.update(_concreteParentInterface.concreteParentInterfaceProperty);
    return _hasher;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ConcreteParentInterface> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ConcreteParentInterfaceStatic.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "ConcreteParentInterface" | "ConcreteChildInterface";
      concreteParentInterfaceProperty: string;
    } & $UnwrapR<
      ReturnType<typeof BaseInterfaceWithoutPropertiesStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either =
      BaseInterfaceWithoutPropertiesStatic.$propertiesFromRdf({
        ...$context,
        ignoreRdfType: true,
        objectSet: $objectSet,
        preferredLanguages: $preferredLanguages,
        resource: $resource,
      });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/ConcreteParentInterface":
            case "http://example.com/ConcreteChildInterface":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $resource.isInstanceOf(ConcreteParentInterfaceStatic.$fromRdfType)
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ConcreteParentInterface)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: ConcreteParentInterfaceStatic.$Identifier =
      $resource.identifier;
    const $type = "ConcreteParentInterface" as const;
    const _concreteParentInterfacePropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.concreteParentInterfaceProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    ConcreteParentInterfaceStatic.$properties
                      .concreteParentInterfaceProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_concreteParentInterfacePropertyEither.isLeft()) {
      return _concreteParentInterfacePropertyEither;
    }

    const concreteParentInterfaceProperty =
      _concreteParentInterfacePropertyEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      $type,
      concreteParentInterfaceProperty,
    });
  }

  export function $toRdf(
    _concreteParentInterface: ConcreteParentInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = BaseInterfaceWithoutPropertiesStatic.$toRdf(
      _concreteParentInterface,
      { ignoreRdfType: true, mutateGraph, resourceSet },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/ConcreteParentInterface",
        ),
      );
    }

    resource.add(
      ConcreteParentInterfaceStatic.$properties.concreteParentInterfaceProperty[
        "identifier"
      ],
      ...[_concreteParentInterface.concreteParentInterfaceProperty],
    );
    return resource;
  }

  export const $properties = {
    ...BaseInterfaceWithoutPropertiesStatic.$properties,
    concreteParentInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/concreteParentInterfaceProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConcreteParentInterfaceStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ConcreteParentInterfaceStatic.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConcreteParentInterfaceStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteParentInterface");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "concreteParentInterface");
    triples.push(
      ...BaseInterfaceWithoutPropertiesStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}ConcreteParentInterfaceProperty`,
      ),
      predicate:
        ConcreteParentInterfaceStatic.$properties
          .concreteParentInterfaceProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteParentInterface");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "concreteParentInterface");
    for (const pattern of BaseInterfaceWithoutPropertiesStatic.$sparqlWherePatterns(
      { ignoreRdfType: true, subject, variablePrefix },
    )) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        {
          type: "values" as const,
          values: [
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[`?${variablePrefix}FromRdfType`] =
              identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(`${variablePrefix}FromRdfType`),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}ConcreteParentInterfaceProperty`,
            ),
            predicate:
              ConcreteParentInterfaceStatic.$properties
                .concreteParentInterfaceProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}ConcreteParentInterfaceProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Child interface of ConcreteParentInterface. Should inherit properties and node kinds.
 */
export interface ConcreteChildInterface extends ConcreteParentInterface {
  readonly $identifier: ConcreteChildInterface.$Identifier;
  readonly $type: "ConcreteChildInterface";
  readonly concreteChildInterfaceProperty: string;
}

export namespace ConcreteChildInterface {
  export function $create(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly concreteChildInterfaceProperty: string;
    } & Parameters<typeof ConcreteParentInterfaceStatic.$create>[0],
  ): ConcreteChildInterface {
    let $identifier: ConcreteChildInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "ConcreteChildInterface" as const;
    const concreteChildInterfaceProperty =
      parameters.concreteChildInterfaceProperty;
    return {
      ...ConcreteParentInterfaceStatic.$create(parameters),
      $identifier,
      $type,
      concreteChildInterfaceProperty,
    };
  }

  export function $equals(
    left: ConcreteChildInterface,
    right: ConcreteChildInterface,
  ): $EqualsResult {
    return ConcreteParentInterfaceStatic.$equals(left, right).chain(() =>
      $strictEquals(
        left.concreteChildInterfaceProperty,
        right.concreteChildInterfaceProperty,
      ).mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "concreteChildInterfaceProperty",
        propertyValuesUnequal,
        type: "Property" as const,
      })),
    );
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ConcreteChildInterface",
  );
  export type $Identifier = ConcreteParentInterfaceStatic.$Identifier;
  export const $Identifier = ConcreteParentInterfaceStatic.$Identifier;
  export type $Json = {
    readonly concreteChildInterfaceProperty: string;
  } & ConcreteParentInterfaceStatic.$Json;

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "ConcreteChildInterface";
      concreteChildInterfaceProperty: string;
    } & $UnwrapR<
      ReturnType<typeof ConcreteParentInterfaceStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      ConcreteParentInterfaceStatic.$propertiesFromJson($jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "ConcreteChildInterface" as const;
    const concreteChildInterfaceProperty =
      $jsonObject["concreteChildInterfaceProperty"];
    return purify.Either.of({
      ...$super0,
      $identifier,
      $type,
      concreteChildInterfaceProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ConcreteChildInterface> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ConcreteParentInterfaceStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/concreteChildInterfaceProperty`,
          type: "Control",
        },
      ],
      label: "ConcreteChildInterface",
      type: "Group",
    };
  }

  export function $toJson(
    _concreteChildInterface: ConcreteChildInterface,
  ): ConcreteChildInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        ...ConcreteParentInterfaceStatic.$toJson(_concreteChildInterface),
        concreteChildInterfaceProperty:
          _concreteChildInterface.concreteChildInterfaceProperty,
      } satisfies ConcreteChildInterface.$Json),
    );
  }

  export function $jsonZodSchema() {
    return ConcreteParentInterfaceStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("ConcreteChildInterface"),
        concreteChildInterfaceProperty: zod.string(),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _concreteChildInterface: ConcreteChildInterface,
    _hasher: HasherT,
  ): HasherT {
    ConcreteChildInterface.$hashShaclProperties(
      _concreteChildInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _concreteChildInterface: ConcreteChildInterface,
    _hasher: HasherT,
  ): HasherT {
    ConcreteParentInterfaceStatic.$hashShaclProperties(
      _concreteChildInterface,
      _hasher,
    );
    _hasher.update(_concreteChildInterface.concreteChildInterfaceProperty);
    return _hasher;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ConcreteChildInterface> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ConcreteChildInterface.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "ConcreteChildInterface";
      concreteChildInterfaceProperty: string;
    } & $UnwrapR<
      ReturnType<typeof ConcreteParentInterfaceStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = ConcreteParentInterfaceStatic.$propertiesFromRdf({
      ...$context,
      ignoreRdfType: true,
      objectSet: $objectSet,
      preferredLanguages: $preferredLanguages,
      resource: $resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/ConcreteChildInterface":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if ($resource.isInstanceOf(ConcreteChildInterface.$fromRdfType)) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ConcreteChildInterface)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: ConcreteChildInterface.$Identifier =
      $resource.identifier;
    const $type = "ConcreteChildInterface" as const;
    const _concreteChildInterfacePropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.concreteChildInterfaceProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    ConcreteChildInterface.$properties
                      .concreteChildInterfaceProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_concreteChildInterfacePropertyEither.isLeft()) {
      return _concreteChildInterfacePropertyEither;
    }

    const concreteChildInterfaceProperty =
      _concreteChildInterfacePropertyEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      $type,
      concreteChildInterfaceProperty,
    });
  }

  export function $toRdf(
    _concreteChildInterface: ConcreteChildInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = ConcreteParentInterfaceStatic.$toRdf(
      _concreteChildInterface,
      { ignoreRdfType: true, mutateGraph, resourceSet },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/ConcreteChildInterface",
        ),
      );
    }

    resource.add(
      ConcreteChildInterface.$properties.concreteChildInterfaceProperty[
        "identifier"
      ],
      ...[_concreteChildInterface.concreteChildInterfaceProperty],
    );
    return resource;
  }

  export const $properties = {
    ...ConcreteParentInterfaceStatic.$properties,
    concreteChildInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/concreteChildInterfaceProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConcreteChildInterface.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ConcreteChildInterface.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConcreteChildInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteChildInterface");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "concreteChildInterface");
    triples.push(
      ...ConcreteParentInterfaceStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}ConcreteChildInterfaceProperty`,
      ),
      predicate:
        ConcreteChildInterface.$properties.concreteChildInterfaceProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteChildInterface");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "concreteChildInterface");
    for (const pattern of ConcreteParentInterfaceStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ConcreteChildInterface.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}ConcreteChildInterfaceProperty`,
            ),
            predicate:
              ConcreteChildInterface.$properties.concreteChildInterfaceProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}ConcreteChildInterfaceProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Node shape that serves as an abstract base class for child node shapes.
 *
 * It's marked abstract in TypeScript and not exported from the module.
 *
 * Common pattern: put the minting strategy and nodeKind on an ABC.
 */
export abstract class AbstractBaseClassWithProperties {
  abstract readonly $identifier: AbstractBaseClassWithPropertiesStatic.$Identifier;
  protected readonly _$identifierPrefix?: string;
  abstract readonly $type: "ConcreteChildClass" | "ConcreteParentClass";
  readonly abstractBaseClassWithPropertiesProperty: string;

  constructor(parameters: {
    readonly $identifierPrefix?: string;
    readonly abstractBaseClassWithPropertiesProperty: string;
  }) {
    this._$identifierPrefix = parameters.$identifierPrefix;
    this.abstractBaseClassWithPropertiesProperty =
      parameters.abstractBaseClassWithPropertiesProperty;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  $equals(other: AbstractBaseClassWithProperties): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$identifierPrefix, other.$identifierPrefix).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$identifierPrefix",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.abstractBaseClassWithPropertiesProperty,
          other.abstractBaseClassWithPropertiesProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "abstractBaseClassWithPropertiesProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.abstractBaseClassWithPropertiesProperty);
    return _hasher;
  }

  $toJson(): AbstractBaseClassWithPropertiesStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        abstractBaseClassWithPropertiesProperty:
          this.abstractBaseClassWithPropertiesProperty,
      } satisfies AbstractBaseClassWithPropertiesStatic.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      AbstractBaseClassWithPropertiesStatic.$properties
        .abstractBaseClassWithPropertiesProperty["identifier"],
      ...[this.abstractBaseClassWithPropertiesProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace AbstractBaseClassWithPropertiesStatic {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ConcreteChildClass" | "ConcreteParentClass";
    readonly abstractBaseClassWithPropertiesProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      abstractBaseClassWithPropertiesProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const abstractBaseClassWithPropertiesProperty =
      $jsonObject["abstractBaseClassWithPropertiesProperty"];
    return purify.Either.of({
      $identifier,
      abstractBaseClassWithPropertiesProperty,
    });
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "AbstractBaseClassWithProperties" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/abstractBaseClassWithPropertiesProperty`,
          type: "Control",
        },
      ],
      label: "AbstractBaseClassWithProperties",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.enum(["ConcreteChildClass", "ConcreteParentClass"]),
      abstractBaseClassWithPropertiesProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      abstractBaseClassWithPropertiesProperty: string;
    }
  > {
    const $identifier: AbstractBaseClassWithPropertiesStatic.$Identifier =
      $resource.identifier;
    const _abstractBaseClassWithPropertiesPropertyEither: purify.Either<
      Error,
      string
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.abstractBaseClassWithPropertiesProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) => {
        if (!$preferredLanguages || $preferredLanguages.length === 0) {
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(values);
        }

        const literalValuesEither = values.chainMap((value) =>
          value.toLiteral(),
        );
        if (literalValuesEither.isLeft()) {
          return literalValuesEither;
        }
        const literalValues = literalValuesEither.unsafeCoerce();

        // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
        // Within a preferredLanguage the literals may be in any order.
        let filteredLiteralValues:
          | rdfjsResource.Resource.Values<rdfjs.Literal>
          | undefined;
        for (const preferredLanguage of $preferredLanguages) {
          if (!filteredLiteralValues) {
            filteredLiteralValues = literalValues.filter(
              (value) => value.language === preferredLanguage,
            );
          } else {
            filteredLiteralValues = filteredLiteralValues.concat(
              ...literalValues
                .filter((value) => value.language === preferredLanguage)
                .toArray(),
            );
          }
        }

        return purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
        >(
          filteredLiteralValues!.map(
            (literalValue) =>
              new rdfjsResource.Resource.Value({
                object: literalValue,
                predicate:
                  AbstractBaseClassWithPropertiesStatic.$properties
                    .abstractBaseClassWithPropertiesProperty["identifier"],
                subject: $resource,
              }),
          ),
        );
      })
      .chain((values) => values.chainMap((value) => value.toString()))
      .chain((values) => values.head());
    if (_abstractBaseClassWithPropertiesPropertyEither.isLeft()) {
      return _abstractBaseClassWithPropertiesPropertyEither;
    }

    const abstractBaseClassWithPropertiesProperty =
      _abstractBaseClassWithPropertiesPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      abstractBaseClassWithPropertiesProperty,
    });
  }

  export const $properties = {
    abstractBaseClassWithPropertiesProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/abstractBaseClassWithPropertiesProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        AbstractBaseClassWithPropertiesStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        AbstractBaseClassWithPropertiesStatic.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      AbstractBaseClassWithPropertiesStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassWithProperties");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "abstractBaseClassWithProperties");
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}AbstractBaseClassWithPropertiesProperty`,
      ),
      predicate:
        AbstractBaseClassWithPropertiesStatic.$properties
          .abstractBaseClassWithPropertiesProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassWithProperties");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "abstractBaseClassWithProperties");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}AbstractBaseClassWithPropertiesProperty`,
            ),
            predicate:
              AbstractBaseClassWithPropertiesStatic.$properties
                .abstractBaseClassWithPropertiesProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}AbstractBaseClassWithPropertiesProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Abstract base for other node shapes. Put the ABC with properties above the ABC without.
 */
export abstract class AbstractBaseClassWithoutProperties extends AbstractBaseClassWithProperties {
  abstract override readonly $identifier: AbstractBaseClassWithoutPropertiesStatic.$Identifier;
  abstract override readonly $type:
    | "ConcreteChildClass"
    | "ConcreteParentClass";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: { readonly $identifierPrefix?: string } & ConstructorParameters<
      typeof AbstractBaseClassWithProperties
    >[0],
  ) {
    super(parameters);
  }

  protected override get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace AbstractBaseClassWithoutPropertiesStatic {
  export type $Identifier = AbstractBaseClassWithPropertiesStatic.$Identifier;
  export const $Identifier = AbstractBaseClassWithPropertiesStatic.$Identifier;
  export type $Json = AbstractBaseClassWithPropertiesStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<
        typeof AbstractBaseClassWithPropertiesStatic.$propertiesFromJson
      >
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      AbstractBaseClassWithPropertiesStatic.$propertiesFromJson($jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        AbstractBaseClassWithPropertiesStatic.$jsonUiSchema({ scopePrefix }),
      ],
      label: "AbstractBaseClassWithoutProperties",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return AbstractBaseClassWithPropertiesStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["ConcreteChildClass", "ConcreteParentClass"]),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<
        typeof AbstractBaseClassWithPropertiesStatic.$propertiesFromRdf
      >
    >
  > {
    const $super0Either =
      AbstractBaseClassWithPropertiesStatic.$propertiesFromRdf({
        ...$context,
        ignoreRdfType: true,
        objectSet: $objectSet,
        preferredLanguages: $preferredLanguages,
        resource: $resource,
      });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier: AbstractBaseClassWithoutPropertiesStatic.$Identifier =
      $resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export const $properties = {
    ...AbstractBaseClassWithPropertiesStatic.$properties,
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        AbstractBaseClassWithoutPropertiesStatic.$sparqlConstructTemplateTriples(
          { ignoreRdfType, subject },
        ),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        AbstractBaseClassWithoutPropertiesStatic.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      AbstractBaseClassWithoutPropertiesStatic.$sparqlConstructQuery(
        parameters,
      ),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassWithoutProperties");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "abstractBaseClassWithoutProperties");
    triples.push(
      ...AbstractBaseClassWithPropertiesStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassWithoutProperties");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "abstractBaseClassWithoutProperties");
    for (const pattern of AbstractBaseClassWithPropertiesStatic.$sparqlWherePatterns(
      { ignoreRdfType: true, subject, variablePrefix },
    )) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Class node shape that inherits the abstract base class and is the parent of the ConcreteChildClass.
 */
export class ConcreteParentClass extends AbstractBaseClassWithoutProperties {
  protected _$identifier?: ConcreteParentClassStatic.$Identifier;
  override readonly $type: "ConcreteParentClass" | "ConcreteChildClass" =
    "ConcreteParentClass";
  readonly concreteParentClassProperty: string;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly $identifierPrefix?: string;
      readonly concreteParentClassProperty: string;
    } & ConstructorParameters<typeof AbstractBaseClassWithoutProperties>[0],
  ) {
    super(parameters);
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.concreteParentClassProperty = parameters.concreteParentClassProperty;
  }

  override get $identifier(): ConcreteParentClassStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }
    return this._$identifier;
  }

  protected override get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  override $equals(other: ConcreteParentClass): $EqualsResult {
    return super.$equals(other).chain(() =>
      $strictEquals(
        this.concreteParentClassProperty,
        other.concreteParentClassProperty,
      ).mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "concreteParentClassProperty",
        propertyValuesUnequal,
        type: "Property" as const,
      })),
    );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    _hasher.update(this.concreteParentClassProperty);
    return _hasher;
  }

  override $toJson(): ConcreteParentClassStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        concreteParentClassProperty: this.concreteParentClassProperty,
      } satisfies ConcreteParentClassStatic.$Json),
    );
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/ConcreteParentClass",
        ),
      );
    }

    resource.add(
      ConcreteParentClassStatic.$properties.concreteParentClassProperty[
        "identifier"
      ],
      ...[this.concreteParentClassProperty],
    );
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ConcreteParentClassStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ConcreteParentClass",
  );
  export type $Identifier =
    AbstractBaseClassWithoutPropertiesStatic.$Identifier;
  export const $Identifier =
    AbstractBaseClassWithoutPropertiesStatic.$Identifier;
  export type $Json = {
    readonly concreteParentClassProperty: string;
  } & AbstractBaseClassWithoutPropertiesStatic.$Json;

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      concreteParentClassProperty: string;
    } & $UnwrapR<
      ReturnType<
        typeof AbstractBaseClassWithoutPropertiesStatic.$propertiesFromJson
      >
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      AbstractBaseClassWithoutPropertiesStatic.$propertiesFromJson($jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const concreteParentClassProperty =
      $jsonObject["concreteParentClassProperty"];
    return purify.Either.of({
      ...$super0,
      $identifier,
      concreteParentClassProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ConcreteParentClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ConcreteParentClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        AbstractBaseClassWithoutPropertiesStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/concreteParentClassProperty`,
          type: "Control",
        },
      ],
      label: "ConcreteParentClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return AbstractBaseClassWithoutPropertiesStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["ConcreteParentClass", "ConcreteChildClass"]),
        concreteParentClassProperty: zod.string(),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ConcreteParentClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ConcreteParentClassStatic.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ConcreteParentClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      concreteParentClassProperty: string;
    } & $UnwrapR<
      ReturnType<
        typeof AbstractBaseClassWithoutPropertiesStatic.$propertiesFromRdf
      >
    >
  > {
    const $super0Either =
      AbstractBaseClassWithoutPropertiesStatic.$propertiesFromRdf({
        ...$context,
        ignoreRdfType: true,
        objectSet: $objectSet,
        preferredLanguages: $preferredLanguages,
        resource: $resource,
      });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/ConcreteParentClass":
            case "http://example.com/ConcreteChildClass":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if ($resource.isInstanceOf(ConcreteParentClassStatic.$fromRdfType)) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ConcreteParentClass)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: ConcreteParentClassStatic.$Identifier =
      $resource.identifier;
    const _concreteParentClassPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values(
          $properties.concreteParentClassProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    ConcreteParentClassStatic.$properties
                      .concreteParentClassProperty["identifier"],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_concreteParentClassPropertyEither.isLeft()) {
      return _concreteParentClassPropertyEither;
    }

    const concreteParentClassProperty =
      _concreteParentClassPropertyEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      concreteParentClassProperty,
    });
  }

  export const $properties = {
    ...AbstractBaseClassWithoutPropertiesStatic.$properties,
    concreteParentClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/concreteParentClassProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConcreteParentClassStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ConcreteParentClassStatic.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConcreteParentClassStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteParentClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "concreteParentClass");
    triples.push(
      ...AbstractBaseClassWithoutPropertiesStatic.$sparqlConstructTemplateTriples(
        { ignoreRdfType: true, subject, variablePrefix },
      ),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}ConcreteParentClassProperty`,
      ),
      predicate:
        ConcreteParentClassStatic.$properties.concreteParentClassProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteParentClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "concreteParentClass");
    for (const pattern of AbstractBaseClassWithoutPropertiesStatic.$sparqlWherePatterns(
      { ignoreRdfType: true, subject, variablePrefix },
    )) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        {
          type: "values" as const,
          values: [
            ConcreteParentClassStatic.$fromRdfType,
            ConcreteChildClass.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[`?${variablePrefix}FromRdfType`] =
              identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(`${variablePrefix}FromRdfType`),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}ConcreteParentClassProperty`,
            ),
            predicate:
              ConcreteParentClassStatic.$properties.concreteParentClassProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}ConcreteParentClassProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Child (class) of ConcreteParentClass. Should inherit properties, node kinds, and minting strategy.
 */
export class ConcreteChildClass extends ConcreteParentClass {
  override readonly $type = "ConcreteChildClass";
  readonly concreteChildClassProperty: string;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly $identifierPrefix?: string;
      readonly concreteChildClassProperty: string;
    } & ConstructorParameters<typeof ConcreteParentClass>[0],
  ) {
    super(parameters);
    this.concreteChildClassProperty = parameters.concreteChildClassProperty;
  }

  override get $identifier(): ConcreteChildClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }
    return this._$identifier;
  }

  protected override get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  override $equals(other: ConcreteChildClass): $EqualsResult {
    return super.$equals(other).chain(() =>
      $strictEquals(
        this.concreteChildClassProperty,
        other.concreteChildClassProperty,
      ).mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "concreteChildClassProperty",
        propertyValuesUnequal,
        type: "Property" as const,
      })),
    );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    _hasher.update(this.concreteChildClassProperty);
    return _hasher;
  }

  override $toJson(): ConcreteChildClass.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        concreteChildClassProperty: this.concreteChildClassProperty,
      } satisfies ConcreteChildClass.$Json),
    );
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode("http://example.com/ConcreteChildClass"),
      );
    }

    resource.add(
      ConcreteChildClass.$properties.concreteChildClassProperty["identifier"],
      ...[this.concreteChildClassProperty],
    );
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ConcreteChildClass {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ConcreteChildClass",
  );
  export type $Identifier = ConcreteParentClassStatic.$Identifier;
  export const $Identifier = ConcreteParentClassStatic.$Identifier;
  export type $Json = {
    readonly concreteChildClassProperty: string;
  } & ConcreteParentClassStatic.$Json;

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      concreteChildClassProperty: string;
    } & $UnwrapR<
      ReturnType<typeof ConcreteParentClassStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      ConcreteParentClassStatic.$propertiesFromJson($jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const concreteChildClassProperty =
      $jsonObject["concreteChildClassProperty"];
    return purify.Either.of({
      ...$super0,
      $identifier,
      concreteChildClassProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ConcreteChildClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ConcreteChildClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ConcreteParentClassStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/concreteChildClassProperty`,
          type: "Control",
        },
      ],
      label: "ConcreteChildClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ConcreteParentClassStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("ConcreteChildClass"),
        concreteChildClassProperty: zod.string(),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ConcreteChildClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ConcreteChildClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ConcreteChildClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      concreteChildClassProperty: string;
    } & $UnwrapR<
      ReturnType<typeof ConcreteParentClassStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = ConcreteParentClassStatic.$propertiesFromRdf({
      ...$context,
      ignoreRdfType: true,
      objectSet: $objectSet,
      preferredLanguages: $preferredLanguages,
      resource: $resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/ConcreteChildClass":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if ($resource.isInstanceOf(ConcreteChildClass.$fromRdfType)) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ConcreteChildClass)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: ConcreteChildClass.$Identifier = $resource.identifier;
    const _concreteChildClassPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.concreteChildClassProperty["identifier"], {
          unique: true,
        }),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    ConcreteChildClass.$properties.concreteChildClassProperty[
                      "identifier"
                    ],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_concreteChildClassPropertyEither.isLeft()) {
      return _concreteChildClassPropertyEither;
    }

    const concreteChildClassProperty =
      _concreteChildClassPropertyEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      concreteChildClassProperty,
    });
  }

  export const $properties = {
    ...ConcreteParentClassStatic.$properties,
    concreteChildClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/concreteChildClassProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConcreteChildClass.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ConcreteChildClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConcreteChildClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteChildClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "concreteChildClass");
    triples.push(
      ...ConcreteParentClassStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}ConcreteChildClassProperty`,
      ),
      predicate:
        ConcreteChildClass.$properties.concreteChildClassProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteChildClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "concreteChildClass");
    for (const pattern of ConcreteParentClassStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ConcreteChildClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}ConcreteChildClassProperty`,
            ),
            predicate:
              ConcreteChildClass.$properties.concreteChildClassProperty[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}ConcreteChildClassProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class ClassUnionMember2 {
  private _$identifier?: ClassUnionMember2.$Identifier;
  readonly $type = "ClassUnionMember2";
  readonly classUnionMember2Property: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly classUnionMember2Property: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.classUnionMember2Property = parameters.classUnionMember2Property;
  }

  get $identifier(): ClassUnionMember2.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: ClassUnionMember2): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.classUnionMember2Property,
          other.classUnionMember2Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "classUnionMember2Property",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.classUnionMember2Property);
    return _hasher;
  }

  $toJson(): ClassUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        classUnionMember2Property: this.classUnionMember2Property,
      } satisfies ClassUnionMember2.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode("http://example.com/ClassUnionMember2"),
      );
    }

    resource.add(
      ClassUnionMember2.$properties.classUnionMember2Property["identifier"],
      ...[this.classUnionMember2Property],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ClassUnionMember2 {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ClassUnionMember2",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ClassUnionMember2";
    readonly classUnionMember2Property: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      classUnionMember2Property: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const classUnionMember2Property = $jsonObject["classUnionMember2Property"];
    return purify.Either.of({ $identifier, classUnionMember2Property });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ClassUnionMember2> {
    return $propertiesFromJson(json).map(
      (properties) => new ClassUnionMember2(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ClassUnionMember2" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/classUnionMember2Property`,
          type: "Control",
        },
      ],
      label: "ClassUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("ClassUnionMember2"),
      classUnionMember2Property: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ClassUnionMember2> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ClassUnionMember2.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ClassUnionMember2(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      classUnionMember2Property: string;
    }
  > {
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/ClassUnionMember2":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if ($resource.isInstanceOf(ClassUnionMember2.$fromRdfType)) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ClassUnionMember2)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: ClassUnionMember2.$Identifier = $resource.identifier;
    const _classUnionMember2PropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.classUnionMember2Property["identifier"], {
          unique: true,
        }),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    ClassUnionMember2.$properties.classUnionMember2Property[
                      "identifier"
                    ],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_classUnionMember2PropertyEither.isLeft()) {
      return _classUnionMember2PropertyEither;
    }

    const classUnionMember2Property =
      _classUnionMember2PropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, classUnionMember2Property });
  }

  export const $properties = {
    classUnionMember2Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/classUnionMember2Property",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ClassUnionMember2.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ClassUnionMember2.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ClassUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("classUnionMember2");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "classUnionMember2");
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}ClassUnionMember2Property`,
      ),
      predicate:
        ClassUnionMember2.$properties.classUnionMember2Property["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("classUnionMember2");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "classUnionMember2");
    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ClassUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}ClassUnionMember2Property`,
            ),
            predicate:
              ClassUnionMember2.$properties.classUnionMember2Property[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}ClassUnionMember2Property`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class ClassUnionMember1 {
  private _$identifier?: ClassUnionMember1.$Identifier;
  readonly $type = "ClassUnionMember1";
  readonly classUnionMember1Property: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly classUnionMember1Property: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.classUnionMember1Property = parameters.classUnionMember1Property;
  }

  get $identifier(): ClassUnionMember1.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: ClassUnionMember1): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.classUnionMember1Property,
          other.classUnionMember1Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "classUnionMember1Property",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.classUnionMember1Property);
    return _hasher;
  }

  $toJson(): ClassUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        classUnionMember1Property: this.classUnionMember1Property,
      } satisfies ClassUnionMember1.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode("http://example.com/ClassUnionMember1"),
      );
    }

    resource.add(
      ClassUnionMember1.$properties.classUnionMember1Property["identifier"],
      ...[this.classUnionMember1Property],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ClassUnionMember1 {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ClassUnionMember1",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ClassUnionMember1";
    readonly classUnionMember1Property: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      classUnionMember1Property: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const classUnionMember1Property = $jsonObject["classUnionMember1Property"];
    return purify.Either.of({ $identifier, classUnionMember1Property });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ClassUnionMember1> {
    return $propertiesFromJson(json).map(
      (properties) => new ClassUnionMember1(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ClassUnionMember1" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/classUnionMember1Property`,
          type: "Control",
        },
      ],
      label: "ClassUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("ClassUnionMember1"),
      classUnionMember1Property: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ClassUnionMember1> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ClassUnionMember1.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ClassUnionMember1(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      classUnionMember1Property: string;
    }
  > {
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/ClassUnionMember1":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if ($resource.isInstanceOf(ClassUnionMember1.$fromRdfType)) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ClassUnionMember1)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: ClassUnionMember1.$Identifier = $resource.identifier;
    const _classUnionMember1PropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
      >(
        $resource.values($properties.classUnionMember1Property["identifier"], {
          unique: true,
        }),
      )
        .chain((values) => {
          if (!$preferredLanguages || $preferredLanguages.length === 0) {
            return purify.Either.of<
              Error,
              rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
            >(values);
          }

          const literalValuesEither = values.chainMap((value) =>
            value.toLiteral(),
          );
          if (literalValuesEither.isLeft()) {
            return literalValuesEither;
          }
          const literalValues = literalValuesEither.unsafeCoerce();

          // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
          // Within a preferredLanguage the literals may be in any order.
          let filteredLiteralValues:
            | rdfjsResource.Resource.Values<rdfjs.Literal>
            | undefined;
          for (const preferredLanguage of $preferredLanguages) {
            if (!filteredLiteralValues) {
              filteredLiteralValues = literalValues.filter(
                (value) => value.language === preferredLanguage,
              );
            } else {
              filteredLiteralValues = filteredLiteralValues.concat(
                ...literalValues
                  .filter((value) => value.language === preferredLanguage)
                  .toArray(),
              );
            }
          }

          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(
            filteredLiteralValues!.map(
              (literalValue) =>
                new rdfjsResource.Resource.Value({
                  object: literalValue,
                  predicate:
                    ClassUnionMember1.$properties.classUnionMember1Property[
                      "identifier"
                    ],
                  subject: $resource,
                }),
            ),
          );
        })
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_classUnionMember1PropertyEither.isLeft()) {
      return _classUnionMember1PropertyEither;
    }

    const classUnionMember1Property =
      _classUnionMember1PropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, classUnionMember1Property });
  }

  export const $properties = {
    classUnionMember1Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/classUnionMember1Property",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ClassUnionMember1.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ClassUnionMember1.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ClassUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("classUnionMember1");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "classUnionMember1");
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}ClassUnionMember1Property`,
      ),
      predicate:
        ClassUnionMember1.$properties.classUnionMember1Property["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("classUnionMember1");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "classUnionMember1");
    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ClassUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}ClassUnionMember1Property`,
            ),
            predicate:
              ClassUnionMember1.$properties.classUnionMember1Property[
                "identifier"
              ],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}ClassUnionMember1Property`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Node shape that can have a blank node or IRI as an identifier
 */
export interface BlankInterface {
  readonly $identifier: BlankInterface.$Identifier;
  readonly $type: "BlankInterface";
}

export namespace BlankInterface {
  export function $create(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
  }): BlankInterface {
    let $identifier: BlankInterface.$Identifier;
    if (typeof parameters?.$identifier === "object") {
      $identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters?.$identifier satisfies never;
    }

    const $type = "BlankInterface" as const;
    return { $identifier, $type };
  }

  export function $equals(
    left: BlankInterface,
    right: BlankInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "BlankInterface";
  };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode; $type: "BlankInterface" }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "BlankInterface" as const;
    return purify.Either.of({ $identifier, $type });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, BlankInterface> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "BlankInterface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "BlankInterface",
      type: "Group",
    };
  }

  export function $toJson(
    _blankInterface: BlankInterface,
  ): BlankInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _blankInterface.$identifier.termType === "BlankNode"
            ? `_:${_blankInterface.$identifier.value}`
            : _blankInterface.$identifier.value,
        $type: _blankInterface.$type,
      } satisfies BlankInterface.$Json),
    );
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("BlankInterface"),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_blankInterface: BlankInterface, _hasher: HasherT): HasherT {
    _hasher.update(_blankInterface.$identifier.value);
    _hasher.update(_blankInterface.$type);
    BlankInterface.$hashShaclProperties(_blankInterface, _hasher);
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_blankInterface: BlankInterface, _hasher: HasherT): HasherT {
    return _hasher;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, BlankInterface> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return BlankInterface.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode; $type: "BlankInterface" }
  > {
    const $identifier: BlankInterface.$Identifier = $resource.identifier;
    const $type = "BlankInterface" as const;
    return purify.Either.of({ $identifier, $type });
  }

  export function $toRdf(
    _blankInterface: BlankInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(_blankInterface.$identifier, {
      mutateGraph,
    });
    return resource;
  }

  export const $properties = {};

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BlankInterface.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        BlankInterface.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BlankInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(_parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [];
  }
}
/**
 * Node shape that can have a blank node or IRI as an identifier
 */
export class BlankClass {
  private _$identifier?: BlankClass.$Identifier;
  readonly $type = "BlankClass";

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }
  }

  get $identifier(): BlankClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: BlankClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    return _hasher;
  }

  $toJson(): BlankClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
      } satisfies BlankClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode("http://example.com/BlankClass"),
      );
    }

    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace BlankClass {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/BlankClass",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = { readonly "@id": string; readonly $type: "BlankClass" };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    return purify.Either.of({ $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, BlankClass> {
    return $propertiesFromJson(json).map(
      (properties) => new BlankClass(properties),
    );
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "BlankClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "BlankClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("BlankClass"),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, BlankClass> {
    let {
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
      ...context
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return BlankClass.$propertiesFromRdf({
      ...context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new BlankClass(properties));
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<Error, { $identifier: rdfjs.BlankNode | rdfjs.NamedNode }> {
    if (!$ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/BlankClass":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if ($resource.isInstanceOf(BlankClass.$fromRdfType)) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/BlankClass)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: BlankClass.$Identifier = $resource.identifier;
    return purify.Either.of({ $identifier });
  }

  export const $properties = {};

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BlankClass.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        BlankClass.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BlankClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("blankClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "blankClass");
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("blankClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "blankClass");
    const rdfTypeVariable = dataFactory.variable!(`${variablePrefix}RdfType`);
    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({
          rdfType: BlankClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
      );
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: rdfTypeVariable,
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * An abstract base class that will be inherited by the extern object type, showing how to mix generated and hand-written code.
 */
export abstract class AbstractBaseClassForExternClass {
  abstract readonly $identifier: AbstractBaseClassForExternClassStatic.$Identifier;
  abstract readonly $type: "ExternClass";
  readonly abstractBaseClassForExternClassProperty: string;

  constructor(parameters: {
    readonly abstractBaseClassForExternClassProperty: string;
  }) {
    this.abstractBaseClassForExternClassProperty =
      parameters.abstractBaseClassForExternClassProperty;
  }

  $equals(other: AbstractBaseClassForExternClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.abstractBaseClassForExternClassProperty,
          other.abstractBaseClassForExternClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "abstractBaseClassForExternClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.abstractBaseClassForExternClassProperty);
    return _hasher;
  }

  $toJson(): AbstractBaseClassForExternClassStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        abstractBaseClassForExternClassProperty:
          this.abstractBaseClassForExternClassProperty,
      } satisfies AbstractBaseClassForExternClassStatic.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      AbstractBaseClassForExternClassStatic.$properties
        .abstractBaseClassForExternClassProperty["identifier"],
      ...[this.abstractBaseClassForExternClassProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace AbstractBaseClassForExternClassStatic {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ExternClass";
    readonly abstractBaseClassForExternClassProperty: string;
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      abstractBaseClassForExternClassProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const abstractBaseClassForExternClassProperty =
      $jsonObject["abstractBaseClassForExternClassProperty"];
    return purify.Either.of({
      $identifier,
      abstractBaseClassForExternClassProperty,
    });
  }

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "AbstractBaseClassForExternClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/abstractBaseClassForExternClassProperty`,
          type: "Control",
        },
      ],
      label: "AbstractBaseClassForExternClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("ExternClass"),
      abstractBaseClassForExternClassProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export function $propertiesFromRdf({
    ignoreRdfType: $ignoreRdfType,
    objectSet: $objectSet,
    preferredLanguages: $preferredLanguages,
    resource: $resource,
    // @ts-ignore
    ...$context
  }: {
    [_index: string]: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      abstractBaseClassForExternClassProperty: string;
    }
  > {
    const $identifier: AbstractBaseClassForExternClassStatic.$Identifier =
      $resource.identifier;
    const _abstractBaseClassForExternClassPropertyEither: purify.Either<
      Error,
      string
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
    >(
      $resource.values(
        $properties.abstractBaseClassForExternClassProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) => {
        if (!$preferredLanguages || $preferredLanguages.length === 0) {
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
          >(values);
        }

        const literalValuesEither = values.chainMap((value) =>
          value.toLiteral(),
        );
        if (literalValuesEither.isLeft()) {
          return literalValuesEither;
        }
        const literalValues = literalValuesEither.unsafeCoerce();

        // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
        // Within a preferredLanguage the literals may be in any order.
        let filteredLiteralValues:
          | rdfjsResource.Resource.Values<rdfjs.Literal>
          | undefined;
        for (const preferredLanguage of $preferredLanguages) {
          if (!filteredLiteralValues) {
            filteredLiteralValues = literalValues.filter(
              (value) => value.language === preferredLanguage,
            );
          } else {
            filteredLiteralValues = filteredLiteralValues.concat(
              ...literalValues
                .filter((value) => value.language === preferredLanguage)
                .toArray(),
            );
          }
        }

        return purify.Either.of<
          Error,
          rdfjsResource.Resource.Values<rdfjsResource.Resource.Value>
        >(
          filteredLiteralValues!.map(
            (literalValue) =>
              new rdfjsResource.Resource.Value({
                object: literalValue,
                predicate:
                  AbstractBaseClassForExternClassStatic.$properties
                    .abstractBaseClassForExternClassProperty["identifier"],
                subject: $resource,
              }),
          ),
        );
      })
      .chain((values) => values.chainMap((value) => value.toString()))
      .chain((values) => values.head());
    if (_abstractBaseClassForExternClassPropertyEither.isLeft()) {
      return _abstractBaseClassForExternClassPropertyEither;
    }

    const abstractBaseClassForExternClassProperty =
      _abstractBaseClassForExternClassPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      abstractBaseClassForExternClassProperty,
    });
  }

  export const $properties = {
    abstractBaseClassForExternClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/abstractBaseClassForExternClassProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        AbstractBaseClassForExternClassStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        AbstractBaseClassForExternClassStatic.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      AbstractBaseClassForExternClassStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassForExternClass");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "abstractBaseClassForExternClass");
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}AbstractBaseClassForExternClassProperty`,
      ),
      predicate:
        AbstractBaseClassForExternClassStatic.$properties
          .abstractBaseClassForExternClassProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassForExternClass");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "abstractBaseClassForExternClass");
    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}AbstractBaseClassForExternClassProperty`,
            ),
            predicate:
              AbstractBaseClassForExternClassStatic.$properties
                .abstractBaseClassForExternClassProperty["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...[parameters?.preferredLanguages ?? []]
        .filter((languages) => languages.length > 0)
        .map((languages) =>
          languages.map((language) => ({
            type: "operation" as const,
            operator: "=",
            args: [
              {
                type: "operation" as const,
                operator: "lang",
                args: [
                  dataFactory.variable!(
                    `${variablePrefix}AbstractBaseClassForExternClassProperty`,
                  ),
                ],
              },
              dataFactory.literal(language),
            ],
          })),
        )
        .map((langEqualsExpressions) => ({
          type: "filter" as const,
          expression: langEqualsExpressions.reduce(
            (reducedExpression, langEqualsExpression) => {
              if (reducedExpression === null) {
                return langEqualsExpression;
              }
              return {
                type: "operation" as const,
                operator: "||",
                args: [reducedExpression, langEqualsExpression],
              };
            },
            null as sparqljs.Expression | null,
          ) as sparqljs.Expression,
        })),
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
/**
 * Node shape sh:xone's other node shapes. This will usually be generated as a discriminated union.
 */
export type ClassUnion = ClassUnionMember1 | ClassUnionMember2;

export namespace ClassUnion {
  export function $equals(left: ClassUnion, right: ClassUnion): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      switch (left.$type) {
        case "ClassUnionMember1":
          return left.$equals(right as unknown as ClassUnionMember1);
        case "ClassUnionMember2":
          return left.$equals(right as unknown as ClassUnionMember2);
        default:
          left satisfies never;
          throw new Error("unrecognized type");
      }
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ClassUnion> {
    return (
      ClassUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        ClassUnion
      >
    ).altLazy(
      () =>
        ClassUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          ClassUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ClassUnion> {
    return (
      ClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, ClassUnion>
    ).altLazy(
      () =>
        ClassUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, ClassUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_classUnion: ClassUnion, _hasher: HasherT): HasherT {
    switch (_classUnion.$type) {
      case "ClassUnionMember1":
        return _classUnion.$hash(_hasher);
      case "ClassUnionMember2":
        return _classUnion.$hash(_hasher);
      default:
        _classUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export type $Json = ClassUnionMember1.$Json | ClassUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      ClassUnionMember1.$jsonZodSchema(),
      ClassUnionMember2.$jsonZodSchema(),
    ]);
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ClassUnion.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ClassUnion.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...ClassUnionMember1.$sparqlConstructTemplateTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("classUnionClassUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ClassUnionMember1`
          : "classUnionClassUnionMember1",
      }).concat(),
      ...ClassUnionMember2.$sparqlConstructTemplateTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("classUnionClassUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ClassUnionMember2`
          : "classUnionClassUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: ClassUnionMember1.$sparqlWherePatterns({
              subject:
                parameters?.subject ??
                dataFactory.variable!("classUnionClassUnionMember1"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}ClassUnionMember1`
                : "classUnionClassUnionMember1",
            }).concat(),
            type: "group",
          },
          {
            patterns: ClassUnionMember2.$sparqlWherePatterns({
              subject:
                parameters?.subject ??
                dataFactory.variable!("classUnionClassUnionMember2"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}ClassUnionMember2`
                : "classUnionClassUnionMember2",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function $toJson(
    _classUnion: ClassUnion,
  ): ClassUnionMember1.$Json | ClassUnionMember2.$Json {
    switch (_classUnion.$type) {
      case "ClassUnionMember1":
        return _classUnion.$toJson();
      case "ClassUnionMember2":
        return _classUnion.$toJson();
      default:
        _classUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export function $toRdf(
    _classUnion: ClassUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    switch (_classUnion.$type) {
      case "ClassUnionMember1":
        return _classUnion.$toRdf(_parameters);
      case "ClassUnionMember2":
        return _classUnion.$toRdf(_parameters);
      default:
        _classUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }
}
/**
 * Node shape that sh:xone's other node shapes. This will usually be generated as a discriminated union.
 */
export type InterfaceUnion =
  | InterfaceUnionMember1
  | InterfaceUnionMember2a
  | InterfaceUnionMember2b;

export namespace InterfaceUnion {
  export function $equals(
    left: InterfaceUnion,
    right: InterfaceUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      switch (left.$type) {
        case "InterfaceUnionMember1":
          return InterfaceUnionMember1.$equals(
            left,
            right as unknown as InterfaceUnionMember1,
          );
        case "InterfaceUnionMember2a":
          return InterfaceUnionMember2a.$equals(
            left,
            right as unknown as InterfaceUnionMember2a,
          );
        case "InterfaceUnionMember2b":
          return InterfaceUnionMember2b.$equals(
            left,
            right as unknown as InterfaceUnionMember2b,
          );
        default:
          left satisfies never;
          throw new Error("unrecognized type");
      }
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, InterfaceUnion> {
    return (
      InterfaceUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        InterfaceUnion
      >
    )
      .altLazy(
        () =>
          InterfaceUnionMember2a.$fromJson(json) as purify.Either<
            zod.ZodError,
            InterfaceUnion
          >,
      )
      .altLazy(
        () =>
          InterfaceUnionMember2b.$fromJson(json) as purify.Either<
            zod.ZodError,
            InterfaceUnion
          >,
      );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, InterfaceUnion> {
    return (
      InterfaceUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, InterfaceUnion>
    )
      .altLazy(
        () =>
          InterfaceUnionMember2a.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, InterfaceUnion>,
      )
      .altLazy(
        () =>
          InterfaceUnionMember2b.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, InterfaceUnion>,
      );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_interfaceUnion: InterfaceUnion, _hasher: HasherT): HasherT {
    switch (_interfaceUnion.$type) {
      case "InterfaceUnionMember1":
        return InterfaceUnionMember1.$hash(_interfaceUnion, _hasher);
      case "InterfaceUnionMember2a":
        return InterfaceUnionMember2a.$hash(_interfaceUnion, _hasher);
      case "InterfaceUnionMember2b":
        return InterfaceUnionMember2b.$hash(_interfaceUnion, _hasher);
      default:
        _interfaceUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export type $Json =
    | InterfaceUnionMember1.$Json
    | InterfaceUnionMember2a.$Json
    | InterfaceUnionMember2b.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      InterfaceUnionMember1.$jsonZodSchema(),
      InterfaceUnionMember2a.$jsonZodSchema(),
      InterfaceUnionMember2b.$jsonZodSchema(),
    ]);
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InterfaceUnion.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        InterfaceUnion.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InterfaceUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...InterfaceUnionMember1.$sparqlConstructTemplateTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("interfaceUnionInterfaceUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}InterfaceUnionMember1`
          : "interfaceUnionInterfaceUnionMember1",
      }).concat(),
      ...InterfaceUnionMember2a.$sparqlConstructTemplateTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("interfaceUnionInterfaceUnionMember2a"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}InterfaceUnionMember2a`
          : "interfaceUnionInterfaceUnionMember2a",
      }).concat(),
      ...InterfaceUnionMember2b.$sparqlConstructTemplateTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("interfaceUnionInterfaceUnionMember2b"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}InterfaceUnionMember2b`
          : "interfaceUnionInterfaceUnionMember2b",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: InterfaceUnionMember1.$sparqlWherePatterns({
              subject:
                parameters?.subject ??
                dataFactory.variable!("interfaceUnionInterfaceUnionMember1"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}InterfaceUnionMember1`
                : "interfaceUnionInterfaceUnionMember1",
            }).concat(),
            type: "group",
          },
          {
            patterns: InterfaceUnionMember2a.$sparqlWherePatterns({
              subject:
                parameters?.subject ??
                dataFactory.variable!("interfaceUnionInterfaceUnionMember2a"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}InterfaceUnionMember2a`
                : "interfaceUnionInterfaceUnionMember2a",
            }).concat(),
            type: "group",
          },
          {
            patterns: InterfaceUnionMember2b.$sparqlWherePatterns({
              subject:
                parameters?.subject ??
                dataFactory.variable!("interfaceUnionInterfaceUnionMember2b"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}InterfaceUnionMember2b`
                : "interfaceUnionInterfaceUnionMember2b",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function $toJson(
    _interfaceUnion: InterfaceUnion,
  ):
    | InterfaceUnionMember1.$Json
    | InterfaceUnionMember2a.$Json
    | InterfaceUnionMember2b.$Json {
    switch (_interfaceUnion.$type) {
      case "InterfaceUnionMember1":
        return InterfaceUnionMember1.$toJson(_interfaceUnion);
      case "InterfaceUnionMember2a":
        return InterfaceUnionMember2a.$toJson(_interfaceUnion);
      case "InterfaceUnionMember2b":
        return InterfaceUnionMember2b.$toJson(_interfaceUnion);
      default:
        _interfaceUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export function $toRdf(
    _interfaceUnion: InterfaceUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    switch (_interfaceUnion.$type) {
      case "InterfaceUnionMember1":
        return InterfaceUnionMember1.$toRdf(_interfaceUnion, _parameters);
      case "InterfaceUnionMember2a":
        return InterfaceUnionMember2a.$toRdf(_interfaceUnion, _parameters);
      case "InterfaceUnionMember2b":
        return InterfaceUnionMember2b.$toRdf(_interfaceUnion, _parameters);
      default:
        _interfaceUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }
}
/**
 * A union node shape that is part of another union shape, to test composition of unions.
 */
export type InterfaceUnionMember2 =
  | InterfaceUnionMember2a
  | InterfaceUnionMember2b;

export namespace InterfaceUnionMember2 {
  export function $equals(
    left: InterfaceUnionMember2,
    right: InterfaceUnionMember2,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      switch (left.$type) {
        case "InterfaceUnionMember2a":
          return InterfaceUnionMember2a.$equals(
            left,
            right as unknown as InterfaceUnionMember2a,
          );
        case "InterfaceUnionMember2b":
          return InterfaceUnionMember2b.$equals(
            left,
            right as unknown as InterfaceUnionMember2b,
          );
        default:
          left satisfies never;
          throw new Error("unrecognized type");
      }
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, InterfaceUnionMember2> {
    return (
      InterfaceUnionMember2a.$fromJson(json) as purify.Either<
        zod.ZodError,
        InterfaceUnionMember2
      >
    ).altLazy(
      () =>
        InterfaceUnionMember2b.$fromJson(json) as purify.Either<
          zod.ZodError,
          InterfaceUnionMember2
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, InterfaceUnionMember2> {
    return (
      InterfaceUnionMember2a.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, InterfaceUnionMember2>
    ).altLazy(
      () =>
        InterfaceUnionMember2b.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, InterfaceUnionMember2>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_interfaceUnionMember2: InterfaceUnionMember2, _hasher: HasherT): HasherT {
    switch (_interfaceUnionMember2.$type) {
      case "InterfaceUnionMember2a":
        return InterfaceUnionMember2a.$hash(_interfaceUnionMember2, _hasher);
      case "InterfaceUnionMember2b":
        return InterfaceUnionMember2b.$hash(_interfaceUnionMember2, _hasher);
      default:
        _interfaceUnionMember2 satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export type $Json =
    | InterfaceUnionMember2a.$Json
    | InterfaceUnionMember2b.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      InterfaceUnionMember2a.$jsonZodSchema(),
      InterfaceUnionMember2b.$jsonZodSchema(),
    ]);
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InterfaceUnionMember2.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        InterfaceUnionMember2.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InterfaceUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...InterfaceUnionMember2a.$sparqlConstructTemplateTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("interfaceUnionMember2InterfaceUnionMember2a"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}InterfaceUnionMember2a`
          : "interfaceUnionMember2InterfaceUnionMember2a",
      }).concat(),
      ...InterfaceUnionMember2b.$sparqlConstructTemplateTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("interfaceUnionMember2InterfaceUnionMember2b"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}InterfaceUnionMember2b`
          : "interfaceUnionMember2InterfaceUnionMember2b",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: InterfaceUnionMember2a.$sparqlWherePatterns({
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "interfaceUnionMember2InterfaceUnionMember2a",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}InterfaceUnionMember2a`
                : "interfaceUnionMember2InterfaceUnionMember2a",
            }).concat(),
            type: "group",
          },
          {
            patterns: InterfaceUnionMember2b.$sparqlWherePatterns({
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "interfaceUnionMember2InterfaceUnionMember2b",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}InterfaceUnionMember2b`
                : "interfaceUnionMember2InterfaceUnionMember2b",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function $toJson(
    _interfaceUnionMember2: InterfaceUnionMember2,
  ): InterfaceUnionMember2a.$Json | InterfaceUnionMember2b.$Json {
    switch (_interfaceUnionMember2.$type) {
      case "InterfaceUnionMember2a":
        return InterfaceUnionMember2a.$toJson(_interfaceUnionMember2);
      case "InterfaceUnionMember2b":
        return InterfaceUnionMember2b.$toJson(_interfaceUnionMember2);
      default:
        _interfaceUnionMember2 satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export function $toRdf(
    _interfaceUnionMember2: InterfaceUnionMember2,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    switch (_interfaceUnionMember2.$type) {
      case "InterfaceUnionMember2a":
        return InterfaceUnionMember2a.$toRdf(
          _interfaceUnionMember2,
          _parameters,
        );
      case "InterfaceUnionMember2b":
        return InterfaceUnionMember2b.$toRdf(
          _interfaceUnionMember2,
          _parameters,
        );
      default:
        _interfaceUnionMember2 satisfies never;
        throw new Error("unrecognized type");
    }
  }
}
/**
 * Node shape sh:xone's other node shapes. This will usually be generated as a discriminated union.
 */
export type LazilyResolvedClassUnion =
  | LazilyResolvedClassUnionMember1
  | LazilyResolvedClassUnionMember2;

export namespace LazilyResolvedClassUnion {
  export function $equals(
    left: LazilyResolvedClassUnion,
    right: LazilyResolvedClassUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      switch (left.$type) {
        case "LazilyResolvedClassUnionMember1":
          return left.$equals(
            right as unknown as LazilyResolvedClassUnionMember1,
          );
        case "LazilyResolvedClassUnionMember2":
          return left.$equals(
            right as unknown as LazilyResolvedClassUnionMember2,
          );
        default:
          left satisfies never;
          throw new Error("unrecognized type");
      }
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedClassUnion> {
    return (
      LazilyResolvedClassUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        LazilyResolvedClassUnion
      >
    ).altLazy(
      () =>
        LazilyResolvedClassUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          LazilyResolvedClassUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedClassUnion> {
    return (
      LazilyResolvedClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, LazilyResolvedClassUnion>
    ).altLazy(
      () =>
        LazilyResolvedClassUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, LazilyResolvedClassUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedClassUnion: LazilyResolvedClassUnion,
    _hasher: HasherT,
  ): HasherT {
    switch (_lazilyResolvedClassUnion.$type) {
      case "LazilyResolvedClassUnionMember1":
        return _lazilyResolvedClassUnion.$hash(_hasher);
      case "LazilyResolvedClassUnionMember2":
        return _lazilyResolvedClassUnion.$hash(_hasher);
      default:
        _lazilyResolvedClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export type $Json =
    | LazilyResolvedClassUnionMember1.$Json
    | LazilyResolvedClassUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      LazilyResolvedClassUnionMember1.$jsonZodSchema(),
      LazilyResolvedClassUnionMember2.$jsonZodSchema(),
    ]);
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedClassUnion.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        LazilyResolvedClassUnion.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...LazilyResolvedClassUnionMember1.$sparqlConstructTemplateTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "lazilyResolvedClassUnionLazilyResolvedClassUnionMember1",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember1`
          : "lazilyResolvedClassUnionLazilyResolvedClassUnionMember1",
      }).concat(),
      ...LazilyResolvedClassUnionMember2.$sparqlConstructTemplateTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "lazilyResolvedClassUnionLazilyResolvedClassUnionMember2",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember2`
          : "lazilyResolvedClassUnionLazilyResolvedClassUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: LazilyResolvedClassUnionMember1.$sparqlWherePatterns({
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "lazilyResolvedClassUnionLazilyResolvedClassUnionMember1",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember1`
                : "lazilyResolvedClassUnionLazilyResolvedClassUnionMember1",
            }).concat(),
            type: "group",
          },
          {
            patterns: LazilyResolvedClassUnionMember2.$sparqlWherePatterns({
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "lazilyResolvedClassUnionLazilyResolvedClassUnionMember2",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember2`
                : "lazilyResolvedClassUnionLazilyResolvedClassUnionMember2",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function $toJson(
    _lazilyResolvedClassUnion: LazilyResolvedClassUnion,
  ):
    | LazilyResolvedClassUnionMember1.$Json
    | LazilyResolvedClassUnionMember2.$Json {
    switch (_lazilyResolvedClassUnion.$type) {
      case "LazilyResolvedClassUnionMember1":
        return _lazilyResolvedClassUnion.$toJson();
      case "LazilyResolvedClassUnionMember2":
        return _lazilyResolvedClassUnion.$toJson();
      default:
        _lazilyResolvedClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export function $toRdf(
    _lazilyResolvedClassUnion: LazilyResolvedClassUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    switch (_lazilyResolvedClassUnion.$type) {
      case "LazilyResolvedClassUnionMember1":
        return _lazilyResolvedClassUnion.$toRdf(_parameters);
      case "LazilyResolvedClassUnionMember2":
        return _lazilyResolvedClassUnion.$toRdf(_parameters);
      default:
        _lazilyResolvedClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }
}
/**
 * Node shape sh:xone's other node shapes. This will usually be generated as a discriminated union.
 */
export type LazilyResolvedInterfaceUnion =
  | LazilyResolvedInterfaceUnionMember1
  | LazilyResolvedInterfaceUnionMember2;

export namespace LazilyResolvedInterfaceUnion {
  export function $equals(
    left: LazilyResolvedInterfaceUnion,
    right: LazilyResolvedInterfaceUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      switch (left.$type) {
        case "LazilyResolvedInterfaceUnionMember1":
          return LazilyResolvedInterfaceUnionMember1.$equals(
            left,
            right as unknown as LazilyResolvedInterfaceUnionMember1,
          );
        case "LazilyResolvedInterfaceUnionMember2":
          return LazilyResolvedInterfaceUnionMember2.$equals(
            left,
            right as unknown as LazilyResolvedInterfaceUnionMember2,
          );
        default:
          left satisfies never;
          throw new Error("unrecognized type");
      }
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedInterfaceUnion> {
    return (
      LazilyResolvedInterfaceUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        LazilyResolvedInterfaceUnion
      >
    ).altLazy(
      () =>
        LazilyResolvedInterfaceUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          LazilyResolvedInterfaceUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedInterfaceUnion> {
    return (
      LazilyResolvedInterfaceUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, LazilyResolvedInterfaceUnion>
    ).altLazy(
      () =>
        LazilyResolvedInterfaceUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, LazilyResolvedInterfaceUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedInterfaceUnion: LazilyResolvedInterfaceUnion,
    _hasher: HasherT,
  ): HasherT {
    switch (_lazilyResolvedInterfaceUnion.$type) {
      case "LazilyResolvedInterfaceUnionMember1":
        return LazilyResolvedInterfaceUnionMember1.$hash(
          _lazilyResolvedInterfaceUnion,
          _hasher,
        );
      case "LazilyResolvedInterfaceUnionMember2":
        return LazilyResolvedInterfaceUnionMember2.$hash(
          _lazilyResolvedInterfaceUnion,
          _hasher,
        );
      default:
        _lazilyResolvedInterfaceUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export type $Json =
    | LazilyResolvedInterfaceUnionMember1.$Json
    | LazilyResolvedInterfaceUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      LazilyResolvedInterfaceUnionMember1.$jsonZodSchema(),
      LazilyResolvedInterfaceUnionMember2.$jsonZodSchema(),
    ]);
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedInterfaceUnion.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        LazilyResolvedInterfaceUnion.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedInterfaceUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...LazilyResolvedInterfaceUnionMember1.$sparqlConstructTemplateTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember1",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember1`
          : "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember1",
      }).concat(),
      ...LazilyResolvedInterfaceUnionMember2.$sparqlConstructTemplateTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember2",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember2`
          : "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: LazilyResolvedInterfaceUnionMember1.$sparqlWherePatterns({
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember1",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember1`
                : "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember1",
            }).concat(),
            type: "group",
          },
          {
            patterns: LazilyResolvedInterfaceUnionMember2.$sparqlWherePatterns({
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember2",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember2`
                : "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember2",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function $toJson(
    _lazilyResolvedInterfaceUnion: LazilyResolvedInterfaceUnion,
  ):
    | LazilyResolvedInterfaceUnionMember1.$Json
    | LazilyResolvedInterfaceUnionMember2.$Json {
    switch (_lazilyResolvedInterfaceUnion.$type) {
      case "LazilyResolvedInterfaceUnionMember1":
        return LazilyResolvedInterfaceUnionMember1.$toJson(
          _lazilyResolvedInterfaceUnion,
        );
      case "LazilyResolvedInterfaceUnionMember2":
        return LazilyResolvedInterfaceUnionMember2.$toJson(
          _lazilyResolvedInterfaceUnion,
        );
      default:
        _lazilyResolvedInterfaceUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export function $toRdf(
    _lazilyResolvedInterfaceUnion: LazilyResolvedInterfaceUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    switch (_lazilyResolvedInterfaceUnion.$type) {
      case "LazilyResolvedInterfaceUnionMember1":
        return LazilyResolvedInterfaceUnionMember1.$toRdf(
          _lazilyResolvedInterfaceUnion,
          _parameters,
        );
      case "LazilyResolvedInterfaceUnionMember2":
        return LazilyResolvedInterfaceUnionMember2.$toRdf(
          _lazilyResolvedInterfaceUnion,
          _parameters,
        );
      default:
        _lazilyResolvedInterfaceUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }
}
/**
 * Node shape sh:xone's other node shapes. This will usually be generated as a discriminated union.
 */
export type PartialClassUnion =
  | PartialClassUnionMember1
  | PartialClassUnionMember2;

export namespace PartialClassUnion {
  export function $equals(
    left: PartialClassUnion,
    right: PartialClassUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      switch (left.$type) {
        case "PartialClassUnionMember1":
          return left.$equals(right as unknown as PartialClassUnionMember1);
        case "PartialClassUnionMember2":
          return left.$equals(right as unknown as PartialClassUnionMember2);
        default:
          left satisfies never;
          throw new Error("unrecognized type");
      }
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialClassUnion> {
    return (
      PartialClassUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        PartialClassUnion
      >
    ).altLazy(
      () =>
        PartialClassUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          PartialClassUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialClassUnion> {
    return (
      PartialClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, PartialClassUnion>
    ).altLazy(
      () =>
        PartialClassUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, PartialClassUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_partialClassUnion: PartialClassUnion, _hasher: HasherT): HasherT {
    switch (_partialClassUnion.$type) {
      case "PartialClassUnionMember1":
        return _partialClassUnion.$hash(_hasher);
      case "PartialClassUnionMember2":
        return _partialClassUnion.$hash(_hasher);
      default:
        _partialClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export type $Json =
    | PartialClassUnionMember1.$Json
    | PartialClassUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      PartialClassUnionMember1.$jsonZodSchema(),
      PartialClassUnionMember2.$jsonZodSchema(),
    ]);
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialClassUnion.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PartialClassUnion.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...PartialClassUnionMember1.$sparqlConstructTemplateTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("partialClassUnionPartialClassUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialClassUnionMember1`
          : "partialClassUnionPartialClassUnionMember1",
      }).concat(),
      ...PartialClassUnionMember2.$sparqlConstructTemplateTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("partialClassUnionPartialClassUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialClassUnionMember2`
          : "partialClassUnionPartialClassUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: PartialClassUnionMember1.$sparqlWherePatterns({
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "partialClassUnionPartialClassUnionMember1",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}PartialClassUnionMember1`
                : "partialClassUnionPartialClassUnionMember1",
            }).concat(),
            type: "group",
          },
          {
            patterns: PartialClassUnionMember2.$sparqlWherePatterns({
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "partialClassUnionPartialClassUnionMember2",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}PartialClassUnionMember2`
                : "partialClassUnionPartialClassUnionMember2",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function $toJson(
    _partialClassUnion: PartialClassUnion,
  ): PartialClassUnionMember1.$Json | PartialClassUnionMember2.$Json {
    switch (_partialClassUnion.$type) {
      case "PartialClassUnionMember1":
        return _partialClassUnion.$toJson();
      case "PartialClassUnionMember2":
        return _partialClassUnion.$toJson();
      default:
        _partialClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export function $toRdf(
    _partialClassUnion: PartialClassUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    switch (_partialClassUnion.$type) {
      case "PartialClassUnionMember1":
        return _partialClassUnion.$toRdf(_parameters);
      case "PartialClassUnionMember2":
        return _partialClassUnion.$toRdf(_parameters);
      default:
        _partialClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }
}
/**
 * Node shape sh:xone's other node shapes. This will usually be generated as a discriminated union.
 */
export type PartialInterfaceUnion =
  | PartialInterfaceUnionMember1
  | PartialInterfaceUnionMember2;

export namespace PartialInterfaceUnion {
  export function $equals(
    left: PartialInterfaceUnion,
    right: PartialInterfaceUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      switch (left.$type) {
        case "PartialInterfaceUnionMember1":
          return PartialInterfaceUnionMember1.$equals(
            left,
            right as unknown as PartialInterfaceUnionMember1,
          );
        case "PartialInterfaceUnionMember2":
          return PartialInterfaceUnionMember2.$equals(
            left,
            right as unknown as PartialInterfaceUnionMember2,
          );
        default:
          left satisfies never;
          throw new Error("unrecognized type");
      }
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialInterfaceUnion> {
    return (
      PartialInterfaceUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        PartialInterfaceUnion
      >
    ).altLazy(
      () =>
        PartialInterfaceUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          PartialInterfaceUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialInterfaceUnion> {
    return (
      PartialInterfaceUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, PartialInterfaceUnion>
    ).altLazy(
      () =>
        PartialInterfaceUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, PartialInterfaceUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_partialInterfaceUnion: PartialInterfaceUnion, _hasher: HasherT): HasherT {
    switch (_partialInterfaceUnion.$type) {
      case "PartialInterfaceUnionMember1":
        return PartialInterfaceUnionMember1.$hash(
          _partialInterfaceUnion,
          _hasher,
        );
      case "PartialInterfaceUnionMember2":
        return PartialInterfaceUnionMember2.$hash(
          _partialInterfaceUnion,
          _hasher,
        );
      default:
        _partialInterfaceUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export type $Json =
    | PartialInterfaceUnionMember1.$Json
    | PartialInterfaceUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      PartialInterfaceUnionMember1.$jsonZodSchema(),
      PartialInterfaceUnionMember2.$jsonZodSchema(),
    ]);
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialInterfaceUnion.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PartialInterfaceUnion.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialInterfaceUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...PartialInterfaceUnionMember1.$sparqlConstructTemplateTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "partialInterfaceUnionPartialInterfaceUnionMember1",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialInterfaceUnionMember1`
          : "partialInterfaceUnionPartialInterfaceUnionMember1",
      }).concat(),
      ...PartialInterfaceUnionMember2.$sparqlConstructTemplateTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "partialInterfaceUnionPartialInterfaceUnionMember2",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialInterfaceUnionMember2`
          : "partialInterfaceUnionPartialInterfaceUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: PartialInterfaceUnionMember1.$sparqlWherePatterns({
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "partialInterfaceUnionPartialInterfaceUnionMember1",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}PartialInterfaceUnionMember1`
                : "partialInterfaceUnionPartialInterfaceUnionMember1",
            }).concat(),
            type: "group",
          },
          {
            patterns: PartialInterfaceUnionMember2.$sparqlWherePatterns({
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "partialInterfaceUnionPartialInterfaceUnionMember2",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}PartialInterfaceUnionMember2`
                : "partialInterfaceUnionPartialInterfaceUnionMember2",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function $toJson(
    _partialInterfaceUnion: PartialInterfaceUnion,
  ): PartialInterfaceUnionMember1.$Json | PartialInterfaceUnionMember2.$Json {
    switch (_partialInterfaceUnion.$type) {
      case "PartialInterfaceUnionMember1":
        return PartialInterfaceUnionMember1.$toJson(_partialInterfaceUnion);
      case "PartialInterfaceUnionMember2":
        return PartialInterfaceUnionMember2.$toJson(_partialInterfaceUnion);
      default:
        _partialInterfaceUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export function $toRdf(
    _partialInterfaceUnion: PartialInterfaceUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    switch (_partialInterfaceUnion.$type) {
      case "PartialInterfaceUnionMember1":
        return PartialInterfaceUnionMember1.$toRdf(
          _partialInterfaceUnion,
          _parameters,
        );
      case "PartialInterfaceUnionMember2":
        return PartialInterfaceUnionMember2.$toRdf(
          _partialInterfaceUnion,
          _parameters,
        );
      default:
        _partialInterfaceUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }
}
/**
 * Node shape sh:xone's node shapes that have properties with the union's type
 */
export type RecursiveClassUnion =
  | RecursiveClassUnionMember1
  | RecursiveClassUnionMember2;

export namespace RecursiveClassUnion {
  export function $equals(
    left: RecursiveClassUnion,
    right: RecursiveClassUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      switch (left.$type) {
        case "RecursiveClassUnionMember1":
          return left.$equals(right as unknown as RecursiveClassUnionMember1);
        case "RecursiveClassUnionMember2":
          return left.$equals(right as unknown as RecursiveClassUnionMember2);
        default:
          left satisfies never;
          throw new Error("unrecognized type");
      }
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, RecursiveClassUnion> {
    return (
      RecursiveClassUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        RecursiveClassUnion
      >
    ).altLazy(
      () =>
        RecursiveClassUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          RecursiveClassUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, RecursiveClassUnion> {
    return (
      RecursiveClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, RecursiveClassUnion>
    ).altLazy(
      () =>
        RecursiveClassUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, RecursiveClassUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_recursiveClassUnion: RecursiveClassUnion, _hasher: HasherT): HasherT {
    switch (_recursiveClassUnion.$type) {
      case "RecursiveClassUnionMember1":
        return _recursiveClassUnion.$hash(_hasher);
      case "RecursiveClassUnionMember2":
        return _recursiveClassUnion.$hash(_hasher);
      default:
        _recursiveClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export type $Json =
    | RecursiveClassUnionMember1.$Json
    | RecursiveClassUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      RecursiveClassUnionMember1.$jsonZodSchema(),
      RecursiveClassUnionMember2.$jsonZodSchema(),
    ]);
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, preferredLanguages, subject, ...queryParameters } =
      parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        RecursiveClassUnion.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        RecursiveClassUnion.$sparqlWherePatterns({
          ignoreRdfType,
          preferredLanguages,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      RecursiveClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...RecursiveClassUnionMember1.$sparqlConstructTemplateTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "recursiveClassUnionRecursiveClassUnionMember1",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}RecursiveClassUnionMember1`
          : "recursiveClassUnionRecursiveClassUnionMember1",
      }).concat(),
      ...RecursiveClassUnionMember2.$sparqlConstructTemplateTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "recursiveClassUnionRecursiveClassUnionMember2",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}RecursiveClassUnionMember2`
          : "recursiveClassUnionRecursiveClassUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: RecursiveClassUnionMember1.$sparqlWherePatterns({
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "recursiveClassUnionRecursiveClassUnionMember1",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}RecursiveClassUnionMember1`
                : "recursiveClassUnionRecursiveClassUnionMember1",
            }).concat(),
            type: "group",
          },
          {
            patterns: RecursiveClassUnionMember2.$sparqlWherePatterns({
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "recursiveClassUnionRecursiveClassUnionMember2",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}RecursiveClassUnionMember2`
                : "recursiveClassUnionRecursiveClassUnionMember2",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function $toJson(
    _recursiveClassUnion: RecursiveClassUnion,
  ): RecursiveClassUnionMember1.$Json | RecursiveClassUnionMember2.$Json {
    switch (_recursiveClassUnion.$type) {
      case "RecursiveClassUnionMember1":
        return _recursiveClassUnion.$toJson();
      case "RecursiveClassUnionMember2":
        return _recursiveClassUnion.$toJson();
      default:
        _recursiveClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export function $toRdf(
    _recursiveClassUnion: RecursiveClassUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    switch (_recursiveClassUnion.$type) {
      case "RecursiveClassUnionMember1":
        return _recursiveClassUnion.$toRdf(_parameters);
      case "RecursiveClassUnionMember2":
        return _recursiveClassUnion.$toRdf(_parameters);
      default:
        _recursiveClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }
}
export interface $ObjectSet {
  baseInterfaceWithoutProperties(
    identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithoutProperties>>;
  baseInterfaceWithoutPropertiesIdentifiers(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithoutPropertiesStatic.$Identifier[]
    >
  >;
  baseInterfaceWithoutPropertieses(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithoutProperties[]>>;
  baseInterfaceWithoutPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  baseInterfaceWithProperties(
    identifier: BaseInterfaceWithPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithProperties>>;
  baseInterfaceWithPropertiesIdentifiers(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithPropertiesStatic.$Identifier[]
    >
  >;
  baseInterfaceWithPropertieses(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithProperties[]>>;
  baseInterfaceWithPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  blankClass(
    identifier: BlankClass.$Identifier,
  ): Promise<purify.Either<Error, BlankClass>>;
  blankClassIdentifiers(
    query?: $ObjectSet.Query<BlankClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankClass.$Identifier[]>>;
  blankClasses(
    query?: $ObjectSet.Query<BlankClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankClass[]>>;
  blankClassesCount(
    query?: Pick<$ObjectSet.Query<BlankClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  blankInterface(
    identifier: BlankInterface.$Identifier,
  ): Promise<purify.Either<Error, BlankInterface>>;
  blankInterfaceIdentifiers(
    query?: $ObjectSet.Query<BlankInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankInterface.$Identifier[]>>;
  blankInterfaces(
    query?: $ObjectSet.Query<BlankInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankInterface[]>>;
  blankInterfacesCount(
    query?: Pick<$ObjectSet.Query<BlankInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  classUnionMember1(
    identifier: ClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember1>>;
  classUnionMember1Identifiers(
    query?: $ObjectSet.Query<ClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1.$Identifier[]>>;
  classUnionMember1s(
    query?: $ObjectSet.Query<ClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1[]>>;
  classUnionMember1sCount(
    query?: Pick<$ObjectSet.Query<ClassUnionMember1.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  classUnionMember2(
    identifier: ClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember2>>;
  classUnionMember2Identifiers(
    query?: $ObjectSet.Query<ClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2.$Identifier[]>>;
  classUnionMember2s(
    query?: $ObjectSet.Query<ClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2[]>>;
  classUnionMember2sCount(
    query?: Pick<$ObjectSet.Query<ClassUnionMember2.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  concreteChildClass(
    identifier: ConcreteChildClass.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildClass>>;
  concreteChildClassIdentifiers(
    query?: $ObjectSet.Query<ConcreteChildClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass.$Identifier[]>>;
  concreteChildClasses(
    query?: $ObjectSet.Query<ConcreteChildClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass[]>>;
  concreteChildClassesCount(
    query?: Pick<$ObjectSet.Query<ConcreteChildClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  concreteChildInterface(
    identifier: ConcreteChildInterface.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildInterface>>;
  concreteChildInterfaceIdentifiers(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteChildInterface.$Identifier[]>
  >;
  concreteChildInterfaces(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildInterface[]>>;
  concreteChildInterfacesCount(
    query?: Pick<$ObjectSet.Query<ConcreteChildInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  concreteParentClass(
    identifier: ConcreteParentClassStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentClass>>;
  concreteParentClassIdentifiers(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentClassStatic.$Identifier[]>
  >;
  concreteParentClasses(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteParentClass[]>>;
  concreteParentClassesCount(
    query?: Pick<
      $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  concreteParentInterface(
    identifier: ConcreteParentInterfaceStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentInterface>>;
  concreteParentInterfaceIdentifiers(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentInterfaceStatic.$Identifier[]>
  >;
  concreteParentInterfaces(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteParentInterface[]>>;
  concreteParentInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  convertibleTypePropertiesClass(
    identifier: ConvertibleTypePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ConvertibleTypePropertiesClass>>;
  convertibleTypePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConvertibleTypePropertiesClass.$Identifier[]>
  >;
  convertibleTypePropertiesClasses(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConvertibleTypePropertiesClass[]>>;
  convertibleTypePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  defaultValuePropertiesClass(
    identifier: DefaultValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, DefaultValuePropertiesClass>>;
  defaultValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly DefaultValuePropertiesClass.$Identifier[]>
  >;
  defaultValuePropertiesClasses(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DefaultValuePropertiesClass[]>>;
  defaultValuePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  directRecursiveClass(
    identifier: DirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, DirectRecursiveClass>>;
  directRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DirectRecursiveClass.$Identifier[]>>;
  directRecursiveClasses(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DirectRecursiveClass[]>>;
  directRecursiveClassesCount(
    query?: Pick<$ObjectSet.Query<DirectRecursiveClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  explicitFromToRdfTypesClass(
    identifier: ExplicitFromToRdfTypesClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitFromToRdfTypesClass>>;
  explicitFromToRdfTypesClassIdentifiers(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExplicitFromToRdfTypesClass.$Identifier[]>
  >;
  explicitFromToRdfTypesClasses(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExplicitFromToRdfTypesClass[]>>;
  explicitFromToRdfTypesClassesCount(
    query?: Pick<
      $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  explicitRdfTypeClass(
    identifier: ExplicitRdfTypeClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitRdfTypeClass>>;
  explicitRdfTypeClassIdentifiers(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExplicitRdfTypeClass.$Identifier[]>>;
  explicitRdfTypeClasses(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExplicitRdfTypeClass[]>>;
  explicitRdfTypeClassesCount(
    query?: Pick<$ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  externClassPropertyClass(
    identifier: ExternClassPropertyClass.$Identifier,
  ): Promise<purify.Either<Error, ExternClassPropertyClass>>;
  externClassPropertyClassIdentifiers(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExternClassPropertyClass.$Identifier[]>
  >;
  externClassPropertyClasses(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExternClassPropertyClass[]>>;
  externClassPropertyClassesCount(
    query?: Pick<
      $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  hasValuePropertiesClass(
    identifier: HasValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, HasValuePropertiesClass>>;
  hasValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly HasValuePropertiesClass.$Identifier[]>
  >;
  hasValuePropertiesClasses(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly HasValuePropertiesClass[]>>;
  hasValuePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  indirectRecursiveClass(
    identifier: IndirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveClass>>;
  indirectRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveClass.$Identifier[]>
  >;
  indirectRecursiveClasses(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveClass[]>>;
  indirectRecursiveClassesCount(
    query?: Pick<$ObjectSet.Query<IndirectRecursiveClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  indirectRecursiveHelperClass(
    identifier: IndirectRecursiveHelperClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveHelperClass>>;
  indirectRecursiveHelperClassIdentifiers(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveHelperClass.$Identifier[]>
  >;
  indirectRecursiveHelperClasses(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveHelperClass[]>>;
  indirectRecursiveHelperClassesCount(
    query?: Pick<
      $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  inIdentifierClass(
    identifier: InIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, InIdentifierClass>>;
  inIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<InIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass.$Identifier[]>>;
  inIdentifierClasses(
    query?: $ObjectSet.Query<InIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass[]>>;
  inIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<InIdentifierClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  inPropertiesClass(
    identifier: InPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, InPropertiesClass>>;
  inPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<InPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass.$Identifier[]>>;
  inPropertiesClasses(
    query?: $ObjectSet.Query<InPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass[]>>;
  inPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<InPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  interface(
    identifier: Interface.$Identifier,
  ): Promise<purify.Either<Error, Interface>>;
  interfaceIdentifiers(
    query?: $ObjectSet.Query<Interface.$Identifier>,
  ): Promise<purify.Either<Error, readonly Interface.$Identifier[]>>;
  interfaces(
    query?: $ObjectSet.Query<Interface.$Identifier>,
  ): Promise<purify.Either<Error, readonly Interface[]>>;
  interfacesCount(
    query?: Pick<$ObjectSet.Query<Interface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  interfaceUnionMember1(
    identifier: InterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember1>>;
  interfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember1.$Identifier[]>
  >;
  interfaceUnionMember1s(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember1[]>>;
  interfaceUnionMember1sCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember1.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  interfaceUnionMember2a(
    identifier: InterfaceUnionMember2a.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember2a>>;
  interfaceUnionMember2aIdentifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember2a.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember2a.$Identifier[]>
  >;
  interfaceUnionMember2as(
    query?: $ObjectSet.Query<InterfaceUnionMember2a.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember2a[]>>;
  interfaceUnionMember2asCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember2a.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  interfaceUnionMember2b(
    identifier: InterfaceUnionMember2b.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember2b>>;
  interfaceUnionMember2bIdentifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember2b.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember2b.$Identifier[]>
  >;
  interfaceUnionMember2bs(
    query?: $ObjectSet.Query<InterfaceUnionMember2b.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember2b[]>>;
  interfaceUnionMember2bsCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember2b.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  iriClass(
    identifier: IriClass.$Identifier,
  ): Promise<purify.Either<Error, IriClass>>;
  iriClassIdentifiers(
    query?: $ObjectSet.Query<IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IriClass.$Identifier[]>>;
  iriClasses(
    query?: $ObjectSet.Query<IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IriClass[]>>;
  iriClassesCount(
    query?: Pick<$ObjectSet.Query<IriClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  languageInPropertiesClass(
    identifier: LanguageInPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LanguageInPropertiesClass>>;
  languageInPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LanguageInPropertiesClass.$Identifier[]>
  >;
  languageInPropertiesClasses(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LanguageInPropertiesClass[]>>;
  languageInPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedBlankNodeOrIriClass(
    identifier: LazilyResolvedBlankNodeOrIriClass.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedBlankNodeOrIriClass>>;
  lazilyResolvedBlankNodeOrIriClassIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriClass.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriClass.$Identifier[]
    >
  >;
  lazilyResolvedBlankNodeOrIriClasses(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedBlankNodeOrIriClass[]>
  >;
  lazilyResolvedBlankNodeOrIriClassesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedBlankNodeOrIriInterface(
    identifier: LazilyResolvedBlankNodeOrIriInterface.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedBlankNodeOrIriInterface>>;
  lazilyResolvedBlankNodeOrIriInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriInterface.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriInterface.$Identifier[]
    >
  >;
  lazilyResolvedBlankNodeOrIriInterfaces(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedBlankNodeOrIriInterface[]>
  >;
  lazilyResolvedBlankNodeOrIriInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedClassUnionMember1(
    identifier: LazilyResolvedClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember1>>;
  lazilyResolvedClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember1.$Identifier[]>
  >;
  lazilyResolvedClassUnionMember1s(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember1[]>>;
  lazilyResolvedClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedClassUnionMember2(
    identifier: LazilyResolvedClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember2>>;
  lazilyResolvedClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember2.$Identifier[]>
  >;
  lazilyResolvedClassUnionMember2s(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember2[]>>;
  lazilyResolvedClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedInterfaceUnionMember1(
    identifier: LazilyResolvedInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember1>>;
  lazilyResolvedInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember1.$Identifier[]
    >
  >;
  lazilyResolvedInterfaceUnionMember1s(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember1[]>
  >;
  lazilyResolvedInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedInterfaceUnionMember2(
    identifier: LazilyResolvedInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember2>>;
  lazilyResolvedInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember2.$Identifier[]
    >
  >;
  lazilyResolvedInterfaceUnionMember2s(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember2[]>
  >;
  lazilyResolvedInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedIriClass(
    identifier: LazilyResolvedIriClass.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriClass>>;
  lazilyResolvedIriClassIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedIriClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriClass.$Identifier[]>
  >;
  lazilyResolvedIriClasses(
    query?: $ObjectSet.Query<LazilyResolvedIriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedIriClass[]>>;
  lazilyResolvedIriClassesCount(
    query?: Pick<$ObjectSet.Query<LazilyResolvedIriClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedIriInterface(
    identifier: LazilyResolvedIriInterface.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriInterface>>;
  lazilyResolvedIriInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedIriInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriInterface.$Identifier[]>
  >;
  lazilyResolvedIriInterfaces(
    query?: $ObjectSet.Query<LazilyResolvedIriInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedIriInterface[]>>;
  lazilyResolvedIriInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedIriInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazyPropertiesClass(
    identifier: LazyPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesClass>>;
  lazyPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass.$Identifier[]>>;
  lazyPropertiesClasses(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass[]>>;
  lazyPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<LazyPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  lazyPropertiesInterface(
    identifier: LazyPropertiesInterface.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesInterface>>;
  lazyPropertiesInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazyPropertiesInterface.$Identifier[]>
  >;
  lazyPropertiesInterfaces(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesInterface[]>>;
  lazyPropertiesInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  listPropertiesClass(
    identifier: ListPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ListPropertiesClass>>;
  listPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<ListPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass.$Identifier[]>>;
  listPropertiesClasses(
    query?: $ObjectSet.Query<ListPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass[]>>;
  listPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<ListPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  mutablePropertiesClass(
    identifier: MutablePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, MutablePropertiesClass>>;
  mutablePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly MutablePropertiesClass.$Identifier[]>
  >;
  mutablePropertiesClasses(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly MutablePropertiesClass[]>>;
  mutablePropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<MutablePropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  narrowedIdentifierClass(
    identifier: NarrowedIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, NarrowedIdentifierClass>>;
  narrowedIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<NarrowedIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly NarrowedIdentifierClass.$Identifier[]>
  >;
  narrowedIdentifierClasses(
    query?: $ObjectSet.Query<NarrowedIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly NarrowedIdentifierClass[]>>;
  narrowedIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<NarrowedIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  nonClass(
    identifier: NonClass.$Identifier,
  ): Promise<purify.Either<Error, NonClass>>;
  nonClassIdentifiers(
    query?: $ObjectSet.Query<NonClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly NonClass.$Identifier[]>>;
  nonClasses(
    query?: $ObjectSet.Query<NonClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly NonClass[]>>;
  nonClassesCount(
    query?: Pick<$ObjectSet.Query<NonClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  orderedPropertiesClass(
    identifier: OrderedPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, OrderedPropertiesClass>>;
  orderedPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly OrderedPropertiesClass.$Identifier[]>
  >;
  orderedPropertiesClasses(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly OrderedPropertiesClass[]>>;
  orderedPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<OrderedPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  partialClass(
    identifier: PartialClass.$Identifier,
  ): Promise<purify.Either<Error, PartialClass>>;
  partialClassIdentifiers(
    query?: $ObjectSet.Query<PartialClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClass.$Identifier[]>>;
  partialClasses(
    query?: $ObjectSet.Query<PartialClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClass[]>>;
  partialClassesCount(
    query?: Pick<$ObjectSet.Query<PartialClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  partialClassUnionMember1(
    identifier: PartialClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember1>>;
  partialClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember1.$Identifier[]>
  >;
  partialClassUnionMember1s(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember1[]>>;
  partialClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  partialClassUnionMember2(
    identifier: PartialClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember2>>;
  partialClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember2.$Identifier[]>
  >;
  partialClassUnionMember2s(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember2[]>>;
  partialClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  partialInterface(
    identifier: PartialInterface.$Identifier,
  ): Promise<purify.Either<Error, PartialInterface>>;
  partialInterfaceIdentifiers(
    query?: $ObjectSet.Query<PartialInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterface.$Identifier[]>>;
  partialInterfaces(
    query?: $ObjectSet.Query<PartialInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterface[]>>;
  partialInterfacesCount(
    query?: Pick<$ObjectSet.Query<PartialInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  partialInterfaceUnionMember1(
    identifier: PartialInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember1>>;
  partialInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember1.$Identifier[]>
  >;
  partialInterfaceUnionMember1s(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember1[]>>;
  partialInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  partialInterfaceUnionMember2(
    identifier: PartialInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember2>>;
  partialInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember2.$Identifier[]>
  >;
  partialInterfaceUnionMember2s(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember2[]>>;
  partialInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  propertyCardinalitiesClass(
    identifier: PropertyCardinalitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyCardinalitiesClass>>;
  propertyCardinalitiesClassIdentifiers(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PropertyCardinalitiesClass.$Identifier[]>
  >;
  propertyCardinalitiesClasses(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PropertyCardinalitiesClass[]>>;
  propertyCardinalitiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  propertyVisibilitiesClass(
    identifier: PropertyVisibilitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyVisibilitiesClass>>;
  propertyVisibilitiesClassIdentifiers(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PropertyVisibilitiesClass.$Identifier[]>
  >;
  propertyVisibilitiesClasses(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PropertyVisibilitiesClass[]>>;
  propertyVisibilitiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  recursiveClassUnionMember1(
    identifier: RecursiveClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember1>>;
  recursiveClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember1.$Identifier[]>
  >;
  recursiveClassUnionMember1s(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember1[]>>;
  recursiveClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  recursiveClassUnionMember2(
    identifier: RecursiveClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember2>>;
  recursiveClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember2.$Identifier[]>
  >;
  recursiveClassUnionMember2s(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember2[]>>;
  recursiveClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  sha256IriClass(
    identifier: Sha256IriClass.$Identifier,
  ): Promise<purify.Either<Error, Sha256IriClass>>;
  sha256IriClassIdentifiers(
    query?: $ObjectSet.Query<Sha256IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly Sha256IriClass.$Identifier[]>>;
  sha256IriClasses(
    query?: $ObjectSet.Query<Sha256IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly Sha256IriClass[]>>;
  sha256IriClassesCount(
    query?: Pick<$ObjectSet.Query<Sha256IriClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  termPropertiesClass(
    identifier: TermPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, TermPropertiesClass>>;
  termPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<TermPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass.$Identifier[]>>;
  termPropertiesClasses(
    query?: $ObjectSet.Query<TermPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass[]>>;
  termPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<TermPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  unionPropertiesClass(
    identifier: UnionPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, UnionPropertiesClass>>;
  unionPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<UnionPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly UnionPropertiesClass.$Identifier[]>>;
  unionPropertiesClasses(
    query?: $ObjectSet.Query<UnionPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly UnionPropertiesClass[]>>;
  unionPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<UnionPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  uuidV4IriClass(
    identifier: UuidV4IriClass.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriClass>>;
  uuidV4IriClassIdentifiers(
    query?: $ObjectSet.Query<UuidV4IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriClass.$Identifier[]>>;
  uuidV4IriClasses(
    query?: $ObjectSet.Query<UuidV4IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriClass[]>>;
  uuidV4IriClassesCount(
    query?: Pick<$ObjectSet.Query<UuidV4IriClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  uuidV4IriInterface(
    identifier: UuidV4IriInterface.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriInterface>>;
  uuidV4IriInterfaceIdentifiers(
    query?: $ObjectSet.Query<UuidV4IriInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriInterface.$Identifier[]>>;
  uuidV4IriInterfaces(
    query?: $ObjectSet.Query<UuidV4IriInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriInterface[]>>;
  uuidV4IriInterfacesCount(
    query?: Pick<$ObjectSet.Query<UuidV4IriInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  wideIdentifierClass(
    identifier: WideIdentifierClassStatic.$Identifier,
  ): Promise<purify.Either<Error, WideIdentifierClass>>;
  wideIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<WideIdentifierClassStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly WideIdentifierClassStatic.$Identifier[]>
  >;
  wideIdentifierClasses(
    query?: $ObjectSet.Query<WideIdentifierClassStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly WideIdentifierClass[]>>;
  wideIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<WideIdentifierClassStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  classUnion(
    identifier: ClassUnion.$Identifier,
  ): Promise<purify.Either<Error, ClassUnion>>;
  classUnionIdentifiers(
    query?: $ObjectSet.Query<ClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnion.$Identifier[]>>;
  classUnions(
    query?: $ObjectSet.Query<ClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnion[]>>;
  classUnionsCount(
    query?: Pick<$ObjectSet.Query<ClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  interfaceUnion(
    identifier: InterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnion>>;
  interfaceUnionIdentifiers(
    query?: $ObjectSet.Query<InterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion.$Identifier[]>>;
  interfaceUnions(
    query?: $ObjectSet.Query<InterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion[]>>;
  interfaceUnionsCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  interfaceUnionMember2(
    identifier: InterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember2>>;
  interfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember2.$Identifier[]>
  >;
  interfaceUnionMember2s(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember2[]>>;
  interfaceUnionMember2sCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember2.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedClassUnion(
    identifier: LazilyResolvedClassUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnion>>;
  lazilyResolvedClassUnionIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnion.$Identifier[]>
  >;
  lazilyResolvedClassUnions(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnion[]>>;
  lazilyResolvedClassUnionsCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedInterfaceUnion(
    identifier: LazilyResolvedInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnion>>;
  lazilyResolvedInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnion.$Identifier[]>
  >;
  lazilyResolvedInterfaceUnions(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedInterfaceUnion[]>>;
  lazilyResolvedInterfaceUnionsCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  partialClassUnion(
    identifier: PartialClassUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnion>>;
  partialClassUnionIdentifiers(
    query?: $ObjectSet.Query<PartialClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion.$Identifier[]>>;
  partialClassUnions(
    query?: $ObjectSet.Query<PartialClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion[]>>;
  partialClassUnionsCount(
    query?: Pick<$ObjectSet.Query<PartialClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  partialInterfaceUnion(
    identifier: PartialInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnion>>;
  partialInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnion.$Identifier[]>
  >;
  partialInterfaceUnions(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnion[]>>;
  partialInterfaceUnionsCount(
    query?: Pick<$ObjectSet.Query<PartialInterfaceUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  recursiveClassUnion(
    identifier: RecursiveClassUnion.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnion>>;
  recursiveClassUnionIdentifiers(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion.$Identifier[]>>;
  recursiveClassUnions(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion[]>>;
  recursiveClassUnionsCount(
    query?: Pick<$ObjectSet.Query<RecursiveClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
}

export namespace $ObjectSet {
  export type Query<
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  > = {
    readonly limit?: number;
    readonly offset?: number;
    readonly where?: Where<ObjectIdentifierT>;
  };
  export type Where<
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  > =
    | {
        readonly identifiers: readonly ObjectIdentifierT[];
        readonly type: "identifiers";
      }
    | {
        readonly objectTermType?: "NamedNode";
        readonly predicate: rdfjs.NamedNode;
        readonly subject?: rdfjs.BlankNode | rdfjs.NamedNode;
        readonly type: "triple-objects";
      }
    | {
        readonly object?: rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode;
        readonly predicate: rdfjs.NamedNode;
        readonly subjectTermType?: "NamedNode";
        readonly type: "triple-subjects";
      }
    | { readonly identifierType?: "NamedNode"; readonly type: "type" };
}

export abstract class $ForwardingObjectSet implements $ObjectSet {
  protected abstract get $delegate(): $ObjectSet;

  baseInterfaceWithoutProperties(
    identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithoutProperties>> {
    return this.$delegate.baseInterfaceWithoutProperties(identifier);
  }

  baseInterfaceWithoutPropertiesIdentifiers(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithoutPropertiesStatic.$Identifier[]
    >
  > {
    return this.$delegate.baseInterfaceWithoutPropertiesIdentifiers(query);
  }

  baseInterfaceWithoutPropertieses(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithoutProperties[]>> {
    return this.$delegate.baseInterfaceWithoutPropertieses(query);
  }

  baseInterfaceWithoutPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.baseInterfaceWithoutPropertiesesCount(query);
  }

  baseInterfaceWithProperties(
    identifier: BaseInterfaceWithPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithProperties>> {
    return this.$delegate.baseInterfaceWithProperties(identifier);
  }

  baseInterfaceWithPropertiesIdentifiers(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithPropertiesStatic.$Identifier[]
    >
  > {
    return this.$delegate.baseInterfaceWithPropertiesIdentifiers(query);
  }

  baseInterfaceWithPropertieses(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithProperties[]>> {
    return this.$delegate.baseInterfaceWithPropertieses(query);
  }

  baseInterfaceWithPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.baseInterfaceWithPropertiesesCount(query);
  }

  blankClass(
    identifier: BlankClass.$Identifier,
  ): Promise<purify.Either<Error, BlankClass>> {
    return this.$delegate.blankClass(identifier);
  }

  blankClassIdentifiers(
    query?: $ObjectSet.Query<BlankClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankClass.$Identifier[]>> {
    return this.$delegate.blankClassIdentifiers(query);
  }

  blankClasses(
    query?: $ObjectSet.Query<BlankClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankClass[]>> {
    return this.$delegate.blankClasses(query);
  }

  blankClassesCount(
    query?: Pick<$ObjectSet.Query<BlankClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.blankClassesCount(query);
  }

  blankInterface(
    identifier: BlankInterface.$Identifier,
  ): Promise<purify.Either<Error, BlankInterface>> {
    return this.$delegate.blankInterface(identifier);
  }

  blankInterfaceIdentifiers(
    query?: $ObjectSet.Query<BlankInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankInterface.$Identifier[]>> {
    return this.$delegate.blankInterfaceIdentifiers(query);
  }

  blankInterfaces(
    query?: $ObjectSet.Query<BlankInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankInterface[]>> {
    return this.$delegate.blankInterfaces(query);
  }

  blankInterfacesCount(
    query?: Pick<$ObjectSet.Query<BlankInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.blankInterfacesCount(query);
  }

  classUnionMember1(
    identifier: ClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember1>> {
    return this.$delegate.classUnionMember1(identifier);
  }

  classUnionMember1Identifiers(
    query?: $ObjectSet.Query<ClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1.$Identifier[]>> {
    return this.$delegate.classUnionMember1Identifiers(query);
  }

  classUnionMember1s(
    query?: $ObjectSet.Query<ClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1[]>> {
    return this.$delegate.classUnionMember1s(query);
  }

  classUnionMember1sCount(
    query?: Pick<$ObjectSet.Query<ClassUnionMember1.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.classUnionMember1sCount(query);
  }

  classUnionMember2(
    identifier: ClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember2>> {
    return this.$delegate.classUnionMember2(identifier);
  }

  classUnionMember2Identifiers(
    query?: $ObjectSet.Query<ClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2.$Identifier[]>> {
    return this.$delegate.classUnionMember2Identifiers(query);
  }

  classUnionMember2s(
    query?: $ObjectSet.Query<ClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2[]>> {
    return this.$delegate.classUnionMember2s(query);
  }

  classUnionMember2sCount(
    query?: Pick<$ObjectSet.Query<ClassUnionMember2.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.classUnionMember2sCount(query);
  }

  concreteChildClass(
    identifier: ConcreteChildClass.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildClass>> {
    return this.$delegate.concreteChildClass(identifier);
  }

  concreteChildClassIdentifiers(
    query?: $ObjectSet.Query<ConcreteChildClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass.$Identifier[]>> {
    return this.$delegate.concreteChildClassIdentifiers(query);
  }

  concreteChildClasses(
    query?: $ObjectSet.Query<ConcreteChildClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass[]>> {
    return this.$delegate.concreteChildClasses(query);
  }

  concreteChildClassesCount(
    query?: Pick<$ObjectSet.Query<ConcreteChildClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.concreteChildClassesCount(query);
  }

  concreteChildInterface(
    identifier: ConcreteChildInterface.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildInterface>> {
    return this.$delegate.concreteChildInterface(identifier);
  }

  concreteChildInterfaceIdentifiers(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteChildInterface.$Identifier[]>
  > {
    return this.$delegate.concreteChildInterfaceIdentifiers(query);
  }

  concreteChildInterfaces(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildInterface[]>> {
    return this.$delegate.concreteChildInterfaces(query);
  }

  concreteChildInterfacesCount(
    query?: Pick<$ObjectSet.Query<ConcreteChildInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.concreteChildInterfacesCount(query);
  }

  concreteParentClass(
    identifier: ConcreteParentClassStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentClass>> {
    return this.$delegate.concreteParentClass(identifier);
  }

  concreteParentClassIdentifiers(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentClassStatic.$Identifier[]>
  > {
    return this.$delegate.concreteParentClassIdentifiers(query);
  }

  concreteParentClasses(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteParentClass[]>> {
    return this.$delegate.concreteParentClasses(query);
  }

  concreteParentClassesCount(
    query?: Pick<
      $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.concreteParentClassesCount(query);
  }

  concreteParentInterface(
    identifier: ConcreteParentInterfaceStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentInterface>> {
    return this.$delegate.concreteParentInterface(identifier);
  }

  concreteParentInterfaceIdentifiers(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentInterfaceStatic.$Identifier[]>
  > {
    return this.$delegate.concreteParentInterfaceIdentifiers(query);
  }

  concreteParentInterfaces(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteParentInterface[]>> {
    return this.$delegate.concreteParentInterfaces(query);
  }

  concreteParentInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.concreteParentInterfacesCount(query);
  }

  convertibleTypePropertiesClass(
    identifier: ConvertibleTypePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ConvertibleTypePropertiesClass>> {
    return this.$delegate.convertibleTypePropertiesClass(identifier);
  }

  convertibleTypePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConvertibleTypePropertiesClass.$Identifier[]>
  > {
    return this.$delegate.convertibleTypePropertiesClassIdentifiers(query);
  }

  convertibleTypePropertiesClasses(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConvertibleTypePropertiesClass[]>> {
    return this.$delegate.convertibleTypePropertiesClasses(query);
  }

  convertibleTypePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.convertibleTypePropertiesClassesCount(query);
  }

  defaultValuePropertiesClass(
    identifier: DefaultValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, DefaultValuePropertiesClass>> {
    return this.$delegate.defaultValuePropertiesClass(identifier);
  }

  defaultValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly DefaultValuePropertiesClass.$Identifier[]>
  > {
    return this.$delegate.defaultValuePropertiesClassIdentifiers(query);
  }

  defaultValuePropertiesClasses(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DefaultValuePropertiesClass[]>> {
    return this.$delegate.defaultValuePropertiesClasses(query);
  }

  defaultValuePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.defaultValuePropertiesClassesCount(query);
  }

  directRecursiveClass(
    identifier: DirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, DirectRecursiveClass>> {
    return this.$delegate.directRecursiveClass(identifier);
  }

  directRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly DirectRecursiveClass.$Identifier[]>
  > {
    return this.$delegate.directRecursiveClassIdentifiers(query);
  }

  directRecursiveClasses(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DirectRecursiveClass[]>> {
    return this.$delegate.directRecursiveClasses(query);
  }

  directRecursiveClassesCount(
    query?: Pick<$ObjectSet.Query<DirectRecursiveClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.directRecursiveClassesCount(query);
  }

  explicitFromToRdfTypesClass(
    identifier: ExplicitFromToRdfTypesClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitFromToRdfTypesClass>> {
    return this.$delegate.explicitFromToRdfTypesClass(identifier);
  }

  explicitFromToRdfTypesClassIdentifiers(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExplicitFromToRdfTypesClass.$Identifier[]>
  > {
    return this.$delegate.explicitFromToRdfTypesClassIdentifiers(query);
  }

  explicitFromToRdfTypesClasses(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExplicitFromToRdfTypesClass[]>> {
    return this.$delegate.explicitFromToRdfTypesClasses(query);
  }

  explicitFromToRdfTypesClassesCount(
    query?: Pick<
      $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.explicitFromToRdfTypesClassesCount(query);
  }

  explicitRdfTypeClass(
    identifier: ExplicitRdfTypeClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitRdfTypeClass>> {
    return this.$delegate.explicitRdfTypeClass(identifier);
  }

  explicitRdfTypeClassIdentifiers(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExplicitRdfTypeClass.$Identifier[]>
  > {
    return this.$delegate.explicitRdfTypeClassIdentifiers(query);
  }

  explicitRdfTypeClasses(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExplicitRdfTypeClass[]>> {
    return this.$delegate.explicitRdfTypeClasses(query);
  }

  explicitRdfTypeClassesCount(
    query?: Pick<$ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.explicitRdfTypeClassesCount(query);
  }

  externClassPropertyClass(
    identifier: ExternClassPropertyClass.$Identifier,
  ): Promise<purify.Either<Error, ExternClassPropertyClass>> {
    return this.$delegate.externClassPropertyClass(identifier);
  }

  externClassPropertyClassIdentifiers(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExternClassPropertyClass.$Identifier[]>
  > {
    return this.$delegate.externClassPropertyClassIdentifiers(query);
  }

  externClassPropertyClasses(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExternClassPropertyClass[]>> {
    return this.$delegate.externClassPropertyClasses(query);
  }

  externClassPropertyClassesCount(
    query?: Pick<
      $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.externClassPropertyClassesCount(query);
  }

  hasValuePropertiesClass(
    identifier: HasValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, HasValuePropertiesClass>> {
    return this.$delegate.hasValuePropertiesClass(identifier);
  }

  hasValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly HasValuePropertiesClass.$Identifier[]>
  > {
    return this.$delegate.hasValuePropertiesClassIdentifiers(query);
  }

  hasValuePropertiesClasses(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly HasValuePropertiesClass[]>> {
    return this.$delegate.hasValuePropertiesClasses(query);
  }

  hasValuePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.hasValuePropertiesClassesCount(query);
  }

  indirectRecursiveClass(
    identifier: IndirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveClass>> {
    return this.$delegate.indirectRecursiveClass(identifier);
  }

  indirectRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveClass.$Identifier[]>
  > {
    return this.$delegate.indirectRecursiveClassIdentifiers(query);
  }

  indirectRecursiveClasses(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveClass[]>> {
    return this.$delegate.indirectRecursiveClasses(query);
  }

  indirectRecursiveClassesCount(
    query?: Pick<$ObjectSet.Query<IndirectRecursiveClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.indirectRecursiveClassesCount(query);
  }

  indirectRecursiveHelperClass(
    identifier: IndirectRecursiveHelperClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveHelperClass>> {
    return this.$delegate.indirectRecursiveHelperClass(identifier);
  }

  indirectRecursiveHelperClassIdentifiers(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveHelperClass.$Identifier[]>
  > {
    return this.$delegate.indirectRecursiveHelperClassIdentifiers(query);
  }

  indirectRecursiveHelperClasses(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveHelperClass[]>> {
    return this.$delegate.indirectRecursiveHelperClasses(query);
  }

  indirectRecursiveHelperClassesCount(
    query?: Pick<
      $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.indirectRecursiveHelperClassesCount(query);
  }

  inIdentifierClass(
    identifier: InIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, InIdentifierClass>> {
    return this.$delegate.inIdentifierClass(identifier);
  }

  inIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<InIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass.$Identifier[]>> {
    return this.$delegate.inIdentifierClassIdentifiers(query);
  }

  inIdentifierClasses(
    query?: $ObjectSet.Query<InIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass[]>> {
    return this.$delegate.inIdentifierClasses(query);
  }

  inIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<InIdentifierClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.inIdentifierClassesCount(query);
  }

  inPropertiesClass(
    identifier: InPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, InPropertiesClass>> {
    return this.$delegate.inPropertiesClass(identifier);
  }

  inPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<InPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass.$Identifier[]>> {
    return this.$delegate.inPropertiesClassIdentifiers(query);
  }

  inPropertiesClasses(
    query?: $ObjectSet.Query<InPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass[]>> {
    return this.$delegate.inPropertiesClasses(query);
  }

  inPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<InPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.inPropertiesClassesCount(query);
  }

  interface(
    identifier: Interface.$Identifier,
  ): Promise<purify.Either<Error, Interface>> {
    return this.$delegate.interface(identifier);
  }

  interfaceIdentifiers(
    query?: $ObjectSet.Query<Interface.$Identifier>,
  ): Promise<purify.Either<Error, readonly Interface.$Identifier[]>> {
    return this.$delegate.interfaceIdentifiers(query);
  }

  interfaces(
    query?: $ObjectSet.Query<Interface.$Identifier>,
  ): Promise<purify.Either<Error, readonly Interface[]>> {
    return this.$delegate.interfaces(query);
  }

  interfacesCount(
    query?: Pick<$ObjectSet.Query<Interface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.interfacesCount(query);
  }

  interfaceUnionMember1(
    identifier: InterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember1>> {
    return this.$delegate.interfaceUnionMember1(identifier);
  }

  interfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember1.$Identifier[]>
  > {
    return this.$delegate.interfaceUnionMember1Identifiers(query);
  }

  interfaceUnionMember1s(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember1[]>> {
    return this.$delegate.interfaceUnionMember1s(query);
  }

  interfaceUnionMember1sCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember1.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.interfaceUnionMember1sCount(query);
  }

  interfaceUnionMember2a(
    identifier: InterfaceUnionMember2a.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember2a>> {
    return this.$delegate.interfaceUnionMember2a(identifier);
  }

  interfaceUnionMember2aIdentifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember2a.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember2a.$Identifier[]>
  > {
    return this.$delegate.interfaceUnionMember2aIdentifiers(query);
  }

  interfaceUnionMember2as(
    query?: $ObjectSet.Query<InterfaceUnionMember2a.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember2a[]>> {
    return this.$delegate.interfaceUnionMember2as(query);
  }

  interfaceUnionMember2asCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember2a.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.interfaceUnionMember2asCount(query);
  }

  interfaceUnionMember2b(
    identifier: InterfaceUnionMember2b.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember2b>> {
    return this.$delegate.interfaceUnionMember2b(identifier);
  }

  interfaceUnionMember2bIdentifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember2b.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember2b.$Identifier[]>
  > {
    return this.$delegate.interfaceUnionMember2bIdentifiers(query);
  }

  interfaceUnionMember2bs(
    query?: $ObjectSet.Query<InterfaceUnionMember2b.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember2b[]>> {
    return this.$delegate.interfaceUnionMember2bs(query);
  }

  interfaceUnionMember2bsCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember2b.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.interfaceUnionMember2bsCount(query);
  }

  iriClass(
    identifier: IriClass.$Identifier,
  ): Promise<purify.Either<Error, IriClass>> {
    return this.$delegate.iriClass(identifier);
  }

  iriClassIdentifiers(
    query?: $ObjectSet.Query<IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IriClass.$Identifier[]>> {
    return this.$delegate.iriClassIdentifiers(query);
  }

  iriClasses(
    query?: $ObjectSet.Query<IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IriClass[]>> {
    return this.$delegate.iriClasses(query);
  }

  iriClassesCount(
    query?: Pick<$ObjectSet.Query<IriClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.iriClassesCount(query);
  }

  languageInPropertiesClass(
    identifier: LanguageInPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LanguageInPropertiesClass>> {
    return this.$delegate.languageInPropertiesClass(identifier);
  }

  languageInPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LanguageInPropertiesClass.$Identifier[]>
  > {
    return this.$delegate.languageInPropertiesClassIdentifiers(query);
  }

  languageInPropertiesClasses(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LanguageInPropertiesClass[]>> {
    return this.$delegate.languageInPropertiesClasses(query);
  }

  languageInPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.languageInPropertiesClassesCount(query);
  }

  lazilyResolvedBlankNodeOrIriClass(
    identifier: LazilyResolvedBlankNodeOrIriClass.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedBlankNodeOrIriClass>> {
    return this.$delegate.lazilyResolvedBlankNodeOrIriClass(identifier);
  }

  lazilyResolvedBlankNodeOrIriClassIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriClass.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriClass.$Identifier[]
    >
  > {
    return this.$delegate.lazilyResolvedBlankNodeOrIriClassIdentifiers(query);
  }

  lazilyResolvedBlankNodeOrIriClasses(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedBlankNodeOrIriClass[]>
  > {
    return this.$delegate.lazilyResolvedBlankNodeOrIriClasses(query);
  }

  lazilyResolvedBlankNodeOrIriClassesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedBlankNodeOrIriClassesCount(query);
  }

  lazilyResolvedBlankNodeOrIriInterface(
    identifier: LazilyResolvedBlankNodeOrIriInterface.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedBlankNodeOrIriInterface>> {
    return this.$delegate.lazilyResolvedBlankNodeOrIriInterface(identifier);
  }

  lazilyResolvedBlankNodeOrIriInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriInterface.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriInterface.$Identifier[]
    >
  > {
    return this.$delegate.lazilyResolvedBlankNodeOrIriInterfaceIdentifiers(
      query,
    );
  }

  lazilyResolvedBlankNodeOrIriInterfaces(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedBlankNodeOrIriInterface[]>
  > {
    return this.$delegate.lazilyResolvedBlankNodeOrIriInterfaces(query);
  }

  lazilyResolvedBlankNodeOrIriInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedBlankNodeOrIriInterfacesCount(query);
  }

  lazilyResolvedClassUnionMember1(
    identifier: LazilyResolvedClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember1>> {
    return this.$delegate.lazilyResolvedClassUnionMember1(identifier);
  }

  lazilyResolvedClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember1.$Identifier[]>
  > {
    return this.$delegate.lazilyResolvedClassUnionMember1Identifiers(query);
  }

  lazilyResolvedClassUnionMember1s(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember1[]>> {
    return this.$delegate.lazilyResolvedClassUnionMember1s(query);
  }

  lazilyResolvedClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedClassUnionMember1sCount(query);
  }

  lazilyResolvedClassUnionMember2(
    identifier: LazilyResolvedClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember2>> {
    return this.$delegate.lazilyResolvedClassUnionMember2(identifier);
  }

  lazilyResolvedClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember2.$Identifier[]>
  > {
    return this.$delegate.lazilyResolvedClassUnionMember2Identifiers(query);
  }

  lazilyResolvedClassUnionMember2s(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember2[]>> {
    return this.$delegate.lazilyResolvedClassUnionMember2s(query);
  }

  lazilyResolvedClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedClassUnionMember2sCount(query);
  }

  lazilyResolvedInterfaceUnionMember1(
    identifier: LazilyResolvedInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember1>> {
    return this.$delegate.lazilyResolvedInterfaceUnionMember1(identifier);
  }

  lazilyResolvedInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember1.$Identifier[]
    >
  > {
    return this.$delegate.lazilyResolvedInterfaceUnionMember1Identifiers(query);
  }

  lazilyResolvedInterfaceUnionMember1s(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember1[]>
  > {
    return this.$delegate.lazilyResolvedInterfaceUnionMember1s(query);
  }

  lazilyResolvedInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedInterfaceUnionMember1sCount(query);
  }

  lazilyResolvedInterfaceUnionMember2(
    identifier: LazilyResolvedInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember2>> {
    return this.$delegate.lazilyResolvedInterfaceUnionMember2(identifier);
  }

  lazilyResolvedInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember2.$Identifier[]
    >
  > {
    return this.$delegate.lazilyResolvedInterfaceUnionMember2Identifiers(query);
  }

  lazilyResolvedInterfaceUnionMember2s(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember2[]>
  > {
    return this.$delegate.lazilyResolvedInterfaceUnionMember2s(query);
  }

  lazilyResolvedInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedInterfaceUnionMember2sCount(query);
  }

  lazilyResolvedIriClass(
    identifier: LazilyResolvedIriClass.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriClass>> {
    return this.$delegate.lazilyResolvedIriClass(identifier);
  }

  lazilyResolvedIriClassIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedIriClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriClass.$Identifier[]>
  > {
    return this.$delegate.lazilyResolvedIriClassIdentifiers(query);
  }

  lazilyResolvedIriClasses(
    query?: $ObjectSet.Query<LazilyResolvedIriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedIriClass[]>> {
    return this.$delegate.lazilyResolvedIriClasses(query);
  }

  lazilyResolvedIriClassesCount(
    query?: Pick<$ObjectSet.Query<LazilyResolvedIriClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedIriClassesCount(query);
  }

  lazilyResolvedIriInterface(
    identifier: LazilyResolvedIriInterface.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriInterface>> {
    return this.$delegate.lazilyResolvedIriInterface(identifier);
  }

  lazilyResolvedIriInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedIriInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriInterface.$Identifier[]>
  > {
    return this.$delegate.lazilyResolvedIriInterfaceIdentifiers(query);
  }

  lazilyResolvedIriInterfaces(
    query?: $ObjectSet.Query<LazilyResolvedIriInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedIriInterface[]>> {
    return this.$delegate.lazilyResolvedIriInterfaces(query);
  }

  lazilyResolvedIriInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedIriInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedIriInterfacesCount(query);
  }

  lazyPropertiesClass(
    identifier: LazyPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesClass>> {
    return this.$delegate.lazyPropertiesClass(identifier);
  }

  lazyPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass.$Identifier[]>> {
    return this.$delegate.lazyPropertiesClassIdentifiers(query);
  }

  lazyPropertiesClasses(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass[]>> {
    return this.$delegate.lazyPropertiesClasses(query);
  }

  lazyPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<LazyPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazyPropertiesClassesCount(query);
  }

  lazyPropertiesInterface(
    identifier: LazyPropertiesInterface.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesInterface>> {
    return this.$delegate.lazyPropertiesInterface(identifier);
  }

  lazyPropertiesInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazyPropertiesInterface.$Identifier[]>
  > {
    return this.$delegate.lazyPropertiesInterfaceIdentifiers(query);
  }

  lazyPropertiesInterfaces(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesInterface[]>> {
    return this.$delegate.lazyPropertiesInterfaces(query);
  }

  lazyPropertiesInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazyPropertiesInterfacesCount(query);
  }

  listPropertiesClass(
    identifier: ListPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ListPropertiesClass>> {
    return this.$delegate.listPropertiesClass(identifier);
  }

  listPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<ListPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass.$Identifier[]>> {
    return this.$delegate.listPropertiesClassIdentifiers(query);
  }

  listPropertiesClasses(
    query?: $ObjectSet.Query<ListPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass[]>> {
    return this.$delegate.listPropertiesClasses(query);
  }

  listPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<ListPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.listPropertiesClassesCount(query);
  }

  mutablePropertiesClass(
    identifier: MutablePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, MutablePropertiesClass>> {
    return this.$delegate.mutablePropertiesClass(identifier);
  }

  mutablePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly MutablePropertiesClass.$Identifier[]>
  > {
    return this.$delegate.mutablePropertiesClassIdentifiers(query);
  }

  mutablePropertiesClasses(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly MutablePropertiesClass[]>> {
    return this.$delegate.mutablePropertiesClasses(query);
  }

  mutablePropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<MutablePropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.mutablePropertiesClassesCount(query);
  }

  narrowedIdentifierClass(
    identifier: NarrowedIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, NarrowedIdentifierClass>> {
    return this.$delegate.narrowedIdentifierClass(identifier);
  }

  narrowedIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<NarrowedIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly NarrowedIdentifierClass.$Identifier[]>
  > {
    return this.$delegate.narrowedIdentifierClassIdentifiers(query);
  }

  narrowedIdentifierClasses(
    query?: $ObjectSet.Query<NarrowedIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly NarrowedIdentifierClass[]>> {
    return this.$delegate.narrowedIdentifierClasses(query);
  }

  narrowedIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<NarrowedIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.narrowedIdentifierClassesCount(query);
  }

  nonClass(
    identifier: NonClass.$Identifier,
  ): Promise<purify.Either<Error, NonClass>> {
    return this.$delegate.nonClass(identifier);
  }

  nonClassIdentifiers(
    query?: $ObjectSet.Query<NonClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly NonClass.$Identifier[]>> {
    return this.$delegate.nonClassIdentifiers(query);
  }

  nonClasses(
    query?: $ObjectSet.Query<NonClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly NonClass[]>> {
    return this.$delegate.nonClasses(query);
  }

  nonClassesCount(
    query?: Pick<$ObjectSet.Query<NonClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.nonClassesCount(query);
  }

  orderedPropertiesClass(
    identifier: OrderedPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, OrderedPropertiesClass>> {
    return this.$delegate.orderedPropertiesClass(identifier);
  }

  orderedPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly OrderedPropertiesClass.$Identifier[]>
  > {
    return this.$delegate.orderedPropertiesClassIdentifiers(query);
  }

  orderedPropertiesClasses(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly OrderedPropertiesClass[]>> {
    return this.$delegate.orderedPropertiesClasses(query);
  }

  orderedPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<OrderedPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.orderedPropertiesClassesCount(query);
  }

  partialClass(
    identifier: PartialClass.$Identifier,
  ): Promise<purify.Either<Error, PartialClass>> {
    return this.$delegate.partialClass(identifier);
  }

  partialClassIdentifiers(
    query?: $ObjectSet.Query<PartialClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClass.$Identifier[]>> {
    return this.$delegate.partialClassIdentifiers(query);
  }

  partialClasses(
    query?: $ObjectSet.Query<PartialClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClass[]>> {
    return this.$delegate.partialClasses(query);
  }

  partialClassesCount(
    query?: Pick<$ObjectSet.Query<PartialClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialClassesCount(query);
  }

  partialClassUnionMember1(
    identifier: PartialClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember1>> {
    return this.$delegate.partialClassUnionMember1(identifier);
  }

  partialClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember1.$Identifier[]>
  > {
    return this.$delegate.partialClassUnionMember1Identifiers(query);
  }

  partialClassUnionMember1s(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember1[]>> {
    return this.$delegate.partialClassUnionMember1s(query);
  }

  partialClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialClassUnionMember1sCount(query);
  }

  partialClassUnionMember2(
    identifier: PartialClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember2>> {
    return this.$delegate.partialClassUnionMember2(identifier);
  }

  partialClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember2.$Identifier[]>
  > {
    return this.$delegate.partialClassUnionMember2Identifiers(query);
  }

  partialClassUnionMember2s(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember2[]>> {
    return this.$delegate.partialClassUnionMember2s(query);
  }

  partialClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialClassUnionMember2sCount(query);
  }

  partialInterface(
    identifier: PartialInterface.$Identifier,
  ): Promise<purify.Either<Error, PartialInterface>> {
    return this.$delegate.partialInterface(identifier);
  }

  partialInterfaceIdentifiers(
    query?: $ObjectSet.Query<PartialInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterface.$Identifier[]>> {
    return this.$delegate.partialInterfaceIdentifiers(query);
  }

  partialInterfaces(
    query?: $ObjectSet.Query<PartialInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterface[]>> {
    return this.$delegate.partialInterfaces(query);
  }

  partialInterfacesCount(
    query?: Pick<$ObjectSet.Query<PartialInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialInterfacesCount(query);
  }

  partialInterfaceUnionMember1(
    identifier: PartialInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember1>> {
    return this.$delegate.partialInterfaceUnionMember1(identifier);
  }

  partialInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember1.$Identifier[]>
  > {
    return this.$delegate.partialInterfaceUnionMember1Identifiers(query);
  }

  partialInterfaceUnionMember1s(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember1[]>> {
    return this.$delegate.partialInterfaceUnionMember1s(query);
  }

  partialInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialInterfaceUnionMember1sCount(query);
  }

  partialInterfaceUnionMember2(
    identifier: PartialInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember2>> {
    return this.$delegate.partialInterfaceUnionMember2(identifier);
  }

  partialInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember2.$Identifier[]>
  > {
    return this.$delegate.partialInterfaceUnionMember2Identifiers(query);
  }

  partialInterfaceUnionMember2s(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember2[]>> {
    return this.$delegate.partialInterfaceUnionMember2s(query);
  }

  partialInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialInterfaceUnionMember2sCount(query);
  }

  propertyCardinalitiesClass(
    identifier: PropertyCardinalitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyCardinalitiesClass>> {
    return this.$delegate.propertyCardinalitiesClass(identifier);
  }

  propertyCardinalitiesClassIdentifiers(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PropertyCardinalitiesClass.$Identifier[]>
  > {
    return this.$delegate.propertyCardinalitiesClassIdentifiers(query);
  }

  propertyCardinalitiesClasses(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PropertyCardinalitiesClass[]>> {
    return this.$delegate.propertyCardinalitiesClasses(query);
  }

  propertyCardinalitiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.propertyCardinalitiesClassesCount(query);
  }

  propertyVisibilitiesClass(
    identifier: PropertyVisibilitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyVisibilitiesClass>> {
    return this.$delegate.propertyVisibilitiesClass(identifier);
  }

  propertyVisibilitiesClassIdentifiers(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PropertyVisibilitiesClass.$Identifier[]>
  > {
    return this.$delegate.propertyVisibilitiesClassIdentifiers(query);
  }

  propertyVisibilitiesClasses(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PropertyVisibilitiesClass[]>> {
    return this.$delegate.propertyVisibilitiesClasses(query);
  }

  propertyVisibilitiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.propertyVisibilitiesClassesCount(query);
  }

  recursiveClassUnionMember1(
    identifier: RecursiveClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember1>> {
    return this.$delegate.recursiveClassUnionMember1(identifier);
  }

  recursiveClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember1.$Identifier[]>
  > {
    return this.$delegate.recursiveClassUnionMember1Identifiers(query);
  }

  recursiveClassUnionMember1s(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember1[]>> {
    return this.$delegate.recursiveClassUnionMember1s(query);
  }

  recursiveClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.recursiveClassUnionMember1sCount(query);
  }

  recursiveClassUnionMember2(
    identifier: RecursiveClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember2>> {
    return this.$delegate.recursiveClassUnionMember2(identifier);
  }

  recursiveClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember2.$Identifier[]>
  > {
    return this.$delegate.recursiveClassUnionMember2Identifiers(query);
  }

  recursiveClassUnionMember2s(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember2[]>> {
    return this.$delegate.recursiveClassUnionMember2s(query);
  }

  recursiveClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.recursiveClassUnionMember2sCount(query);
  }

  sha256IriClass(
    identifier: Sha256IriClass.$Identifier,
  ): Promise<purify.Either<Error, Sha256IriClass>> {
    return this.$delegate.sha256IriClass(identifier);
  }

  sha256IriClassIdentifiers(
    query?: $ObjectSet.Query<Sha256IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly Sha256IriClass.$Identifier[]>> {
    return this.$delegate.sha256IriClassIdentifiers(query);
  }

  sha256IriClasses(
    query?: $ObjectSet.Query<Sha256IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly Sha256IriClass[]>> {
    return this.$delegate.sha256IriClasses(query);
  }

  sha256IriClassesCount(
    query?: Pick<$ObjectSet.Query<Sha256IriClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.sha256IriClassesCount(query);
  }

  termPropertiesClass(
    identifier: TermPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, TermPropertiesClass>> {
    return this.$delegate.termPropertiesClass(identifier);
  }

  termPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<TermPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass.$Identifier[]>> {
    return this.$delegate.termPropertiesClassIdentifiers(query);
  }

  termPropertiesClasses(
    query?: $ObjectSet.Query<TermPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass[]>> {
    return this.$delegate.termPropertiesClasses(query);
  }

  termPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<TermPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.termPropertiesClassesCount(query);
  }

  unionPropertiesClass(
    identifier: UnionPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, UnionPropertiesClass>> {
    return this.$delegate.unionPropertiesClass(identifier);
  }

  unionPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<UnionPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly UnionPropertiesClass.$Identifier[]>
  > {
    return this.$delegate.unionPropertiesClassIdentifiers(query);
  }

  unionPropertiesClasses(
    query?: $ObjectSet.Query<UnionPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly UnionPropertiesClass[]>> {
    return this.$delegate.unionPropertiesClasses(query);
  }

  unionPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<UnionPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.unionPropertiesClassesCount(query);
  }

  uuidV4IriClass(
    identifier: UuidV4IriClass.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriClass>> {
    return this.$delegate.uuidV4IriClass(identifier);
  }

  uuidV4IriClassIdentifiers(
    query?: $ObjectSet.Query<UuidV4IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriClass.$Identifier[]>> {
    return this.$delegate.uuidV4IriClassIdentifiers(query);
  }

  uuidV4IriClasses(
    query?: $ObjectSet.Query<UuidV4IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriClass[]>> {
    return this.$delegate.uuidV4IriClasses(query);
  }

  uuidV4IriClassesCount(
    query?: Pick<$ObjectSet.Query<UuidV4IriClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.uuidV4IriClassesCount(query);
  }

  uuidV4IriInterface(
    identifier: UuidV4IriInterface.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriInterface>> {
    return this.$delegate.uuidV4IriInterface(identifier);
  }

  uuidV4IriInterfaceIdentifiers(
    query?: $ObjectSet.Query<UuidV4IriInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriInterface.$Identifier[]>> {
    return this.$delegate.uuidV4IriInterfaceIdentifiers(query);
  }

  uuidV4IriInterfaces(
    query?: $ObjectSet.Query<UuidV4IriInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriInterface[]>> {
    return this.$delegate.uuidV4IriInterfaces(query);
  }

  uuidV4IriInterfacesCount(
    query?: Pick<$ObjectSet.Query<UuidV4IriInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.uuidV4IriInterfacesCount(query);
  }

  wideIdentifierClass(
    identifier: WideIdentifierClassStatic.$Identifier,
  ): Promise<purify.Either<Error, WideIdentifierClass>> {
    return this.$delegate.wideIdentifierClass(identifier);
  }

  wideIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<WideIdentifierClassStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly WideIdentifierClassStatic.$Identifier[]>
  > {
    return this.$delegate.wideIdentifierClassIdentifiers(query);
  }

  wideIdentifierClasses(
    query?: $ObjectSet.Query<WideIdentifierClassStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly WideIdentifierClass[]>> {
    return this.$delegate.wideIdentifierClasses(query);
  }

  wideIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<WideIdentifierClassStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.wideIdentifierClassesCount(query);
  }

  classUnion(
    identifier: ClassUnion.$Identifier,
  ): Promise<purify.Either<Error, ClassUnion>> {
    return this.$delegate.classUnion(identifier);
  }

  classUnionIdentifiers(
    query?: $ObjectSet.Query<ClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnion.$Identifier[]>> {
    return this.$delegate.classUnionIdentifiers(query);
  }

  classUnions(
    query?: $ObjectSet.Query<ClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnion[]>> {
    return this.$delegate.classUnions(query);
  }

  classUnionsCount(
    query?: Pick<$ObjectSet.Query<ClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.classUnionsCount(query);
  }

  interfaceUnion(
    identifier: InterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnion>> {
    return this.$delegate.interfaceUnion(identifier);
  }

  interfaceUnionIdentifiers(
    query?: $ObjectSet.Query<InterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion.$Identifier[]>> {
    return this.$delegate.interfaceUnionIdentifiers(query);
  }

  interfaceUnions(
    query?: $ObjectSet.Query<InterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion[]>> {
    return this.$delegate.interfaceUnions(query);
  }

  interfaceUnionsCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.interfaceUnionsCount(query);
  }

  interfaceUnionMember2(
    identifier: InterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember2>> {
    return this.$delegate.interfaceUnionMember2(identifier);
  }

  interfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember2.$Identifier[]>
  > {
    return this.$delegate.interfaceUnionMember2Identifiers(query);
  }

  interfaceUnionMember2s(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember2[]>> {
    return this.$delegate.interfaceUnionMember2s(query);
  }

  interfaceUnionMember2sCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember2.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.interfaceUnionMember2sCount(query);
  }

  lazilyResolvedClassUnion(
    identifier: LazilyResolvedClassUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnion>> {
    return this.$delegate.lazilyResolvedClassUnion(identifier);
  }

  lazilyResolvedClassUnionIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnion.$Identifier[]>
  > {
    return this.$delegate.lazilyResolvedClassUnionIdentifiers(query);
  }

  lazilyResolvedClassUnions(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnion[]>> {
    return this.$delegate.lazilyResolvedClassUnions(query);
  }

  lazilyResolvedClassUnionsCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedClassUnionsCount(query);
  }

  lazilyResolvedInterfaceUnion(
    identifier: LazilyResolvedInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnion>> {
    return this.$delegate.lazilyResolvedInterfaceUnion(identifier);
  }

  lazilyResolvedInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnion.$Identifier[]>
  > {
    return this.$delegate.lazilyResolvedInterfaceUnionIdentifiers(query);
  }

  lazilyResolvedInterfaceUnions(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedInterfaceUnion[]>> {
    return this.$delegate.lazilyResolvedInterfaceUnions(query);
  }

  lazilyResolvedInterfaceUnionsCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedInterfaceUnionsCount(query);
  }

  partialClassUnion(
    identifier: PartialClassUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnion>> {
    return this.$delegate.partialClassUnion(identifier);
  }

  partialClassUnionIdentifiers(
    query?: $ObjectSet.Query<PartialClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion.$Identifier[]>> {
    return this.$delegate.partialClassUnionIdentifiers(query);
  }

  partialClassUnions(
    query?: $ObjectSet.Query<PartialClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion[]>> {
    return this.$delegate.partialClassUnions(query);
  }

  partialClassUnionsCount(
    query?: Pick<$ObjectSet.Query<PartialClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialClassUnionsCount(query);
  }

  partialInterfaceUnion(
    identifier: PartialInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnion>> {
    return this.$delegate.partialInterfaceUnion(identifier);
  }

  partialInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnion.$Identifier[]>
  > {
    return this.$delegate.partialInterfaceUnionIdentifiers(query);
  }

  partialInterfaceUnions(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnion[]>> {
    return this.$delegate.partialInterfaceUnions(query);
  }

  partialInterfaceUnionsCount(
    query?: Pick<$ObjectSet.Query<PartialInterfaceUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialInterfaceUnionsCount(query);
  }

  recursiveClassUnion(
    identifier: RecursiveClassUnion.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnion>> {
    return this.$delegate.recursiveClassUnion(identifier);
  }

  recursiveClassUnionIdentifiers(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion.$Identifier[]>> {
    return this.$delegate.recursiveClassUnionIdentifiers(query);
  }

  recursiveClassUnions(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion[]>> {
    return this.$delegate.recursiveClassUnions(query);
  }

  recursiveClassUnionsCount(
    query?: Pick<$ObjectSet.Query<RecursiveClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.recursiveClassUnionsCount(query);
  }
}

export class $RdfjsDatasetObjectSet implements $ObjectSet {
  readonly resourceSet: rdfjsResource.ResourceSet;

  constructor({ dataset }: { dataset: rdfjs.DatasetCore }) {
    this.resourceSet = new rdfjsResource.ResourceSet({ dataset });
  }

  async baseInterfaceWithoutProperties(
    identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithoutProperties>> {
    return this.baseInterfaceWithoutPropertiesSync(identifier);
  }

  baseInterfaceWithoutPropertiesSync(
    identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier,
  ): purify.Either<Error, BaseInterfaceWithoutProperties> {
    return this.baseInterfaceWithoutPropertiesesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async baseInterfaceWithoutPropertiesIdentifiers(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithoutPropertiesStatic.$Identifier[]
    >
  > {
    return this.baseInterfaceWithoutPropertiesIdentifiersSync(query);
  }

  baseInterfaceWithoutPropertiesIdentifiersSync(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
  ): purify.Either<
    Error,
    readonly BaseInterfaceWithoutPropertiesStatic.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      BaseInterfaceWithoutProperties,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >(
      [
        {
          $fromRdf: BaseInterfaceWithoutPropertiesStatic.$fromRdf,
          $fromRdfTypes: [
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async baseInterfaceWithoutPropertieses(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithoutProperties[]>> {
    return this.baseInterfaceWithoutPropertiesesSync(query);
  }

  baseInterfaceWithoutPropertiesesSync(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
  ): purify.Either<Error, readonly BaseInterfaceWithoutProperties[]> {
    return this.$objectsSync<
      BaseInterfaceWithoutProperties,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >(
      [
        {
          $fromRdf: BaseInterfaceWithoutPropertiesStatic.$fromRdf,
          $fromRdfTypes: [
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async baseInterfaceWithoutPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.baseInterfaceWithoutPropertiesesCountSync(query);
  }

  baseInterfaceWithoutPropertiesesCountSync(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      BaseInterfaceWithoutProperties,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >(
      [
        {
          $fromRdf: BaseInterfaceWithoutPropertiesStatic.$fromRdf,
          $fromRdfTypes: [
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async baseInterfaceWithProperties(
    identifier: BaseInterfaceWithPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithProperties>> {
    return this.baseInterfaceWithPropertiesSync(identifier);
  }

  baseInterfaceWithPropertiesSync(
    identifier: BaseInterfaceWithPropertiesStatic.$Identifier,
  ): purify.Either<Error, BaseInterfaceWithProperties> {
    return this.baseInterfaceWithPropertiesesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async baseInterfaceWithPropertiesIdentifiers(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithPropertiesStatic.$Identifier[]
    >
  > {
    return this.baseInterfaceWithPropertiesIdentifiersSync(query);
  }

  baseInterfaceWithPropertiesIdentifiersSync(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
  ): purify.Either<
    Error,
    readonly BaseInterfaceWithPropertiesStatic.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      BaseInterfaceWithProperties,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >(
      [
        {
          $fromRdf: BaseInterfaceWithPropertiesStatic.$fromRdf,
          $fromRdfTypes: [
            BaseInterfaceWithPropertiesStatic.$fromRdfType,
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async baseInterfaceWithPropertieses(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithProperties[]>> {
    return this.baseInterfaceWithPropertiesesSync(query);
  }

  baseInterfaceWithPropertiesesSync(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
  ): purify.Either<Error, readonly BaseInterfaceWithProperties[]> {
    return this.$objectsSync<
      BaseInterfaceWithProperties,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >(
      [
        {
          $fromRdf: BaseInterfaceWithPropertiesStatic.$fromRdf,
          $fromRdfTypes: [
            BaseInterfaceWithPropertiesStatic.$fromRdfType,
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async baseInterfaceWithPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.baseInterfaceWithPropertiesesCountSync(query);
  }

  baseInterfaceWithPropertiesesCountSync(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      BaseInterfaceWithProperties,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >(
      [
        {
          $fromRdf: BaseInterfaceWithPropertiesStatic.$fromRdf,
          $fromRdfTypes: [
            BaseInterfaceWithPropertiesStatic.$fromRdfType,
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async blankClass(
    identifier: BlankClass.$Identifier,
  ): Promise<purify.Either<Error, BlankClass>> {
    return this.blankClassSync(identifier);
  }

  blankClassSync(
    identifier: BlankClass.$Identifier,
  ): purify.Either<Error, BlankClass> {
    return this.blankClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async blankClassIdentifiers(
    query?: $ObjectSet.Query<BlankClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankClass.$Identifier[]>> {
    return this.blankClassIdentifiersSync(query);
  }

  blankClassIdentifiersSync(
    query?: $ObjectSet.Query<BlankClass.$Identifier>,
  ): purify.Either<Error, readonly BlankClass.$Identifier[]> {
    return this.$objectIdentifiersSync<BlankClass, BlankClass.$Identifier>(
      [
        {
          $fromRdf: BlankClass.$fromRdf,
          $fromRdfTypes: [BlankClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async blankClasses(
    query?: $ObjectSet.Query<BlankClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankClass[]>> {
    return this.blankClassesSync(query);
  }

  blankClassesSync(
    query?: $ObjectSet.Query<BlankClass.$Identifier>,
  ): purify.Either<Error, readonly BlankClass[]> {
    return this.$objectsSync<BlankClass, BlankClass.$Identifier>(
      [
        {
          $fromRdf: BlankClass.$fromRdf,
          $fromRdfTypes: [BlankClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async blankClassesCount(
    query?: Pick<$ObjectSet.Query<BlankClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.blankClassesCountSync(query);
  }

  blankClassesCountSync(
    query?: Pick<$ObjectSet.Query<BlankClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<BlankClass, BlankClass.$Identifier>(
      [
        {
          $fromRdf: BlankClass.$fromRdf,
          $fromRdfTypes: [BlankClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async blankInterface(
    identifier: BlankInterface.$Identifier,
  ): Promise<purify.Either<Error, BlankInterface>> {
    return this.blankInterfaceSync(identifier);
  }

  blankInterfaceSync(
    identifier: BlankInterface.$Identifier,
  ): purify.Either<Error, BlankInterface> {
    return this.blankInterfacesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async blankInterfaceIdentifiers(
    query?: $ObjectSet.Query<BlankInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankInterface.$Identifier[]>> {
    return this.blankInterfaceIdentifiersSync(query);
  }

  blankInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<BlankInterface.$Identifier>,
  ): purify.Either<Error, readonly BlankInterface.$Identifier[]> {
    return this.$objectIdentifiersSync<
      BlankInterface,
      BlankInterface.$Identifier
    >([{ $fromRdf: BlankInterface.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async blankInterfaces(
    query?: $ObjectSet.Query<BlankInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankInterface[]>> {
    return this.blankInterfacesSync(query);
  }

  blankInterfacesSync(
    query?: $ObjectSet.Query<BlankInterface.$Identifier>,
  ): purify.Either<Error, readonly BlankInterface[]> {
    return this.$objectsSync<BlankInterface, BlankInterface.$Identifier>(
      [{ $fromRdf: BlankInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async blankInterfacesCount(
    query?: Pick<$ObjectSet.Query<BlankInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.blankInterfacesCountSync(query);
  }

  blankInterfacesCountSync(
    query?: Pick<$ObjectSet.Query<BlankInterface.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<BlankInterface, BlankInterface.$Identifier>(
      [{ $fromRdf: BlankInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async classUnionMember1(
    identifier: ClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember1>> {
    return this.classUnionMember1Sync(identifier);
  }

  classUnionMember1Sync(
    identifier: ClassUnionMember1.$Identifier,
  ): purify.Either<Error, ClassUnionMember1> {
    return this.classUnionMember1sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async classUnionMember1Identifiers(
    query?: $ObjectSet.Query<ClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1.$Identifier[]>> {
    return this.classUnionMember1IdentifiersSync(query);
  }

  classUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<ClassUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly ClassUnionMember1.$Identifier[]> {
    return this.$objectIdentifiersSync<
      ClassUnionMember1,
      ClassUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: ClassUnionMember1.$fromRdf,
          $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async classUnionMember1s(
    query?: $ObjectSet.Query<ClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1[]>> {
    return this.classUnionMember1sSync(query);
  }

  classUnionMember1sSync(
    query?: $ObjectSet.Query<ClassUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly ClassUnionMember1[]> {
    return this.$objectsSync<ClassUnionMember1, ClassUnionMember1.$Identifier>(
      [
        {
          $fromRdf: ClassUnionMember1.$fromRdf,
          $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async classUnionMember1sCount(
    query?: Pick<$ObjectSet.Query<ClassUnionMember1.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.classUnionMember1sCountSync(query);
  }

  classUnionMember1sCountSync(
    query?: Pick<$ObjectSet.Query<ClassUnionMember1.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ClassUnionMember1,
      ClassUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: ClassUnionMember1.$fromRdf,
          $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async classUnionMember2(
    identifier: ClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember2>> {
    return this.classUnionMember2Sync(identifier);
  }

  classUnionMember2Sync(
    identifier: ClassUnionMember2.$Identifier,
  ): purify.Either<Error, ClassUnionMember2> {
    return this.classUnionMember2sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async classUnionMember2Identifiers(
    query?: $ObjectSet.Query<ClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2.$Identifier[]>> {
    return this.classUnionMember2IdentifiersSync(query);
  }

  classUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<ClassUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly ClassUnionMember2.$Identifier[]> {
    return this.$objectIdentifiersSync<
      ClassUnionMember2,
      ClassUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: ClassUnionMember2.$fromRdf,
          $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async classUnionMember2s(
    query?: $ObjectSet.Query<ClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2[]>> {
    return this.classUnionMember2sSync(query);
  }

  classUnionMember2sSync(
    query?: $ObjectSet.Query<ClassUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly ClassUnionMember2[]> {
    return this.$objectsSync<ClassUnionMember2, ClassUnionMember2.$Identifier>(
      [
        {
          $fromRdf: ClassUnionMember2.$fromRdf,
          $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async classUnionMember2sCount(
    query?: Pick<$ObjectSet.Query<ClassUnionMember2.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.classUnionMember2sCountSync(query);
  }

  classUnionMember2sCountSync(
    query?: Pick<$ObjectSet.Query<ClassUnionMember2.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ClassUnionMember2,
      ClassUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: ClassUnionMember2.$fromRdf,
          $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async concreteChildClass(
    identifier: ConcreteChildClass.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildClass>> {
    return this.concreteChildClassSync(identifier);
  }

  concreteChildClassSync(
    identifier: ConcreteChildClass.$Identifier,
  ): purify.Either<Error, ConcreteChildClass> {
    return this.concreteChildClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async concreteChildClassIdentifiers(
    query?: $ObjectSet.Query<ConcreteChildClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass.$Identifier[]>> {
    return this.concreteChildClassIdentifiersSync(query);
  }

  concreteChildClassIdentifiersSync(
    query?: $ObjectSet.Query<ConcreteChildClass.$Identifier>,
  ): purify.Either<Error, readonly ConcreteChildClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      ConcreteChildClass,
      ConcreteChildClass.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteChildClass.$fromRdf,
          $fromRdfTypes: [ConcreteChildClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async concreteChildClasses(
    query?: $ObjectSet.Query<ConcreteChildClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass[]>> {
    return this.concreteChildClassesSync(query);
  }

  concreteChildClassesSync(
    query?: $ObjectSet.Query<ConcreteChildClass.$Identifier>,
  ): purify.Either<Error, readonly ConcreteChildClass[]> {
    return this.$objectsSync<
      ConcreteChildClass,
      ConcreteChildClass.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteChildClass.$fromRdf,
          $fromRdfTypes: [ConcreteChildClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async concreteChildClassesCount(
    query?: Pick<$ObjectSet.Query<ConcreteChildClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.concreteChildClassesCountSync(query);
  }

  concreteChildClassesCountSync(
    query?: Pick<$ObjectSet.Query<ConcreteChildClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ConcreteChildClass,
      ConcreteChildClass.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteChildClass.$fromRdf,
          $fromRdfTypes: [ConcreteChildClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async concreteChildInterface(
    identifier: ConcreteChildInterface.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildInterface>> {
    return this.concreteChildInterfaceSync(identifier);
  }

  concreteChildInterfaceSync(
    identifier: ConcreteChildInterface.$Identifier,
  ): purify.Either<Error, ConcreteChildInterface> {
    return this.concreteChildInterfacesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async concreteChildInterfaceIdentifiers(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteChildInterface.$Identifier[]>
  > {
    return this.concreteChildInterfaceIdentifiersSync(query);
  }

  concreteChildInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Identifier>,
  ): purify.Either<Error, readonly ConcreteChildInterface.$Identifier[]> {
    return this.$objectIdentifiersSync<
      ConcreteChildInterface,
      ConcreteChildInterface.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteChildInterface.$fromRdf,
          $fromRdfTypes: [ConcreteChildInterface.$fromRdfType],
        },
      ],
      query,
    );
  }

  async concreteChildInterfaces(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildInterface[]>> {
    return this.concreteChildInterfacesSync(query);
  }

  concreteChildInterfacesSync(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Identifier>,
  ): purify.Either<Error, readonly ConcreteChildInterface[]> {
    return this.$objectsSync<
      ConcreteChildInterface,
      ConcreteChildInterface.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteChildInterface.$fromRdf,
          $fromRdfTypes: [ConcreteChildInterface.$fromRdfType],
        },
      ],
      query,
    );
  }

  async concreteChildInterfacesCount(
    query?: Pick<$ObjectSet.Query<ConcreteChildInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.concreteChildInterfacesCountSync(query);
  }

  concreteChildInterfacesCountSync(
    query?: Pick<$ObjectSet.Query<ConcreteChildInterface.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ConcreteChildInterface,
      ConcreteChildInterface.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteChildInterface.$fromRdf,
          $fromRdfTypes: [ConcreteChildInterface.$fromRdfType],
        },
      ],
      query,
    );
  }

  async concreteParentClass(
    identifier: ConcreteParentClassStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentClass>> {
    return this.concreteParentClassSync(identifier);
  }

  concreteParentClassSync(
    identifier: ConcreteParentClassStatic.$Identifier,
  ): purify.Either<Error, ConcreteParentClass> {
    return this.concreteParentClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async concreteParentClassIdentifiers(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentClassStatic.$Identifier[]>
  > {
    return this.concreteParentClassIdentifiersSync(query);
  }

  concreteParentClassIdentifiersSync(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
  ): purify.Either<Error, readonly ConcreteParentClassStatic.$Identifier[]> {
    return this.$objectIdentifiersSync<
      ConcreteParentClass,
      ConcreteParentClassStatic.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteParentClassStatic.$fromRdf,
          $fromRdfTypes: [
            ConcreteParentClassStatic.$fromRdfType,
            ConcreteChildClass.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async concreteParentClasses(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteParentClass[]>> {
    return this.concreteParentClassesSync(query);
  }

  concreteParentClassesSync(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
  ): purify.Either<Error, readonly ConcreteParentClass[]> {
    return this.$objectsSync<
      ConcreteParentClass,
      ConcreteParentClassStatic.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteParentClassStatic.$fromRdf,
          $fromRdfTypes: [
            ConcreteParentClassStatic.$fromRdfType,
            ConcreteChildClass.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async concreteParentClassesCount(
    query?: Pick<
      $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.concreteParentClassesCountSync(query);
  }

  concreteParentClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ConcreteParentClass,
      ConcreteParentClassStatic.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteParentClassStatic.$fromRdf,
          $fromRdfTypes: [
            ConcreteParentClassStatic.$fromRdfType,
            ConcreteChildClass.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async concreteParentInterface(
    identifier: ConcreteParentInterfaceStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentInterface>> {
    return this.concreteParentInterfaceSync(identifier);
  }

  concreteParentInterfaceSync(
    identifier: ConcreteParentInterfaceStatic.$Identifier,
  ): purify.Either<Error, ConcreteParentInterface> {
    return this.concreteParentInterfacesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async concreteParentInterfaceIdentifiers(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentInterfaceStatic.$Identifier[]>
  > {
    return this.concreteParentInterfaceIdentifiersSync(query);
  }

  concreteParentInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
  ): purify.Either<
    Error,
    readonly ConcreteParentInterfaceStatic.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      ConcreteParentInterface,
      ConcreteParentInterfaceStatic.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteParentInterfaceStatic.$fromRdf,
          $fromRdfTypes: [
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async concreteParentInterfaces(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteParentInterface[]>> {
    return this.concreteParentInterfacesSync(query);
  }

  concreteParentInterfacesSync(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
  ): purify.Either<Error, readonly ConcreteParentInterface[]> {
    return this.$objectsSync<
      ConcreteParentInterface,
      ConcreteParentInterfaceStatic.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteParentInterfaceStatic.$fromRdf,
          $fromRdfTypes: [
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async concreteParentInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.concreteParentInterfacesCountSync(query);
  }

  concreteParentInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ConcreteParentInterface,
      ConcreteParentInterfaceStatic.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteParentInterfaceStatic.$fromRdf,
          $fromRdfTypes: [
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async convertibleTypePropertiesClass(
    identifier: ConvertibleTypePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ConvertibleTypePropertiesClass>> {
    return this.convertibleTypePropertiesClassSync(identifier);
  }

  convertibleTypePropertiesClassSync(
    identifier: ConvertibleTypePropertiesClass.$Identifier,
  ): purify.Either<Error, ConvertibleTypePropertiesClass> {
    return this.convertibleTypePropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async convertibleTypePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConvertibleTypePropertiesClass.$Identifier[]>
  > {
    return this.convertibleTypePropertiesClassIdentifiersSync(query);
  }

  convertibleTypePropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
  ): purify.Either<
    Error,
    readonly ConvertibleTypePropertiesClass.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      ConvertibleTypePropertiesClass,
      ConvertibleTypePropertiesClass.$Identifier
    >(
      [
        {
          $fromRdf: ConvertibleTypePropertiesClass.$fromRdf,
          $fromRdfTypes: [ConvertibleTypePropertiesClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async convertibleTypePropertiesClasses(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConvertibleTypePropertiesClass[]>> {
    return this.convertibleTypePropertiesClassesSync(query);
  }

  convertibleTypePropertiesClassesSync(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly ConvertibleTypePropertiesClass[]> {
    return this.$objectsSync<
      ConvertibleTypePropertiesClass,
      ConvertibleTypePropertiesClass.$Identifier
    >(
      [
        {
          $fromRdf: ConvertibleTypePropertiesClass.$fromRdf,
          $fromRdfTypes: [ConvertibleTypePropertiesClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async convertibleTypePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.convertibleTypePropertiesClassesCountSync(query);
  }

  convertibleTypePropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ConvertibleTypePropertiesClass,
      ConvertibleTypePropertiesClass.$Identifier
    >(
      [
        {
          $fromRdf: ConvertibleTypePropertiesClass.$fromRdf,
          $fromRdfTypes: [ConvertibleTypePropertiesClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async defaultValuePropertiesClass(
    identifier: DefaultValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, DefaultValuePropertiesClass>> {
    return this.defaultValuePropertiesClassSync(identifier);
  }

  defaultValuePropertiesClassSync(
    identifier: DefaultValuePropertiesClass.$Identifier,
  ): purify.Either<Error, DefaultValuePropertiesClass> {
    return this.defaultValuePropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async defaultValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly DefaultValuePropertiesClass.$Identifier[]>
  > {
    return this.defaultValuePropertiesClassIdentifiersSync(query);
  }

  defaultValuePropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly DefaultValuePropertiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      DefaultValuePropertiesClass,
      DefaultValuePropertiesClass.$Identifier
    >(
      [{ $fromRdf: DefaultValuePropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async defaultValuePropertiesClasses(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DefaultValuePropertiesClass[]>> {
    return this.defaultValuePropertiesClassesSync(query);
  }

  defaultValuePropertiesClassesSync(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly DefaultValuePropertiesClass[]> {
    return this.$objectsSync<
      DefaultValuePropertiesClass,
      DefaultValuePropertiesClass.$Identifier
    >(
      [{ $fromRdf: DefaultValuePropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async defaultValuePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.defaultValuePropertiesClassesCountSync(query);
  }

  defaultValuePropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      DefaultValuePropertiesClass,
      DefaultValuePropertiesClass.$Identifier
    >(
      [{ $fromRdf: DefaultValuePropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async directRecursiveClass(
    identifier: DirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, DirectRecursiveClass>> {
    return this.directRecursiveClassSync(identifier);
  }

  directRecursiveClassSync(
    identifier: DirectRecursiveClass.$Identifier,
  ): purify.Either<Error, DirectRecursiveClass> {
    return this.directRecursiveClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async directRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly DirectRecursiveClass.$Identifier[]>
  > {
    return this.directRecursiveClassIdentifiersSync(query);
  }

  directRecursiveClassIdentifiersSync(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Identifier>,
  ): purify.Either<Error, readonly DirectRecursiveClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      DirectRecursiveClass,
      DirectRecursiveClass.$Identifier
    >([{ $fromRdf: DirectRecursiveClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async directRecursiveClasses(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DirectRecursiveClass[]>> {
    return this.directRecursiveClassesSync(query);
  }

  directRecursiveClassesSync(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Identifier>,
  ): purify.Either<Error, readonly DirectRecursiveClass[]> {
    return this.$objectsSync<
      DirectRecursiveClass,
      DirectRecursiveClass.$Identifier
    >([{ $fromRdf: DirectRecursiveClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async directRecursiveClassesCount(
    query?: Pick<$ObjectSet.Query<DirectRecursiveClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.directRecursiveClassesCountSync(query);
  }

  directRecursiveClassesCountSync(
    query?: Pick<$ObjectSet.Query<DirectRecursiveClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      DirectRecursiveClass,
      DirectRecursiveClass.$Identifier
    >([{ $fromRdf: DirectRecursiveClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async explicitFromToRdfTypesClass(
    identifier: ExplicitFromToRdfTypesClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitFromToRdfTypesClass>> {
    return this.explicitFromToRdfTypesClassSync(identifier);
  }

  explicitFromToRdfTypesClassSync(
    identifier: ExplicitFromToRdfTypesClass.$Identifier,
  ): purify.Either<Error, ExplicitFromToRdfTypesClass> {
    return this.explicitFromToRdfTypesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async explicitFromToRdfTypesClassIdentifiers(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExplicitFromToRdfTypesClass.$Identifier[]>
  > {
    return this.explicitFromToRdfTypesClassIdentifiersSync(query);
  }

  explicitFromToRdfTypesClassIdentifiersSync(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
  ): purify.Either<Error, readonly ExplicitFromToRdfTypesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      ExplicitFromToRdfTypesClass,
      ExplicitFromToRdfTypesClass.$Identifier
    >(
      [
        {
          $fromRdf: ExplicitFromToRdfTypesClass.$fromRdf,
          $fromRdfTypes: [ExplicitFromToRdfTypesClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async explicitFromToRdfTypesClasses(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExplicitFromToRdfTypesClass[]>> {
    return this.explicitFromToRdfTypesClassesSync(query);
  }

  explicitFromToRdfTypesClassesSync(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
  ): purify.Either<Error, readonly ExplicitFromToRdfTypesClass[]> {
    return this.$objectsSync<
      ExplicitFromToRdfTypesClass,
      ExplicitFromToRdfTypesClass.$Identifier
    >(
      [
        {
          $fromRdf: ExplicitFromToRdfTypesClass.$fromRdf,
          $fromRdfTypes: [ExplicitFromToRdfTypesClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async explicitFromToRdfTypesClassesCount(
    query?: Pick<
      $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.explicitFromToRdfTypesClassesCountSync(query);
  }

  explicitFromToRdfTypesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ExplicitFromToRdfTypesClass,
      ExplicitFromToRdfTypesClass.$Identifier
    >(
      [
        {
          $fromRdf: ExplicitFromToRdfTypesClass.$fromRdf,
          $fromRdfTypes: [ExplicitFromToRdfTypesClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async explicitRdfTypeClass(
    identifier: ExplicitRdfTypeClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitRdfTypeClass>> {
    return this.explicitRdfTypeClassSync(identifier);
  }

  explicitRdfTypeClassSync(
    identifier: ExplicitRdfTypeClass.$Identifier,
  ): purify.Either<Error, ExplicitRdfTypeClass> {
    return this.explicitRdfTypeClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async explicitRdfTypeClassIdentifiers(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExplicitRdfTypeClass.$Identifier[]>
  > {
    return this.explicitRdfTypeClassIdentifiersSync(query);
  }

  explicitRdfTypeClassIdentifiersSync(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
  ): purify.Either<Error, readonly ExplicitRdfTypeClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      ExplicitRdfTypeClass,
      ExplicitRdfTypeClass.$Identifier
    >(
      [
        {
          $fromRdf: ExplicitRdfTypeClass.$fromRdf,
          $fromRdfTypes: [ExplicitRdfTypeClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async explicitRdfTypeClasses(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExplicitRdfTypeClass[]>> {
    return this.explicitRdfTypeClassesSync(query);
  }

  explicitRdfTypeClassesSync(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
  ): purify.Either<Error, readonly ExplicitRdfTypeClass[]> {
    return this.$objectsSync<
      ExplicitRdfTypeClass,
      ExplicitRdfTypeClass.$Identifier
    >(
      [
        {
          $fromRdf: ExplicitRdfTypeClass.$fromRdf,
          $fromRdfTypes: [ExplicitRdfTypeClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async explicitRdfTypeClassesCount(
    query?: Pick<$ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.explicitRdfTypeClassesCountSync(query);
  }

  explicitRdfTypeClassesCountSync(
    query?: Pick<$ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ExplicitRdfTypeClass,
      ExplicitRdfTypeClass.$Identifier
    >(
      [
        {
          $fromRdf: ExplicitRdfTypeClass.$fromRdf,
          $fromRdfTypes: [ExplicitRdfTypeClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async externClassPropertyClass(
    identifier: ExternClassPropertyClass.$Identifier,
  ): Promise<purify.Either<Error, ExternClassPropertyClass>> {
    return this.externClassPropertyClassSync(identifier);
  }

  externClassPropertyClassSync(
    identifier: ExternClassPropertyClass.$Identifier,
  ): purify.Either<Error, ExternClassPropertyClass> {
    return this.externClassPropertyClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async externClassPropertyClassIdentifiers(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExternClassPropertyClass.$Identifier[]>
  > {
    return this.externClassPropertyClassIdentifiersSync(query);
  }

  externClassPropertyClassIdentifiersSync(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
  ): purify.Either<Error, readonly ExternClassPropertyClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      ExternClassPropertyClass,
      ExternClassPropertyClass.$Identifier
    >(
      [{ $fromRdf: ExternClassPropertyClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async externClassPropertyClasses(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExternClassPropertyClass[]>> {
    return this.externClassPropertyClassesSync(query);
  }

  externClassPropertyClassesSync(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
  ): purify.Either<Error, readonly ExternClassPropertyClass[]> {
    return this.$objectsSync<
      ExternClassPropertyClass,
      ExternClassPropertyClass.$Identifier
    >(
      [{ $fromRdf: ExternClassPropertyClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async externClassPropertyClassesCount(
    query?: Pick<
      $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.externClassPropertyClassesCountSync(query);
  }

  externClassPropertyClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ExternClassPropertyClass,
      ExternClassPropertyClass.$Identifier
    >(
      [{ $fromRdf: ExternClassPropertyClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async hasValuePropertiesClass(
    identifier: HasValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, HasValuePropertiesClass>> {
    return this.hasValuePropertiesClassSync(identifier);
  }

  hasValuePropertiesClassSync(
    identifier: HasValuePropertiesClass.$Identifier,
  ): purify.Either<Error, HasValuePropertiesClass> {
    return this.hasValuePropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async hasValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly HasValuePropertiesClass.$Identifier[]>
  > {
    return this.hasValuePropertiesClassIdentifiersSync(query);
  }

  hasValuePropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly HasValuePropertiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      HasValuePropertiesClass,
      HasValuePropertiesClass.$Identifier
    >(
      [{ $fromRdf: HasValuePropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async hasValuePropertiesClasses(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly HasValuePropertiesClass[]>> {
    return this.hasValuePropertiesClassesSync(query);
  }

  hasValuePropertiesClassesSync(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly HasValuePropertiesClass[]> {
    return this.$objectsSync<
      HasValuePropertiesClass,
      HasValuePropertiesClass.$Identifier
    >(
      [{ $fromRdf: HasValuePropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async hasValuePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.hasValuePropertiesClassesCountSync(query);
  }

  hasValuePropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      HasValuePropertiesClass,
      HasValuePropertiesClass.$Identifier
    >(
      [{ $fromRdf: HasValuePropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async indirectRecursiveClass(
    identifier: IndirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveClass>> {
    return this.indirectRecursiveClassSync(identifier);
  }

  indirectRecursiveClassSync(
    identifier: IndirectRecursiveClass.$Identifier,
  ): purify.Either<Error, IndirectRecursiveClass> {
    return this.indirectRecursiveClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async indirectRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveClass.$Identifier[]>
  > {
    return this.indirectRecursiveClassIdentifiersSync(query);
  }

  indirectRecursiveClassIdentifiersSync(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Identifier>,
  ): purify.Either<Error, readonly IndirectRecursiveClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      IndirectRecursiveClass,
      IndirectRecursiveClass.$Identifier
    >(
      [{ $fromRdf: IndirectRecursiveClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async indirectRecursiveClasses(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveClass[]>> {
    return this.indirectRecursiveClassesSync(query);
  }

  indirectRecursiveClassesSync(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Identifier>,
  ): purify.Either<Error, readonly IndirectRecursiveClass[]> {
    return this.$objectsSync<
      IndirectRecursiveClass,
      IndirectRecursiveClass.$Identifier
    >(
      [{ $fromRdf: IndirectRecursiveClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async indirectRecursiveClassesCount(
    query?: Pick<$ObjectSet.Query<IndirectRecursiveClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.indirectRecursiveClassesCountSync(query);
  }

  indirectRecursiveClassesCountSync(
    query?: Pick<$ObjectSet.Query<IndirectRecursiveClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      IndirectRecursiveClass,
      IndirectRecursiveClass.$Identifier
    >(
      [{ $fromRdf: IndirectRecursiveClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async indirectRecursiveHelperClass(
    identifier: IndirectRecursiveHelperClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveHelperClass>> {
    return this.indirectRecursiveHelperClassSync(identifier);
  }

  indirectRecursiveHelperClassSync(
    identifier: IndirectRecursiveHelperClass.$Identifier,
  ): purify.Either<Error, IndirectRecursiveHelperClass> {
    return this.indirectRecursiveHelperClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async indirectRecursiveHelperClassIdentifiers(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveHelperClass.$Identifier[]>
  > {
    return this.indirectRecursiveHelperClassIdentifiersSync(query);
  }

  indirectRecursiveHelperClassIdentifiersSync(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
  ): purify.Either<Error, readonly IndirectRecursiveHelperClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      IndirectRecursiveHelperClass,
      IndirectRecursiveHelperClass.$Identifier
    >(
      [{ $fromRdf: IndirectRecursiveHelperClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async indirectRecursiveHelperClasses(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveHelperClass[]>> {
    return this.indirectRecursiveHelperClassesSync(query);
  }

  indirectRecursiveHelperClassesSync(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
  ): purify.Either<Error, readonly IndirectRecursiveHelperClass[]> {
    return this.$objectsSync<
      IndirectRecursiveHelperClass,
      IndirectRecursiveHelperClass.$Identifier
    >(
      [{ $fromRdf: IndirectRecursiveHelperClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async indirectRecursiveHelperClassesCount(
    query?: Pick<
      $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.indirectRecursiveHelperClassesCountSync(query);
  }

  indirectRecursiveHelperClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      IndirectRecursiveHelperClass,
      IndirectRecursiveHelperClass.$Identifier
    >(
      [{ $fromRdf: IndirectRecursiveHelperClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async inIdentifierClass(
    identifier: InIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, InIdentifierClass>> {
    return this.inIdentifierClassSync(identifier);
  }

  inIdentifierClassSync(
    identifier: InIdentifierClass.$Identifier,
  ): purify.Either<Error, InIdentifierClass> {
    return this.inIdentifierClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async inIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<InIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass.$Identifier[]>> {
    return this.inIdentifierClassIdentifiersSync(query);
  }

  inIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<InIdentifierClass.$Identifier>,
  ): purify.Either<Error, readonly InIdentifierClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      InIdentifierClass,
      InIdentifierClass.$Identifier
    >([{ $fromRdf: InIdentifierClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async inIdentifierClasses(
    query?: $ObjectSet.Query<InIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass[]>> {
    return this.inIdentifierClassesSync(query);
  }

  inIdentifierClassesSync(
    query?: $ObjectSet.Query<InIdentifierClass.$Identifier>,
  ): purify.Either<Error, readonly InIdentifierClass[]> {
    return this.$objectsSync<InIdentifierClass, InIdentifierClass.$Identifier>(
      [{ $fromRdf: InIdentifierClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async inIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<InIdentifierClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.inIdentifierClassesCountSync(query);
  }

  inIdentifierClassesCountSync(
    query?: Pick<$ObjectSet.Query<InIdentifierClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      InIdentifierClass,
      InIdentifierClass.$Identifier
    >([{ $fromRdf: InIdentifierClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async inPropertiesClass(
    identifier: InPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, InPropertiesClass>> {
    return this.inPropertiesClassSync(identifier);
  }

  inPropertiesClassSync(
    identifier: InPropertiesClass.$Identifier,
  ): purify.Either<Error, InPropertiesClass> {
    return this.inPropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async inPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<InPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass.$Identifier[]>> {
    return this.inPropertiesClassIdentifiersSync(query);
  }

  inPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<InPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly InPropertiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      InPropertiesClass,
      InPropertiesClass.$Identifier
    >([{ $fromRdf: InPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async inPropertiesClasses(
    query?: $ObjectSet.Query<InPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass[]>> {
    return this.inPropertiesClassesSync(query);
  }

  inPropertiesClassesSync(
    query?: $ObjectSet.Query<InPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly InPropertiesClass[]> {
    return this.$objectsSync<InPropertiesClass, InPropertiesClass.$Identifier>(
      [{ $fromRdf: InPropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async inPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<InPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.inPropertiesClassesCountSync(query);
  }

  inPropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<InPropertiesClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      InPropertiesClass,
      InPropertiesClass.$Identifier
    >([{ $fromRdf: InPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async interface(
    identifier: Interface.$Identifier,
  ): Promise<purify.Either<Error, Interface>> {
    return this.interfaceSync(identifier);
  }

  interfaceSync(
    identifier: Interface.$Identifier,
  ): purify.Either<Error, Interface> {
    return this.interfacesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async interfaceIdentifiers(
    query?: $ObjectSet.Query<Interface.$Identifier>,
  ): Promise<purify.Either<Error, readonly Interface.$Identifier[]>> {
    return this.interfaceIdentifiersSync(query);
  }

  interfaceIdentifiersSync(
    query?: $ObjectSet.Query<Interface.$Identifier>,
  ): purify.Either<Error, readonly Interface.$Identifier[]> {
    return this.$objectIdentifiersSync<Interface, Interface.$Identifier>(
      [{ $fromRdf: Interface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async interfaces(
    query?: $ObjectSet.Query<Interface.$Identifier>,
  ): Promise<purify.Either<Error, readonly Interface[]>> {
    return this.interfacesSync(query);
  }

  interfacesSync(
    query?: $ObjectSet.Query<Interface.$Identifier>,
  ): purify.Either<Error, readonly Interface[]> {
    return this.$objectsSync<Interface, Interface.$Identifier>(
      [{ $fromRdf: Interface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async interfacesCount(
    query?: Pick<$ObjectSet.Query<Interface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.interfacesCountSync(query);
  }

  interfacesCountSync(
    query?: Pick<$ObjectSet.Query<Interface.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<Interface, Interface.$Identifier>(
      [{ $fromRdf: Interface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async interfaceUnionMember1(
    identifier: InterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember1>> {
    return this.interfaceUnionMember1Sync(identifier);
  }

  interfaceUnionMember1Sync(
    identifier: InterfaceUnionMember1.$Identifier,
  ): purify.Either<Error, InterfaceUnionMember1> {
    return this.interfaceUnionMember1sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async interfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember1.$Identifier[]>
  > {
    return this.interfaceUnionMember1IdentifiersSync(query);
  }

  interfaceUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly InterfaceUnionMember1.$Identifier[]> {
    return this.$objectIdentifiersSync<
      InterfaceUnionMember1,
      InterfaceUnionMember1.$Identifier
    >([{ $fromRdf: InterfaceUnionMember1.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async interfaceUnionMember1s(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember1[]>> {
    return this.interfaceUnionMember1sSync(query);
  }

  interfaceUnionMember1sSync(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly InterfaceUnionMember1[]> {
    return this.$objectsSync<
      InterfaceUnionMember1,
      InterfaceUnionMember1.$Identifier
    >([{ $fromRdf: InterfaceUnionMember1.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async interfaceUnionMember1sCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember1.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.interfaceUnionMember1sCountSync(query);
  }

  interfaceUnionMember1sCountSync(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember1.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      InterfaceUnionMember1,
      InterfaceUnionMember1.$Identifier
    >([{ $fromRdf: InterfaceUnionMember1.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async interfaceUnionMember2a(
    identifier: InterfaceUnionMember2a.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember2a>> {
    return this.interfaceUnionMember2aSync(identifier);
  }

  interfaceUnionMember2aSync(
    identifier: InterfaceUnionMember2a.$Identifier,
  ): purify.Either<Error, InterfaceUnionMember2a> {
    return this.interfaceUnionMember2asSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async interfaceUnionMember2aIdentifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember2a.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember2a.$Identifier[]>
  > {
    return this.interfaceUnionMember2aIdentifiersSync(query);
  }

  interfaceUnionMember2aIdentifiersSync(
    query?: $ObjectSet.Query<InterfaceUnionMember2a.$Identifier>,
  ): purify.Either<Error, readonly InterfaceUnionMember2a.$Identifier[]> {
    return this.$objectIdentifiersSync<
      InterfaceUnionMember2a,
      InterfaceUnionMember2a.$Identifier
    >(
      [{ $fromRdf: InterfaceUnionMember2a.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async interfaceUnionMember2as(
    query?: $ObjectSet.Query<InterfaceUnionMember2a.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember2a[]>> {
    return this.interfaceUnionMember2asSync(query);
  }

  interfaceUnionMember2asSync(
    query?: $ObjectSet.Query<InterfaceUnionMember2a.$Identifier>,
  ): purify.Either<Error, readonly InterfaceUnionMember2a[]> {
    return this.$objectsSync<
      InterfaceUnionMember2a,
      InterfaceUnionMember2a.$Identifier
    >(
      [{ $fromRdf: InterfaceUnionMember2a.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async interfaceUnionMember2asCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember2a.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.interfaceUnionMember2asCountSync(query);
  }

  interfaceUnionMember2asCountSync(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember2a.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      InterfaceUnionMember2a,
      InterfaceUnionMember2a.$Identifier
    >(
      [{ $fromRdf: InterfaceUnionMember2a.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async interfaceUnionMember2b(
    identifier: InterfaceUnionMember2b.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember2b>> {
    return this.interfaceUnionMember2bSync(identifier);
  }

  interfaceUnionMember2bSync(
    identifier: InterfaceUnionMember2b.$Identifier,
  ): purify.Either<Error, InterfaceUnionMember2b> {
    return this.interfaceUnionMember2bsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async interfaceUnionMember2bIdentifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember2b.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember2b.$Identifier[]>
  > {
    return this.interfaceUnionMember2bIdentifiersSync(query);
  }

  interfaceUnionMember2bIdentifiersSync(
    query?: $ObjectSet.Query<InterfaceUnionMember2b.$Identifier>,
  ): purify.Either<Error, readonly InterfaceUnionMember2b.$Identifier[]> {
    return this.$objectIdentifiersSync<
      InterfaceUnionMember2b,
      InterfaceUnionMember2b.$Identifier
    >(
      [{ $fromRdf: InterfaceUnionMember2b.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async interfaceUnionMember2bs(
    query?: $ObjectSet.Query<InterfaceUnionMember2b.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember2b[]>> {
    return this.interfaceUnionMember2bsSync(query);
  }

  interfaceUnionMember2bsSync(
    query?: $ObjectSet.Query<InterfaceUnionMember2b.$Identifier>,
  ): purify.Either<Error, readonly InterfaceUnionMember2b[]> {
    return this.$objectsSync<
      InterfaceUnionMember2b,
      InterfaceUnionMember2b.$Identifier
    >(
      [{ $fromRdf: InterfaceUnionMember2b.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async interfaceUnionMember2bsCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember2b.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.interfaceUnionMember2bsCountSync(query);
  }

  interfaceUnionMember2bsCountSync(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember2b.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      InterfaceUnionMember2b,
      InterfaceUnionMember2b.$Identifier
    >(
      [{ $fromRdf: InterfaceUnionMember2b.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async iriClass(
    identifier: IriClass.$Identifier,
  ): Promise<purify.Either<Error, IriClass>> {
    return this.iriClassSync(identifier);
  }

  iriClassSync(
    identifier: IriClass.$Identifier,
  ): purify.Either<Error, IriClass> {
    return this.iriClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async iriClassIdentifiers(
    query?: $ObjectSet.Query<IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IriClass.$Identifier[]>> {
    return this.iriClassIdentifiersSync(query);
  }

  iriClassIdentifiersSync(
    query?: $ObjectSet.Query<IriClass.$Identifier>,
  ): purify.Either<Error, readonly IriClass.$Identifier[]> {
    return this.$objectIdentifiersSync<IriClass, IriClass.$Identifier>(
      [{ $fromRdf: IriClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async iriClasses(
    query?: $ObjectSet.Query<IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IriClass[]>> {
    return this.iriClassesSync(query);
  }

  iriClassesSync(
    query?: $ObjectSet.Query<IriClass.$Identifier>,
  ): purify.Either<Error, readonly IriClass[]> {
    return this.$objectsSync<IriClass, IriClass.$Identifier>(
      [{ $fromRdf: IriClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async iriClassesCount(
    query?: Pick<$ObjectSet.Query<IriClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.iriClassesCountSync(query);
  }

  iriClassesCountSync(
    query?: Pick<$ObjectSet.Query<IriClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<IriClass, IriClass.$Identifier>(
      [{ $fromRdf: IriClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async languageInPropertiesClass(
    identifier: LanguageInPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LanguageInPropertiesClass>> {
    return this.languageInPropertiesClassSync(identifier);
  }

  languageInPropertiesClassSync(
    identifier: LanguageInPropertiesClass.$Identifier,
  ): purify.Either<Error, LanguageInPropertiesClass> {
    return this.languageInPropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async languageInPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LanguageInPropertiesClass.$Identifier[]>
  > {
    return this.languageInPropertiesClassIdentifiersSync(query);
  }

  languageInPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly LanguageInPropertiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      LanguageInPropertiesClass,
      LanguageInPropertiesClass.$Identifier
    >(
      [{ $fromRdf: LanguageInPropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async languageInPropertiesClasses(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LanguageInPropertiesClass[]>> {
    return this.languageInPropertiesClassesSync(query);
  }

  languageInPropertiesClassesSync(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly LanguageInPropertiesClass[]> {
    return this.$objectsSync<
      LanguageInPropertiesClass,
      LanguageInPropertiesClass.$Identifier
    >(
      [{ $fromRdf: LanguageInPropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async languageInPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.languageInPropertiesClassesCountSync(query);
  }

  languageInPropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LanguageInPropertiesClass,
      LanguageInPropertiesClass.$Identifier
    >(
      [{ $fromRdf: LanguageInPropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriClass(
    identifier: LazilyResolvedBlankNodeOrIriClass.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedBlankNodeOrIriClass>> {
    return this.lazilyResolvedBlankNodeOrIriClassSync(identifier);
  }

  lazilyResolvedBlankNodeOrIriClassSync(
    identifier: LazilyResolvedBlankNodeOrIriClass.$Identifier,
  ): purify.Either<Error, LazilyResolvedBlankNodeOrIriClass> {
    return this.lazilyResolvedBlankNodeOrIriClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedBlankNodeOrIriClassIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriClass.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriClass.$Identifier[]
    >
  > {
    return this.lazilyResolvedBlankNodeOrIriClassIdentifiersSync(query);
  }

  lazilyResolvedBlankNodeOrIriClassIdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriClass.$Identifier>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedBlankNodeOrIriClass.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      LazilyResolvedBlankNodeOrIriClass,
      LazilyResolvedBlankNodeOrIriClass.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedBlankNodeOrIriClass.$fromRdf,
          $fromRdfTypes: [LazilyResolvedBlankNodeOrIriClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriClasses(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedBlankNodeOrIriClass[]>
  > {
    return this.lazilyResolvedBlankNodeOrIriClassesSync(query);
  }

  lazilyResolvedBlankNodeOrIriClassesSync(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriClass.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedBlankNodeOrIriClass[]> {
    return this.$objectsSync<
      LazilyResolvedBlankNodeOrIriClass,
      LazilyResolvedBlankNodeOrIriClass.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedBlankNodeOrIriClass.$fromRdf,
          $fromRdfTypes: [LazilyResolvedBlankNodeOrIriClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriClassesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedBlankNodeOrIriClassesCountSync(query);
  }

  lazilyResolvedBlankNodeOrIriClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazilyResolvedBlankNodeOrIriClass,
      LazilyResolvedBlankNodeOrIriClass.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedBlankNodeOrIriClass.$fromRdf,
          $fromRdfTypes: [LazilyResolvedBlankNodeOrIriClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriInterface(
    identifier: LazilyResolvedBlankNodeOrIriInterface.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedBlankNodeOrIriInterface>> {
    return this.lazilyResolvedBlankNodeOrIriInterfaceSync(identifier);
  }

  lazilyResolvedBlankNodeOrIriInterfaceSync(
    identifier: LazilyResolvedBlankNodeOrIriInterface.$Identifier,
  ): purify.Either<Error, LazilyResolvedBlankNodeOrIriInterface> {
    return this.lazilyResolvedBlankNodeOrIriInterfacesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedBlankNodeOrIriInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriInterface.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriInterface.$Identifier[]
    >
  > {
    return this.lazilyResolvedBlankNodeOrIriInterfaceIdentifiersSync(query);
  }

  lazilyResolvedBlankNodeOrIriInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriInterface.$Identifier>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedBlankNodeOrIriInterface.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      LazilyResolvedBlankNodeOrIriInterface,
      LazilyResolvedBlankNodeOrIriInterface.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedBlankNodeOrIriInterface.$fromRdf,
          $fromRdfTypes: [LazilyResolvedBlankNodeOrIriInterface.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriInterfaces(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedBlankNodeOrIriInterface[]>
  > {
    return this.lazilyResolvedBlankNodeOrIriInterfacesSync(query);
  }

  lazilyResolvedBlankNodeOrIriInterfacesSync(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriInterface.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedBlankNodeOrIriInterface[]> {
    return this.$objectsSync<
      LazilyResolvedBlankNodeOrIriInterface,
      LazilyResolvedBlankNodeOrIriInterface.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedBlankNodeOrIriInterface.$fromRdf,
          $fromRdfTypes: [LazilyResolvedBlankNodeOrIriInterface.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedBlankNodeOrIriInterfacesCountSync(query);
  }

  lazilyResolvedBlankNodeOrIriInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriInterface.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazilyResolvedBlankNodeOrIriInterface,
      LazilyResolvedBlankNodeOrIriInterface.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedBlankNodeOrIriInterface.$fromRdf,
          $fromRdfTypes: [LazilyResolvedBlankNodeOrIriInterface.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedClassUnionMember1(
    identifier: LazilyResolvedClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember1>> {
    return this.lazilyResolvedClassUnionMember1Sync(identifier);
  }

  lazilyResolvedClassUnionMember1Sync(
    identifier: LazilyResolvedClassUnionMember1.$Identifier,
  ): purify.Either<Error, LazilyResolvedClassUnionMember1> {
    return this.lazilyResolvedClassUnionMember1sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember1.$Identifier[]>
  > {
    return this.lazilyResolvedClassUnionMember1IdentifiersSync(query);
  }

  lazilyResolvedClassUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedClassUnionMember1.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      LazilyResolvedClassUnionMember1,
      LazilyResolvedClassUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedClassUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedClassUnionMember1s(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember1[]>> {
    return this.lazilyResolvedClassUnionMember1sSync(query);
  }

  lazilyResolvedClassUnionMember1sSync(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedClassUnionMember1[]> {
    return this.$objectsSync<
      LazilyResolvedClassUnionMember1,
      LazilyResolvedClassUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedClassUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedClassUnionMember1sCountSync(query);
  }

  lazilyResolvedClassUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazilyResolvedClassUnionMember1,
      LazilyResolvedClassUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedClassUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedClassUnionMember2(
    identifier: LazilyResolvedClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember2>> {
    return this.lazilyResolvedClassUnionMember2Sync(identifier);
  }

  lazilyResolvedClassUnionMember2Sync(
    identifier: LazilyResolvedClassUnionMember2.$Identifier,
  ): purify.Either<Error, LazilyResolvedClassUnionMember2> {
    return this.lazilyResolvedClassUnionMember2sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember2.$Identifier[]>
  > {
    return this.lazilyResolvedClassUnionMember2IdentifiersSync(query);
  }

  lazilyResolvedClassUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedClassUnionMember2.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      LazilyResolvedClassUnionMember2,
      LazilyResolvedClassUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedClassUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedClassUnionMember2s(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember2[]>> {
    return this.lazilyResolvedClassUnionMember2sSync(query);
  }

  lazilyResolvedClassUnionMember2sSync(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedClassUnionMember2[]> {
    return this.$objectsSync<
      LazilyResolvedClassUnionMember2,
      LazilyResolvedClassUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedClassUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedClassUnionMember2sCountSync(query);
  }

  lazilyResolvedClassUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazilyResolvedClassUnionMember2,
      LazilyResolvedClassUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedClassUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember1(
    identifier: LazilyResolvedInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember1>> {
    return this.lazilyResolvedInterfaceUnionMember1Sync(identifier);
  }

  lazilyResolvedInterfaceUnionMember1Sync(
    identifier: LazilyResolvedInterfaceUnionMember1.$Identifier,
  ): purify.Either<Error, LazilyResolvedInterfaceUnionMember1> {
    return this.lazilyResolvedInterfaceUnionMember1sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember1.$Identifier[]
    >
  > {
    return this.lazilyResolvedInterfaceUnionMember1IdentifiersSync(query);
  }

  lazilyResolvedInterfaceUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedInterfaceUnionMember1.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      LazilyResolvedInterfaceUnionMember1,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember1s(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember1[]>
  > {
    return this.lazilyResolvedInterfaceUnionMember1sSync(query);
  }

  lazilyResolvedInterfaceUnionMember1sSync(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember1[]> {
    return this.$objectsSync<
      LazilyResolvedInterfaceUnionMember1,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedInterfaceUnionMember1sCountSync(query);
  }

  lazilyResolvedInterfaceUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazilyResolvedInterfaceUnionMember1,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember2(
    identifier: LazilyResolvedInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember2>> {
    return this.lazilyResolvedInterfaceUnionMember2Sync(identifier);
  }

  lazilyResolvedInterfaceUnionMember2Sync(
    identifier: LazilyResolvedInterfaceUnionMember2.$Identifier,
  ): purify.Either<Error, LazilyResolvedInterfaceUnionMember2> {
    return this.lazilyResolvedInterfaceUnionMember2sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember2.$Identifier[]
    >
  > {
    return this.lazilyResolvedInterfaceUnionMember2IdentifiersSync(query);
  }

  lazilyResolvedInterfaceUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedInterfaceUnionMember2.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      LazilyResolvedInterfaceUnionMember2,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember2s(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember2[]>
  > {
    return this.lazilyResolvedInterfaceUnionMember2sSync(query);
  }

  lazilyResolvedInterfaceUnionMember2sSync(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember2[]> {
    return this.$objectsSync<
      LazilyResolvedInterfaceUnionMember2,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedInterfaceUnionMember2sCountSync(query);
  }

  lazilyResolvedInterfaceUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazilyResolvedInterfaceUnionMember2,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedIriClass(
    identifier: LazilyResolvedIriClass.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriClass>> {
    return this.lazilyResolvedIriClassSync(identifier);
  }

  lazilyResolvedIriClassSync(
    identifier: LazilyResolvedIriClass.$Identifier,
  ): purify.Either<Error, LazilyResolvedIriClass> {
    return this.lazilyResolvedIriClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedIriClassIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedIriClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriClass.$Identifier[]>
  > {
    return this.lazilyResolvedIriClassIdentifiersSync(query);
  }

  lazilyResolvedIriClassIdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedIriClass.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedIriClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      LazilyResolvedIriClass,
      LazilyResolvedIriClass.$Identifier
    >(
      [{ $fromRdf: LazilyResolvedIriClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async lazilyResolvedIriClasses(
    query?: $ObjectSet.Query<LazilyResolvedIriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedIriClass[]>> {
    return this.lazilyResolvedIriClassesSync(query);
  }

  lazilyResolvedIriClassesSync(
    query?: $ObjectSet.Query<LazilyResolvedIriClass.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedIriClass[]> {
    return this.$objectsSync<
      LazilyResolvedIriClass,
      LazilyResolvedIriClass.$Identifier
    >(
      [{ $fromRdf: LazilyResolvedIriClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async lazilyResolvedIriClassesCount(
    query?: Pick<$ObjectSet.Query<LazilyResolvedIriClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedIriClassesCountSync(query);
  }

  lazilyResolvedIriClassesCountSync(
    query?: Pick<$ObjectSet.Query<LazilyResolvedIriClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazilyResolvedIriClass,
      LazilyResolvedIriClass.$Identifier
    >(
      [{ $fromRdf: LazilyResolvedIriClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async lazilyResolvedIriInterface(
    identifier: LazilyResolvedIriInterface.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriInterface>> {
    return this.lazilyResolvedIriInterfaceSync(identifier);
  }

  lazilyResolvedIriInterfaceSync(
    identifier: LazilyResolvedIriInterface.$Identifier,
  ): purify.Either<Error, LazilyResolvedIriInterface> {
    return this.lazilyResolvedIriInterfacesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedIriInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedIriInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriInterface.$Identifier[]>
  > {
    return this.lazilyResolvedIriInterfaceIdentifiersSync(query);
  }

  lazilyResolvedIriInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedIriInterface.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedIriInterface.$Identifier[]> {
    return this.$objectIdentifiersSync<
      LazilyResolvedIriInterface,
      LazilyResolvedIriInterface.$Identifier
    >(
      [{ $fromRdf: LazilyResolvedIriInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async lazilyResolvedIriInterfaces(
    query?: $ObjectSet.Query<LazilyResolvedIriInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedIriInterface[]>> {
    return this.lazilyResolvedIriInterfacesSync(query);
  }

  lazilyResolvedIriInterfacesSync(
    query?: $ObjectSet.Query<LazilyResolvedIriInterface.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedIriInterface[]> {
    return this.$objectsSync<
      LazilyResolvedIriInterface,
      LazilyResolvedIriInterface.$Identifier
    >(
      [{ $fromRdf: LazilyResolvedIriInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async lazilyResolvedIriInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedIriInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedIriInterfacesCountSync(query);
  }

  lazilyResolvedIriInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedIriInterface.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazilyResolvedIriInterface,
      LazilyResolvedIriInterface.$Identifier
    >(
      [{ $fromRdf: LazilyResolvedIriInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async lazyPropertiesClass(
    identifier: LazyPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesClass>> {
    return this.lazyPropertiesClassSync(identifier);
  }

  lazyPropertiesClassSync(
    identifier: LazyPropertiesClass.$Identifier,
  ): purify.Either<Error, LazyPropertiesClass> {
    return this.lazyPropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazyPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass.$Identifier[]>> {
    return this.lazyPropertiesClassIdentifiersSync(query);
  }

  lazyPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly LazyPropertiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      LazyPropertiesClass,
      LazyPropertiesClass.$Identifier
    >([{ $fromRdf: LazyPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async lazyPropertiesClasses(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass[]>> {
    return this.lazyPropertiesClassesSync(query);
  }

  lazyPropertiesClassesSync(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly LazyPropertiesClass[]> {
    return this.$objectsSync<
      LazyPropertiesClass,
      LazyPropertiesClass.$Identifier
    >([{ $fromRdf: LazyPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async lazyPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<LazyPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.lazyPropertiesClassesCountSync(query);
  }

  lazyPropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<LazyPropertiesClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazyPropertiesClass,
      LazyPropertiesClass.$Identifier
    >([{ $fromRdf: LazyPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async lazyPropertiesInterface(
    identifier: LazyPropertiesInterface.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesInterface>> {
    return this.lazyPropertiesInterfaceSync(identifier);
  }

  lazyPropertiesInterfaceSync(
    identifier: LazyPropertiesInterface.$Identifier,
  ): purify.Either<Error, LazyPropertiesInterface> {
    return this.lazyPropertiesInterfacesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazyPropertiesInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazyPropertiesInterface.$Identifier[]>
  > {
    return this.lazyPropertiesInterfaceIdentifiersSync(query);
  }

  lazyPropertiesInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
  ): purify.Either<Error, readonly LazyPropertiesInterface.$Identifier[]> {
    return this.$objectIdentifiersSync<
      LazyPropertiesInterface,
      LazyPropertiesInterface.$Identifier
    >(
      [{ $fromRdf: LazyPropertiesInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async lazyPropertiesInterfaces(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesInterface[]>> {
    return this.lazyPropertiesInterfacesSync(query);
  }

  lazyPropertiesInterfacesSync(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
  ): purify.Either<Error, readonly LazyPropertiesInterface[]> {
    return this.$objectsSync<
      LazyPropertiesInterface,
      LazyPropertiesInterface.$Identifier
    >(
      [{ $fromRdf: LazyPropertiesInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async lazyPropertiesInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazyPropertiesInterfacesCountSync(query);
  }

  lazyPropertiesInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazyPropertiesInterface,
      LazyPropertiesInterface.$Identifier
    >(
      [{ $fromRdf: LazyPropertiesInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async listPropertiesClass(
    identifier: ListPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ListPropertiesClass>> {
    return this.listPropertiesClassSync(identifier);
  }

  listPropertiesClassSync(
    identifier: ListPropertiesClass.$Identifier,
  ): purify.Either<Error, ListPropertiesClass> {
    return this.listPropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async listPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<ListPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass.$Identifier[]>> {
    return this.listPropertiesClassIdentifiersSync(query);
  }

  listPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<ListPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly ListPropertiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      ListPropertiesClass,
      ListPropertiesClass.$Identifier
    >([{ $fromRdf: ListPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async listPropertiesClasses(
    query?: $ObjectSet.Query<ListPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass[]>> {
    return this.listPropertiesClassesSync(query);
  }

  listPropertiesClassesSync(
    query?: $ObjectSet.Query<ListPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly ListPropertiesClass[]> {
    return this.$objectsSync<
      ListPropertiesClass,
      ListPropertiesClass.$Identifier
    >([{ $fromRdf: ListPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async listPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<ListPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.listPropertiesClassesCountSync(query);
  }

  listPropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<ListPropertiesClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ListPropertiesClass,
      ListPropertiesClass.$Identifier
    >([{ $fromRdf: ListPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async mutablePropertiesClass(
    identifier: MutablePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, MutablePropertiesClass>> {
    return this.mutablePropertiesClassSync(identifier);
  }

  mutablePropertiesClassSync(
    identifier: MutablePropertiesClass.$Identifier,
  ): purify.Either<Error, MutablePropertiesClass> {
    return this.mutablePropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async mutablePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly MutablePropertiesClass.$Identifier[]>
  > {
    return this.mutablePropertiesClassIdentifiersSync(query);
  }

  mutablePropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly MutablePropertiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      MutablePropertiesClass,
      MutablePropertiesClass.$Identifier
    >(
      [{ $fromRdf: MutablePropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async mutablePropertiesClasses(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly MutablePropertiesClass[]>> {
    return this.mutablePropertiesClassesSync(query);
  }

  mutablePropertiesClassesSync(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly MutablePropertiesClass[]> {
    return this.$objectsSync<
      MutablePropertiesClass,
      MutablePropertiesClass.$Identifier
    >(
      [{ $fromRdf: MutablePropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async mutablePropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<MutablePropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.mutablePropertiesClassesCountSync(query);
  }

  mutablePropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<MutablePropertiesClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      MutablePropertiesClass,
      MutablePropertiesClass.$Identifier
    >(
      [{ $fromRdf: MutablePropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async narrowedIdentifierClass(
    identifier: NarrowedIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, NarrowedIdentifierClass>> {
    return this.narrowedIdentifierClassSync(identifier);
  }

  narrowedIdentifierClassSync(
    identifier: NarrowedIdentifierClass.$Identifier,
  ): purify.Either<Error, NarrowedIdentifierClass> {
    return this.narrowedIdentifierClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async narrowedIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<NarrowedIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly NarrowedIdentifierClass.$Identifier[]>
  > {
    return this.narrowedIdentifierClassIdentifiersSync(query);
  }

  narrowedIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<NarrowedIdentifierClass.$Identifier>,
  ): purify.Either<Error, readonly NarrowedIdentifierClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      NarrowedIdentifierClass,
      NarrowedIdentifierClass.$Identifier
    >(
      [
        {
          $fromRdf: NarrowedIdentifierClass.$fromRdf,
          $fromRdfTypes: [NarrowedIdentifierClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async narrowedIdentifierClasses(
    query?: $ObjectSet.Query<NarrowedIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly NarrowedIdentifierClass[]>> {
    return this.narrowedIdentifierClassesSync(query);
  }

  narrowedIdentifierClassesSync(
    query?: $ObjectSet.Query<NarrowedIdentifierClass.$Identifier>,
  ): purify.Either<Error, readonly NarrowedIdentifierClass[]> {
    return this.$objectsSync<
      NarrowedIdentifierClass,
      NarrowedIdentifierClass.$Identifier
    >(
      [
        {
          $fromRdf: NarrowedIdentifierClass.$fromRdf,
          $fromRdfTypes: [NarrowedIdentifierClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async narrowedIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<NarrowedIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.narrowedIdentifierClassesCountSync(query);
  }

  narrowedIdentifierClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<NarrowedIdentifierClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      NarrowedIdentifierClass,
      NarrowedIdentifierClass.$Identifier
    >(
      [
        {
          $fromRdf: NarrowedIdentifierClass.$fromRdf,
          $fromRdfTypes: [NarrowedIdentifierClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async nonClass(
    identifier: NonClass.$Identifier,
  ): Promise<purify.Either<Error, NonClass>> {
    return this.nonClassSync(identifier);
  }

  nonClassSync(
    identifier: NonClass.$Identifier,
  ): purify.Either<Error, NonClass> {
    return this.nonClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async nonClassIdentifiers(
    query?: $ObjectSet.Query<NonClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly NonClass.$Identifier[]>> {
    return this.nonClassIdentifiersSync(query);
  }

  nonClassIdentifiersSync(
    query?: $ObjectSet.Query<NonClass.$Identifier>,
  ): purify.Either<Error, readonly NonClass.$Identifier[]> {
    return this.$objectIdentifiersSync<NonClass, NonClass.$Identifier>(
      [{ $fromRdf: NonClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async nonClasses(
    query?: $ObjectSet.Query<NonClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly NonClass[]>> {
    return this.nonClassesSync(query);
  }

  nonClassesSync(
    query?: $ObjectSet.Query<NonClass.$Identifier>,
  ): purify.Either<Error, readonly NonClass[]> {
    return this.$objectsSync<NonClass, NonClass.$Identifier>(
      [{ $fromRdf: NonClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async nonClassesCount(
    query?: Pick<$ObjectSet.Query<NonClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.nonClassesCountSync(query);
  }

  nonClassesCountSync(
    query?: Pick<$ObjectSet.Query<NonClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<NonClass, NonClass.$Identifier>(
      [{ $fromRdf: NonClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async orderedPropertiesClass(
    identifier: OrderedPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, OrderedPropertiesClass>> {
    return this.orderedPropertiesClassSync(identifier);
  }

  orderedPropertiesClassSync(
    identifier: OrderedPropertiesClass.$Identifier,
  ): purify.Either<Error, OrderedPropertiesClass> {
    return this.orderedPropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async orderedPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly OrderedPropertiesClass.$Identifier[]>
  > {
    return this.orderedPropertiesClassIdentifiersSync(query);
  }

  orderedPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly OrderedPropertiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      OrderedPropertiesClass,
      OrderedPropertiesClass.$Identifier
    >(
      [{ $fromRdf: OrderedPropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async orderedPropertiesClasses(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly OrderedPropertiesClass[]>> {
    return this.orderedPropertiesClassesSync(query);
  }

  orderedPropertiesClassesSync(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly OrderedPropertiesClass[]> {
    return this.$objectsSync<
      OrderedPropertiesClass,
      OrderedPropertiesClass.$Identifier
    >(
      [{ $fromRdf: OrderedPropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async orderedPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<OrderedPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.orderedPropertiesClassesCountSync(query);
  }

  orderedPropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<OrderedPropertiesClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      OrderedPropertiesClass,
      OrderedPropertiesClass.$Identifier
    >(
      [{ $fromRdf: OrderedPropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async partialClass(
    identifier: PartialClass.$Identifier,
  ): Promise<purify.Either<Error, PartialClass>> {
    return this.partialClassSync(identifier);
  }

  partialClassSync(
    identifier: PartialClass.$Identifier,
  ): purify.Either<Error, PartialClass> {
    return this.partialClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async partialClassIdentifiers(
    query?: $ObjectSet.Query<PartialClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClass.$Identifier[]>> {
    return this.partialClassIdentifiersSync(query);
  }

  partialClassIdentifiersSync(
    query?: $ObjectSet.Query<PartialClass.$Identifier>,
  ): purify.Either<Error, readonly PartialClass.$Identifier[]> {
    return this.$objectIdentifiersSync<PartialClass, PartialClass.$Identifier>(
      [{ $fromRdf: PartialClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async partialClasses(
    query?: $ObjectSet.Query<PartialClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClass[]>> {
    return this.partialClassesSync(query);
  }

  partialClassesSync(
    query?: $ObjectSet.Query<PartialClass.$Identifier>,
  ): purify.Either<Error, readonly PartialClass[]> {
    return this.$objectsSync<PartialClass, PartialClass.$Identifier>(
      [{ $fromRdf: PartialClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async partialClassesCount(
    query?: Pick<$ObjectSet.Query<PartialClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.partialClassesCountSync(query);
  }

  partialClassesCountSync(
    query?: Pick<$ObjectSet.Query<PartialClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<PartialClass, PartialClass.$Identifier>(
      [{ $fromRdf: PartialClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async partialClassUnionMember1(
    identifier: PartialClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember1>> {
    return this.partialClassUnionMember1Sync(identifier);
  }

  partialClassUnionMember1Sync(
    identifier: PartialClassUnionMember1.$Identifier,
  ): purify.Either<Error, PartialClassUnionMember1> {
    return this.partialClassUnionMember1sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async partialClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember1.$Identifier[]>
  > {
    return this.partialClassUnionMember1IdentifiersSync(query);
  }

  partialClassUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly PartialClassUnionMember1.$Identifier[]> {
    return this.$objectIdentifiersSync<
      PartialClassUnionMember1,
      PartialClassUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: PartialClassUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialClassUnionMember1s(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember1[]>> {
    return this.partialClassUnionMember1sSync(query);
  }

  partialClassUnionMember1sSync(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly PartialClassUnionMember1[]> {
    return this.$objectsSync<
      PartialClassUnionMember1,
      PartialClassUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: PartialClassUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.partialClassUnionMember1sCountSync(query);
  }

  partialClassUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PartialClassUnionMember1,
      PartialClassUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: PartialClassUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialClassUnionMember2(
    identifier: PartialClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember2>> {
    return this.partialClassUnionMember2Sync(identifier);
  }

  partialClassUnionMember2Sync(
    identifier: PartialClassUnionMember2.$Identifier,
  ): purify.Either<Error, PartialClassUnionMember2> {
    return this.partialClassUnionMember2sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async partialClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember2.$Identifier[]>
  > {
    return this.partialClassUnionMember2IdentifiersSync(query);
  }

  partialClassUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly PartialClassUnionMember2.$Identifier[]> {
    return this.$objectIdentifiersSync<
      PartialClassUnionMember2,
      PartialClassUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: PartialClassUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialClassUnionMember2s(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember2[]>> {
    return this.partialClassUnionMember2sSync(query);
  }

  partialClassUnionMember2sSync(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly PartialClassUnionMember2[]> {
    return this.$objectsSync<
      PartialClassUnionMember2,
      PartialClassUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: PartialClassUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.partialClassUnionMember2sCountSync(query);
  }

  partialClassUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PartialClassUnionMember2,
      PartialClassUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: PartialClassUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialInterface(
    identifier: PartialInterface.$Identifier,
  ): Promise<purify.Either<Error, PartialInterface>> {
    return this.partialInterfaceSync(identifier);
  }

  partialInterfaceSync(
    identifier: PartialInterface.$Identifier,
  ): purify.Either<Error, PartialInterface> {
    return this.partialInterfacesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async partialInterfaceIdentifiers(
    query?: $ObjectSet.Query<PartialInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterface.$Identifier[]>> {
    return this.partialInterfaceIdentifiersSync(query);
  }

  partialInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<PartialInterface.$Identifier>,
  ): purify.Either<Error, readonly PartialInterface.$Identifier[]> {
    return this.$objectIdentifiersSync<
      PartialInterface,
      PartialInterface.$Identifier
    >([{ $fromRdf: PartialInterface.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async partialInterfaces(
    query?: $ObjectSet.Query<PartialInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterface[]>> {
    return this.partialInterfacesSync(query);
  }

  partialInterfacesSync(
    query?: $ObjectSet.Query<PartialInterface.$Identifier>,
  ): purify.Either<Error, readonly PartialInterface[]> {
    return this.$objectsSync<PartialInterface, PartialInterface.$Identifier>(
      [{ $fromRdf: PartialInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async partialInterfacesCount(
    query?: Pick<$ObjectSet.Query<PartialInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.partialInterfacesCountSync(query);
  }

  partialInterfacesCountSync(
    query?: Pick<$ObjectSet.Query<PartialInterface.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PartialInterface,
      PartialInterface.$Identifier
    >([{ $fromRdf: PartialInterface.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async partialInterfaceUnionMember1(
    identifier: PartialInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember1>> {
    return this.partialInterfaceUnionMember1Sync(identifier);
  }

  partialInterfaceUnionMember1Sync(
    identifier: PartialInterfaceUnionMember1.$Identifier,
  ): purify.Either<Error, PartialInterfaceUnionMember1> {
    return this.partialInterfaceUnionMember1sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async partialInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember1.$Identifier[]>
  > {
    return this.partialInterfaceUnionMember1IdentifiersSync(query);
  }

  partialInterfaceUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly PartialInterfaceUnionMember1.$Identifier[]> {
    return this.$objectIdentifiersSync<
      PartialInterfaceUnionMember1,
      PartialInterfaceUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: PartialInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialInterfaceUnionMember1s(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember1[]>> {
    return this.partialInterfaceUnionMember1sSync(query);
  }

  partialInterfaceUnionMember1sSync(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly PartialInterfaceUnionMember1[]> {
    return this.$objectsSync<
      PartialInterfaceUnionMember1,
      PartialInterfaceUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: PartialInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.partialInterfaceUnionMember1sCountSync(query);
  }

  partialInterfaceUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PartialInterfaceUnionMember1,
      PartialInterfaceUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: PartialInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialInterfaceUnionMember2(
    identifier: PartialInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember2>> {
    return this.partialInterfaceUnionMember2Sync(identifier);
  }

  partialInterfaceUnionMember2Sync(
    identifier: PartialInterfaceUnionMember2.$Identifier,
  ): purify.Either<Error, PartialInterfaceUnionMember2> {
    return this.partialInterfaceUnionMember2sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async partialInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember2.$Identifier[]>
  > {
    return this.partialInterfaceUnionMember2IdentifiersSync(query);
  }

  partialInterfaceUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly PartialInterfaceUnionMember2.$Identifier[]> {
    return this.$objectIdentifiersSync<
      PartialInterfaceUnionMember2,
      PartialInterfaceUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: PartialInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialInterfaceUnionMember2s(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember2[]>> {
    return this.partialInterfaceUnionMember2sSync(query);
  }

  partialInterfaceUnionMember2sSync(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly PartialInterfaceUnionMember2[]> {
    return this.$objectsSync<
      PartialInterfaceUnionMember2,
      PartialInterfaceUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: PartialInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.partialInterfaceUnionMember2sCountSync(query);
  }

  partialInterfaceUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PartialInterfaceUnionMember2,
      PartialInterfaceUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: PartialInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async propertyCardinalitiesClass(
    identifier: PropertyCardinalitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyCardinalitiesClass>> {
    return this.propertyCardinalitiesClassSync(identifier);
  }

  propertyCardinalitiesClassSync(
    identifier: PropertyCardinalitiesClass.$Identifier,
  ): purify.Either<Error, PropertyCardinalitiesClass> {
    return this.propertyCardinalitiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async propertyCardinalitiesClassIdentifiers(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PropertyCardinalitiesClass.$Identifier[]>
  > {
    return this.propertyCardinalitiesClassIdentifiersSync(query);
  }

  propertyCardinalitiesClassIdentifiersSync(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
  ): purify.Either<Error, readonly PropertyCardinalitiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      PropertyCardinalitiesClass,
      PropertyCardinalitiesClass.$Identifier
    >(
      [{ $fromRdf: PropertyCardinalitiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async propertyCardinalitiesClasses(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PropertyCardinalitiesClass[]>> {
    return this.propertyCardinalitiesClassesSync(query);
  }

  propertyCardinalitiesClassesSync(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
  ): purify.Either<Error, readonly PropertyCardinalitiesClass[]> {
    return this.$objectsSync<
      PropertyCardinalitiesClass,
      PropertyCardinalitiesClass.$Identifier
    >(
      [{ $fromRdf: PropertyCardinalitiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async propertyCardinalitiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.propertyCardinalitiesClassesCountSync(query);
  }

  propertyCardinalitiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PropertyCardinalitiesClass,
      PropertyCardinalitiesClass.$Identifier
    >(
      [{ $fromRdf: PropertyCardinalitiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async propertyVisibilitiesClass(
    identifier: PropertyVisibilitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyVisibilitiesClass>> {
    return this.propertyVisibilitiesClassSync(identifier);
  }

  propertyVisibilitiesClassSync(
    identifier: PropertyVisibilitiesClass.$Identifier,
  ): purify.Either<Error, PropertyVisibilitiesClass> {
    return this.propertyVisibilitiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async propertyVisibilitiesClassIdentifiers(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PropertyVisibilitiesClass.$Identifier[]>
  > {
    return this.propertyVisibilitiesClassIdentifiersSync(query);
  }

  propertyVisibilitiesClassIdentifiersSync(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
  ): purify.Either<Error, readonly PropertyVisibilitiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      PropertyVisibilitiesClass,
      PropertyVisibilitiesClass.$Identifier
    >(
      [{ $fromRdf: PropertyVisibilitiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async propertyVisibilitiesClasses(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PropertyVisibilitiesClass[]>> {
    return this.propertyVisibilitiesClassesSync(query);
  }

  propertyVisibilitiesClassesSync(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
  ): purify.Either<Error, readonly PropertyVisibilitiesClass[]> {
    return this.$objectsSync<
      PropertyVisibilitiesClass,
      PropertyVisibilitiesClass.$Identifier
    >(
      [{ $fromRdf: PropertyVisibilitiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async propertyVisibilitiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.propertyVisibilitiesClassesCountSync(query);
  }

  propertyVisibilitiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PropertyVisibilitiesClass,
      PropertyVisibilitiesClass.$Identifier
    >(
      [{ $fromRdf: PropertyVisibilitiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async recursiveClassUnionMember1(
    identifier: RecursiveClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember1>> {
    return this.recursiveClassUnionMember1Sync(identifier);
  }

  recursiveClassUnionMember1Sync(
    identifier: RecursiveClassUnionMember1.$Identifier,
  ): purify.Either<Error, RecursiveClassUnionMember1> {
    return this.recursiveClassUnionMember1sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async recursiveClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember1.$Identifier[]>
  > {
    return this.recursiveClassUnionMember1IdentifiersSync(query);
  }

  recursiveClassUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly RecursiveClassUnionMember1.$Identifier[]> {
    return this.$objectIdentifiersSync<
      RecursiveClassUnionMember1,
      RecursiveClassUnionMember1.$Identifier
    >(
      [{ $fromRdf: RecursiveClassUnionMember1.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async recursiveClassUnionMember1s(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember1[]>> {
    return this.recursiveClassUnionMember1sSync(query);
  }

  recursiveClassUnionMember1sSync(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly RecursiveClassUnionMember1[]> {
    return this.$objectsSync<
      RecursiveClassUnionMember1,
      RecursiveClassUnionMember1.$Identifier
    >(
      [{ $fromRdf: RecursiveClassUnionMember1.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async recursiveClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.recursiveClassUnionMember1sCountSync(query);
  }

  recursiveClassUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      RecursiveClassUnionMember1,
      RecursiveClassUnionMember1.$Identifier
    >(
      [{ $fromRdf: RecursiveClassUnionMember1.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async recursiveClassUnionMember2(
    identifier: RecursiveClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember2>> {
    return this.recursiveClassUnionMember2Sync(identifier);
  }

  recursiveClassUnionMember2Sync(
    identifier: RecursiveClassUnionMember2.$Identifier,
  ): purify.Either<Error, RecursiveClassUnionMember2> {
    return this.recursiveClassUnionMember2sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async recursiveClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember2.$Identifier[]>
  > {
    return this.recursiveClassUnionMember2IdentifiersSync(query);
  }

  recursiveClassUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly RecursiveClassUnionMember2.$Identifier[]> {
    return this.$objectIdentifiersSync<
      RecursiveClassUnionMember2,
      RecursiveClassUnionMember2.$Identifier
    >(
      [{ $fromRdf: RecursiveClassUnionMember2.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async recursiveClassUnionMember2s(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember2[]>> {
    return this.recursiveClassUnionMember2sSync(query);
  }

  recursiveClassUnionMember2sSync(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly RecursiveClassUnionMember2[]> {
    return this.$objectsSync<
      RecursiveClassUnionMember2,
      RecursiveClassUnionMember2.$Identifier
    >(
      [{ $fromRdf: RecursiveClassUnionMember2.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async recursiveClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.recursiveClassUnionMember2sCountSync(query);
  }

  recursiveClassUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      RecursiveClassUnionMember2,
      RecursiveClassUnionMember2.$Identifier
    >(
      [{ $fromRdf: RecursiveClassUnionMember2.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async sha256IriClass(
    identifier: Sha256IriClass.$Identifier,
  ): Promise<purify.Either<Error, Sha256IriClass>> {
    return this.sha256IriClassSync(identifier);
  }

  sha256IriClassSync(
    identifier: Sha256IriClass.$Identifier,
  ): purify.Either<Error, Sha256IriClass> {
    return this.sha256IriClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async sha256IriClassIdentifiers(
    query?: $ObjectSet.Query<Sha256IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly Sha256IriClass.$Identifier[]>> {
    return this.sha256IriClassIdentifiersSync(query);
  }

  sha256IriClassIdentifiersSync(
    query?: $ObjectSet.Query<Sha256IriClass.$Identifier>,
  ): purify.Either<Error, readonly Sha256IriClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      Sha256IriClass,
      Sha256IriClass.$Identifier
    >([{ $fromRdf: Sha256IriClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async sha256IriClasses(
    query?: $ObjectSet.Query<Sha256IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly Sha256IriClass[]>> {
    return this.sha256IriClassesSync(query);
  }

  sha256IriClassesSync(
    query?: $ObjectSet.Query<Sha256IriClass.$Identifier>,
  ): purify.Either<Error, readonly Sha256IriClass[]> {
    return this.$objectsSync<Sha256IriClass, Sha256IriClass.$Identifier>(
      [{ $fromRdf: Sha256IriClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async sha256IriClassesCount(
    query?: Pick<$ObjectSet.Query<Sha256IriClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.sha256IriClassesCountSync(query);
  }

  sha256IriClassesCountSync(
    query?: Pick<$ObjectSet.Query<Sha256IriClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<Sha256IriClass, Sha256IriClass.$Identifier>(
      [{ $fromRdf: Sha256IriClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async termPropertiesClass(
    identifier: TermPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, TermPropertiesClass>> {
    return this.termPropertiesClassSync(identifier);
  }

  termPropertiesClassSync(
    identifier: TermPropertiesClass.$Identifier,
  ): purify.Either<Error, TermPropertiesClass> {
    return this.termPropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async termPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<TermPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass.$Identifier[]>> {
    return this.termPropertiesClassIdentifiersSync(query);
  }

  termPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<TermPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly TermPropertiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      TermPropertiesClass,
      TermPropertiesClass.$Identifier
    >([{ $fromRdf: TermPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async termPropertiesClasses(
    query?: $ObjectSet.Query<TermPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass[]>> {
    return this.termPropertiesClassesSync(query);
  }

  termPropertiesClassesSync(
    query?: $ObjectSet.Query<TermPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly TermPropertiesClass[]> {
    return this.$objectsSync<
      TermPropertiesClass,
      TermPropertiesClass.$Identifier
    >([{ $fromRdf: TermPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async termPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<TermPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.termPropertiesClassesCountSync(query);
  }

  termPropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<TermPropertiesClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      TermPropertiesClass,
      TermPropertiesClass.$Identifier
    >([{ $fromRdf: TermPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async unionPropertiesClass(
    identifier: UnionPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, UnionPropertiesClass>> {
    return this.unionPropertiesClassSync(identifier);
  }

  unionPropertiesClassSync(
    identifier: UnionPropertiesClass.$Identifier,
  ): purify.Either<Error, UnionPropertiesClass> {
    return this.unionPropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async unionPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<UnionPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly UnionPropertiesClass.$Identifier[]>
  > {
    return this.unionPropertiesClassIdentifiersSync(query);
  }

  unionPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<UnionPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly UnionPropertiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      UnionPropertiesClass,
      UnionPropertiesClass.$Identifier
    >([{ $fromRdf: UnionPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async unionPropertiesClasses(
    query?: $ObjectSet.Query<UnionPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly UnionPropertiesClass[]>> {
    return this.unionPropertiesClassesSync(query);
  }

  unionPropertiesClassesSync(
    query?: $ObjectSet.Query<UnionPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly UnionPropertiesClass[]> {
    return this.$objectsSync<
      UnionPropertiesClass,
      UnionPropertiesClass.$Identifier
    >([{ $fromRdf: UnionPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async unionPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<UnionPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.unionPropertiesClassesCountSync(query);
  }

  unionPropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<UnionPropertiesClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      UnionPropertiesClass,
      UnionPropertiesClass.$Identifier
    >([{ $fromRdf: UnionPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async uuidV4IriClass(
    identifier: UuidV4IriClass.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriClass>> {
    return this.uuidV4IriClassSync(identifier);
  }

  uuidV4IriClassSync(
    identifier: UuidV4IriClass.$Identifier,
  ): purify.Either<Error, UuidV4IriClass> {
    return this.uuidV4IriClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async uuidV4IriClassIdentifiers(
    query?: $ObjectSet.Query<UuidV4IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriClass.$Identifier[]>> {
    return this.uuidV4IriClassIdentifiersSync(query);
  }

  uuidV4IriClassIdentifiersSync(
    query?: $ObjectSet.Query<UuidV4IriClass.$Identifier>,
  ): purify.Either<Error, readonly UuidV4IriClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      UuidV4IriClass,
      UuidV4IriClass.$Identifier
    >([{ $fromRdf: UuidV4IriClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async uuidV4IriClasses(
    query?: $ObjectSet.Query<UuidV4IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriClass[]>> {
    return this.uuidV4IriClassesSync(query);
  }

  uuidV4IriClassesSync(
    query?: $ObjectSet.Query<UuidV4IriClass.$Identifier>,
  ): purify.Either<Error, readonly UuidV4IriClass[]> {
    return this.$objectsSync<UuidV4IriClass, UuidV4IriClass.$Identifier>(
      [{ $fromRdf: UuidV4IriClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async uuidV4IriClassesCount(
    query?: Pick<$ObjectSet.Query<UuidV4IriClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.uuidV4IriClassesCountSync(query);
  }

  uuidV4IriClassesCountSync(
    query?: Pick<$ObjectSet.Query<UuidV4IriClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<UuidV4IriClass, UuidV4IriClass.$Identifier>(
      [{ $fromRdf: UuidV4IriClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async uuidV4IriInterface(
    identifier: UuidV4IriInterface.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriInterface>> {
    return this.uuidV4IriInterfaceSync(identifier);
  }

  uuidV4IriInterfaceSync(
    identifier: UuidV4IriInterface.$Identifier,
  ): purify.Either<Error, UuidV4IriInterface> {
    return this.uuidV4IriInterfacesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async uuidV4IriInterfaceIdentifiers(
    query?: $ObjectSet.Query<UuidV4IriInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriInterface.$Identifier[]>> {
    return this.uuidV4IriInterfaceIdentifiersSync(query);
  }

  uuidV4IriInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<UuidV4IriInterface.$Identifier>,
  ): purify.Either<Error, readonly UuidV4IriInterface.$Identifier[]> {
    return this.$objectIdentifiersSync<
      UuidV4IriInterface,
      UuidV4IriInterface.$Identifier
    >([{ $fromRdf: UuidV4IriInterface.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async uuidV4IriInterfaces(
    query?: $ObjectSet.Query<UuidV4IriInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriInterface[]>> {
    return this.uuidV4IriInterfacesSync(query);
  }

  uuidV4IriInterfacesSync(
    query?: $ObjectSet.Query<UuidV4IriInterface.$Identifier>,
  ): purify.Either<Error, readonly UuidV4IriInterface[]> {
    return this.$objectsSync<
      UuidV4IriInterface,
      UuidV4IriInterface.$Identifier
    >([{ $fromRdf: UuidV4IriInterface.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async uuidV4IriInterfacesCount(
    query?: Pick<$ObjectSet.Query<UuidV4IriInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.uuidV4IriInterfacesCountSync(query);
  }

  uuidV4IriInterfacesCountSync(
    query?: Pick<$ObjectSet.Query<UuidV4IriInterface.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      UuidV4IriInterface,
      UuidV4IriInterface.$Identifier
    >([{ $fromRdf: UuidV4IriInterface.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async wideIdentifierClass(
    identifier: WideIdentifierClassStatic.$Identifier,
  ): Promise<purify.Either<Error, WideIdentifierClass>> {
    return this.wideIdentifierClassSync(identifier);
  }

  wideIdentifierClassSync(
    identifier: WideIdentifierClassStatic.$Identifier,
  ): purify.Either<Error, WideIdentifierClass> {
    return this.wideIdentifierClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async wideIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<WideIdentifierClassStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly WideIdentifierClassStatic.$Identifier[]>
  > {
    return this.wideIdentifierClassIdentifiersSync(query);
  }

  wideIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<WideIdentifierClassStatic.$Identifier>,
  ): purify.Either<Error, readonly WideIdentifierClassStatic.$Identifier[]> {
    return this.$objectIdentifiersSync<
      WideIdentifierClass,
      WideIdentifierClassStatic.$Identifier
    >(
      [
        {
          $fromRdf: WideIdentifierClassStatic.$fromRdf,
          $fromRdfTypes: [
            WideIdentifierClassStatic.$fromRdfType,
            NarrowedIdentifierClass.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async wideIdentifierClasses(
    query?: $ObjectSet.Query<WideIdentifierClassStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly WideIdentifierClass[]>> {
    return this.wideIdentifierClassesSync(query);
  }

  wideIdentifierClassesSync(
    query?: $ObjectSet.Query<WideIdentifierClassStatic.$Identifier>,
  ): purify.Either<Error, readonly WideIdentifierClass[]> {
    return this.$objectsSync<
      WideIdentifierClass,
      WideIdentifierClassStatic.$Identifier
    >(
      [
        {
          $fromRdf: WideIdentifierClassStatic.$fromRdf,
          $fromRdfTypes: [
            WideIdentifierClassStatic.$fromRdfType,
            NarrowedIdentifierClass.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async wideIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<WideIdentifierClassStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.wideIdentifierClassesCountSync(query);
  }

  wideIdentifierClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<WideIdentifierClassStatic.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      WideIdentifierClass,
      WideIdentifierClassStatic.$Identifier
    >(
      [
        {
          $fromRdf: WideIdentifierClassStatic.$fromRdf,
          $fromRdfTypes: [
            WideIdentifierClassStatic.$fromRdfType,
            NarrowedIdentifierClass.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async classUnion(
    identifier: ClassUnion.$Identifier,
  ): Promise<purify.Either<Error, ClassUnion>> {
    return this.classUnionSync(identifier);
  }

  classUnionSync(
    identifier: ClassUnion.$Identifier,
  ): purify.Either<Error, ClassUnion> {
    return this.classUnionsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async classUnionIdentifiers(
    query?: $ObjectSet.Query<ClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnion.$Identifier[]>> {
    return this.classUnionIdentifiersSync(query);
  }

  classUnionIdentifiersSync(
    query?: $ObjectSet.Query<ClassUnion.$Identifier>,
  ): purify.Either<Error, readonly ClassUnion.$Identifier[]> {
    return this.$objectIdentifiersSync<ClassUnion, ClassUnion.$Identifier>(
      [
        {
          $fromRdf: ClassUnionMember1.$fromRdf,
          $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: ClassUnionMember2.$fromRdf,
          $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async classUnions(
    query?: $ObjectSet.Query<ClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnion[]>> {
    return this.classUnionsSync(query);
  }

  classUnionsSync(
    query?: $ObjectSet.Query<ClassUnion.$Identifier>,
  ): purify.Either<Error, readonly ClassUnion[]> {
    return this.$objectsSync<ClassUnion, ClassUnion.$Identifier>(
      [
        {
          $fromRdf: ClassUnionMember1.$fromRdf,
          $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: ClassUnionMember2.$fromRdf,
          $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async classUnionsCount(
    query?: Pick<$ObjectSet.Query<ClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.classUnionsCountSync(query);
  }

  classUnionsCountSync(
    query?: Pick<$ObjectSet.Query<ClassUnion.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<ClassUnion, ClassUnion.$Identifier>(
      [
        {
          $fromRdf: ClassUnionMember1.$fromRdf,
          $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: ClassUnionMember2.$fromRdf,
          $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async interfaceUnion(
    identifier: InterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnion>> {
    return this.interfaceUnionSync(identifier);
  }

  interfaceUnionSync(
    identifier: InterfaceUnion.$Identifier,
  ): purify.Either<Error, InterfaceUnion> {
    return this.interfaceUnionsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async interfaceUnionIdentifiers(
    query?: $ObjectSet.Query<InterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion.$Identifier[]>> {
    return this.interfaceUnionIdentifiersSync(query);
  }

  interfaceUnionIdentifiersSync(
    query?: $ObjectSet.Query<InterfaceUnion.$Identifier>,
  ): purify.Either<Error, readonly InterfaceUnion.$Identifier[]> {
    return this.$objectIdentifiersSync<
      InterfaceUnion,
      InterfaceUnion.$Identifier
    >(
      [
        { $fromRdf: InterfaceUnionMember1.$fromRdf, $fromRdfTypes: [] },
        { $fromRdf: InterfaceUnionMember2a.$fromRdf, $fromRdfTypes: [] },
        { $fromRdf: InterfaceUnionMember2b.$fromRdf, $fromRdfTypes: [] },
      ],
      query,
    );
  }

  async interfaceUnions(
    query?: $ObjectSet.Query<InterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion[]>> {
    return this.interfaceUnionsSync(query);
  }

  interfaceUnionsSync(
    query?: $ObjectSet.Query<InterfaceUnion.$Identifier>,
  ): purify.Either<Error, readonly InterfaceUnion[]> {
    return this.$objectsSync<InterfaceUnion, InterfaceUnion.$Identifier>(
      [
        { $fromRdf: InterfaceUnionMember1.$fromRdf, $fromRdfTypes: [] },
        { $fromRdf: InterfaceUnionMember2a.$fromRdf, $fromRdfTypes: [] },
        { $fromRdf: InterfaceUnionMember2b.$fromRdf, $fromRdfTypes: [] },
      ],
      query,
    );
  }

  async interfaceUnionsCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.interfaceUnionsCountSync(query);
  }

  interfaceUnionsCountSync(
    query?: Pick<$ObjectSet.Query<InterfaceUnion.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<InterfaceUnion, InterfaceUnion.$Identifier>(
      [
        { $fromRdf: InterfaceUnionMember1.$fromRdf, $fromRdfTypes: [] },
        { $fromRdf: InterfaceUnionMember2a.$fromRdf, $fromRdfTypes: [] },
        { $fromRdf: InterfaceUnionMember2b.$fromRdf, $fromRdfTypes: [] },
      ],
      query,
    );
  }

  async interfaceUnionMember2(
    identifier: InterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember2>> {
    return this.interfaceUnionMember2Sync(identifier);
  }

  interfaceUnionMember2Sync(
    identifier: InterfaceUnionMember2.$Identifier,
  ): purify.Either<Error, InterfaceUnionMember2> {
    return this.interfaceUnionMember2sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async interfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember2.$Identifier[]>
  > {
    return this.interfaceUnionMember2IdentifiersSync(query);
  }

  interfaceUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly InterfaceUnionMember2.$Identifier[]> {
    return this.$objectIdentifiersSync<
      InterfaceUnionMember2,
      InterfaceUnionMember2.$Identifier
    >(
      [
        { $fromRdf: InterfaceUnionMember2a.$fromRdf, $fromRdfTypes: [] },
        { $fromRdf: InterfaceUnionMember2b.$fromRdf, $fromRdfTypes: [] },
      ],
      query,
    );
  }

  async interfaceUnionMember2s(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember2[]>> {
    return this.interfaceUnionMember2sSync(query);
  }

  interfaceUnionMember2sSync(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly InterfaceUnionMember2[]> {
    return this.$objectsSync<
      InterfaceUnionMember2,
      InterfaceUnionMember2.$Identifier
    >(
      [
        { $fromRdf: InterfaceUnionMember2a.$fromRdf, $fromRdfTypes: [] },
        { $fromRdf: InterfaceUnionMember2b.$fromRdf, $fromRdfTypes: [] },
      ],
      query,
    );
  }

  async interfaceUnionMember2sCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember2.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.interfaceUnionMember2sCountSync(query);
  }

  interfaceUnionMember2sCountSync(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember2.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      InterfaceUnionMember2,
      InterfaceUnionMember2.$Identifier
    >(
      [
        { $fromRdf: InterfaceUnionMember2a.$fromRdf, $fromRdfTypes: [] },
        { $fromRdf: InterfaceUnionMember2b.$fromRdf, $fromRdfTypes: [] },
      ],
      query,
    );
  }

  async lazilyResolvedClassUnion(
    identifier: LazilyResolvedClassUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnion>> {
    return this.lazilyResolvedClassUnionSync(identifier);
  }

  lazilyResolvedClassUnionSync(
    identifier: LazilyResolvedClassUnion.$Identifier,
  ): purify.Either<Error, LazilyResolvedClassUnion> {
    return this.lazilyResolvedClassUnionsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnion.$Identifier[]>
  > {
    return this.lazilyResolvedClassUnionIdentifiersSync(query);
  }

  lazilyResolvedClassUnionIdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedClassUnion.$Identifier[]> {
    return this.$objectIdentifiersSync<
      LazilyResolvedClassUnion,
      LazilyResolvedClassUnion.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedClassUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: LazilyResolvedClassUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedClassUnions(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnion[]>> {
    return this.lazilyResolvedClassUnionsSync(query);
  }

  lazilyResolvedClassUnionsSync(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedClassUnion[]> {
    return this.$objectsSync<
      LazilyResolvedClassUnion,
      LazilyResolvedClassUnion.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedClassUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: LazilyResolvedClassUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedClassUnionsCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedClassUnionsCountSync(query);
  }

  lazilyResolvedClassUnionsCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazilyResolvedClassUnion,
      LazilyResolvedClassUnion.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedClassUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: LazilyResolvedClassUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedInterfaceUnion(
    identifier: LazilyResolvedInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnion>> {
    return this.lazilyResolvedInterfaceUnionSync(identifier);
  }

  lazilyResolvedInterfaceUnionSync(
    identifier: LazilyResolvedInterfaceUnion.$Identifier,
  ): purify.Either<Error, LazilyResolvedInterfaceUnion> {
    return this.lazilyResolvedInterfaceUnionsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnion.$Identifier[]>
  > {
    return this.lazilyResolvedInterfaceUnionIdentifiersSync(query);
  }

  lazilyResolvedInterfaceUnionIdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedInterfaceUnion.$Identifier[]> {
    return this.$objectIdentifiersSync<
      LazilyResolvedInterfaceUnion,
      LazilyResolvedInterfaceUnion.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedInterfaceUnions(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedInterfaceUnion[]>> {
    return this.lazilyResolvedInterfaceUnionsSync(query);
  }

  lazilyResolvedInterfaceUnionsSync(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedInterfaceUnion[]> {
    return this.$objectsSync<
      LazilyResolvedInterfaceUnion,
      LazilyResolvedInterfaceUnion.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedInterfaceUnionsCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedInterfaceUnionsCountSync(query);
  }

  lazilyResolvedInterfaceUnionsCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazilyResolvedInterfaceUnion,
      LazilyResolvedInterfaceUnion.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialClassUnion(
    identifier: PartialClassUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnion>> {
    return this.partialClassUnionSync(identifier);
  }

  partialClassUnionSync(
    identifier: PartialClassUnion.$Identifier,
  ): purify.Either<Error, PartialClassUnion> {
    return this.partialClassUnionsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async partialClassUnionIdentifiers(
    query?: $ObjectSet.Query<PartialClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion.$Identifier[]>> {
    return this.partialClassUnionIdentifiersSync(query);
  }

  partialClassUnionIdentifiersSync(
    query?: $ObjectSet.Query<PartialClassUnion.$Identifier>,
  ): purify.Either<Error, readonly PartialClassUnion.$Identifier[]> {
    return this.$objectIdentifiersSync<
      PartialClassUnion,
      PartialClassUnion.$Identifier
    >(
      [
        {
          $fromRdf: PartialClassUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: PartialClassUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialClassUnions(
    query?: $ObjectSet.Query<PartialClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion[]>> {
    return this.partialClassUnionsSync(query);
  }

  partialClassUnionsSync(
    query?: $ObjectSet.Query<PartialClassUnion.$Identifier>,
  ): purify.Either<Error, readonly PartialClassUnion[]> {
    return this.$objectsSync<PartialClassUnion, PartialClassUnion.$Identifier>(
      [
        {
          $fromRdf: PartialClassUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: PartialClassUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialClassUnionsCount(
    query?: Pick<$ObjectSet.Query<PartialClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.partialClassUnionsCountSync(query);
  }

  partialClassUnionsCountSync(
    query?: Pick<$ObjectSet.Query<PartialClassUnion.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PartialClassUnion,
      PartialClassUnion.$Identifier
    >(
      [
        {
          $fromRdf: PartialClassUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: PartialClassUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialInterfaceUnion(
    identifier: PartialInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnion>> {
    return this.partialInterfaceUnionSync(identifier);
  }

  partialInterfaceUnionSync(
    identifier: PartialInterfaceUnion.$Identifier,
  ): purify.Either<Error, PartialInterfaceUnion> {
    return this.partialInterfaceUnionsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async partialInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnion.$Identifier[]>
  > {
    return this.partialInterfaceUnionIdentifiersSync(query);
  }

  partialInterfaceUnionIdentifiersSync(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Identifier>,
  ): purify.Either<Error, readonly PartialInterfaceUnion.$Identifier[]> {
    return this.$objectIdentifiersSync<
      PartialInterfaceUnion,
      PartialInterfaceUnion.$Identifier
    >(
      [
        {
          $fromRdf: PartialInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: PartialInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialInterfaceUnions(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnion[]>> {
    return this.partialInterfaceUnionsSync(query);
  }

  partialInterfaceUnionsSync(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Identifier>,
  ): purify.Either<Error, readonly PartialInterfaceUnion[]> {
    return this.$objectsSync<
      PartialInterfaceUnion,
      PartialInterfaceUnion.$Identifier
    >(
      [
        {
          $fromRdf: PartialInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: PartialInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialInterfaceUnionsCount(
    query?: Pick<$ObjectSet.Query<PartialInterfaceUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.partialInterfaceUnionsCountSync(query);
  }

  partialInterfaceUnionsCountSync(
    query?: Pick<$ObjectSet.Query<PartialInterfaceUnion.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PartialInterfaceUnion,
      PartialInterfaceUnion.$Identifier
    >(
      [
        {
          $fromRdf: PartialInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: PartialInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async recursiveClassUnion(
    identifier: RecursiveClassUnion.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnion>> {
    return this.recursiveClassUnionSync(identifier);
  }

  recursiveClassUnionSync(
    identifier: RecursiveClassUnion.$Identifier,
  ): purify.Either<Error, RecursiveClassUnion> {
    return this.recursiveClassUnionsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async recursiveClassUnionIdentifiers(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion.$Identifier[]>> {
    return this.recursiveClassUnionIdentifiersSync(query);
  }

  recursiveClassUnionIdentifiersSync(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Identifier>,
  ): purify.Either<Error, readonly RecursiveClassUnion.$Identifier[]> {
    return this.$objectIdentifiersSync<
      RecursiveClassUnion,
      RecursiveClassUnion.$Identifier
    >(
      [
        { $fromRdf: RecursiveClassUnionMember1.$fromRdf, $fromRdfTypes: [] },
        { $fromRdf: RecursiveClassUnionMember2.$fromRdf, $fromRdfTypes: [] },
      ],
      query,
    );
  }

  async recursiveClassUnions(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion[]>> {
    return this.recursiveClassUnionsSync(query);
  }

  recursiveClassUnionsSync(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Identifier>,
  ): purify.Either<Error, readonly RecursiveClassUnion[]> {
    return this.$objectsSync<
      RecursiveClassUnion,
      RecursiveClassUnion.$Identifier
    >(
      [
        { $fromRdf: RecursiveClassUnionMember1.$fromRdf, $fromRdfTypes: [] },
        { $fromRdf: RecursiveClassUnionMember2.$fromRdf, $fromRdfTypes: [] },
      ],
      query,
    );
  }

  async recursiveClassUnionsCount(
    query?: Pick<$ObjectSet.Query<RecursiveClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.recursiveClassUnionsCountSync(query);
  }

  recursiveClassUnionsCountSync(
    query?: Pick<$ObjectSet.Query<RecursiveClassUnion.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      RecursiveClassUnion,
      RecursiveClassUnion.$Identifier
    >(
      [
        { $fromRdf: RecursiveClassUnionMember1.$fromRdf, $fromRdfTypes: [] },
        { $fromRdf: RecursiveClassUnionMember2.$fromRdf, $fromRdfTypes: [] },
      ],
      query,
    );
  }

  protected $objectIdentifiersSync<
    ObjectT extends { readonly $identifier: ObjectIdentifierT },
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectTypes: readonly {
      $fromRdf: (
        resource: rdfjsResource.Resource,
        options: { objectSet: $ObjectSet },
      ) => purify.Either<Error, ObjectT>;
      $fromRdfTypes: readonly rdfjs.NamedNode[];
    }[],
    query?: $ObjectSet.Query<ObjectIdentifierT>,
  ): purify.Either<Error, readonly ObjectIdentifierT[]> {
    return this.$objectsSync<ObjectT, ObjectIdentifierT>(
      objectTypes,
      query,
    ).map((objects) => objects.map((object) => object.$identifier));
  }

  protected $objectsSync<
    ObjectT extends { readonly $identifier: ObjectIdentifierT },
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectTypes: readonly {
      $fromRdf: (
        resource: rdfjsResource.Resource,
        options: { objectSet: $ObjectSet },
      ) => purify.Either<Error, ObjectT>;
      $fromRdfTypes: readonly rdfjs.NamedNode[];
    }[],
    query?: $ObjectSet.Query<ObjectIdentifierT>,
  ): purify.Either<Error, readonly ObjectT[]> {
    const limit = query?.limit ?? Number.MAX_SAFE_INTEGER;
    if (limit <= 0) {
      return purify.Either.of([]);
    }

    let offset = query?.offset ?? 0;
    if (offset < 0) {
      offset = 0;
    }

    // First pass: gather all resources that meet the where filters.
    // We don't limit + offset here because the resources aren't sorted and limit + offset should be deterministic.
    const resources: {
      objectType?: {
        $fromRdf: (
          resource: rdfjsResource.Resource,
          options: { objectSet: $ObjectSet },
        ) => purify.Either<Error, ObjectT>;
        $fromRdfTypes: readonly rdfjs.NamedNode[];
      };
      resource: rdfjsResource.Resource;
    }[] = [];
    const where = query?.where ?? { type: "type" };
    switch (where.type) {
      case "identifiers": {
        for (const identifier of where.identifiers) {
          // Don't deduplicate
          resources.push({ resource: this.resourceSet.resource(identifier) });
        }
        break;
      }

      case "triple-objects": {
        for (const quad of this.resourceSet.dataset.match(
          where.subject,
          where.predicate,
          null,
        )) {
          if (
            where.objectTermType &&
            quad.object.termType !== where.objectTermType
          ) {
            continue;
          }

          switch (quad.object.termType) {
            case "BlankNode":
            case "NamedNode":
              break;
            default:
              return purify.Left(
                new Error(
                  `subject=${where.subject?.value} predicate=${where.predicate.value} pattern matches non-identifier (${quad.object.termType}) object`,
                ),
              );
          }

          const resource = this.resourceSet.resource(quad.object);
          if (
            !resources.some(({ resource: existingResource }) =>
              existingResource.identifier.equals(resource.identifier),
            )
          ) {
            resources.push({ resource });
          }
        }
        break;
      }

      case "triple-subjects": {
        for (const quad of this.resourceSet.dataset.match(
          null,
          where.predicate,
          where.object,
        )) {
          if (
            where.subjectTermType &&
            quad.subject.termType !== where.subjectTermType
          ) {
            continue;
          }

          switch (quad.subject.termType) {
            case "BlankNode":
            case "NamedNode":
              break;
            default:
              return purify.Left(
                new Error(
                  `predicate=${where.predicate.value} object=${where.object?.value} pattern matches non-identifier (${quad.subject.termType}) subject`,
                ),
              );
          }

          const resource = this.resourceSet.resource(quad.subject);
          if (
            !resources.some(({ resource: existingResource }) =>
              existingResource.identifier.equals(resource.identifier),
            )
          ) {
            resources.push({ resource });
          }
        }
        break;
      }

      case "type": {
        for (const objectType of objectTypes) {
          if (objectType.$fromRdfTypes.length === 0) {
            continue;
          }

          for (const fromRdfType of objectType.$fromRdfTypes) {
            for (const resource of where.identifierType === "NamedNode"
              ? this.resourceSet.namedInstancesOf(fromRdfType)
              : this.resourceSet.instancesOf(fromRdfType)) {
              if (
                !resources.some(({ resource: existingResource }) =>
                  existingResource.identifier.equals(resource.identifier),
                )
              ) {
                resources.push({ objectType, resource });
              }
            }
          }
        }

        break;
      }
    }

    // Sort resources by identifier so limit and offset are deterministic
    resources.sort((left, right) =>
      left.resource.identifier.value.localeCompare(
        right.resource.identifier.value,
      ),
    );

    let objectI = 0;
    const objects: ObjectT[] = [];
    for (let { objectType, resource } of resources) {
      let objectEither: purify.Either<Error, ObjectT>;
      if (objectType) {
        objectEither = objectType.$fromRdf(resource, { objectSet: this });
      } else {
        for (const tryObjectType of objectTypes) {
          objectEither = tryObjectType.$fromRdf(resource, { objectSet: this });
          if (objectEither.isRight()) {
            objectType = tryObjectType;
            break;
          }
        }
      }

      if (objectEither!.isLeft()) {
        // Doesn't appear to belong to any of the known object types, just assume the first
        return objectEither as unknown as purify.Either<
          Error,
          readonly ObjectT[]
        >;
      }
      const object = objectEither!.unsafeCoerce();
      if (objectI++ >= offset) {
        objects.push(object);
        if (objects.length === limit) {
          return purify.Either.of(objects);
        }
      }
    }

    return purify.Either.of(objects);
  }

  protected $objectsCountSync<
    ObjectT extends { readonly $identifier: ObjectIdentifierT },
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectTypes: readonly {
      $fromRdf: (
        resource: rdfjsResource.Resource,
        options: { objectSet: $ObjectSet },
      ) => purify.Either<Error, ObjectT>;
      $fromRdfTypes: readonly rdfjs.NamedNode[];
    }[],
    query?: $ObjectSet.Query<ObjectIdentifierT>,
  ): purify.Either<Error, number> {
    return this.$objectsSync<ObjectT, ObjectIdentifierT>(
      objectTypes,
      query,
    ).map((objects) => objects.length);
  }
}

export class $SparqlObjectSet implements $ObjectSet {
  protected readonly $countVariable = dataFactory.variable!("count");
  protected readonly $objectVariable = dataFactory.variable!("object");
  protected readonly $sparqlClient: {
    queryBindings: (
      query: string,
    ) => Promise<
      readonly Record<
        string,
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
      >[]
    >;
    queryQuads: (query: string) => Promise<readonly rdfjs.Quad[]>;
  };
  protected readonly $sparqlGenerator = new sparqljs.Generator();

  constructor({
    sparqlClient,
  }: { sparqlClient: $SparqlObjectSet["$sparqlClient"] }) {
    this.$sparqlClient = sparqlClient;
  }

  async baseInterfaceWithoutProperties(
    identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithoutProperties>> {
    return (
      await this.baseInterfaceWithoutPropertieses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async baseInterfaceWithoutPropertiesIdentifiers(
    query?: $SparqlObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithoutPropertiesStatic.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<BaseInterfaceWithoutPropertiesStatic.$Identifier>(
      BaseInterfaceWithoutPropertiesStatic,
      query,
    );
  }

  async baseInterfaceWithoutPropertieses(
    query?: $SparqlObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithoutProperties[]>> {
    return this.$objects<
      BaseInterfaceWithoutProperties,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >(BaseInterfaceWithoutPropertiesStatic, query);
  }

  async baseInterfaceWithoutPropertiesesCount(
    query?: Pick<
      $SparqlObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<BaseInterfaceWithoutPropertiesStatic.$Identifier>(
      BaseInterfaceWithoutPropertiesStatic,
      query,
    );
  }

  async baseInterfaceWithProperties(
    identifier: BaseInterfaceWithPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithProperties>> {
    return (
      await this.baseInterfaceWithPropertieses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async baseInterfaceWithPropertiesIdentifiers(
    query?: $SparqlObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithPropertiesStatic.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<BaseInterfaceWithPropertiesStatic.$Identifier>(
      BaseInterfaceWithPropertiesStatic,
      query,
    );
  }

  async baseInterfaceWithPropertieses(
    query?: $SparqlObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithProperties[]>> {
    return this.$objects<
      BaseInterfaceWithProperties,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >(BaseInterfaceWithPropertiesStatic, query);
  }

  async baseInterfaceWithPropertiesesCount(
    query?: Pick<
      $SparqlObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<BaseInterfaceWithPropertiesStatic.$Identifier>(
      BaseInterfaceWithPropertiesStatic,
      query,
    );
  }

  async blankClass(
    identifier: BlankClass.$Identifier,
  ): Promise<purify.Either<Error, BlankClass>> {
    return (
      await this.blankClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async blankClassIdentifiers(
    query?: $SparqlObjectSet.Query<BlankClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankClass.$Identifier[]>> {
    return this.$objectIdentifiers<BlankClass.$Identifier>(BlankClass, query);
  }

  async blankClasses(
    query?: $SparqlObjectSet.Query<BlankClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankClass[]>> {
    return this.$objects<BlankClass, BlankClass.$Identifier>(BlankClass, query);
  }

  async blankClassesCount(
    query?: Pick<$SparqlObjectSet.Query<BlankClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<BlankClass.$Identifier>(BlankClass, query);
  }

  async blankInterface(
    identifier: BlankInterface.$Identifier,
  ): Promise<purify.Either<Error, BlankInterface>> {
    return (
      await this.blankInterfaces({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async blankInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<BlankInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankInterface.$Identifier[]>> {
    return this.$objectIdentifiers<BlankInterface.$Identifier>(
      BlankInterface,
      query,
    );
  }

  async blankInterfaces(
    query?: $SparqlObjectSet.Query<BlankInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankInterface[]>> {
    return this.$objects<BlankInterface, BlankInterface.$Identifier>(
      BlankInterface,
      query,
    );
  }

  async blankInterfacesCount(
    query?: Pick<$SparqlObjectSet.Query<BlankInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<BlankInterface.$Identifier>(
      BlankInterface,
      query,
    );
  }

  async classUnionMember1(
    identifier: ClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember1>> {
    return (
      await this.classUnionMember1s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async classUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<ClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1.$Identifier[]>> {
    return this.$objectIdentifiers<ClassUnionMember1.$Identifier>(
      ClassUnionMember1,
      query,
    );
  }

  async classUnionMember1s(
    query?: $SparqlObjectSet.Query<ClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1[]>> {
    return this.$objects<ClassUnionMember1, ClassUnionMember1.$Identifier>(
      ClassUnionMember1,
      query,
    );
  }

  async classUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<ClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ClassUnionMember1.$Identifier>(
      ClassUnionMember1,
      query,
    );
  }

  async classUnionMember2(
    identifier: ClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember2>> {
    return (
      await this.classUnionMember2s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async classUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<ClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2.$Identifier[]>> {
    return this.$objectIdentifiers<ClassUnionMember2.$Identifier>(
      ClassUnionMember2,
      query,
    );
  }

  async classUnionMember2s(
    query?: $SparqlObjectSet.Query<ClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2[]>> {
    return this.$objects<ClassUnionMember2, ClassUnionMember2.$Identifier>(
      ClassUnionMember2,
      query,
    );
  }

  async classUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<ClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ClassUnionMember2.$Identifier>(
      ClassUnionMember2,
      query,
    );
  }

  async concreteChildClass(
    identifier: ConcreteChildClass.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildClass>> {
    return (
      await this.concreteChildClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async concreteChildClassIdentifiers(
    query?: $SparqlObjectSet.Query<ConcreteChildClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass.$Identifier[]>> {
    return this.$objectIdentifiers<ConcreteChildClass.$Identifier>(
      ConcreteChildClass,
      query,
    );
  }

  async concreteChildClasses(
    query?: $SparqlObjectSet.Query<ConcreteChildClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass[]>> {
    return this.$objects<ConcreteChildClass, ConcreteChildClass.$Identifier>(
      ConcreteChildClass,
      query,
    );
  }

  async concreteChildClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ConcreteChildClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ConcreteChildClass.$Identifier>(
      ConcreteChildClass,
      query,
    );
  }

  async concreteChildInterface(
    identifier: ConcreteChildInterface.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildInterface>> {
    return (
      await this.concreteChildInterfaces({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async concreteChildInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<ConcreteChildInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteChildInterface.$Identifier[]>
  > {
    return this.$objectIdentifiers<ConcreteChildInterface.$Identifier>(
      ConcreteChildInterface,
      query,
    );
  }

  async concreteChildInterfaces(
    query?: $SparqlObjectSet.Query<ConcreteChildInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildInterface[]>> {
    return this.$objects<
      ConcreteChildInterface,
      ConcreteChildInterface.$Identifier
    >(ConcreteChildInterface, query);
  }

  async concreteChildInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ConcreteChildInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ConcreteChildInterface.$Identifier>(
      ConcreteChildInterface,
      query,
    );
  }

  async concreteParentClass(
    identifier: ConcreteParentClassStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentClass>> {
    return (
      await this.concreteParentClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async concreteParentClassIdentifiers(
    query?: $SparqlObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentClassStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<ConcreteParentClassStatic.$Identifier>(
      ConcreteParentClassStatic,
      query,
    );
  }

  async concreteParentClasses(
    query?: $SparqlObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteParentClass[]>> {
    return this.$objects<
      ConcreteParentClass,
      ConcreteParentClassStatic.$Identifier
    >(ConcreteParentClassStatic, query);
  }

  async concreteParentClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ConcreteParentClassStatic.$Identifier>(
      ConcreteParentClassStatic,
      query,
    );
  }

  async concreteParentInterface(
    identifier: ConcreteParentInterfaceStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentInterface>> {
    return (
      await this.concreteParentInterfaces({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async concreteParentInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentInterfaceStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<ConcreteParentInterfaceStatic.$Identifier>(
      ConcreteParentInterfaceStatic,
      query,
    );
  }

  async concreteParentInterfaces(
    query?: $SparqlObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteParentInterface[]>> {
    return this.$objects<
      ConcreteParentInterface,
      ConcreteParentInterfaceStatic.$Identifier
    >(ConcreteParentInterfaceStatic, query);
  }

  async concreteParentInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ConcreteParentInterfaceStatic.$Identifier>(
      ConcreteParentInterfaceStatic,
      query,
    );
  }

  async convertibleTypePropertiesClass(
    identifier: ConvertibleTypePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ConvertibleTypePropertiesClass>> {
    return (
      await this.convertibleTypePropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async convertibleTypePropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConvertibleTypePropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<ConvertibleTypePropertiesClass.$Identifier>(
      ConvertibleTypePropertiesClass,
      query,
    );
  }

  async convertibleTypePropertiesClasses(
    query?: $SparqlObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConvertibleTypePropertiesClass[]>> {
    return this.$objects<
      ConvertibleTypePropertiesClass,
      ConvertibleTypePropertiesClass.$Identifier
    >(ConvertibleTypePropertiesClass, query);
  }

  async convertibleTypePropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ConvertibleTypePropertiesClass.$Identifier>(
      ConvertibleTypePropertiesClass,
      query,
    );
  }

  async defaultValuePropertiesClass(
    identifier: DefaultValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, DefaultValuePropertiesClass>> {
    return (
      await this.defaultValuePropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async defaultValuePropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly DefaultValuePropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<DefaultValuePropertiesClass.$Identifier>(
      DefaultValuePropertiesClass,
      query,
    );
  }

  async defaultValuePropertiesClasses(
    query?: $SparqlObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DefaultValuePropertiesClass[]>> {
    return this.$objects<
      DefaultValuePropertiesClass,
      DefaultValuePropertiesClass.$Identifier
    >(DefaultValuePropertiesClass, query);
  }

  async defaultValuePropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<DefaultValuePropertiesClass.$Identifier>(
      DefaultValuePropertiesClass,
      query,
    );
  }

  async directRecursiveClass(
    identifier: DirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, DirectRecursiveClass>> {
    return (
      await this.directRecursiveClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async directRecursiveClassIdentifiers(
    query?: $SparqlObjectSet.Query<DirectRecursiveClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly DirectRecursiveClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<DirectRecursiveClass.$Identifier>(
      DirectRecursiveClass,
      query,
    );
  }

  async directRecursiveClasses(
    query?: $SparqlObjectSet.Query<DirectRecursiveClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DirectRecursiveClass[]>> {
    return this.$objects<
      DirectRecursiveClass,
      DirectRecursiveClass.$Identifier
    >(DirectRecursiveClass, query);
  }

  async directRecursiveClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<DirectRecursiveClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<DirectRecursiveClass.$Identifier>(
      DirectRecursiveClass,
      query,
    );
  }

  async explicitFromToRdfTypesClass(
    identifier: ExplicitFromToRdfTypesClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitFromToRdfTypesClass>> {
    return (
      await this.explicitFromToRdfTypesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async explicitFromToRdfTypesClassIdentifiers(
    query?: $SparqlObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExplicitFromToRdfTypesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<ExplicitFromToRdfTypesClass.$Identifier>(
      ExplicitFromToRdfTypesClass,
      query,
    );
  }

  async explicitFromToRdfTypesClasses(
    query?: $SparqlObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExplicitFromToRdfTypesClass[]>> {
    return this.$objects<
      ExplicitFromToRdfTypesClass,
      ExplicitFromToRdfTypesClass.$Identifier
    >(ExplicitFromToRdfTypesClass, query);
  }

  async explicitFromToRdfTypesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ExplicitFromToRdfTypesClass.$Identifier>(
      ExplicitFromToRdfTypesClass,
      query,
    );
  }

  async explicitRdfTypeClass(
    identifier: ExplicitRdfTypeClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitRdfTypeClass>> {
    return (
      await this.explicitRdfTypeClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async explicitRdfTypeClassIdentifiers(
    query?: $SparqlObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExplicitRdfTypeClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<ExplicitRdfTypeClass.$Identifier>(
      ExplicitRdfTypeClass,
      query,
    );
  }

  async explicitRdfTypeClasses(
    query?: $SparqlObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExplicitRdfTypeClass[]>> {
    return this.$objects<
      ExplicitRdfTypeClass,
      ExplicitRdfTypeClass.$Identifier
    >(ExplicitRdfTypeClass, query);
  }

  async explicitRdfTypeClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ExplicitRdfTypeClass.$Identifier>(
      ExplicitRdfTypeClass,
      query,
    );
  }

  async externClassPropertyClass(
    identifier: ExternClassPropertyClass.$Identifier,
  ): Promise<purify.Either<Error, ExternClassPropertyClass>> {
    return (
      await this.externClassPropertyClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async externClassPropertyClassIdentifiers(
    query?: $SparqlObjectSet.Query<ExternClassPropertyClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExternClassPropertyClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<ExternClassPropertyClass.$Identifier>(
      ExternClassPropertyClass,
      query,
    );
  }

  async externClassPropertyClasses(
    query?: $SparqlObjectSet.Query<ExternClassPropertyClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExternClassPropertyClass[]>> {
    return this.$objects<
      ExternClassPropertyClass,
      ExternClassPropertyClass.$Identifier
    >(ExternClassPropertyClass, query);
  }

  async externClassPropertyClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ExternClassPropertyClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ExternClassPropertyClass.$Identifier>(
      ExternClassPropertyClass,
      query,
    );
  }

  async hasValuePropertiesClass(
    identifier: HasValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, HasValuePropertiesClass>> {
    return (
      await this.hasValuePropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async hasValuePropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<HasValuePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly HasValuePropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<HasValuePropertiesClass.$Identifier>(
      HasValuePropertiesClass,
      query,
    );
  }

  async hasValuePropertiesClasses(
    query?: $SparqlObjectSet.Query<HasValuePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly HasValuePropertiesClass[]>> {
    return this.$objects<
      HasValuePropertiesClass,
      HasValuePropertiesClass.$Identifier
    >(HasValuePropertiesClass, query);
  }

  async hasValuePropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<HasValuePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<HasValuePropertiesClass.$Identifier>(
      HasValuePropertiesClass,
      query,
    );
  }

  async indirectRecursiveClass(
    identifier: IndirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveClass>> {
    return (
      await this.indirectRecursiveClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async indirectRecursiveClassIdentifiers(
    query?: $SparqlObjectSet.Query<IndirectRecursiveClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<IndirectRecursiveClass.$Identifier>(
      IndirectRecursiveClass,
      query,
    );
  }

  async indirectRecursiveClasses(
    query?: $SparqlObjectSet.Query<IndirectRecursiveClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveClass[]>> {
    return this.$objects<
      IndirectRecursiveClass,
      IndirectRecursiveClass.$Identifier
    >(IndirectRecursiveClass, query);
  }

  async indirectRecursiveClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<IndirectRecursiveClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<IndirectRecursiveClass.$Identifier>(
      IndirectRecursiveClass,
      query,
    );
  }

  async indirectRecursiveHelperClass(
    identifier: IndirectRecursiveHelperClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveHelperClass>> {
    return (
      await this.indirectRecursiveHelperClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async indirectRecursiveHelperClassIdentifiers(
    query?: $SparqlObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveHelperClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<IndirectRecursiveHelperClass.$Identifier>(
      IndirectRecursiveHelperClass,
      query,
    );
  }

  async indirectRecursiveHelperClasses(
    query?: $SparqlObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveHelperClass[]>> {
    return this.$objects<
      IndirectRecursiveHelperClass,
      IndirectRecursiveHelperClass.$Identifier
    >(IndirectRecursiveHelperClass, query);
  }

  async indirectRecursiveHelperClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<IndirectRecursiveHelperClass.$Identifier>(
      IndirectRecursiveHelperClass,
      query,
    );
  }

  async inIdentifierClass(
    identifier: InIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, InIdentifierClass>> {
    return (
      await this.inIdentifierClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async inIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<InIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass.$Identifier[]>> {
    return this.$objectIdentifiers<InIdentifierClass.$Identifier>(
      InIdentifierClass,
      query,
    );
  }

  async inIdentifierClasses(
    query?: $SparqlObjectSet.Query<InIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass[]>> {
    return this.$objects<InIdentifierClass, InIdentifierClass.$Identifier>(
      InIdentifierClass,
      query,
    );
  }

  async inIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<InIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<InIdentifierClass.$Identifier>(
      InIdentifierClass,
      query,
    );
  }

  async inPropertiesClass(
    identifier: InPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, InPropertiesClass>> {
    return (
      await this.inPropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async inPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<InPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<InPropertiesClass.$Identifier>(
      InPropertiesClass,
      query,
    );
  }

  async inPropertiesClasses(
    query?: $SparqlObjectSet.Query<InPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass[]>> {
    return this.$objects<InPropertiesClass, InPropertiesClass.$Identifier>(
      InPropertiesClass,
      query,
    );
  }

  async inPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<InPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<InPropertiesClass.$Identifier>(
      InPropertiesClass,
      query,
    );
  }

  async interface(
    identifier: Interface.$Identifier,
  ): Promise<purify.Either<Error, Interface>> {
    return (
      await this.interfaces({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async interfaceIdentifiers(
    query?: $SparqlObjectSet.Query<Interface.$Identifier>,
  ): Promise<purify.Either<Error, readonly Interface.$Identifier[]>> {
    return this.$objectIdentifiers<Interface.$Identifier>(Interface, query);
  }

  async interfaces(
    query?: $SparqlObjectSet.Query<Interface.$Identifier>,
  ): Promise<purify.Either<Error, readonly Interface[]>> {
    return this.$objects<Interface, Interface.$Identifier>(Interface, query);
  }

  async interfacesCount(
    query?: Pick<$SparqlObjectSet.Query<Interface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<Interface.$Identifier>(Interface, query);
  }

  async interfaceUnionMember1(
    identifier: InterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember1>> {
    return (
      await this.interfaceUnionMember1s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async interfaceUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<InterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember1.$Identifier[]>
  > {
    return this.$objectIdentifiers<InterfaceUnionMember1.$Identifier>(
      InterfaceUnionMember1,
      query,
    );
  }

  async interfaceUnionMember1s(
    query?: $SparqlObjectSet.Query<InterfaceUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember1[]>> {
    return this.$objects<
      InterfaceUnionMember1,
      InterfaceUnionMember1.$Identifier
    >(InterfaceUnionMember1, query);
  }

  async interfaceUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<InterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<InterfaceUnionMember1.$Identifier>(
      InterfaceUnionMember1,
      query,
    );
  }

  async interfaceUnionMember2a(
    identifier: InterfaceUnionMember2a.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember2a>> {
    return (
      await this.interfaceUnionMember2as({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async interfaceUnionMember2aIdentifiers(
    query?: $SparqlObjectSet.Query<InterfaceUnionMember2a.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember2a.$Identifier[]>
  > {
    return this.$objectIdentifiers<InterfaceUnionMember2a.$Identifier>(
      InterfaceUnionMember2a,
      query,
    );
  }

  async interfaceUnionMember2as(
    query?: $SparqlObjectSet.Query<InterfaceUnionMember2a.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember2a[]>> {
    return this.$objects<
      InterfaceUnionMember2a,
      InterfaceUnionMember2a.$Identifier
    >(InterfaceUnionMember2a, query);
  }

  async interfaceUnionMember2asCount(
    query?: Pick<
      $SparqlObjectSet.Query<InterfaceUnionMember2a.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<InterfaceUnionMember2a.$Identifier>(
      InterfaceUnionMember2a,
      query,
    );
  }

  async interfaceUnionMember2b(
    identifier: InterfaceUnionMember2b.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember2b>> {
    return (
      await this.interfaceUnionMember2bs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async interfaceUnionMember2bIdentifiers(
    query?: $SparqlObjectSet.Query<InterfaceUnionMember2b.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember2b.$Identifier[]>
  > {
    return this.$objectIdentifiers<InterfaceUnionMember2b.$Identifier>(
      InterfaceUnionMember2b,
      query,
    );
  }

  async interfaceUnionMember2bs(
    query?: $SparqlObjectSet.Query<InterfaceUnionMember2b.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember2b[]>> {
    return this.$objects<
      InterfaceUnionMember2b,
      InterfaceUnionMember2b.$Identifier
    >(InterfaceUnionMember2b, query);
  }

  async interfaceUnionMember2bsCount(
    query?: Pick<
      $SparqlObjectSet.Query<InterfaceUnionMember2b.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<InterfaceUnionMember2b.$Identifier>(
      InterfaceUnionMember2b,
      query,
    );
  }

  async iriClass(
    identifier: IriClass.$Identifier,
  ): Promise<purify.Either<Error, IriClass>> {
    return (
      await this.iriClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async iriClassIdentifiers(
    query?: $SparqlObjectSet.Query<IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IriClass.$Identifier[]>> {
    return this.$objectIdentifiers<IriClass.$Identifier>(IriClass, query);
  }

  async iriClasses(
    query?: $SparqlObjectSet.Query<IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IriClass[]>> {
    return this.$objects<IriClass, IriClass.$Identifier>(IriClass, query);
  }

  async iriClassesCount(
    query?: Pick<$SparqlObjectSet.Query<IriClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<IriClass.$Identifier>(IriClass, query);
  }

  async languageInPropertiesClass(
    identifier: LanguageInPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LanguageInPropertiesClass>> {
    return (
      await this.languageInPropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async languageInPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LanguageInPropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<LanguageInPropertiesClass.$Identifier>(
      LanguageInPropertiesClass,
      query,
    );
  }

  async languageInPropertiesClasses(
    query?: $SparqlObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LanguageInPropertiesClass[]>> {
    return this.$objects<
      LanguageInPropertiesClass,
      LanguageInPropertiesClass.$Identifier
    >(LanguageInPropertiesClass, query);
  }

  async languageInPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LanguageInPropertiesClass.$Identifier>(
      LanguageInPropertiesClass,
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriClass(
    identifier: LazilyResolvedBlankNodeOrIriClass.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedBlankNodeOrIriClass>> {
    return (
      await this.lazilyResolvedBlankNodeOrIriClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedBlankNodeOrIriClassIdentifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedBlankNodeOrIriClass.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriClass.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<LazilyResolvedBlankNodeOrIriClass.$Identifier>(
      LazilyResolvedBlankNodeOrIriClass,
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriClasses(
    query?: $SparqlObjectSet.Query<LazilyResolvedBlankNodeOrIriClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedBlankNodeOrIriClass[]>
  > {
    return this.$objects<
      LazilyResolvedBlankNodeOrIriClass,
      LazilyResolvedBlankNodeOrIriClass.$Identifier
    >(LazilyResolvedBlankNodeOrIriClass, query);
  }

  async lazilyResolvedBlankNodeOrIriClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedBlankNodeOrIriClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedBlankNodeOrIriClass.$Identifier>(
      LazilyResolvedBlankNodeOrIriClass,
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriInterface(
    identifier: LazilyResolvedBlankNodeOrIriInterface.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedBlankNodeOrIriInterface>> {
    return (
      await this.lazilyResolvedBlankNodeOrIriInterfaces({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedBlankNodeOrIriInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedBlankNodeOrIriInterface.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriInterface.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<LazilyResolvedBlankNodeOrIriInterface.$Identifier>(
      LazilyResolvedBlankNodeOrIriInterface,
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriInterfaces(
    query?: $SparqlObjectSet.Query<LazilyResolvedBlankNodeOrIriInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedBlankNodeOrIriInterface[]>
  > {
    return this.$objects<
      LazilyResolvedBlankNodeOrIriInterface,
      LazilyResolvedBlankNodeOrIriInterface.$Identifier
    >(LazilyResolvedBlankNodeOrIriInterface, query);
  }

  async lazilyResolvedBlankNodeOrIriInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedBlankNodeOrIriInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedBlankNodeOrIriInterface.$Identifier>(
      LazilyResolvedBlankNodeOrIriInterface,
      query,
    );
  }

  async lazilyResolvedClassUnionMember1(
    identifier: LazilyResolvedClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember1>> {
    return (
      await this.lazilyResolvedClassUnionMember1s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember1.$Identifier[]>
  > {
    return this.$objectIdentifiers<LazilyResolvedClassUnionMember1.$Identifier>(
      LazilyResolvedClassUnionMember1,
      query,
    );
  }

  async lazilyResolvedClassUnionMember1s(
    query?: $SparqlObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember1[]>> {
    return this.$objects<
      LazilyResolvedClassUnionMember1,
      LazilyResolvedClassUnionMember1.$Identifier
    >(LazilyResolvedClassUnionMember1, query);
  }

  async lazilyResolvedClassUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedClassUnionMember1.$Identifier>(
      LazilyResolvedClassUnionMember1,
      query,
    );
  }

  async lazilyResolvedClassUnionMember2(
    identifier: LazilyResolvedClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember2>> {
    return (
      await this.lazilyResolvedClassUnionMember2s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember2.$Identifier[]>
  > {
    return this.$objectIdentifiers<LazilyResolvedClassUnionMember2.$Identifier>(
      LazilyResolvedClassUnionMember2,
      query,
    );
  }

  async lazilyResolvedClassUnionMember2s(
    query?: $SparqlObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember2[]>> {
    return this.$objects<
      LazilyResolvedClassUnionMember2,
      LazilyResolvedClassUnionMember2.$Identifier
    >(LazilyResolvedClassUnionMember2, query);
  }

  async lazilyResolvedClassUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedClassUnionMember2.$Identifier>(
      LazilyResolvedClassUnionMember2,
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember1(
    identifier: LazilyResolvedInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember1>> {
    return (
      await this.lazilyResolvedInterfaceUnionMember1s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember1.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<LazilyResolvedInterfaceUnionMember1.$Identifier>(
      LazilyResolvedInterfaceUnionMember1,
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember1s(
    query?: $SparqlObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember1[]>
  > {
    return this.$objects<
      LazilyResolvedInterfaceUnionMember1,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >(LazilyResolvedInterfaceUnionMember1, query);
  }

  async lazilyResolvedInterfaceUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedInterfaceUnionMember1.$Identifier>(
      LazilyResolvedInterfaceUnionMember1,
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember2(
    identifier: LazilyResolvedInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember2>> {
    return (
      await this.lazilyResolvedInterfaceUnionMember2s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember2.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<LazilyResolvedInterfaceUnionMember2.$Identifier>(
      LazilyResolvedInterfaceUnionMember2,
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember2s(
    query?: $SparqlObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember2[]>
  > {
    return this.$objects<
      LazilyResolvedInterfaceUnionMember2,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >(LazilyResolvedInterfaceUnionMember2, query);
  }

  async lazilyResolvedInterfaceUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedInterfaceUnionMember2.$Identifier>(
      LazilyResolvedInterfaceUnionMember2,
      query,
    );
  }

  async lazilyResolvedIriClass(
    identifier: LazilyResolvedIriClass.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriClass>> {
    return (
      await this.lazilyResolvedIriClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedIriClassIdentifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedIriClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<LazilyResolvedIriClass.$Identifier>(
      LazilyResolvedIriClass,
      query,
    );
  }

  async lazilyResolvedIriClasses(
    query?: $SparqlObjectSet.Query<LazilyResolvedIriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedIriClass[]>> {
    return this.$objects<
      LazilyResolvedIriClass,
      LazilyResolvedIriClass.$Identifier
    >(LazilyResolvedIriClass, query);
  }

  async lazilyResolvedIriClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedIriClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedIriClass.$Identifier>(
      LazilyResolvedIriClass,
      query,
    );
  }

  async lazilyResolvedIriInterface(
    identifier: LazilyResolvedIriInterface.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriInterface>> {
    return (
      await this.lazilyResolvedIriInterfaces({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedIriInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedIriInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriInterface.$Identifier[]>
  > {
    return this.$objectIdentifiers<LazilyResolvedIriInterface.$Identifier>(
      LazilyResolvedIriInterface,
      query,
    );
  }

  async lazilyResolvedIriInterfaces(
    query?: $SparqlObjectSet.Query<LazilyResolvedIriInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedIriInterface[]>> {
    return this.$objects<
      LazilyResolvedIriInterface,
      LazilyResolvedIriInterface.$Identifier
    >(LazilyResolvedIriInterface, query);
  }

  async lazilyResolvedIriInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedIriInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedIriInterface.$Identifier>(
      LazilyResolvedIriInterface,
      query,
    );
  }

  async lazyPropertiesClass(
    identifier: LazyPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesClass>> {
    return (
      await this.lazyPropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazyPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<LazyPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<LazyPropertiesClass.$Identifier>(
      LazyPropertiesClass,
      query,
    );
  }

  async lazyPropertiesClasses(
    query?: $SparqlObjectSet.Query<LazyPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass[]>> {
    return this.$objects<LazyPropertiesClass, LazyPropertiesClass.$Identifier>(
      LazyPropertiesClass,
      query,
    );
  }

  async lazyPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazyPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazyPropertiesClass.$Identifier>(
      LazyPropertiesClass,
      query,
    );
  }

  async lazyPropertiesInterface(
    identifier: LazyPropertiesInterface.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesInterface>> {
    return (
      await this.lazyPropertiesInterfaces({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazyPropertiesInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<LazyPropertiesInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazyPropertiesInterface.$Identifier[]>
  > {
    return this.$objectIdentifiers<LazyPropertiesInterface.$Identifier>(
      LazyPropertiesInterface,
      query,
    );
  }

  async lazyPropertiesInterfaces(
    query?: $SparqlObjectSet.Query<LazyPropertiesInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesInterface[]>> {
    return this.$objects<
      LazyPropertiesInterface,
      LazyPropertiesInterface.$Identifier
    >(LazyPropertiesInterface, query);
  }

  async lazyPropertiesInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazyPropertiesInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazyPropertiesInterface.$Identifier>(
      LazyPropertiesInterface,
      query,
    );
  }

  async listPropertiesClass(
    identifier: ListPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ListPropertiesClass>> {
    return (
      await this.listPropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async listPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<ListPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<ListPropertiesClass.$Identifier>(
      ListPropertiesClass,
      query,
    );
  }

  async listPropertiesClasses(
    query?: $SparqlObjectSet.Query<ListPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass[]>> {
    return this.$objects<ListPropertiesClass, ListPropertiesClass.$Identifier>(
      ListPropertiesClass,
      query,
    );
  }

  async listPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ListPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ListPropertiesClass.$Identifier>(
      ListPropertiesClass,
      query,
    );
  }

  async mutablePropertiesClass(
    identifier: MutablePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, MutablePropertiesClass>> {
    return (
      await this.mutablePropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async mutablePropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<MutablePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly MutablePropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<MutablePropertiesClass.$Identifier>(
      MutablePropertiesClass,
      query,
    );
  }

  async mutablePropertiesClasses(
    query?: $SparqlObjectSet.Query<MutablePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly MutablePropertiesClass[]>> {
    return this.$objects<
      MutablePropertiesClass,
      MutablePropertiesClass.$Identifier
    >(MutablePropertiesClass, query);
  }

  async mutablePropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<MutablePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<MutablePropertiesClass.$Identifier>(
      MutablePropertiesClass,
      query,
    );
  }

  async narrowedIdentifierClass(
    identifier: NarrowedIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, NarrowedIdentifierClass>> {
    return (
      await this.narrowedIdentifierClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async narrowedIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<NarrowedIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly NarrowedIdentifierClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<NarrowedIdentifierClass.$Identifier>(
      NarrowedIdentifierClass,
      query,
    );
  }

  async narrowedIdentifierClasses(
    query?: $SparqlObjectSet.Query<NarrowedIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly NarrowedIdentifierClass[]>> {
    return this.$objects<
      NarrowedIdentifierClass,
      NarrowedIdentifierClass.$Identifier
    >(NarrowedIdentifierClass, query);
  }

  async narrowedIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<NarrowedIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<NarrowedIdentifierClass.$Identifier>(
      NarrowedIdentifierClass,
      query,
    );
  }

  async nonClass(
    identifier: NonClass.$Identifier,
  ): Promise<purify.Either<Error, NonClass>> {
    return (
      await this.nonClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async nonClassIdentifiers(
    query?: $SparqlObjectSet.Query<NonClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly NonClass.$Identifier[]>> {
    return this.$objectIdentifiers<NonClass.$Identifier>(NonClass, query);
  }

  async nonClasses(
    query?: $SparqlObjectSet.Query<NonClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly NonClass[]>> {
    return this.$objects<NonClass, NonClass.$Identifier>(NonClass, query);
  }

  async nonClassesCount(
    query?: Pick<$SparqlObjectSet.Query<NonClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<NonClass.$Identifier>(NonClass, query);
  }

  async orderedPropertiesClass(
    identifier: OrderedPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, OrderedPropertiesClass>> {
    return (
      await this.orderedPropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async orderedPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<OrderedPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly OrderedPropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<OrderedPropertiesClass.$Identifier>(
      OrderedPropertiesClass,
      query,
    );
  }

  async orderedPropertiesClasses(
    query?: $SparqlObjectSet.Query<OrderedPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly OrderedPropertiesClass[]>> {
    return this.$objects<
      OrderedPropertiesClass,
      OrderedPropertiesClass.$Identifier
    >(OrderedPropertiesClass, query);
  }

  async orderedPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<OrderedPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<OrderedPropertiesClass.$Identifier>(
      OrderedPropertiesClass,
      query,
    );
  }

  async partialClass(
    identifier: PartialClass.$Identifier,
  ): Promise<purify.Either<Error, PartialClass>> {
    return (
      await this.partialClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async partialClassIdentifiers(
    query?: $SparqlObjectSet.Query<PartialClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClass.$Identifier[]>> {
    return this.$objectIdentifiers<PartialClass.$Identifier>(
      PartialClass,
      query,
    );
  }

  async partialClasses(
    query?: $SparqlObjectSet.Query<PartialClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClass[]>> {
    return this.$objects<PartialClass, PartialClass.$Identifier>(
      PartialClass,
      query,
    );
  }

  async partialClassesCount(
    query?: Pick<$SparqlObjectSet.Query<PartialClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialClass.$Identifier>(PartialClass, query);
  }

  async partialClassUnionMember1(
    identifier: PartialClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember1>> {
    return (
      await this.partialClassUnionMember1s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async partialClassUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<PartialClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember1.$Identifier[]>
  > {
    return this.$objectIdentifiers<PartialClassUnionMember1.$Identifier>(
      PartialClassUnionMember1,
      query,
    );
  }

  async partialClassUnionMember1s(
    query?: $SparqlObjectSet.Query<PartialClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember1[]>> {
    return this.$objects<
      PartialClassUnionMember1,
      PartialClassUnionMember1.$Identifier
    >(PartialClassUnionMember1, query);
  }

  async partialClassUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<PartialClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialClassUnionMember1.$Identifier>(
      PartialClassUnionMember1,
      query,
    );
  }

  async partialClassUnionMember2(
    identifier: PartialClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember2>> {
    return (
      await this.partialClassUnionMember2s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async partialClassUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<PartialClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember2.$Identifier[]>
  > {
    return this.$objectIdentifiers<PartialClassUnionMember2.$Identifier>(
      PartialClassUnionMember2,
      query,
    );
  }

  async partialClassUnionMember2s(
    query?: $SparqlObjectSet.Query<PartialClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember2[]>> {
    return this.$objects<
      PartialClassUnionMember2,
      PartialClassUnionMember2.$Identifier
    >(PartialClassUnionMember2, query);
  }

  async partialClassUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<PartialClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialClassUnionMember2.$Identifier>(
      PartialClassUnionMember2,
      query,
    );
  }

  async partialInterface(
    identifier: PartialInterface.$Identifier,
  ): Promise<purify.Either<Error, PartialInterface>> {
    return (
      await this.partialInterfaces({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async partialInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<PartialInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterface.$Identifier[]>> {
    return this.$objectIdentifiers<PartialInterface.$Identifier>(
      PartialInterface,
      query,
    );
  }

  async partialInterfaces(
    query?: $SparqlObjectSet.Query<PartialInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterface[]>> {
    return this.$objects<PartialInterface, PartialInterface.$Identifier>(
      PartialInterface,
      query,
    );
  }

  async partialInterfacesCount(
    query?: Pick<$SparqlObjectSet.Query<PartialInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialInterface.$Identifier>(
      PartialInterface,
      query,
    );
  }

  async partialInterfaceUnionMember1(
    identifier: PartialInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember1>> {
    return (
      await this.partialInterfaceUnionMember1s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async partialInterfaceUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember1.$Identifier[]>
  > {
    return this.$objectIdentifiers<PartialInterfaceUnionMember1.$Identifier>(
      PartialInterfaceUnionMember1,
      query,
    );
  }

  async partialInterfaceUnionMember1s(
    query?: $SparqlObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember1[]>> {
    return this.$objects<
      PartialInterfaceUnionMember1,
      PartialInterfaceUnionMember1.$Identifier
    >(PartialInterfaceUnionMember1, query);
  }

  async partialInterfaceUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialInterfaceUnionMember1.$Identifier>(
      PartialInterfaceUnionMember1,
      query,
    );
  }

  async partialInterfaceUnionMember2(
    identifier: PartialInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember2>> {
    return (
      await this.partialInterfaceUnionMember2s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async partialInterfaceUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember2.$Identifier[]>
  > {
    return this.$objectIdentifiers<PartialInterfaceUnionMember2.$Identifier>(
      PartialInterfaceUnionMember2,
      query,
    );
  }

  async partialInterfaceUnionMember2s(
    query?: $SparqlObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember2[]>> {
    return this.$objects<
      PartialInterfaceUnionMember2,
      PartialInterfaceUnionMember2.$Identifier
    >(PartialInterfaceUnionMember2, query);
  }

  async partialInterfaceUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialInterfaceUnionMember2.$Identifier>(
      PartialInterfaceUnionMember2,
      query,
    );
  }

  async propertyCardinalitiesClass(
    identifier: PropertyCardinalitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyCardinalitiesClass>> {
    return (
      await this.propertyCardinalitiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async propertyCardinalitiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PropertyCardinalitiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<PropertyCardinalitiesClass.$Identifier>(
      PropertyCardinalitiesClass,
      query,
    );
  }

  async propertyCardinalitiesClasses(
    query?: $SparqlObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PropertyCardinalitiesClass[]>> {
    return this.$objects<
      PropertyCardinalitiesClass,
      PropertyCardinalitiesClass.$Identifier
    >(PropertyCardinalitiesClass, query);
  }

  async propertyCardinalitiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PropertyCardinalitiesClass.$Identifier>(
      PropertyCardinalitiesClass,
      query,
    );
  }

  async propertyVisibilitiesClass(
    identifier: PropertyVisibilitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyVisibilitiesClass>> {
    return (
      await this.propertyVisibilitiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async propertyVisibilitiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PropertyVisibilitiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<PropertyVisibilitiesClass.$Identifier>(
      PropertyVisibilitiesClass,
      query,
    );
  }

  async propertyVisibilitiesClasses(
    query?: $SparqlObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PropertyVisibilitiesClass[]>> {
    return this.$objects<
      PropertyVisibilitiesClass,
      PropertyVisibilitiesClass.$Identifier
    >(PropertyVisibilitiesClass, query);
  }

  async propertyVisibilitiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PropertyVisibilitiesClass.$Identifier>(
      PropertyVisibilitiesClass,
      query,
    );
  }

  async recursiveClassUnionMember1(
    identifier: RecursiveClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember1>> {
    return (
      await this.recursiveClassUnionMember1s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async recursiveClassUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember1.$Identifier[]>
  > {
    return this.$objectIdentifiers<RecursiveClassUnionMember1.$Identifier>(
      RecursiveClassUnionMember1,
      query,
    );
  }

  async recursiveClassUnionMember1s(
    query?: $SparqlObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember1[]>> {
    return this.$objects<
      RecursiveClassUnionMember1,
      RecursiveClassUnionMember1.$Identifier
    >(RecursiveClassUnionMember1, query);
  }

  async recursiveClassUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<RecursiveClassUnionMember1.$Identifier>(
      RecursiveClassUnionMember1,
      query,
    );
  }

  async recursiveClassUnionMember2(
    identifier: RecursiveClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember2>> {
    return (
      await this.recursiveClassUnionMember2s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async recursiveClassUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember2.$Identifier[]>
  > {
    return this.$objectIdentifiers<RecursiveClassUnionMember2.$Identifier>(
      RecursiveClassUnionMember2,
      query,
    );
  }

  async recursiveClassUnionMember2s(
    query?: $SparqlObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember2[]>> {
    return this.$objects<
      RecursiveClassUnionMember2,
      RecursiveClassUnionMember2.$Identifier
    >(RecursiveClassUnionMember2, query);
  }

  async recursiveClassUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<RecursiveClassUnionMember2.$Identifier>(
      RecursiveClassUnionMember2,
      query,
    );
  }

  async sha256IriClass(
    identifier: Sha256IriClass.$Identifier,
  ): Promise<purify.Either<Error, Sha256IriClass>> {
    return (
      await this.sha256IriClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async sha256IriClassIdentifiers(
    query?: $SparqlObjectSet.Query<Sha256IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly Sha256IriClass.$Identifier[]>> {
    return this.$objectIdentifiers<Sha256IriClass.$Identifier>(
      Sha256IriClass,
      query,
    );
  }

  async sha256IriClasses(
    query?: $SparqlObjectSet.Query<Sha256IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly Sha256IriClass[]>> {
    return this.$objects<Sha256IriClass, Sha256IriClass.$Identifier>(
      Sha256IriClass,
      query,
    );
  }

  async sha256IriClassesCount(
    query?: Pick<$SparqlObjectSet.Query<Sha256IriClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<Sha256IriClass.$Identifier>(
      Sha256IriClass,
      query,
    );
  }

  async termPropertiesClass(
    identifier: TermPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, TermPropertiesClass>> {
    return (
      await this.termPropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async termPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<TermPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<TermPropertiesClass.$Identifier>(
      TermPropertiesClass,
      query,
    );
  }

  async termPropertiesClasses(
    query?: $SparqlObjectSet.Query<TermPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass[]>> {
    return this.$objects<TermPropertiesClass, TermPropertiesClass.$Identifier>(
      TermPropertiesClass,
      query,
    );
  }

  async termPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<TermPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<TermPropertiesClass.$Identifier>(
      TermPropertiesClass,
      query,
    );
  }

  async unionPropertiesClass(
    identifier: UnionPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, UnionPropertiesClass>> {
    return (
      await this.unionPropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async unionPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<UnionPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly UnionPropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<UnionPropertiesClass.$Identifier>(
      UnionPropertiesClass,
      query,
    );
  }

  async unionPropertiesClasses(
    query?: $SparqlObjectSet.Query<UnionPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly UnionPropertiesClass[]>> {
    return this.$objects<
      UnionPropertiesClass,
      UnionPropertiesClass.$Identifier
    >(UnionPropertiesClass, query);
  }

  async unionPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<UnionPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<UnionPropertiesClass.$Identifier>(
      UnionPropertiesClass,
      query,
    );
  }

  async uuidV4IriClass(
    identifier: UuidV4IriClass.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriClass>> {
    return (
      await this.uuidV4IriClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async uuidV4IriClassIdentifiers(
    query?: $SparqlObjectSet.Query<UuidV4IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriClass.$Identifier[]>> {
    return this.$objectIdentifiers<UuidV4IriClass.$Identifier>(
      UuidV4IriClass,
      query,
    );
  }

  async uuidV4IriClasses(
    query?: $SparqlObjectSet.Query<UuidV4IriClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriClass[]>> {
    return this.$objects<UuidV4IriClass, UuidV4IriClass.$Identifier>(
      UuidV4IriClass,
      query,
    );
  }

  async uuidV4IriClassesCount(
    query?: Pick<$SparqlObjectSet.Query<UuidV4IriClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<UuidV4IriClass.$Identifier>(
      UuidV4IriClass,
      query,
    );
  }

  async uuidV4IriInterface(
    identifier: UuidV4IriInterface.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriInterface>> {
    return (
      await this.uuidV4IriInterfaces({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async uuidV4IriInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<UuidV4IriInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriInterface.$Identifier[]>> {
    return this.$objectIdentifiers<UuidV4IriInterface.$Identifier>(
      UuidV4IriInterface,
      query,
    );
  }

  async uuidV4IriInterfaces(
    query?: $SparqlObjectSet.Query<UuidV4IriInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriInterface[]>> {
    return this.$objects<UuidV4IriInterface, UuidV4IriInterface.$Identifier>(
      UuidV4IriInterface,
      query,
    );
  }

  async uuidV4IriInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<UuidV4IriInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<UuidV4IriInterface.$Identifier>(
      UuidV4IriInterface,
      query,
    );
  }

  async wideIdentifierClass(
    identifier: WideIdentifierClassStatic.$Identifier,
  ): Promise<purify.Either<Error, WideIdentifierClass>> {
    return (
      await this.wideIdentifierClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async wideIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<WideIdentifierClassStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly WideIdentifierClassStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<WideIdentifierClassStatic.$Identifier>(
      WideIdentifierClassStatic,
      query,
    );
  }

  async wideIdentifierClasses(
    query?: $SparqlObjectSet.Query<WideIdentifierClassStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly WideIdentifierClass[]>> {
    return this.$objects<
      WideIdentifierClass,
      WideIdentifierClassStatic.$Identifier
    >(WideIdentifierClassStatic, query);
  }

  async wideIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<WideIdentifierClassStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<WideIdentifierClassStatic.$Identifier>(
      WideIdentifierClassStatic,
      query,
    );
  }

  async classUnion(
    identifier: ClassUnion.$Identifier,
  ): Promise<purify.Either<Error, ClassUnion>> {
    return (
      await this.classUnions({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async classUnionIdentifiers(
    query?: $SparqlObjectSet.Query<ClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnion.$Identifier[]>> {
    return this.$objectIdentifiers<ClassUnion.$Identifier>(ClassUnion, query);
  }

  async classUnions(
    query?: $SparqlObjectSet.Query<ClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnion[]>> {
    return this.$objects<ClassUnion, ClassUnion.$Identifier>(ClassUnion, query);
  }

  async classUnionsCount(
    query?: Pick<$SparqlObjectSet.Query<ClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ClassUnion.$Identifier>(ClassUnion, query);
  }

  async interfaceUnion(
    identifier: InterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnion>> {
    return (
      await this.interfaceUnions({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async interfaceUnionIdentifiers(
    query?: $SparqlObjectSet.Query<InterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion.$Identifier[]>> {
    return this.$objectIdentifiers<InterfaceUnion.$Identifier>(
      InterfaceUnion,
      query,
    );
  }

  async interfaceUnions(
    query?: $SparqlObjectSet.Query<InterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion[]>> {
    return this.$objects<InterfaceUnion, InterfaceUnion.$Identifier>(
      InterfaceUnion,
      query,
    );
  }

  async interfaceUnionsCount(
    query?: Pick<$SparqlObjectSet.Query<InterfaceUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<InterfaceUnion.$Identifier>(
      InterfaceUnion,
      query,
    );
  }

  async interfaceUnionMember2(
    identifier: InterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember2>> {
    return (
      await this.interfaceUnionMember2s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async interfaceUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<InterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember2.$Identifier[]>
  > {
    return this.$objectIdentifiers<InterfaceUnionMember2.$Identifier>(
      InterfaceUnionMember2,
      query,
    );
  }

  async interfaceUnionMember2s(
    query?: $SparqlObjectSet.Query<InterfaceUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember2[]>> {
    return this.$objects<
      InterfaceUnionMember2,
      InterfaceUnionMember2.$Identifier
    >(InterfaceUnionMember2, query);
  }

  async interfaceUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<InterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<InterfaceUnionMember2.$Identifier>(
      InterfaceUnionMember2,
      query,
    );
  }

  async lazilyResolvedClassUnion(
    identifier: LazilyResolvedClassUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnion>> {
    return (
      await this.lazilyResolvedClassUnions({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionIdentifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnion.$Identifier[]>
  > {
    return this.$objectIdentifiers<LazilyResolvedClassUnion.$Identifier>(
      LazilyResolvedClassUnion,
      query,
    );
  }

  async lazilyResolvedClassUnions(
    query?: $SparqlObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnion[]>> {
    return this.$objects<
      LazilyResolvedClassUnion,
      LazilyResolvedClassUnion.$Identifier
    >(LazilyResolvedClassUnion, query);
  }

  async lazilyResolvedClassUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedClassUnion.$Identifier>(
      LazilyResolvedClassUnion,
      query,
    );
  }

  async lazilyResolvedInterfaceUnion(
    identifier: LazilyResolvedInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnion>> {
    return (
      await this.lazilyResolvedInterfaceUnions({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionIdentifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnion.$Identifier[]>
  > {
    return this.$objectIdentifiers<LazilyResolvedInterfaceUnion.$Identifier>(
      LazilyResolvedInterfaceUnion,
      query,
    );
  }

  async lazilyResolvedInterfaceUnions(
    query?: $SparqlObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedInterfaceUnion[]>> {
    return this.$objects<
      LazilyResolvedInterfaceUnion,
      LazilyResolvedInterfaceUnion.$Identifier
    >(LazilyResolvedInterfaceUnion, query);
  }

  async lazilyResolvedInterfaceUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedInterfaceUnion.$Identifier>(
      LazilyResolvedInterfaceUnion,
      query,
    );
  }

  async partialClassUnion(
    identifier: PartialClassUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnion>> {
    return (
      await this.partialClassUnions({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async partialClassUnionIdentifiers(
    query?: $SparqlObjectSet.Query<PartialClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion.$Identifier[]>> {
    return this.$objectIdentifiers<PartialClassUnion.$Identifier>(
      PartialClassUnion,
      query,
    );
  }

  async partialClassUnions(
    query?: $SparqlObjectSet.Query<PartialClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion[]>> {
    return this.$objects<PartialClassUnion, PartialClassUnion.$Identifier>(
      PartialClassUnion,
      query,
    );
  }

  async partialClassUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<PartialClassUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialClassUnion.$Identifier>(
      PartialClassUnion,
      query,
    );
  }

  async partialInterfaceUnion(
    identifier: PartialInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnion>> {
    return (
      await this.partialInterfaceUnions({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async partialInterfaceUnionIdentifiers(
    query?: $SparqlObjectSet.Query<PartialInterfaceUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnion.$Identifier[]>
  > {
    return this.$objectIdentifiers<PartialInterfaceUnion.$Identifier>(
      PartialInterfaceUnion,
      query,
    );
  }

  async partialInterfaceUnions(
    query?: $SparqlObjectSet.Query<PartialInterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnion[]>> {
    return this.$objects<
      PartialInterfaceUnion,
      PartialInterfaceUnion.$Identifier
    >(PartialInterfaceUnion, query);
  }

  async partialInterfaceUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<PartialInterfaceUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialInterfaceUnion.$Identifier>(
      PartialInterfaceUnion,
      query,
    );
  }

  async recursiveClassUnion(
    identifier: RecursiveClassUnion.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnion>> {
    return (
      await this.recursiveClassUnions({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async recursiveClassUnionIdentifiers(
    query?: $SparqlObjectSet.Query<RecursiveClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion.$Identifier[]>> {
    return this.$objectIdentifiers<RecursiveClassUnion.$Identifier>(
      RecursiveClassUnion,
      query,
    );
  }

  async recursiveClassUnions(
    query?: $SparqlObjectSet.Query<RecursiveClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion[]>> {
    return this.$objects<RecursiveClassUnion, RecursiveClassUnion.$Identifier>(
      RecursiveClassUnion,
      query,
    );
  }

  async recursiveClassUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<RecursiveClassUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<RecursiveClassUnion.$Identifier>(
      RecursiveClassUnion,
      query,
    );
  }

  protected $mapBindingsToCount(
    bindings: readonly Record<
      string,
      rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
    >[],
    variable: string,
  ): purify.Either<Error, number> {
    if (bindings.length === 0) {
      return purify.Left(new Error("empty result rows"));
    }
    if (bindings.length > 1) {
      return purify.Left(new Error("more than one result row"));
    }
    const count = bindings[0][variable];
    if (typeof count === "undefined") {
      return purify.Left(new Error("no 'count' variable in result row"));
    }
    if (count.termType !== "Literal") {
      return purify.Left(new Error("'count' variable is not a Literal"));
    }
    const parsedCount = Number.parseInt(count.value);
    if (Number.isNaN(parsedCount)) {
      return purify.Left(new Error("'count' variable is NaN"));
    }
    return purify.Either.of(parsedCount);
  }

  protected $mapBindingsToIdentifiers(
    bindings: readonly Record<
      string,
      rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
    >[],
    variable: string,
  ): readonly rdfjs.NamedNode[] {
    const identifiers: rdfjs.NamedNode[] = [];
    for (const bindings_ of bindings) {
      const identifier = bindings_[variable];
      if (
        typeof identifier !== "undefined" &&
        identifier.termType === "NamedNode"
      ) {
        identifiers.push(identifier);
      }
    }
    return identifiers;
  }

  protected async $objectIdentifiers<
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectType: {
      $sparqlWherePatterns: (parameters?: {
        subject?: sparqljs.Triple["subject"];
      }) => readonly sparqljs.Pattern[];
    },
    query?: $SparqlObjectSet.Query<ObjectIdentifierT>,
  ): Promise<purify.Either<Error, readonly ObjectIdentifierT[]>> {
    const limit = query?.limit ?? Number.MAX_SAFE_INTEGER;
    if (limit <= 0) {
      return purify.Either.of([]);
    }

    let offset = query?.offset ?? 0;
    if (offset < 0) {
      offset = 0;
    }

    const wherePatterns = this.$wherePatterns(objectType, query?.where).filter(
      (pattern) => pattern.type !== "optional",
    );
    if (wherePatterns.length === 0) {
      return purify.Left(
        new Error("no required SPARQL WHERE patterns for identifiers"),
      );
    }

    const selectQueryString = this.$sparqlGenerator.stringify({
      distinct: true,
      limit: limit < Number.MAX_SAFE_INTEGER ? limit : undefined,
      offset,
      order: query?.order
        ? query.order(this.$objectVariable).concat()
        : [{ expression: this.$objectVariable }],
      prefixes: {},
      queryType: "SELECT",
      type: "query",
      variables: [this.$objectVariable],
      where: wherePatterns,
    });

    return purify.EitherAsync(
      async () =>
        this.$mapBindingsToIdentifiers(
          await this.$sparqlClient.queryBindings(selectQueryString),
          this.$objectVariable.value,
        ) as readonly ObjectIdentifierT[],
    );
  }

  async $objects<
    ObjectT,
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectType: {
      $fromRdf: (
        resource: rdfjsResource.Resource,
        options: { objectSet: $ObjectSet },
      ) => purify.Either<Error, ObjectT>;
      $sparqlConstructQueryString: (
        parameters?: { subject?: sparqljs.Triple["subject"] } & Omit<
          sparqljs.ConstructQuery,
          "prefixes" | "queryType" | "type"
        > &
          sparqljs.GeneratorOptions,
      ) => string;
      $sparqlWherePatterns: (parameters?: {
        subject?: sparqljs.Triple["subject"];
      }) => readonly sparqljs.Pattern[];
    },
    query?: $SparqlObjectSet.Query<ObjectIdentifierT>,
  ): Promise<purify.Either<Error, readonly ObjectT[]>> {
    const identifiersEither = await this.$objectIdentifiers<ObjectIdentifierT>(
      objectType,
      query,
    );
    if (identifiersEither.isLeft()) {
      return identifiersEither;
    }
    const identifiers = identifiersEither.unsafeCoerce();
    if (identifiers.length === 0) {
      return purify.Either.of([]);
    }

    const constructQueryString = objectType.$sparqlConstructQueryString({
      subject: this.$objectVariable,
      where: [
        {
          type: "values" as const,
          values: identifiers.map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow["?object"] = identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        },
      ],
    });

    let quads: readonly rdfjs.Quad[];
    try {
      quads = await this.$sparqlClient.queryQuads(constructQueryString);
    } catch (e) {
      return purify.Left(e as Error);
    }

    const dataset = datasetFactory.dataset(quads.concat());
    const objects: ObjectT[] = [];
    for (const identifier of identifiers) {
      const objectEither = objectType.$fromRdf(
        new rdfjsResource.Resource<rdfjs.NamedNode>({
          dataset,
          identifier: identifier as rdfjs.NamedNode,
        }),
        { objectSet: this },
      );
      if (objectEither.isLeft()) {
        return objectEither;
      }
      objects.push(objectEither.unsafeCoerce());
    }
    return purify.Either.of(objects);
  }

  protected async $objectsCount<
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectType: {
      $sparqlWherePatterns: (parameters?: {
        subject?: sparqljs.Triple["subject"];
      }) => readonly sparqljs.Pattern[];
    },
    query?: $SparqlObjectSet.Query<ObjectIdentifierT>,
  ): Promise<purify.Either<Error, number>> {
    const wherePatterns = this.$wherePatterns(objectType, query?.where).filter(
      (pattern) => pattern.type !== "optional",
    );
    if (wherePatterns.length === 0) {
      return purify.Left(
        new Error("no required SPARQL WHERE patterns for count"),
      );
    }

    const selectQueryString = this.$sparqlGenerator.stringify({
      prefixes: {},
      queryType: "SELECT",
      type: "query",
      variables: [
        {
          expression: {
            aggregation: "COUNT",
            distinct: true,
            expression: this.$objectVariable,
            type: "aggregate",
          },
          variable: this.$countVariable,
        },
      ],
      where: wherePatterns,
    });

    return purify.EitherAsync(async ({ liftEither }) =>
      liftEither(
        this.$mapBindingsToCount(
          await this.$sparqlClient.queryBindings(selectQueryString),
          this.$countVariable.value,
        ),
      ),
    );
  }

  protected $wherePatterns<
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectType: {
      $sparqlWherePatterns: (parameters?: {
        subject?: sparqljs.Triple["subject"];
      }) => readonly sparqljs.Pattern[];
    },
    where?: $SparqlObjectSet.Where<ObjectIdentifierT>,
  ): sparqljs.Pattern[] {
    // Patterns should be most to least specific.
    const patterns: sparqljs.Pattern[] = [];

    const where_ = where ?? { type: "type" };
    switch (where_.type) {
      case "identifiers": {
        const valuePatternRowKey = `?${this.$objectVariable.value}`;
        patterns.push({
          type: "values" as const,
          values: where_.identifiers.map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[valuePatternRowKey] = identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        });
        break;
      }

      case "sparql-patterns": {
        patterns.push(...where_.sparqlPatterns(this.$objectVariable));
        break;
      }

      case "triple-objects": {
        patterns.push({
          triples: [
            {
              subject: where_.subject ?? dataFactory.blankNode(),
              predicate: where_.predicate,
              object: this.$objectVariable,
            },
          ],
          type: "bgp",
        });

        if (where_.objectTermType === "NamedNode") {
          patterns.push({
            type: "filter" as const,
            expression: {
              type: "operation" as const,
              operator: "isIRI",
              args: [this.$objectVariable],
            },
          });
        }

        break;
      }

      case "triple-subjects": {
        patterns.push({
          triples: [
            {
              subject: this.$objectVariable,
              predicate: where_.predicate,
              object: where_.object ?? dataFactory.blankNode(),
            },
          ],
          type: "bgp",
        });

        if (where_.subjectTermType === "NamedNode") {
          patterns.push({
            type: "filter" as const,
            expression: {
              type: "operation" as const,
              operator: "isIRI",
              args: [this.$objectVariable],
            },
          });
        }

        break;
      }

      case "type": {
        // The type patterns are always added below.

        if (where_.identifierType === "NamedNode") {
          patterns.push({
            type: "filter" as const,
            expression: {
              type: "operation" as const,
              operator: "isIRI",
              args: [this.$objectVariable],
            },
          });
        }
        break;
      }
    }

    patterns.push(
      ...objectType.$sparqlWherePatterns({ subject: this.$objectVariable }),
    );

    return patterns;
  }
}

export namespace $SparqlObjectSet {
  export type Query<
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  > = Omit<$ObjectSet.Query<ObjectIdentifierT>, "where"> & {
    readonly order?: (
      objectVariable: rdfjs.Variable,
    ) => readonly sparqljs.Ordering[];
    readonly where?: Where<ObjectIdentifierT>;
  };
  export type Where<
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  > =
    | $ObjectSet.Where<ObjectIdentifierT>
    | {
        readonly sparqlPatterns: (
          objectVariable: rdfjs.Variable,
        ) => readonly sparqljs.Pattern[];
        readonly type: "sparql-patterns";
      };
}
