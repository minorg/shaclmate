import type {
  BlankNode,
  DatasetCore,
  Literal,
  NamedNode,
  Quad,
  Quad_Graph,
  Variable,
} from "@rdfjs/types";
import { sha256 } from "js-sha256";
import { StoreFactory as DatasetFactory, DataFactory as dataFactory } from "n3";
import { Either, EitherAsync, Left, Maybe, NonEmptyList } from "purify-ts";
import { LiteralFactory, Resource, ResourceSet } from "rdfjs-resource";
import * as sparqljs from "sparqljs";
import * as uuid from "uuid";
import { z } from "zod";

/**
 * Compare two arrays element-wise with the provided elementEquals function.
 */
function $arrayEquals<T>(
  leftArray: readonly T[],
  rightArray: readonly T[],
  elementEquals: (left: T, right: T) => boolean | $EqualsResult,
): $EqualsResult {
  if (leftArray.length !== rightArray.length) {
    return Left({ left: leftArray, right: rightArray, type: "array-length" });
  }

  for (
    let leftElementIndex = 0;
    leftElementIndex < leftArray.length;
    leftElementIndex++
  ) {
    const leftElement = leftArray[leftElementIndex];

    const rightUnequals: $EqualsResult.Unequal[] = [];
    for (
      let rightElementIndex = 0;
      rightElementIndex < rightArray.length;
      rightElementIndex++
    ) {
      const rightElement = rightArray[rightElementIndex];

      const leftElementEqualsRightElement =
        $EqualsResult.fromBooleanEqualsResult(
          leftElement,
          rightElement,
          elementEquals(leftElement, rightElement),
        );
      if (leftElementEqualsRightElement.isRight()) {
        break; // left element === right element, break out of the right iteration
      }
      rightUnequals.push(
        leftElementEqualsRightElement.extract() as $EqualsResult.Unequal,
      );
    }

    if (rightUnequals.length === rightArray.length) {
      // All right elements were unequal to the left element
      return Left({
        left: {
          array: leftArray,
          element: leftElement,
          elementIndex: leftElementIndex,
        },
        right: { array: rightArray, unequals: rightUnequals },
        type: "array-element",
      });
    }
    // Else there was a right element equal to the left element, continue to the next left element
  }

  return $EqualsResult.Equal;
}

function $arrayIntersection<T>(
  left: readonly T[],
  right: readonly T[],
): readonly T[] {
  if (left.length === 0) {
    return right;
  }
  if (right.length === 0) {
    return left;
  }

  const intersection = new Set<T>();
  if (left.length <= right.length) {
    const rightSet = new Set(right);
    for (const leftElement of left) {
      if (rightSet.has(leftElement)) {
        intersection.add(leftElement);
      }
    }
  } else {
    const leftSet = new Set(left);
    for (const rightElement of right) {
      if (leftSet.has(rightElement)) {
        intersection.add(rightElement);
      }
    }
  }
  return [...intersection];
}

interface $BlankNodeFilter {}

export function $blankNodeFromString(
  identifier: string,
): Either<Error, BlankNode> {
  return Either.encase(() =>
    Resource.Identifier.fromString({ dataFactory, identifier }),
  ).chain((identifier) =>
    identifier.termType === "BlankNode"
      ? Either.of(identifier)
      : Left(new Error("expected identifier to be BlankNode")),
  ) as Either<Error, BlankNode>;
}

interface $BlankNodeSchema {
  readonly kind: "BlankNode";
}

const $blankNodeSparqlWherePatterns: $SparqlWherePatternsFunction<
  $BlankNodeFilter,
  $BlankNodeSchema
> = ({ propertyPatterns }) => propertyPatterns;

/**
 * Compare two objects with equals(other: T): boolean methods and return an $EqualsResult.
 */
function $booleanEquals<T extends { equals: (other: T) => boolean }>(
  left: T,
  right: T,
): $EqualsResult {
  return $EqualsResult.fromBooleanEqualsResult(left, right, left.equals(right));
}

interface $BooleanFilter {
  readonly value?: boolean;
}

interface $BooleanSchema {
  readonly kind: "Boolean";
  readonly in?: readonly boolean[];
}

const $booleanSparqlWherePatterns: $SparqlWherePatternsFunction<
  $BooleanFilter,
  $BooleanSchema
> = ({ filter, valueVariable, ...otherParameters }) => {
  const filterPatterns: $SparqlFilterPattern[] = [];

  if (filter) {
    if (typeof filter.value !== "undefined") {
      filterPatterns.push(
        $sparqlValueInPattern({
          lift: true,
          valueVariable,
          valueIn: [filter.value],
        }),
      );
    }
  }

  return $termSchemaSparqlPatterns({
    filterPatterns,
    valueVariable,
    ...otherParameters,
  });
};

type $CollectionFilter<ItemFilterT> = ItemFilterT & {
  readonly $maxCount?: number;
  readonly $minCount?: number;
};

interface $CollectionSchema<ItemSchemaT> {
  readonly item: () => ItemSchemaT;
  readonly kind: "List" | "Set";
  readonly minCount?: number;
}

const $datasetFactory = new DatasetFactory();

/**
 * Compare two Dates and return an $EqualsResult.
 */
function $dateEquals(left: Date, right: Date): $EqualsResult {
  return $EqualsResult.fromBooleanEqualsResult(
    left,
    right,
    left.getTime() === right.getTime(),
  );
}

interface $DateFilter {
  readonly in?: readonly Date[];
  readonly maxExclusive?: Date;
  readonly maxInclusive?: Date;
  readonly minExclusive?: Date;
  readonly minInclusive?: Date;
}

interface $DateSchema {
  in?: readonly Date[];
  kind: "Date" | "DateTime";
}

const $dateSparqlWherePatterns: $SparqlWherePatternsFunction<
  $DateFilter,
  $DateSchema
> = ({ filter, valueVariable, ...otherParameters }) => {
  const filterPatterns: $SparqlFilterPattern[] = [];

  if (filter) {
    if (typeof filter.in !== "undefined" && filter.in.length > 0) {
      filterPatterns.push({
        expression: {
          type: "operation",
          operator: "in",
          args: [
            valueVariable,
            filter.in.map((inValue) => $literalFactory.date(inValue)),
          ],
        },
        lift: true,
        type: "filter",
      });
    }

    if (typeof filter.maxExclusive !== "undefined") {
      filterPatterns.push({
        expression: {
          type: "operation",
          operator: "<",
          args: [valueVariable, $literalFactory.date(filter.maxExclusive)],
        },
        lift: true,
        type: "filter",
      });
    }

    if (typeof filter.maxInclusive !== "undefined") {
      filterPatterns.push({
        expression: {
          type: "operation",
          operator: "<=",
          args: [valueVariable, $literalFactory.date(filter.maxInclusive)],
        },
        lift: true,
        type: "filter",
      });
    }

    if (typeof filter.minExclusive !== "undefined") {
      filterPatterns.push({
        expression: {
          type: "operation",
          operator: ">",
          args: [valueVariable, $literalFactory.date(filter.minExclusive)],
        },
        lift: true,
        type: "filter",
      });
    }

    if (typeof filter.minInclusive !== "undefined") {
      filterPatterns.push({
        expression: {
          type: "operation",
          operator: ">=",
          args: [valueVariable, $literalFactory.date(filter.minInclusive)],
        },
        lift: true,
        type: "filter",
      });
    }
  }

  return $termSchemaSparqlPatterns({
    filterPatterns,
    valueVariable,
    ...otherParameters,
  });
};

function $deduplicateSparqlPatterns(
  patterns: readonly $SparqlPattern[],
): readonly $SparqlPattern[] {
  if (patterns.length === 0) {
    return patterns;
  }

  const deduplicatedPatterns: $SparqlPattern[] = [];
  const deduplicatePatternStrings = new Set<string>();
  for (const pattern of patterns) {
    const patternString = JSON.stringify(pattern);
    if (!deduplicatePatternStrings.has(patternString)) {
      deduplicatePatternStrings.add(patternString);
      deduplicatedPatterns.push(pattern);
    }
  }
  return deduplicatedPatterns;
}

interface $DefaultValueSchema<ItemSchemaT> {
  readonly defaultValue: Literal | NamedNode;
  readonly item: () => ItemSchemaT;
  readonly kind: "DefaultValue";
}

function $defaultValueSparqlWherePatterns<ItemFilterT, ItemSchemaT>(
  itemSparqlWherePatternsFunction: $SparqlWherePatternsFunction<
    ItemFilterT,
    ItemSchemaT
  >,
): $SparqlWherePatternsFunction<ItemFilterT, $DefaultValueSchema<ItemSchemaT>> {
  return ({ schema, ...otherParameters }) => {
    const [itemSparqlWherePatterns, liftSparqlPatterns] = $liftSparqlPatterns(
      itemSparqlWherePatternsFunction({
        schema: schema.item(),
        ...otherParameters,
      }),
    );
    return [
      { patterns: itemSparqlWherePatterns.concat(), type: "optional" },
      ...liftSparqlPatterns,
    ];
  };
}

export type $EqualsResult = Either<$EqualsResult.Unequal, true>;

export namespace $EqualsResult {
  export const Equal: $EqualsResult = Either.of<Unequal, true>(true);

  export function fromBooleanEqualsResult(
    left: any,
    right: any,
    equalsResult: boolean | $EqualsResult,
  ): $EqualsResult {
    if (typeof equalsResult !== "boolean") {
      return equalsResult;
    }

    if (equalsResult) {
      return Equal;
    }

    return Left({ left, right, type: "boolean" });
  }

  export type Unequal =
    | {
        readonly left: {
          readonly array: readonly any[];
          readonly element: any;
          readonly elementIndex: number;
        };
        readonly right: {
          readonly array: readonly any[];
          readonly unequals: readonly Unequal[];
        };
        readonly type: "array-element";
      }
    | {
        readonly left: readonly any[];
        readonly right: readonly any[];
        readonly type: "array-length";
      }
    | { readonly left: any; readonly right: any; readonly type: "boolean" }
    | { readonly right: any; readonly type: "left-null" }
    | {
        readonly left: any;
        readonly right: any;
        readonly propertyName: string;
        readonly propertyValuesUnequal: Unequal;
        readonly type: "property";
      }
    | { readonly left: any; readonly type: "right-null" };
}

function $filterArray<ItemT, ItemFilterT>(
  filterItem: (itemFilter: ItemFilterT, item: ItemT) => boolean,
) {
  return (
    filter: $CollectionFilter<ItemFilterT>,
    values: readonly ItemT[],
  ): boolean => {
    for (const value of values) {
      if (!filterItem(filter, value)) {
        return false;
      }
    }

    if (
      typeof filter.$maxCount !== "undefined" &&
      values.length > filter.$maxCount
    ) {
      return false;
    }

    if (
      typeof filter.$minCount !== "undefined" &&
      values.length < filter.$minCount
    ) {
      return false;
    }

    return true;
  };
}

function $filterBlankNode(_filter: $BlankNodeFilter, _value: BlankNode) {
  return true;
}

function $filterBoolean(filter: $BooleanFilter, value: boolean) {
  if (typeof filter.value !== "undefined" && value !== filter.value) {
    return false;
  }

  return true;
}

function $filterDate(filter: $DateFilter, value: Date) {
  if (
    typeof filter.in !== "undefined" &&
    !filter.in.some((inValue) => inValue.getTime() === value.getTime())
  ) {
    return false;
  }

  if (
    typeof filter.maxExclusive !== "undefined" &&
    value.getTime() >= filter.maxExclusive.getTime()
  ) {
    return false;
  }

  if (
    typeof filter.maxInclusive !== "undefined" &&
    value.getTime() > filter.maxInclusive.getTime()
  ) {
    return false;
  }

  if (
    typeof filter.minExclusive !== "undefined" &&
    value.getTime() <= filter.minExclusive.getTime()
  ) {
    return false;
  }

  if (
    typeof filter.minInclusive !== "undefined" &&
    value.getTime() < filter.minInclusive.getTime()
  ) {
    return false;
  }

  return true;
}

function $filterIdentifier(
  filter: $IdentifierFilter,
  value: BlankNode | NamedNode,
) {
  if (
    typeof filter.in !== "undefined" &&
    !filter.in.some((inValue) => inValue.equals(value))
  ) {
    return false;
  }

  if (typeof filter.type !== "undefined" && value.termType !== filter.type) {
    return false;
  }

  return true;
}

function $filterLiteral(filter: $LiteralFilter, value: Literal): boolean {
  return $filterTerm(filter, value);
}

function $filterMaybe<ItemT, ItemFilterT>(
  filterItem: (itemFilter: ItemFilterT, item: ItemT) => boolean,
) {
  return (filter: $MaybeFilter<ItemFilterT>, value: Maybe<ItemT>): boolean => {
    if (filter !== null) {
      if (value.isNothing()) {
        return false;
      }

      if (!filterItem(filter, value.extract()!)) {
        return false;
      }
    } else {
      if (value.isJust()) {
        return false;
      }
    }

    return true;
  };
}

function $filterNamedNode(filter: $NamedNodeFilter, value: NamedNode) {
  if (
    typeof filter.in !== "undefined" &&
    !filter.in.some((inValue) => inValue.equals(value))
  ) {
    return false;
  }

  return true;
}

function $filterNumber(filter: $NumberFilter, value: number) {
  if (
    typeof filter.in !== "undefined" &&
    !filter.in.some((inValue) => inValue === value)
  ) {
    return false;
  }

  if (
    typeof filter.maxExclusive !== "undefined" &&
    value >= filter.maxExclusive
  ) {
    return false;
  }

  if (
    typeof filter.maxInclusive !== "undefined" &&
    value > filter.maxInclusive
  ) {
    return false;
  }

  if (
    typeof filter.minExclusive !== "undefined" &&
    value <= filter.minExclusive
  ) {
    return false;
  }

  if (
    typeof filter.minInclusive !== "undefined" &&
    value < filter.minInclusive
  ) {
    return false;
  }

  return true;
}

function $filterString(filter: $StringFilter, value: string) {
  if (
    typeof filter.in !== "undefined" &&
    !filter.in.some((inValue) => inValue === value)
  ) {
    return false;
  }

  if (
    typeof filter.maxLength !== "undefined" &&
    value.length > filter.maxLength
  ) {
    return false;
  }

  if (
    typeof filter.minLength !== "undefined" &&
    value.length < filter.minLength
  ) {
    return false;
  }

  return true;
}

function $filterTerm(
  filter: $TermFilter,
  value: BlankNode | Literal | NamedNode,
): boolean {
  if (
    typeof filter.datatypeIn !== "undefined" &&
    (value.termType !== "Literal" ||
      !filter.datatypeIn.some((inDatatype) =>
        inDatatype.equals(value.datatype),
      ))
  ) {
    return false;
  }

  if (
    typeof filter.in !== "undefined" &&
    !filter.in.some((inTerm) => inTerm.equals(value))
  ) {
    return false;
  }

  if (
    typeof filter.languageIn !== "undefined" &&
    (value.termType !== "Literal" ||
      !filter.languageIn.some((inLanguage) => inLanguage === value.language))
  ) {
    return false;
  }

  if (
    typeof filter.typeIn !== "undefined" &&
    !filter.typeIn.some((inType) => inType === value.termType)
  ) {
    return false;
  }

  return true;
}

type $FromRdfOptions = {
  context?: any;
  ignoreRdfType?: boolean;
  objectSet?: $ObjectSet;
  preferredLanguages?: readonly string[];
};

function $fromRdfPreferredLanguages({
  focusResource,
  predicate,
  preferredLanguages,
  values,
}: {
  focusResource: Resource;
  predicate: NamedNode;
  preferredLanguages?: readonly string[];
  values: Resource.Values<Resource.TermValue>;
}): Either<Error, Resource.Values<Resource.TermValue>> {
  if (!preferredLanguages || preferredLanguages.length === 0) {
    return Either.of<Error, Resource.Values<Resource.TermValue>>(values);
  }

  return values
    .chainMap((value) => value.toLiteral())
    .map((literalValues) => {
      // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
      // Within a preferredLanguage the literals may be in any order.
      let filteredLiteralValues: Resource.Values<Literal> | undefined;
      for (const preferredLanguage of preferredLanguages) {
        if (!filteredLiteralValues) {
          filteredLiteralValues = literalValues.filter(
            (value) => value.language === preferredLanguage,
          );
        } else {
          filteredLiteralValues = filteredLiteralValues.concat(
            ...literalValues
              .filter((value) => value.language === preferredLanguage)
              .toArray(),
          );
        }
      }

      return filteredLiteralValues!.map(
        (literalValue) =>
          new Resource.TermValue({
            focusResource,
            predicate,
            term: literalValue,
          }),
      );
    });
}

type $Hasher = {
  update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
};

interface $IdentifierFilter {
  readonly in?: readonly (BlankNode | NamedNode)[];
  readonly type?: "BlankNode" | "NamedNode";
}

function $identifierFromString(
  identifier: string,
): Either<Error, BlankNode | NamedNode> {
  return Either.encase(() =>
    Resource.Identifier.fromString({ dataFactory, identifier }),
  );
}

interface $IdentifierSchema {
  readonly kind: "Identifier";
}

class $IdentifierSet {
  private readonly blankNodeValues = new Set<string>();
  private readonly namedNodeValues = new Set<string>();

  add(identifier: BlankNode | NamedNode): this {
    switch (identifier.termType) {
      case "BlankNode":
        this.blankNodeValues.add(identifier.value);
        return this;
      case "NamedNode":
        this.namedNodeValues.add(identifier.value);
        return this;
    }
  }

  has(identifier: BlankNode | NamedNode): boolean {
    switch (identifier.termType) {
      case "BlankNode":
        return this.blankNodeValues.has(identifier.value);
      case "NamedNode":
        return this.namedNodeValues.has(identifier.value);
    }
  }
}

const $identifierSparqlWherePatterns: $SparqlWherePatternsFunction<
  $IdentifierFilter,
  $IdentifierSchema
> = ({ filter, propertyPatterns, valueVariable }) => {
  const patterns: $SparqlPattern[] = propertyPatterns.concat();

  if (filter) {
    if (typeof filter.in !== "undefined") {
      const valueIn = filter.in.filter(
        (identifier) => identifier.termType === "NamedNode",
      );
      if (valueIn.length > 0) {
        patterns.push(
          $sparqlValueInPattern({ lift: true, valueVariable, valueIn }),
        );
      }
    }

    if (typeof filter.type !== "undefined") {
      patterns.push({
        expression: {
          type: "operation",
          operator: filter.type === "BlankNode" ? "isBlank" : "isIRI",
          args: [valueVariable],
        },
        lift: true,
        type: "filter",
      });
    }
  }

  return patterns;
};

function $isReadonlyBigintArray(x: unknown): x is readonly bigint[] {
  return Array.isArray(x) && x.every((z) => typeof z === "bigint");
}

function $isReadonlyBooleanArray(x: unknown): x is readonly boolean[] {
  return Array.isArray(x) && x.every((z) => typeof z === "boolean");
}

function $isReadonlyNumberArray(x: unknown): x is readonly number[] {
  return Array.isArray(x) && x.every((z) => typeof z === "number");
}

function $isReadonlyObjectArray(x: unknown): x is readonly object[] {
  return Array.isArray(x) && x.every((z) => typeof z === "object");
}

function $isReadonlyStringArray(x: unknown): x is readonly string[] {
  return Array.isArray(x) && x.every((z) => typeof z === "string");
}

/**
 * Type of lazy properties that return a single required object. This is a class instead of an interface so it can be instanceof'd elsewhere.
 */
export class $LazyObject<
  ObjectIdentifierT extends BlankNode | NamedNode,
  PartialObjectT extends { $identifier: ObjectIdentifierT },
  ResolvedObjectT extends { $identifier: ObjectIdentifierT },
> {
  readonly partial: PartialObjectT;
  private readonly resolver: (
    identifier: ObjectIdentifierT,
  ) => Promise<Either<Error, ResolvedObjectT>>;

  constructor({
    partial,
    resolver,
  }: {
    partial: PartialObjectT;
    resolver: (
      identifier: ObjectIdentifierT,
    ) => Promise<Either<Error, ResolvedObjectT>>;
  }) {
    this.partial = partial;
    this.resolver = resolver;
  }

  resolve(): Promise<Either<Error, ResolvedObjectT>> {
    return this.resolver(this.partial.$identifier);
  }
}

/**
 * Type of lazy properties that return a single optional object. This is a class instead of an interface so it can be instanceof'd elsewhere.
 */
export class $LazyObjectOption<
  ObjectIdentifierT extends BlankNode | NamedNode,
  PartialObjectT extends { $identifier: ObjectIdentifierT },
  ResolvedObjectT extends { $identifier: ObjectIdentifierT },
> {
  readonly partial: Maybe<PartialObjectT>;
  private readonly resolver: (
    identifier: ObjectIdentifierT,
  ) => Promise<Either<Error, ResolvedObjectT>>;

  constructor({
    partial,
    resolver,
  }: {
    partial: Maybe<PartialObjectT>;
    resolver: (
      identifier: ObjectIdentifierT,
    ) => Promise<Either<Error, ResolvedObjectT>>;
  }) {
    this.partial = partial;
    this.resolver = resolver;
  }

  async resolve(): Promise<Either<Error, Maybe<ResolvedObjectT>>> {
    if (this.partial.isNothing()) {
      return Either.of(Maybe.empty());
    }
    return (await this.resolver(this.partial.unsafeCoerce().$identifier)).map(
      Maybe.of,
    );
  }
}

/**
 * Type of lazy properties that return a set of objects. This is a class instead of an interface so it can be instanceof'd elsewhere.
 */
export class $LazyObjectSet<
  ObjectIdentifierT extends BlankNode | NamedNode,
  PartialObjectT extends { $identifier: ObjectIdentifierT },
  ResolvedObjectT extends { $identifier: ObjectIdentifierT },
> {
  readonly partials: readonly PartialObjectT[];
  private readonly resolver: (
    identifiers: readonly ObjectIdentifierT[],
  ) => Promise<Either<Error, readonly ResolvedObjectT[]>>;

  constructor({
    partials,
    resolver,
  }: {
    partials: readonly PartialObjectT[];
    resolver: (
      identifiers: readonly ObjectIdentifierT[],
    ) => Promise<Either<Error, readonly ResolvedObjectT[]>>;
  }) {
    this.partials = partials;
    this.resolver = resolver;
  }

  get length(): number {
    return this.partials.length;
  }

  async resolve(options?: {
    limit?: number;
    offset?: number;
  }): Promise<Either<Error, readonly ResolvedObjectT[]>> {
    if (this.partials.length === 0) {
      return Either.of([]);
    }

    const limit = options?.limit ?? Number.MAX_SAFE_INTEGER;
    if (limit <= 0) {
      return Either.of([]);
    }

    let offset = options?.offset ?? 0;
    if (offset < 0) {
      offset = 0;
    }

    return await this.resolver(
      this.partials
        .slice(offset, offset + limit)
        .map((partial) => partial.$identifier),
    );
  }
}

function $liftSparqlPatterns(
  patterns: Iterable<$SparqlPattern>,
): [readonly $SparqlPattern[], readonly $SparqlFilterPattern[]] {
  const liftedPatterns: $SparqlFilterPattern[] = [];
  const unliftedPatterns: $SparqlPattern[] = [];
  for (const pattern of patterns) {
    if (pattern.type === "filter" && pattern.lift) {
      liftedPatterns.push(pattern);
    } else {
      unliftedPatterns.push(pattern);
    }
  }
  return [unliftedPatterns, liftedPatterns];
}

function $listSparqlWherePatterns<ItemFilterT, ItemSchemaT>(
  itemSparqlWherePatternsFunction: $SparqlWherePatternsFunction<
    ItemFilterT,
    ItemSchemaT
  >,
): $SparqlWherePatternsFunction<
  $CollectionFilter<ItemFilterT>,
  $CollectionSchema<ItemSchemaT>
> {
  return (parameters) => {
    // Need to handle two cases:
    // (1) (?s, ?p, ?list) where ?list binds to rdf:nil
    // (2) (?s, ?p, ?list) (?list, rdf:first, "element") (?list, rdf:rest, rdf:nil) etc. where list binds to the head of a list
    // Case (2) is case (1) with OPTIONAL graph patterns to handle actual list elements.

    const listVariable = parameters.valueVariable;
    const patterns: $SparqlPattern[] = [];
    const variable = (suffix: string) =>
      dataFactory.variable!(`${parameters.variablePrefix}${suffix}`);
    const variablePrefix = (suffix: string) =>
      `${parameters.variablePrefix}${suffix}`;

    {
      // ?list rdf:first ?item0
      const item0Variable = variable("Item0");
      patterns.push(
        {
          triples: [
            {
              subject: listVariable,
              predicate: $RdfVocabularies.rdf.first,
              object: item0Variable,
            },
          ],
          type: "bgp",
        },
        ...itemSparqlWherePatternsFunction({
          filter: parameters.filter,
          preferredLanguages: parameters.preferredLanguages,
          propertyPatterns: [],
          schema: parameters.schema.item(),
          valueVariable: item0Variable,
          variablePrefix: variablePrefix("Item0"),
        }),
      );
    }

    {
      // ?list rdf:rest ?rest0
      const rest0Variable = variable("Rest0");
      patterns.push({
        triples: [
          {
            subject: listVariable,
            predicate: $RdfVocabularies.rdf.rest,
            object: rest0Variable,
          },
        ],
        type: "bgp",
      });
    }

    const optionalPatterns: $SparqlPattern[] = [];

    const restNVariable = variable("RestN");
    // ?list rdf:rest+ ?restN
    optionalPatterns.push({
      type: "bgp",
      triples: [
        {
          subject: listVariable,
          predicate: {
            type: "path",
            pathType: "*",
            items: [$RdfVocabularies.rdf.rest],
          },
          object: restNVariable,
        },
      ],
    });

    {
      // ?rest rdf:first ?itemN
      const itemNVariable = variable("ItemN");
      optionalPatterns.push(
        {
          triples: [
            {
              subject: restNVariable,
              predicate: $RdfVocabularies.rdf.first,
              object: itemNVariable,
            },
          ],
          type: "bgp",
        },
        ...itemSparqlWherePatternsFunction({
          filter: parameters.filter,
          preferredLanguages: parameters.preferredLanguages,
          propertyPatterns: [],
          schema: parameters.schema.item(),
          valueVariable: itemNVariable,
          variablePrefix: variablePrefix("ItemN"),
        }),
      );
    }

    // ?restN rdf:rest ?restNBasic to get the rdf:rest statement in the CONSTRUCT
    optionalPatterns.push({
      triples: [
        {
          subject: restNVariable,
          predicate: $RdfVocabularies.rdf.rest,
          object: variable("RestNBasic"),
        },
      ],
      type: "bgp",
    });

    patterns.push({ type: "optional", patterns: optionalPatterns });

    // Having an optional around everything handles the rdf:nil case
    return [...parameters.propertyPatterns, { patterns, type: "optional" }];
  };
}

const $literalFactory = new LiteralFactory({ dataFactory: dataFactory });

interface $LiteralFilter extends Omit<$TermFilter, "in" | "type"> {
  readonly in?: readonly Literal[];
}

interface $LiteralSchema {
  readonly in?: readonly Literal[];
  readonly kind: "Literal";
  readonly languageIn?: readonly string[];
}

function $literalSchemaSparqlPatterns({
  filterPatterns,
  preferredLanguages,
  propertyPatterns,
  schema,
  valueVariable,
}: {
  filterPatterns: readonly $SparqlFilterPattern[];
  preferredLanguages?: readonly string[];
  propertyPatterns: readonly sparqljs.BgpPattern[];
  schema: Readonly<{
    languageIn?: readonly string[];
    in?: readonly (boolean | Date | string | number | Literal | NamedNode)[];
  }>;
  valueVariable: Variable;
}): readonly $SparqlPattern[] {
  const patterns: $SparqlPattern[] = propertyPatterns.concat();

  if (schema.in && schema.in.length > 0) {
    patterns.push($sparqlValueInPattern({ valueVariable, valueIn: schema.in }));
  }

  const languageIn = $arrayIntersection(
    schema.languageIn ?? [],
    preferredLanguages ?? [],
  );
  if (languageIn.length > 0) {
    patterns.push({
      expression: {
        args: [
          { args: [valueVariable], operator: "lang", type: "operation" },
          languageIn.map((_) => dataFactory.literal(_)),
        ],
        operator: "in",
        type: "operation",
      },
      type: "filter",
    });
  }

  return patterns.concat(filterPatterns);
}

const $literalSparqlWherePatterns: $SparqlWherePatternsFunction<
  $LiteralFilter,
  $LiteralSchema
> = (parameters) =>
  $literalSchemaSparqlPatterns({
    filterPatterns: $termFilterSparqlPatterns(parameters),
    ...parameters,
  });

function $maybeEquals<T>(
  leftMaybe: Maybe<T>,
  rightMaybe: Maybe<T>,
  valueEquals: (left: T, right: T) => boolean | $EqualsResult,
): $EqualsResult {
  if (leftMaybe.isJust()) {
    if (rightMaybe.isJust()) {
      return $EqualsResult.fromBooleanEqualsResult(
        leftMaybe,
        rightMaybe,
        valueEquals(leftMaybe.unsafeCoerce(), rightMaybe.unsafeCoerce()),
      );
    }
    return Left({ left: leftMaybe.unsafeCoerce(), type: "right-null" });
  }

  if (rightMaybe.isJust()) {
    return Left({ right: rightMaybe.unsafeCoerce(), type: "left-null" });
  }

  return $EqualsResult.Equal;
}

type $MaybeFilter<ItemFilterT> = ItemFilterT | null;

interface $MaybeSchema<ItemSchemaT> {
  readonly item: () => ItemSchemaT;
  readonly kind: "Maybe";
}

function $maybeSparqlWherePatterns<ItemFilterT, ItemSchemaT>(
  itemSparqlWherePatternsFunction: $SparqlWherePatternsFunction<
    ItemFilterT,
    ItemSchemaT
  >,
): $SparqlWherePatternsFunction<
  $MaybeFilter<ItemFilterT>,
  $MaybeSchema<ItemSchemaT>
> {
  return ({ filter, schema, ...otherParameters }) => {
    if (typeof filter === "undefined") {
      // Treat the item's patterns as optional
      const [itemSparqlWherePatterns, liftSparqlPatterns] = $liftSparqlPatterns(
        itemSparqlWherePatternsFunction({
          filter,
          schema: schema.item(),
          ...otherParameters,
        }),
      );
      return [
        { patterns: itemSparqlWherePatterns.concat(), type: "optional" },
        ...liftSparqlPatterns,
      ];
    }

    if (filter === null) {
      // Use FILTER NOT EXISTS around the item's patterns
      const [itemSparqlWherePatterns, liftSparqlPatterns] = $liftSparqlPatterns(
        itemSparqlWherePatternsFunction({
          schema: schema.item(),
          ...otherParameters,
        }),
      );
      return [
        {
          expression: {
            args: itemSparqlWherePatterns.concat(),
            operator: "notexists",
            type: "operation",
          },
          lift: true,
          type: "filter",
        },
        ...liftSparqlPatterns,
      ];
    }

    // Treat the item as required.
    return itemSparqlWherePatternsFunction({
      filter,
      schema: schema.item(),
      ...otherParameters,
    });
  };
}

interface $NamedNodeFilter {
  readonly in?: readonly NamedNode[];
}

interface $NamedNodeSchema {
  readonly in?: readonly NamedNode[];
  readonly kind: "NamedNode";
}

const $namedNodeSparqlWherePatterns: $SparqlWherePatternsFunction<
  $NamedNodeFilter,
  $NamedNodeSchema
> = ({ filter, valueVariable, ...otherParameters }) => {
  const filterPatterns: $SparqlFilterPattern[] = [];

  if (typeof filter?.in !== "undefined" && filter.in.length > 0) {
    filterPatterns.push(
      $sparqlValueInPattern({ lift: true, valueVariable, valueIn: filter.in }),
    );
  }

  return $termSchemaSparqlPatterns({
    filterPatterns,
    valueVariable,
    ...otherParameters,
  });
};

function $normalizeSparqlWherePatterns(
  patterns: readonly $SparqlPattern[],
): readonly $SparqlPattern[] {
  function normalizePatternsRecursive(
    patternsRecursive: readonly $SparqlPattern[],
  ): readonly $SparqlPattern[] {
    if (patternsRecursive.length === 0) {
      return patternsRecursive;
    }

    const compactedPatterns: $SparqlPattern[] = [];
    for (const pattern of $deduplicateSparqlPatterns(patternsRecursive)) {
      switch (pattern.type) {
        case "bgp": {
          if (pattern.triples.length === 0) {
            continue;
          }
          const lastPattern = compactedPatterns.at(-1);
          if (lastPattern && lastPattern.type === "bgp") {
            // Coalesce adjacent BGP patterns without mutating lastPattern
            compactedPatterns[compactedPatterns.length - 1] = {
              triples: lastPattern.triples.concat(pattern.triples),
              type: "bgp",
            };
          } else {
            compactedPatterns.push(pattern);
          }
          break;
        }
        case "bind":
        case "filter":
        case "query":
        case "values":
          compactedPatterns.push(pattern);
          break;
        case "group":
          // Flatten groups outside unions
          compactedPatterns.push(
            ...normalizePatternsRecursive(pattern.patterns),
          );
          break;
        case "graph":
        case "minus":
        case "optional":
        case "service": {
          const patterns_ = normalizePatternsRecursive(pattern.patterns);
          if (patterns_.length > 0) {
            compactedPatterns.push({
              ...pattern,
              patterns: patterns_.concat(),
            });
          }
          break;
        }
        case "union": {
          const unionPatterns = $deduplicateSparqlPatterns(
            pattern.patterns.flatMap((pattern) => {
              switch (pattern.type) {
                case "group":
                // Don't flatten the groups in a union
                case "graph":
                case "minus":
                case "optional":
                case "service": {
                  const patterns_ = normalizePatternsRecursive(
                    pattern.patterns,
                  );
                  if (patterns_.length > 0) {
                    return [{ ...pattern, patterns: patterns_.concat() }];
                  }
                  return [] as $SparqlPattern[];
                }
                default:
                  return [pattern];
              }
            }),
          );

          switch (unionPatterns.length) {
            case 0:
              break;
            case 1:
              compactedPatterns.push(
                ...normalizePatternsRecursive([unionPatterns[0]]),
              );
              break;
            default:
              compactedPatterns.push({
                ...pattern,
                patterns: unionPatterns.concat(),
              });
              break;
          }
          break;
        }
        default:
          pattern satisfies never;
      }
    }

    return $sortSparqlPatterns($deduplicateSparqlPatterns(compactedPatterns));
  }

  const normalizedPatterns = normalizePatternsRecursive(patterns);
  if (!normalizedPatterns.some($SparqlPattern.isSolutionGenerating)) {
    throw new Error(
      "SPARQL WHERE patterns must have at least one solution-generating pattern",
    );
  }

  return normalizedPatterns;
}

interface $NumberFilter {
  readonly in?: readonly number[];
  readonly maxExclusive?: number;
  readonly maxInclusive?: number;
  readonly minExclusive?: number;
  readonly minInclusive?: number;
}

interface $NumberSchema {
  readonly in?: readonly number[];
  readonly kind: "Float" | "Int";
}

const $numberSparqlWherePatterns: $SparqlWherePatternsFunction<
  $NumberFilter,
  $NumberSchema
> = ({ filter, valueVariable, ...otherParameters }) => {
  const filterPatterns: $SparqlFilterPattern[] = [];

  if (filter) {
    if (typeof filter.in !== "undefined" && filter.in.length > 0) {
      filterPatterns.push(
        $sparqlValueInPattern({
          lift: true,
          valueVariable,
          valueIn: filter.in,
        }),
      );
    }

    if (typeof filter.maxExclusive !== "undefined") {
      filterPatterns.push({
        expression: {
          type: "operation",
          operator: "<",
          args: [valueVariable, $literalFactory.number(filter.maxExclusive)],
        },
        lift: true,
        type: "filter",
      });
    }

    if (typeof filter.maxInclusive !== "undefined") {
      filterPatterns.push({
        expression: {
          type: "operation",
          operator: "<=",
          args: [valueVariable, $literalFactory.number(filter.maxInclusive)],
        },
        lift: true,
        type: "filter",
      });
    }

    if (typeof filter.minExclusive !== "undefined") {
      filterPatterns.push({
        expression: {
          type: "operation",
          operator: ">",
          args: [valueVariable, $literalFactory.number(filter.minExclusive)],
        },
        lift: true,
        type: "filter",
      });
    }

    if (typeof filter.minInclusive !== "undefined") {
      filterPatterns.push({
        expression: {
          type: "operation",
          operator: ">=",
          args: [valueVariable, $literalFactory.number(filter.minInclusive)],
        },
        lift: true,
        type: "filter",
      });
    }
  }

  return $termSchemaSparqlPatterns({
    filterPatterns,
    valueVariable,
    ...otherParameters,
  });
};

type $PropertiesFromRdfParameters = {
  context?: any;
  ignoreRdfType: boolean;
  objectSet: $ObjectSet;
  preferredLanguages?: readonly string[];
  resource: Resource;
};

namespace $RdfVocabularies {
  export namespace rdf {
    export const first = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
    );
    export const nil = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil",
    );
    export const rest = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
    );
    export const subject = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#subject",
    );
    export const type = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    );
  }

  export namespace rdfs {
    export const subClassOf = dataFactory.namedNode(
      "http://www.w3.org/2000/01/rdf-schema#subClassOf",
    );
  }

  export namespace xsd {
    export const boolean = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#boolean",
    );
    export const date = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#date",
    );
    export const dateTime = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#dateTime",
    );
    export const decimal = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#decimal",
    );
    export const double = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#double",
    );
    export const integer = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#integer",
    );
  }
}

function $setSparqlWherePatterns<ItemFilterT, ItemSchemaT>(
  itemSparqlWherePatternsFunction: $SparqlWherePatternsFunction<
    ItemFilterT,
    ItemSchemaT
  >,
): $SparqlWherePatternsFunction<
  $CollectionFilter<ItemFilterT>,
  $CollectionSchema<ItemSchemaT>
> {
  return ({ filter, schema, ...otherParameters }) => {
    const itemSparqlWherePatterns = itemSparqlWherePatternsFunction({
      filter,
      schema: schema.item(),
      ...otherParameters,
    });

    const minCount = filter?.$minCount ?? schema.minCount ?? 0;
    if (minCount > 0) {
      // Required
      return itemSparqlWherePatterns;
    }

    const [optionalSparqlWherePatterns, liftSparqlPatterns] =
      $liftSparqlPatterns(itemSparqlWherePatterns);
    return [
      { patterns: optionalSparqlWherePatterns.concat(), type: "optional" },
      ...liftSparqlPatterns,
    ];
  };
}

function $sortSparqlPatterns(
  patterns: readonly $SparqlPattern[],
): readonly $SparqlPattern[] {
  const filterPatterns: $SparqlPattern[] = [];
  const otherPatterns: $SparqlPattern[] = [];
  const valuesPatterns: $SparqlPattern[] = [];

  for (const pattern of patterns) {
    switch (pattern.type) {
      case "filter":
        filterPatterns.push(pattern);
        break;
      case "values":
        valuesPatterns.push(pattern);
        break;
      default:
        otherPatterns.push(pattern);
        break;
    }
  }

  return valuesPatterns.concat(otherPatterns).concat(filterPatterns);
}

type $SparqlFilterPattern = sparqljs.FilterPattern & { lift?: boolean };

/**
 * A sparqljs.Pattern that's the equivalent of ?subject rdf:type/rdfs:subClassOf* ?rdfType .
 */
function $sparqlInstancesOfPattern({
  rdfType,
  subject,
}: {
  rdfType: NamedNode | Variable;
  subject: sparqljs.Triple["subject"];
}): sparqljs.BgpPattern {
  return {
    triples: [
      {
        subject,
        predicate: {
          items: [
            $RdfVocabularies.rdf.type,
            {
              items: [$RdfVocabularies.rdfs.subClassOf],
              pathType: "*",
              type: "path",
            },
          ],
          pathType: "/",
          type: "path",
        },
        object: rdfType,
      },
    ],
    type: "bgp",
  };
}

type $SparqlPattern =
  | Exclude<sparqljs.Pattern, sparqljs.FilterPattern>
  | $SparqlFilterPattern;

namespace $SparqlPattern {
  export function isSolutionGenerating(pattern: $SparqlPattern): boolean {
    switch (pattern.type) {
      case "bind":
      case "bgp":
      case "service":
      case "values":
        return true;

      case "graph":
      case "group":
        return pattern.patterns.some(isSolutionGenerating);

      case "filter":
      case "minus":
      case "optional":
        return false;

      case "union":
        // A union pattern is solution-generating if every branch is solution-generating
        return pattern.patterns.every(isSolutionGenerating);

      default:
        throw new RangeError(
          `unable to determine whether "${pattern.type}" pattern is solution-generating`,
        );
    }
  }
}

function $sparqlValueInPattern({
  lift,
  valueIn,
  valueVariable,
}: {
  lift?: boolean;
  valueIn: readonly (boolean | Date | number | string | Literal | NamedNode)[];
  valueVariable: Variable;
}): $SparqlFilterPattern {
  if (valueIn.length === 0) {
    throw new RangeError("expected valueIn not to be empty");
  }

  return {
    expression: {
      args: [
        valueVariable,
        valueIn.map((inValue) => {
          if (typeof inValue !== "object" || inValue instanceof Date) {
            return $literalFactory.primitive(inValue);
          }
          return inValue;
        }),
      ],
      operator: "in",
      type: "operation",
    },
    lift,
    type: "filter",
  };
}

type $SparqlWherePatternsFunction<FilterT, SchemaT> = (
  parameters: $SparqlWherePatternsFunctionParameters<FilterT, SchemaT>,
) => readonly $SparqlPattern[];

type $SparqlWherePatternsFunctionParameters<FilterT, SchemaT> = Readonly<{
  filter?: FilterT;
  ignoreRdfType?: boolean;
  preferredLanguages?: readonly string[];
  propertyPatterns: readonly sparqljs.BgpPattern[];
  schema: SchemaT;
  valueVariable: Variable;
  variablePrefix: string;
}>;

/**
 * Compare two values for strict equality (===), returning an $EqualsResult rather than a boolean.
 */
function $strictEquals<T extends bigint | boolean | number | string>(
  left: T,
  right: T,
): $EqualsResult {
  return $EqualsResult.fromBooleanEqualsResult(left, right, left === right);
}

interface $StringFilter {
  readonly in?: readonly string[];
  readonly maxLength?: number;
  readonly minLength?: number;
}

interface $StringSchema {
  readonly in?: readonly string[];
  readonly kind: "String";
}

const $stringSparqlWherePatterns: $SparqlWherePatternsFunction<
  $StringFilter,
  $StringSchema
> = ({ filter, valueVariable, ...otherParameters }) => {
  const filterPatterns: $SparqlFilterPattern[] = [];

  if (filter) {
    if (typeof filter.in !== "undefined" && filter.in.length > 0) {
      filterPatterns.push(
        $sparqlValueInPattern({
          lift: true,
          valueVariable,
          valueIn: filter.in,
        }),
      );
    }

    if (typeof filter.maxLength !== "undefined") {
      filterPatterns.push({
        expression: {
          type: "operation",
          operator: "<=",
          args: [
            { args: [valueVariable], operator: "strlen", type: "operation" },
            $literalFactory.number(filter.maxLength),
          ],
        },
        lift: true,
        type: "filter",
      });
    }

    if (typeof filter.minLength !== "undefined") {
      filterPatterns.push({
        expression: {
          type: "operation",
          operator: ">=",
          args: [
            { args: [valueVariable], operator: "strlen", type: "operation" },
            $literalFactory.number(filter.minLength),
          ],
        },
        lift: true,
        type: "filter",
      });
    }
  }

  return $literalSchemaSparqlPatterns({
    filterPatterns,
    valueVariable,
    ...otherParameters,
  });
};

interface $TermFilter {
  readonly datatypeIn?: readonly NamedNode[];
  readonly in?: readonly (Literal | NamedNode)[];
  readonly languageIn?: readonly string[];
  readonly typeIn?: readonly ("BlankNode" | "Literal" | "NamedNode")[];
}

function $termFilterSparqlPatterns({
  filter,
  valueVariable,
}: {
  filter?: $TermFilter;
  valueVariable: Variable;
}): readonly $SparqlFilterPattern[] {
  if (!filter) {
    return [];
  }

  const filterPatterns: $SparqlFilterPattern[] = [];

  if (
    typeof filter.datatypeIn !== "undefined" &&
    filter.datatypeIn.length > 0
  ) {
    filterPatterns.push({
      expression: {
        type: "operation",
        operator: "in",
        args: [
          { args: [valueVariable], operator: "datatype", type: "operation" },
          filter.datatypeIn.concat(),
        ],
      },
      lift: true,
      type: "filter",
    });
  }

  if (typeof filter.in !== "undefined" && filter.in.length > 0) {
    filterPatterns.push(
      $sparqlValueInPattern({ lift: true, valueVariable, valueIn: filter.in }),
    );
  }

  if (
    typeof filter.languageIn !== "undefined" &&
    filter.languageIn.length > 0
  ) {
    filterPatterns.push({
      expression: {
        type: "operation",
        operator: "in",
        args: [
          { args: [valueVariable], operator: "lang", type: "operation" },
          filter.languageIn.map((value) => dataFactory.literal(value)),
        ],
      },
      lift: true,
      type: "filter",
    });
  }

  if (typeof filter.typeIn !== "undefined") {
    const typeInExpressions = filter.typeIn
      .map((inType) => {
        switch (inType) {
          case "BlankNode":
            return "isBlank";
          case "Literal":
            return "isLiteral";
          case "NamedNode":
            return "isIRI";
          default:
            inType satisfies never;
            throw new RangeError(inType);
        }
      })
      .map((operator) => ({
        type: "operation" as const,
        operator,
        args: [valueVariable],
      }));

    switch (typeInExpressions.length) {
      case 0:
        break;
      case 1:
        filterPatterns.push({
          expression: typeInExpressions[0],
          lift: true,
          type: "filter",
        });
        break;
      default:
        filterPatterns.push({
          expression: {
            type: "operation",
            operator: "||",
            args: typeInExpressions,
          },
          lift: true,
          type: "filter",
        });
    }
  }

  return filterPatterns;
}

interface $TermSchema {
  readonly in?: readonly (Literal | NamedNode)[];
  readonly kind: "Term";
  readonly nodeKinds: readonly ("BlankNode" | "Literal" | "NamedNode")[];
}

function $termSchemaSparqlPatterns({
  filterPatterns,
  propertyPatterns,
  schema,
  valueVariable,
}: {
  filterPatterns: readonly $SparqlFilterPattern[];
  propertyPatterns: readonly sparqljs.BgpPattern[];
  schema: Readonly<{
    in?: readonly (boolean | Date | string | number | Literal | NamedNode)[];
  }>;
  valueVariable: Variable;
}): readonly $SparqlPattern[] {
  const patterns: $SparqlPattern[] = propertyPatterns.concat();

  if (schema.in && schema.in.length > 0) {
    patterns.push($sparqlValueInPattern({ valueVariable, valueIn: schema.in }));
  }

  return patterns.concat(filterPatterns);
}

const $termSparqlWherePatterns: $SparqlWherePatternsFunction<
  $TermFilter,
  $TermSchema
> = (parameters) =>
  $termSchemaSparqlPatterns({
    filterPatterns: $termFilterSparqlPatterns(parameters),
    ...parameters,
  });

type $UnwrapR<T> = T extends Either<any, infer R> ? R : never;
export class $NamedDefaultPartial {
  readonly $identifier: $NamedDefaultPartial.$Identifier;

  readonly $type: "$NamedDefaultPartial" = "$NamedDefaultPartial" as const;

  constructor(parameters: { readonly $identifier: NamedNode | string }) {
    if (typeof parameters.$identifier === "object") {
      this.$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this.$identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      this.$identifier = parameters.$identifier satisfies never;
    }
  }

  $equals(other: $NamedDefaultPartial): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    return _hasher;
  }

  $toJson(): $NamedDefaultPartial.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
      } satisfies $NamedDefaultPartial.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource<NamedNode> {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace $NamedDefaultPartial {
  export function $filter(
    filter: $NamedDefaultPartial.$Filter,
    value: $NamedDefaultPartial,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = { readonly $identifier?: $NamedNodeFilter };

  export type $Identifier = NamedNode;

  export namespace $Identifier {
    export function fromString(identifier: string): Either<Error, NamedNode> {
      return Either.encase(() =>
        Resource.Identifier.fromString({ dataFactory, identifier }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? Either.of(identifier)
          : Left(new Error("expected identifier to be NamedNode")),
      ) as Either<Error, NamedNode>;
    } // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<z.ZodError, { $identifier: NamedNode }> {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    return Either.of({ $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, $NamedDefaultPartial> {
    return $propertiesFromJson(json).map(
      (properties) => new $NamedDefaultPartial(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "$NamedDefaultPartial" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "$NamedDefaultPartial",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("$NamedDefaultPartial"),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "$NamedDefaultPartial";
  };

  export function is$NamedDefaultPartial(
    object: $Object,
  ): object is $NamedDefaultPartial {
    switch (object.$type) {
      case "$NamedDefaultPartial":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, $NamedDefaultPartial> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return $NamedDefaultPartial
      .$propertiesFromRdf({
        context,
        ignoreRdfType,
        objectSet,
        preferredLanguages,
        resource,
      })
      .map((properties) => new $NamedDefaultPartial(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<Error, { $identifier: NamedNode }> {
    return (
      $parameters.resource.identifier.termType === "NamedNode"
        ? Either.of<Error, $NamedDefaultPartial.$Identifier>(
            $parameters.resource.identifier,
          )
        : Left(
            new Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "NamedNode",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
    ).map(($identifier) => ({ $identifier }));
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "NamedNode" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["$NamedDefaultPartial"],
        }),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: $NamedDefaultPartial.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        $NamedDefaultPartial.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          $NamedDefaultPartial.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: $NamedDefaultPartial.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      $NamedDefaultPartial.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: $NamedDefaultPartial.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("namedDefaultPartial");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $namedNodeSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: $NamedDefaultPartial.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "namedDefaultPartial"),
        }),
      );
    }
    return patterns;
  }
}
export class $DefaultPartial {
  readonly $identifier: $DefaultPartial.$Identifier;

  readonly $type: "$DefaultPartial" = "$DefaultPartial" as const;

  constructor(parameters: {
    readonly $identifier: (BlankNode | NamedNode) | string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this.$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this.$identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      this.$identifier = parameters.$identifier satisfies never;
    }
  }

  $equals(other: $DefaultPartial): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    return _hasher;
  }

  $toJson(): $DefaultPartial.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
      } satisfies $DefaultPartial.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace $DefaultPartial {
  export function $filter(
    filter: $DefaultPartial.$Filter,
    value: $DefaultPartial,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = { readonly $identifier?: $IdentifierFilter };

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<z.ZodError, { $identifier: BlankNode | NamedNode }> {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    return Either.of({ $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, $DefaultPartial> {
    return $propertiesFromJson(json).map(
      (properties) => new $DefaultPartial(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "$DefaultPartial" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "$DefaultPartial",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("$DefaultPartial"),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "$DefaultPartial";
  };

  export function is$DefaultPartial(
    object: $Object,
  ): object is $DefaultPartial {
    switch (object.$type) {
      case "$DefaultPartial":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, $DefaultPartial> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return $DefaultPartial
      .$propertiesFromRdf({
        context,
        ignoreRdfType,
        objectSet,
        preferredLanguages,
        resource,
      })
      .map((properties) => new $DefaultPartial(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<Error, { $identifier: BlankNode | NamedNode }> {
    return Either.of<Error, $DefaultPartial.$Identifier>(
      $parameters.resource.identifier as $DefaultPartial.$Identifier,
    ).map(($identifier) => ({ $identifier }));
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["$DefaultPartial"],
        }),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: $DefaultPartial.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        $DefaultPartial.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          $DefaultPartial.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: $DefaultPartial.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      $DefaultPartial.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: $DefaultPartial.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("defaultPartial");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: $DefaultPartial.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "defaultPartial"),
        }),
      );
    }
    return patterns;
  }
} /**
 * A node shape that mints its identifier by generating a v4 UUID, if no identifier is supplied.
 */

export interface UuidV4IriIdentifierInterface {
  readonly $identifier: UuidV4IriIdentifierInterface.$Identifier;
  readonly $type: "UuidV4IriIdentifierInterface";
  readonly uuidV4IriProperty: string;
}

export namespace UuidV4IriIdentifierInterface {
  export function $create(parameters: {
    readonly $identifier?: NamedNode | string;
    readonly $identifierPrefix?: string;
    readonly uuidV4IriProperty: string;
  }): Omit<UuidV4IriIdentifierInterface, "$identifierPrefix"> {
    let $identifier: UuidV4IriIdentifierInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.namedNode(
        `${parameters.$identifierPrefix ?? "urn:shaclmate:UuidV4IriIdentifierInterface:"}${uuid.v4()}`,
      );
    } else {
      $identifier = parameters.$identifier satisfies never;
    }
    const $type = "UuidV4IriIdentifierInterface" as const;
    const uuidV4IriProperty = parameters.uuidV4IriProperty;
    return { $identifier, $type, uuidV4IriProperty };
  }

  export function $equals(
    left: UuidV4IriIdentifierInterface,
    right: UuidV4IriIdentifierInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(left.uuidV4IriProperty, right.uuidV4IriProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "uuidV4IriProperty",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      );
  }

  export function $hash<HasherT extends $Hasher>(
    _uuidV4IriIdentifierInterface: UuidV4IriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    UuidV4IriIdentifierInterface.$hashShaclProperties(
      _uuidV4IriIdentifierInterface,
      _hasher,
    );
    _hasher.update(_uuidV4IriIdentifierInterface.$identifier.value);
    _hasher.update(_uuidV4IriIdentifierInterface.$type);
    return _hasher;
  }

  export function $hashShaclProperties<HasherT extends $Hasher>(
    _uuidV4IriIdentifierInterface: UuidV4IriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_uuidV4IriIdentifierInterface.uuidV4IriProperty);
    return _hasher;
  }

  export function $filter(
    filter: UuidV4IriIdentifierInterface.$Filter,
    value: UuidV4IriIdentifierInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.uuidV4IriProperty !== "undefined" &&
      !$filterString(filter.uuidV4IriProperty, value.uuidV4IriProperty)
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
    readonly uuidV4IriProperty?: $StringFilter;
  };

  export type $Identifier = NamedNode;

  export namespace $Identifier {
    export function fromString(identifier: string): Either<Error, NamedNode> {
      return Either.encase(() =>
        Resource.Identifier.fromString({ dataFactory, identifier }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? Either.of(identifier)
          : Left(new Error("expected identifier to be NamedNode")),
      ) as Either<Error, NamedNode>;
    } // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: NamedNode;
      $type: "UuidV4IriIdentifierInterface";
      uuidV4IriProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const $type = "UuidV4IriIdentifierInterface" as const;
    const uuidV4IriProperty = $jsonObject["uuidV4IriProperty"];
    return Either.of({ $identifier, $type, uuidV4IriProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, UuidV4IriIdentifierInterface> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "UuidV4IriIdentifierInterface" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/uuidV4IriProperty`,
          type: "Control",
        },
      ],
      label: "UuidV4IriIdentifierInterface",
      type: "Group",
    };
  }

  export function $toJson(
    _uuidV4IriIdentifierInterface: UuidV4IriIdentifierInterface,
  ): UuidV4IriIdentifierInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": _uuidV4IriIdentifierInterface.$identifier.value,
        $type: _uuidV4IriIdentifierInterface.$type,
        uuidV4IriProperty: _uuidV4IriIdentifierInterface.uuidV4IriProperty,
      } satisfies UuidV4IriIdentifierInterface.$Json),
    );
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("UuidV4IriIdentifierInterface"),
      uuidV4IriProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "UuidV4IriIdentifierInterface";
    readonly uuidV4IriProperty: string;
  };

  export function isUuidV4IriIdentifierInterface(
    object: $Object,
  ): object is UuidV4IriIdentifierInterface {
    switch (object.$type) {
      case "UuidV4IriIdentifierInterface":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, UuidV4IriIdentifierInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return UuidV4IriIdentifierInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: NamedNode;
      $type: "UuidV4IriIdentifierInterface";
      uuidV4IriProperty: string;
    }
  > {
    return (
      $parameters.resource.identifier.termType === "NamedNode"
        ? Either.of<Error, UuidV4IriIdentifierInterface.$Identifier>(
            $parameters.resource.identifier,
          )
        : Left(
            new Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "NamedNode",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
    ).chain(($identifier) =>
      Either.of<Error, "UuidV4IriIdentifierInterface">(
        "UuidV4IriIdentifierInterface" as const,
      ).chain(($type) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.uuidV4IriProperty.identifier,
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                UuidV4IriIdentifierInterface.$schema.properties
                  .uuidV4IriProperty.identifier,
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((uuidV4IriProperty) => ({
            $identifier,
            $type,
            uuidV4IriProperty,
          })),
      ),
    );
  }

  export function $toRdf(
    _uuidV4IriIdentifierInterface: UuidV4IriIdentifierInterface,
    options?: {
      ignoreRdfType?: boolean;
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource<NamedNode> {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(
      _uuidV4IriIdentifierInterface.$identifier,
    );
    resource.add(
      UuidV4IriIdentifierInterface.$schema.properties.uuidV4IriProperty
        .identifier,
      [$literalFactory.string(_uuidV4IriIdentifierInterface.uuidV4IriProperty)],
      options?.graph,
    );
    return resource;
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "NamedNode" as const }),
      },
      $identifierPrefix: {
        kind: "IdentifierPrefix" as const,
        type: () => ({ kind: "String" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["UuidV4IriIdentifierInterface"],
        }),
      },
      uuidV4IriProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/uuidV4IriProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: UuidV4IriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        UuidV4IriIdentifierInterface.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          UuidV4IriIdentifierInterface.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: UuidV4IriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      UuidV4IriIdentifierInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("uuidV4IriIdentifierInterface");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "uuidV4IriIdentifierInterface")
          }UuidV4IriProperty`,
        ),
        predicate:
          UuidV4IriIdentifierInterface.$schema.properties.uuidV4IriProperty
            .identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: UuidV4IriIdentifierInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("uuidV4IriIdentifierInterface");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $namedNodeSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            UuidV4IriIdentifierInterface.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "uuidV4IriIdentifierInterface"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.uuidV4IriProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "uuidV4IriIdentifierInterface")
                  }UuidV4IriProperty`,
                ),
                predicate:
                  UuidV4IriIdentifierInterface.$schema.properties
                    .uuidV4IriProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          UuidV4IriIdentifierInterface.$schema.properties.uuidV4IriProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "uuidV4IriIdentifierInterface")
          }UuidV4IriProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "uuidV4IriIdentifierInterface")
        }UuidV4IriProperty`,
      }),
    );
    return patterns;
  }
} /**
 * A node shape that mints its identifier by generating a v4 UUID, if no identifier is supplied.
 */

export class UuidV4IriIdentifierClass {
  private _$identifier?: UuidV4IriIdentifierClass.$Identifier;

  protected readonly _$identifierPrefix?: string;

  readonly $type: "UuidV4IriIdentifierClass" =
    "UuidV4IriIdentifierClass" as const;

  readonly uuidV4IriProperty: string;

  constructor(parameters: {
    readonly $identifier?: NamedNode | string;
    readonly $identifierPrefix?: string;
    readonly uuidV4IriProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this._$identifierPrefix = parameters.$identifierPrefix;
    this.uuidV4IriProperty = parameters.uuidV4IriProperty;
  }

  get $identifier(): UuidV4IriIdentifierClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${uuid.v4()}`,
      );
    }
    if (this._$identifier.termType !== "NamedNode") {
      throw new Error(
        `expected identifier to be NamedNode, not ${this._$identifier.termType}`,
      );
    }
    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  $equals(other: UuidV4IriIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$identifierPrefix, other.$identifierPrefix).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$identifierPrefix",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.uuidV4IriProperty, other.uuidV4IriProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "uuidV4IriProperty",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.uuidV4IriProperty);
    return _hasher;
  }

  $toJson(): UuidV4IriIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
        uuidV4IriProperty: this.uuidV4IriProperty,
      } satisfies UuidV4IriIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource<NamedNode> {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    resource.add(
      UuidV4IriIdentifierClass.$schema.properties.uuidV4IriProperty.identifier,
      [$literalFactory.string(this.uuidV4IriProperty)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace UuidV4IriIdentifierClass {
  export function $filter(
    filter: UuidV4IriIdentifierClass.$Filter,
    value: UuidV4IriIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.uuidV4IriProperty !== "undefined" &&
      !$filterString(filter.uuidV4IriProperty, value.uuidV4IriProperty)
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
    readonly uuidV4IriProperty?: $StringFilter;
  };

  export type $Identifier = NamedNode;

  export namespace $Identifier {
    export function fromString(identifier: string): Either<Error, NamedNode> {
      return Either.encase(() =>
        Resource.Identifier.fromString({ dataFactory, identifier }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? Either.of(identifier)
          : Left(new Error("expected identifier to be NamedNode")),
      ) as Either<Error, NamedNode>;
    } // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<z.ZodError, { $identifier: NamedNode; uuidV4IriProperty: string }> {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const uuidV4IriProperty = $jsonObject["uuidV4IriProperty"];
    return Either.of({ $identifier, uuidV4IriProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, UuidV4IriIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new UuidV4IriIdentifierClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "UuidV4IriIdentifierClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/uuidV4IriProperty`,
          type: "Control",
        },
      ],
      label: "UuidV4IriIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("UuidV4IriIdentifierClass"),
      uuidV4IriProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "UuidV4IriIdentifierClass";
    readonly uuidV4IriProperty: string;
  };

  export function isUuidV4IriIdentifierClass(
    object: $Object,
  ): object is UuidV4IriIdentifierClass {
    switch (object.$type) {
      case "UuidV4IriIdentifierClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, UuidV4IriIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return UuidV4IriIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new UuidV4IriIdentifierClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<Error, { $identifier: NamedNode; uuidV4IriProperty: string }> {
    return (
      $parameters.resource.identifier.termType === "NamedNode"
        ? Either.of<Error, UuidV4IriIdentifierClass.$Identifier>(
            $parameters.resource.identifier,
          )
        : Left(
            new Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "NamedNode",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
    ).chain(($identifier) =>
      Either.of<Error, Resource.Values<Resource.TermValue>>(
        $parameters.resource.values(
          $schema.properties.uuidV4IriProperty.identifier,
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              UuidV4IriIdentifierClass.$schema.properties.uuidV4IriProperty
                .identifier,
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((uuidV4IriProperty) => ({ $identifier, uuidV4IriProperty })),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "NamedNode" as const }),
      },
      $identifierPrefix: {
        kind: "IdentifierPrefix" as const,
        type: () => ({ kind: "String" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["UuidV4IriIdentifierClass"],
        }),
      },
      uuidV4IriProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/uuidV4IriProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: UuidV4IriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        UuidV4IriIdentifierClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          UuidV4IriIdentifierClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: UuidV4IriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      UuidV4IriIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("uuidV4IriIdentifierClass");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "uuidV4IriIdentifierClass")
          }UuidV4IriProperty`,
        ),
        predicate:
          UuidV4IriIdentifierClass.$schema.properties.uuidV4IriProperty
            .identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: UuidV4IriIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("uuidV4IriIdentifierClass");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $namedNodeSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            UuidV4IriIdentifierClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "uuidV4IriIdentifierClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.uuidV4IriProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "uuidV4IriIdentifierClass")
                  }UuidV4IriProperty`,
                ),
                predicate:
                  UuidV4IriIdentifierClass.$schema.properties.uuidV4IriProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          UuidV4IriIdentifierClass.$schema.properties.uuidV4IriProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "uuidV4IriIdentifierClass")
          }UuidV4IriProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "uuidV4IriIdentifierClass")
        }UuidV4IriProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Shape with sh:xone (union) properties with different discriminant types (envelope, typeof, property) x cardinality.
 */

export class UnionDiscriminantsClass {
  private _$identifier?: UnionDiscriminantsClass.$Identifier;

  readonly $type: "UnionDiscriminantsClass" =
    "UnionDiscriminantsClass" as const;

  /**
   * Union with an envelope discriminant (multiple+duplicate typeofs, no inline discriminant property).
   */
  readonly optionalClassOrClassOrStringProperty: Maybe<
    | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
    | {
        type: "1-ClassUnionMember2";
        value: ClassUnionMember2;
      }
    | { type: "2-string"; value: string }
  >;

  /**
   * Union that can be discriminated by an inline discriminant property (termType).
   */
  readonly optionalIriOrLiteralProperty: Maybe<NamedNode | Literal>;

  /**
   * Union that can be discriminated by typeof.
   */
  readonly optionalIriOrStringProperty: Maybe<NamedNode | string>;

  /**
   * Union with an envelope discriminant (multiple typeofs, no inline discriminant property).
   */
  readonly requiredClassOrClassOrStringProperty:
    | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
    | {
        type: "1-ClassUnionMember2";
        value: ClassUnionMember2;
      }
    | { type: "2-string"; value: string };

  /**
   * Union that can be discriminated by an inline discriminant property (termType).
   */
  readonly requiredIriOrLiteralProperty: NamedNode | Literal;

  /**
   * Union that can be discriminated by typeof.
   */
  readonly requiredIriOrStringProperty: NamedNode | string;

  /**
   * Union with an envelope discriminant (multiple typeofs, no inline discriminant property).
   */
  readonly setClassOrClassOrStringProperty: readonly (
    | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
    | {
        type: "1-ClassUnionMember2";
        value: ClassUnionMember2;
      }
    | { type: "2-string"; value: string }
  )[];

  /**
   * Union that can be discriminated by an inline discriminant property (termType).
   */
  readonly setIriOrLiteralProperty: readonly (NamedNode | Literal)[];

  /**
   * Union that can be discriminated by typeof.
   */
  readonly setIriOrStringProperty: readonly (NamedNode | string)[];

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly optionalClassOrClassOrStringProperty?:
      | Maybe<
          | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
          | {
              type: "1-ClassUnionMember2";
              value: ClassUnionMember2;
            }
          | { type: "2-string"; value: string }
        >
      | (
          | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
          | {
              type: "1-ClassUnionMember2";
              value: ClassUnionMember2;
            }
          | { type: "2-string"; value: string }
        );
    readonly optionalIriOrLiteralProperty?:
      | Maybe<NamedNode | Literal>
      | (NamedNode | Literal);
    readonly optionalIriOrStringProperty?:
      | Maybe<NamedNode | string>
      | NamedNode
      | string;
    readonly requiredClassOrClassOrStringProperty:
      | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
      | {
          type: "1-ClassUnionMember2";
          value: ClassUnionMember2;
        }
      | { type: "2-string"; value: string };
    readonly requiredIriOrLiteralProperty: NamedNode | Literal;
    readonly requiredIriOrStringProperty: NamedNode | string;
    readonly setClassOrClassOrStringProperty?: readonly (
      | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
      | {
          type: "1-ClassUnionMember2";
          value: ClassUnionMember2;
        }
      | { type: "2-string"; value: string }
    )[];
    readonly setIriOrLiteralProperty?: readonly (NamedNode | Literal)[];
    readonly setIriOrStringProperty?: readonly (NamedNode | string)[];
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    if (Maybe.isMaybe(parameters.optionalClassOrClassOrStringProperty)) {
      this.optionalClassOrClassOrStringProperty =
        parameters.optionalClassOrClassOrStringProperty;
    } else if (
      typeof parameters.optionalClassOrClassOrStringProperty === "object"
    ) {
      this.optionalClassOrClassOrStringProperty = Maybe.of(
        parameters.optionalClassOrClassOrStringProperty,
      );
    } else if (
      typeof parameters.optionalClassOrClassOrStringProperty === "undefined"
    ) {
      this.optionalClassOrClassOrStringProperty = Maybe.empty();
    } else {
      this.optionalClassOrClassOrStringProperty =
        parameters.optionalClassOrClassOrStringProperty satisfies never;
    }
    if (Maybe.isMaybe(parameters.optionalIriOrLiteralProperty)) {
      this.optionalIriOrLiteralProperty =
        parameters.optionalIriOrLiteralProperty;
    } else if (typeof parameters.optionalIriOrLiteralProperty === "object") {
      this.optionalIriOrLiteralProperty = Maybe.of(
        parameters.optionalIriOrLiteralProperty,
      );
    } else if (typeof parameters.optionalIriOrLiteralProperty === "undefined") {
      this.optionalIriOrLiteralProperty = Maybe.empty();
    } else {
      this.optionalIriOrLiteralProperty =
        parameters.optionalIriOrLiteralProperty satisfies never;
    }
    if (Maybe.isMaybe(parameters.optionalIriOrStringProperty)) {
      this.optionalIriOrStringProperty = parameters.optionalIriOrStringProperty;
    } else if (typeof parameters.optionalIriOrStringProperty === "object") {
      this.optionalIriOrStringProperty = Maybe.of(
        parameters.optionalIriOrStringProperty,
      );
    } else if (typeof parameters.optionalIriOrStringProperty === "string") {
      this.optionalIriOrStringProperty = Maybe.of(
        parameters.optionalIriOrStringProperty,
      );
    } else if (typeof parameters.optionalIriOrStringProperty === "undefined") {
      this.optionalIriOrStringProperty = Maybe.empty();
    } else {
      this.optionalIriOrStringProperty =
        parameters.optionalIriOrStringProperty satisfies never;
    }
    this.requiredClassOrClassOrStringProperty =
      parameters.requiredClassOrClassOrStringProperty;
    this.requiredIriOrLiteralProperty = parameters.requiredIriOrLiteralProperty;
    if (typeof parameters.requiredIriOrStringProperty === "object") {
      this.requiredIriOrStringProperty = parameters.requiredIriOrStringProperty;
    } else if (typeof parameters.requiredIriOrStringProperty === "string") {
      this.requiredIriOrStringProperty = parameters.requiredIriOrStringProperty;
    } else {
      this.requiredIriOrStringProperty =
        parameters.requiredIriOrStringProperty satisfies never;
    }
    if (typeof parameters.setClassOrClassOrStringProperty === "undefined") {
      this.setClassOrClassOrStringProperty = [];
    } else if (typeof parameters.setClassOrClassOrStringProperty === "object") {
      this.setClassOrClassOrStringProperty =
        parameters.setClassOrClassOrStringProperty;
    } else {
      this.setClassOrClassOrStringProperty =
        parameters.setClassOrClassOrStringProperty satisfies never;
    }
    if (typeof parameters.setIriOrLiteralProperty === "undefined") {
      this.setIriOrLiteralProperty = [];
    } else if (typeof parameters.setIriOrLiteralProperty === "object") {
      this.setIriOrLiteralProperty = parameters.setIriOrLiteralProperty;
    } else {
      this.setIriOrLiteralProperty =
        parameters.setIriOrLiteralProperty satisfies never;
    }
    if (typeof parameters.setIriOrStringProperty === "undefined") {
      this.setIriOrStringProperty = [];
    } else if (typeof parameters.setIriOrStringProperty === "object") {
      this.setIriOrStringProperty = parameters.setIriOrStringProperty;
    } else {
      this.setIriOrStringProperty =
        parameters.setIriOrStringProperty satisfies never;
    }
  }

  get $identifier(): UnionDiscriminantsClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: UnionDiscriminantsClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (
              left:
                | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                | {
                    type: "1-ClassUnionMember2";
                    value: ClassUnionMember2;
                  }
                | { type: "2-string"; value: string },
              right:
                | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                | {
                    type: "1-ClassUnionMember2";
                    value: ClassUnionMember2;
                  }
                | { type: "2-string"; value: string },
            ) => {
              if (
                left.type === "0-ClassUnionMember1" &&
                right.type === "0-ClassUnionMember1"
              ) {
                return ((left, right) => left.$equals(right))(
                  left.value,
                  right.value,
                );
              }
              if (
                left.type === "1-ClassUnionMember2" &&
                right.type === "1-ClassUnionMember2"
              ) {
                return ((left, right) => left.$equals(right))(
                  left.value,
                  right.value,
                );
              }
              if (left.type === "2-string" && right.type === "2-string") {
                return $strictEquals(left.value, right.value);
              }

              return Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "boolean" as const,
                },
                type: "property" as const,
              });
            },
          ))(
          this.optionalClassOrClassOrStringProperty,
          other.optionalClassOrClassOrStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalClassOrClassOrStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (left: NamedNode | Literal, right: NamedNode | Literal) => {
              if (
                left.termType === "NamedNode" &&
                right.termType === "NamedNode"
              ) {
                return $booleanEquals(left, right);
              }
              if (left.termType === "Literal" && right.termType === "Literal") {
                return $booleanEquals(left, right);
              }

              return Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "boolean" as const,
                },
                type: "property" as const,
              });
            },
          ))(
          this.optionalIriOrLiteralProperty,
          other.optionalIriOrLiteralProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalIriOrLiteralProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (left: NamedNode | string, right: NamedNode | string) => {
              if (typeof left === "object" && typeof right === "object") {
                return $booleanEquals(left, right);
              }
              if (typeof left === "string" && typeof right === "string") {
                return $strictEquals(left, right);
              }

              return Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "boolean" as const,
                },
                type: "property" as const,
              });
            },
          ))(
          this.optionalIriOrStringProperty,
          other.optionalIriOrStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalIriOrStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((
          left:
            | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
            | {
                type: "1-ClassUnionMember2";
                value: ClassUnionMember2;
              }
            | { type: "2-string"; value: string },
          right:
            | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
            | {
                type: "1-ClassUnionMember2";
                value: ClassUnionMember2;
              }
            | { type: "2-string"; value: string },
        ) => {
          if (
            left.type === "0-ClassUnionMember1" &&
            right.type === "0-ClassUnionMember1"
          ) {
            return ((left, right) => left.$equals(right))(
              left.value,
              right.value,
            );
          }
          if (
            left.type === "1-ClassUnionMember2" &&
            right.type === "1-ClassUnionMember2"
          ) {
            return ((left, right) => left.$equals(right))(
              left.value,
              right.value,
            );
          }
          if (left.type === "2-string" && right.type === "2-string") {
            return $strictEquals(left.value, right.value);
          }

          return Left({
            left,
            right,
            propertyName: "type",
            propertyValuesUnequal: {
              left: typeof left,
              right: typeof right,
              type: "boolean" as const,
            },
            type: "property" as const,
          });
        })(
          this.requiredClassOrClassOrStringProperty,
          other.requiredClassOrClassOrStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "requiredClassOrClassOrStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left: NamedNode | Literal, right: NamedNode | Literal) => {
          if (left.termType === "NamedNode" && right.termType === "NamedNode") {
            return $booleanEquals(left, right);
          }
          if (left.termType === "Literal" && right.termType === "Literal") {
            return $booleanEquals(left, right);
          }

          return Left({
            left,
            right,
            propertyName: "type",
            propertyValuesUnequal: {
              left: typeof left,
              right: typeof right,
              type: "boolean" as const,
            },
            type: "property" as const,
          });
        })(
          this.requiredIriOrLiteralProperty,
          other.requiredIriOrLiteralProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "requiredIriOrLiteralProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left: NamedNode | string, right: NamedNode | string) => {
          if (typeof left === "object" && typeof right === "object") {
            return $booleanEquals(left, right);
          }
          if (typeof left === "string" && typeof right === "string") {
            return $strictEquals(left, right);
          }

          return Left({
            left,
            right,
            propertyName: "type",
            propertyValuesUnequal: {
              left: typeof left,
              right: typeof right,
              type: "boolean" as const,
            },
            type: "property" as const,
          });
        })(
          this.requiredIriOrStringProperty,
          other.requiredIriOrStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "requiredIriOrStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(
            left,
            right,
            (
              left:
                | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                | {
                    type: "1-ClassUnionMember2";
                    value: ClassUnionMember2;
                  }
                | { type: "2-string"; value: string },
              right:
                | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                | {
                    type: "1-ClassUnionMember2";
                    value: ClassUnionMember2;
                  }
                | { type: "2-string"; value: string },
            ) => {
              if (
                left.type === "0-ClassUnionMember1" &&
                right.type === "0-ClassUnionMember1"
              ) {
                return ((left, right) => left.$equals(right))(
                  left.value,
                  right.value,
                );
              }
              if (
                left.type === "1-ClassUnionMember2" &&
                right.type === "1-ClassUnionMember2"
              ) {
                return ((left, right) => left.$equals(right))(
                  left.value,
                  right.value,
                );
              }
              if (left.type === "2-string" && right.type === "2-string") {
                return $strictEquals(left.value, right.value);
              }

              return Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "boolean" as const,
                },
                type: "property" as const,
              });
            },
          ))(
          this.setClassOrClassOrStringProperty,
          other.setClassOrClassOrStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "setClassOrClassOrStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(
            left,
            right,
            (left: NamedNode | Literal, right: NamedNode | Literal) => {
              if (
                left.termType === "NamedNode" &&
                right.termType === "NamedNode"
              ) {
                return $booleanEquals(left, right);
              }
              if (left.termType === "Literal" && right.termType === "Literal") {
                return $booleanEquals(left, right);
              }

              return Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "boolean" as const,
                },
                type: "property" as const,
              });
            },
          ))(
          this.setIriOrLiteralProperty,
          other.setIriOrLiteralProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "setIriOrLiteralProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(
            left,
            right,
            (left: NamedNode | string, right: NamedNode | string) => {
              if (typeof left === "object" && typeof right === "object") {
                return $booleanEquals(left, right);
              }
              if (typeof left === "string" && typeof right === "string") {
                return $strictEquals(left, right);
              }

              return Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "boolean" as const,
                },
                type: "property" as const,
              });
            },
          ))(this.setIriOrStringProperty, other.setIriOrStringProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "setIriOrStringProperty",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    this.optionalClassOrClassOrStringProperty.ifJust((value0) => {
      switch (value0.type) {
        case "0-ClassUnionMember1": {
          value0.value.$hash(_hasher);
          break;
        }
        case "1-ClassUnionMember2": {
          value0.value.$hash(_hasher);
          break;
        }
        case "2-string": {
          _hasher.update(value0.value);
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    this.optionalIriOrLiteralProperty.ifJust((value0) => {
      switch (value0.termType) {
        case "NamedNode": {
          _hasher.update(value0.termType);
          _hasher.update(value0.value);
          break;
        }
        case "Literal": {
          _hasher.update(value0.termType);
          _hasher.update(value0.value);
          _hasher.update(value0.datatype.value);
          _hasher.update(value0.language);
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    this.optionalIriOrStringProperty.ifJust((value0) => {
      switch (typeof value0) {
        case "object": {
          _hasher.update(value0.termType);
          _hasher.update(value0.value);
          break;
        }
        case "string": {
          _hasher.update(value0);
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    switch (this.requiredClassOrClassOrStringProperty.type) {
      case "0-ClassUnionMember1": {
        this.requiredClassOrClassOrStringProperty.value.$hash(_hasher);
        break;
      }
      case "1-ClassUnionMember2": {
        this.requiredClassOrClassOrStringProperty.value.$hash(_hasher);
        break;
      }
      case "2-string": {
        _hasher.update(this.requiredClassOrClassOrStringProperty.value);
        break;
      }
      default:
        this.requiredClassOrClassOrStringProperty satisfies never;
        throw new Error("unrecognized type");
    }
    switch (this.requiredIriOrLiteralProperty.termType) {
      case "NamedNode": {
        _hasher.update(this.requiredIriOrLiteralProperty.termType);
        _hasher.update(this.requiredIriOrLiteralProperty.value);
        break;
      }
      case "Literal": {
        _hasher.update(this.requiredIriOrLiteralProperty.termType);
        _hasher.update(this.requiredIriOrLiteralProperty.value);
        _hasher.update(this.requiredIriOrLiteralProperty.datatype.value);
        _hasher.update(this.requiredIriOrLiteralProperty.language);
        break;
      }
      default:
        this.requiredIriOrLiteralProperty satisfies never;
        throw new Error("unrecognized type");
    }
    switch (typeof this.requiredIriOrStringProperty) {
      case "object": {
        _hasher.update(this.requiredIriOrStringProperty.termType);
        _hasher.update(this.requiredIriOrStringProperty.value);
        break;
      }
      case "string": {
        _hasher.update(this.requiredIriOrStringProperty);
        break;
      }
      default:
        this.requiredIriOrStringProperty satisfies never;
        throw new Error("unrecognized type");
    }
    for (const item0 of this.setClassOrClassOrStringProperty) {
      switch (item0.type) {
        case "0-ClassUnionMember1": {
          item0.value.$hash(_hasher);
          break;
        }
        case "1-ClassUnionMember2": {
          item0.value.$hash(_hasher);
          break;
        }
        case "2-string": {
          _hasher.update(item0.value);
          break;
        }
        default:
          item0 satisfies never;
          throw new Error("unrecognized type");
      }
    }
    for (const item0 of this.setIriOrLiteralProperty) {
      switch (item0.termType) {
        case "NamedNode": {
          _hasher.update(item0.termType);
          _hasher.update(item0.value);
          break;
        }
        case "Literal": {
          _hasher.update(item0.termType);
          _hasher.update(item0.value);
          _hasher.update(item0.datatype.value);
          _hasher.update(item0.language);
          break;
        }
        default:
          item0 satisfies never;
          throw new Error("unrecognized type");
      }
    }
    for (const item0 of this.setIriOrStringProperty) {
      switch (typeof item0) {
        case "object": {
          _hasher.update(item0.termType);
          _hasher.update(item0.value);
          break;
        }
        case "string": {
          _hasher.update(item0);
          break;
        }
        default:
          item0 satisfies never;
          throw new Error("unrecognized type");
      }
    }
    return _hasher;
  }

  $toJson(): UnionDiscriminantsClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        optionalClassOrClassOrStringProperty:
          this.optionalClassOrClassOrStringProperty
            .map((item) =>
              item.type === "2-string"
                ? { type: "2-string" as const, value: item.value }
                : item.type === "1-ClassUnionMember2"
                  ? {
                      type: "1-ClassUnionMember2" as const,
                      value: item.value.$toJson(),
                    }
                  : {
                      type: "0-ClassUnionMember1" as const,
                      value: item.value.$toJson(),
                    },
            )
            .extract(),
        optionalIriOrLiteralProperty: this.optionalIriOrLiteralProperty
          .map((item) =>
            item.termType === "Literal"
              ? {
                  "@language":
                    item.language.length > 0 ? item.language : undefined,
                  termType: "Literal" as const,
                  "@type":
                    item.datatype.value !==
                    "http://www.w3.org/2001/XMLSchema#string"
                      ? item.datatype.value
                      : undefined,
                  "@value": item.value,
                }
              : { "@id": item.value, termType: item.termType },
          )
          .extract(),
        optionalIriOrStringProperty: this.optionalIriOrStringProperty
          .map((item) =>
            typeof item === "string" ? item : { "@id": item.value },
          )
          .extract(),
        requiredClassOrClassOrStringProperty:
          this.requiredClassOrClassOrStringProperty.type === "2-string"
            ? {
                type: "2-string" as const,
                value: this.requiredClassOrClassOrStringProperty.value,
              }
            : this.requiredClassOrClassOrStringProperty.type ===
                "1-ClassUnionMember2"
              ? {
                  type: "1-ClassUnionMember2" as const,
                  value:
                    this.requiredClassOrClassOrStringProperty.value.$toJson(),
                }
              : {
                  type: "0-ClassUnionMember1" as const,
                  value:
                    this.requiredClassOrClassOrStringProperty.value.$toJson(),
                },
        requiredIriOrLiteralProperty:
          this.requiredIriOrLiteralProperty.termType === "Literal"
            ? {
                "@language":
                  this.requiredIriOrLiteralProperty.language.length > 0
                    ? this.requiredIriOrLiteralProperty.language
                    : undefined,
                termType: "Literal" as const,
                "@type":
                  this.requiredIriOrLiteralProperty.datatype.value !==
                  "http://www.w3.org/2001/XMLSchema#string"
                    ? this.requiredIriOrLiteralProperty.datatype.value
                    : undefined,
                "@value": this.requiredIriOrLiteralProperty.value,
              }
            : {
                "@id": this.requiredIriOrLiteralProperty.value,
                termType: this.requiredIriOrLiteralProperty.termType,
              },
        requiredIriOrStringProperty:
          typeof this.requiredIriOrStringProperty === "string"
            ? this.requiredIriOrStringProperty
            : { "@id": this.requiredIriOrStringProperty.value },
        setClassOrClassOrStringProperty:
          this.setClassOrClassOrStringProperty.map((item) =>
            item.type === "2-string"
              ? { type: "2-string" as const, value: item.value }
              : item.type === "1-ClassUnionMember2"
                ? {
                    type: "1-ClassUnionMember2" as const,
                    value: item.value.$toJson(),
                  }
                : {
                    type: "0-ClassUnionMember1" as const,
                    value: item.value.$toJson(),
                  },
          ),
        setIriOrLiteralProperty: this.setIriOrLiteralProperty.map((item) =>
          item.termType === "Literal"
            ? {
                "@language":
                  item.language.length > 0 ? item.language : undefined,
                termType: "Literal" as const,
                "@type":
                  item.datatype.value !==
                  "http://www.w3.org/2001/XMLSchema#string"
                    ? item.datatype.value
                    : undefined,
                "@value": item.value,
              }
            : { "@id": item.value, termType: item.termType },
        ),
        setIriOrStringProperty: this.setIriOrStringProperty.map((item) =>
          typeof item === "string" ? item : { "@id": item.value },
        ),
      } satisfies UnionDiscriminantsClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    resource.add(
      UnionDiscriminantsClass.$schema.properties
        .optionalClassOrClassOrStringProperty.identifier,
      this.optionalClassOrClassOrStringProperty.toList().flatMap((value) =>
        value.type === "2-string"
          ? ([$literalFactory.string(value.value)] as (
              | bigint
              | boolean
              | number
              | string
              | BlankNode
              | Literal
              | NamedNode
            )[])
          : ([
              value.value.$toRdf({
                graph: options?.graph,
                resourceSet: resourceSet,
              }).identifier,
            ] as (
              | bigint
              | boolean
              | number
              | string
              | BlankNode
              | Literal
              | NamedNode
            )[]),
      ),
      options?.graph,
    );
    resource.add(
      UnionDiscriminantsClass.$schema.properties.optionalIriOrLiteralProperty
        .identifier,
      this.optionalIriOrLiteralProperty
        .toList()
        .flatMap(
          (value) =>
            [value] as (
              | bigint
              | boolean
              | number
              | string
              | BlankNode
              | Literal
              | NamedNode
            )[],
        ),
      options?.graph,
    );
    resource.add(
      UnionDiscriminantsClass.$schema.properties.optionalIriOrStringProperty
        .identifier,
      this.optionalIriOrStringProperty
        .toList()
        .flatMap((value) =>
          typeof value === "string"
            ? ([$literalFactory.string(value)] as (
                | bigint
                | boolean
                | number
                | string
                | BlankNode
                | Literal
                | NamedNode
              )[])
            : ([value] as (
                | bigint
                | boolean
                | number
                | string
                | BlankNode
                | Literal
                | NamedNode
              )[]),
        ),
      options?.graph,
    );
    resource.add(
      UnionDiscriminantsClass.$schema.properties
        .requiredClassOrClassOrStringProperty.identifier,
      this.requiredClassOrClassOrStringProperty.type === "2-string"
        ? ([
            $literalFactory.string(
              this.requiredClassOrClassOrStringProperty.value,
            ),
          ] as (
            | bigint
            | boolean
            | number
            | string
            | BlankNode
            | Literal
            | NamedNode
          )[])
        : ([
            this.requiredClassOrClassOrStringProperty.value.$toRdf({
              graph: options?.graph,
              resourceSet: resourceSet,
            }).identifier,
          ] as (
            | bigint
            | boolean
            | number
            | string
            | BlankNode
            | Literal
            | NamedNode
          )[]),
      options?.graph,
    );
    resource.add(
      UnionDiscriminantsClass.$schema.properties.requiredIriOrLiteralProperty
        .identifier,
      [this.requiredIriOrLiteralProperty] as (
        | bigint
        | boolean
        | number
        | string
        | BlankNode
        | Literal
        | NamedNode
      )[],
      options?.graph,
    );
    resource.add(
      UnionDiscriminantsClass.$schema.properties.requiredIriOrStringProperty
        .identifier,
      typeof this.requiredIriOrStringProperty === "string"
        ? ([$literalFactory.string(this.requiredIriOrStringProperty)] as (
            | bigint
            | boolean
            | number
            | string
            | BlankNode
            | Literal
            | NamedNode
          )[])
        : ([this.requiredIriOrStringProperty] as (
            | bigint
            | boolean
            | number
            | string
            | BlankNode
            | Literal
            | NamedNode
          )[]),
      options?.graph,
    );
    resource.add(
      UnionDiscriminantsClass.$schema.properties.setClassOrClassOrStringProperty
        .identifier,
      this.setClassOrClassOrStringProperty.flatMap((item) =>
        item.type === "2-string"
          ? ([$literalFactory.string(item.value)] as (
              | bigint
              | boolean
              | number
              | string
              | BlankNode
              | Literal
              | NamedNode
            )[])
          : ([
              item.value.$toRdf({
                graph: options?.graph,
                resourceSet: resourceSet,
              }).identifier,
            ] as (
              | bigint
              | boolean
              | number
              | string
              | BlankNode
              | Literal
              | NamedNode
            )[]),
      ),
      options?.graph,
    );
    resource.add(
      UnionDiscriminantsClass.$schema.properties.setIriOrLiteralProperty
        .identifier,
      this.setIriOrLiteralProperty.flatMap(
        (item) =>
          [item] as (
            | bigint
            | boolean
            | number
            | string
            | BlankNode
            | Literal
            | NamedNode
          )[],
      ),
      options?.graph,
    );
    resource.add(
      UnionDiscriminantsClass.$schema.properties.setIriOrStringProperty
        .identifier,
      this.setIriOrStringProperty.flatMap((item) =>
        typeof item === "string"
          ? ([$literalFactory.string(item)] as (
              | bigint
              | boolean
              | number
              | string
              | BlankNode
              | Literal
              | NamedNode
            )[])
          : ([item] as (
              | bigint
              | boolean
              | number
              | string
              | BlankNode
              | Literal
              | NamedNode
            )[]),
      ),
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace UnionDiscriminantsClass {
  export function $filter(
    filter: UnionDiscriminantsClass.$Filter,
    value: UnionDiscriminantsClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.optionalClassOrClassOrStringProperty !== "undefined" &&
      !$filterMaybe<
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | {
            type: "1-ClassUnionMember2";
            value: ClassUnionMember2;
          }
        | { type: "2-string"; value: string },
        {
          readonly on?: {
            readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
            readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
            readonly "2-string"?: $StringFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
              readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
              readonly "2-string"?: $StringFilter;
            };
          },
          value:
            | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
            | {
                type: "1-ClassUnionMember2";
                value: ClassUnionMember2;
              }
            | { type: "2-string"; value: string },
        ) => {
          if (typeof filter.on?.["0-ClassUnionMember1"] !== "undefined") {
            switch (value.type) {
              case "0-ClassUnionMember1":
                if (
                  !ClassUnionMember1.$filter(
                    filter.on["0-ClassUnionMember1"],
                    value.value,
                  )
                ) {
                  return false;
                }
                break;
            }
          }
          if (typeof filter.on?.["1-ClassUnionMember2"] !== "undefined") {
            switch (value.type) {
              case "1-ClassUnionMember2":
                if (
                  !ClassUnionMember2.$filter(
                    filter.on["1-ClassUnionMember2"],
                    value.value,
                  )
                ) {
                  return false;
                }
                break;
            }
          }
          if (typeof filter.on?.["2-string"] !== "undefined") {
            switch (value.type) {
              case "2-string":
                if (!$filterString(filter.on["2-string"], value.value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(
        filter.optionalClassOrClassOrStringProperty,
        value.optionalClassOrClassOrStringProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.optionalIriOrLiteralProperty !== "undefined" &&
      !$filterMaybe<
        NamedNode | Literal,
        {
          readonly on?: {
            readonly NamedNode?: $NamedNodeFilter;
            readonly Literal?: $LiteralFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly NamedNode?: $NamedNodeFilter;
              readonly Literal?: $LiteralFilter;
            };
          },
          value: NamedNode | Literal,
        ) => {
          if (typeof filter.on?.["NamedNode"] !== "undefined") {
            switch (value.termType) {
              case "NamedNode":
                if (!$filterNamedNode(filter.on["NamedNode"], value)) {
                  return false;
                }
                break;
            }
          }
          if (typeof filter.on?.["Literal"] !== "undefined") {
            switch (value.termType) {
              case "Literal":
                if (!$filterLiteral(filter.on["Literal"], value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.optionalIriOrLiteralProperty, value.optionalIriOrLiteralProperty)
    ) {
      return false;
    }
    if (
      typeof filter.optionalIriOrStringProperty !== "undefined" &&
      !$filterMaybe<
        NamedNode | string,
        {
          readonly on?: {
            readonly object?: $NamedNodeFilter;
            readonly string?: $StringFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly object?: $NamedNodeFilter;
              readonly string?: $StringFilter;
            };
          },
          value: NamedNode | string,
        ) => {
          if (typeof filter.on?.["object"] !== "undefined") {
            switch (typeof value) {
              case "object":
                if (!$filterNamedNode(filter.on["object"], value)) {
                  return false;
                }
                break;
            }
          }
          if (typeof filter.on?.["string"] !== "undefined") {
            switch (typeof value) {
              case "string":
                if (!$filterString(filter.on["string"], value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.optionalIriOrStringProperty, value.optionalIriOrStringProperty)
    ) {
      return false;
    }
    if (
      typeof filter.requiredClassOrClassOrStringProperty !== "undefined" &&
      !((
        filter: {
          readonly on?: {
            readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
            readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
            readonly "2-string"?: $StringFilter;
          };
        },
        value:
          | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
          | {
              type: "1-ClassUnionMember2";
              value: ClassUnionMember2;
            }
          | { type: "2-string"; value: string },
      ) => {
        if (typeof filter.on?.["0-ClassUnionMember1"] !== "undefined") {
          switch (value.type) {
            case "0-ClassUnionMember1":
              if (
                !ClassUnionMember1.$filter(
                  filter.on["0-ClassUnionMember1"],
                  value.value,
                )
              ) {
                return false;
              }
              break;
          }
        }
        if (typeof filter.on?.["1-ClassUnionMember2"] !== "undefined") {
          switch (value.type) {
            case "1-ClassUnionMember2":
              if (
                !ClassUnionMember2.$filter(
                  filter.on["1-ClassUnionMember2"],
                  value.value,
                )
              ) {
                return false;
              }
              break;
          }
        }
        if (typeof filter.on?.["2-string"] !== "undefined") {
          switch (value.type) {
            case "2-string":
              if (!$filterString(filter.on["2-string"], value.value)) {
                return false;
              }
              break;
          }
        }

        return true;
      })(
        filter.requiredClassOrClassOrStringProperty,
        value.requiredClassOrClassOrStringProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.requiredIriOrLiteralProperty !== "undefined" &&
      !((
        filter: {
          readonly on?: {
            readonly NamedNode?: $NamedNodeFilter;
            readonly Literal?: $LiteralFilter;
          };
        },
        value: NamedNode | Literal,
      ) => {
        if (typeof filter.on?.["NamedNode"] !== "undefined") {
          switch (value.termType) {
            case "NamedNode":
              if (!$filterNamedNode(filter.on["NamedNode"], value)) {
                return false;
              }
              break;
          }
        }
        if (typeof filter.on?.["Literal"] !== "undefined") {
          switch (value.termType) {
            case "Literal":
              if (!$filterLiteral(filter.on["Literal"], value)) {
                return false;
              }
              break;
          }
        }

        return true;
      })(
        filter.requiredIriOrLiteralProperty,
        value.requiredIriOrLiteralProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.requiredIriOrStringProperty !== "undefined" &&
      !((
        filter: {
          readonly on?: {
            readonly object?: $NamedNodeFilter;
            readonly string?: $StringFilter;
          };
        },
        value: NamedNode | string,
      ) => {
        if (typeof filter.on?.["object"] !== "undefined") {
          switch (typeof value) {
            case "object":
              if (!$filterNamedNode(filter.on["object"], value)) {
                return false;
              }
              break;
          }
        }
        if (typeof filter.on?.["string"] !== "undefined") {
          switch (typeof value) {
            case "string":
              if (!$filterString(filter.on["string"], value)) {
                return false;
              }
              break;
          }
        }

        return true;
      })(filter.requiredIriOrStringProperty, value.requiredIriOrStringProperty)
    ) {
      return false;
    }
    if (
      typeof filter.setClassOrClassOrStringProperty !== "undefined" &&
      !$filterArray<
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | {
            type: "1-ClassUnionMember2";
            value: ClassUnionMember2;
          }
        | { type: "2-string"; value: string },
        {
          readonly on?: {
            readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
            readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
            readonly "2-string"?: $StringFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
              readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
              readonly "2-string"?: $StringFilter;
            };
          },
          value:
            | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
            | {
                type: "1-ClassUnionMember2";
                value: ClassUnionMember2;
              }
            | { type: "2-string"; value: string },
        ) => {
          if (typeof filter.on?.["0-ClassUnionMember1"] !== "undefined") {
            switch (value.type) {
              case "0-ClassUnionMember1":
                if (
                  !ClassUnionMember1.$filter(
                    filter.on["0-ClassUnionMember1"],
                    value.value,
                  )
                ) {
                  return false;
                }
                break;
            }
          }
          if (typeof filter.on?.["1-ClassUnionMember2"] !== "undefined") {
            switch (value.type) {
              case "1-ClassUnionMember2":
                if (
                  !ClassUnionMember2.$filter(
                    filter.on["1-ClassUnionMember2"],
                    value.value,
                  )
                ) {
                  return false;
                }
                break;
            }
          }
          if (typeof filter.on?.["2-string"] !== "undefined") {
            switch (value.type) {
              case "2-string":
                if (!$filterString(filter.on["2-string"], value.value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(
        filter.setClassOrClassOrStringProperty,
        value.setClassOrClassOrStringProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.setIriOrLiteralProperty !== "undefined" &&
      !$filterArray<
        NamedNode | Literal,
        {
          readonly on?: {
            readonly NamedNode?: $NamedNodeFilter;
            readonly Literal?: $LiteralFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly NamedNode?: $NamedNodeFilter;
              readonly Literal?: $LiteralFilter;
            };
          },
          value: NamedNode | Literal,
        ) => {
          if (typeof filter.on?.["NamedNode"] !== "undefined") {
            switch (value.termType) {
              case "NamedNode":
                if (!$filterNamedNode(filter.on["NamedNode"], value)) {
                  return false;
                }
                break;
            }
          }
          if (typeof filter.on?.["Literal"] !== "undefined") {
            switch (value.termType) {
              case "Literal":
                if (!$filterLiteral(filter.on["Literal"], value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.setIriOrLiteralProperty, value.setIriOrLiteralProperty)
    ) {
      return false;
    }
    if (
      typeof filter.setIriOrStringProperty !== "undefined" &&
      !$filterArray<
        NamedNode | string,
        {
          readonly on?: {
            readonly object?: $NamedNodeFilter;
            readonly string?: $StringFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly object?: $NamedNodeFilter;
              readonly string?: $StringFilter;
            };
          },
          value: NamedNode | string,
        ) => {
          if (typeof filter.on?.["object"] !== "undefined") {
            switch (typeof value) {
              case "object":
                if (!$filterNamedNode(filter.on["object"], value)) {
                  return false;
                }
                break;
            }
          }
          if (typeof filter.on?.["string"] !== "undefined") {
            switch (typeof value) {
              case "string":
                if (!$filterString(filter.on["string"], value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.setIriOrStringProperty, value.setIriOrStringProperty)
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly optionalClassOrClassOrStringProperty?: $MaybeFilter<{
      readonly on?: {
        readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
        readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
        readonly "2-string"?: $StringFilter;
      };
    }>;
    readonly optionalIriOrLiteralProperty?: $MaybeFilter<{
      readonly on?: {
        readonly NamedNode?: $NamedNodeFilter;
        readonly Literal?: $LiteralFilter;
      };
    }>;
    readonly optionalIriOrStringProperty?: $MaybeFilter<{
      readonly on?: {
        readonly object?: $NamedNodeFilter;
        readonly string?: $StringFilter;
      };
    }>;
    readonly requiredClassOrClassOrStringProperty?: {
      readonly on?: {
        readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
        readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
        readonly "2-string"?: $StringFilter;
      };
    };
    readonly requiredIriOrLiteralProperty?: {
      readonly on?: {
        readonly NamedNode?: $NamedNodeFilter;
        readonly Literal?: $LiteralFilter;
      };
    };
    readonly requiredIriOrStringProperty?: {
      readonly on?: {
        readonly object?: $NamedNodeFilter;
        readonly string?: $StringFilter;
      };
    };
    readonly setClassOrClassOrStringProperty?: $CollectionFilter<{
      readonly on?: {
        readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
        readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
        readonly "2-string"?: $StringFilter;
      };
    }>;
    readonly setIriOrLiteralProperty?: $CollectionFilter<{
      readonly on?: {
        readonly NamedNode?: $NamedNodeFilter;
        readonly Literal?: $LiteralFilter;
      };
    }>;
    readonly setIriOrStringProperty?: $CollectionFilter<{
      readonly on?: {
        readonly object?: $NamedNodeFilter;
        readonly string?: $StringFilter;
      };
    }>;
  };

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      optionalClassOrClassOrStringProperty: Maybe<
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | {
            type: "1-ClassUnionMember2";
            value: ClassUnionMember2;
          }
        | { type: "2-string"; value: string }
      >;
      optionalIriOrLiteralProperty: Maybe<NamedNode | Literal>;
      optionalIriOrStringProperty: Maybe<NamedNode | string>;
      requiredClassOrClassOrStringProperty:
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | {
            type: "1-ClassUnionMember2";
            value: ClassUnionMember2;
          }
        | { type: "2-string"; value: string };
      requiredIriOrLiteralProperty: NamedNode | Literal;
      requiredIriOrStringProperty: NamedNode | string;
      setClassOrClassOrStringProperty: readonly (
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | {
            type: "1-ClassUnionMember2";
            value: ClassUnionMember2;
          }
        | { type: "2-string"; value: string }
      )[];
      setIriOrLiteralProperty: readonly (NamedNode | Literal)[];
      setIriOrStringProperty: readonly (NamedNode | string)[];
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const optionalClassOrClassOrStringProperty = Maybe.fromNullable(
      $jsonObject["optionalClassOrClassOrStringProperty"],
    ).map((item) =>
      item.type === "2-string"
        ? { type: "2-string" as const, value: item.value }
        : item.type === "1-ClassUnionMember2"
          ? {
              type: "1-ClassUnionMember2" as const,
              value: ClassUnionMember2.$fromJson(item.value).unsafeCoerce(),
            }
          : {
              type: "0-ClassUnionMember1" as const,
              value: ClassUnionMember1.$fromJson(item.value).unsafeCoerce(),
            },
    );
    const optionalIriOrLiteralProperty = Maybe.fromNullable(
      $jsonObject["optionalIriOrLiteralProperty"],
    ).map((item) =>
      item.termType === "Literal"
        ? dataFactory.literal(
            item["@value"],
            typeof item["@language"] !== "undefined"
              ? item["@language"]
              : typeof item["@type"] !== "undefined"
                ? dataFactory.namedNode(item["@type"])
                : undefined,
          )
        : dataFactory.namedNode(item["@id"]),
    );
    const optionalIriOrStringProperty = Maybe.fromNullable(
      $jsonObject["optionalIriOrStringProperty"],
    ).map((item) =>
      typeof item === "string" ? item : dataFactory.namedNode(item["@id"]),
    );
    const requiredClassOrClassOrStringProperty =
      $jsonObject["requiredClassOrClassOrStringProperty"].type === "2-string"
        ? {
            type: "2-string" as const,
            value: $jsonObject["requiredClassOrClassOrStringProperty"].value,
          }
        : $jsonObject["requiredClassOrClassOrStringProperty"].type ===
            "1-ClassUnionMember2"
          ? {
              type: "1-ClassUnionMember2" as const,
              value: ClassUnionMember2.$fromJson(
                $jsonObject["requiredClassOrClassOrStringProperty"].value,
              ).unsafeCoerce(),
            }
          : {
              type: "0-ClassUnionMember1" as const,
              value: ClassUnionMember1.$fromJson(
                $jsonObject["requiredClassOrClassOrStringProperty"].value,
              ).unsafeCoerce(),
            };
    const requiredIriOrLiteralProperty =
      $jsonObject["requiredIriOrLiteralProperty"].termType === "Literal"
        ? dataFactory.literal(
            $jsonObject["requiredIriOrLiteralProperty"]["@value"],
            typeof $jsonObject["requiredIriOrLiteralProperty"]["@language"] !==
              "undefined"
              ? $jsonObject["requiredIriOrLiteralProperty"]["@language"]
              : typeof $jsonObject["requiredIriOrLiteralProperty"]["@type"] !==
                  "undefined"
                ? dataFactory.namedNode(
                    $jsonObject["requiredIriOrLiteralProperty"]["@type"],
                  )
                : undefined,
          )
        : dataFactory.namedNode(
            $jsonObject["requiredIriOrLiteralProperty"]["@id"],
          );
    const requiredIriOrStringProperty =
      typeof $jsonObject["requiredIriOrStringProperty"] === "string"
        ? $jsonObject["requiredIriOrStringProperty"]
        : dataFactory.namedNode(
            $jsonObject["requiredIriOrStringProperty"]["@id"],
          );
    const setClassOrClassOrStringProperty = $jsonObject[
      "setClassOrClassOrStringProperty"
    ].map((item) =>
      item.type === "2-string"
        ? { type: "2-string" as const, value: item.value }
        : item.type === "1-ClassUnionMember2"
          ? {
              type: "1-ClassUnionMember2" as const,
              value: ClassUnionMember2.$fromJson(item.value).unsafeCoerce(),
            }
          : {
              type: "0-ClassUnionMember1" as const,
              value: ClassUnionMember1.$fromJson(item.value).unsafeCoerce(),
            },
    );
    const setIriOrLiteralProperty = $jsonObject["setIriOrLiteralProperty"].map(
      (item) =>
        item.termType === "Literal"
          ? dataFactory.literal(
              item["@value"],
              typeof item["@language"] !== "undefined"
                ? item["@language"]
                : typeof item["@type"] !== "undefined"
                  ? dataFactory.namedNode(item["@type"])
                  : undefined,
            )
          : dataFactory.namedNode(item["@id"]),
    );
    const setIriOrStringProperty = $jsonObject["setIriOrStringProperty"].map(
      (item) =>
        typeof item === "string" ? item : dataFactory.namedNode(item["@id"]),
    );
    return Either.of({
      $identifier,
      optionalClassOrClassOrStringProperty,
      optionalIriOrLiteralProperty,
      optionalIriOrStringProperty,
      requiredClassOrClassOrStringProperty,
      requiredIriOrLiteralProperty,
      requiredIriOrStringProperty,
      setClassOrClassOrStringProperty,
      setIriOrLiteralProperty,
      setIriOrStringProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, UnionDiscriminantsClass> {
    return $propertiesFromJson(json).map(
      (properties) => new UnionDiscriminantsClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "UnionDiscriminantsClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/optionalClassOrClassOrStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/optionalIriOrLiteralProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/optionalIriOrStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/requiredClassOrClassOrStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/requiredIriOrLiteralProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/requiredIriOrStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/setClassOrClassOrStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/setIriOrLiteralProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/setIriOrStringProperty`,
          type: "Control",
        },
      ],
      label: "UnionDiscriminantsClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("UnionDiscriminantsClass"),
      optionalClassOrClassOrStringProperty: z
        .discriminatedUnion("type", [
          z.object({
            type: z.literal("0-ClassUnionMember1"),
            value: ClassUnionMember1.$jsonZodSchema(),
          }),
          z.object({
            type: z.literal("1-ClassUnionMember2"),
            value: ClassUnionMember2.$jsonZodSchema(),
          }),
          z.object({ type: z.literal("2-string"), value: z.string() }),
        ])
        .optional()
        .describe(
          "Union with an envelope discriminant (multiple+duplicate typeofs, no inline discriminant property).",
        ),
      optionalIriOrLiteralProperty: z
        .discriminatedUnion("termType", [
          z.object({
            "@id": z.string().min(1),
            termType: z.literal("NamedNode"),
          }),
          z.object({
            "@language": z.string().optional(),
            termType: z.literal("Literal"),
            "@type": z.string().optional(),
            "@value": z.string(),
          }),
        ])
        .optional()
        .describe(
          "Union that can be discriminated by an inline discriminant property (termType).",
        ),
      optionalIriOrStringProperty: z
        .union([z.object({ "@id": z.string().min(1) }), z.string()])
        .optional()
        .describe("Union that can be discriminated by typeof."),
      requiredClassOrClassOrStringProperty: z
        .discriminatedUnion("type", [
          z.object({
            type: z.literal("0-ClassUnionMember1"),
            value: ClassUnionMember1.$jsonZodSchema(),
          }),
          z.object({
            type: z.literal("1-ClassUnionMember2"),
            value: ClassUnionMember2.$jsonZodSchema(),
          }),
          z.object({ type: z.literal("2-string"), value: z.string() }),
        ])
        .describe(
          "Union with an envelope discriminant (multiple typeofs, no inline discriminant property).",
        ),
      requiredIriOrLiteralProperty: z
        .discriminatedUnion("termType", [
          z.object({
            "@id": z.string().min(1),
            termType: z.literal("NamedNode"),
          }),
          z.object({
            "@language": z.string().optional(),
            termType: z.literal("Literal"),
            "@type": z.string().optional(),
            "@value": z.string(),
          }),
        ])
        .describe(
          "Union that can be discriminated by an inline discriminant property (termType).",
        ),
      requiredIriOrStringProperty: z
        .union([z.object({ "@id": z.string().min(1) }), z.string()])
        .describe("Union that can be discriminated by typeof."),
      setClassOrClassOrStringProperty: z
        .discriminatedUnion("type", [
          z.object({
            type: z.literal("0-ClassUnionMember1"),
            value: ClassUnionMember1.$jsonZodSchema(),
          }),
          z.object({
            type: z.literal("1-ClassUnionMember2"),
            value: ClassUnionMember2.$jsonZodSchema(),
          }),
          z.object({ type: z.literal("2-string"), value: z.string() }),
        ])
        .array()
        .default(() => [])
        .describe(
          "Union with an envelope discriminant (multiple typeofs, no inline discriminant property).",
        ),
      setIriOrLiteralProperty: z
        .discriminatedUnion("termType", [
          z.object({
            "@id": z.string().min(1),
            termType: z.literal("NamedNode"),
          }),
          z.object({
            "@language": z.string().optional(),
            termType: z.literal("Literal"),
            "@type": z.string().optional(),
            "@value": z.string(),
          }),
        ])
        .array()
        .default(() => [])
        .describe(
          "Union that can be discriminated by an inline discriminant property (termType).",
        ),
      setIriOrStringProperty: z
        .union([z.object({ "@id": z.string().min(1) }), z.string()])
        .array()
        .default(() => [])
        .describe("Union that can be discriminated by typeof."),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "UnionDiscriminantsClass";
    readonly optionalClassOrClassOrStringProperty?:
      | { type: "0-ClassUnionMember1"; value: ClassUnionMember1.$Json }
      | {
          type: "1-ClassUnionMember2";
          value: ClassUnionMember2.$Json;
        }
      | { type: "2-string"; value: string };
    readonly optionalIriOrLiteralProperty?:
      | { readonly "@id": string; readonly termType: "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly termType: "Literal";
          readonly "@type"?: string;
          readonly "@value": string;
        };
    readonly optionalIriOrStringProperty?: { readonly "@id": string } | string;
    readonly requiredClassOrClassOrStringProperty:
      | { type: "0-ClassUnionMember1"; value: ClassUnionMember1.$Json }
      | {
          type: "1-ClassUnionMember2";
          value: ClassUnionMember2.$Json;
        }
      | { type: "2-string"; value: string };
    readonly requiredIriOrLiteralProperty:
      | { readonly "@id": string; readonly termType: "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly termType: "Literal";
          readonly "@type"?: string;
          readonly "@value": string;
        };
    readonly requiredIriOrStringProperty: { readonly "@id": string } | string;
    readonly setClassOrClassOrStringProperty?: readonly (
      | { type: "0-ClassUnionMember1"; value: ClassUnionMember1.$Json }
      | {
          type: "1-ClassUnionMember2";
          value: ClassUnionMember2.$Json;
        }
      | { type: "2-string"; value: string }
    )[];
    readonly setIriOrLiteralProperty?: readonly (
      | { readonly "@id": string; readonly termType: "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly termType: "Literal";
          readonly "@type"?: string;
          readonly "@value": string;
        }
    )[];
    readonly setIriOrStringProperty?: readonly (
      | { readonly "@id": string }
      | string
    )[];
  };

  export function isUnionDiscriminantsClass(
    object: $Object,
  ): object is UnionDiscriminantsClass {
    switch (object.$type) {
      case "UnionDiscriminantsClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, UnionDiscriminantsClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return UnionDiscriminantsClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new UnionDiscriminantsClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      optionalClassOrClassOrStringProperty: Maybe<
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | {
            type: "1-ClassUnionMember2";
            value: ClassUnionMember2;
          }
        | { type: "2-string"; value: string }
      >;
      optionalIriOrLiteralProperty: Maybe<NamedNode | Literal>;
      optionalIriOrStringProperty: Maybe<NamedNode | string>;
      requiredClassOrClassOrStringProperty:
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | {
            type: "1-ClassUnionMember2";
            value: ClassUnionMember2;
          }
        | { type: "2-string"; value: string };
      requiredIriOrLiteralProperty: NamedNode | Literal;
      requiredIriOrStringProperty: NamedNode | string;
      setClassOrClassOrStringProperty: readonly (
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | {
            type: "1-ClassUnionMember2";
            value: ClassUnionMember2;
          }
        | { type: "2-string"; value: string }
      )[];
      setIriOrLiteralProperty: readonly (NamedNode | Literal)[];
      setIriOrStringProperty: readonly (NamedNode | string)[];
    }
  > {
    return Either.of<Error, UnionDiscriminantsClass.$Identifier>(
      $parameters.resource.identifier as UnionDiscriminantsClass.$Identifier,
    ).chain(($identifier) =>
      Either.of<Error, Resource.Values<Resource.TermValue>>(
        $parameters.resource.values(
          $schema.properties.optionalClassOrClassOrStringProperty.identifier,
          {
            unique: true,
          },
        ),
      )
        .chain((values) =>
          values.chainMap((value) => {
            const valueAsValues = Either.of(value.toValues());
            return (
              valueAsValues
                .chain((values) =>
                  values.chainMap((value) =>
                    value.toResource().chain((resource) =>
                      ClassUnionMember1.$fromRdf(resource, {
                        context: $parameters.context,
                        objectSet: $parameters.objectSet,
                        preferredLanguages: $parameters.preferredLanguages,
                      }),
                    ),
                  ),
                )
                .map((values) =>
                  values.map(
                    (value) =>
                      ({
                        type: "0-ClassUnionMember1" as const,
                        value,
                      }) as
                        | {
                            type: "0-ClassUnionMember1";
                            value: ClassUnionMember1;
                          }
                        | {
                            type: "1-ClassUnionMember2";
                            value: ClassUnionMember2;
                          }
                        | { type: "2-string"; value: string },
                  ),
                ) as Either<
                Error,
                Resource.Values<
                  | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                  | {
                      type: "1-ClassUnionMember2";
                      value: ClassUnionMember2;
                    }
                  | { type: "2-string"; value: string }
                >
              >
            )
              .altLazy(
                () =>
                  valueAsValues
                    .chain((values) =>
                      values.chainMap((value) =>
                        value.toResource().chain((resource) =>
                          ClassUnionMember2.$fromRdf(resource, {
                            context: $parameters.context,
                            objectSet: $parameters.objectSet,
                            preferredLanguages: $parameters.preferredLanguages,
                          }),
                        ),
                      ),
                    )
                    .map((values) =>
                      values.map(
                        (value) =>
                          ({
                            type: "1-ClassUnionMember2" as const,
                            value,
                          }) as
                            | {
                                type: "0-ClassUnionMember1";
                                value: ClassUnionMember1;
                              }
                            | {
                                type: "1-ClassUnionMember2";
                                value: ClassUnionMember2;
                              }
                            | { type: "2-string"; value: string },
                      ),
                    ) as Either<
                    Error,
                    Resource.Values<
                      | {
                          type: "0-ClassUnionMember1";
                          value: ClassUnionMember1;
                        }
                      | {
                          type: "1-ClassUnionMember2";
                          value: ClassUnionMember2;
                        }
                      | { type: "2-string"; value: string }
                    >
                  >,
              )
              .altLazy(
                () =>
                  valueAsValues
                    .chain((values) =>
                      $fromRdfPreferredLanguages({
                        focusResource: $parameters.resource,
                        predicate:
                          UnionDiscriminantsClass.$schema.properties
                            .optionalClassOrClassOrStringProperty.identifier,
                        preferredLanguages: $parameters.preferredLanguages,
                        values,
                      }),
                    )
                    .chain((values) =>
                      values.chainMap((value) => value.toString()),
                    )
                    .map((values) =>
                      values.map(
                        (value) =>
                          ({
                            type: "2-string" as const,
                            value,
                          }) as
                            | {
                                type: "0-ClassUnionMember1";
                                value: ClassUnionMember1;
                              }
                            | {
                                type: "1-ClassUnionMember2";
                                value: ClassUnionMember2;
                              }
                            | { type: "2-string"; value: string },
                      ),
                    ) as Either<
                    Error,
                    Resource.Values<
                      | {
                          type: "0-ClassUnionMember1";
                          value: ClassUnionMember1;
                        }
                      | {
                          type: "1-ClassUnionMember2";
                          value: ClassUnionMember2;
                        }
                      | { type: "2-string"; value: string }
                    >
                  >,
              )
              .chain((values) => values.head());
          }),
        )
        .map((values) =>
          values.length > 0
            ? values.map((value) => Maybe.of(value))
            : Resource.Values.fromValue<
                Maybe<
                  | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                  | {
                      type: "1-ClassUnionMember2";
                      value: ClassUnionMember2;
                    }
                  | { type: "2-string"; value: string }
                >
              >({
                focusResource: $parameters.resource,
                predicate:
                  UnionDiscriminantsClass.$schema.properties
                    .optionalClassOrClassOrStringProperty.identifier,
                value: Maybe.empty(),
              }),
        )
        .chain((values) => values.head())
        .chain((optionalClassOrClassOrStringProperty) =>
          Either.of<Error, Resource.Values<Resource.TermValue>>(
            $parameters.resource.values(
              $schema.properties.optionalIriOrLiteralProperty.identifier,
              { unique: true },
            ),
          )
            .chain((values) =>
              values.chainMap((value) => {
                const valueAsValues = Either.of(value.toValues());
                return (
                  valueAsValues.chain((values) =>
                    values.chainMap((value) => value.toIri()),
                  ) as Either<Error, Resource.Values<NamedNode | Literal>>
                )
                  .altLazy(
                    () =>
                      valueAsValues
                        .chain((values) =>
                          $fromRdfPreferredLanguages({
                            focusResource: $parameters.resource,
                            predicate:
                              UnionDiscriminantsClass.$schema.properties
                                .optionalIriOrLiteralProperty.identifier,
                            preferredLanguages: $parameters.preferredLanguages,
                            values,
                          }),
                        )
                        .chain((values) =>
                          values.chainMap((value) => value.toLiteral()),
                        ) as Either<
                        Error,
                        Resource.Values<NamedNode | Literal>
                      >,
                  )
                  .chain((values) => values.head());
              }),
            )
            .map((values) =>
              values.length > 0
                ? values.map((value) => Maybe.of(value))
                : Resource.Values.fromValue<Maybe<NamedNode | Literal>>({
                    focusResource: $parameters.resource,
                    predicate:
                      UnionDiscriminantsClass.$schema.properties
                        .optionalIriOrLiteralProperty.identifier,
                    value: Maybe.empty(),
                  }),
            )
            .chain((values) => values.head())
            .chain((optionalIriOrLiteralProperty) =>
              Either.of<Error, Resource.Values<Resource.TermValue>>(
                $parameters.resource.values(
                  $schema.properties.optionalIriOrStringProperty.identifier,
                  { unique: true },
                ),
              )
                .chain((values) =>
                  values.chainMap((value) => {
                    const valueAsValues = Either.of(value.toValues());
                    return (
                      valueAsValues.chain((values) =>
                        values.chainMap((value) => value.toIri()),
                      ) as Either<Error, Resource.Values<NamedNode | string>>
                    )
                      .altLazy(
                        () =>
                          valueAsValues
                            .chain((values) =>
                              $fromRdfPreferredLanguages({
                                focusResource: $parameters.resource,
                                predicate:
                                  UnionDiscriminantsClass.$schema.properties
                                    .optionalIriOrStringProperty.identifier,
                                preferredLanguages:
                                  $parameters.preferredLanguages,
                                values,
                              }),
                            )
                            .chain((values) =>
                              values.chainMap((value) => value.toString()),
                            ) as Either<
                            Error,
                            Resource.Values<NamedNode | string>
                          >,
                      )
                      .chain((values) => values.head());
                  }),
                )
                .map((values) =>
                  values.length > 0
                    ? values.map((value) => Maybe.of(value))
                    : Resource.Values.fromValue<Maybe<NamedNode | string>>({
                        focusResource: $parameters.resource,
                        predicate:
                          UnionDiscriminantsClass.$schema.properties
                            .optionalIriOrStringProperty.identifier,
                        value: Maybe.empty(),
                      }),
                )
                .chain((values) => values.head())
                .chain((optionalIriOrStringProperty) =>
                  Either.of<Error, Resource.Values<Resource.TermValue>>(
                    $parameters.resource.values(
                      $schema.properties.requiredClassOrClassOrStringProperty
                        .identifier,
                      {
                        unique: true,
                      },
                    ),
                  )
                    .chain((values) =>
                      values.chainMap((value) => {
                        const valueAsValues = Either.of(value.toValues());
                        return (
                          valueAsValues
                            .chain((values) =>
                              values.chainMap((value) =>
                                value.toResource().chain((resource) =>
                                  ClassUnionMember1.$fromRdf(resource, {
                                    context: $parameters.context,
                                    objectSet: $parameters.objectSet,
                                    preferredLanguages:
                                      $parameters.preferredLanguages,
                                  }),
                                ),
                              ),
                            )
                            .map((values) =>
                              values.map(
                                (value) =>
                                  ({
                                    type: "0-ClassUnionMember1" as const,
                                    value,
                                  }) as
                                    | {
                                        type: "0-ClassUnionMember1";
                                        value: ClassUnionMember1;
                                      }
                                    | {
                                        type: "1-ClassUnionMember2";
                                        value: ClassUnionMember2;
                                      }
                                    | { type: "2-string"; value: string },
                              ),
                            ) as Either<
                            Error,
                            Resource.Values<
                              | {
                                  type: "0-ClassUnionMember1";
                                  value: ClassUnionMember1;
                                }
                              | {
                                  type: "1-ClassUnionMember2";
                                  value: ClassUnionMember2;
                                }
                              | { type: "2-string"; value: string }
                            >
                          >
                        )
                          .altLazy(
                            () =>
                              valueAsValues
                                .chain((values) =>
                                  values.chainMap((value) =>
                                    value.toResource().chain((resource) =>
                                      ClassUnionMember2.$fromRdf(resource, {
                                        context: $parameters.context,
                                        objectSet: $parameters.objectSet,
                                        preferredLanguages:
                                          $parameters.preferredLanguages,
                                      }),
                                    ),
                                  ),
                                )
                                .map((values) =>
                                  values.map(
                                    (value) =>
                                      ({
                                        type: "1-ClassUnionMember2" as const,
                                        value,
                                      }) as
                                        | {
                                            type: "0-ClassUnionMember1";
                                            value: ClassUnionMember1;
                                          }
                                        | {
                                            type: "1-ClassUnionMember2";
                                            value: ClassUnionMember2;
                                          }
                                        | { type: "2-string"; value: string },
                                  ),
                                ) as Either<
                                Error,
                                Resource.Values<
                                  | {
                                      type: "0-ClassUnionMember1";
                                      value: ClassUnionMember1;
                                    }
                                  | {
                                      type: "1-ClassUnionMember2";
                                      value: ClassUnionMember2;
                                    }
                                  | { type: "2-string"; value: string }
                                >
                              >,
                          )
                          .altLazy(
                            () =>
                              valueAsValues
                                .chain((values) =>
                                  $fromRdfPreferredLanguages({
                                    focusResource: $parameters.resource,
                                    predicate:
                                      UnionDiscriminantsClass.$schema.properties
                                        .requiredClassOrClassOrStringProperty
                                        .identifier,
                                    preferredLanguages:
                                      $parameters.preferredLanguages,
                                    values,
                                  }),
                                )
                                .chain((values) =>
                                  values.chainMap((value) => value.toString()),
                                )
                                .map((values) =>
                                  values.map(
                                    (value) =>
                                      ({
                                        type: "2-string" as const,
                                        value,
                                      }) as
                                        | {
                                            type: "0-ClassUnionMember1";
                                            value: ClassUnionMember1;
                                          }
                                        | {
                                            type: "1-ClassUnionMember2";
                                            value: ClassUnionMember2;
                                          }
                                        | { type: "2-string"; value: string },
                                  ),
                                ) as Either<
                                Error,
                                Resource.Values<
                                  | {
                                      type: "0-ClassUnionMember1";
                                      value: ClassUnionMember1;
                                    }
                                  | {
                                      type: "1-ClassUnionMember2";
                                      value: ClassUnionMember2;
                                    }
                                  | { type: "2-string"; value: string }
                                >
                              >,
                          )
                          .chain((values) => values.head());
                      }),
                    )
                    .chain((values) => values.head())
                    .chain((requiredClassOrClassOrStringProperty) =>
                      Either.of<Error, Resource.Values<Resource.TermValue>>(
                        $parameters.resource.values(
                          $schema.properties.requiredIriOrLiteralProperty
                            .identifier,
                          {
                            unique: true,
                          },
                        ),
                      )
                        .chain((values) =>
                          values.chainMap((value) => {
                            const valueAsValues = Either.of(value.toValues());
                            return (
                              valueAsValues.chain((values) =>
                                values.chainMap((value) => value.toIri()),
                              ) as Either<
                                Error,
                                Resource.Values<NamedNode | Literal>
                              >
                            )
                              .altLazy(
                                () =>
                                  valueAsValues
                                    .chain((values) =>
                                      $fromRdfPreferredLanguages({
                                        focusResource: $parameters.resource,
                                        predicate:
                                          UnionDiscriminantsClass.$schema
                                            .properties
                                            .requiredIriOrLiteralProperty
                                            .identifier,
                                        preferredLanguages:
                                          $parameters.preferredLanguages,
                                        values,
                                      }),
                                    )
                                    .chain((values) =>
                                      values.chainMap((value) =>
                                        value.toLiteral(),
                                      ),
                                    ) as Either<
                                    Error,
                                    Resource.Values<NamedNode | Literal>
                                  >,
                              )
                              .chain((values) => values.head());
                          }),
                        )
                        .chain((values) => values.head())
                        .chain((requiredIriOrLiteralProperty) =>
                          Either.of<Error, Resource.Values<Resource.TermValue>>(
                            $parameters.resource.values(
                              $schema.properties.requiredIriOrStringProperty
                                .identifier,
                              {
                                unique: true,
                              },
                            ),
                          )
                            .chain((values) =>
                              values.chainMap((value) => {
                                const valueAsValues = Either.of(
                                  value.toValues(),
                                );
                                return (
                                  valueAsValues.chain((values) =>
                                    values.chainMap((value) => value.toIri()),
                                  ) as Either<
                                    Error,
                                    Resource.Values<NamedNode | string>
                                  >
                                )
                                  .altLazy(
                                    () =>
                                      valueAsValues
                                        .chain((values) =>
                                          $fromRdfPreferredLanguages({
                                            focusResource: $parameters.resource,
                                            predicate:
                                              UnionDiscriminantsClass.$schema
                                                .properties
                                                .requiredIriOrStringProperty
                                                .identifier,
                                            preferredLanguages:
                                              $parameters.preferredLanguages,
                                            values,
                                          }),
                                        )
                                        .chain((values) =>
                                          values.chainMap((value) =>
                                            value.toString(),
                                          ),
                                        ) as Either<
                                        Error,
                                        Resource.Values<NamedNode | string>
                                      >,
                                  )
                                  .chain((values) => values.head());
                              }),
                            )
                            .chain((values) => values.head())
                            .chain((requiredIriOrStringProperty) =>
                              Either.of<
                                Error,
                                Resource.Values<Resource.TermValue>
                              >(
                                $parameters.resource.values(
                                  $schema.properties
                                    .setClassOrClassOrStringProperty.identifier,
                                  {
                                    unique: true,
                                  },
                                ),
                              )
                                .chain((values) =>
                                  values.chainMap((value) => {
                                    const valueAsValues = Either.of(
                                      value.toValues(),
                                    );
                                    return (
                                      valueAsValues
                                        .chain((values) =>
                                          values.chainMap((value) =>
                                            value
                                              .toResource()
                                              .chain((resource) =>
                                                ClassUnionMember1.$fromRdf(
                                                  resource,
                                                  {
                                                    context:
                                                      $parameters.context,
                                                    objectSet:
                                                      $parameters.objectSet,
                                                    preferredLanguages:
                                                      $parameters.preferredLanguages,
                                                  },
                                                ),
                                              ),
                                          ),
                                        )
                                        .map((values) =>
                                          values.map(
                                            (value) =>
                                              ({
                                                type: "0-ClassUnionMember1" as const,
                                                value,
                                              }) as
                                                | {
                                                    type: "0-ClassUnionMember1";
                                                    value: ClassUnionMember1;
                                                  }
                                                | {
                                                    type: "1-ClassUnionMember2";
                                                    value: ClassUnionMember2;
                                                  }
                                                | {
                                                    type: "2-string";
                                                    value: string;
                                                  },
                                          ),
                                        ) as Either<
                                        Error,
                                        Resource.Values<
                                          | {
                                              type: "0-ClassUnionMember1";
                                              value: ClassUnionMember1;
                                            }
                                          | {
                                              type: "1-ClassUnionMember2";
                                              value: ClassUnionMember2;
                                            }
                                          | { type: "2-string"; value: string }
                                        >
                                      >
                                    )
                                      .altLazy(
                                        () =>
                                          valueAsValues
                                            .chain((values) =>
                                              values.chainMap((value) =>
                                                value
                                                  .toResource()
                                                  .chain((resource) =>
                                                    ClassUnionMember2.$fromRdf(
                                                      resource,
                                                      {
                                                        context:
                                                          $parameters.context,
                                                        objectSet:
                                                          $parameters.objectSet,
                                                        preferredLanguages:
                                                          $parameters.preferredLanguages,
                                                      },
                                                    ),
                                                  ),
                                              ),
                                            )
                                            .map((values) =>
                                              values.map(
                                                (value) =>
                                                  ({
                                                    type: "1-ClassUnionMember2" as const,
                                                    value,
                                                  }) as
                                                    | {
                                                        type: "0-ClassUnionMember1";
                                                        value: ClassUnionMember1;
                                                      }
                                                    | {
                                                        type: "1-ClassUnionMember2";
                                                        value: ClassUnionMember2;
                                                      }
                                                    | {
                                                        type: "2-string";
                                                        value: string;
                                                      },
                                              ),
                                            ) as Either<
                                            Error,
                                            Resource.Values<
                                              | {
                                                  type: "0-ClassUnionMember1";
                                                  value: ClassUnionMember1;
                                                }
                                              | {
                                                  type: "1-ClassUnionMember2";
                                                  value: ClassUnionMember2;
                                                }
                                              | {
                                                  type: "2-string";
                                                  value: string;
                                                }
                                            >
                                          >,
                                      )
                                      .altLazy(
                                        () =>
                                          valueAsValues
                                            .chain((values) =>
                                              $fromRdfPreferredLanguages({
                                                focusResource:
                                                  $parameters.resource,
                                                predicate:
                                                  UnionDiscriminantsClass
                                                    .$schema.properties
                                                    .setClassOrClassOrStringProperty
                                                    .identifier,
                                                preferredLanguages:
                                                  $parameters.preferredLanguages,
                                                values,
                                              }),
                                            )
                                            .chain((values) =>
                                              values.chainMap((value) =>
                                                value.toString(),
                                              ),
                                            )
                                            .map((values) =>
                                              values.map(
                                                (value) =>
                                                  ({
                                                    type: "2-string" as const,
                                                    value,
                                                  }) as
                                                    | {
                                                        type: "0-ClassUnionMember1";
                                                        value: ClassUnionMember1;
                                                      }
                                                    | {
                                                        type: "1-ClassUnionMember2";
                                                        value: ClassUnionMember2;
                                                      }
                                                    | {
                                                        type: "2-string";
                                                        value: string;
                                                      },
                                              ),
                                            ) as Either<
                                            Error,
                                            Resource.Values<
                                              | {
                                                  type: "0-ClassUnionMember1";
                                                  value: ClassUnionMember1;
                                                }
                                              | {
                                                  type: "1-ClassUnionMember2";
                                                  value: ClassUnionMember2;
                                                }
                                              | {
                                                  type: "2-string";
                                                  value: string;
                                                }
                                            >
                                          >,
                                      )
                                      .chain((values) => values.head());
                                  }),
                                )
                                .map((values) => values.toArray())
                                .map((valuesArray) =>
                                  Resource.Values.fromValue({
                                    focusResource: $parameters.resource,
                                    predicate:
                                      UnionDiscriminantsClass.$schema.properties
                                        .setClassOrClassOrStringProperty
                                        .identifier,
                                    value: valuesArray,
                                  }),
                                )
                                .chain((values) => values.head())
                                .chain((setClassOrClassOrStringProperty) =>
                                  Either.of<
                                    Error,
                                    Resource.Values<Resource.TermValue>
                                  >(
                                    $parameters.resource.values(
                                      $schema.properties.setIriOrLiteralProperty
                                        .identifier,
                                      {
                                        unique: true,
                                      },
                                    ),
                                  )
                                    .chain((values) =>
                                      values.chainMap((value) => {
                                        const valueAsValues = Either.of(
                                          value.toValues(),
                                        );
                                        return (
                                          valueAsValues.chain((values) =>
                                            values.chainMap((value) =>
                                              value.toIri(),
                                            ),
                                          ) as Either<
                                            Error,
                                            Resource.Values<NamedNode | Literal>
                                          >
                                        )
                                          .altLazy(
                                            () =>
                                              valueAsValues
                                                .chain((values) =>
                                                  $fromRdfPreferredLanguages({
                                                    focusResource:
                                                      $parameters.resource,
                                                    predicate:
                                                      UnionDiscriminantsClass
                                                        .$schema.properties
                                                        .setIriOrLiteralProperty
                                                        .identifier,
                                                    preferredLanguages:
                                                      $parameters.preferredLanguages,
                                                    values,
                                                  }),
                                                )
                                                .chain((values) =>
                                                  values.chainMap((value) =>
                                                    value.toLiteral(),
                                                  ),
                                                ) as Either<
                                                Error,
                                                Resource.Values<
                                                  NamedNode | Literal
                                                >
                                              >,
                                          )
                                          .chain((values) => values.head());
                                      }),
                                    )
                                    .map((values) => values.toArray())
                                    .map((valuesArray) =>
                                      Resource.Values.fromValue({
                                        focusResource: $parameters.resource,
                                        predicate:
                                          UnionDiscriminantsClass.$schema
                                            .properties.setIriOrLiteralProperty
                                            .identifier,
                                        value: valuesArray,
                                      }),
                                    )
                                    .chain((values) => values.head())
                                    .chain((setIriOrLiteralProperty) =>
                                      Either.of<
                                        Error,
                                        Resource.Values<Resource.TermValue>
                                      >(
                                        $parameters.resource.values(
                                          $schema.properties
                                            .setIriOrStringProperty.identifier,
                                          {
                                            unique: true,
                                          },
                                        ),
                                      )
                                        .chain((values) =>
                                          values.chainMap((value) => {
                                            const valueAsValues = Either.of(
                                              value.toValues(),
                                            );
                                            return (
                                              valueAsValues.chain((values) =>
                                                values.chainMap((value) =>
                                                  value.toIri(),
                                                ),
                                              ) as Either<
                                                Error,
                                                Resource.Values<
                                                  NamedNode | string
                                                >
                                              >
                                            )
                                              .altLazy(
                                                () =>
                                                  valueAsValues
                                                    .chain((values) =>
                                                      $fromRdfPreferredLanguages(
                                                        {
                                                          focusResource:
                                                            $parameters.resource,
                                                          predicate:
                                                            UnionDiscriminantsClass
                                                              .$schema
                                                              .properties
                                                              .setIriOrStringProperty
                                                              .identifier,
                                                          preferredLanguages:
                                                            $parameters.preferredLanguages,
                                                          values,
                                                        },
                                                      ),
                                                    )
                                                    .chain((values) =>
                                                      values.chainMap((value) =>
                                                        value.toString(),
                                                      ),
                                                    ) as Either<
                                                    Error,
                                                    Resource.Values<
                                                      NamedNode | string
                                                    >
                                                  >,
                                              )
                                              .chain((values) => values.head());
                                          }),
                                        )
                                        .map((values) => values.toArray())
                                        .map((valuesArray) =>
                                          Resource.Values.fromValue({
                                            focusResource: $parameters.resource,
                                            predicate:
                                              UnionDiscriminantsClass.$schema
                                                .properties
                                                .setIriOrStringProperty
                                                .identifier,
                                            value: valuesArray,
                                          }),
                                        )
                                        .chain((values) => values.head())
                                        .map((setIriOrStringProperty) => ({
                                          $identifier,
                                          optionalClassOrClassOrStringProperty,
                                          optionalIriOrLiteralProperty,
                                          optionalIriOrStringProperty,
                                          requiredClassOrClassOrStringProperty,
                                          requiredIriOrLiteralProperty,
                                          requiredIriOrStringProperty,
                                          setClassOrClassOrStringProperty,
                                          setIriOrLiteralProperty,
                                          setIriOrStringProperty,
                                        })),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["UnionDiscriminantsClass"],
        }),
      },
      optionalClassOrClassOrStringProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({
            kind: "Union" as const,
            members: {
              "0-ClassUnionMember1": {
                discriminantValues: ["0-ClassUnionMember1"],
                type: ClassUnionMember1.$schema,
              },
              "1-ClassUnionMember2": {
                discriminantValues: ["1-ClassUnionMember2"],
                type: ClassUnionMember2.$schema,
              },
              "2-string": {
                discriminantValues: ["2-string"],
                type: { kind: "String" as const },
              },
            },
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/optionalClassOrClassOrStringProperty",
        ),
      },
      optionalIriOrLiteralProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({
            kind: "Union" as const,
            members: {
              NamedNode: {
                discriminantValues: ["NamedNode"],
                type: { kind: "NamedNode" as const },
              },
              Literal: {
                discriminantValues: ["Literal"],
                type: { kind: "Literal" as const },
              },
            },
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/optionalIriOrLiteralProperty",
        ),
      },
      optionalIriOrStringProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({
            kind: "Union" as const,
            members: {
              object: {
                discriminantValues: ["object"],
                type: { kind: "NamedNode" as const },
              },
              string: {
                discriminantValues: ["string"],
                type: { kind: "String" as const },
              },
            },
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/optionalIriOrStringProperty",
        ),
      },
      requiredClassOrClassOrStringProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Union" as const,
          members: {
            "0-ClassUnionMember1": {
              discriminantValues: ["0-ClassUnionMember1"],
              type: ClassUnionMember1.$schema,
            },
            "1-ClassUnionMember2": {
              discriminantValues: ["1-ClassUnionMember2"],
              type: ClassUnionMember2.$schema,
            },
            "2-string": {
              discriminantValues: ["2-string"],
              type: { kind: "String" as const },
            },
          },
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/requiredClassOrClassOrStringProperty",
        ),
      },
      requiredIriOrLiteralProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Union" as const,
          members: {
            NamedNode: {
              discriminantValues: ["NamedNode"],
              type: { kind: "NamedNode" as const },
            },
            Literal: {
              discriminantValues: ["Literal"],
              type: { kind: "Literal" as const },
            },
          },
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/requiredIriOrLiteralProperty",
        ),
      },
      requiredIriOrStringProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Union" as const,
          members: {
            object: {
              discriminantValues: ["object"],
              type: { kind: "NamedNode" as const },
            },
            string: {
              discriminantValues: ["string"],
              type: { kind: "String" as const },
            },
          },
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/requiredIriOrStringProperty",
        ),
      },
      setClassOrClassOrStringProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Set" as const,
          item: () => ({
            kind: "Union" as const,
            members: {
              "0-ClassUnionMember1": {
                discriminantValues: ["0-ClassUnionMember1"],
                type: ClassUnionMember1.$schema,
              },
              "1-ClassUnionMember2": {
                discriminantValues: ["1-ClassUnionMember2"],
                type: ClassUnionMember2.$schema,
              },
              "2-string": {
                discriminantValues: ["2-string"],
                type: { kind: "String" as const },
              },
            },
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/setClassOrClassOrStringProperty",
        ),
      },
      setIriOrLiteralProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Set" as const,
          item: () => ({
            kind: "Union" as const,
            members: {
              NamedNode: {
                discriminantValues: ["NamedNode"],
                type: { kind: "NamedNode" as const },
              },
              Literal: {
                discriminantValues: ["Literal"],
                type: { kind: "Literal" as const },
              },
            },
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/setIriOrLiteralProperty",
        ),
      },
      setIriOrStringProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Set" as const,
          item: () => ({
            kind: "Union" as const,
            members: {
              object: {
                discriminantValues: ["object"],
                type: { kind: "NamedNode" as const },
              },
              string: {
                discriminantValues: ["string"],
                type: { kind: "String" as const },
              },
            },
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/setIriOrStringProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: UnionDiscriminantsClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        UnionDiscriminantsClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          UnionDiscriminantsClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: UnionDiscriminantsClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      UnionDiscriminantsClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("unionDiscriminantsClass");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }OptionalClassOrClassOrStringProperty`,
        ),
        predicate:
          UnionDiscriminantsClass.$schema.properties
            .optionalClassOrClassOrStringProperty.identifier,
        subject: subject,
      },
      ...[
        ...ClassUnionMember1.$sparqlConstructTriples({
          ignoreRdfType: undefined,
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "unionDiscriminantsClass")
            }OptionalClassOrClassOrStringProperty`,
          ),
          variablePrefix: `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }OptionalClassOrClassOrStringProperty`,
        }),
        ...ClassUnionMember2.$sparqlConstructTriples({
          ignoreRdfType: undefined,
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "unionDiscriminantsClass")
            }OptionalClassOrClassOrStringProperty`,
          ),
          variablePrefix: `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }OptionalClassOrClassOrStringProperty`,
        }),
      ],
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }OptionalIriOrLiteralProperty`,
        ),
        predicate:
          UnionDiscriminantsClass.$schema.properties
            .optionalIriOrLiteralProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }OptionalIriOrStringProperty`,
        ),
        predicate:
          UnionDiscriminantsClass.$schema.properties.optionalIriOrStringProperty
            .identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }RequiredClassOrClassOrStringProperty`,
        ),
        predicate:
          UnionDiscriminantsClass.$schema.properties
            .requiredClassOrClassOrStringProperty.identifier,
        subject: subject,
      },
      ...[
        ...ClassUnionMember1.$sparqlConstructTriples({
          ignoreRdfType: undefined,
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "unionDiscriminantsClass")
            }RequiredClassOrClassOrStringProperty`,
          ),
          variablePrefix: `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }RequiredClassOrClassOrStringProperty`,
        }),
        ...ClassUnionMember2.$sparqlConstructTriples({
          ignoreRdfType: undefined,
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "unionDiscriminantsClass")
            }RequiredClassOrClassOrStringProperty`,
          ),
          variablePrefix: `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }RequiredClassOrClassOrStringProperty`,
        }),
      ],
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }RequiredIriOrLiteralProperty`,
        ),
        predicate:
          UnionDiscriminantsClass.$schema.properties
            .requiredIriOrLiteralProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }RequiredIriOrStringProperty`,
        ),
        predicate:
          UnionDiscriminantsClass.$schema.properties.requiredIriOrStringProperty
            .identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }SetClassOrClassOrStringProperty`,
        ),
        predicate:
          UnionDiscriminantsClass.$schema.properties
            .setClassOrClassOrStringProperty.identifier,
        subject: subject,
      },
      ...[
        ...ClassUnionMember1.$sparqlConstructTriples({
          ignoreRdfType: undefined,
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "unionDiscriminantsClass")
            }SetClassOrClassOrStringProperty`,
          ),
          variablePrefix: `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }SetClassOrClassOrStringProperty`,
        }),
        ...ClassUnionMember2.$sparqlConstructTriples({
          ignoreRdfType: undefined,
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "unionDiscriminantsClass")
            }SetClassOrClassOrStringProperty`,
          ),
          variablePrefix: `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }SetClassOrClassOrStringProperty`,
        }),
      ],
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }SetIriOrLiteralProperty`,
        ),
        predicate:
          UnionDiscriminantsClass.$schema.properties.setIriOrLiteralProperty
            .identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }SetIriOrStringProperty`,
        ),
        predicate:
          UnionDiscriminantsClass.$schema.properties.setIriOrStringProperty
            .identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: UnionDiscriminantsClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("unionDiscriminantsClass");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: UnionDiscriminantsClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<
        {
          readonly on?: {
            readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
            readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
            readonly "2-string"?: $StringFilter;
          };
        },
        {
          kind: "Union";
          members: {
            readonly "0-ClassUnionMember1": {
              discriminantValues: readonly string[];
              type: typeof ClassUnionMember1.$schema;
            };
            readonly "1-ClassUnionMember2": {
              discriminantValues: readonly string[];
              type: typeof ClassUnionMember2.$schema;
            };
            readonly "2-string": {
              discriminantValues: readonly string[];
              type: $StringSchema;
            };
          };
        }
      >(({ filter, schema, ...otherParameters }) => {
        const unionPatterns: sparqljs.GroupPattern[] = [];

        unionPatterns.push({
          patterns: (({
            ignoreRdfType,
            propertyPatterns,
            valueVariable,
            ...otherParameters
          }: $SparqlWherePatternsFunctionParameters<
            ClassUnionMember1.$Filter,
            typeof ClassUnionMember1.$schema
          >) =>
            (propertyPatterns as readonly $SparqlPattern[]).concat(
              ClassUnionMember1.$sparqlWherePatterns({
                ignoreRdfType: ignoreRdfType ?? true,
                subject: valueVariable,
                ...otherParameters,
              }),
            ))({
            filter: filter?.on?.["0-ClassUnionMember1"],
            schema: schema.members["0-ClassUnionMember1"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });
        unionPatterns.push({
          patterns: (({
            ignoreRdfType,
            propertyPatterns,
            valueVariable,
            ...otherParameters
          }: $SparqlWherePatternsFunctionParameters<
            ClassUnionMember2.$Filter,
            typeof ClassUnionMember2.$schema
          >) =>
            (propertyPatterns as readonly $SparqlPattern[]).concat(
              ClassUnionMember2.$sparqlWherePatterns({
                ignoreRdfType: ignoreRdfType ?? true,
                subject: valueVariable,
                ...otherParameters,
              }),
            ))({
            filter: filter?.on?.["1-ClassUnionMember2"],
            schema: schema.members["1-ClassUnionMember2"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });
        unionPatterns.push({
          patterns: $stringSparqlWherePatterns({
            filter: filter?.on?.["2-string"],
            schema: schema.members["2-string"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });

        return [{ patterns: unionPatterns, type: "union" }];
      })({
        filter: parameters?.filter?.optionalClassOrClassOrStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "unionDiscriminantsClass")
                  }OptionalClassOrClassOrStringProperty`,
                ),
                predicate:
                  UnionDiscriminantsClass.$schema.properties
                    .optionalClassOrClassOrStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          UnionDiscriminantsClass.$schema.properties.optionalClassOrClassOrStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }OptionalClassOrClassOrStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "unionDiscriminantsClass")
        }OptionalClassOrClassOrStringProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<
        {
          readonly on?: {
            readonly NamedNode?: $NamedNodeFilter;
            readonly Literal?: $LiteralFilter;
          };
        },
        {
          kind: "Union";
          members: {
            readonly NamedNode: {
              discriminantValues: readonly string[];
              type: $NamedNodeSchema;
            };
            readonly Literal: {
              discriminantValues: readonly string[];
              type: $LiteralSchema;
            };
          };
        }
      >(({ filter, schema, ...otherParameters }) => {
        const unionPatterns: sparqljs.GroupPattern[] = [];

        unionPatterns.push({
          patterns: $namedNodeSparqlWherePatterns({
            filter: filter?.on?.["NamedNode"],
            schema: schema.members["NamedNode"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });
        unionPatterns.push({
          patterns: $literalSparqlWherePatterns({
            filter: filter?.on?.["Literal"],
            schema: schema.members["Literal"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });

        return [{ patterns: unionPatterns, type: "union" }];
      })({
        filter: parameters?.filter?.optionalIriOrLiteralProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "unionDiscriminantsClass")
                  }OptionalIriOrLiteralProperty`,
                ),
                predicate:
                  UnionDiscriminantsClass.$schema.properties
                    .optionalIriOrLiteralProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          UnionDiscriminantsClass.$schema.properties.optionalIriOrLiteralProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }OptionalIriOrLiteralProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "unionDiscriminantsClass")
        }OptionalIriOrLiteralProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<
        {
          readonly on?: {
            readonly object?: $NamedNodeFilter;
            readonly string?: $StringFilter;
          };
        },
        {
          kind: "Union";
          members: {
            readonly object: {
              discriminantValues: readonly string[];
              type: $NamedNodeSchema;
            };
            readonly string: {
              discriminantValues: readonly string[];
              type: $StringSchema;
            };
          };
        }
      >(({ filter, schema, ...otherParameters }) => {
        const unionPatterns: sparqljs.GroupPattern[] = [];

        unionPatterns.push({
          patterns: $namedNodeSparqlWherePatterns({
            filter: filter?.on?.["object"],
            schema: schema.members["object"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });
        unionPatterns.push({
          patterns: $stringSparqlWherePatterns({
            filter: filter?.on?.["string"],
            schema: schema.members["string"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });

        return [{ patterns: unionPatterns, type: "union" }];
      })({
        filter: parameters?.filter?.optionalIriOrStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "unionDiscriminantsClass")
                  }OptionalIriOrStringProperty`,
                ),
                predicate:
                  UnionDiscriminantsClass.$schema.properties
                    .optionalIriOrStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          UnionDiscriminantsClass.$schema.properties.optionalIriOrStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }OptionalIriOrStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "unionDiscriminantsClass")
        }OptionalIriOrStringProperty`,
      }),
    );
    patterns = patterns.concat(
      (({ filter, schema, ...otherParameters }) => {
        const unionPatterns: sparqljs.GroupPattern[] = [];

        unionPatterns.push({
          patterns: (({
            ignoreRdfType,
            propertyPatterns,
            valueVariable,
            ...otherParameters
          }: $SparqlWherePatternsFunctionParameters<
            ClassUnionMember1.$Filter,
            typeof ClassUnionMember1.$schema
          >) =>
            (propertyPatterns as readonly $SparqlPattern[]).concat(
              ClassUnionMember1.$sparqlWherePatterns({
                ignoreRdfType: ignoreRdfType ?? true,
                subject: valueVariable,
                ...otherParameters,
              }),
            ))({
            filter: filter?.on?.["0-ClassUnionMember1"],
            schema: schema.members["0-ClassUnionMember1"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });
        unionPatterns.push({
          patterns: (({
            ignoreRdfType,
            propertyPatterns,
            valueVariable,
            ...otherParameters
          }: $SparqlWherePatternsFunctionParameters<
            ClassUnionMember2.$Filter,
            typeof ClassUnionMember2.$schema
          >) =>
            (propertyPatterns as readonly $SparqlPattern[]).concat(
              ClassUnionMember2.$sparqlWherePatterns({
                ignoreRdfType: ignoreRdfType ?? true,
                subject: valueVariable,
                ...otherParameters,
              }),
            ))({
            filter: filter?.on?.["1-ClassUnionMember2"],
            schema: schema.members["1-ClassUnionMember2"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });
        unionPatterns.push({
          patterns: $stringSparqlWherePatterns({
            filter: filter?.on?.["2-string"],
            schema: schema.members["2-string"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });

        return [{ patterns: unionPatterns, type: "union" }];
      })({
        filter: parameters?.filter?.requiredClassOrClassOrStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "unionDiscriminantsClass")
                  }RequiredClassOrClassOrStringProperty`,
                ),
                predicate:
                  UnionDiscriminantsClass.$schema.properties
                    .requiredClassOrClassOrStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          UnionDiscriminantsClass.$schema.properties.requiredClassOrClassOrStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }RequiredClassOrClassOrStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "unionDiscriminantsClass")
        }RequiredClassOrClassOrStringProperty`,
      }),
    );
    patterns = patterns.concat(
      (({ filter, schema, ...otherParameters }) => {
        const unionPatterns: sparqljs.GroupPattern[] = [];

        unionPatterns.push({
          patterns: $namedNodeSparqlWherePatterns({
            filter: filter?.on?.["NamedNode"],
            schema: schema.members["NamedNode"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });
        unionPatterns.push({
          patterns: $literalSparqlWherePatterns({
            filter: filter?.on?.["Literal"],
            schema: schema.members["Literal"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });

        return [{ patterns: unionPatterns, type: "union" }];
      })({
        filter: parameters?.filter?.requiredIriOrLiteralProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "unionDiscriminantsClass")
                  }RequiredIriOrLiteralProperty`,
                ),
                predicate:
                  UnionDiscriminantsClass.$schema.properties
                    .requiredIriOrLiteralProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          UnionDiscriminantsClass.$schema.properties.requiredIriOrLiteralProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }RequiredIriOrLiteralProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "unionDiscriminantsClass")
        }RequiredIriOrLiteralProperty`,
      }),
    );
    patterns = patterns.concat(
      (({ filter, schema, ...otherParameters }) => {
        const unionPatterns: sparqljs.GroupPattern[] = [];

        unionPatterns.push({
          patterns: $namedNodeSparqlWherePatterns({
            filter: filter?.on?.["object"],
            schema: schema.members["object"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });
        unionPatterns.push({
          patterns: $stringSparqlWherePatterns({
            filter: filter?.on?.["string"],
            schema: schema.members["string"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });

        return [{ patterns: unionPatterns, type: "union" }];
      })({
        filter: parameters?.filter?.requiredIriOrStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "unionDiscriminantsClass")
                  }RequiredIriOrStringProperty`,
                ),
                predicate:
                  UnionDiscriminantsClass.$schema.properties
                    .requiredIriOrStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          UnionDiscriminantsClass.$schema.properties.requiredIriOrStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }RequiredIriOrStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "unionDiscriminantsClass")
        }RequiredIriOrStringProperty`,
      }),
    );
    patterns = patterns.concat(
      $setSparqlWherePatterns<
        {
          readonly on?: {
            readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
            readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
            readonly "2-string"?: $StringFilter;
          };
        },
        {
          kind: "Union";
          members: {
            readonly "0-ClassUnionMember1": {
              discriminantValues: readonly string[];
              type: typeof ClassUnionMember1.$schema;
            };
            readonly "1-ClassUnionMember2": {
              discriminantValues: readonly string[];
              type: typeof ClassUnionMember2.$schema;
            };
            readonly "2-string": {
              discriminantValues: readonly string[];
              type: $StringSchema;
            };
          };
        }
      >(({ filter, schema, ...otherParameters }) => {
        const unionPatterns: sparqljs.GroupPattern[] = [];

        unionPatterns.push({
          patterns: (({
            ignoreRdfType,
            propertyPatterns,
            valueVariable,
            ...otherParameters
          }: $SparqlWherePatternsFunctionParameters<
            ClassUnionMember1.$Filter,
            typeof ClassUnionMember1.$schema
          >) =>
            (propertyPatterns as readonly $SparqlPattern[]).concat(
              ClassUnionMember1.$sparqlWherePatterns({
                ignoreRdfType: ignoreRdfType ?? true,
                subject: valueVariable,
                ...otherParameters,
              }),
            ))({
            filter: filter?.on?.["0-ClassUnionMember1"],
            schema: schema.members["0-ClassUnionMember1"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });
        unionPatterns.push({
          patterns: (({
            ignoreRdfType,
            propertyPatterns,
            valueVariable,
            ...otherParameters
          }: $SparqlWherePatternsFunctionParameters<
            ClassUnionMember2.$Filter,
            typeof ClassUnionMember2.$schema
          >) =>
            (propertyPatterns as readonly $SparqlPattern[]).concat(
              ClassUnionMember2.$sparqlWherePatterns({
                ignoreRdfType: ignoreRdfType ?? true,
                subject: valueVariable,
                ...otherParameters,
              }),
            ))({
            filter: filter?.on?.["1-ClassUnionMember2"],
            schema: schema.members["1-ClassUnionMember2"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });
        unionPatterns.push({
          patterns: $stringSparqlWherePatterns({
            filter: filter?.on?.["2-string"],
            schema: schema.members["2-string"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });

        return [{ patterns: unionPatterns, type: "union" }];
      })({
        filter: parameters?.filter?.setClassOrClassOrStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "unionDiscriminantsClass")
                  }SetClassOrClassOrStringProperty`,
                ),
                predicate:
                  UnionDiscriminantsClass.$schema.properties
                    .setClassOrClassOrStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          UnionDiscriminantsClass.$schema.properties.setClassOrClassOrStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }SetClassOrClassOrStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "unionDiscriminantsClass")
        }SetClassOrClassOrStringProperty`,
      }),
    );
    patterns = patterns.concat(
      $setSparqlWherePatterns<
        {
          readonly on?: {
            readonly NamedNode?: $NamedNodeFilter;
            readonly Literal?: $LiteralFilter;
          };
        },
        {
          kind: "Union";
          members: {
            readonly NamedNode: {
              discriminantValues: readonly string[];
              type: $NamedNodeSchema;
            };
            readonly Literal: {
              discriminantValues: readonly string[];
              type: $LiteralSchema;
            };
          };
        }
      >(({ filter, schema, ...otherParameters }) => {
        const unionPatterns: sparqljs.GroupPattern[] = [];

        unionPatterns.push({
          patterns: $namedNodeSparqlWherePatterns({
            filter: filter?.on?.["NamedNode"],
            schema: schema.members["NamedNode"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });
        unionPatterns.push({
          patterns: $literalSparqlWherePatterns({
            filter: filter?.on?.["Literal"],
            schema: schema.members["Literal"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });

        return [{ patterns: unionPatterns, type: "union" }];
      })({
        filter: parameters?.filter?.setIriOrLiteralProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "unionDiscriminantsClass")
                  }SetIriOrLiteralProperty`,
                ),
                predicate:
                  UnionDiscriminantsClass.$schema.properties
                    .setIriOrLiteralProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          UnionDiscriminantsClass.$schema.properties.setIriOrLiteralProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }SetIriOrLiteralProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "unionDiscriminantsClass")
        }SetIriOrLiteralProperty`,
      }),
    );
    patterns = patterns.concat(
      $setSparqlWherePatterns<
        {
          readonly on?: {
            readonly object?: $NamedNodeFilter;
            readonly string?: $StringFilter;
          };
        },
        {
          kind: "Union";
          members: {
            readonly object: {
              discriminantValues: readonly string[];
              type: $NamedNodeSchema;
            };
            readonly string: {
              discriminantValues: readonly string[];
              type: $StringSchema;
            };
          };
        }
      >(({ filter, schema, ...otherParameters }) => {
        const unionPatterns: sparqljs.GroupPattern[] = [];

        unionPatterns.push({
          patterns: $namedNodeSparqlWherePatterns({
            filter: filter?.on?.["object"],
            schema: schema.members["object"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });
        unionPatterns.push({
          patterns: $stringSparqlWherePatterns({
            filter: filter?.on?.["string"],
            schema: schema.members["string"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });

        return [{ patterns: unionPatterns, type: "union" }];
      })({
        filter: parameters?.filter?.setIriOrStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "unionDiscriminantsClass")
                  }SetIriOrStringProperty`,
                ),
                predicate:
                  UnionDiscriminantsClass.$schema.properties
                    .setIriOrStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          UnionDiscriminantsClass.$schema.properties.setIriOrStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "unionDiscriminantsClass")
          }SetIriOrStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "unionDiscriminantsClass")
        }SetIriOrStringProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Shape with properties that are not nested objects
 */

export class TermPropertiesClass {
  private _$identifier?: TermPropertiesClass.$Identifier;

  readonly $type: "TermPropertiesClass" = "TermPropertiesClass" as const;

  readonly blankNodeTermProperty: Maybe<BlankNode>;

  readonly booleanTermProperty: Maybe<boolean>;

  readonly dateTermProperty: Maybe<Date>;

  readonly dateTimeTermProperty: Maybe<Date>;

  readonly iriTermProperty: Maybe<NamedNode>;

  readonly literalTermProperty: Maybe<Literal>;

  readonly numberTermProperty: Maybe<number>;

  readonly stringTermProperty: Maybe<string>;

  readonly termProperty: Maybe<BlankNode | Literal | NamedNode>;

  constructor(parameters?: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly blankNodeTermProperty?: Maybe<BlankNode> | BlankNode;
    readonly booleanTermProperty?: Maybe<boolean> | boolean;
    readonly dateTermProperty?: Maybe<Date> | Date;
    readonly dateTimeTermProperty?: Maybe<Date> | Date;
    readonly iriTermProperty?: Maybe<NamedNode> | NamedNode | string;
    readonly literalTermProperty?:
      | Maybe<Literal>
      | bigint
      | boolean
      | Date
      | number
      | string
      | Literal;
    readonly numberTermProperty?: Maybe<number> | number;
    readonly stringTermProperty?: Maybe<string> | string;
    readonly termProperty?:
      | Maybe<BlankNode | Literal | NamedNode>
      | bigint
      | boolean
      | Date
      | number
      | string
      | (BlankNode | Literal | NamedNode);
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }
    if (Maybe.isMaybe(parameters?.blankNodeTermProperty)) {
      this.blankNodeTermProperty = parameters?.blankNodeTermProperty;
    } else if (typeof parameters?.blankNodeTermProperty === "object") {
      this.blankNodeTermProperty = Maybe.of(parameters?.blankNodeTermProperty);
    } else if (typeof parameters?.blankNodeTermProperty === "undefined") {
      this.blankNodeTermProperty = Maybe.empty();
    } else {
      this.blankNodeTermProperty =
        parameters?.blankNodeTermProperty satisfies never;
    }
    if (Maybe.isMaybe(parameters?.booleanTermProperty)) {
      this.booleanTermProperty = parameters?.booleanTermProperty;
    } else if (typeof parameters?.booleanTermProperty === "boolean") {
      this.booleanTermProperty = Maybe.of(parameters?.booleanTermProperty);
    } else if (typeof parameters?.booleanTermProperty === "undefined") {
      this.booleanTermProperty = Maybe.empty();
    } else {
      this.booleanTermProperty =
        parameters?.booleanTermProperty satisfies never;
    }
    if (Maybe.isMaybe(parameters?.dateTermProperty)) {
      this.dateTermProperty = parameters?.dateTermProperty;
    } else if (
      typeof parameters?.dateTermProperty === "object" &&
      parameters?.dateTermProperty instanceof Date
    ) {
      this.dateTermProperty = Maybe.of(parameters?.dateTermProperty);
    } else if (typeof parameters?.dateTermProperty === "undefined") {
      this.dateTermProperty = Maybe.empty();
    } else {
      this.dateTermProperty = parameters?.dateTermProperty satisfies never;
    }
    if (Maybe.isMaybe(parameters?.dateTimeTermProperty)) {
      this.dateTimeTermProperty = parameters?.dateTimeTermProperty;
    } else if (
      typeof parameters?.dateTimeTermProperty === "object" &&
      parameters?.dateTimeTermProperty instanceof Date
    ) {
      this.dateTimeTermProperty = Maybe.of(parameters?.dateTimeTermProperty);
    } else if (typeof parameters?.dateTimeTermProperty === "undefined") {
      this.dateTimeTermProperty = Maybe.empty();
    } else {
      this.dateTimeTermProperty =
        parameters?.dateTimeTermProperty satisfies never;
    }
    if (Maybe.isMaybe(parameters?.iriTermProperty)) {
      this.iriTermProperty = parameters?.iriTermProperty;
    } else if (typeof parameters?.iriTermProperty === "object") {
      this.iriTermProperty = Maybe.of(parameters?.iriTermProperty);
    } else if (typeof parameters?.iriTermProperty === "string") {
      this.iriTermProperty = Maybe.of(
        dataFactory.namedNode(parameters?.iriTermProperty),
      );
    } else if (typeof parameters?.iriTermProperty === "undefined") {
      this.iriTermProperty = Maybe.empty();
    } else {
      this.iriTermProperty = parameters?.iriTermProperty satisfies never;
    }
    if (Maybe.isMaybe(parameters?.literalTermProperty)) {
      this.literalTermProperty = parameters?.literalTermProperty;
    } else if (typeof parameters?.literalTermProperty === "bigint") {
      this.literalTermProperty = Maybe.of(
        $literalFactory.bigint(parameters?.literalTermProperty),
      );
    } else if (typeof parameters?.literalTermProperty === "boolean") {
      this.literalTermProperty = Maybe.of(
        $literalFactory.boolean(parameters?.literalTermProperty),
      );
    } else if (
      typeof parameters?.literalTermProperty === "object" &&
      parameters?.literalTermProperty instanceof Date
    ) {
      this.literalTermProperty = Maybe.of(
        $literalFactory.date(parameters?.literalTermProperty),
      );
    } else if (typeof parameters?.literalTermProperty === "number") {
      this.literalTermProperty = Maybe.of(
        $literalFactory.number(parameters?.literalTermProperty),
      );
    } else if (typeof parameters?.literalTermProperty === "string") {
      this.literalTermProperty = Maybe.of(
        $literalFactory.string(parameters?.literalTermProperty),
      );
    } else if (typeof parameters?.literalTermProperty === "object") {
      this.literalTermProperty = Maybe.of(parameters?.literalTermProperty);
    } else if (typeof parameters?.literalTermProperty === "undefined") {
      this.literalTermProperty = Maybe.empty();
    } else {
      this.literalTermProperty =
        parameters?.literalTermProperty satisfies never;
    }
    if (Maybe.isMaybe(parameters?.numberTermProperty)) {
      this.numberTermProperty = parameters?.numberTermProperty;
    } else if (typeof parameters?.numberTermProperty === "number") {
      this.numberTermProperty = Maybe.of(parameters?.numberTermProperty);
    } else if (typeof parameters?.numberTermProperty === "undefined") {
      this.numberTermProperty = Maybe.empty();
    } else {
      this.numberTermProperty = parameters?.numberTermProperty satisfies never;
    }
    if (Maybe.isMaybe(parameters?.stringTermProperty)) {
      this.stringTermProperty = parameters?.stringTermProperty;
    } else if (typeof parameters?.stringTermProperty === "string") {
      this.stringTermProperty = Maybe.of(parameters?.stringTermProperty);
    } else if (typeof parameters?.stringTermProperty === "undefined") {
      this.stringTermProperty = Maybe.empty();
    } else {
      this.stringTermProperty = parameters?.stringTermProperty satisfies never;
    }
    if (Maybe.isMaybe(parameters?.termProperty)) {
      this.termProperty = parameters?.termProperty;
    } else if (typeof parameters?.termProperty === "bigint") {
      this.termProperty = Maybe.of(
        $literalFactory.bigint(parameters?.termProperty),
      );
    } else if (typeof parameters?.termProperty === "boolean") {
      this.termProperty = Maybe.of(
        $literalFactory.boolean(parameters?.termProperty),
      );
    } else if (
      typeof parameters?.termProperty === "object" &&
      parameters?.termProperty instanceof Date
    ) {
      this.termProperty = Maybe.of(
        $literalFactory.date(parameters?.termProperty),
      );
    } else if (typeof parameters?.termProperty === "number") {
      this.termProperty = Maybe.of(
        $literalFactory.number(parameters?.termProperty),
      );
    } else if (typeof parameters?.termProperty === "string") {
      this.termProperty = Maybe.of(
        $literalFactory.string(parameters?.termProperty),
      );
    } else if (typeof parameters?.termProperty === "object") {
      this.termProperty = Maybe.of(parameters?.termProperty);
    } else if (typeof parameters?.termProperty === "undefined") {
      this.termProperty = Maybe.empty();
    } else {
      this.termProperty = parameters?.termProperty satisfies never;
    }
  }

  get $identifier(): TermPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: TermPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.blankNodeTermProperty,
          other.blankNodeTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "blankNodeTermProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.booleanTermProperty,
          other.booleanTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "booleanTermProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.dateTermProperty,
          other.dateTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "dateTermProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.dateTimeTermProperty,
          other.dateTimeTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "dateTimeTermProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.iriTermProperty,
          other.iriTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "iriTermProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.literalTermProperty,
          other.literalTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "literalTermProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.numberTermProperty,
          other.numberTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "numberTermProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.stringTermProperty,
          other.stringTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "stringTermProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.termProperty,
          other.termProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "termProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    this.blankNodeTermProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    this.booleanTermProperty.ifJust((value0) => {
      _hasher.update(value0.toString());
    });
    this.dateTermProperty.ifJust((value0) => {
      _hasher.update(value0.toISOString());
    });
    this.dateTimeTermProperty.ifJust((value0) => {
      _hasher.update(value0.toISOString());
    });
    this.iriTermProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    this.literalTermProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
      _hasher.update(value0.datatype.value);
      _hasher.update(value0.language);
    });
    this.numberTermProperty.ifJust((value0) => {
      _hasher.update(value0.toString());
    });
    this.stringTermProperty.ifJust((value0) => {
      _hasher.update(value0);
    });
    this.termProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    return _hasher;
  }

  $toJson(): TermPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        blankNodeTermProperty: this.blankNodeTermProperty
          .map((item) => ({ "@id": `_:${item.value}` }))
          .extract(),
        booleanTermProperty: this.booleanTermProperty
          .map((item) => item)
          .extract(),
        dateTermProperty: this.dateTermProperty
          .map((item) => item.toISOString().replace(/T.*$/, ""))
          .extract(),
        dateTimeTermProperty: this.dateTimeTermProperty
          .map((item) => item.toISOString())
          .extract(),
        iriTermProperty: this.iriTermProperty
          .map((item) => ({ "@id": item.value }))
          .extract(),
        literalTermProperty: this.literalTermProperty
          .map((item) => ({
            "@language": item.language.length > 0 ? item.language : undefined,
            "@type":
              item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? item.datatype.value
                : undefined,
            "@value": item.value,
          }))
          .extract(),
        numberTermProperty: this.numberTermProperty
          .map((item) => item)
          .extract(),
        stringTermProperty: this.stringTermProperty
          .map((item) => item)
          .extract(),
        termProperty: this.termProperty
          .map((item) =>
            item.termType === "NamedNode"
              ? { "@id": item.value, termType: "NamedNode" as const }
              : item.termType === "Literal"
                ? {
                    "@language":
                      item.language.length > 0 ? item.language : undefined,
                    "@type":
                      item.datatype.value !==
                      "http://www.w3.org/2001/XMLSchema#string"
                        ? item.datatype.value
                        : undefined,
                    "@value": item.value,
                    termType: "Literal" as const,
                  }
                : { "@id": `_:${item.value}`, termType: "BlankNode" as const },
          )
          .extract(),
      } satisfies TermPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/TermPropertiesClass"),
        options?.graph,
      );
    }
    resource.add(
      TermPropertiesClass.$schema.properties.blankNodeTermProperty.identifier,
      this.blankNodeTermProperty.toList(),
      options?.graph,
    );
    resource.add(
      TermPropertiesClass.$schema.properties.booleanTermProperty.identifier,
      this.booleanTermProperty
        .toList()
        .flatMap((value) => [$literalFactory.boolean(value)]),
      options?.graph,
    );
    resource.add(
      TermPropertiesClass.$schema.properties.dateTermProperty.identifier,
      this.dateTermProperty
        .toList()
        .flatMap((value) => [
          $literalFactory.date(value, $RdfVocabularies.xsd.date),
        ]),
      options?.graph,
    );
    resource.add(
      TermPropertiesClass.$schema.properties.dateTimeTermProperty.identifier,
      this.dateTimeTermProperty
        .toList()
        .flatMap((value) => [
          $literalFactory.date(value, $RdfVocabularies.xsd.dateTime),
        ]),
      options?.graph,
    );
    resource.add(
      TermPropertiesClass.$schema.properties.iriTermProperty.identifier,
      this.iriTermProperty.toList(),
      options?.graph,
    );
    resource.add(
      TermPropertiesClass.$schema.properties.literalTermProperty.identifier,
      this.literalTermProperty.toList(),
      options?.graph,
    );
    resource.add(
      TermPropertiesClass.$schema.properties.numberTermProperty.identifier,
      this.numberTermProperty
        .toList()
        .flatMap((value) => [
          $literalFactory.number(value, $RdfVocabularies.xsd.decimal),
        ]),
      options?.graph,
    );
    resource.add(
      TermPropertiesClass.$schema.properties.stringTermProperty.identifier,
      this.stringTermProperty
        .toList()
        .flatMap((value) => [$literalFactory.string(value)]),
      options?.graph,
    );
    resource.add(
      TermPropertiesClass.$schema.properties.termProperty.identifier,
      this.termProperty.toList(),
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace TermPropertiesClass {
  export function $filter(
    filter: TermPropertiesClass.$Filter,
    value: TermPropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.blankNodeTermProperty !== "undefined" &&
      !$filterMaybe<BlankNode, $BlankNodeFilter>($filterBlankNode)(
        filter.blankNodeTermProperty,
        value.blankNodeTermProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.booleanTermProperty !== "undefined" &&
      !$filterMaybe<boolean, $BooleanFilter>($filterBoolean)(
        filter.booleanTermProperty,
        value.booleanTermProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.dateTermProperty !== "undefined" &&
      !$filterMaybe<Date, $DateFilter>($filterDate)(
        filter.dateTermProperty,
        value.dateTermProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.dateTimeTermProperty !== "undefined" &&
      !$filterMaybe<Date, $DateFilter>($filterDate)(
        filter.dateTimeTermProperty,
        value.dateTimeTermProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.iriTermProperty !== "undefined" &&
      !$filterMaybe<NamedNode, $NamedNodeFilter>($filterNamedNode)(
        filter.iriTermProperty,
        value.iriTermProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.literalTermProperty !== "undefined" &&
      !$filterMaybe<Literal, $LiteralFilter>($filterLiteral)(
        filter.literalTermProperty,
        value.literalTermProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.numberTermProperty !== "undefined" &&
      !$filterMaybe<number, $NumberFilter>($filterNumber)(
        filter.numberTermProperty,
        value.numberTermProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.stringTermProperty !== "undefined" &&
      !$filterMaybe<string, $StringFilter>($filterString)(
        filter.stringTermProperty,
        value.stringTermProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.termProperty !== "undefined" &&
      !$filterMaybe<BlankNode | Literal | NamedNode, $TermFilter>($filterTerm)(
        filter.termProperty,
        value.termProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly blankNodeTermProperty?: $MaybeFilter<$BlankNodeFilter>;
    readonly booleanTermProperty?: $MaybeFilter<$BooleanFilter>;
    readonly dateTermProperty?: $MaybeFilter<$DateFilter>;
    readonly dateTimeTermProperty?: $MaybeFilter<$DateFilter>;
    readonly iriTermProperty?: $MaybeFilter<$NamedNodeFilter>;
    readonly literalTermProperty?: $MaybeFilter<$LiteralFilter>;
    readonly numberTermProperty?: $MaybeFilter<$NumberFilter>;
    readonly stringTermProperty?: $MaybeFilter<$StringFilter>;
    readonly termProperty?: $MaybeFilter<$TermFilter>;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/TermPropertiesClass",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      blankNodeTermProperty: Maybe<BlankNode>;
      booleanTermProperty: Maybe<boolean>;
      dateTermProperty: Maybe<Date>;
      dateTimeTermProperty: Maybe<Date>;
      iriTermProperty: Maybe<NamedNode>;
      literalTermProperty: Maybe<Literal>;
      numberTermProperty: Maybe<number>;
      stringTermProperty: Maybe<string>;
      termProperty: Maybe<BlankNode | Literal | NamedNode>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const blankNodeTermProperty = Maybe.fromNullable(
      $jsonObject["blankNodeTermProperty"],
    ).map((item) => dataFactory.blankNode(item["@id"].substring(2)));
    const booleanTermProperty = Maybe.fromNullable(
      $jsonObject["booleanTermProperty"],
    );
    const dateTermProperty = Maybe.fromNullable(
      $jsonObject["dateTermProperty"],
    ).map((item) => new Date(item));
    const dateTimeTermProperty = Maybe.fromNullable(
      $jsonObject["dateTimeTermProperty"],
    ).map((item) => new Date(item));
    const iriTermProperty = Maybe.fromNullable(
      $jsonObject["iriTermProperty"],
    ).map((item) => dataFactory.namedNode(item["@id"]));
    const literalTermProperty = Maybe.fromNullable(
      $jsonObject["literalTermProperty"],
    ).map((item) =>
      dataFactory.literal(
        item["@value"],
        typeof item["@language"] !== "undefined"
          ? item["@language"]
          : typeof item["@type"] !== "undefined"
            ? dataFactory.namedNode(item["@type"])
            : undefined,
      ),
    );
    const numberTermProperty = Maybe.fromNullable(
      $jsonObject["numberTermProperty"],
    );
    const stringTermProperty = Maybe.fromNullable(
      $jsonObject["stringTermProperty"],
    );
    const termProperty = Maybe.fromNullable($jsonObject["termProperty"]).map(
      (item) =>
        item.termType === "NamedNode"
          ? dataFactory.namedNode(item["@id"])
          : item.termType === "Literal"
            ? dataFactory.literal(
                item["@value"],
                typeof item["@language"] !== "undefined"
                  ? item["@language"]
                  : typeof item["@type"] !== "undefined"
                    ? dataFactory.namedNode(item["@type"])
                    : undefined,
              )
            : dataFactory.blankNode(item["@id"].substring(2)),
    );
    return Either.of({
      $identifier,
      blankNodeTermProperty,
      booleanTermProperty,
      dateTermProperty,
      dateTimeTermProperty,
      iriTermProperty,
      literalTermProperty,
      numberTermProperty,
      stringTermProperty,
      termProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, TermPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new TermPropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "TermPropertiesClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/blankNodeTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/booleanTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateTimeTermProperty`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/iriTermProperty`, type: "Control" },
        {
          scope: `${scopePrefix}/properties/literalTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/numberTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/stringTermProperty`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/termProperty`, type: "Control" },
      ],
      label: "TermPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("TermPropertiesClass"),
      blankNodeTermProperty: z.object({ "@id": z.string().min(1) }).optional(),
      booleanTermProperty: z.boolean().optional(),
      dateTermProperty: z.iso.date().optional(),
      dateTimeTermProperty: z.iso.datetime().optional(),
      iriTermProperty: z.object({ "@id": z.string().min(1) }).optional(),
      literalTermProperty: z
        .object({
          "@language": z.string().optional(),
          "@type": z.string().optional(),
          "@value": z.string(),
        })
        .optional(),
      numberTermProperty: z.number().optional(),
      stringTermProperty: z.string().optional(),
      termProperty: z
        .discriminatedUnion("termType", [
          z.object({
            "@id": z.string().min(1),
            termType: z.literal("BlankNode"),
          }),
          z.object({
            "@language": z.string().optional(),
            "@type": z.string().optional(),
            "@value": z.string(),
            termType: z.literal("Literal"),
          }),
          z.object({
            "@id": z.string().min(1),
            termType: z.literal("NamedNode"),
          }),
        ])
        .optional(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "TermPropertiesClass";
    readonly blankNodeTermProperty?: { readonly "@id": string };
    readonly booleanTermProperty?: boolean;
    readonly dateTermProperty?: string;
    readonly dateTimeTermProperty?: string;
    readonly iriTermProperty?: { readonly "@id": string };
    readonly literalTermProperty?: {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    };
    readonly numberTermProperty?: number;
    readonly stringTermProperty?: string;
    readonly termProperty?:
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly "@type"?: string;
          readonly "@value": string;
          readonly termType: "Literal";
        };
  };

  export function isTermPropertiesClass(
    object: $Object,
  ): object is TermPropertiesClass {
    switch (object.$type) {
      case "TermPropertiesClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, TermPropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return TermPropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new TermPropertiesClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      blankNodeTermProperty: Maybe<BlankNode>;
      booleanTermProperty: Maybe<boolean>;
      dateTermProperty: Maybe<Date>;
      dateTimeTermProperty: Maybe<Date>;
      iriTermProperty: Maybe<NamedNode>;
      literalTermProperty: Maybe<Literal>;
      numberTermProperty: Maybe<number>;
      stringTermProperty: Maybe<string>;
      termProperty: Maybe<BlankNode | Literal | NamedNode>;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/TermPropertiesClass":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  TermPropertiesClass.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/TermPropertiesClass)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, TermPropertiesClass.$Identifier>(
        $parameters.resource.identifier as TermPropertiesClass.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.blankNodeTermProperty.identifier,
            { unique: true },
          ),
        )
          .chain((values) => values.chainMap((value) => value.toBlankNode()))
          .map((values) =>
            values.length > 0
              ? values.map((value) => Maybe.of(value))
              : Resource.Values.fromValue<Maybe<BlankNode>>({
                  focusResource: $parameters.resource,
                  predicate:
                    TermPropertiesClass.$schema.properties.blankNodeTermProperty
                      .identifier,
                  value: Maybe.empty(),
                }),
          )
          .chain((values) => values.head())
          .chain((blankNodeTermProperty) =>
            Either.of<Error, Resource.Values<Resource.TermValue>>(
              $parameters.resource.values(
                $schema.properties.booleanTermProperty.identifier,
                { unique: true },
              ),
            )
              .chain((values) => values.chainMap((value) => value.toBoolean()))
              .map((values) =>
                values.length > 0
                  ? values.map((value) => Maybe.of(value))
                  : Resource.Values.fromValue<Maybe<boolean>>({
                      focusResource: $parameters.resource,
                      predicate:
                        TermPropertiesClass.$schema.properties
                          .booleanTermProperty.identifier,
                      value: Maybe.empty(),
                    }),
              )
              .chain((values) => values.head())
              .chain((booleanTermProperty) =>
                Either.of<Error, Resource.Values<Resource.TermValue>>(
                  $parameters.resource.values(
                    $schema.properties.dateTermProperty.identifier,
                    { unique: true },
                  ),
                )
                  .chain((values) => values.chainMap((value) => value.toDate()))
                  .map((values) =>
                    values.length > 0
                      ? values.map((value) => Maybe.of(value))
                      : Resource.Values.fromValue<Maybe<Date>>({
                          focusResource: $parameters.resource,
                          predicate:
                            TermPropertiesClass.$schema.properties
                              .dateTermProperty.identifier,
                          value: Maybe.empty(),
                        }),
                  )
                  .chain((values) => values.head())
                  .chain((dateTermProperty) =>
                    Either.of<Error, Resource.Values<Resource.TermValue>>(
                      $parameters.resource.values(
                        $schema.properties.dateTimeTermProperty.identifier,
                        { unique: true },
                      ),
                    )
                      .chain((values) =>
                        values.chainMap((value) => value.toDate()),
                      )
                      .map((values) =>
                        values.length > 0
                          ? values.map((value) => Maybe.of(value))
                          : Resource.Values.fromValue<Maybe<Date>>({
                              focusResource: $parameters.resource,
                              predicate:
                                TermPropertiesClass.$schema.properties
                                  .dateTimeTermProperty.identifier,
                              value: Maybe.empty(),
                            }),
                      )
                      .chain((values) => values.head())
                      .chain((dateTimeTermProperty) =>
                        Either.of<Error, Resource.Values<Resource.TermValue>>(
                          $parameters.resource.values(
                            $schema.properties.iriTermProperty.identifier,
                            { unique: true },
                          ),
                        )
                          .chain((values) =>
                            values.chainMap((value) => value.toIri()),
                          )
                          .map((values) =>
                            values.length > 0
                              ? values.map((value) => Maybe.of(value))
                              : Resource.Values.fromValue<Maybe<NamedNode>>({
                                  focusResource: $parameters.resource,
                                  predicate:
                                    TermPropertiesClass.$schema.properties
                                      .iriTermProperty.identifier,
                                  value: Maybe.empty(),
                                }),
                          )
                          .chain((values) => values.head())
                          .chain((iriTermProperty) =>
                            Either.of<
                              Error,
                              Resource.Values<Resource.TermValue>
                            >(
                              $parameters.resource.values(
                                $schema.properties.literalTermProperty
                                  .identifier,
                                { unique: true },
                              ),
                            )
                              .chain((values) =>
                                $fromRdfPreferredLanguages({
                                  focusResource: $parameters.resource,
                                  predicate:
                                    TermPropertiesClass.$schema.properties
                                      .literalTermProperty.identifier,
                                  preferredLanguages:
                                    $parameters.preferredLanguages,
                                  values,
                                }),
                              )
                              .chain((values) =>
                                values.chainMap((value) => value.toLiteral()),
                              )
                              .map((values) =>
                                values.length > 0
                                  ? values.map((value) => Maybe.of(value))
                                  : Resource.Values.fromValue<Maybe<Literal>>({
                                      focusResource: $parameters.resource,
                                      predicate:
                                        TermPropertiesClass.$schema.properties
                                          .literalTermProperty.identifier,
                                      value: Maybe.empty(),
                                    }),
                              )
                              .chain((values) => values.head())
                              .chain((literalTermProperty) =>
                                Either.of<
                                  Error,
                                  Resource.Values<Resource.TermValue>
                                >(
                                  $parameters.resource.values(
                                    $schema.properties.numberTermProperty
                                      .identifier,
                                    { unique: true },
                                  ),
                                )
                                  .chain((values) =>
                                    values.chainMap((value) =>
                                      value.toNumber(),
                                    ),
                                  )
                                  .map((values) =>
                                    values.length > 0
                                      ? values.map((value) => Maybe.of(value))
                                      : Resource.Values.fromValue<
                                          Maybe<number>
                                        >({
                                          focusResource: $parameters.resource,
                                          predicate:
                                            TermPropertiesClass.$schema
                                              .properties.numberTermProperty
                                              .identifier,
                                          value: Maybe.empty(),
                                        }),
                                  )
                                  .chain((values) => values.head())
                                  .chain((numberTermProperty) =>
                                    Either.of<
                                      Error,
                                      Resource.Values<Resource.TermValue>
                                    >(
                                      $parameters.resource.values(
                                        $schema.properties.stringTermProperty
                                          .identifier,
                                        {
                                          unique: true,
                                        },
                                      ),
                                    )
                                      .chain((values) =>
                                        $fromRdfPreferredLanguages({
                                          focusResource: $parameters.resource,
                                          predicate:
                                            TermPropertiesClass.$schema
                                              .properties.stringTermProperty
                                              .identifier,
                                          preferredLanguages:
                                            $parameters.preferredLanguages,
                                          values,
                                        }),
                                      )
                                      .chain((values) =>
                                        values.chainMap((value) =>
                                          value.toString(),
                                        ),
                                      )
                                      .map((values) =>
                                        values.length > 0
                                          ? values.map((value) =>
                                              Maybe.of(value),
                                            )
                                          : Resource.Values.fromValue<
                                              Maybe<string>
                                            >({
                                              focusResource:
                                                $parameters.resource,
                                              predicate:
                                                TermPropertiesClass.$schema
                                                  .properties.stringTermProperty
                                                  .identifier,
                                              value: Maybe.empty(),
                                            }),
                                      )
                                      .chain((values) => values.head())
                                      .chain((stringTermProperty) =>
                                        Either.of<
                                          Error,
                                          Resource.Values<Resource.TermValue>
                                        >(
                                          $parameters.resource.values(
                                            $schema.properties.termProperty
                                              .identifier,
                                            { unique: true },
                                          ),
                                        )
                                          .chain((values) =>
                                            values.chainMap((value) =>
                                              Either.of<
                                                Error,
                                                BlankNode | Literal | NamedNode
                                              >(value.toTerm()),
                                            ),
                                          )
                                          .map((values) =>
                                            values.length > 0
                                              ? values.map((value) =>
                                                  Maybe.of(value),
                                                )
                                              : Resource.Values.fromValue<
                                                  Maybe<
                                                    | BlankNode
                                                    | Literal
                                                    | NamedNode
                                                  >
                                                >({
                                                  focusResource:
                                                    $parameters.resource,
                                                  predicate:
                                                    TermPropertiesClass.$schema
                                                      .properties.termProperty
                                                      .identifier,
                                                  value: Maybe.empty(),
                                                }),
                                          )
                                          .chain((values) => values.head())
                                          .map((termProperty) => ({
                                            $identifier,
                                            blankNodeTermProperty,
                                            booleanTermProperty,
                                            dateTermProperty,
                                            dateTimeTermProperty,
                                            iriTermProperty,
                                            literalTermProperty,
                                            numberTermProperty,
                                            stringTermProperty,
                                            termProperty,
                                          })),
                                      ),
                                  ),
                              ),
                          ),
                      ),
                  ),
              ),
          ),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["TermPropertiesClass"],
        }),
      },
      blankNodeTermProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({ kind: "BlankNode" as const }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/blankNodeTermProperty",
        ),
      },
      booleanTermProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({ kind: "Boolean" as const }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/booleanTermProperty",
        ),
      },
      dateTermProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({ kind: "Date" as const }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/dateTermProperty",
        ),
      },
      dateTimeTermProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({ kind: "DateTime" as const }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/dateTimeTermProperty",
        ),
      },
      iriTermProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({ kind: "NamedNode" as const }),
        }),
        identifier: dataFactory.namedNode("http://example.com/iriTermProperty"),
      },
      literalTermProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({ kind: "Literal" as const }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/literalTermProperty",
        ),
      },
      numberTermProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({ kind: "Float" as const }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/numberTermProperty",
        ),
      },
      stringTermProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({ kind: "String" as const }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/stringTermProperty",
        ),
      },
      termProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({
            kind: "Term" as const,
            nodeKinds: [
              "BlankNode" as const,
              "Literal" as const,
              "NamedNode" as const,
            ],
          }),
        }),
        identifier: dataFactory.namedNode("http://example.com/termProperty"),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: TermPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        TermPropertiesClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          TermPropertiesClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: TermPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      TermPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("termPropertiesClass");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "termPropertiesClass")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "termPropertiesClass")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "termPropertiesClass")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "termPropertiesClass")
          }BlankNodeTermProperty`,
        ),
        predicate:
          TermPropertiesClass.$schema.properties.blankNodeTermProperty
            .identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "termPropertiesClass")
          }BooleanTermProperty`,
        ),
        predicate:
          TermPropertiesClass.$schema.properties.booleanTermProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "termPropertiesClass")
          }DateTermProperty`,
        ),
        predicate:
          TermPropertiesClass.$schema.properties.dateTermProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "termPropertiesClass")
          }DateTimeTermProperty`,
        ),
        predicate:
          TermPropertiesClass.$schema.properties.dateTimeTermProperty
            .identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "termPropertiesClass")
          }IriTermProperty`,
        ),
        predicate:
          TermPropertiesClass.$schema.properties.iriTermProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "termPropertiesClass")
          }LiteralTermProperty`,
        ),
        predicate:
          TermPropertiesClass.$schema.properties.literalTermProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "termPropertiesClass")
          }NumberTermProperty`,
        ),
        predicate:
          TermPropertiesClass.$schema.properties.numberTermProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "termPropertiesClass")
          }StringTermProperty`,
        ),
        predicate:
          TermPropertiesClass.$schema.properties.stringTermProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "termPropertiesClass")
          }TermProperty`,
        ),
        predicate:
          TermPropertiesClass.$schema.properties.termProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: TermPropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("termPropertiesClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "termPropertiesClass")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: TermPropertiesClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "termPropertiesClass")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: TermPropertiesClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "termPropertiesClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<$BlankNodeFilter, $BlankNodeSchema>(
        $blankNodeSparqlWherePatterns,
      )({
        filter: parameters?.filter?.blankNodeTermProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "termPropertiesClass")
                  }BlankNodeTermProperty`,
                ),
                predicate:
                  TermPropertiesClass.$schema.properties.blankNodeTermProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          TermPropertiesClass.$schema.properties.blankNodeTermProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "termPropertiesClass")
          }BlankNodeTermProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "termPropertiesClass")
        }BlankNodeTermProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<$BooleanFilter, $BooleanSchema>(
        $booleanSparqlWherePatterns,
      )({
        filter: parameters?.filter?.booleanTermProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "termPropertiesClass")
                  }BooleanTermProperty`,
                ),
                predicate:
                  TermPropertiesClass.$schema.properties.booleanTermProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          TermPropertiesClass.$schema.properties.booleanTermProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "termPropertiesClass")
          }BooleanTermProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "termPropertiesClass")
        }BooleanTermProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<$DateFilter, $DateSchema>(
        $dateSparqlWherePatterns,
      )({
        filter: parameters?.filter?.dateTermProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "termPropertiesClass")
                  }DateTermProperty`,
                ),
                predicate:
                  TermPropertiesClass.$schema.properties.dateTermProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema: TermPropertiesClass.$schema.properties.dateTermProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "termPropertiesClass")
          }DateTermProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "termPropertiesClass")
        }DateTermProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<$DateFilter, $DateSchema>(
        $dateSparqlWherePatterns,
      )({
        filter: parameters?.filter?.dateTimeTermProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "termPropertiesClass")
                  }DateTimeTermProperty`,
                ),
                predicate:
                  TermPropertiesClass.$schema.properties.dateTimeTermProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          TermPropertiesClass.$schema.properties.dateTimeTermProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "termPropertiesClass")
          }DateTimeTermProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "termPropertiesClass")
        }DateTimeTermProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<$NamedNodeFilter, $NamedNodeSchema>(
        $namedNodeSparqlWherePatterns,
      )({
        filter: parameters?.filter?.iriTermProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "termPropertiesClass")
                  }IriTermProperty`,
                ),
                predicate:
                  TermPropertiesClass.$schema.properties.iriTermProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema: TermPropertiesClass.$schema.properties.iriTermProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "termPropertiesClass")
          }IriTermProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "termPropertiesClass")
        }IriTermProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<$LiteralFilter, $LiteralSchema>(
        $literalSparqlWherePatterns,
      )({
        filter: parameters?.filter?.literalTermProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "termPropertiesClass")
                  }LiteralTermProperty`,
                ),
                predicate:
                  TermPropertiesClass.$schema.properties.literalTermProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          TermPropertiesClass.$schema.properties.literalTermProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "termPropertiesClass")
          }LiteralTermProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "termPropertiesClass")
        }LiteralTermProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<$NumberFilter, $NumberSchema>(
        $numberSparqlWherePatterns,
      )({
        filter: parameters?.filter?.numberTermProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "termPropertiesClass")
                  }NumberTermProperty`,
                ),
                predicate:
                  TermPropertiesClass.$schema.properties.numberTermProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          TermPropertiesClass.$schema.properties.numberTermProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "termPropertiesClass")
          }NumberTermProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "termPropertiesClass")
        }NumberTermProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<$StringFilter, $StringSchema>(
        $stringSparqlWherePatterns,
      )({
        filter: parameters?.filter?.stringTermProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "termPropertiesClass")
                  }StringTermProperty`,
                ),
                predicate:
                  TermPropertiesClass.$schema.properties.stringTermProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          TermPropertiesClass.$schema.properties.stringTermProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "termPropertiesClass")
          }StringTermProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "termPropertiesClass")
        }StringTermProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<$TermFilter, $TermSchema>(
        $termSparqlWherePatterns,
      )({
        filter: parameters?.filter?.termProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "termPropertiesClass")
                  }TermProperty`,
                ),
                predicate:
                  TermPropertiesClass.$schema.properties.termProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema: TermPropertiesClass.$schema.properties.termProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "termPropertiesClass")
          }TermProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "termPropertiesClass")
        }TermProperty`,
      }),
    );
    return patterns;
  }
} /**
 * A node shape that mints its identifier by hashing (other) contents, if no identifier is supplied.
 */

export class Sha256IriIdentifierClass {
  private _$identifier?: Sha256IriIdentifierClass.$Identifier;

  protected readonly _$identifierPrefix?: string;

  readonly $type: "Sha256IriIdentifierClass" =
    "Sha256IriIdentifierClass" as const;

  readonly sha256IriProperty: string;

  constructor(parameters: {
    readonly $identifier?: NamedNode | string;
    readonly $identifierPrefix?: string;
    readonly sha256IriProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this._$identifierPrefix = parameters.$identifierPrefix;
    this.sha256IriProperty = parameters.sha256IriProperty;
  }

  get $identifier(): Sha256IriIdentifierClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }
    if (this._$identifier.termType !== "NamedNode") {
      throw new Error(
        `expected identifier to be NamedNode, not ${this._$identifier.termType}`,
      );
    }
    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  $equals(other: Sha256IriIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$identifierPrefix, other.$identifierPrefix).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$identifierPrefix",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.sha256IriProperty, other.sha256IriProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "sha256IriProperty",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.sha256IriProperty);
    return _hasher;
  }

  $toJson(): Sha256IriIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
        sha256IriProperty: this.sha256IriProperty,
      } satisfies Sha256IriIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource<NamedNode> {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    resource.add(
      Sha256IriIdentifierClass.$schema.properties.sha256IriProperty.identifier,
      [$literalFactory.string(this.sha256IriProperty)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace Sha256IriIdentifierClass {
  export function $filter(
    filter: Sha256IriIdentifierClass.$Filter,
    value: Sha256IriIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.sha256IriProperty !== "undefined" &&
      !$filterString(filter.sha256IriProperty, value.sha256IriProperty)
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
    readonly sha256IriProperty?: $StringFilter;
  };

  export type $Identifier = NamedNode;

  export namespace $Identifier {
    export function fromString(identifier: string): Either<Error, NamedNode> {
      return Either.encase(() =>
        Resource.Identifier.fromString({ dataFactory, identifier }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? Either.of(identifier)
          : Left(new Error("expected identifier to be NamedNode")),
      ) as Either<Error, NamedNode>;
    } // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<z.ZodError, { $identifier: NamedNode; sha256IriProperty: string }> {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const sha256IriProperty = $jsonObject["sha256IriProperty"];
    return Either.of({ $identifier, sha256IriProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, Sha256IriIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new Sha256IriIdentifierClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "Sha256IriIdentifierClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/sha256IriProperty`,
          type: "Control",
        },
      ],
      label: "Sha256IriIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("Sha256IriIdentifierClass"),
      sha256IriProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "Sha256IriIdentifierClass";
    readonly sha256IriProperty: string;
  };

  export function isSha256IriIdentifierClass(
    object: $Object,
  ): object is Sha256IriIdentifierClass {
    switch (object.$type) {
      case "Sha256IriIdentifierClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, Sha256IriIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return Sha256IriIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new Sha256IriIdentifierClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<Error, { $identifier: NamedNode; sha256IriProperty: string }> {
    return (
      $parameters.resource.identifier.termType === "NamedNode"
        ? Either.of<Error, Sha256IriIdentifierClass.$Identifier>(
            $parameters.resource.identifier,
          )
        : Left(
            new Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "NamedNode",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
    ).chain(($identifier) =>
      Either.of<Error, Resource.Values<Resource.TermValue>>(
        $parameters.resource.values(
          $schema.properties.sha256IriProperty.identifier,
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              Sha256IriIdentifierClass.$schema.properties.sha256IriProperty
                .identifier,
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((sha256IriProperty) => ({ $identifier, sha256IriProperty })),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "NamedNode" as const }),
      },
      $identifierPrefix: {
        kind: "IdentifierPrefix" as const,
        type: () => ({ kind: "String" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["Sha256IriIdentifierClass"],
        }),
      },
      sha256IriProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/sha256IriProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: Sha256IriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Sha256IriIdentifierClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          Sha256IriIdentifierClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: Sha256IriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Sha256IriIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("sha256IriIdentifierClass");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "sha256IriIdentifierClass")
          }Sha256IriProperty`,
        ),
        predicate:
          Sha256IriIdentifierClass.$schema.properties.sha256IriProperty
            .identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: Sha256IriIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("sha256IriIdentifierClass");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $namedNodeSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            Sha256IriIdentifierClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "sha256IriIdentifierClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.sha256IriProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "sha256IriIdentifierClass")
                  }Sha256IriProperty`,
                ),
                predicate:
                  Sha256IriIdentifierClass.$schema.properties.sha256IriProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          Sha256IriIdentifierClass.$schema.properties.sha256IriProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "sha256IriIdentifierClass")
          }Sha256IriProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "sha256IriIdentifierClass")
        }Sha256IriProperty`,
      }),
    );
    return patterns;
  }
}
export class RecursiveClassUnionMember2 {
  private _$identifier?: RecursiveClassUnionMember2.$Identifier;

  readonly $type: "RecursiveClassUnionMember2" =
    "RecursiveClassUnionMember2" as const;

  readonly recursiveClassUnionMember2Property: Maybe<RecursiveClassUnion>;

  constructor(parameters?: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly recursiveClassUnionMember2Property?:
      | Maybe<RecursiveClassUnion>
      | RecursiveClassUnion;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }
    if (Maybe.isMaybe(parameters?.recursiveClassUnionMember2Property)) {
      this.recursiveClassUnionMember2Property =
        parameters?.recursiveClassUnionMember2Property;
    } else if (
      typeof parameters?.recursiveClassUnionMember2Property === "object"
    ) {
      this.recursiveClassUnionMember2Property = Maybe.of(
        parameters?.recursiveClassUnionMember2Property,
      );
    } else if (
      typeof parameters?.recursiveClassUnionMember2Property === "undefined"
    ) {
      this.recursiveClassUnionMember2Property = Maybe.empty();
    } else {
      this.recursiveClassUnionMember2Property =
        parameters?.recursiveClassUnionMember2Property satisfies never;
    }
  }

  get $identifier(): RecursiveClassUnionMember2.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: RecursiveClassUnionMember2): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, RecursiveClassUnion.$equals))(
          this.recursiveClassUnionMember2Property,
          other.recursiveClassUnionMember2Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "recursiveClassUnionMember2Property",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    this.recursiveClassUnionMember2Property.ifJust((value0) => {
      RecursiveClassUnion.$hash(value0, _hasher);
    });
    return _hasher;
  }

  $toJson(): RecursiveClassUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        recursiveClassUnionMember2Property:
          this.recursiveClassUnionMember2Property
            .map((item) => RecursiveClassUnion.$toJson(item))
            .extract(),
      } satisfies RecursiveClassUnionMember2.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/RecursiveClassUnionMember2"),
        options?.graph,
      );
    }
    resource.add(
      RecursiveClassUnionMember2.$schema.properties
        .recursiveClassUnionMember2Property.identifier,
      this.recursiveClassUnionMember2Property.toList().flatMap((value) => [
        RecursiveClassUnion.$toRdf(value, {
          graph: options?.graph,
          resourceSet: resourceSet,
        }).identifier,
      ]),
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace RecursiveClassUnionMember2 {
  export function $filter(
    filter: RecursiveClassUnionMember2.$Filter,
    value: RecursiveClassUnionMember2,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.recursiveClassUnionMember2Property !== "undefined" &&
      !$filterMaybe<RecursiveClassUnion, RecursiveClassUnion.$Filter>(
        RecursiveClassUnion.$filter,
      )(
        filter.recursiveClassUnionMember2Property,
        value.recursiveClassUnionMember2Property,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly recursiveClassUnionMember2Property?: $MaybeFilter<RecursiveClassUnion.$Filter>;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/RecursiveClassUnionMember2",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      recursiveClassUnionMember2Property: Maybe<RecursiveClassUnion>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const recursiveClassUnionMember2Property = Maybe.fromNullable(
      $jsonObject["recursiveClassUnionMember2Property"],
    ).map((item) => RecursiveClassUnion.$fromJson(item).unsafeCoerce());
    return Either.of({ $identifier, recursiveClassUnionMember2Property });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, RecursiveClassUnionMember2> {
    return $propertiesFromJson(json).map(
      (properties) => new RecursiveClassUnionMember2(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "RecursiveClassUnionMember2" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/recursiveClassUnionMember2Property`,
          type: "Control",
        },
      ],
      label: "RecursiveClassUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("RecursiveClassUnionMember2"),
      recursiveClassUnionMember2Property: z
        .lazy(
          (): z.ZodType<RecursiveClassUnion.$Json> =>
            RecursiveClassUnion.$jsonZodSchema(),
        )
        .optional(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "RecursiveClassUnionMember2";
    readonly recursiveClassUnionMember2Property?:
      | RecursiveClassUnionMember1.$Json
      | RecursiveClassUnionMember2.$Json;
  };

  export function isRecursiveClassUnionMember2(
    object: $Object,
  ): object is RecursiveClassUnionMember2 {
    switch (object.$type) {
      case "RecursiveClassUnionMember2":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, RecursiveClassUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return RecursiveClassUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new RecursiveClassUnionMember2(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      recursiveClassUnionMember2Property: Maybe<RecursiveClassUnion>;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/RecursiveClassUnionMember2":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  RecursiveClassUnionMember2.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/RecursiveClassUnionMember2)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, RecursiveClassUnionMember2.$Identifier>(
        $parameters.resource
          .identifier as RecursiveClassUnionMember2.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.recursiveClassUnionMember2Property.identifier,
            {
              unique: true,
            },
          ),
        )
          .chain((values) =>
            values.chainMap((value) =>
              value.toResource().chain((resource) =>
                RecursiveClassUnion.$fromRdf(resource, {
                  context: $parameters.context,
                  ignoreRdfType: false,
                  objectSet: $parameters.objectSet,
                  preferredLanguages: $parameters.preferredLanguages,
                }),
              ),
            ),
          )
          .map((values) =>
            values.length > 0
              ? values.map((value) => Maybe.of(value))
              : Resource.Values.fromValue<Maybe<RecursiveClassUnion>>({
                  focusResource: $parameters.resource,
                  predicate:
                    RecursiveClassUnionMember2.$schema.properties
                      .recursiveClassUnionMember2Property.identifier,
                  value: Maybe.empty(),
                }),
          )
          .chain((values) => values.head())
          .map((recursiveClassUnionMember2Property) => ({
            $identifier,
            recursiveClassUnionMember2Property,
          })),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["RecursiveClassUnionMember2"],
        }),
      },
      recursiveClassUnionMember2Property: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => RecursiveClassUnion.$schema,
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/recursiveClassUnionMember2Property",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: RecursiveClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        RecursiveClassUnionMember2.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          RecursiveClassUnionMember2.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: RecursiveClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      RecursiveClassUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("recursiveClassUnionMember2");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "recursiveClassUnionMember2")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "recursiveClassUnionMember2")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "recursiveClassUnionMember2")
            }RdfClass`,
          ),
        },
      );
    }
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: RecursiveClassUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("recursiveClassUnionMember2");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "recursiveClassUnionMember2")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: RecursiveClassUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "recursiveClassUnionMember2")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            RecursiveClassUnionMember2.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "recursiveClassUnionMember2"),
        }),
      );
    }
    return patterns;
  }
}
export class RecursiveClassUnionMember1 {
  private _$identifier?: RecursiveClassUnionMember1.$Identifier;

  readonly $type: "RecursiveClassUnionMember1" =
    "RecursiveClassUnionMember1" as const;

  readonly recursiveClassUnionMember1Property: Maybe<RecursiveClassUnion>;

  constructor(parameters?: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly recursiveClassUnionMember1Property?:
      | Maybe<RecursiveClassUnion>
      | RecursiveClassUnion;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }
    if (Maybe.isMaybe(parameters?.recursiveClassUnionMember1Property)) {
      this.recursiveClassUnionMember1Property =
        parameters?.recursiveClassUnionMember1Property;
    } else if (
      typeof parameters?.recursiveClassUnionMember1Property === "object"
    ) {
      this.recursiveClassUnionMember1Property = Maybe.of(
        parameters?.recursiveClassUnionMember1Property,
      );
    } else if (
      typeof parameters?.recursiveClassUnionMember1Property === "undefined"
    ) {
      this.recursiveClassUnionMember1Property = Maybe.empty();
    } else {
      this.recursiveClassUnionMember1Property =
        parameters?.recursiveClassUnionMember1Property satisfies never;
    }
  }

  get $identifier(): RecursiveClassUnionMember1.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: RecursiveClassUnionMember1): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, RecursiveClassUnion.$equals))(
          this.recursiveClassUnionMember1Property,
          other.recursiveClassUnionMember1Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "recursiveClassUnionMember1Property",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    this.recursiveClassUnionMember1Property.ifJust((value0) => {
      RecursiveClassUnion.$hash(value0, _hasher);
    });
    return _hasher;
  }

  $toJson(): RecursiveClassUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        recursiveClassUnionMember1Property:
          this.recursiveClassUnionMember1Property
            .map((item) => RecursiveClassUnion.$toJson(item))
            .extract(),
      } satisfies RecursiveClassUnionMember1.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/RecursiveClassUnionMember1"),
        options?.graph,
      );
    }
    resource.add(
      RecursiveClassUnionMember1.$schema.properties
        .recursiveClassUnionMember1Property.identifier,
      this.recursiveClassUnionMember1Property.toList().flatMap((value) => [
        RecursiveClassUnion.$toRdf(value, {
          graph: options?.graph,
          resourceSet: resourceSet,
        }).identifier,
      ]),
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace RecursiveClassUnionMember1 {
  export function $filter(
    filter: RecursiveClassUnionMember1.$Filter,
    value: RecursiveClassUnionMember1,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.recursiveClassUnionMember1Property !== "undefined" &&
      !$filterMaybe<RecursiveClassUnion, RecursiveClassUnion.$Filter>(
        RecursiveClassUnion.$filter,
      )(
        filter.recursiveClassUnionMember1Property,
        value.recursiveClassUnionMember1Property,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly recursiveClassUnionMember1Property?: $MaybeFilter<RecursiveClassUnion.$Filter>;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/RecursiveClassUnionMember1",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      recursiveClassUnionMember1Property: Maybe<RecursiveClassUnion>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const recursiveClassUnionMember1Property = Maybe.fromNullable(
      $jsonObject["recursiveClassUnionMember1Property"],
    ).map((item) => RecursiveClassUnion.$fromJson(item).unsafeCoerce());
    return Either.of({ $identifier, recursiveClassUnionMember1Property });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, RecursiveClassUnionMember1> {
    return $propertiesFromJson(json).map(
      (properties) => new RecursiveClassUnionMember1(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "RecursiveClassUnionMember1" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/recursiveClassUnionMember1Property`,
          type: "Control",
        },
      ],
      label: "RecursiveClassUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("RecursiveClassUnionMember1"),
      recursiveClassUnionMember1Property: z
        .lazy(
          (): z.ZodType<RecursiveClassUnion.$Json> =>
            RecursiveClassUnion.$jsonZodSchema(),
        )
        .optional(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "RecursiveClassUnionMember1";
    readonly recursiveClassUnionMember1Property?:
      | RecursiveClassUnionMember1.$Json
      | RecursiveClassUnionMember2.$Json;
  };

  export function isRecursiveClassUnionMember1(
    object: $Object,
  ): object is RecursiveClassUnionMember1 {
    switch (object.$type) {
      case "RecursiveClassUnionMember1":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, RecursiveClassUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return RecursiveClassUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new RecursiveClassUnionMember1(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      recursiveClassUnionMember1Property: Maybe<RecursiveClassUnion>;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/RecursiveClassUnionMember1":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  RecursiveClassUnionMember1.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/RecursiveClassUnionMember1)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, RecursiveClassUnionMember1.$Identifier>(
        $parameters.resource
          .identifier as RecursiveClassUnionMember1.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.recursiveClassUnionMember1Property.identifier,
            {
              unique: true,
            },
          ),
        )
          .chain((values) =>
            values.chainMap((value) =>
              value.toResource().chain((resource) =>
                RecursiveClassUnion.$fromRdf(resource, {
                  context: $parameters.context,
                  ignoreRdfType: false,
                  objectSet: $parameters.objectSet,
                  preferredLanguages: $parameters.preferredLanguages,
                }),
              ),
            ),
          )
          .map((values) =>
            values.length > 0
              ? values.map((value) => Maybe.of(value))
              : Resource.Values.fromValue<Maybe<RecursiveClassUnion>>({
                  focusResource: $parameters.resource,
                  predicate:
                    RecursiveClassUnionMember1.$schema.properties
                      .recursiveClassUnionMember1Property.identifier,
                  value: Maybe.empty(),
                }),
          )
          .chain((values) => values.head())
          .map((recursiveClassUnionMember1Property) => ({
            $identifier,
            recursiveClassUnionMember1Property,
          })),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["RecursiveClassUnionMember1"],
        }),
      },
      recursiveClassUnionMember1Property: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => RecursiveClassUnion.$schema,
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/recursiveClassUnionMember1Property",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: RecursiveClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        RecursiveClassUnionMember1.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          RecursiveClassUnionMember1.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: RecursiveClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      RecursiveClassUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("recursiveClassUnionMember1");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "recursiveClassUnionMember1")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "recursiveClassUnionMember1")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "recursiveClassUnionMember1")
            }RdfClass`,
          ),
        },
      );
    }
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: RecursiveClassUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("recursiveClassUnionMember1");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "recursiveClassUnionMember1")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: RecursiveClassUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "recursiveClassUnionMember1")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            RecursiveClassUnionMember1.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "recursiveClassUnionMember1"),
        }),
      );
    }
    return patterns;
  }
} /**
 * Shape with properties that have visibility modifiers (private, protected, public)
 */

export class PropertyVisibilitiesClass {
  private _$identifier?: PropertyVisibilitiesClass.$Identifier;

  readonly $type: "PropertyVisibilitiesClass" =
    "PropertyVisibilitiesClass" as const;

  private readonly privateProperty: string;

  protected readonly protectedProperty: string;

  readonly publicProperty: string;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly privateProperty: string;
    readonly protectedProperty: string;
    readonly publicProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this.privateProperty = parameters.privateProperty;
    this.protectedProperty = parameters.protectedProperty;
    this.publicProperty = parameters.publicProperty;
  }

  get $identifier(): PropertyVisibilitiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: PropertyVisibilitiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.privateProperty, other.privateProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "privateProperty",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.protectedProperty, other.protectedProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "protectedProperty",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.publicProperty, other.publicProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "publicProperty",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.privateProperty);
    _hasher.update(this.protectedProperty);
    _hasher.update(this.publicProperty);
    return _hasher;
  }

  $toJson(): PropertyVisibilitiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        privateProperty: this.privateProperty,
        protectedProperty: this.protectedProperty,
        publicProperty: this.publicProperty,
      } satisfies PropertyVisibilitiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    resource.add(
      PropertyVisibilitiesClass.$schema.properties.privateProperty.identifier,
      [$literalFactory.string(this.privateProperty)],
      options?.graph,
    );
    resource.add(
      PropertyVisibilitiesClass.$schema.properties.protectedProperty.identifier,
      [$literalFactory.string(this.protectedProperty)],
      options?.graph,
    );
    resource.add(
      PropertyVisibilitiesClass.$schema.properties.publicProperty.identifier,
      [$literalFactory.string(this.publicProperty)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PropertyVisibilitiesClass {
  export function $filter(
    filter: PropertyVisibilitiesClass.$Filter,
    value: PropertyVisibilitiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.publicProperty !== "undefined" &&
      !$filterString(filter.publicProperty, value.publicProperty)
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly publicProperty?: $StringFilter;
  };

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      privateProperty: string;
      protectedProperty: string;
      publicProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const privateProperty = $jsonObject["privateProperty"];
    const protectedProperty = $jsonObject["protectedProperty"];
    const publicProperty = $jsonObject["publicProperty"];
    return Either.of({
      $identifier,
      privateProperty,
      protectedProperty,
      publicProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, PropertyVisibilitiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new PropertyVisibilitiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PropertyVisibilitiesClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/privateProperty`, type: "Control" },
        {
          scope: `${scopePrefix}/properties/protectedProperty`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/publicProperty`, type: "Control" },
      ],
      label: "PropertyVisibilitiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("PropertyVisibilitiesClass"),
      privateProperty: z.string(),
      protectedProperty: z.string(),
      publicProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PropertyVisibilitiesClass";
    readonly privateProperty: string;
    readonly protectedProperty: string;
    readonly publicProperty: string;
  };

  export function isPropertyVisibilitiesClass(
    object: $Object,
  ): object is PropertyVisibilitiesClass {
    switch (object.$type) {
      case "PropertyVisibilitiesClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, PropertyVisibilitiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return PropertyVisibilitiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new PropertyVisibilitiesClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      privateProperty: string;
      protectedProperty: string;
      publicProperty: string;
    }
  > {
    return Either.of<Error, PropertyVisibilitiesClass.$Identifier>(
      $parameters.resource.identifier as PropertyVisibilitiesClass.$Identifier,
    ).chain(($identifier) =>
      Either.of<Error, Resource.Values<Resource.TermValue>>(
        $parameters.resource.values(
          $schema.properties.privateProperty.identifier,
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              PropertyVisibilitiesClass.$schema.properties.privateProperty
                .identifier,
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .chain((privateProperty) =>
          Either.of<Error, Resource.Values<Resource.TermValue>>(
            $parameters.resource.values(
              $schema.properties.protectedProperty.identifier,
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  PropertyVisibilitiesClass.$schema.properties.protectedProperty
                    .identifier,
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .chain((protectedProperty) =>
              Either.of<Error, Resource.Values<Resource.TermValue>>(
                $parameters.resource.values(
                  $schema.properties.publicProperty.identifier,
                  { unique: true },
                ),
              )
                .chain((values) =>
                  $fromRdfPreferredLanguages({
                    focusResource: $parameters.resource,
                    predicate:
                      PropertyVisibilitiesClass.$schema.properties
                        .publicProperty.identifier,
                    preferredLanguages: $parameters.preferredLanguages,
                    values,
                  }),
                )
                .chain((values) => values.chainMap((value) => value.toString()))
                .chain((values) => values.head())
                .map((publicProperty) => ({
                  $identifier,
                  privateProperty,
                  protectedProperty,
                  publicProperty,
                })),
            ),
        ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["PropertyVisibilitiesClass"],
        }),
      },
      privateProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode("http://example.com/privateProperty"),
      },
      protectedProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/protectedProperty",
        ),
      },
      publicProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode("http://example.com/publicProperty"),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PropertyVisibilitiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PropertyVisibilitiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          PropertyVisibilitiesClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PropertyVisibilitiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PropertyVisibilitiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("propertyVisibilitiesClass");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "propertyVisibilitiesClass")
          }PrivateProperty`,
        ),
        predicate:
          PropertyVisibilitiesClass.$schema.properties.privateProperty
            .identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "propertyVisibilitiesClass")
          }ProtectedProperty`,
        ),
        predicate:
          PropertyVisibilitiesClass.$schema.properties.protectedProperty
            .identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "propertyVisibilitiesClass")
          }PublicProperty`,
        ),
        predicate:
          PropertyVisibilitiesClass.$schema.properties.publicProperty
            .identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PropertyVisibilitiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("propertyVisibilitiesClass");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            PropertyVisibilitiesClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "propertyVisibilitiesClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: undefined,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "propertyVisibilitiesClass")
                  }PrivateProperty`,
                ),
                predicate:
                  PropertyVisibilitiesClass.$schema.properties.privateProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          PropertyVisibilitiesClass.$schema.properties.privateProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "propertyVisibilitiesClass")
          }PrivateProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "propertyVisibilitiesClass")
        }PrivateProperty`,
      }),
    );
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: undefined,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "propertyVisibilitiesClass")
                  }ProtectedProperty`,
                ),
                predicate:
                  PropertyVisibilitiesClass.$schema.properties.protectedProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          PropertyVisibilitiesClass.$schema.properties.protectedProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "propertyVisibilitiesClass")
          }ProtectedProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "propertyVisibilitiesClass")
        }ProtectedProperty`,
      }),
    );
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.publicProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "propertyVisibilitiesClass")
                  }PublicProperty`,
                ),
                predicate:
                  PropertyVisibilitiesClass.$schema.properties.publicProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          PropertyVisibilitiesClass.$schema.properties.publicProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "propertyVisibilitiesClass")
          }PublicProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "propertyVisibilitiesClass")
        }PublicProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Shape that has properties with different cardinalities
 */

export class PropertyCardinalitiesClass {
  private _$identifier?: PropertyCardinalitiesClass.$Identifier;

  readonly $type: "PropertyCardinalitiesClass" =
    "PropertyCardinalitiesClass" as const;

  /**
   * Set: minCount implicitly=0, no maxCount
   */
  readonly emptyStringSetProperty: readonly string[];

  /**
   * Set: minCount=1, no maxCount
   */
  readonly nonEmptyStringSetProperty: NonEmptyList<string>;

  /**
   * Option: maxCount=1, minCount=0
   */
  readonly optionalStringProperty: Maybe<string>;

  /**
   * Required: maxCount=minCount=1
   */
  readonly requiredStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly emptyStringSetProperty?: readonly string[];
    readonly nonEmptyStringSetProperty: NonEmptyList<string>;
    readonly optionalStringProperty?: Maybe<string> | string;
    readonly requiredStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    if (typeof parameters.emptyStringSetProperty === "undefined") {
      this.emptyStringSetProperty = [];
    } else if (typeof parameters.emptyStringSetProperty === "object") {
      this.emptyStringSetProperty = parameters.emptyStringSetProperty;
    } else {
      this.emptyStringSetProperty =
        parameters.emptyStringSetProperty satisfies never;
    }
    this.nonEmptyStringSetProperty = parameters.nonEmptyStringSetProperty;
    if (Maybe.isMaybe(parameters.optionalStringProperty)) {
      this.optionalStringProperty = parameters.optionalStringProperty;
    } else if (typeof parameters.optionalStringProperty === "string") {
      this.optionalStringProperty = Maybe.of(parameters.optionalStringProperty);
    } else if (typeof parameters.optionalStringProperty === "undefined") {
      this.optionalStringProperty = Maybe.empty();
    } else {
      this.optionalStringProperty =
        parameters.optionalStringProperty satisfies never;
    }
    this.requiredStringProperty = parameters.requiredStringProperty;
  }

  get $identifier(): PropertyCardinalitiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: PropertyCardinalitiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $strictEquals))(
          this.emptyStringSetProperty,
          other.emptyStringSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "emptyStringSetProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $strictEquals))(
          this.nonEmptyStringSetProperty,
          other.nonEmptyStringSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "nonEmptyStringSetProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.optionalStringProperty,
          other.optionalStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.requiredStringProperty,
          other.requiredStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "requiredStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    for (const item0 of this.emptyStringSetProperty) {
      _hasher.update(item0);
    }
    for (const item0 of this.nonEmptyStringSetProperty) {
      _hasher.update(item0);
    }
    this.optionalStringProperty.ifJust((value0) => {
      _hasher.update(value0);
    });
    _hasher.update(this.requiredStringProperty);
    return _hasher;
  }

  $toJson(): PropertyCardinalitiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        emptyStringSetProperty: this.emptyStringSetProperty.map((item) => item),
        nonEmptyStringSetProperty: this.nonEmptyStringSetProperty.map(
          (item) => item,
        ),
        optionalStringProperty: this.optionalStringProperty
          .map((item) => item)
          .extract(),
        requiredStringProperty: this.requiredStringProperty,
      } satisfies PropertyCardinalitiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    resource.add(
      PropertyCardinalitiesClass.$schema.properties.emptyStringSetProperty
        .identifier,
      this.emptyStringSetProperty.flatMap((item) => [
        $literalFactory.string(item),
      ]),
      options?.graph,
    );
    resource.add(
      PropertyCardinalitiesClass.$schema.properties.nonEmptyStringSetProperty
        .identifier,
      this.nonEmptyStringSetProperty.flatMap((item) => [
        $literalFactory.string(item),
      ]),
      options?.graph,
    );
    resource.add(
      PropertyCardinalitiesClass.$schema.properties.optionalStringProperty
        .identifier,
      this.optionalStringProperty
        .toList()
        .flatMap((value) => [$literalFactory.string(value)]),
      options?.graph,
    );
    resource.add(
      PropertyCardinalitiesClass.$schema.properties.requiredStringProperty
        .identifier,
      [$literalFactory.string(this.requiredStringProperty)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PropertyCardinalitiesClass {
  export function $filter(
    filter: PropertyCardinalitiesClass.$Filter,
    value: PropertyCardinalitiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.emptyStringSetProperty !== "undefined" &&
      !$filterArray<string, $StringFilter>($filterString)(
        filter.emptyStringSetProperty,
        value.emptyStringSetProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.nonEmptyStringSetProperty !== "undefined" &&
      !$filterArray<string, $StringFilter>($filterString)(
        filter.nonEmptyStringSetProperty,
        value.nonEmptyStringSetProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.optionalStringProperty !== "undefined" &&
      !$filterMaybe<string, $StringFilter>($filterString)(
        filter.optionalStringProperty,
        value.optionalStringProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.requiredStringProperty !== "undefined" &&
      !$filterString(
        filter.requiredStringProperty,
        value.requiredStringProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly emptyStringSetProperty?: $CollectionFilter<$StringFilter>;
    readonly nonEmptyStringSetProperty?: $CollectionFilter<$StringFilter>;
    readonly optionalStringProperty?: $MaybeFilter<$StringFilter>;
    readonly requiredStringProperty?: $StringFilter;
  };

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      emptyStringSetProperty: readonly string[];
      nonEmptyStringSetProperty: NonEmptyList<string>;
      optionalStringProperty: Maybe<string>;
      requiredStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const emptyStringSetProperty = $jsonObject["emptyStringSetProperty"];
    const nonEmptyStringSetProperty = NonEmptyList.fromArray(
      $jsonObject["nonEmptyStringSetProperty"],
    ).unsafeCoerce();
    const optionalStringProperty = Maybe.fromNullable(
      $jsonObject["optionalStringProperty"],
    );
    const requiredStringProperty = $jsonObject["requiredStringProperty"];
    return Either.of({
      $identifier,
      emptyStringSetProperty,
      nonEmptyStringSetProperty,
      optionalStringProperty,
      requiredStringProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, PropertyCardinalitiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new PropertyCardinalitiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PropertyCardinalitiesClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/emptyStringSetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/nonEmptyStringSetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/optionalStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/requiredStringProperty`,
          type: "Control",
        },
      ],
      label: "PropertyCardinalitiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("PropertyCardinalitiesClass"),
      emptyStringSetProperty: z
        .string()
        .array()
        .default(() => [])
        .describe("Set: minCount implicitly=0, no maxCount"),
      nonEmptyStringSetProperty: z
        .string()
        .array()
        .nonempty()
        .min(1)
        .describe("Set: minCount=1, no maxCount"),
      optionalStringProperty: z
        .string()
        .optional()
        .describe("Option: maxCount=1, minCount=0"),
      requiredStringProperty: z
        .string()
        .describe("Required: maxCount=minCount=1"),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PropertyCardinalitiesClass";
    readonly emptyStringSetProperty?: readonly string[];
    readonly nonEmptyStringSetProperty: readonly string[];
    readonly optionalStringProperty?: string;
    readonly requiredStringProperty: string;
  };

  export function isPropertyCardinalitiesClass(
    object: $Object,
  ): object is PropertyCardinalitiesClass {
    switch (object.$type) {
      case "PropertyCardinalitiesClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, PropertyCardinalitiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return PropertyCardinalitiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new PropertyCardinalitiesClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      emptyStringSetProperty: readonly string[];
      nonEmptyStringSetProperty: NonEmptyList<string>;
      optionalStringProperty: Maybe<string>;
      requiredStringProperty: string;
    }
  > {
    return Either.of<Error, PropertyCardinalitiesClass.$Identifier>(
      $parameters.resource.identifier as PropertyCardinalitiesClass.$Identifier,
    ).chain(($identifier) =>
      Either.of<Error, Resource.Values<Resource.TermValue>>(
        $parameters.resource.values(
          $schema.properties.emptyStringSetProperty.identifier,
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              PropertyCardinalitiesClass.$schema.properties
                .emptyStringSetProperty.identifier,
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .map((values) => values.toArray())
        .map((valuesArray) =>
          Resource.Values.fromValue({
            focusResource: $parameters.resource,
            predicate:
              PropertyCardinalitiesClass.$schema.properties
                .emptyStringSetProperty.identifier,
            value: valuesArray,
          }),
        )
        .chain((values) => values.head())
        .chain((emptyStringSetProperty) =>
          Either.of<Error, Resource.Values<Resource.TermValue>>(
            $parameters.resource.values(
              $schema.properties.nonEmptyStringSetProperty.identifier,
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  PropertyCardinalitiesClass.$schema.properties
                    .nonEmptyStringSetProperty.identifier,
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) =>
              NonEmptyList.fromArray(values.toArray()).toEither(
                new Error(
                  `${Resource.Identifier.toString($parameters.resource.identifier)} is an empty set`,
                ),
              ),
            )
            .map((valuesArray) =>
              Resource.Values.fromValue({
                focusResource: $parameters.resource,
                predicate:
                  PropertyCardinalitiesClass.$schema.properties
                    .nonEmptyStringSetProperty.identifier,
                value: valuesArray,
              }),
            )
            .chain((values) => values.head())
            .chain((nonEmptyStringSetProperty) =>
              Either.of<Error, Resource.Values<Resource.TermValue>>(
                $parameters.resource.values(
                  $schema.properties.optionalStringProperty.identifier,
                  { unique: true },
                ),
              )
                .chain((values) =>
                  $fromRdfPreferredLanguages({
                    focusResource: $parameters.resource,
                    predicate:
                      PropertyCardinalitiesClass.$schema.properties
                        .optionalStringProperty.identifier,
                    preferredLanguages: $parameters.preferredLanguages,
                    values,
                  }),
                )
                .chain((values) => values.chainMap((value) => value.toString()))
                .map((values) =>
                  values.length > 0
                    ? values.map((value) => Maybe.of(value))
                    : Resource.Values.fromValue<Maybe<string>>({
                        focusResource: $parameters.resource,
                        predicate:
                          PropertyCardinalitiesClass.$schema.properties
                            .optionalStringProperty.identifier,
                        value: Maybe.empty(),
                      }),
                )
                .chain((values) => values.head())
                .chain((optionalStringProperty) =>
                  Either.of<Error, Resource.Values<Resource.TermValue>>(
                    $parameters.resource.values(
                      $schema.properties.requiredStringProperty.identifier,
                      { unique: true },
                    ),
                  )
                    .chain((values) =>
                      $fromRdfPreferredLanguages({
                        focusResource: $parameters.resource,
                        predicate:
                          PropertyCardinalitiesClass.$schema.properties
                            .requiredStringProperty.identifier,
                        preferredLanguages: $parameters.preferredLanguages,
                        values,
                      }),
                    )
                    .chain((values) =>
                      values.chainMap((value) => value.toString()),
                    )
                    .chain((values) => values.head())
                    .map((requiredStringProperty) => ({
                      $identifier,
                      emptyStringSetProperty,
                      nonEmptyStringSetProperty,
                      optionalStringProperty,
                      requiredStringProperty,
                    })),
                ),
            ),
        ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["PropertyCardinalitiesClass"],
        }),
      },
      emptyStringSetProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Set" as const,
          item: () => ({ kind: "String" as const }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/emptyStringSetProperty",
        ),
      },
      nonEmptyStringSetProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Set" as const,
          item: () => ({ kind: "String" as const }),
          minCount: 1,
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/nonEmptyStringSetProperty",
        ),
      },
      optionalStringProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({ kind: "String" as const }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/optionalStringProperty",
        ),
      },
      requiredStringProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/requiredStringProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PropertyCardinalitiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PropertyCardinalitiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          PropertyCardinalitiesClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PropertyCardinalitiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PropertyCardinalitiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("propertyCardinalitiesClass");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "propertyCardinalitiesClass")
          }EmptyStringSetProperty`,
        ),
        predicate:
          PropertyCardinalitiesClass.$schema.properties.emptyStringSetProperty
            .identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "propertyCardinalitiesClass")
          }NonEmptyStringSetProperty`,
        ),
        predicate:
          PropertyCardinalitiesClass.$schema.properties
            .nonEmptyStringSetProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "propertyCardinalitiesClass")
          }OptionalStringProperty`,
        ),
        predicate:
          PropertyCardinalitiesClass.$schema.properties.optionalStringProperty
            .identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "propertyCardinalitiesClass")
          }RequiredStringProperty`,
        ),
        predicate:
          PropertyCardinalitiesClass.$schema.properties.requiredStringProperty
            .identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PropertyCardinalitiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("propertyCardinalitiesClass");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            PropertyCardinalitiesClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "propertyCardinalitiesClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $setSparqlWherePatterns<$StringFilter, $StringSchema>(
        $stringSparqlWherePatterns,
      )({
        filter: parameters?.filter?.emptyStringSetProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "propertyCardinalitiesClass")
                  }EmptyStringSetProperty`,
                ),
                predicate:
                  PropertyCardinalitiesClass.$schema.properties
                    .emptyStringSetProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          PropertyCardinalitiesClass.$schema.properties.emptyStringSetProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "propertyCardinalitiesClass")
          }EmptyStringSetProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "propertyCardinalitiesClass")
        }EmptyStringSetProperty`,
      }),
    );
    patterns = patterns.concat(
      $setSparqlWherePatterns<$StringFilter, $StringSchema>(
        $stringSparqlWherePatterns,
      )({
        filter: parameters?.filter?.nonEmptyStringSetProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "propertyCardinalitiesClass")
                  }NonEmptyStringSetProperty`,
                ),
                predicate:
                  PropertyCardinalitiesClass.$schema.properties
                    .nonEmptyStringSetProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          PropertyCardinalitiesClass.$schema.properties.nonEmptyStringSetProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "propertyCardinalitiesClass")
          }NonEmptyStringSetProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "propertyCardinalitiesClass")
        }NonEmptyStringSetProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<$StringFilter, $StringSchema>(
        $stringSparqlWherePatterns,
      )({
        filter: parameters?.filter?.optionalStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "propertyCardinalitiesClass")
                  }OptionalStringProperty`,
                ),
                predicate:
                  PropertyCardinalitiesClass.$schema.properties
                    .optionalStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          PropertyCardinalitiesClass.$schema.properties.optionalStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "propertyCardinalitiesClass")
          }OptionalStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "propertyCardinalitiesClass")
        }OptionalStringProperty`,
      }),
    );
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.requiredStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "propertyCardinalitiesClass")
                  }RequiredStringProperty`,
                ),
                predicate:
                  PropertyCardinalitiesClass.$schema.properties
                    .requiredStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          PropertyCardinalitiesClass.$schema.properties.requiredStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "propertyCardinalitiesClass")
          }RequiredStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "propertyCardinalitiesClass")
        }RequiredStringProperty`,
      }),
    );
    return patterns;
  }
}
export interface PartialInterfaceUnionMember2 {
  readonly $identifier: PartialInterfaceUnionMember2.$Identifier;
  readonly $type: "PartialInterfaceUnionMember2";
  readonly lazilyResolvedStringProperty: string;
}

export namespace PartialInterfaceUnionMember2 {
  export function $create(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): PartialInterfaceUnionMember2 {
    let $identifier: PartialInterfaceUnionMember2.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }
    const $type = "PartialInterfaceUnionMember2" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: PartialInterfaceUnionMember2,
    right: PartialInterfaceUnionMember2,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  export function $hash<HasherT extends $Hasher>(
    _partialInterfaceUnionMember2: PartialInterfaceUnionMember2,
    _hasher: HasherT,
  ): HasherT {
    PartialInterfaceUnionMember2.$hashShaclProperties(
      _partialInterfaceUnionMember2,
      _hasher,
    );
    _hasher.update(_partialInterfaceUnionMember2.$identifier.value);
    _hasher.update(_partialInterfaceUnionMember2.$type);
    return _hasher;
  }

  export function $hashShaclProperties<HasherT extends $Hasher>(
    _partialInterfaceUnionMember2: PartialInterfaceUnionMember2,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_partialInterfaceUnionMember2.lazilyResolvedStringProperty);
    return _hasher;
  }

  export function $filter(
    filter: PartialInterfaceUnionMember2.$Filter,
    value: PartialInterfaceUnionMember2,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/PartialInterfaceUnionMember2",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      $type: "PartialInterfaceUnionMember2";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "PartialInterfaceUnionMember2" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return Either.of({ $identifier, $type, lazilyResolvedStringProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, PartialInterfaceUnionMember2> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialInterfaceUnionMember2" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialInterfaceUnionMember2",
      type: "Group",
    };
  }

  export function $toJson(
    _partialInterfaceUnionMember2: PartialInterfaceUnionMember2,
  ): PartialInterfaceUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _partialInterfaceUnionMember2.$identifier.termType === "BlankNode"
            ? `_:${_partialInterfaceUnionMember2.$identifier.value}`
            : _partialInterfaceUnionMember2.$identifier.value,
        $type: _partialInterfaceUnionMember2.$type,
        lazilyResolvedStringProperty:
          _partialInterfaceUnionMember2.lazilyResolvedStringProperty,
      } satisfies PartialInterfaceUnionMember2.$Json),
    );
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("PartialInterfaceUnionMember2"),
      lazilyResolvedStringProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialInterfaceUnionMember2";
    readonly lazilyResolvedStringProperty: string;
  };

  export function isPartialInterfaceUnionMember2(
    object: $Object,
  ): object is PartialInterfaceUnionMember2 {
    switch (object.$type) {
      case "PartialInterfaceUnionMember2":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, PartialInterfaceUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return PartialInterfaceUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      $type: "PartialInterfaceUnionMember2";
      lazilyResolvedStringProperty: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/PartialInterfaceUnionMember2":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  PartialInterfaceUnionMember2.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/PartialInterfaceUnionMember2)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, PartialInterfaceUnionMember2.$Identifier>(
        $parameters.resource
          .identifier as PartialInterfaceUnionMember2.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, "PartialInterfaceUnionMember2">(
          "PartialInterfaceUnionMember2" as const,
        ).chain(($type) =>
          Either.of<Error, Resource.Values<Resource.TermValue>>(
            $parameters.resource.values(
              $schema.properties.lazilyResolvedStringProperty.identifier,
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  PartialInterfaceUnionMember2.$schema.properties
                    .lazilyResolvedStringProperty.identifier,
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((lazilyResolvedStringProperty) => ({
              $identifier,
              $type,
              lazilyResolvedStringProperty,
            })),
        ),
      ),
    );
  }

  export function $toRdf(
    _partialInterfaceUnionMember2: PartialInterfaceUnionMember2,
    options?: {
      ignoreRdfType?: boolean;
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(
      _partialInterfaceUnionMember2.$identifier,
    );
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode(
          "http://example.com/PartialInterfaceUnionMember2",
        ),
        options?.graph,
      );
    }
    resource.add(
      PartialInterfaceUnionMember2.$schema.properties
        .lazilyResolvedStringProperty.identifier,
      [
        $literalFactory.string(
          _partialInterfaceUnionMember2.lazilyResolvedStringProperty,
        ),
      ],
      options?.graph,
    );
    return resource;
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["PartialInterfaceUnionMember2"],
        }),
      },
      lazilyResolvedStringProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/lazilyResolvedStringProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialInterfaceUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialInterfaceUnionMember2.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          PartialInterfaceUnionMember2.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialInterfaceUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialInterfaceUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("partialInterfaceUnionMember2");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "partialInterfaceUnionMember2")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "partialInterfaceUnionMember2")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "partialInterfaceUnionMember2")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "partialInterfaceUnionMember2")
          }LazilyResolvedStringProperty`,
        ),
        predicate:
          PartialInterfaceUnionMember2.$schema.properties
            .lazilyResolvedStringProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialInterfaceUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("partialInterfaceUnionMember2");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "partialInterfaceUnionMember2")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: PartialInterfaceUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "partialInterfaceUnionMember2")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            PartialInterfaceUnionMember2.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "partialInterfaceUnionMember2"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.lazilyResolvedStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "partialInterfaceUnionMember2")
                  }LazilyResolvedStringProperty`,
                ),
                predicate:
                  PartialInterfaceUnionMember2.$schema.properties
                    .lazilyResolvedStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          PartialInterfaceUnionMember2.$schema.properties.lazilyResolvedStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "partialInterfaceUnionMember2")
          }LazilyResolvedStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "partialInterfaceUnionMember2")
        }LazilyResolvedStringProperty`,
      }),
    );
    return patterns;
  }
}
export interface PartialInterfaceUnionMember1 {
  readonly $identifier: PartialInterfaceUnionMember1.$Identifier;
  readonly $type: "PartialInterfaceUnionMember1";
  readonly lazilyResolvedStringProperty: string;
}

export namespace PartialInterfaceUnionMember1 {
  export function $create(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): PartialInterfaceUnionMember1 {
    let $identifier: PartialInterfaceUnionMember1.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }
    const $type = "PartialInterfaceUnionMember1" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: PartialInterfaceUnionMember1,
    right: PartialInterfaceUnionMember1,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  export function $hash<HasherT extends $Hasher>(
    _partialInterfaceUnionMember1: PartialInterfaceUnionMember1,
    _hasher: HasherT,
  ): HasherT {
    PartialInterfaceUnionMember1.$hashShaclProperties(
      _partialInterfaceUnionMember1,
      _hasher,
    );
    _hasher.update(_partialInterfaceUnionMember1.$identifier.value);
    _hasher.update(_partialInterfaceUnionMember1.$type);
    return _hasher;
  }

  export function $hashShaclProperties<HasherT extends $Hasher>(
    _partialInterfaceUnionMember1: PartialInterfaceUnionMember1,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_partialInterfaceUnionMember1.lazilyResolvedStringProperty);
    return _hasher;
  }

  export function $filter(
    filter: PartialInterfaceUnionMember1.$Filter,
    value: PartialInterfaceUnionMember1,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/PartialInterfaceUnionMember1",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      $type: "PartialInterfaceUnionMember1";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "PartialInterfaceUnionMember1" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return Either.of({ $identifier, $type, lazilyResolvedStringProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, PartialInterfaceUnionMember1> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialInterfaceUnionMember1" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialInterfaceUnionMember1",
      type: "Group",
    };
  }

  export function $toJson(
    _partialInterfaceUnionMember1: PartialInterfaceUnionMember1,
  ): PartialInterfaceUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _partialInterfaceUnionMember1.$identifier.termType === "BlankNode"
            ? `_:${_partialInterfaceUnionMember1.$identifier.value}`
            : _partialInterfaceUnionMember1.$identifier.value,
        $type: _partialInterfaceUnionMember1.$type,
        lazilyResolvedStringProperty:
          _partialInterfaceUnionMember1.lazilyResolvedStringProperty,
      } satisfies PartialInterfaceUnionMember1.$Json),
    );
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("PartialInterfaceUnionMember1"),
      lazilyResolvedStringProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialInterfaceUnionMember1";
    readonly lazilyResolvedStringProperty: string;
  };

  export function isPartialInterfaceUnionMember1(
    object: $Object,
  ): object is PartialInterfaceUnionMember1 {
    switch (object.$type) {
      case "PartialInterfaceUnionMember1":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, PartialInterfaceUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return PartialInterfaceUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      $type: "PartialInterfaceUnionMember1";
      lazilyResolvedStringProperty: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/PartialInterfaceUnionMember1":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  PartialInterfaceUnionMember1.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/PartialInterfaceUnionMember1)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, PartialInterfaceUnionMember1.$Identifier>(
        $parameters.resource
          .identifier as PartialInterfaceUnionMember1.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, "PartialInterfaceUnionMember1">(
          "PartialInterfaceUnionMember1" as const,
        ).chain(($type) =>
          Either.of<Error, Resource.Values<Resource.TermValue>>(
            $parameters.resource.values(
              $schema.properties.lazilyResolvedStringProperty.identifier,
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  PartialInterfaceUnionMember1.$schema.properties
                    .lazilyResolvedStringProperty.identifier,
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((lazilyResolvedStringProperty) => ({
              $identifier,
              $type,
              lazilyResolvedStringProperty,
            })),
        ),
      ),
    );
  }

  export function $toRdf(
    _partialInterfaceUnionMember1: PartialInterfaceUnionMember1,
    options?: {
      ignoreRdfType?: boolean;
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(
      _partialInterfaceUnionMember1.$identifier,
    );
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode(
          "http://example.com/PartialInterfaceUnionMember1",
        ),
        options?.graph,
      );
    }
    resource.add(
      PartialInterfaceUnionMember1.$schema.properties
        .lazilyResolvedStringProperty.identifier,
      [
        $literalFactory.string(
          _partialInterfaceUnionMember1.lazilyResolvedStringProperty,
        ),
      ],
      options?.graph,
    );
    return resource;
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["PartialInterfaceUnionMember1"],
        }),
      },
      lazilyResolvedStringProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/lazilyResolvedStringProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialInterfaceUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialInterfaceUnionMember1.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          PartialInterfaceUnionMember1.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialInterfaceUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialInterfaceUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("partialInterfaceUnionMember1");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "partialInterfaceUnionMember1")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "partialInterfaceUnionMember1")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "partialInterfaceUnionMember1")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "partialInterfaceUnionMember1")
          }LazilyResolvedStringProperty`,
        ),
        predicate:
          PartialInterfaceUnionMember1.$schema.properties
            .lazilyResolvedStringProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialInterfaceUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("partialInterfaceUnionMember1");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "partialInterfaceUnionMember1")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: PartialInterfaceUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "partialInterfaceUnionMember1")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            PartialInterfaceUnionMember1.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "partialInterfaceUnionMember1"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.lazilyResolvedStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "partialInterfaceUnionMember1")
                  }LazilyResolvedStringProperty`,
                ),
                predicate:
                  PartialInterfaceUnionMember1.$schema.properties
                    .lazilyResolvedStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          PartialInterfaceUnionMember1.$schema.properties.lazilyResolvedStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "partialInterfaceUnionMember1")
          }LazilyResolvedStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "partialInterfaceUnionMember1")
        }LazilyResolvedStringProperty`,
      }),
    );
    return patterns;
  }
}
export class PartialClassUnionMember2 {
  private _$identifier?: PartialClassUnionMember2.$Identifier;

  readonly $type: "PartialClassUnionMember2" =
    "PartialClassUnionMember2" as const;

  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): PartialClassUnionMember2.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: PartialClassUnionMember2): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): PartialClassUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies PartialClassUnionMember2.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/PartialClassUnionMember2"),
        options?.graph,
      );
    }
    resource.add(
      PartialClassUnionMember2.$schema.properties.lazilyResolvedStringProperty
        .identifier,
      [$literalFactory.string(this.lazilyResolvedStringProperty)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PartialClassUnionMember2 {
  export function $filter(
    filter: PartialClassUnionMember2.$Filter,
    value: PartialClassUnionMember2,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/PartialClassUnionMember2",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<
    z.ZodError,
    { $identifier: BlankNode | NamedNode; lazilyResolvedStringProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, PartialClassUnionMember2> {
    return $propertiesFromJson(json).map(
      (properties) => new PartialClassUnionMember2(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialClassUnionMember2" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialClassUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("PartialClassUnionMember2"),
      lazilyResolvedStringProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialClassUnionMember2";
    readonly lazilyResolvedStringProperty: string;
  };

  export function isPartialClassUnionMember2(
    object: $Object,
  ): object is PartialClassUnionMember2 {
    switch (object.$type) {
      case "PartialClassUnionMember2":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, PartialClassUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return PartialClassUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new PartialClassUnionMember2(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    { $identifier: BlankNode | NamedNode; lazilyResolvedStringProperty: string }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/PartialClassUnionMember2":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  PartialClassUnionMember2.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/PartialClassUnionMember2)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, PartialClassUnionMember2.$Identifier>(
        $parameters.resource.identifier as PartialClassUnionMember2.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.lazilyResolvedStringProperty.identifier,
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                PartialClassUnionMember2.$schema.properties
                  .lazilyResolvedStringProperty.identifier,
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((lazilyResolvedStringProperty) => ({
            $identifier,
            lazilyResolvedStringProperty,
          })),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["PartialClassUnionMember2"],
        }),
      },
      lazilyResolvedStringProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/lazilyResolvedStringProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialClassUnionMember2.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          PartialClassUnionMember2.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialClassUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClassUnionMember2");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "partialClassUnionMember2")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "partialClassUnionMember2")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "partialClassUnionMember2")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "partialClassUnionMember2")
          }LazilyResolvedStringProperty`,
        ),
        predicate:
          PartialClassUnionMember2.$schema.properties
            .lazilyResolvedStringProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialClassUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClassUnionMember2");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "partialClassUnionMember2")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: PartialClassUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "partialClassUnionMember2")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            PartialClassUnionMember2.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "partialClassUnionMember2"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.lazilyResolvedStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "partialClassUnionMember2")
                  }LazilyResolvedStringProperty`,
                ),
                predicate:
                  PartialClassUnionMember2.$schema.properties
                    .lazilyResolvedStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          PartialClassUnionMember2.$schema.properties.lazilyResolvedStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "partialClassUnionMember2")
          }LazilyResolvedStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "partialClassUnionMember2")
        }LazilyResolvedStringProperty`,
      }),
    );
    return patterns;
  }
}
export class PartialClassUnionMember1 {
  private _$identifier?: PartialClassUnionMember1.$Identifier;

  readonly $type: "PartialClassUnionMember1" =
    "PartialClassUnionMember1" as const;

  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): PartialClassUnionMember1.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: PartialClassUnionMember1): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): PartialClassUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies PartialClassUnionMember1.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/PartialClassUnionMember1"),
        options?.graph,
      );
    }
    resource.add(
      PartialClassUnionMember1.$schema.properties.lazilyResolvedStringProperty
        .identifier,
      [$literalFactory.string(this.lazilyResolvedStringProperty)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PartialClassUnionMember1 {
  export function $filter(
    filter: PartialClassUnionMember1.$Filter,
    value: PartialClassUnionMember1,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/PartialClassUnionMember1",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<
    z.ZodError,
    { $identifier: BlankNode | NamedNode; lazilyResolvedStringProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, PartialClassUnionMember1> {
    return $propertiesFromJson(json).map(
      (properties) => new PartialClassUnionMember1(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialClassUnionMember1" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialClassUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("PartialClassUnionMember1"),
      lazilyResolvedStringProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialClassUnionMember1";
    readonly lazilyResolvedStringProperty: string;
  };

  export function isPartialClassUnionMember1(
    object: $Object,
  ): object is PartialClassUnionMember1 {
    switch (object.$type) {
      case "PartialClassUnionMember1":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, PartialClassUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return PartialClassUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new PartialClassUnionMember1(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    { $identifier: BlankNode | NamedNode; lazilyResolvedStringProperty: string }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/PartialClassUnionMember1":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  PartialClassUnionMember1.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/PartialClassUnionMember1)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, PartialClassUnionMember1.$Identifier>(
        $parameters.resource.identifier as PartialClassUnionMember1.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.lazilyResolvedStringProperty.identifier,
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                PartialClassUnionMember1.$schema.properties
                  .lazilyResolvedStringProperty.identifier,
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((lazilyResolvedStringProperty) => ({
            $identifier,
            lazilyResolvedStringProperty,
          })),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["PartialClassUnionMember1"],
        }),
      },
      lazilyResolvedStringProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/lazilyResolvedStringProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialClassUnionMember1.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          PartialClassUnionMember1.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialClassUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClassUnionMember1");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "partialClassUnionMember1")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "partialClassUnionMember1")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "partialClassUnionMember1")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "partialClassUnionMember1")
          }LazilyResolvedStringProperty`,
        ),
        predicate:
          PartialClassUnionMember1.$schema.properties
            .lazilyResolvedStringProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialClassUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClassUnionMember1");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "partialClassUnionMember1")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: PartialClassUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "partialClassUnionMember1")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            PartialClassUnionMember1.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "partialClassUnionMember1"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.lazilyResolvedStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "partialClassUnionMember1")
                  }LazilyResolvedStringProperty`,
                ),
                predicate:
                  PartialClassUnionMember1.$schema.properties
                    .lazilyResolvedStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          PartialClassUnionMember1.$schema.properties.lazilyResolvedStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "partialClassUnionMember1")
          }LazilyResolvedStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "partialClassUnionMember1")
        }LazilyResolvedStringProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Shape whose sh:properties have sh:order's. The compiler should order them C, A, B based on sh:order instead of on the declaration or lexicographic orders.
 */

export class OrderedPropertiesClass {
  private _$identifier?: OrderedPropertiesClass.$Identifier;

  readonly $type: "OrderedPropertiesClass" = "OrderedPropertiesClass" as const;

  readonly orderedPropertyC: string;

  readonly orderedPropertyB: string;

  readonly orderedPropertyA: string;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly orderedPropertyC: string;
    readonly orderedPropertyB: string;
    readonly orderedPropertyA: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this.orderedPropertyC = parameters.orderedPropertyC;
    this.orderedPropertyB = parameters.orderedPropertyB;
    this.orderedPropertyA = parameters.orderedPropertyA;
  }

  get $identifier(): OrderedPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: OrderedPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.orderedPropertyC, other.orderedPropertyC).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "orderedPropertyC",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.orderedPropertyB, other.orderedPropertyB).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "orderedPropertyB",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.orderedPropertyA, other.orderedPropertyA).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "orderedPropertyA",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.orderedPropertyC);
    _hasher.update(this.orderedPropertyB);
    _hasher.update(this.orderedPropertyA);
    return _hasher;
  }

  $toJson(): OrderedPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        orderedPropertyC: this.orderedPropertyC,
        orderedPropertyB: this.orderedPropertyB,
        orderedPropertyA: this.orderedPropertyA,
      } satisfies OrderedPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    resource.add(
      OrderedPropertiesClass.$schema.properties.orderedPropertyC.identifier,
      [$literalFactory.string(this.orderedPropertyC)],
      options?.graph,
    );
    resource.add(
      OrderedPropertiesClass.$schema.properties.orderedPropertyB.identifier,
      [$literalFactory.string(this.orderedPropertyB)],
      options?.graph,
    );
    resource.add(
      OrderedPropertiesClass.$schema.properties.orderedPropertyA.identifier,
      [$literalFactory.string(this.orderedPropertyA)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace OrderedPropertiesClass {
  export function $filter(
    filter: OrderedPropertiesClass.$Filter,
    value: OrderedPropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.orderedPropertyC !== "undefined" &&
      !$filterString(filter.orderedPropertyC, value.orderedPropertyC)
    ) {
      return false;
    }
    if (
      typeof filter.orderedPropertyB !== "undefined" &&
      !$filterString(filter.orderedPropertyB, value.orderedPropertyB)
    ) {
      return false;
    }
    if (
      typeof filter.orderedPropertyA !== "undefined" &&
      !$filterString(filter.orderedPropertyA, value.orderedPropertyA)
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly orderedPropertyC?: $StringFilter;
    readonly orderedPropertyB?: $StringFilter;
    readonly orderedPropertyA?: $StringFilter;
  };

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      orderedPropertyC: string;
      orderedPropertyB: string;
      orderedPropertyA: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const orderedPropertyC = $jsonObject["orderedPropertyC"];
    const orderedPropertyB = $jsonObject["orderedPropertyB"];
    const orderedPropertyA = $jsonObject["orderedPropertyA"];
    return Either.of({
      $identifier,
      orderedPropertyC,
      orderedPropertyB,
      orderedPropertyA,
    });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, OrderedPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new OrderedPropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "OrderedPropertiesClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/orderedPropertyC`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/orderedPropertyB`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/orderedPropertyA`,
          type: "Control",
        },
      ],
      label: "OrderedPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("OrderedPropertiesClass"),
      orderedPropertyC: z.string(),
      orderedPropertyB: z.string(),
      orderedPropertyA: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "OrderedPropertiesClass";
    readonly orderedPropertyC: string;
    readonly orderedPropertyB: string;
    readonly orderedPropertyA: string;
  };

  export function isOrderedPropertiesClass(
    object: $Object,
  ): object is OrderedPropertiesClass {
    switch (object.$type) {
      case "OrderedPropertiesClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, OrderedPropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return OrderedPropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new OrderedPropertiesClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      orderedPropertyC: string;
      orderedPropertyB: string;
      orderedPropertyA: string;
    }
  > {
    return Either.of<Error, OrderedPropertiesClass.$Identifier>(
      $parameters.resource.identifier as OrderedPropertiesClass.$Identifier,
    ).chain(($identifier) =>
      Either.of<Error, Resource.Values<Resource.TermValue>>(
        $parameters.resource.values(
          $schema.properties.orderedPropertyC.identifier,
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              OrderedPropertiesClass.$schema.properties.orderedPropertyC
                .identifier,
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .chain((orderedPropertyC) =>
          Either.of<Error, Resource.Values<Resource.TermValue>>(
            $parameters.resource.values(
              $schema.properties.orderedPropertyB.identifier,
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  OrderedPropertiesClass.$schema.properties.orderedPropertyB
                    .identifier,
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .chain((orderedPropertyB) =>
              Either.of<Error, Resource.Values<Resource.TermValue>>(
                $parameters.resource.values(
                  $schema.properties.orderedPropertyA.identifier,
                  { unique: true },
                ),
              )
                .chain((values) =>
                  $fromRdfPreferredLanguages({
                    focusResource: $parameters.resource,
                    predicate:
                      OrderedPropertiesClass.$schema.properties.orderedPropertyA
                        .identifier,
                    preferredLanguages: $parameters.preferredLanguages,
                    values,
                  }),
                )
                .chain((values) => values.chainMap((value) => value.toString()))
                .chain((values) => values.head())
                .map((orderedPropertyA) => ({
                  $identifier,
                  orderedPropertyC,
                  orderedPropertyB,
                  orderedPropertyA,
                })),
            ),
        ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["OrderedPropertiesClass"],
        }),
      },
      orderedPropertyC: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/orderedPropertyC",
        ),
      },
      orderedPropertyB: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/orderedPropertyB",
        ),
      },
      orderedPropertyA: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/orderedPropertyA",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: OrderedPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        OrderedPropertiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          OrderedPropertiesClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: OrderedPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      OrderedPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("orderedPropertiesClass");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "orderedPropertiesClass")
          }OrderedPropertyC`,
        ),
        predicate:
          OrderedPropertiesClass.$schema.properties.orderedPropertyC.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "orderedPropertiesClass")
          }OrderedPropertyB`,
        ),
        predicate:
          OrderedPropertiesClass.$schema.properties.orderedPropertyB.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "orderedPropertiesClass")
          }OrderedPropertyA`,
        ),
        predicate:
          OrderedPropertiesClass.$schema.properties.orderedPropertyA.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: OrderedPropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("orderedPropertiesClass");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: OrderedPropertiesClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "orderedPropertiesClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.orderedPropertyC,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "orderedPropertiesClass")
                  }OrderedPropertyC`,
                ),
                predicate:
                  OrderedPropertiesClass.$schema.properties.orderedPropertyC
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          OrderedPropertiesClass.$schema.properties.orderedPropertyC.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "orderedPropertiesClass")
          }OrderedPropertyC`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "orderedPropertiesClass")
        }OrderedPropertyC`,
      }),
    );
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.orderedPropertyB,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "orderedPropertiesClass")
                  }OrderedPropertyB`,
                ),
                predicate:
                  OrderedPropertiesClass.$schema.properties.orderedPropertyB
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          OrderedPropertiesClass.$schema.properties.orderedPropertyB.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "orderedPropertiesClass")
          }OrderedPropertyB`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "orderedPropertiesClass")
        }OrderedPropertyB`,
      }),
    );
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.orderedPropertyA,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "orderedPropertiesClass")
                  }OrderedPropertyA`,
                ),
                predicate:
                  OrderedPropertiesClass.$schema.properties.orderedPropertyA
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          OrderedPropertiesClass.$schema.properties.orderedPropertyA.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "orderedPropertiesClass")
          }OrderedPropertyA`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "orderedPropertiesClass")
        }OrderedPropertyA`,
      }),
    );
    return patterns;
  }
} /**
 * Node shape that isn't an rdfs:Class.
 */

export class NonClass {
  private _$identifier?: NonClass.$Identifier;

  readonly $type: "NonClass" = "NonClass" as const;

  readonly nonClassProperty: string;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly nonClassProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this.nonClassProperty = parameters.nonClassProperty;
  }

  get $identifier(): NonClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: NonClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.nonClassProperty, other.nonClassProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "nonClassProperty",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.nonClassProperty);
    return _hasher;
  }

  $toJson(): NonClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        nonClassProperty: this.nonClassProperty,
      } satisfies NonClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    resource.add(
      NonClass.$schema.properties.nonClassProperty.identifier,
      [$literalFactory.string(this.nonClassProperty)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace NonClass {
  export function $filter(filter: NonClass.$Filter, value: NonClass): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.nonClassProperty !== "undefined" &&
      !$filterString(filter.nonClassProperty, value.nonClassProperty)
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly nonClassProperty?: $StringFilter;
  };

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<
    z.ZodError,
    { $identifier: BlankNode | NamedNode; nonClassProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const nonClassProperty = $jsonObject["nonClassProperty"];
    return Either.of({ $identifier, nonClassProperty });
  }

  export function $fromJson(json: unknown): Either<z.ZodError, NonClass> {
    return $propertiesFromJson(json).map(
      (properties) => new NonClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "NonClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/nonClassProperty`,
          type: "Control",
        },
      ],
      label: "NonClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("NonClass"),
      nonClassProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "NonClass";
    readonly nonClassProperty: string;
  };

  export function isNonClass(object: $Object): object is NonClass {
    switch (object.$type) {
      case "NonClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, NonClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return NonClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new NonClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    { $identifier: BlankNode | NamedNode; nonClassProperty: string }
  > {
    return Either.of<Error, NonClass.$Identifier>(
      $parameters.resource.identifier as NonClass.$Identifier,
    ).chain(($identifier) =>
      Either.of<Error, Resource.Values<Resource.TermValue>>(
        $parameters.resource.values(
          $schema.properties.nonClassProperty.identifier,
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate: NonClass.$schema.properties.nonClassProperty.identifier,
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((nonClassProperty) => ({ $identifier, nonClassProperty })),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["NonClass"],
        }),
      },
      nonClassProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/nonClassProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: NonClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        NonClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          NonClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: NonClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      NonClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("nonClass");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable" ? subject.value : "nonClass")
          }NonClassProperty`,
        ),
        predicate: NonClass.$schema.properties.nonClassProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: NonClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("nonClass");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: NonClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable" ? subject.value : "nonClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.nonClassProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "nonClass")
                  }NonClassProperty`,
                ),
                predicate:
                  NonClass.$schema.properties.nonClassProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema: NonClass.$schema.properties.nonClassProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable" ? subject.value : "nonClass")
          }NonClassProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable" ? subject.value : "nonClass")
        }NonClassProperty`,
      }),
    );
    return patterns;
  }
}
export class NoRdfTypeClassUnionMember2 {
  private _$identifier?: NoRdfTypeClassUnionMember2.$Identifier;

  readonly $type: "NoRdfTypeClassUnionMember2" =
    "NoRdfTypeClassUnionMember2" as const;

  readonly noRdfTypeClassUnionMember2Property: string;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly noRdfTypeClassUnionMember2Property: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this.noRdfTypeClassUnionMember2Property =
      parameters.noRdfTypeClassUnionMember2Property;
  }

  get $identifier(): NoRdfTypeClassUnionMember2.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: NoRdfTypeClassUnionMember2): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.noRdfTypeClassUnionMember2Property,
          other.noRdfTypeClassUnionMember2Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "noRdfTypeClassUnionMember2Property",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.noRdfTypeClassUnionMember2Property);
    return _hasher;
  }

  $toJson(): NoRdfTypeClassUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        noRdfTypeClassUnionMember2Property:
          this.noRdfTypeClassUnionMember2Property,
      } satisfies NoRdfTypeClassUnionMember2.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    resource.add(
      NoRdfTypeClassUnionMember2.$schema.properties
        .noRdfTypeClassUnionMember2Property.identifier,
      [$literalFactory.string(this.noRdfTypeClassUnionMember2Property)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace NoRdfTypeClassUnionMember2 {
  export function $filter(
    filter: NoRdfTypeClassUnionMember2.$Filter,
    value: NoRdfTypeClassUnionMember2,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.noRdfTypeClassUnionMember2Property !== "undefined" &&
      !$filterString(
        filter.noRdfTypeClassUnionMember2Property,
        value.noRdfTypeClassUnionMember2Property,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly noRdfTypeClassUnionMember2Property?: $StringFilter;
  };

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      noRdfTypeClassUnionMember2Property: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const noRdfTypeClassUnionMember2Property =
      $jsonObject["noRdfTypeClassUnionMember2Property"];
    return Either.of({ $identifier, noRdfTypeClassUnionMember2Property });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, NoRdfTypeClassUnionMember2> {
    return $propertiesFromJson(json).map(
      (properties) => new NoRdfTypeClassUnionMember2(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "NoRdfTypeClassUnionMember2" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/noRdfTypeClassUnionMember2Property`,
          type: "Control",
        },
      ],
      label: "NoRdfTypeClassUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("NoRdfTypeClassUnionMember2"),
      noRdfTypeClassUnionMember2Property: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "NoRdfTypeClassUnionMember2";
    readonly noRdfTypeClassUnionMember2Property: string;
  };

  export function isNoRdfTypeClassUnionMember2(
    object: $Object,
  ): object is NoRdfTypeClassUnionMember2 {
    switch (object.$type) {
      case "NoRdfTypeClassUnionMember2":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, NoRdfTypeClassUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return NoRdfTypeClassUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new NoRdfTypeClassUnionMember2(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      noRdfTypeClassUnionMember2Property: string;
    }
  > {
    return Either.of<Error, NoRdfTypeClassUnionMember2.$Identifier>(
      $parameters.resource.identifier as NoRdfTypeClassUnionMember2.$Identifier,
    ).chain(($identifier) =>
      Either.of<Error, Resource.Values<Resource.TermValue>>(
        $parameters.resource.values(
          $schema.properties.noRdfTypeClassUnionMember2Property.identifier,
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              NoRdfTypeClassUnionMember2.$schema.properties
                .noRdfTypeClassUnionMember2Property.identifier,
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((noRdfTypeClassUnionMember2Property) => ({
          $identifier,
          noRdfTypeClassUnionMember2Property,
        })),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["NoRdfTypeClassUnionMember2"],
        }),
      },
      noRdfTypeClassUnionMember2Property: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/noRdfTypeClassUnionMember2Property",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: NoRdfTypeClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        NoRdfTypeClassUnionMember2.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          NoRdfTypeClassUnionMember2.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: NoRdfTypeClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      NoRdfTypeClassUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("noRdfTypeClassUnionMember2");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "noRdfTypeClassUnionMember2")
          }NoRdfTypeClassUnionMember2Property`,
        ),
        predicate:
          NoRdfTypeClassUnionMember2.$schema.properties
            .noRdfTypeClassUnionMember2Property.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: NoRdfTypeClassUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("noRdfTypeClassUnionMember2");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            NoRdfTypeClassUnionMember2.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "noRdfTypeClassUnionMember2"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.noRdfTypeClassUnionMember2Property,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "noRdfTypeClassUnionMember2")
                  }NoRdfTypeClassUnionMember2Property`,
                ),
                predicate:
                  NoRdfTypeClassUnionMember2.$schema.properties
                    .noRdfTypeClassUnionMember2Property.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          NoRdfTypeClassUnionMember2.$schema.properties.noRdfTypeClassUnionMember2Property.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "noRdfTypeClassUnionMember2")
          }NoRdfTypeClassUnionMember2Property`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "noRdfTypeClassUnionMember2")
        }NoRdfTypeClassUnionMember2Property`,
      }),
    );
    return patterns;
  }
}
export class NoRdfTypeClassUnionMember1 {
  private _$identifier?: NoRdfTypeClassUnionMember1.$Identifier;

  readonly $type: "NoRdfTypeClassUnionMember1" =
    "NoRdfTypeClassUnionMember1" as const;

  readonly noRdfTypeClassUnionMember1Property: string;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly noRdfTypeClassUnionMember1Property: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this.noRdfTypeClassUnionMember1Property =
      parameters.noRdfTypeClassUnionMember1Property;
  }

  get $identifier(): NoRdfTypeClassUnionMember1.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: NoRdfTypeClassUnionMember1): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.noRdfTypeClassUnionMember1Property,
          other.noRdfTypeClassUnionMember1Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "noRdfTypeClassUnionMember1Property",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.noRdfTypeClassUnionMember1Property);
    return _hasher;
  }

  $toJson(): NoRdfTypeClassUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        noRdfTypeClassUnionMember1Property:
          this.noRdfTypeClassUnionMember1Property,
      } satisfies NoRdfTypeClassUnionMember1.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    resource.add(
      NoRdfTypeClassUnionMember1.$schema.properties
        .noRdfTypeClassUnionMember1Property.identifier,
      [$literalFactory.string(this.noRdfTypeClassUnionMember1Property)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace NoRdfTypeClassUnionMember1 {
  export function $filter(
    filter: NoRdfTypeClassUnionMember1.$Filter,
    value: NoRdfTypeClassUnionMember1,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.noRdfTypeClassUnionMember1Property !== "undefined" &&
      !$filterString(
        filter.noRdfTypeClassUnionMember1Property,
        value.noRdfTypeClassUnionMember1Property,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly noRdfTypeClassUnionMember1Property?: $StringFilter;
  };

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      noRdfTypeClassUnionMember1Property: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const noRdfTypeClassUnionMember1Property =
      $jsonObject["noRdfTypeClassUnionMember1Property"];
    return Either.of({ $identifier, noRdfTypeClassUnionMember1Property });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, NoRdfTypeClassUnionMember1> {
    return $propertiesFromJson(json).map(
      (properties) => new NoRdfTypeClassUnionMember1(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "NoRdfTypeClassUnionMember1" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/noRdfTypeClassUnionMember1Property`,
          type: "Control",
        },
      ],
      label: "NoRdfTypeClassUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("NoRdfTypeClassUnionMember1"),
      noRdfTypeClassUnionMember1Property: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "NoRdfTypeClassUnionMember1";
    readonly noRdfTypeClassUnionMember1Property: string;
  };

  export function isNoRdfTypeClassUnionMember1(
    object: $Object,
  ): object is NoRdfTypeClassUnionMember1 {
    switch (object.$type) {
      case "NoRdfTypeClassUnionMember1":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, NoRdfTypeClassUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return NoRdfTypeClassUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new NoRdfTypeClassUnionMember1(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      noRdfTypeClassUnionMember1Property: string;
    }
  > {
    return Either.of<Error, NoRdfTypeClassUnionMember1.$Identifier>(
      $parameters.resource.identifier as NoRdfTypeClassUnionMember1.$Identifier,
    ).chain(($identifier) =>
      Either.of<Error, Resource.Values<Resource.TermValue>>(
        $parameters.resource.values(
          $schema.properties.noRdfTypeClassUnionMember1Property.identifier,
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              NoRdfTypeClassUnionMember1.$schema.properties
                .noRdfTypeClassUnionMember1Property.identifier,
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((noRdfTypeClassUnionMember1Property) => ({
          $identifier,
          noRdfTypeClassUnionMember1Property,
        })),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["NoRdfTypeClassUnionMember1"],
        }),
      },
      noRdfTypeClassUnionMember1Property: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/noRdfTypeClassUnionMember1Property",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: NoRdfTypeClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        NoRdfTypeClassUnionMember1.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          NoRdfTypeClassUnionMember1.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: NoRdfTypeClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      NoRdfTypeClassUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("noRdfTypeClassUnionMember1");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "noRdfTypeClassUnionMember1")
          }NoRdfTypeClassUnionMember1Property`,
        ),
        predicate:
          NoRdfTypeClassUnionMember1.$schema.properties
            .noRdfTypeClassUnionMember1Property.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: NoRdfTypeClassUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("noRdfTypeClassUnionMember1");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            NoRdfTypeClassUnionMember1.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "noRdfTypeClassUnionMember1"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.noRdfTypeClassUnionMember1Property,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "noRdfTypeClassUnionMember1")
                  }NoRdfTypeClassUnionMember1Property`,
                ),
                predicate:
                  NoRdfTypeClassUnionMember1.$schema.properties
                    .noRdfTypeClassUnionMember1Property.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          NoRdfTypeClassUnionMember1.$schema.properties.noRdfTypeClassUnionMember1Property.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "noRdfTypeClassUnionMember1")
          }NoRdfTypeClassUnionMember1Property`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "noRdfTypeClassUnionMember1")
        }NoRdfTypeClassUnionMember1Property`,
      }),
    );
    return patterns;
  }
} /**
 * Shape with shaclmate:mutable properties.
 */

export class MutablePropertiesClass {
  private _$identifier?: MutablePropertiesClass.$Identifier;

  protected readonly _$identifierPrefix?: string;

  readonly $type: "MutablePropertiesClass" = "MutablePropertiesClass" as const;

  /**
   * List-valued property that can't be reassigned but whose value can be mutated
   */
  readonly mutableListProperty: Maybe<string[]>;

  /**
   * Set-valued property that can't be reassigned but whose value can be mutated
   */
  mutableSetProperty: string[];

  /**
   * String-valued property that can be re-assigned
   */
  mutableStringProperty: Maybe<string>;

  constructor(parameters?: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly $identifierPrefix?: string;
    readonly mutableListProperty?: Maybe<string[]> | readonly string[];
    readonly mutableSetProperty?: readonly string[];
    readonly mutableStringProperty?: Maybe<string> | string;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }
    this._$identifierPrefix = parameters?.$identifierPrefix;
    if (Maybe.isMaybe(parameters?.mutableListProperty)) {
      this.mutableListProperty = parameters?.mutableListProperty;
    } else if (typeof parameters?.mutableListProperty === "undefined") {
      this.mutableListProperty = Maybe.of([]);
    } else if (typeof parameters?.mutableListProperty === "object") {
      this.mutableListProperty = Maybe.of(
        parameters?.mutableListProperty.concat(),
      );
    } else {
      this.mutableListProperty =
        parameters?.mutableListProperty satisfies never;
    }
    if (typeof parameters?.mutableSetProperty === "undefined") {
      this.mutableSetProperty = [];
    } else if (typeof parameters?.mutableSetProperty === "object") {
      this.mutableSetProperty = parameters?.mutableSetProperty.concat();
    } else {
      this.mutableSetProperty = parameters?.mutableSetProperty satisfies never;
    }
    if (Maybe.isMaybe(parameters?.mutableStringProperty)) {
      this.mutableStringProperty = parameters?.mutableStringProperty;
    } else if (typeof parameters?.mutableStringProperty === "string") {
      this.mutableStringProperty = Maybe.of(parameters?.mutableStringProperty);
    } else if (typeof parameters?.mutableStringProperty === "undefined") {
      this.mutableStringProperty = Maybe.empty();
    } else {
      this.mutableStringProperty =
        parameters?.mutableStringProperty satisfies never;
    }
  }

  get $identifier(): MutablePropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      return dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }
    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  $equals(other: MutablePropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$identifierPrefix, other.$identifierPrefix).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$identifierPrefix",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) =>
            $arrayEquals(left, right, $strictEquals),
          ))(this.mutableListProperty, other.mutableListProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "mutableListProperty",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $strictEquals))(
          this.mutableSetProperty,
          other.mutableSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "mutableSetProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.mutableStringProperty,
          other.mutableStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "mutableStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    this.mutableListProperty.ifJust((value0) => {
      for (const item1 of value0) {
        _hasher.update(item1);
      }
    });
    for (const item0 of this.mutableSetProperty) {
      _hasher.update(item0);
    }
    this.mutableStringProperty.ifJust((value0) => {
      _hasher.update(value0);
    });
    return _hasher;
  }

  $toJson(): MutablePropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        mutableListProperty: this.mutableListProperty
          .map((item) => item.map((item) => item))
          .extract(),
        mutableSetProperty: this.mutableSetProperty.map((item) => item),
        mutableStringProperty: this.mutableStringProperty
          .map((item) => item)
          .extract(),
      } satisfies MutablePropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/MutablePropertiesClass"),
        options?.graph,
      );
    }
    resource.add(
      MutablePropertiesClass.$schema.properties.mutableListProperty.identifier,
      this.mutableListProperty.toList().flatMap((value) => [
        value.length > 0
          ? value.reduce(
              (
                { currentSubListResource, listResource },
                item,
                itemIndex,
                list,
              ) => {
                if (itemIndex === 0) {
                  currentSubListResource = listResource;
                } else {
                  const newSubListResource = resourceSet.resource(
                    dataFactory.blankNode(),
                  );
                  currentSubListResource!.add(
                    $RdfVocabularies.rdf.rest,
                    newSubListResource.identifier,
                    options?.graph,
                  );
                  currentSubListResource = newSubListResource;
                }

                currentSubListResource.add(
                  $RdfVocabularies.rdf.first,
                  [$literalFactory.string(item)],
                  options?.graph,
                );

                if (itemIndex + 1 === list.length) {
                  currentSubListResource.add(
                    $RdfVocabularies.rdf.rest,
                    $RdfVocabularies.rdf.nil,
                    options?.graph,
                  );
                }

                return { currentSubListResource, listResource };
              },
              {
                currentSubListResource: null,
                listResource: resourceSet.resource(dataFactory.blankNode()),
              } as {
                currentSubListResource: Resource<BlankNode> | null;
                listResource: Resource<BlankNode>;
              },
            ).listResource.identifier
          : $RdfVocabularies.rdf.nil,
      ]),
      options?.graph,
    );
    resource.add(
      MutablePropertiesClass.$schema.properties.mutableSetProperty.identifier,
      this.mutableSetProperty.flatMap((item) => [$literalFactory.string(item)]),
      options?.graph,
    );
    resource.add(
      MutablePropertiesClass.$schema.properties.mutableStringProperty
        .identifier,
      this.mutableStringProperty
        .toList()
        .flatMap((value) => [$literalFactory.string(value)]),
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace MutablePropertiesClass {
  export function $filter(
    filter: MutablePropertiesClass.$Filter,
    value: MutablePropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.mutableListProperty !== "undefined" &&
      !$filterMaybe<string[], $CollectionFilter<$StringFilter>>(
        $filterArray<string, $StringFilter>($filterString),
      )(filter.mutableListProperty, value.mutableListProperty)
    ) {
      return false;
    }
    if (
      typeof filter.mutableSetProperty !== "undefined" &&
      !$filterArray<string, $StringFilter>($filterString)(
        filter.mutableSetProperty,
        value.mutableSetProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.mutableStringProperty !== "undefined" &&
      !$filterMaybe<string, $StringFilter>($filterString)(
        filter.mutableStringProperty,
        value.mutableStringProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly mutableListProperty?: $MaybeFilter<
      $CollectionFilter<$StringFilter>
    >;
    readonly mutableSetProperty?: $CollectionFilter<$StringFilter>;
    readonly mutableStringProperty?: $MaybeFilter<$StringFilter>;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/MutablePropertiesClass",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      mutableListProperty: Maybe<string[]>;
      mutableSetProperty: string[];
      mutableStringProperty: Maybe<string>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const mutableListProperty = Maybe.fromNullable(
      $jsonObject["mutableListProperty"],
    );
    const mutableSetProperty = $jsonObject["mutableSetProperty"];
    const mutableStringProperty = Maybe.fromNullable(
      $jsonObject["mutableStringProperty"],
    );
    return Either.of({
      $identifier,
      mutableListProperty,
      mutableSetProperty,
      mutableStringProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, MutablePropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new MutablePropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "MutablePropertiesClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/mutableListProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/mutableSetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/mutableStringProperty`,
          type: "Control",
        },
      ],
      label: "MutablePropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("MutablePropertiesClass"),
      mutableListProperty: z
        .string()
        .array()
        .default(() => [])
        .optional()
        .describe(
          "List-valued property that can't be reassigned but whose value can be mutated",
        ),
      mutableSetProperty: z
        .string()
        .array()
        .default(() => [])
        .describe(
          "Set-valued property that can't be reassigned but whose value can be mutated",
        ),
      mutableStringProperty: z
        .string()
        .optional()
        .describe("String-valued property that can be re-assigned"),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "MutablePropertiesClass";
    readonly mutableListProperty?: readonly string[];
    readonly mutableSetProperty?: readonly string[];
    readonly mutableStringProperty?: string;
  };

  export function isMutablePropertiesClass(
    object: $Object,
  ): object is MutablePropertiesClass {
    switch (object.$type) {
      case "MutablePropertiesClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, MutablePropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return MutablePropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new MutablePropertiesClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      mutableListProperty: Maybe<string[]>;
      mutableSetProperty: string[];
      mutableStringProperty: Maybe<string>;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/MutablePropertiesClass":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  MutablePropertiesClass.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/MutablePropertiesClass)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, MutablePropertiesClass.$Identifier>(
        $parameters.resource.identifier as MutablePropertiesClass.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.mutableListProperty.identifier,
            { unique: true },
          ),
        )
          .chain((values) => values.chainMap((value) => value.toList()))
          .chain((valueLists) =>
            valueLists.chainMap((valueList) =>
              Either.of<Error, Resource.Values<Resource.TermValue>>(
                Resource.Values.fromArray({
                  focusResource: $parameters.resource,
                  predicate:
                    MutablePropertiesClass.$schema.properties
                      .mutableListProperty.identifier,
                  values: valueList,
                }),
              )
                .chain((values) =>
                  $fromRdfPreferredLanguages({
                    focusResource: $parameters.resource,
                    predicate:
                      MutablePropertiesClass.$schema.properties
                        .mutableListProperty.identifier,
                    preferredLanguages: $parameters.preferredLanguages,
                    values,
                  }),
                )
                .chain((values) =>
                  values.chainMap((value) => value.toString()),
                ),
            ),
          )
          .map((valueLists) =>
            valueLists.map((valueList) => valueList.toArray().concat()),
          )
          .map((values) =>
            values.length > 0
              ? values.map((value) => Maybe.of(value))
              : Resource.Values.fromValue<Maybe<string[]>>({
                  focusResource: $parameters.resource,
                  predicate:
                    MutablePropertiesClass.$schema.properties
                      .mutableListProperty.identifier,
                  value: Maybe.empty(),
                }),
          )
          .chain((values) => values.head())
          .chain((mutableListProperty) =>
            Either.of<Error, Resource.Values<Resource.TermValue>>(
              $parameters.resource.values(
                $schema.properties.mutableSetProperty.identifier,
                { unique: true },
              ),
            )
              .chain((values) =>
                $fromRdfPreferredLanguages({
                  focusResource: $parameters.resource,
                  predicate:
                    MutablePropertiesClass.$schema.properties.mutableSetProperty
                      .identifier,
                  preferredLanguages: $parameters.preferredLanguages,
                  values,
                }),
              )
              .chain((values) => values.chainMap((value) => value.toString()))
              .map((values) => values.toArray().concat())
              .map((valuesArray) =>
                Resource.Values.fromValue({
                  focusResource: $parameters.resource,
                  predicate:
                    MutablePropertiesClass.$schema.properties.mutableSetProperty
                      .identifier,
                  value: valuesArray,
                }),
              )
              .chain((values) => values.head())
              .chain((mutableSetProperty) =>
                Either.of<Error, Resource.Values<Resource.TermValue>>(
                  $parameters.resource.values(
                    $schema.properties.mutableStringProperty.identifier,
                    { unique: true },
                  ),
                )
                  .chain((values) =>
                    $fromRdfPreferredLanguages({
                      focusResource: $parameters.resource,
                      predicate:
                        MutablePropertiesClass.$schema.properties
                          .mutableStringProperty.identifier,
                      preferredLanguages: $parameters.preferredLanguages,
                      values,
                    }),
                  )
                  .chain((values) =>
                    values.chainMap((value) => value.toString()),
                  )
                  .map((values) =>
                    values.length > 0
                      ? values.map((value) => Maybe.of(value))
                      : Resource.Values.fromValue<Maybe<string>>({
                          focusResource: $parameters.resource,
                          predicate:
                            MutablePropertiesClass.$schema.properties
                              .mutableStringProperty.identifier,
                          value: Maybe.empty(),
                        }),
                  )
                  .chain((values) => values.head())
                  .map((mutableStringProperty) => ({
                    $identifier,
                    mutableListProperty,
                    mutableSetProperty,
                    mutableStringProperty,
                  })),
              ),
          ),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $identifierPrefix: {
        kind: "IdentifierPrefix" as const,
        type: () => ({ kind: "String" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["MutablePropertiesClass"],
        }),
      },
      mutableListProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({
            kind: "List" as const,
            item: () => ({ kind: "String" as const }),
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/mutableListProperty",
        ),
      },
      mutableSetProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Set" as const,
          item: () => ({ kind: "String" as const }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/mutableSetProperty",
        ),
      },
      mutableStringProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({ kind: "String" as const }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/mutableStringProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: MutablePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        MutablePropertiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          MutablePropertiesClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: MutablePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      MutablePropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("mutablePropertiesClass");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "mutablePropertiesClass")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "mutablePropertiesClass")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "mutablePropertiesClass")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "mutablePropertiesClass")
          }MutableListProperty`,
        ),
        predicate:
          MutablePropertiesClass.$schema.properties.mutableListProperty
            .identifier,
        subject: subject,
      },
      ...[
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "mutablePropertiesClass")
            }MutableListProperty`,
          ),
          predicate: $RdfVocabularies.rdf.first,
          object: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "mutablePropertiesClass")
            }MutableListProperty`}Item0`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "mutablePropertiesClass")
            }MutableListProperty`,
          ),
          predicate: $RdfVocabularies.rdf.rest,
          object: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "mutablePropertiesClass")
            }MutableListProperty`}Rest0`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "mutablePropertiesClass")
            }MutableListProperty`}RestN`,
          ),
          predicate: $RdfVocabularies.rdf.first,
          object: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "mutablePropertiesClass")
            }MutableListProperty`}ItemN`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "mutablePropertiesClass")
            }MutableListProperty`}RestN`,
          ),
          predicate: $RdfVocabularies.rdf.rest,
          object: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "mutablePropertiesClass")
            }MutableListProperty`}RestNBasic`,
          ),
        },
      ],
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "mutablePropertiesClass")
          }MutableSetProperty`,
        ),
        predicate:
          MutablePropertiesClass.$schema.properties.mutableSetProperty
            .identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "mutablePropertiesClass")
          }MutableStringProperty`,
        ),
        predicate:
          MutablePropertiesClass.$schema.properties.mutableStringProperty
            .identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: MutablePropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("mutablePropertiesClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "mutablePropertiesClass")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: MutablePropertiesClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "mutablePropertiesClass")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: MutablePropertiesClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "mutablePropertiesClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<
        $CollectionFilter<$StringFilter>,
        $CollectionSchema<$StringSchema>
      >(
        $listSparqlWherePatterns<$StringFilter, $StringSchema>(
          $stringSparqlWherePatterns,
        ),
      )({
        filter: parameters?.filter?.mutableListProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "mutablePropertiesClass")
                  }MutableListProperty`,
                ),
                predicate:
                  MutablePropertiesClass.$schema.properties.mutableListProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          MutablePropertiesClass.$schema.properties.mutableListProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "mutablePropertiesClass")
          }MutableListProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "mutablePropertiesClass")
        }MutableListProperty`,
      }),
    );
    patterns = patterns.concat(
      $setSparqlWherePatterns<$StringFilter, $StringSchema>(
        $stringSparqlWherePatterns,
      )({
        filter: parameters?.filter?.mutableSetProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "mutablePropertiesClass")
                  }MutableSetProperty`,
                ),
                predicate:
                  MutablePropertiesClass.$schema.properties.mutableSetProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          MutablePropertiesClass.$schema.properties.mutableSetProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "mutablePropertiesClass")
          }MutableSetProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "mutablePropertiesClass")
        }MutableSetProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<$StringFilter, $StringSchema>(
        $stringSparqlWherePatterns,
      )({
        filter: parameters?.filter?.mutableStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "mutablePropertiesClass")
                  }MutableStringProperty`,
                ),
                predicate:
                  MutablePropertiesClass.$schema.properties
                    .mutableStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          MutablePropertiesClass.$schema.properties.mutableStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "mutablePropertiesClass")
          }MutableStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "mutablePropertiesClass")
        }MutableStringProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Shape that uses the list shapes in properties.
 */

export class ListPropertiesClass {
  private _$identifier?: ListPropertiesClass.$Identifier;

  readonly $type: "ListPropertiesClass" = "ListPropertiesClass" as const;

  readonly iriListProperty: Maybe<readonly NamedNode[]>;

  readonly objectListProperty: Maybe<readonly NonClass[]>;

  readonly stringListProperty: Maybe<readonly string[]>;

  constructor(parameters?: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly iriListProperty?:
      | Maybe<readonly NamedNode[]>
      | readonly NamedNode[]
      | readonly string[];
    readonly objectListProperty?:
      | Maybe<readonly NonClass[]>
      | readonly NonClass[];
    readonly stringListProperty?: Maybe<readonly string[]> | readonly string[];
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }
    if (Maybe.isMaybe(parameters?.iriListProperty)) {
      this.iriListProperty = parameters?.iriListProperty;
    } else if (typeof parameters?.iriListProperty === "undefined") {
      this.iriListProperty = Maybe.of([]);
    } else if ($isReadonlyObjectArray(parameters?.iriListProperty)) {
      this.iriListProperty = Maybe.of(parameters?.iriListProperty);
    } else if ($isReadonlyStringArray(parameters?.iriListProperty)) {
      this.iriListProperty = Maybe.of(
        parameters?.iriListProperty.map((item) => dataFactory.namedNode(item)),
      );
    } else {
      this.iriListProperty = parameters?.iriListProperty satisfies never;
    }
    if (Maybe.isMaybe(parameters?.objectListProperty)) {
      this.objectListProperty = parameters?.objectListProperty;
    } else if (typeof parameters?.objectListProperty === "undefined") {
      this.objectListProperty = Maybe.of([]);
    } else if (typeof parameters?.objectListProperty === "object") {
      this.objectListProperty = Maybe.of(parameters?.objectListProperty);
    } else {
      this.objectListProperty = parameters?.objectListProperty satisfies never;
    }
    if (Maybe.isMaybe(parameters?.stringListProperty)) {
      this.stringListProperty = parameters?.stringListProperty;
    } else if (typeof parameters?.stringListProperty === "undefined") {
      this.stringListProperty = Maybe.of([]);
    } else if (typeof parameters?.stringListProperty === "object") {
      this.stringListProperty = Maybe.of(parameters?.stringListProperty);
    } else {
      this.stringListProperty = parameters?.stringListProperty satisfies never;
    }
  }

  get $identifier(): ListPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: ListPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) =>
            $arrayEquals(left, right, $booleanEquals),
          ))(this.iriListProperty, other.iriListProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "iriListProperty",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) =>
            $arrayEquals(left, right, (left, right) => left.$equals(right)),
          ))(this.objectListProperty, other.objectListProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "objectListProperty",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) =>
            $arrayEquals(left, right, $strictEquals),
          ))(this.stringListProperty, other.stringListProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "stringListProperty",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    this.iriListProperty.ifJust((value0) => {
      for (const item1 of value0) {
        _hasher.update(item1.termType);
        _hasher.update(item1.value);
      }
    });
    this.objectListProperty.ifJust((value0) => {
      for (const item1 of value0) {
        item1.$hash(_hasher);
      }
    });
    this.stringListProperty.ifJust((value0) => {
      for (const item1 of value0) {
        _hasher.update(item1);
      }
    });
    return _hasher;
  }

  $toJson(): ListPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        iriListProperty: this.iriListProperty
          .map((item) => item.map((item) => ({ "@id": item.value })))
          .extract(),
        objectListProperty: this.objectListProperty
          .map((item) => item.map((item) => item.$toJson()))
          .extract(),
        stringListProperty: this.stringListProperty
          .map((item) => item.map((item) => item))
          .extract(),
      } satisfies ListPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/ListPropertiesClass"),
        options?.graph,
      );
    }
    resource.add(
      ListPropertiesClass.$schema.properties.iriListProperty.identifier,
      this.iriListProperty.toList().flatMap((value) => [
        value.length > 0
          ? value.reduce(
              (
                { currentSubListResource, listResource },
                item,
                itemIndex,
                list,
              ) => {
                if (itemIndex === 0) {
                  currentSubListResource = listResource;
                } else {
                  const newSubListResource = resourceSet.resource(
                    dataFactory.blankNode(),
                  );
                  currentSubListResource!.add(
                    $RdfVocabularies.rdf.rest,
                    newSubListResource.identifier,
                    options?.graph,
                  );
                  currentSubListResource = newSubListResource;
                }

                currentSubListResource.add(
                  $RdfVocabularies.rdf.first,
                  [item],
                  options?.graph,
                );

                if (itemIndex + 1 === list.length) {
                  currentSubListResource.add(
                    $RdfVocabularies.rdf.rest,
                    $RdfVocabularies.rdf.nil,
                    options?.graph,
                  );
                }

                return { currentSubListResource, listResource };
              },
              {
                currentSubListResource: null,
                listResource: resourceSet.resource(dataFactory.blankNode()),
              } as {
                currentSubListResource: Resource<BlankNode> | null;
                listResource: Resource<BlankNode>;
              },
            ).listResource.identifier
          : $RdfVocabularies.rdf.nil,
      ]),
      options?.graph,
    );
    resource.add(
      ListPropertiesClass.$schema.properties.objectListProperty.identifier,
      this.objectListProperty.toList().flatMap((value) => [
        value.length > 0
          ? value.reduce(
              (
                { currentSubListResource, listResource },
                item,
                itemIndex,
                list,
              ) => {
                if (itemIndex === 0) {
                  currentSubListResource = listResource;
                } else {
                  const newSubListResource = resourceSet.resource(
                    dataFactory.blankNode(),
                  );
                  currentSubListResource!.add(
                    $RdfVocabularies.rdf.rest,
                    newSubListResource.identifier,
                    options?.graph,
                  );
                  currentSubListResource = newSubListResource;
                }

                currentSubListResource.add(
                  $RdfVocabularies.rdf.first,
                  [
                    item.$toRdf({
                      graph: options?.graph,
                      resourceSet: resourceSet,
                    }).identifier,
                  ],
                  options?.graph,
                );

                if (itemIndex + 1 === list.length) {
                  currentSubListResource.add(
                    $RdfVocabularies.rdf.rest,
                    $RdfVocabularies.rdf.nil,
                    options?.graph,
                  );
                }

                return { currentSubListResource, listResource };
              },
              {
                currentSubListResource: null,
                listResource: resourceSet.resource(dataFactory.blankNode()),
              } as {
                currentSubListResource: Resource<BlankNode> | null;
                listResource: Resource<BlankNode>;
              },
            ).listResource.identifier
          : $RdfVocabularies.rdf.nil,
      ]),
      options?.graph,
    );
    resource.add(
      ListPropertiesClass.$schema.properties.stringListProperty.identifier,
      this.stringListProperty.toList().flatMap((value) => [
        value.length > 0
          ? value.reduce(
              (
                { currentSubListResource, listResource },
                item,
                itemIndex,
                list,
              ) => {
                if (itemIndex === 0) {
                  currentSubListResource = listResource;
                } else {
                  const newSubListResource = resourceSet.resource(
                    dataFactory.blankNode(),
                  );
                  currentSubListResource!.add(
                    $RdfVocabularies.rdf.rest,
                    newSubListResource.identifier,
                    options?.graph,
                  );
                  currentSubListResource = newSubListResource;
                }

                currentSubListResource.add(
                  $RdfVocabularies.rdf.first,
                  [$literalFactory.string(item)],
                  options?.graph,
                );

                if (itemIndex + 1 === list.length) {
                  currentSubListResource.add(
                    $RdfVocabularies.rdf.rest,
                    $RdfVocabularies.rdf.nil,
                    options?.graph,
                  );
                }

                return { currentSubListResource, listResource };
              },
              {
                currentSubListResource: null,
                listResource: resourceSet.resource(dataFactory.blankNode()),
              } as {
                currentSubListResource: Resource<BlankNode> | null;
                listResource: Resource<BlankNode>;
              },
            ).listResource.identifier
          : $RdfVocabularies.rdf.nil,
      ]),
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ListPropertiesClass {
  export function $filter(
    filter: ListPropertiesClass.$Filter,
    value: ListPropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.iriListProperty !== "undefined" &&
      !$filterMaybe<readonly NamedNode[], $CollectionFilter<$NamedNodeFilter>>(
        $filterArray<NamedNode, $NamedNodeFilter>($filterNamedNode),
      )(filter.iriListProperty, value.iriListProperty)
    ) {
      return false;
    }
    if (
      typeof filter.objectListProperty !== "undefined" &&
      !$filterMaybe<readonly NonClass[], $CollectionFilter<NonClass.$Filter>>(
        $filterArray<NonClass, NonClass.$Filter>(NonClass.$filter),
      )(filter.objectListProperty, value.objectListProperty)
    ) {
      return false;
    }
    if (
      typeof filter.stringListProperty !== "undefined" &&
      !$filterMaybe<readonly string[], $CollectionFilter<$StringFilter>>(
        $filterArray<string, $StringFilter>($filterString),
      )(filter.stringListProperty, value.stringListProperty)
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly iriListProperty?: $MaybeFilter<
      $CollectionFilter<$NamedNodeFilter>
    >;
    readonly objectListProperty?: $MaybeFilter<
      $CollectionFilter<NonClass.$Filter>
    >;
    readonly stringListProperty?: $MaybeFilter<
      $CollectionFilter<$StringFilter>
    >;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ListPropertiesClass",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      iriListProperty: Maybe<readonly NamedNode[]>;
      objectListProperty: Maybe<readonly NonClass[]>;
      stringListProperty: Maybe<readonly string[]>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const iriListProperty = Maybe.fromNullable(
      $jsonObject["iriListProperty"],
    ).map((item) => item.map((item) => dataFactory.namedNode(item["@id"])));
    const objectListProperty = Maybe.fromNullable(
      $jsonObject["objectListProperty"],
    ).map((item) =>
      item.map((item) => NonClass.$fromJson(item).unsafeCoerce()),
    );
    const stringListProperty = Maybe.fromNullable(
      $jsonObject["stringListProperty"],
    );
    return Either.of({
      $identifier,
      iriListProperty,
      objectListProperty,
      stringListProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, ListPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ListPropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ListPropertiesClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/iriListProperty`, type: "Control" },
        NonClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/objectListProperty`,
        }),
        {
          scope: `${scopePrefix}/properties/stringListProperty`,
          type: "Control",
        },
      ],
      label: "ListPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("ListPropertiesClass"),
      iriListProperty: z
        .object({ "@id": z.string().min(1) })
        .array()
        .default(() => [])
        .optional(),
      objectListProperty: NonClass.$jsonZodSchema()
        .array()
        .default(() => [])
        .optional(),
      stringListProperty: z
        .string()
        .array()
        .default(() => [])
        .optional(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ListPropertiesClass";
    readonly iriListProperty?: readonly { readonly "@id": string }[];
    readonly objectListProperty?: readonly NonClass.$Json[];
    readonly stringListProperty?: readonly string[];
  };

  export function isListPropertiesClass(
    object: $Object,
  ): object is ListPropertiesClass {
    switch (object.$type) {
      case "ListPropertiesClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, ListPropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return ListPropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ListPropertiesClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      iriListProperty: Maybe<readonly NamedNode[]>;
      objectListProperty: Maybe<readonly NonClass[]>;
      stringListProperty: Maybe<readonly string[]>;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/ListPropertiesClass":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  ListPropertiesClass.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ListPropertiesClass)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, ListPropertiesClass.$Identifier>(
        $parameters.resource.identifier as ListPropertiesClass.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.iriListProperty.identifier,
            { unique: true },
          ),
        )
          .chain((values) => values.chainMap((value) => value.toList()))
          .chain((valueLists) =>
            valueLists.chainMap((valueList) =>
              Either.of<Error, Resource.Values<Resource.TermValue>>(
                Resource.Values.fromArray({
                  focusResource: $parameters.resource,
                  predicate:
                    ListPropertiesClass.$schema.properties.iriListProperty
                      .identifier,
                  values: valueList,
                }),
              ).chain((values) => values.chainMap((value) => value.toIri())),
            ),
          )
          .map((valueLists) =>
            valueLists.map((valueList) => valueList.toArray()),
          )
          .map((values) =>
            values.length > 0
              ? values.map((value) => Maybe.of(value))
              : Resource.Values.fromValue<Maybe<readonly NamedNode[]>>({
                  focusResource: $parameters.resource,
                  predicate:
                    ListPropertiesClass.$schema.properties.iriListProperty
                      .identifier,
                  value: Maybe.empty(),
                }),
          )
          .chain((values) => values.head())
          .chain((iriListProperty) =>
            Either.of<Error, Resource.Values<Resource.TermValue>>(
              $parameters.resource.values(
                $schema.properties.objectListProperty.identifier,
                { unique: true },
              ),
            )
              .chain((values) => values.chainMap((value) => value.toList()))
              .chain((valueLists) =>
                valueLists.chainMap((valueList) =>
                  Either.of<Error, Resource.Values<Resource.TermValue>>(
                    Resource.Values.fromArray({
                      focusResource: $parameters.resource,
                      predicate:
                        ListPropertiesClass.$schema.properties
                          .objectListProperty.identifier,
                      values: valueList,
                    }),
                  ).chain((values) =>
                    values.chainMap((value) =>
                      value.toResource().chain((resource) =>
                        NonClass.$fromRdf(resource, {
                          context: $parameters.context,
                          ignoreRdfType: true,
                          objectSet: $parameters.objectSet,
                          preferredLanguages: $parameters.preferredLanguages,
                        }),
                      ),
                    ),
                  ),
                ),
              )
              .map((valueLists) =>
                valueLists.map((valueList) => valueList.toArray()),
              )
              .map((values) =>
                values.length > 0
                  ? values.map((value) => Maybe.of(value))
                  : Resource.Values.fromValue<Maybe<readonly NonClass[]>>({
                      focusResource: $parameters.resource,
                      predicate:
                        ListPropertiesClass.$schema.properties
                          .objectListProperty.identifier,
                      value: Maybe.empty(),
                    }),
              )
              .chain((values) => values.head())
              .chain((objectListProperty) =>
                Either.of<Error, Resource.Values<Resource.TermValue>>(
                  $parameters.resource.values(
                    $schema.properties.stringListProperty.identifier,
                    { unique: true },
                  ),
                )
                  .chain((values) => values.chainMap((value) => value.toList()))
                  .chain((valueLists) =>
                    valueLists.chainMap((valueList) =>
                      Either.of<Error, Resource.Values<Resource.TermValue>>(
                        Resource.Values.fromArray({
                          focusResource: $parameters.resource,
                          predicate:
                            ListPropertiesClass.$schema.properties
                              .stringListProperty.identifier,
                          values: valueList,
                        }),
                      )
                        .chain((values) =>
                          $fromRdfPreferredLanguages({
                            focusResource: $parameters.resource,
                            predicate:
                              ListPropertiesClass.$schema.properties
                                .stringListProperty.identifier,
                            preferredLanguages: $parameters.preferredLanguages,
                            values,
                          }),
                        )
                        .chain((values) =>
                          values.chainMap((value) => value.toString()),
                        ),
                    ),
                  )
                  .map((valueLists) =>
                    valueLists.map((valueList) => valueList.toArray()),
                  )
                  .map((values) =>
                    values.length > 0
                      ? values.map((value) => Maybe.of(value))
                      : Resource.Values.fromValue<Maybe<readonly string[]>>({
                          focusResource: $parameters.resource,
                          predicate:
                            ListPropertiesClass.$schema.properties
                              .stringListProperty.identifier,
                          value: Maybe.empty(),
                        }),
                  )
                  .chain((values) => values.head())
                  .map((stringListProperty) => ({
                    $identifier,
                    iriListProperty,
                    objectListProperty,
                    stringListProperty,
                  })),
              ),
          ),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["ListPropertiesClass"],
        }),
      },
      iriListProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({
            kind: "List" as const,
            item: () => ({ kind: "NamedNode" as const }),
          }),
        }),
        identifier: dataFactory.namedNode("http://example.com/iriListProperty"),
      },
      objectListProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({ kind: "List" as const, item: () => NonClass.$schema }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/objectListProperty",
        ),
      },
      stringListProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({
            kind: "List" as const,
            item: () => ({ kind: "String" as const }),
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/stringListProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ListPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ListPropertiesClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          ListPropertiesClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ListPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ListPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("listPropertiesClass");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "listPropertiesClass")
          }IriListProperty`,
        ),
        predicate:
          ListPropertiesClass.$schema.properties.iriListProperty.identifier,
        subject: subject,
      },
      ...[
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }IriListProperty`,
          ),
          predicate: $RdfVocabularies.rdf.first,
          object: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }IriListProperty`}Item0`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }IriListProperty`,
          ),
          predicate: $RdfVocabularies.rdf.rest,
          object: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }IriListProperty`}Rest0`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }IriListProperty`}RestN`,
          ),
          predicate: $RdfVocabularies.rdf.first,
          object: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }IriListProperty`}ItemN`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }IriListProperty`}RestN`,
          ),
          predicate: $RdfVocabularies.rdf.rest,
          object: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }IriListProperty`}RestNBasic`,
          ),
        },
      ],
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "listPropertiesClass")
          }ObjectListProperty`,
        ),
        predicate:
          ListPropertiesClass.$schema.properties.objectListProperty.identifier,
        subject: subject,
      },
      ...[
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }ObjectListProperty`,
          ),
          predicate: $RdfVocabularies.rdf.first,
          object: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }ObjectListProperty`}Item0`,
          ),
        },
        ...NonClass.$sparqlConstructTriples({
          ignoreRdfType: true,
          subject: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }ObjectListProperty`}Item0`,
          ),
          variablePrefix: `${`${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "listPropertiesClass")
          }ObjectListProperty`}Item0`,
        }),
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }ObjectListProperty`,
          ),
          predicate: $RdfVocabularies.rdf.rest,
          object: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }ObjectListProperty`}Rest0`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }ObjectListProperty`}RestN`,
          ),
          predicate: $RdfVocabularies.rdf.first,
          object: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }ObjectListProperty`}ItemN`,
          ),
        },
        ...NonClass.$sparqlConstructTriples({
          ignoreRdfType: true,
          subject: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }ObjectListProperty`}ItemN`,
          ),
          variablePrefix: `${`${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "listPropertiesClass")
          }ObjectListProperty`}ItemN`,
        }),
        {
          subject: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }ObjectListProperty`}RestN`,
          ),
          predicate: $RdfVocabularies.rdf.rest,
          object: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }ObjectListProperty`}RestNBasic`,
          ),
        },
      ],
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "listPropertiesClass")
          }StringListProperty`,
        ),
        predicate:
          ListPropertiesClass.$schema.properties.stringListProperty.identifier,
        subject: subject,
      },
      ...[
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }StringListProperty`,
          ),
          predicate: $RdfVocabularies.rdf.first,
          object: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }StringListProperty`}Item0`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }StringListProperty`,
          ),
          predicate: $RdfVocabularies.rdf.rest,
          object: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }StringListProperty`}Rest0`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }StringListProperty`}RestN`,
          ),
          predicate: $RdfVocabularies.rdf.first,
          object: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }StringListProperty`}ItemN`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }StringListProperty`}RestN`,
          ),
          predicate: $RdfVocabularies.rdf.rest,
          object: dataFactory.variable!(
            `${`${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "listPropertiesClass")
            }StringListProperty`}RestNBasic`,
          ),
        },
      ],
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ListPropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("listPropertiesClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "listPropertiesClass")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ListPropertiesClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "listPropertiesClass")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: ListPropertiesClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "listPropertiesClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<
        $CollectionFilter<$NamedNodeFilter>,
        $CollectionSchema<$NamedNodeSchema>
      >(
        $listSparqlWherePatterns<$NamedNodeFilter, $NamedNodeSchema>(
          $namedNodeSparqlWherePatterns,
        ),
      )({
        filter: parameters?.filter?.iriListProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "listPropertiesClass")
                  }IriListProperty`,
                ),
                predicate:
                  ListPropertiesClass.$schema.properties.iriListProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema: ListPropertiesClass.$schema.properties.iriListProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "listPropertiesClass")
          }IriListProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "listPropertiesClass")
        }IriListProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<
        $CollectionFilter<NonClass.$Filter>,
        $CollectionSchema<typeof NonClass.$schema>
      >(
        $listSparqlWherePatterns<NonClass.$Filter, typeof NonClass.$schema>(
          ({
            ignoreRdfType,
            propertyPatterns,
            valueVariable,
            ...otherParameters
          }: $SparqlWherePatternsFunctionParameters<
            NonClass.$Filter,
            typeof NonClass.$schema
          >) =>
            (propertyPatterns as readonly $SparqlPattern[]).concat(
              NonClass.$sparqlWherePatterns({
                ignoreRdfType: ignoreRdfType ?? true,
                subject: valueVariable,
                ...otherParameters,
              }),
            ),
        ),
      )({
        filter: parameters?.filter?.objectListProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "listPropertiesClass")
                  }ObjectListProperty`,
                ),
                predicate:
                  ListPropertiesClass.$schema.properties.objectListProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ListPropertiesClass.$schema.properties.objectListProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "listPropertiesClass")
          }ObjectListProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "listPropertiesClass")
        }ObjectListProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<
        $CollectionFilter<$StringFilter>,
        $CollectionSchema<$StringSchema>
      >(
        $listSparqlWherePatterns<$StringFilter, $StringSchema>(
          $stringSparqlWherePatterns,
        ),
      )({
        filter: parameters?.filter?.stringListProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "listPropertiesClass")
                  }StringListProperty`,
                ),
                predicate:
                  ListPropertiesClass.$schema.properties.stringListProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ListPropertiesClass.$schema.properties.stringListProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "listPropertiesClass")
          }StringListProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "listPropertiesClass")
        }StringListProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Node shape used as a partial by LazyPropertiesInterface
 */

export interface PartialInterface {
  readonly $identifier: PartialInterface.$Identifier;
  readonly $type: "PartialInterface";
  readonly lazilyResolvedStringProperty: string;
}

export namespace PartialInterface {
  export function $create(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): PartialInterface {
    let $identifier: PartialInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }
    const $type = "PartialInterface" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: PartialInterface,
    right: PartialInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  export function $hash<HasherT extends $Hasher>(
    _partialInterface: PartialInterface,
    _hasher: HasherT,
  ): HasherT {
    PartialInterface.$hashShaclProperties(_partialInterface, _hasher);
    _hasher.update(_partialInterface.$identifier.value);
    _hasher.update(_partialInterface.$type);
    return _hasher;
  }

  export function $hashShaclProperties<HasherT extends $Hasher>(
    _partialInterface: PartialInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_partialInterface.lazilyResolvedStringProperty);
    return _hasher;
  }

  export function $filter(
    filter: PartialInterface.$Filter,
    value: PartialInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      $type: "PartialInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "PartialInterface" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return Either.of({ $identifier, $type, lazilyResolvedStringProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, PartialInterface> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialInterface" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialInterface",
      type: "Group",
    };
  }

  export function $toJson(
    _partialInterface: PartialInterface,
  ): PartialInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _partialInterface.$identifier.termType === "BlankNode"
            ? `_:${_partialInterface.$identifier.value}`
            : _partialInterface.$identifier.value,
        $type: _partialInterface.$type,
        lazilyResolvedStringProperty:
          _partialInterface.lazilyResolvedStringProperty,
      } satisfies PartialInterface.$Json),
    );
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("PartialInterface"),
      lazilyResolvedStringProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialInterface";
    readonly lazilyResolvedStringProperty: string;
  };

  export function isPartialInterface(
    object: $Object,
  ): object is PartialInterface {
    switch (object.$type) {
      case "PartialInterface":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, PartialInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return PartialInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      $type: "PartialInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    return Either.of<Error, PartialInterface.$Identifier>(
      $parameters.resource.identifier as PartialInterface.$Identifier,
    ).chain(($identifier) =>
      Either.of<Error, "PartialInterface">("PartialInterface" as const).chain(
        ($type) =>
          Either.of<Error, Resource.Values<Resource.TermValue>>(
            $parameters.resource.values(
              $schema.properties.lazilyResolvedStringProperty.identifier,
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  PartialInterface.$schema.properties
                    .lazilyResolvedStringProperty.identifier,
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((lazilyResolvedStringProperty) => ({
              $identifier,
              $type,
              lazilyResolvedStringProperty,
            })),
      ),
    );
  }

  export function $toRdf(
    _partialInterface: PartialInterface,
    options?: {
      ignoreRdfType?: boolean;
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(_partialInterface.$identifier);
    resource.add(
      PartialInterface.$schema.properties.lazilyResolvedStringProperty
        .identifier,
      [$literalFactory.string(_partialInterface.lazilyResolvedStringProperty)],
      options?.graph,
    );
    return resource;
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["PartialInterface"],
        }),
      },
      lazilyResolvedStringProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/lazilyResolvedStringProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialInterface.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          PartialInterface.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialInterface");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "partialInterface")
          }LazilyResolvedStringProperty`,
        ),
        predicate:
          PartialInterface.$schema.properties.lazilyResolvedStringProperty
            .identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialInterface");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: PartialInterface.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "partialInterface"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.lazilyResolvedStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "partialInterface")
                  }LazilyResolvedStringProperty`,
                ),
                predicate:
                  PartialInterface.$schema.properties
                    .lazilyResolvedStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          PartialInterface.$schema.properties.lazilyResolvedStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "partialInterface")
          }LazilyResolvedStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable" ? subject.value : "partialInterface")
        }LazilyResolvedStringProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Node shape that has lazy properties.
 */

export interface LazyPropertiesInterface {
  readonly $identifier: LazyPropertiesInterface.$Identifier;
  readonly $type: "LazyPropertiesInterface";
  readonly optionalLazyToResolvedInterfaceProperty: $LazyObjectOption<
    LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriIdentifierInterface
  >;
  readonly optionalLazyToResolvedInterfaceUnionProperty: $LazyObjectOption<
    LazilyResolvedInterfaceUnion.$Identifier,
    $DefaultPartial,
    LazilyResolvedInterfaceUnion
  >;
  readonly optionalLazyToResolvedIriIdentifierInterfaceProperty: $LazyObjectOption<
    LazilyResolvedIriIdentifierInterface.$Identifier,
    $NamedDefaultPartial,
    LazilyResolvedIriIdentifierInterface
  >;
  readonly optionalPartialInterfaceToResolvedInterfaceProperty: $LazyObjectOption<
    LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
    PartialInterface,
    LazilyResolvedBlankNodeOrIriIdentifierInterface
  >;
  readonly optionalPartialInterfaceToResolvedInterfaceUnionProperty: $LazyObjectOption<
    LazilyResolvedInterfaceUnion.$Identifier,
    PartialInterface,
    LazilyResolvedInterfaceUnion
  >;
  readonly optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty: $LazyObjectOption<
    LazilyResolvedInterfaceUnion.$Identifier,
    PartialInterfaceUnion,
    LazilyResolvedInterfaceUnion
  >;
  readonly requiredLazyToResolvedInterfaceProperty: $LazyObject<
    LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriIdentifierInterface
  >;
  readonly requiredPartialInterfaceToResolvedInterfaceProperty: $LazyObject<
    LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
    PartialInterface,
    LazilyResolvedBlankNodeOrIriIdentifierInterface
  >;
  readonly setLazyToResolvedInterfaceProperty: $LazyObjectSet<
    LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriIdentifierInterface
  >;
  readonly setPartialInterfaceToResolvedInterfaceProperty: $LazyObjectSet<
    LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
    PartialInterface,
    LazilyResolvedBlankNodeOrIriIdentifierInterface
  >;
}

export namespace LazyPropertiesInterface {
  export function $create(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly optionalLazyToResolvedInterfaceProperty?:
      | $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >
      | Maybe<LazilyResolvedBlankNodeOrIriIdentifierInterface>
      | LazilyResolvedBlankNodeOrIriIdentifierInterface;
    readonly optionalLazyToResolvedInterfaceUnionProperty?:
      | $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          $DefaultPartial,
          LazilyResolvedInterfaceUnion
        >
      | Maybe<LazilyResolvedInterfaceUnion>
      | LazilyResolvedInterfaceUnion;
    readonly optionalLazyToResolvedIriIdentifierInterfaceProperty?:
      | $LazyObjectOption<
          LazilyResolvedIriIdentifierInterface.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierInterface
        >
      | Maybe<LazilyResolvedIriIdentifierInterface>
      | LazilyResolvedIriIdentifierInterface;
    readonly optionalPartialInterfaceToResolvedInterfaceProperty?:
      | $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >
      | Maybe<LazilyResolvedBlankNodeOrIriIdentifierInterface>
      | LazilyResolvedBlankNodeOrIriIdentifierInterface;
    readonly optionalPartialInterfaceToResolvedInterfaceUnionProperty?:
      | $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterface,
          LazilyResolvedInterfaceUnion
        >
      | Maybe<LazilyResolvedInterfaceUnion>
      | LazilyResolvedInterfaceUnion;
    readonly optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty?:
      | $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterfaceUnion,
          LazilyResolvedInterfaceUnion
        >
      | Maybe<LazilyResolvedInterfaceUnion>
      | LazilyResolvedInterfaceUnion;
    readonly requiredLazyToResolvedInterfaceProperty:
      | $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >
      | LazilyResolvedBlankNodeOrIriIdentifierInterface;
    readonly requiredPartialInterfaceToResolvedInterfaceProperty:
      | $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >
      | LazilyResolvedBlankNodeOrIriIdentifierInterface;
    readonly setLazyToResolvedInterfaceProperty?:
      | $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >
      | readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[];
    readonly setPartialInterfaceToResolvedInterfaceProperty?:
      | $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >
      | readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[];
  }): LazyPropertiesInterface {
    let $identifier: LazyPropertiesInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }
    const $type = "LazyPropertiesInterface" as const;
    let optionalLazyToResolvedInterfaceProperty: $LazyObjectOption<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >;
    if (
      typeof parameters.optionalLazyToResolvedInterfaceProperty === "object" &&
      parameters.optionalLazyToResolvedInterfaceProperty instanceof
        $LazyObjectOption
    ) {
      optionalLazyToResolvedInterfaceProperty =
        parameters.optionalLazyToResolvedInterfaceProperty;
    } else if (
      Maybe.isMaybe(parameters.optionalLazyToResolvedInterfaceProperty)
    ) {
      optionalLazyToResolvedInterfaceProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partial: parameters.optionalLazyToResolvedInterfaceProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          Either.of(
            (
              parameters.optionalLazyToResolvedInterfaceProperty as Maybe<LazilyResolvedBlankNodeOrIriIdentifierInterface>
            ).unsafeCoerce(),
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedInterfaceProperty === "object"
    ) {
      optionalLazyToResolvedInterfaceProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partial: Maybe.of(
          new $DefaultPartial(
            parameters.optionalLazyToResolvedInterfaceProperty,
          ),
        ),
        resolver: async () =>
          Either.of(
            parameters.optionalLazyToResolvedInterfaceProperty as LazilyResolvedBlankNodeOrIriIdentifierInterface,
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedInterfaceProperty === "undefined"
    ) {
      optionalLazyToResolvedInterfaceProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partial: Maybe.empty(),
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      optionalLazyToResolvedInterfaceProperty =
        parameters.optionalLazyToResolvedInterfaceProperty satisfies never;
    }
    let optionalLazyToResolvedInterfaceUnionProperty: $LazyObjectOption<
      LazilyResolvedInterfaceUnion.$Identifier,
      $DefaultPartial,
      LazilyResolvedInterfaceUnion
    >;
    if (
      typeof parameters.optionalLazyToResolvedInterfaceUnionProperty ===
        "object" &&
      parameters.optionalLazyToResolvedInterfaceUnionProperty instanceof
        $LazyObjectOption
    ) {
      optionalLazyToResolvedInterfaceUnionProperty =
        parameters.optionalLazyToResolvedInterfaceUnionProperty;
    } else if (
      Maybe.isMaybe(parameters.optionalLazyToResolvedInterfaceUnionProperty)
    ) {
      optionalLazyToResolvedInterfaceUnionProperty = new $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >({
        partial: parameters.optionalLazyToResolvedInterfaceUnionProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          Either.of(
            (
              parameters.optionalLazyToResolvedInterfaceUnionProperty as Maybe<LazilyResolvedInterfaceUnion>
            ).unsafeCoerce(),
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedInterfaceUnionProperty ===
      "object"
    ) {
      optionalLazyToResolvedInterfaceUnionProperty = new $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >({
        partial: Maybe.of(
          new $DefaultPartial(
            parameters.optionalLazyToResolvedInterfaceUnionProperty,
          ),
        ),
        resolver: async () =>
          Either.of(
            parameters.optionalLazyToResolvedInterfaceUnionProperty as LazilyResolvedInterfaceUnion,
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedInterfaceUnionProperty ===
      "undefined"
    ) {
      optionalLazyToResolvedInterfaceUnionProperty = new $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >({
        partial: Maybe.empty(),
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      optionalLazyToResolvedInterfaceUnionProperty =
        parameters.optionalLazyToResolvedInterfaceUnionProperty satisfies never;
    }
    let optionalLazyToResolvedIriIdentifierInterfaceProperty: $LazyObjectOption<
      LazilyResolvedIriIdentifierInterface.$Identifier,
      $NamedDefaultPartial,
      LazilyResolvedIriIdentifierInterface
    >;
    if (
      typeof parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty ===
        "object" &&
      parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty instanceof
        $LazyObjectOption
    ) {
      optionalLazyToResolvedIriIdentifierInterfaceProperty =
        parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty;
    } else if (
      Maybe.isMaybe(
        parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty,
      )
    ) {
      optionalLazyToResolvedIriIdentifierInterfaceProperty =
        new $LazyObjectOption<
          LazilyResolvedIriIdentifierInterface.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierInterface
        >({
          partial:
            parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty.map(
              (object) => new $NamedDefaultPartial(object),
            ),
          resolver: async () =>
            Either.of(
              (
                parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty as Maybe<LazilyResolvedIriIdentifierInterface>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty ===
      "object"
    ) {
      optionalLazyToResolvedIriIdentifierInterfaceProperty =
        new $LazyObjectOption<
          LazilyResolvedIriIdentifierInterface.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierInterface
        >({
          partial: Maybe.of(
            new $NamedDefaultPartial(
              parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty,
            ),
          ),
          resolver: async () =>
            Either.of(
              parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty as LazilyResolvedIriIdentifierInterface,
            ),
        });
    } else if (
      typeof parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty ===
      "undefined"
    ) {
      optionalLazyToResolvedIriIdentifierInterfaceProperty =
        new $LazyObjectOption<
          LazilyResolvedIriIdentifierInterface.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierInterface
        >({
          partial: Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      optionalLazyToResolvedIriIdentifierInterfaceProperty =
        parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty satisfies never;
    }
    let optionalPartialInterfaceToResolvedInterfaceProperty: $LazyObjectOption<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      PartialInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >;
    if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceProperty ===
        "object" &&
      parameters.optionalPartialInterfaceToResolvedInterfaceProperty instanceof
        $LazyObjectOption
    ) {
      optionalPartialInterfaceToResolvedInterfaceProperty =
        parameters.optionalPartialInterfaceToResolvedInterfaceProperty;
    } else if (
      Maybe.isMaybe(
        parameters.optionalPartialInterfaceToResolvedInterfaceProperty,
      )
    ) {
      optionalPartialInterfaceToResolvedInterfaceProperty =
        new $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >({
          partial:
            parameters.optionalPartialInterfaceToResolvedInterfaceProperty.map(
              (object) => PartialInterface.$create(object),
            ),
          resolver: async () =>
            Either.of(
              (
                parameters.optionalPartialInterfaceToResolvedInterfaceProperty as Maybe<LazilyResolvedBlankNodeOrIriIdentifierInterface>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceProperty ===
      "object"
    ) {
      optionalPartialInterfaceToResolvedInterfaceProperty =
        new $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >({
          partial: Maybe.of(
            PartialInterface.$create(
              parameters.optionalPartialInterfaceToResolvedInterfaceProperty,
            ),
          ),
          resolver: async () =>
            Either.of(
              parameters.optionalPartialInterfaceToResolvedInterfaceProperty as LazilyResolvedBlankNodeOrIriIdentifierInterface,
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceProperty ===
      "undefined"
    ) {
      optionalPartialInterfaceToResolvedInterfaceProperty =
        new $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >({
          partial: Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      optionalPartialInterfaceToResolvedInterfaceProperty =
        parameters.optionalPartialInterfaceToResolvedInterfaceProperty satisfies never;
    }
    let optionalPartialInterfaceToResolvedInterfaceUnionProperty: $LazyObjectOption<
      LazilyResolvedInterfaceUnion.$Identifier,
      PartialInterface,
      LazilyResolvedInterfaceUnion
    >;
    if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty ===
        "object" &&
      parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty instanceof
        $LazyObjectOption
    ) {
      optionalPartialInterfaceToResolvedInterfaceUnionProperty =
        parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty;
    } else if (
      Maybe.isMaybe(
        parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
      )
    ) {
      optionalPartialInterfaceToResolvedInterfaceUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterface,
          LazilyResolvedInterfaceUnion
        >({
          partial:
            parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty.map(
              (object) => PartialInterface.$create(object),
            ),
          resolver: async () =>
            Either.of(
              (
                parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty as Maybe<LazilyResolvedInterfaceUnion>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty ===
      "object"
    ) {
      optionalPartialInterfaceToResolvedInterfaceUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterface,
          LazilyResolvedInterfaceUnion
        >({
          partial: Maybe.of(
            PartialInterface.$create(
              parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
            ),
          ),
          resolver: async () =>
            Either.of(
              parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty as LazilyResolvedInterfaceUnion,
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty ===
      "undefined"
    ) {
      optionalPartialInterfaceToResolvedInterfaceUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterface,
          LazilyResolvedInterfaceUnion
        >({
          partial: Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      optionalPartialInterfaceToResolvedInterfaceUnionProperty =
        parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty satisfies never;
    }
    let optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty: $LazyObjectOption<
      LazilyResolvedInterfaceUnion.$Identifier,
      PartialInterfaceUnion,
      LazilyResolvedInterfaceUnion
    >;
    if (
      typeof parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty ===
        "object" &&
      parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty instanceof
        $LazyObjectOption
    ) {
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
        parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty;
    } else if (
      Maybe.isMaybe(
        parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
      )
    ) {
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterfaceUnion,
          LazilyResolvedInterfaceUnion
        >({
          partial:
            parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty.map(
              (object) => {
                switch (object.$type) {
                  case "LazilyResolvedInterfaceUnionMember1":
                    return PartialInterfaceUnionMember1.$create(object);
                  case "LazilyResolvedInterfaceUnionMember2":
                    return PartialInterfaceUnionMember2.$create(object);
                  default:
                    object satisfies never;
                    throw new Error("unrecognized type");
                }
              },
            ),
          resolver: async () =>
            Either.of(
              (
                parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty as Maybe<LazilyResolvedInterfaceUnion>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty ===
      "object"
    ) {
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterfaceUnion,
          LazilyResolvedInterfaceUnion
        >({
          partial: Maybe.of(
            parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
          ).map((object) => {
            switch (object.$type) {
              case "LazilyResolvedInterfaceUnionMember1":
                return PartialInterfaceUnionMember1.$create(object);
              case "LazilyResolvedInterfaceUnionMember2":
                return PartialInterfaceUnionMember2.$create(object);
              default:
                object satisfies never;
                throw new Error("unrecognized type");
            }
          }),
          resolver: async () =>
            Either.of(
              parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty as LazilyResolvedInterfaceUnion,
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty ===
      "undefined"
    ) {
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterfaceUnion,
          LazilyResolvedInterfaceUnion
        >({
          partial: Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
        parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty satisfies never;
    }
    let requiredLazyToResolvedInterfaceProperty: $LazyObject<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >;
    if (
      typeof parameters.requiredLazyToResolvedInterfaceProperty === "object" &&
      parameters.requiredLazyToResolvedInterfaceProperty instanceof $LazyObject
    ) {
      requiredLazyToResolvedInterfaceProperty =
        parameters.requiredLazyToResolvedInterfaceProperty;
    } else if (
      typeof parameters.requiredLazyToResolvedInterfaceProperty === "object"
    ) {
      requiredLazyToResolvedInterfaceProperty = new $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partial: new $DefaultPartial(
          parameters.requiredLazyToResolvedInterfaceProperty,
        ),
        resolver: async () =>
          Either.of(
            parameters.requiredLazyToResolvedInterfaceProperty as LazilyResolvedBlankNodeOrIriIdentifierInterface,
          ),
      });
    } else {
      requiredLazyToResolvedInterfaceProperty =
        parameters.requiredLazyToResolvedInterfaceProperty satisfies never;
    }
    let requiredPartialInterfaceToResolvedInterfaceProperty: $LazyObject<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      PartialInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >;
    if (
      typeof parameters.requiredPartialInterfaceToResolvedInterfaceProperty ===
        "object" &&
      parameters.requiredPartialInterfaceToResolvedInterfaceProperty instanceof
        $LazyObject
    ) {
      requiredPartialInterfaceToResolvedInterfaceProperty =
        parameters.requiredPartialInterfaceToResolvedInterfaceProperty;
    } else if (
      typeof parameters.requiredPartialInterfaceToResolvedInterfaceProperty ===
      "object"
    ) {
      requiredPartialInterfaceToResolvedInterfaceProperty = new $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partial: PartialInterface.$create(
          parameters.requiredPartialInterfaceToResolvedInterfaceProperty,
        ),
        resolver: async () =>
          Either.of(
            parameters.requiredPartialInterfaceToResolvedInterfaceProperty as LazilyResolvedBlankNodeOrIriIdentifierInterface,
          ),
      });
    } else {
      requiredPartialInterfaceToResolvedInterfaceProperty =
        parameters.requiredPartialInterfaceToResolvedInterfaceProperty satisfies never;
    }
    let setLazyToResolvedInterfaceProperty: $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >;
    if (
      typeof parameters.setLazyToResolvedInterfaceProperty === "object" &&
      parameters.setLazyToResolvedInterfaceProperty instanceof $LazyObjectSet
    ) {
      setLazyToResolvedInterfaceProperty =
        parameters.setLazyToResolvedInterfaceProperty;
    } else if (
      typeof parameters.setLazyToResolvedInterfaceProperty === "object"
    ) {
      setLazyToResolvedInterfaceProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partials: parameters.setLazyToResolvedInterfaceProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          Either.of(
            parameters.setLazyToResolvedInterfaceProperty as readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[],
          ),
      });
    } else if (
      typeof parameters.setLazyToResolvedInterfaceProperty === "undefined"
    ) {
      setLazyToResolvedInterfaceProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partials: [],
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      setLazyToResolvedInterfaceProperty =
        parameters.setLazyToResolvedInterfaceProperty satisfies never;
    }
    let setPartialInterfaceToResolvedInterfaceProperty: $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      PartialInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >;
    if (
      typeof parameters.setPartialInterfaceToResolvedInterfaceProperty ===
        "object" &&
      parameters.setPartialInterfaceToResolvedInterfaceProperty instanceof
        $LazyObjectSet
    ) {
      setPartialInterfaceToResolvedInterfaceProperty =
        parameters.setPartialInterfaceToResolvedInterfaceProperty;
    } else if (
      typeof parameters.setPartialInterfaceToResolvedInterfaceProperty ===
      "object"
    ) {
      setPartialInterfaceToResolvedInterfaceProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partials: parameters.setPartialInterfaceToResolvedInterfaceProperty.map(
          (object) => PartialInterface.$create(object),
        ),
        resolver: async () =>
          Either.of(
            parameters.setPartialInterfaceToResolvedInterfaceProperty as readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[],
          ),
      });
    } else if (
      typeof parameters.setPartialInterfaceToResolvedInterfaceProperty ===
      "undefined"
    ) {
      setPartialInterfaceToResolvedInterfaceProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partials: [],
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      setPartialInterfaceToResolvedInterfaceProperty =
        parameters.setPartialInterfaceToResolvedInterfaceProperty satisfies never;
    }
    return {
      $identifier,
      $type,
      optionalLazyToResolvedInterfaceProperty,
      optionalLazyToResolvedInterfaceUnionProperty,
      optionalLazyToResolvedIriIdentifierInterfaceProperty,
      optionalPartialInterfaceToResolvedInterfaceProperty,
      optionalPartialInterfaceToResolvedInterfaceUnionProperty,
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
      requiredLazyToResolvedInterfaceProperty,
      requiredPartialInterfaceToResolvedInterfaceProperty,
      setLazyToResolvedInterfaceProperty,
      setPartialInterfaceToResolvedInterfaceProperty,
    };
  }

  export function $equals(
    left: LazyPropertiesInterface,
    right: LazyPropertiesInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          left.optionalLazyToResolvedInterfaceProperty,
          right.optionalLazyToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "optionalLazyToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          left.optionalLazyToResolvedInterfaceUnionProperty,
          right.optionalLazyToResolvedInterfaceUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "optionalLazyToResolvedInterfaceUnionProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          left.optionalLazyToResolvedIriIdentifierInterfaceProperty,
          right.optionalLazyToResolvedIriIdentifierInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "optionalLazyToResolvedIriIdentifierInterfaceProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, PartialInterface.$equals))(
            left.partial,
            right.partial,
          ))(
          left.optionalPartialInterfaceToResolvedInterfaceProperty,
          right.optionalPartialInterfaceToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "optionalPartialInterfaceToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, PartialInterface.$equals))(
            left.partial,
            right.partial,
          ))(
          left.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
          right.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName:
            "optionalPartialInterfaceToResolvedInterfaceUnionProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, PartialInterfaceUnion.$equals))(
            left.partial,
            right.partial,
          ))(
          left.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
          right.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName:
            "optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) => left.$equals(right))(left.partial, right.partial))(
          left.requiredLazyToResolvedInterfaceProperty,
          right.requiredLazyToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "requiredLazyToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          PartialInterface.$equals(left.partial, right.partial))(
          left.requiredPartialInterfaceToResolvedInterfaceProperty,
          right.requiredPartialInterfaceToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "requiredPartialInterfaceToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $arrayEquals(left, right, (left, right) => left.$equals(right)))(
            left.partials,
            right.partials,
          ))(
          left.setLazyToResolvedInterfaceProperty,
          right.setLazyToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "setLazyToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $arrayEquals(left, right, PartialInterface.$equals))(
            left.partials,
            right.partials,
          ))(
          left.setPartialInterfaceToResolvedInterfaceProperty,
          right.setPartialInterfaceToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "setPartialInterfaceToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  export function $hash<HasherT extends $Hasher>(
    _lazyPropertiesInterface: LazyPropertiesInterface,
    _hasher: HasherT,
  ): HasherT {
    LazyPropertiesInterface.$hashShaclProperties(
      _lazyPropertiesInterface,
      _hasher,
    );
    _hasher.update(_lazyPropertiesInterface.$identifier.value);
    _hasher.update(_lazyPropertiesInterface.$type);
    return _hasher;
  }

  export function $hashShaclProperties<HasherT extends $Hasher>(
    _lazyPropertiesInterface: LazyPropertiesInterface,
    _hasher: HasherT,
  ): HasherT {
    _lazyPropertiesInterface.optionalLazyToResolvedInterfaceProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    _lazyPropertiesInterface.optionalLazyToResolvedInterfaceUnionProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    _lazyPropertiesInterface.optionalLazyToResolvedIriIdentifierInterfaceProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    _lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceProperty.partial.ifJust(
      (value1) => {
        PartialInterface.$hash(value1, _hasher);
      },
    );
    _lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceUnionProperty.partial.ifJust(
      (value1) => {
        PartialInterface.$hash(value1, _hasher);
      },
    );
    _lazyPropertiesInterface.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty.partial.ifJust(
      (value1) => {
        PartialInterfaceUnion.$hash(value1, _hasher);
      },
    );
    _lazyPropertiesInterface.requiredLazyToResolvedInterfaceProperty.partial.$hash(
      _hasher,
    );
    PartialInterface.$hash(
      _lazyPropertiesInterface
        .requiredPartialInterfaceToResolvedInterfaceProperty.partial,
      _hasher,
    );
    for (const item1 of _lazyPropertiesInterface
      .setLazyToResolvedInterfaceProperty.partials) {
      item1.$hash(_hasher);
    }
    for (const item1 of _lazyPropertiesInterface
      .setPartialInterfaceToResolvedInterfaceProperty.partials) {
      PartialInterface.$hash(item1, _hasher);
    }
    return _hasher;
  }

  export function $filter(
    filter: LazyPropertiesInterface.$Filter,
    value: LazyPropertiesInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.optionalLazyToResolvedInterfaceProperty !== "undefined" &&
      !((
        filter: $MaybeFilter<$DefaultPartial.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >,
      ) =>
        $filterMaybe<$DefaultPartial, $DefaultPartial.$Filter>(
          $DefaultPartial.$filter,
        )(filter, value.partial))(
        filter.optionalLazyToResolvedInterfaceProperty,
        value.optionalLazyToResolvedInterfaceProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.optionalLazyToResolvedInterfaceUnionProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<$DefaultPartial.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          $DefaultPartial,
          LazilyResolvedInterfaceUnion
        >,
      ) =>
        $filterMaybe<$DefaultPartial, $DefaultPartial.$Filter>(
          $DefaultPartial.$filter,
        )(filter, value.partial))(
        filter.optionalLazyToResolvedInterfaceUnionProperty,
        value.optionalLazyToResolvedInterfaceUnionProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.optionalLazyToResolvedIriIdentifierInterfaceProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<$NamedDefaultPartial.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedIriIdentifierInterface.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierInterface
        >,
      ) =>
        $filterMaybe<$NamedDefaultPartial, $NamedDefaultPartial.$Filter>(
          $NamedDefaultPartial.$filter,
        )(filter, value.partial))(
        filter.optionalLazyToResolvedIriIdentifierInterfaceProperty,
        value.optionalLazyToResolvedIriIdentifierInterfaceProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.optionalPartialInterfaceToResolvedInterfaceProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<PartialInterface.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >,
      ) =>
        $filterMaybe<PartialInterface, PartialInterface.$Filter>(
          PartialInterface.$filter,
        )(filter, value.partial))(
        filter.optionalPartialInterfaceToResolvedInterfaceProperty,
        value.optionalPartialInterfaceToResolvedInterfaceProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.optionalPartialInterfaceToResolvedInterfaceUnionProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<PartialInterface.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterface,
          LazilyResolvedInterfaceUnion
        >,
      ) =>
        $filterMaybe<PartialInterface, PartialInterface.$Filter>(
          PartialInterface.$filter,
        )(filter, value.partial))(
        filter.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
        value.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<PartialInterfaceUnion.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterfaceUnion,
          LazilyResolvedInterfaceUnion
        >,
      ) =>
        $filterMaybe<PartialInterfaceUnion, PartialInterfaceUnion.$Filter>(
          PartialInterfaceUnion.$filter,
        )(filter, value.partial))(
        filter.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
        value.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.requiredLazyToResolvedInterfaceProperty !== "undefined" &&
      !((
        filter: $DefaultPartial.$Filter,
        value: $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >,
      ) => $DefaultPartial.$filter(filter, value.partial))(
        filter.requiredLazyToResolvedInterfaceProperty,
        value.requiredLazyToResolvedInterfaceProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.requiredPartialInterfaceToResolvedInterfaceProperty !==
        "undefined" &&
      !((
        filter: PartialInterface.$Filter,
        value: $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >,
      ) => PartialInterface.$filter(filter, value.partial))(
        filter.requiredPartialInterfaceToResolvedInterfaceProperty,
        value.requiredPartialInterfaceToResolvedInterfaceProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.setLazyToResolvedInterfaceProperty !== "undefined" &&
      !((
        filter: $CollectionFilter<$DefaultPartial.$Filter>,
        value: $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >,
      ) =>
        $filterArray<$DefaultPartial, $DefaultPartial.$Filter>(
          $DefaultPartial.$filter,
        )(filter, value.partials))(
        filter.setLazyToResolvedInterfaceProperty,
        value.setLazyToResolvedInterfaceProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.setPartialInterfaceToResolvedInterfaceProperty !==
        "undefined" &&
      !((
        filter: $CollectionFilter<PartialInterface.$Filter>,
        value: $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >,
      ) =>
        $filterArray<PartialInterface, PartialInterface.$Filter>(
          PartialInterface.$filter,
        )(filter, value.partials))(
        filter.setPartialInterfaceToResolvedInterfaceProperty,
        value.setPartialInterfaceToResolvedInterfaceProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly optionalLazyToResolvedInterfaceProperty?: $MaybeFilter<$DefaultPartial.$Filter>;
    readonly optionalLazyToResolvedInterfaceUnionProperty?: $MaybeFilter<$DefaultPartial.$Filter>;
    readonly optionalLazyToResolvedIriIdentifierInterfaceProperty?: $MaybeFilter<$NamedDefaultPartial.$Filter>;
    readonly optionalPartialInterfaceToResolvedInterfaceProperty?: $MaybeFilter<PartialInterface.$Filter>;
    readonly optionalPartialInterfaceToResolvedInterfaceUnionProperty?: $MaybeFilter<PartialInterface.$Filter>;
    readonly optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty?: $MaybeFilter<PartialInterfaceUnion.$Filter>;
    readonly requiredLazyToResolvedInterfaceProperty?: $DefaultPartial.$Filter;
    readonly requiredPartialInterfaceToResolvedInterfaceProperty?: PartialInterface.$Filter;
    readonly setLazyToResolvedInterfaceProperty?: $CollectionFilter<$DefaultPartial.$Filter>;
    readonly setPartialInterfaceToResolvedInterfaceProperty?: $CollectionFilter<PartialInterface.$Filter>;
  };

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      $type: "LazyPropertiesInterface";
      optionalLazyToResolvedInterfaceProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      optionalLazyToResolvedInterfaceUnionProperty: $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >;
      optionalLazyToResolvedIriIdentifierInterfaceProperty: $LazyObjectOption<
        LazilyResolvedIriIdentifierInterface.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriIdentifierInterface
      >;
      optionalPartialInterfaceToResolvedInterfaceProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      optionalPartialInterfaceToResolvedInterfaceUnionProperty: $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterface,
        LazilyResolvedInterfaceUnion
      >;
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty: $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterfaceUnion,
        LazilyResolvedInterfaceUnion
      >;
      requiredLazyToResolvedInterfaceProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      requiredPartialInterfaceToResolvedInterfaceProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      setLazyToResolvedInterfaceProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      setPartialInterfaceToResolvedInterfaceProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "LazyPropertiesInterface" as const;
    const optionalLazyToResolvedInterfaceProperty = new $LazyObjectOption<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >({
      partial: Maybe.fromNullable(
        $jsonObject["optionalLazyToResolvedInterfaceProperty"],
      ).map((item) => $DefaultPartial.$fromJson(item).unsafeCoerce()),
      resolver: (identifier) =>
        Promise.resolve(
          Left(
            new Error(
              `unable to resolve identifier ${Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const optionalLazyToResolvedInterfaceUnionProperty = new $LazyObjectOption<
      LazilyResolvedInterfaceUnion.$Identifier,
      $DefaultPartial,
      LazilyResolvedInterfaceUnion
    >({
      partial: Maybe.fromNullable(
        $jsonObject["optionalLazyToResolvedInterfaceUnionProperty"],
      ).map((item) => $DefaultPartial.$fromJson(item).unsafeCoerce()),
      resolver: (identifier) =>
        Promise.resolve(
          Left(
            new Error(
              `unable to resolve identifier ${Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const optionalLazyToResolvedIriIdentifierInterfaceProperty =
      new $LazyObjectOption<
        LazilyResolvedIriIdentifierInterface.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriIdentifierInterface
      >({
        partial: Maybe.fromNullable(
          $jsonObject["optionalLazyToResolvedIriIdentifierInterfaceProperty"],
        ).map((item) => $NamedDefaultPartial.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            Left(
              new Error(
                `unable to resolve identifier ${Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const optionalPartialInterfaceToResolvedInterfaceProperty =
      new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partial: Maybe.fromNullable(
          $jsonObject["optionalPartialInterfaceToResolvedInterfaceProperty"],
        ).map((item) => PartialInterface.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            Left(
              new Error(
                `unable to resolve identifier ${Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const optionalPartialInterfaceToResolvedInterfaceUnionProperty =
      new $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterface,
        LazilyResolvedInterfaceUnion
      >({
        partial: Maybe.fromNullable(
          $jsonObject[
            "optionalPartialInterfaceToResolvedInterfaceUnionProperty"
          ],
        ).map((item) => PartialInterface.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            Left(
              new Error(
                `unable to resolve identifier ${Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
      new $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterfaceUnion,
        LazilyResolvedInterfaceUnion
      >({
        partial: Maybe.fromNullable(
          $jsonObject[
            "optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty"
          ],
        ).map((item) => PartialInterfaceUnion.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            Left(
              new Error(
                `unable to resolve identifier ${Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const requiredLazyToResolvedInterfaceProperty = new $LazyObject<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >({
      partial: $DefaultPartial
        .$fromJson($jsonObject["requiredLazyToResolvedInterfaceProperty"])
        .unsafeCoerce(),
      resolver: (identifier) =>
        Promise.resolve(
          Left(
            new Error(
              `unable to resolve identifier ${Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const requiredPartialInterfaceToResolvedInterfaceProperty = new $LazyObject<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      PartialInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >({
      partial: PartialInterface.$fromJson(
        $jsonObject["requiredPartialInterfaceToResolvedInterfaceProperty"],
      ).unsafeCoerce(),
      resolver: (identifier) =>
        Promise.resolve(
          Left(
            new Error(
              `unable to resolve identifier ${Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const setLazyToResolvedInterfaceProperty = new $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >({
      partials: $jsonObject["setLazyToResolvedInterfaceProperty"].map((item) =>
        $DefaultPartial.$fromJson(item).unsafeCoerce(),
      ),
      resolver: () =>
        Promise.resolve(
          Left(
            new Error("unable to resolve identifiers deserialized from JSON"),
          ),
        ),
    });
    const setPartialInterfaceToResolvedInterfaceProperty = new $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      PartialInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >({
      partials: $jsonObject[
        "setPartialInterfaceToResolvedInterfaceProperty"
      ].map((item) => PartialInterface.$fromJson(item).unsafeCoerce()),
      resolver: () =>
        Promise.resolve(
          Left(
            new Error("unable to resolve identifiers deserialized from JSON"),
          ),
        ),
    });
    return Either.of({
      $identifier,
      $type,
      optionalLazyToResolvedInterfaceProperty,
      optionalLazyToResolvedInterfaceUnionProperty,
      optionalLazyToResolvedIriIdentifierInterfaceProperty,
      optionalPartialInterfaceToResolvedInterfaceProperty,
      optionalPartialInterfaceToResolvedInterfaceUnionProperty,
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
      requiredLazyToResolvedInterfaceProperty,
      requiredPartialInterfaceToResolvedInterfaceProperty,
      setLazyToResolvedInterfaceProperty,
      setPartialInterfaceToResolvedInterfaceProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, LazyPropertiesInterface> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazyPropertiesInterface" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedInterfaceProperty`,
        }),
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedInterfaceUnionProperty`,
        }),
        $NamedDefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedIriIdentifierInterfaceProperty`,
        }),
        PartialInterface.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalPartialInterfaceToResolvedInterfaceProperty`,
        }),
        PartialInterface.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalPartialInterfaceToResolvedInterfaceUnionProperty`,
        }),
        {
          scope: `${scopePrefix}/properties/optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
          type: "Control",
        },
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/requiredLazyToResolvedInterfaceProperty`,
        }),
        PartialInterface.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/requiredPartialInterfaceToResolvedInterfaceProperty`,
        }),
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/setLazyToResolvedInterfaceProperty`,
        }),
        PartialInterface.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/setPartialInterfaceToResolvedInterfaceProperty`,
        }),
      ],
      label: "LazyPropertiesInterface",
      type: "Group",
    };
  }

  export function $toJson(
    _lazyPropertiesInterface: LazyPropertiesInterface,
  ): LazyPropertiesInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _lazyPropertiesInterface.$identifier.termType === "BlankNode"
            ? `_:${_lazyPropertiesInterface.$identifier.value}`
            : _lazyPropertiesInterface.$identifier.value,
        $type: _lazyPropertiesInterface.$type,
        optionalLazyToResolvedInterfaceProperty:
          _lazyPropertiesInterface.optionalLazyToResolvedInterfaceProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalLazyToResolvedInterfaceUnionProperty:
          _lazyPropertiesInterface.optionalLazyToResolvedInterfaceUnionProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalLazyToResolvedIriIdentifierInterfaceProperty:
          _lazyPropertiesInterface.optionalLazyToResolvedIriIdentifierInterfaceProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalPartialInterfaceToResolvedInterfaceProperty:
          _lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceProperty.partial
            .map((item) => PartialInterface.$toJson(item))
            .extract(),
        optionalPartialInterfaceToResolvedInterfaceUnionProperty:
          _lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceUnionProperty.partial
            .map((item) => PartialInterface.$toJson(item))
            .extract(),
        optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty:
          _lazyPropertiesInterface.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty.partial
            .map((item) => PartialInterfaceUnion.$toJson(item))
            .extract(),
        requiredLazyToResolvedInterfaceProperty:
          _lazyPropertiesInterface.requiredLazyToResolvedInterfaceProperty.partial.$toJson(),
        requiredPartialInterfaceToResolvedInterfaceProperty:
          PartialInterface.$toJson(
            _lazyPropertiesInterface
              .requiredPartialInterfaceToResolvedInterfaceProperty.partial,
          ),
        setLazyToResolvedInterfaceProperty:
          _lazyPropertiesInterface.setLazyToResolvedInterfaceProperty.partials.map(
            (item) => item.$toJson(),
          ),
        setPartialInterfaceToResolvedInterfaceProperty:
          _lazyPropertiesInterface.setPartialInterfaceToResolvedInterfaceProperty.partials.map(
            (item) => PartialInterface.$toJson(item),
          ),
      } satisfies LazyPropertiesInterface.$Json),
    );
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("LazyPropertiesInterface"),
      optionalLazyToResolvedInterfaceProperty: $DefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalLazyToResolvedInterfaceUnionProperty: $DefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalLazyToResolvedIriIdentifierInterfaceProperty: $NamedDefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalPartialInterfaceToResolvedInterfaceProperty:
        PartialInterface.$jsonZodSchema().optional(),
      optionalPartialInterfaceToResolvedInterfaceUnionProperty:
        PartialInterface.$jsonZodSchema().optional(),
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty:
        PartialInterfaceUnion.$jsonZodSchema().optional(),
      requiredLazyToResolvedInterfaceProperty: $DefaultPartial.$jsonZodSchema(),
      requiredPartialInterfaceToResolvedInterfaceProperty:
        PartialInterface.$jsonZodSchema(),
      setLazyToResolvedInterfaceProperty: $DefaultPartial
        .$jsonZodSchema()
        .array()
        .default(() => []),
      setPartialInterfaceToResolvedInterfaceProperty:
        PartialInterface.$jsonZodSchema()
          .array()
          .default(() => []),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazyPropertiesInterface";
    readonly optionalLazyToResolvedInterfaceProperty?: $DefaultPartial.$Json;
    readonly optionalLazyToResolvedInterfaceUnionProperty?: $DefaultPartial.$Json;
    readonly optionalLazyToResolvedIriIdentifierInterfaceProperty?: $NamedDefaultPartial.$Json;
    readonly optionalPartialInterfaceToResolvedInterfaceProperty?: PartialInterface.$Json;
    readonly optionalPartialInterfaceToResolvedInterfaceUnionProperty?: PartialInterface.$Json;
    readonly optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty?:
      | PartialInterfaceUnionMember1.$Json
      | PartialInterfaceUnionMember2.$Json;
    readonly requiredLazyToResolvedInterfaceProperty: $DefaultPartial.$Json;
    readonly requiredPartialInterfaceToResolvedInterfaceProperty: PartialInterface.$Json;
    readonly setLazyToResolvedInterfaceProperty?: readonly $DefaultPartial.$Json[];
    readonly setPartialInterfaceToResolvedInterfaceProperty?: readonly PartialInterface.$Json[];
  };

  export function isLazyPropertiesInterface(
    object: $Object,
  ): object is LazyPropertiesInterface {
    switch (object.$type) {
      case "LazyPropertiesInterface":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, LazyPropertiesInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return LazyPropertiesInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      $type: "LazyPropertiesInterface";
      optionalLazyToResolvedInterfaceProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      optionalLazyToResolvedInterfaceUnionProperty: $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >;
      optionalLazyToResolvedIriIdentifierInterfaceProperty: $LazyObjectOption<
        LazilyResolvedIriIdentifierInterface.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriIdentifierInterface
      >;
      optionalPartialInterfaceToResolvedInterfaceProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      optionalPartialInterfaceToResolvedInterfaceUnionProperty: $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterface,
        LazilyResolvedInterfaceUnion
      >;
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty: $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterfaceUnion,
        LazilyResolvedInterfaceUnion
      >;
      requiredLazyToResolvedInterfaceProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      requiredPartialInterfaceToResolvedInterfaceProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      setLazyToResolvedInterfaceProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      setPartialInterfaceToResolvedInterfaceProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
    }
  > {
    return Either.of<Error, LazyPropertiesInterface.$Identifier>(
      $parameters.resource.identifier as LazyPropertiesInterface.$Identifier,
    ).chain(($identifier) =>
      Either.of<Error, "LazyPropertiesInterface">(
        "LazyPropertiesInterface" as const,
      ).chain(($type) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.optionalLazyToResolvedInterfaceProperty
              .identifier,
            {
              unique: true,
            },
          ),
        )
          .chain((values) =>
            values.chainMap((value) =>
              value.toResource().chain((resource) =>
                $DefaultPartial.$fromRdf(resource, {
                  context: $parameters.context,
                  ignoreRdfType: true,
                  objectSet: $parameters.objectSet,
                  preferredLanguages: $parameters.preferredLanguages,
                }),
              ),
            ),
          )
          .map((values) =>
            values.length > 0
              ? values.map((value) => Maybe.of(value))
              : Resource.Values.fromValue<Maybe<$DefaultPartial>>({
                  focusResource: $parameters.resource,
                  predicate:
                    LazyPropertiesInterface.$schema.properties
                      .optionalLazyToResolvedInterfaceProperty.identifier,
                  value: Maybe.empty(),
                }),
          )
          .map((values) =>
            values.map(
              (partial) =>
                new $LazyObjectOption<
                  LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
                  $DefaultPartial,
                  LazilyResolvedBlankNodeOrIriIdentifierInterface
                >({
                  partial,
                  resolver: (identifier) =>
                    $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierInterface(
                      identifier,
                    ),
                }),
            ),
          )
          .chain((values) => values.head())
          .chain((optionalLazyToResolvedInterfaceProperty) =>
            Either.of<Error, Resource.Values<Resource.TermValue>>(
              $parameters.resource.values(
                $schema.properties.optionalLazyToResolvedInterfaceUnionProperty
                  .identifier,
                {
                  unique: true,
                },
              ),
            )
              .chain((values) =>
                values.chainMap((value) =>
                  value.toResource().chain((resource) =>
                    $DefaultPartial.$fromRdf(resource, {
                      context: $parameters.context,
                      ignoreRdfType: true,
                      objectSet: $parameters.objectSet,
                      preferredLanguages: $parameters.preferredLanguages,
                    }),
                  ),
                ),
              )
              .map((values) =>
                values.length > 0
                  ? values.map((value) => Maybe.of(value))
                  : Resource.Values.fromValue<Maybe<$DefaultPartial>>({
                      focusResource: $parameters.resource,
                      predicate:
                        LazyPropertiesInterface.$schema.properties
                          .optionalLazyToResolvedInterfaceUnionProperty
                          .identifier,
                      value: Maybe.empty(),
                    }),
              )
              .map((values) =>
                values.map(
                  (partial) =>
                    new $LazyObjectOption<
                      LazilyResolvedInterfaceUnion.$Identifier,
                      $DefaultPartial,
                      LazilyResolvedInterfaceUnion
                    >({
                      partial,
                      resolver: (identifier) =>
                        $parameters.objectSet.lazilyResolvedInterfaceUnion(
                          identifier,
                        ),
                    }),
                ),
              )
              .chain((values) => values.head())
              .chain((optionalLazyToResolvedInterfaceUnionProperty) =>
                Either.of<Error, Resource.Values<Resource.TermValue>>(
                  $parameters.resource.values(
                    $schema.properties
                      .optionalLazyToResolvedIriIdentifierInterfaceProperty
                      .identifier,
                    { unique: true },
                  ),
                )
                  .chain((values) =>
                    values.chainMap((value) =>
                      value.toResource().chain((resource) =>
                        $NamedDefaultPartial.$fromRdf(resource, {
                          context: $parameters.context,
                          ignoreRdfType: true,
                          objectSet: $parameters.objectSet,
                          preferredLanguages: $parameters.preferredLanguages,
                        }),
                      ),
                    ),
                  )
                  .map((values) =>
                    values.length > 0
                      ? values.map((value) => Maybe.of(value))
                      : Resource.Values.fromValue<Maybe<$NamedDefaultPartial>>({
                          focusResource: $parameters.resource,
                          predicate:
                            LazyPropertiesInterface.$schema.properties
                              .optionalLazyToResolvedIriIdentifierInterfaceProperty
                              .identifier,
                          value: Maybe.empty(),
                        }),
                  )
                  .map((values) =>
                    values.map(
                      (partial) =>
                        new $LazyObjectOption<
                          LazilyResolvedIriIdentifierInterface.$Identifier,
                          $NamedDefaultPartial,
                          LazilyResolvedIriIdentifierInterface
                        >({
                          partial,
                          resolver: (identifier) =>
                            $parameters.objectSet.lazilyResolvedIriIdentifierInterface(
                              identifier,
                            ),
                        }),
                    ),
                  )
                  .chain((values) => values.head())
                  .chain(
                    (optionalLazyToResolvedIriIdentifierInterfaceProperty) =>
                      Either.of<Error, Resource.Values<Resource.TermValue>>(
                        $parameters.resource.values(
                          $schema.properties
                            .optionalPartialInterfaceToResolvedInterfaceProperty
                            .identifier,
                          { unique: true },
                        ),
                      )
                        .chain((values) =>
                          values.chainMap((value) =>
                            value.toResource().chain((resource) =>
                              PartialInterface.$fromRdf(resource, {
                                context: $parameters.context,
                                ignoreRdfType: true,
                                objectSet: $parameters.objectSet,
                                preferredLanguages:
                                  $parameters.preferredLanguages,
                              }),
                            ),
                          ),
                        )
                        .map((values) =>
                          values.length > 0
                            ? values.map((value) => Maybe.of(value))
                            : Resource.Values.fromValue<
                                Maybe<PartialInterface>
                              >({
                                focusResource: $parameters.resource,
                                predicate:
                                  LazyPropertiesInterface.$schema.properties
                                    .optionalPartialInterfaceToResolvedInterfaceProperty
                                    .identifier,
                                value: Maybe.empty(),
                              }),
                        )
                        .map((values) =>
                          values.map(
                            (partial) =>
                              new $LazyObjectOption<
                                LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
                                PartialInterface,
                                LazilyResolvedBlankNodeOrIriIdentifierInterface
                              >({
                                partial,
                                resolver: (identifier) =>
                                  $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierInterface(
                                    identifier,
                                  ),
                              }),
                          ),
                        )
                        .chain((values) => values.head())
                        .chain(
                          (
                            optionalPartialInterfaceToResolvedInterfaceProperty,
                          ) =>
                            Either.of<
                              Error,
                              Resource.Values<Resource.TermValue>
                            >(
                              $parameters.resource.values(
                                $schema.properties
                                  .optionalPartialInterfaceToResolvedInterfaceUnionProperty
                                  .identifier,
                                { unique: true },
                              ),
                            )
                              .chain((values) =>
                                values.chainMap((value) =>
                                  value.toResource().chain((resource) =>
                                    PartialInterface.$fromRdf(resource, {
                                      context: $parameters.context,
                                      ignoreRdfType: true,
                                      objectSet: $parameters.objectSet,
                                      preferredLanguages:
                                        $parameters.preferredLanguages,
                                    }),
                                  ),
                                ),
                              )
                              .map((values) =>
                                values.length > 0
                                  ? values.map((value) => Maybe.of(value))
                                  : Resource.Values.fromValue<
                                      Maybe<PartialInterface>
                                    >({
                                      focusResource: $parameters.resource,
                                      predicate:
                                        LazyPropertiesInterface.$schema
                                          .properties
                                          .optionalPartialInterfaceToResolvedInterfaceUnionProperty
                                          .identifier,
                                      value: Maybe.empty(),
                                    }),
                              )
                              .map((values) =>
                                values.map(
                                  (partial) =>
                                    new $LazyObjectOption<
                                      LazilyResolvedInterfaceUnion.$Identifier,
                                      PartialInterface,
                                      LazilyResolvedInterfaceUnion
                                    >({
                                      partial,
                                      resolver: (identifier) =>
                                        $parameters.objectSet.lazilyResolvedInterfaceUnion(
                                          identifier,
                                        ),
                                    }),
                                ),
                              )
                              .chain((values) => values.head())
                              .chain(
                                (
                                  optionalPartialInterfaceToResolvedInterfaceUnionProperty,
                                ) =>
                                  Either.of<
                                    Error,
                                    Resource.Values<Resource.TermValue>
                                  >(
                                    $parameters.resource.values(
                                      $schema.properties
                                        .optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty
                                        .identifier,
                                      { unique: true },
                                    ),
                                  )
                                    .chain((values) =>
                                      values.chainMap((value) =>
                                        value.toResource().chain((resource) =>
                                          PartialInterfaceUnion.$fromRdf(
                                            resource,
                                            {
                                              context: $parameters.context,
                                              ignoreRdfType: false,
                                              objectSet: $parameters.objectSet,
                                              preferredLanguages:
                                                $parameters.preferredLanguages,
                                            },
                                          ),
                                        ),
                                      ),
                                    )
                                    .map((values) =>
                                      values.length > 0
                                        ? values.map((value) => Maybe.of(value))
                                        : Resource.Values.fromValue<
                                            Maybe<PartialInterfaceUnion>
                                          >({
                                            focusResource: $parameters.resource,
                                            predicate:
                                              LazyPropertiesInterface.$schema
                                                .properties
                                                .optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty
                                                .identifier,
                                            value: Maybe.empty(),
                                          }),
                                    )
                                    .map((values) =>
                                      values.map(
                                        (partial) =>
                                          new $LazyObjectOption<
                                            LazilyResolvedInterfaceUnion.$Identifier,
                                            PartialInterfaceUnion,
                                            LazilyResolvedInterfaceUnion
                                          >({
                                            partial,
                                            resolver: (identifier) =>
                                              $parameters.objectSet.lazilyResolvedInterfaceUnion(
                                                identifier,
                                              ),
                                          }),
                                      ),
                                    )
                                    .chain((values) => values.head())
                                    .chain(
                                      (
                                        optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
                                      ) =>
                                        Either.of<
                                          Error,
                                          Resource.Values<Resource.TermValue>
                                        >(
                                          $parameters.resource.values(
                                            $schema.properties
                                              .requiredLazyToResolvedInterfaceProperty
                                              .identifier,
                                            { unique: true },
                                          ),
                                        )
                                          .chain((values) =>
                                            values.chainMap((value) =>
                                              value
                                                .toResource()
                                                .chain((resource) =>
                                                  $DefaultPartial.$fromRdf(
                                                    resource,
                                                    {
                                                      context:
                                                        $parameters.context,
                                                      ignoreRdfType: true,
                                                      objectSet:
                                                        $parameters.objectSet,
                                                      preferredLanguages:
                                                        $parameters.preferredLanguages,
                                                    },
                                                  ),
                                                ),
                                            ),
                                          )
                                          .map((values) =>
                                            values.map(
                                              (partial) =>
                                                new $LazyObject<
                                                  LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
                                                  $DefaultPartial,
                                                  LazilyResolvedBlankNodeOrIriIdentifierInterface
                                                >({
                                                  partial,
                                                  resolver: (identifier) =>
                                                    $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierInterface(
                                                      identifier,
                                                    ),
                                                }),
                                            ),
                                          )
                                          .chain((values) => values.head())
                                          .chain(
                                            (
                                              requiredLazyToResolvedInterfaceProperty,
                                            ) =>
                                              Either.of<
                                                Error,
                                                Resource.Values<Resource.TermValue>
                                              >(
                                                $parameters.resource.values(
                                                  $schema.properties
                                                    .requiredPartialInterfaceToResolvedInterfaceProperty
                                                    .identifier,
                                                  { unique: true },
                                                ),
                                              )
                                                .chain((values) =>
                                                  values.chainMap((value) =>
                                                    value
                                                      .toResource()
                                                      .chain((resource) =>
                                                        PartialInterface.$fromRdf(
                                                          resource,
                                                          {
                                                            context:
                                                              $parameters.context,
                                                            ignoreRdfType: true,
                                                            objectSet:
                                                              $parameters.objectSet,
                                                            preferredLanguages:
                                                              $parameters.preferredLanguages,
                                                          },
                                                        ),
                                                      ),
                                                  ),
                                                )
                                                .map((values) =>
                                                  values.map(
                                                    (partial) =>
                                                      new $LazyObject<
                                                        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
                                                        PartialInterface,
                                                        LazilyResolvedBlankNodeOrIriIdentifierInterface
                                                      >({
                                                        partial,
                                                        resolver: (
                                                          identifier,
                                                        ) =>
                                                          $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierInterface(
                                                            identifier,
                                                          ),
                                                      }),
                                                  ),
                                                )
                                                .chain((values) =>
                                                  values.head(),
                                                )
                                                .chain(
                                                  (
                                                    requiredPartialInterfaceToResolvedInterfaceProperty,
                                                  ) =>
                                                    Either.of<
                                                      Error,
                                                      Resource.Values<Resource.TermValue>
                                                    >(
                                                      $parameters.resource.values(
                                                        $schema.properties
                                                          .setLazyToResolvedInterfaceProperty
                                                          .identifier,
                                                        { unique: true },
                                                      ),
                                                    )
                                                      .chain((values) =>
                                                        values.chainMap(
                                                          (value) =>
                                                            value
                                                              .toResource()
                                                              .chain(
                                                                (resource) =>
                                                                  $DefaultPartial.$fromRdf(
                                                                    resource,
                                                                    {
                                                                      context:
                                                                        $parameters.context,
                                                                      ignoreRdfType: true,
                                                                      objectSet:
                                                                        $parameters.objectSet,
                                                                      preferredLanguages:
                                                                        $parameters.preferredLanguages,
                                                                    },
                                                                  ),
                                                              ),
                                                        ),
                                                      )
                                                      .map((values) =>
                                                        values.toArray(),
                                                      )
                                                      .map((valuesArray) =>
                                                        Resource.Values.fromValue(
                                                          {
                                                            focusResource:
                                                              $parameters.resource,
                                                            predicate:
                                                              LazyPropertiesInterface
                                                                .$schema
                                                                .properties
                                                                .setLazyToResolvedInterfaceProperty
                                                                .identifier,
                                                            value: valuesArray,
                                                          },
                                                        ),
                                                      )
                                                      .map((values) =>
                                                        values.map(
                                                          (partials) =>
                                                            new $LazyObjectSet<
                                                              LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
                                                              $DefaultPartial,
                                                              LazilyResolvedBlankNodeOrIriIdentifierInterface
                                                            >({
                                                              partials,
                                                              resolver: (
                                                                identifiers,
                                                              ) =>
                                                                $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierInterfaces(
                                                                  {
                                                                    identifiers,
                                                                  },
                                                                ),
                                                            }),
                                                        ),
                                                      )
                                                      .chain((values) =>
                                                        values.head(),
                                                      )
                                                      .chain(
                                                        (
                                                          setLazyToResolvedInterfaceProperty,
                                                        ) =>
                                                          Either.of<
                                                            Error,
                                                            Resource.Values<Resource.TermValue>
                                                          >(
                                                            $parameters.resource.values(
                                                              $schema.properties
                                                                .setPartialInterfaceToResolvedInterfaceProperty
                                                                .identifier,
                                                              { unique: true },
                                                            ),
                                                          )
                                                            .chain((values) =>
                                                              values.chainMap(
                                                                (value) =>
                                                                  value
                                                                    .toResource()
                                                                    .chain(
                                                                      (
                                                                        resource,
                                                                      ) =>
                                                                        PartialInterface.$fromRdf(
                                                                          resource,
                                                                          {
                                                                            context:
                                                                              $parameters.context,
                                                                            ignoreRdfType: true,
                                                                            objectSet:
                                                                              $parameters.objectSet,
                                                                            preferredLanguages:
                                                                              $parameters.preferredLanguages,
                                                                          },
                                                                        ),
                                                                    ),
                                                              ),
                                                            )
                                                            .map((values) =>
                                                              values.toArray(),
                                                            )
                                                            .map(
                                                              (valuesArray) =>
                                                                Resource.Values.fromValue(
                                                                  {
                                                                    focusResource:
                                                                      $parameters.resource,
                                                                    predicate:
                                                                      LazyPropertiesInterface
                                                                        .$schema
                                                                        .properties
                                                                        .setPartialInterfaceToResolvedInterfaceProperty
                                                                        .identifier,
                                                                    value:
                                                                      valuesArray,
                                                                  },
                                                                ),
                                                            )
                                                            .map((values) =>
                                                              values.map(
                                                                (partials) =>
                                                                  new $LazyObjectSet<
                                                                    LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
                                                                    PartialInterface,
                                                                    LazilyResolvedBlankNodeOrIriIdentifierInterface
                                                                  >({
                                                                    partials,
                                                                    resolver: (
                                                                      identifiers,
                                                                    ) =>
                                                                      $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierInterfaces(
                                                                        {
                                                                          identifiers,
                                                                        },
                                                                      ),
                                                                  }),
                                                              ),
                                                            )
                                                            .chain((values) =>
                                                              values.head(),
                                                            )
                                                            .map(
                                                              (
                                                                setPartialInterfaceToResolvedInterfaceProperty,
                                                              ) => ({
                                                                $identifier,
                                                                $type,
                                                                optionalLazyToResolvedInterfaceProperty,
                                                                optionalLazyToResolvedInterfaceUnionProperty,
                                                                optionalLazyToResolvedIriIdentifierInterfaceProperty,
                                                                optionalPartialInterfaceToResolvedInterfaceProperty,
                                                                optionalPartialInterfaceToResolvedInterfaceUnionProperty,
                                                                optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
                                                                requiredLazyToResolvedInterfaceProperty,
                                                                requiredPartialInterfaceToResolvedInterfaceProperty,
                                                                setLazyToResolvedInterfaceProperty,
                                                                setPartialInterfaceToResolvedInterfaceProperty,
                                                              }),
                                                            ),
                                                      ),
                                                ),
                                          ),
                                    ),
                              ),
                        ),
                  ),
              ),
          ),
      ),
    );
  }

  export function $toRdf(
    _lazyPropertiesInterface: LazyPropertiesInterface,
    options?: {
      ignoreRdfType?: boolean;
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(_lazyPropertiesInterface.$identifier);
    resource.add(
      LazyPropertiesInterface.$schema.properties
        .optionalLazyToResolvedInterfaceProperty.identifier,
      _lazyPropertiesInterface.optionalLazyToResolvedInterfaceProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ graph: options?.graph, resourceSet: resourceSet })
            .identifier,
        ]),
      options?.graph,
    );
    resource.add(
      LazyPropertiesInterface.$schema.properties
        .optionalLazyToResolvedInterfaceUnionProperty.identifier,
      _lazyPropertiesInterface.optionalLazyToResolvedInterfaceUnionProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ graph: options?.graph, resourceSet: resourceSet })
            .identifier,
        ]),
      options?.graph,
    );
    resource.add(
      LazyPropertiesInterface.$schema.properties
        .optionalLazyToResolvedIriIdentifierInterfaceProperty.identifier,
      _lazyPropertiesInterface.optionalLazyToResolvedIriIdentifierInterfaceProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ graph: options?.graph, resourceSet: resourceSet })
            .identifier,
        ]),
      options?.graph,
    );
    resource.add(
      LazyPropertiesInterface.$schema.properties
        .optionalPartialInterfaceToResolvedInterfaceProperty.identifier,
      _lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceProperty.partial
        .toList()
        .flatMap((value) => [
          PartialInterface.$toRdf(value, {
            graph: options?.graph,
            resourceSet: resourceSet,
          }).identifier,
        ]),
      options?.graph,
    );
    resource.add(
      LazyPropertiesInterface.$schema.properties
        .optionalPartialInterfaceToResolvedInterfaceUnionProperty.identifier,
      _lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceUnionProperty.partial
        .toList()
        .flatMap((value) => [
          PartialInterface.$toRdf(value, {
            graph: options?.graph,
            resourceSet: resourceSet,
          }).identifier,
        ]),
      options?.graph,
    );
    resource.add(
      LazyPropertiesInterface.$schema.properties
        .optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty
        .identifier,
      _lazyPropertiesInterface.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty.partial
        .toList()
        .flatMap((value) => [
          PartialInterfaceUnion.$toRdf(value, {
            graph: options?.graph,
            resourceSet: resourceSet,
          }).identifier,
        ]),
      options?.graph,
    );
    resource.add(
      LazyPropertiesInterface.$schema.properties
        .requiredLazyToResolvedInterfaceProperty.identifier,
      [
        _lazyPropertiesInterface.requiredLazyToResolvedInterfaceProperty.partial.$toRdf(
          {
            graph: options?.graph,
            resourceSet: resourceSet,
          },
        ).identifier,
      ],
      options?.graph,
    );
    resource.add(
      LazyPropertiesInterface.$schema.properties
        .requiredPartialInterfaceToResolvedInterfaceProperty.identifier,
      [
        PartialInterface.$toRdf(
          _lazyPropertiesInterface
            .requiredPartialInterfaceToResolvedInterfaceProperty.partial,
          {
            graph: options?.graph,
            resourceSet: resourceSet,
          },
        ).identifier,
      ],
      options?.graph,
    );
    resource.add(
      LazyPropertiesInterface.$schema.properties
        .setLazyToResolvedInterfaceProperty.identifier,
      _lazyPropertiesInterface.setLazyToResolvedInterfaceProperty.partials.flatMap(
        (item) => [
          item.$toRdf({ graph: options?.graph, resourceSet: resourceSet })
            .identifier,
        ],
      ),
      options?.graph,
    );
    resource.add(
      LazyPropertiesInterface.$schema.properties
        .setPartialInterfaceToResolvedInterfaceProperty.identifier,
      _lazyPropertiesInterface.setPartialInterfaceToResolvedInterfaceProperty.partials.flatMap(
        (item) => [
          PartialInterface.$toRdf(item, {
            graph: options?.graph,
            resourceSet: resourceSet,
          }).identifier,
        ],
      ),
      options?.graph,
    );
    return resource;
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["LazyPropertiesInterface"],
        }),
      },
      optionalLazyToResolvedInterfaceProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "LazyObjectOption" as const,
          partial: () => ({
            kind: "Maybe" as const,
            item: () => $DefaultPartial.$schema,
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/optionalLazyToResolvedInterfaceProperty",
        ),
      },
      optionalLazyToResolvedInterfaceUnionProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "LazyObjectOption" as const,
          partial: () => ({
            kind: "Maybe" as const,
            item: () => $DefaultPartial.$schema,
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/optionalLazyToResolvedInterfaceUnionProperty",
        ),
      },
      optionalLazyToResolvedIriIdentifierInterfaceProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "LazyObjectOption" as const,
          partial: () => ({
            kind: "Maybe" as const,
            item: () => $NamedDefaultPartial.$schema,
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/optionalLazyToResolvedIriIdentifierInterfaceProperty",
        ),
      },
      optionalPartialInterfaceToResolvedInterfaceProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "LazyObjectOption" as const,
          partial: () => ({
            kind: "Maybe" as const,
            item: () => PartialInterface.$schema,
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/optionalPartialInterfaceToResolvedInterfaceProperty",
        ),
      },
      optionalPartialInterfaceToResolvedInterfaceUnionProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "LazyObjectOption" as const,
          partial: () => ({
            kind: "Maybe" as const,
            item: () => PartialInterface.$schema,
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/optionalPartialInterfaceToResolvedInterfaceUnionProperty",
        ),
      },
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "LazyObjectOption" as const,
          partial: () => ({
            kind: "Maybe" as const,
            item: () => PartialInterfaceUnion.$schema,
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty",
        ),
      },
      requiredLazyToResolvedInterfaceProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "LazyObject" as const,
          partial: () => $DefaultPartial.$schema,
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/requiredLazyToResolvedInterfaceProperty",
        ),
      },
      requiredPartialInterfaceToResolvedInterfaceProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "LazyObject" as const,
          partial: () => PartialInterface.$schema,
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/requiredPartialInterfaceToResolvedInterfaceProperty",
        ),
      },
      setLazyToResolvedInterfaceProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "LazyObjectSet" as const,
          partial: () => ({
            kind: "Set" as const,
            item: () => $DefaultPartial.$schema,
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/setLazyToResolvedInterfaceProperty",
        ),
      },
      setPartialInterfaceToResolvedInterfaceProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "LazyObjectSet" as const,
          partial: () => ({
            kind: "Set" as const,
            item: () => PartialInterface.$schema,
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/setPartialInterfaceToResolvedInterfaceProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazyPropertiesInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazyPropertiesInterface.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          LazyPropertiesInterface.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazyPropertiesInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazyPropertiesInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("lazyPropertiesInterface");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }OptionalLazyToResolvedInterfaceProperty`,
        ),
        predicate:
          LazyPropertiesInterface.$schema.properties
            .optionalLazyToResolvedInterfaceProperty.identifier,
        subject: subject,
      },
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }OptionalLazyToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesInterface")
        }OptionalLazyToResolvedInterfaceProperty`,
      }),
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }OptionalLazyToResolvedInterfaceUnionProperty`,
        ),
        predicate:
          LazyPropertiesInterface.$schema.properties
            .optionalLazyToResolvedInterfaceUnionProperty.identifier,
        subject: subject,
      },
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }OptionalLazyToResolvedInterfaceUnionProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesInterface")
        }OptionalLazyToResolvedInterfaceUnionProperty`,
      }),
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }OptionalLazyToResolvedIriIdentifierInterfaceProperty`,
        ),
        predicate:
          LazyPropertiesInterface.$schema.properties
            .optionalLazyToResolvedIriIdentifierInterfaceProperty.identifier,
        subject: subject,
      },
      ...$NamedDefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }OptionalLazyToResolvedIriIdentifierInterfaceProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesInterface")
        }OptionalLazyToResolvedIriIdentifierInterfaceProperty`,
      }),
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }OptionalPartialInterfaceToResolvedInterfaceProperty`,
        ),
        predicate:
          LazyPropertiesInterface.$schema.properties
            .optionalPartialInterfaceToResolvedInterfaceProperty.identifier,
        subject: subject,
      },
      ...PartialInterface.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }OptionalPartialInterfaceToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesInterface")
        }OptionalPartialInterfaceToResolvedInterfaceProperty`,
      }),
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
        ),
        predicate:
          LazyPropertiesInterface.$schema.properties
            .optionalPartialInterfaceToResolvedInterfaceUnionProperty
            .identifier,
        subject: subject,
      },
      ...PartialInterface.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesInterface")
        }OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
      }),
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
        ),
        predicate:
          LazyPropertiesInterface.$schema.properties
            .optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty
            .identifier,
        subject: subject,
      },
      ...PartialInterfaceUnion.$sparqlConstructTriples({
        subject: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesInterface")
        }OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
      }),
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }RequiredLazyToResolvedInterfaceProperty`,
        ),
        predicate:
          LazyPropertiesInterface.$schema.properties
            .requiredLazyToResolvedInterfaceProperty.identifier,
        subject: subject,
      },
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }RequiredLazyToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesInterface")
        }RequiredLazyToResolvedInterfaceProperty`,
      }),
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }RequiredPartialInterfaceToResolvedInterfaceProperty`,
        ),
        predicate:
          LazyPropertiesInterface.$schema.properties
            .requiredPartialInterfaceToResolvedInterfaceProperty.identifier,
        subject: subject,
      },
      ...PartialInterface.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }RequiredPartialInterfaceToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesInterface")
        }RequiredPartialInterfaceToResolvedInterfaceProperty`,
      }),
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }SetLazyToResolvedInterfaceProperty`,
        ),
        predicate:
          LazyPropertiesInterface.$schema.properties
            .setLazyToResolvedInterfaceProperty.identifier,
        subject: subject,
      },
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }SetLazyToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesInterface")
        }SetLazyToResolvedInterfaceProperty`,
      }),
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }SetPartialInterfaceToResolvedInterfaceProperty`,
        ),
        predicate:
          LazyPropertiesInterface.$schema.properties
            .setPartialInterfaceToResolvedInterfaceProperty.identifier,
        subject: subject,
      },
      ...PartialInterface.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }SetPartialInterfaceToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesInterface")
        }SetPartialInterfaceToResolvedInterfaceProperty`,
      }),
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazyPropertiesInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("lazyPropertiesInterface");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: LazyPropertiesInterface.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface"),
        }),
      );
    }
    patterns = patterns.concat(
      (({ schema, ...otherParameters }) =>
        $maybeSparqlWherePatterns<
          $DefaultPartial.$Filter,
          typeof $DefaultPartial.$schema
        >(
          ({
            ignoreRdfType,
            propertyPatterns,
            valueVariable,
            ...otherParameters
          }: $SparqlWherePatternsFunctionParameters<
            $DefaultPartial.$Filter,
            typeof $DefaultPartial.$schema
          >) =>
            (propertyPatterns as readonly $SparqlPattern[]).concat(
              $DefaultPartial.$sparqlWherePatterns({
                ignoreRdfType: ignoreRdfType ?? true,
                subject: valueVariable,
                ...otherParameters,
              }),
            ),
        )({ schema: schema.partial(), ...otherParameters }))({
        filter: parameters?.filter?.optionalLazyToResolvedInterfaceProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazyPropertiesInterface")
                  }OptionalLazyToResolvedInterfaceProperty`,
                ),
                predicate:
                  LazyPropertiesInterface.$schema.properties
                    .optionalLazyToResolvedInterfaceProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazyPropertiesInterface.$schema.properties.optionalLazyToResolvedInterfaceProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }OptionalLazyToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesInterface")
        }OptionalLazyToResolvedInterfaceProperty`,
      }),
    );
    patterns = patterns.concat(
      (({ schema, ...otherParameters }) =>
        $maybeSparqlWherePatterns<
          $DefaultPartial.$Filter,
          typeof $DefaultPartial.$schema
        >(
          ({
            ignoreRdfType,
            propertyPatterns,
            valueVariable,
            ...otherParameters
          }: $SparqlWherePatternsFunctionParameters<
            $DefaultPartial.$Filter,
            typeof $DefaultPartial.$schema
          >) =>
            (propertyPatterns as readonly $SparqlPattern[]).concat(
              $DefaultPartial.$sparqlWherePatterns({
                ignoreRdfType: ignoreRdfType ?? true,
                subject: valueVariable,
                ...otherParameters,
              }),
            ),
        )({ schema: schema.partial(), ...otherParameters }))({
        filter:
          parameters?.filter?.optionalLazyToResolvedInterfaceUnionProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazyPropertiesInterface")
                  }OptionalLazyToResolvedInterfaceUnionProperty`,
                ),
                predicate:
                  LazyPropertiesInterface.$schema.properties
                    .optionalLazyToResolvedInterfaceUnionProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazyPropertiesInterface.$schema.properties.optionalLazyToResolvedInterfaceUnionProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }OptionalLazyToResolvedInterfaceUnionProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesInterface")
        }OptionalLazyToResolvedInterfaceUnionProperty`,
      }),
    );
    patterns = patterns.concat(
      (({ schema, ...otherParameters }) =>
        $maybeSparqlWherePatterns<
          $NamedDefaultPartial.$Filter,
          typeof $NamedDefaultPartial.$schema
        >(
          ({
            ignoreRdfType,
            propertyPatterns,
            valueVariable,
            ...otherParameters
          }: $SparqlWherePatternsFunctionParameters<
            $NamedDefaultPartial.$Filter,
            typeof $NamedDefaultPartial.$schema
          >) =>
            (propertyPatterns as readonly $SparqlPattern[]).concat(
              $NamedDefaultPartial.$sparqlWherePatterns({
                ignoreRdfType: ignoreRdfType ?? true,
                subject: valueVariable,
                ...otherParameters,
              }),
            ),
        )({ schema: schema.partial(), ...otherParameters }))({
        filter:
          parameters?.filter
            ?.optionalLazyToResolvedIriIdentifierInterfaceProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazyPropertiesInterface")
                  }OptionalLazyToResolvedIriIdentifierInterfaceProperty`,
                ),
                predicate:
                  LazyPropertiesInterface.$schema.properties
                    .optionalLazyToResolvedIriIdentifierInterfaceProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazyPropertiesInterface.$schema.properties.optionalLazyToResolvedIriIdentifierInterfaceProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }OptionalLazyToResolvedIriIdentifierInterfaceProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesInterface")
        }OptionalLazyToResolvedIriIdentifierInterfaceProperty`,
      }),
    );
    patterns = patterns.concat(
      (({ schema, ...otherParameters }) =>
        $maybeSparqlWherePatterns<
          PartialInterface.$Filter,
          typeof PartialInterface.$schema
        >(
          ({
            ignoreRdfType,
            propertyPatterns,
            valueVariable,
            ...otherParameters
          }: $SparqlWherePatternsFunctionParameters<
            PartialInterface.$Filter,
            typeof PartialInterface.$schema
          >) =>
            (propertyPatterns as readonly $SparqlPattern[]).concat(
              PartialInterface.$sparqlWherePatterns({
                ignoreRdfType: ignoreRdfType ?? true,
                subject: valueVariable,
                ...otherParameters,
              }),
            ),
        )({ schema: schema.partial(), ...otherParameters }))({
        filter:
          parameters?.filter
            ?.optionalPartialInterfaceToResolvedInterfaceProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazyPropertiesInterface")
                  }OptionalPartialInterfaceToResolvedInterfaceProperty`,
                ),
                predicate:
                  LazyPropertiesInterface.$schema.properties
                    .optionalPartialInterfaceToResolvedInterfaceProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazyPropertiesInterface.$schema.properties.optionalPartialInterfaceToResolvedInterfaceProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }OptionalPartialInterfaceToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesInterface")
        }OptionalPartialInterfaceToResolvedInterfaceProperty`,
      }),
    );
    patterns = patterns.concat(
      (({ schema, ...otherParameters }) =>
        $maybeSparqlWherePatterns<
          PartialInterface.$Filter,
          typeof PartialInterface.$schema
        >(
          ({
            ignoreRdfType,
            propertyPatterns,
            valueVariable,
            ...otherParameters
          }: $SparqlWherePatternsFunctionParameters<
            PartialInterface.$Filter,
            typeof PartialInterface.$schema
          >) =>
            (propertyPatterns as readonly $SparqlPattern[]).concat(
              PartialInterface.$sparqlWherePatterns({
                ignoreRdfType: ignoreRdfType ?? true,
                subject: valueVariable,
                ...otherParameters,
              }),
            ),
        )({ schema: schema.partial(), ...otherParameters }))({
        filter:
          parameters?.filter
            ?.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazyPropertiesInterface")
                  }OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
                ),
                predicate:
                  LazyPropertiesInterface.$schema.properties
                    .optionalPartialInterfaceToResolvedInterfaceUnionProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazyPropertiesInterface.$schema.properties.optionalPartialInterfaceToResolvedInterfaceUnionProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesInterface")
        }OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
      }),
    );
    patterns = patterns.concat(
      (({ schema, ...otherParameters }) =>
        $maybeSparqlWherePatterns<
          PartialInterfaceUnion.$Filter,
          typeof PartialInterfaceUnion.$schema
        >(({ propertyPatterns, valueVariable, ...otherParameters }) =>
          (propertyPatterns as readonly $SparqlPattern[]).concat(
            PartialInterfaceUnion.$sparqlWherePatterns({
              subject: valueVariable,
              ...otherParameters,
            }),
          ),
        )({ schema: schema.partial(), ...otherParameters }))({
        filter:
          parameters?.filter
            ?.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazyPropertiesInterface")
                  }OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
                ),
                predicate:
                  LazyPropertiesInterface.$schema.properties
                    .optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazyPropertiesInterface.$schema.properties.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesInterface")
        }OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
      }),
    );
    patterns = patterns.concat(
      (({ schema, ...otherParameters }) =>
        (({
          ignoreRdfType,
          propertyPatterns,
          valueVariable,
          ...otherParameters
        }: $SparqlWherePatternsFunctionParameters<
          $DefaultPartial.$Filter,
          typeof $DefaultPartial.$schema
        >) =>
          (propertyPatterns as readonly $SparqlPattern[]).concat(
            $DefaultPartial.$sparqlWherePatterns({
              ignoreRdfType: ignoreRdfType ?? true,
              subject: valueVariable,
              ...otherParameters,
            }),
          ))({ schema: schema.partial(), ...otherParameters }))({
        filter: parameters?.filter?.requiredLazyToResolvedInterfaceProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazyPropertiesInterface")
                  }RequiredLazyToResolvedInterfaceProperty`,
                ),
                predicate:
                  LazyPropertiesInterface.$schema.properties
                    .requiredLazyToResolvedInterfaceProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazyPropertiesInterface.$schema.properties.requiredLazyToResolvedInterfaceProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }RequiredLazyToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesInterface")
        }RequiredLazyToResolvedInterfaceProperty`,
      }),
    );
    patterns = patterns.concat(
      (({ schema, ...otherParameters }) =>
        (({
          ignoreRdfType,
          propertyPatterns,
          valueVariable,
          ...otherParameters
        }: $SparqlWherePatternsFunctionParameters<
          PartialInterface.$Filter,
          typeof PartialInterface.$schema
        >) =>
          (propertyPatterns as readonly $SparqlPattern[]).concat(
            PartialInterface.$sparqlWherePatterns({
              ignoreRdfType: ignoreRdfType ?? true,
              subject: valueVariable,
              ...otherParameters,
            }),
          ))({ schema: schema.partial(), ...otherParameters }))({
        filter:
          parameters?.filter
            ?.requiredPartialInterfaceToResolvedInterfaceProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazyPropertiesInterface")
                  }RequiredPartialInterfaceToResolvedInterfaceProperty`,
                ),
                predicate:
                  LazyPropertiesInterface.$schema.properties
                    .requiredPartialInterfaceToResolvedInterfaceProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazyPropertiesInterface.$schema.properties.requiredPartialInterfaceToResolvedInterfaceProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }RequiredPartialInterfaceToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesInterface")
        }RequiredPartialInterfaceToResolvedInterfaceProperty`,
      }),
    );
    patterns = patterns.concat(
      (({ schema, ...otherParameters }) =>
        $setSparqlWherePatterns<
          $DefaultPartial.$Filter,
          typeof $DefaultPartial.$schema
        >(
          ({
            ignoreRdfType,
            propertyPatterns,
            valueVariable,
            ...otherParameters
          }: $SparqlWherePatternsFunctionParameters<
            $DefaultPartial.$Filter,
            typeof $DefaultPartial.$schema
          >) =>
            (propertyPatterns as readonly $SparqlPattern[]).concat(
              $DefaultPartial.$sparqlWherePatterns({
                ignoreRdfType: ignoreRdfType ?? true,
                subject: valueVariable,
                ...otherParameters,
              }),
            ),
        )({ schema: schema.partial(), ...otherParameters }))({
        filter: parameters?.filter?.setLazyToResolvedInterfaceProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazyPropertiesInterface")
                  }SetLazyToResolvedInterfaceProperty`,
                ),
                predicate:
                  LazyPropertiesInterface.$schema.properties
                    .setLazyToResolvedInterfaceProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazyPropertiesInterface.$schema.properties.setLazyToResolvedInterfaceProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }SetLazyToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesInterface")
        }SetLazyToResolvedInterfaceProperty`,
      }),
    );
    patterns = patterns.concat(
      (({ schema, ...otherParameters }) =>
        $setSparqlWherePatterns<
          PartialInterface.$Filter,
          typeof PartialInterface.$schema
        >(
          ({
            ignoreRdfType,
            propertyPatterns,
            valueVariable,
            ...otherParameters
          }: $SparqlWherePatternsFunctionParameters<
            PartialInterface.$Filter,
            typeof PartialInterface.$schema
          >) =>
            (propertyPatterns as readonly $SparqlPattern[]).concat(
              PartialInterface.$sparqlWherePatterns({
                ignoreRdfType: ignoreRdfType ?? true,
                subject: valueVariable,
                ...otherParameters,
              }),
            ),
        )({ schema: schema.partial(), ...otherParameters }))({
        filter:
          parameters?.filter?.setPartialInterfaceToResolvedInterfaceProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazyPropertiesInterface")
                  }SetPartialInterfaceToResolvedInterfaceProperty`,
                ),
                predicate:
                  LazyPropertiesInterface.$schema.properties
                    .setPartialInterfaceToResolvedInterfaceProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazyPropertiesInterface.$schema.properties.setPartialInterfaceToResolvedInterfaceProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesInterface")
          }SetPartialInterfaceToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesInterface")
        }SetPartialInterfaceToResolvedInterfaceProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Node shape used as a partial by LazyPropertiesClass
 */

export class PartialClass {
  private _$identifier?: PartialClass.$Identifier;

  readonly $type: "PartialClass" = "PartialClass" as const;

  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): PartialClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: PartialClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): PartialClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies PartialClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    resource.add(
      PartialClass.$schema.properties.lazilyResolvedStringProperty.identifier,
      [$literalFactory.string(this.lazilyResolvedStringProperty)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PartialClass {
  export function $filter(
    filter: PartialClass.$Filter,
    value: PartialClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<
    z.ZodError,
    { $identifier: BlankNode | NamedNode; lazilyResolvedStringProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $fromJson(json: unknown): Either<z.ZodError, PartialClass> {
    return $propertiesFromJson(json).map(
      (properties) => new PartialClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("PartialClass"),
      lazilyResolvedStringProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialClass";
    readonly lazilyResolvedStringProperty: string;
  };

  export function isPartialClass(object: $Object): object is PartialClass {
    switch (object.$type) {
      case "PartialClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, PartialClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return PartialClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new PartialClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    { $identifier: BlankNode | NamedNode; lazilyResolvedStringProperty: string }
  > {
    return Either.of<Error, PartialClass.$Identifier>(
      $parameters.resource.identifier as PartialClass.$Identifier,
    ).chain(($identifier) =>
      Either.of<Error, Resource.Values<Resource.TermValue>>(
        $parameters.resource.values(
          $schema.properties.lazilyResolvedStringProperty.identifier,
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              PartialClass.$schema.properties.lazilyResolvedStringProperty
                .identifier,
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((lazilyResolvedStringProperty) => ({
          $identifier,
          lazilyResolvedStringProperty,
        })),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["PartialClass"],
        }),
      },
      lazilyResolvedStringProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/lazilyResolvedStringProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          PartialClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClass");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable" ? subject.value : "partialClass")
          }LazilyResolvedStringProperty`,
        ),
        predicate:
          PartialClass.$schema.properties.lazilyResolvedStringProperty
            .identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClass");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: PartialClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable" ? subject.value : "partialClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.lazilyResolvedStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "partialClass")
                  }LazilyResolvedStringProperty`,
                ),
                predicate:
                  PartialClass.$schema.properties.lazilyResolvedStringProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          PartialClass.$schema.properties.lazilyResolvedStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable" ? subject.value : "partialClass")
          }LazilyResolvedStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable" ? subject.value : "partialClass")
        }LazilyResolvedStringProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Node shape that has lazy properties.
 */

export class LazyPropertiesClass {
  private _$identifier?: LazyPropertiesClass.$Identifier;

  readonly $type: "LazyPropertiesClass" = "LazyPropertiesClass" as const;

  readonly optionalLazyToResolvedClassProperty: $LazyObjectOption<
    LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriIdentifierClass
  >;

  readonly optionalLazyToResolvedClassUnionProperty: $LazyObjectOption<
    LazilyResolvedClassUnion.$Identifier,
    $DefaultPartial,
    LazilyResolvedClassUnion
  >;

  readonly optionalLazyToResolvedIriIdentifierClassProperty: $LazyObjectOption<
    LazilyResolvedIriIdentifierClass.$Identifier,
    $NamedDefaultPartial,
    LazilyResolvedIriIdentifierClass
  >;

  readonly optionalPartialClassToResolvedClassProperty: $LazyObjectOption<
    LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
    PartialClass,
    LazilyResolvedBlankNodeOrIriIdentifierClass
  >;

  readonly optionalPartialClassToResolvedClassUnionProperty: $LazyObjectOption<
    LazilyResolvedClassUnion.$Identifier,
    PartialClass,
    LazilyResolvedClassUnion
  >;

  readonly optionalPartialClassUnionToResolvedClassUnionProperty: $LazyObjectOption<
    LazilyResolvedClassUnion.$Identifier,
    PartialClassUnion,
    LazilyResolvedClassUnion
  >;

  readonly requiredLazyToResolvedClassProperty: $LazyObject<
    LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriIdentifierClass
  >;

  readonly requiredPartialClassToResolvedClassProperty: $LazyObject<
    LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
    PartialClass,
    LazilyResolvedBlankNodeOrIriIdentifierClass
  >;

  readonly setLazyToResolvedClassProperty: $LazyObjectSet<
    LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriIdentifierClass
  >;

  readonly setPartialClassToResolvedClassProperty: $LazyObjectSet<
    LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
    PartialClass,
    LazilyResolvedBlankNodeOrIriIdentifierClass
  >;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly optionalLazyToResolvedClassProperty?:
      | $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >
      | Maybe<LazilyResolvedBlankNodeOrIriIdentifierClass>
      | LazilyResolvedBlankNodeOrIriIdentifierClass;
    readonly optionalLazyToResolvedClassUnionProperty?:
      | $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          $DefaultPartial,
          LazilyResolvedClassUnion
        >
      | Maybe<LazilyResolvedClassUnion>
      | LazilyResolvedClassUnion;
    readonly optionalLazyToResolvedIriIdentifierClassProperty?:
      | $LazyObjectOption<
          LazilyResolvedIriIdentifierClass.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierClass
        >
      | Maybe<LazilyResolvedIriIdentifierClass>
      | LazilyResolvedIriIdentifierClass;
    readonly optionalPartialClassToResolvedClassProperty?:
      | $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >
      | Maybe<LazilyResolvedBlankNodeOrIriIdentifierClass>
      | LazilyResolvedBlankNodeOrIriIdentifierClass;
    readonly optionalPartialClassToResolvedClassUnionProperty?:
      | $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClass,
          LazilyResolvedClassUnion
        >
      | Maybe<LazilyResolvedClassUnion>
      | LazilyResolvedClassUnion;
    readonly optionalPartialClassUnionToResolvedClassUnionProperty?:
      | $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClassUnion,
          LazilyResolvedClassUnion
        >
      | Maybe<LazilyResolvedClassUnion>
      | LazilyResolvedClassUnion;
    readonly requiredLazyToResolvedClassProperty:
      | $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >
      | LazilyResolvedBlankNodeOrIriIdentifierClass;
    readonly requiredPartialClassToResolvedClassProperty:
      | $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >
      | LazilyResolvedBlankNodeOrIriIdentifierClass;
    readonly setLazyToResolvedClassProperty?:
      | $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >
      | readonly LazilyResolvedBlankNodeOrIriIdentifierClass[];
    readonly setPartialClassToResolvedClassProperty?:
      | $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >
      | readonly LazilyResolvedBlankNodeOrIriIdentifierClass[];
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    if (
      typeof parameters.optionalLazyToResolvedClassProperty === "object" &&
      parameters.optionalLazyToResolvedClassProperty instanceof
        $LazyObjectOption
    ) {
      this.optionalLazyToResolvedClassProperty =
        parameters.optionalLazyToResolvedClassProperty;
    } else if (Maybe.isMaybe(parameters.optionalLazyToResolvedClassProperty)) {
      this.optionalLazyToResolvedClassProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: parameters.optionalLazyToResolvedClassProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          Either.of(
            (
              parameters.optionalLazyToResolvedClassProperty as Maybe<LazilyResolvedBlankNodeOrIriIdentifierClass>
            ).unsafeCoerce(),
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedClassProperty === "object"
    ) {
      this.optionalLazyToResolvedClassProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: Maybe.of(
          new $DefaultPartial(parameters.optionalLazyToResolvedClassProperty),
        ),
        resolver: async () =>
          Either.of(
            parameters.optionalLazyToResolvedClassProperty as LazilyResolvedBlankNodeOrIriIdentifierClass,
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedClassProperty === "undefined"
    ) {
      this.optionalLazyToResolvedClassProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: Maybe.empty(),
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      this.optionalLazyToResolvedClassProperty =
        parameters.optionalLazyToResolvedClassProperty satisfies never;
    }
    if (
      typeof parameters.optionalLazyToResolvedClassUnionProperty === "object" &&
      parameters.optionalLazyToResolvedClassUnionProperty instanceof
        $LazyObjectOption
    ) {
      this.optionalLazyToResolvedClassUnionProperty =
        parameters.optionalLazyToResolvedClassUnionProperty;
    } else if (
      Maybe.isMaybe(parameters.optionalLazyToResolvedClassUnionProperty)
    ) {
      this.optionalLazyToResolvedClassUnionProperty = new $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >({
        partial: parameters.optionalLazyToResolvedClassUnionProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          Either.of(
            (
              parameters.optionalLazyToResolvedClassUnionProperty as Maybe<LazilyResolvedClassUnion>
            ).unsafeCoerce(),
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedClassUnionProperty === "object"
    ) {
      this.optionalLazyToResolvedClassUnionProperty = new $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >({
        partial: Maybe.of(
          new $DefaultPartial(
            parameters.optionalLazyToResolvedClassUnionProperty,
          ),
        ),
        resolver: async () =>
          Either.of(
            parameters.optionalLazyToResolvedClassUnionProperty as LazilyResolvedClassUnion,
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedClassUnionProperty === "undefined"
    ) {
      this.optionalLazyToResolvedClassUnionProperty = new $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >({
        partial: Maybe.empty(),
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      this.optionalLazyToResolvedClassUnionProperty =
        parameters.optionalLazyToResolvedClassUnionProperty satisfies never;
    }
    if (
      typeof parameters.optionalLazyToResolvedIriIdentifierClassProperty ===
        "object" &&
      parameters.optionalLazyToResolvedIriIdentifierClassProperty instanceof
        $LazyObjectOption
    ) {
      this.optionalLazyToResolvedIriIdentifierClassProperty =
        parameters.optionalLazyToResolvedIriIdentifierClassProperty;
    } else if (
      Maybe.isMaybe(parameters.optionalLazyToResolvedIriIdentifierClassProperty)
    ) {
      this.optionalLazyToResolvedIriIdentifierClassProperty =
        new $LazyObjectOption<
          LazilyResolvedIriIdentifierClass.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierClass
        >({
          partial:
            parameters.optionalLazyToResolvedIriIdentifierClassProperty.map(
              (object) => new $NamedDefaultPartial(object),
            ),
          resolver: async () =>
            Either.of(
              (
                parameters.optionalLazyToResolvedIriIdentifierClassProperty as Maybe<LazilyResolvedIriIdentifierClass>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalLazyToResolvedIriIdentifierClassProperty ===
      "object"
    ) {
      this.optionalLazyToResolvedIriIdentifierClassProperty =
        new $LazyObjectOption<
          LazilyResolvedIriIdentifierClass.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierClass
        >({
          partial: Maybe.of(
            new $NamedDefaultPartial(
              parameters.optionalLazyToResolvedIriIdentifierClassProperty,
            ),
          ),
          resolver: async () =>
            Either.of(
              parameters.optionalLazyToResolvedIriIdentifierClassProperty as LazilyResolvedIriIdentifierClass,
            ),
        });
    } else if (
      typeof parameters.optionalLazyToResolvedIriIdentifierClassProperty ===
      "undefined"
    ) {
      this.optionalLazyToResolvedIriIdentifierClassProperty =
        new $LazyObjectOption<
          LazilyResolvedIriIdentifierClass.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierClass
        >({
          partial: Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      this.optionalLazyToResolvedIriIdentifierClassProperty =
        parameters.optionalLazyToResolvedIriIdentifierClassProperty satisfies never;
    }
    if (
      typeof parameters.optionalPartialClassToResolvedClassProperty ===
        "object" &&
      parameters.optionalPartialClassToResolvedClassProperty instanceof
        $LazyObjectOption
    ) {
      this.optionalPartialClassToResolvedClassProperty =
        parameters.optionalPartialClassToResolvedClassProperty;
    } else if (
      Maybe.isMaybe(parameters.optionalPartialClassToResolvedClassProperty)
    ) {
      this.optionalPartialClassToResolvedClassProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: parameters.optionalPartialClassToResolvedClassProperty.map(
          (object) => new PartialClass(object),
        ),
        resolver: async () =>
          Either.of(
            (
              parameters.optionalPartialClassToResolvedClassProperty as Maybe<LazilyResolvedBlankNodeOrIriIdentifierClass>
            ).unsafeCoerce(),
          ),
      });
    } else if (
      typeof parameters.optionalPartialClassToResolvedClassProperty === "object"
    ) {
      this.optionalPartialClassToResolvedClassProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: Maybe.of(
          new PartialClass(
            parameters.optionalPartialClassToResolvedClassProperty,
          ),
        ),
        resolver: async () =>
          Either.of(
            parameters.optionalPartialClassToResolvedClassProperty as LazilyResolvedBlankNodeOrIriIdentifierClass,
          ),
      });
    } else if (
      typeof parameters.optionalPartialClassToResolvedClassProperty ===
      "undefined"
    ) {
      this.optionalPartialClassToResolvedClassProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: Maybe.empty(),
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      this.optionalPartialClassToResolvedClassProperty =
        parameters.optionalPartialClassToResolvedClassProperty satisfies never;
    }
    if (
      typeof parameters.optionalPartialClassToResolvedClassUnionProperty ===
        "object" &&
      parameters.optionalPartialClassToResolvedClassUnionProperty instanceof
        $LazyObjectOption
    ) {
      this.optionalPartialClassToResolvedClassUnionProperty =
        parameters.optionalPartialClassToResolvedClassUnionProperty;
    } else if (
      Maybe.isMaybe(parameters.optionalPartialClassToResolvedClassUnionProperty)
    ) {
      this.optionalPartialClassToResolvedClassUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClass,
          LazilyResolvedClassUnion
        >({
          partial:
            parameters.optionalPartialClassToResolvedClassUnionProperty.map(
              (object) => new PartialClass(object),
            ),
          resolver: async () =>
            Either.of(
              (
                parameters.optionalPartialClassToResolvedClassUnionProperty as Maybe<LazilyResolvedClassUnion>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalPartialClassToResolvedClassUnionProperty ===
      "object"
    ) {
      this.optionalPartialClassToResolvedClassUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClass,
          LazilyResolvedClassUnion
        >({
          partial: Maybe.of(
            new PartialClass(
              parameters.optionalPartialClassToResolvedClassUnionProperty,
            ),
          ),
          resolver: async () =>
            Either.of(
              parameters.optionalPartialClassToResolvedClassUnionProperty as LazilyResolvedClassUnion,
            ),
        });
    } else if (
      typeof parameters.optionalPartialClassToResolvedClassUnionProperty ===
      "undefined"
    ) {
      this.optionalPartialClassToResolvedClassUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClass,
          LazilyResolvedClassUnion
        >({
          partial: Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      this.optionalPartialClassToResolvedClassUnionProperty =
        parameters.optionalPartialClassToResolvedClassUnionProperty satisfies never;
    }
    if (
      typeof parameters.optionalPartialClassUnionToResolvedClassUnionProperty ===
        "object" &&
      parameters.optionalPartialClassUnionToResolvedClassUnionProperty instanceof
        $LazyObjectOption
    ) {
      this.optionalPartialClassUnionToResolvedClassUnionProperty =
        parameters.optionalPartialClassUnionToResolvedClassUnionProperty;
    } else if (
      Maybe.isMaybe(
        parameters.optionalPartialClassUnionToResolvedClassUnionProperty,
      )
    ) {
      this.optionalPartialClassUnionToResolvedClassUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClassUnion,
          LazilyResolvedClassUnion
        >({
          partial:
            parameters.optionalPartialClassUnionToResolvedClassUnionProperty.map(
              (object) => {
                switch (object.$type) {
                  case "LazilyResolvedClassUnionMember1":
                    return new PartialClassUnionMember1(object);
                  case "LazilyResolvedClassUnionMember2":
                    return new PartialClassUnionMember2(object);
                  default:
                    object satisfies never;
                    throw new Error("unrecognized type");
                }
              },
            ),
          resolver: async () =>
            Either.of(
              (
                parameters.optionalPartialClassUnionToResolvedClassUnionProperty as Maybe<LazilyResolvedClassUnion>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalPartialClassUnionToResolvedClassUnionProperty ===
      "object"
    ) {
      this.optionalPartialClassUnionToResolvedClassUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClassUnion,
          LazilyResolvedClassUnion
        >({
          partial: Maybe.of(
            parameters.optionalPartialClassUnionToResolvedClassUnionProperty,
          ).map((object) => {
            switch (object.$type) {
              case "LazilyResolvedClassUnionMember1":
                return new PartialClassUnionMember1(object);
              case "LazilyResolvedClassUnionMember2":
                return new PartialClassUnionMember2(object);
              default:
                object satisfies never;
                throw new Error("unrecognized type");
            }
          }),
          resolver: async () =>
            Either.of(
              parameters.optionalPartialClassUnionToResolvedClassUnionProperty as LazilyResolvedClassUnion,
            ),
        });
    } else if (
      typeof parameters.optionalPartialClassUnionToResolvedClassUnionProperty ===
      "undefined"
    ) {
      this.optionalPartialClassUnionToResolvedClassUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClassUnion,
          LazilyResolvedClassUnion
        >({
          partial: Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      this.optionalPartialClassUnionToResolvedClassUnionProperty =
        parameters.optionalPartialClassUnionToResolvedClassUnionProperty satisfies never;
    }
    if (
      typeof parameters.requiredLazyToResolvedClassProperty === "object" &&
      parameters.requiredLazyToResolvedClassProperty instanceof $LazyObject
    ) {
      this.requiredLazyToResolvedClassProperty =
        parameters.requiredLazyToResolvedClassProperty;
    } else if (
      typeof parameters.requiredLazyToResolvedClassProperty === "object"
    ) {
      this.requiredLazyToResolvedClassProperty = new $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: new $DefaultPartial(
          parameters.requiredLazyToResolvedClassProperty,
        ),
        resolver: async () =>
          Either.of(
            parameters.requiredLazyToResolvedClassProperty as LazilyResolvedBlankNodeOrIriIdentifierClass,
          ),
      });
    } else {
      this.requiredLazyToResolvedClassProperty =
        parameters.requiredLazyToResolvedClassProperty satisfies never;
    }
    if (
      typeof parameters.requiredPartialClassToResolvedClassProperty ===
        "object" &&
      parameters.requiredPartialClassToResolvedClassProperty instanceof
        $LazyObject
    ) {
      this.requiredPartialClassToResolvedClassProperty =
        parameters.requiredPartialClassToResolvedClassProperty;
    } else if (
      typeof parameters.requiredPartialClassToResolvedClassProperty === "object"
    ) {
      this.requiredPartialClassToResolvedClassProperty = new $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: new PartialClass(
          parameters.requiredPartialClassToResolvedClassProperty,
        ),
        resolver: async () =>
          Either.of(
            parameters.requiredPartialClassToResolvedClassProperty as LazilyResolvedBlankNodeOrIriIdentifierClass,
          ),
      });
    } else {
      this.requiredPartialClassToResolvedClassProperty =
        parameters.requiredPartialClassToResolvedClassProperty satisfies never;
    }
    if (
      typeof parameters.setLazyToResolvedClassProperty === "object" &&
      parameters.setLazyToResolvedClassProperty instanceof $LazyObjectSet
    ) {
      this.setLazyToResolvedClassProperty =
        parameters.setLazyToResolvedClassProperty;
    } else if (typeof parameters.setLazyToResolvedClassProperty === "object") {
      this.setLazyToResolvedClassProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partials: parameters.setLazyToResolvedClassProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          Either.of(
            parameters.setLazyToResolvedClassProperty as readonly LazilyResolvedBlankNodeOrIriIdentifierClass[],
          ),
      });
    } else if (
      typeof parameters.setLazyToResolvedClassProperty === "undefined"
    ) {
      this.setLazyToResolvedClassProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partials: [],
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      this.setLazyToResolvedClassProperty =
        parameters.setLazyToResolvedClassProperty satisfies never;
    }
    if (
      typeof parameters.setPartialClassToResolvedClassProperty === "object" &&
      parameters.setPartialClassToResolvedClassProperty instanceof
        $LazyObjectSet
    ) {
      this.setPartialClassToResolvedClassProperty =
        parameters.setPartialClassToResolvedClassProperty;
    } else if (
      typeof parameters.setPartialClassToResolvedClassProperty === "object"
    ) {
      this.setPartialClassToResolvedClassProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partials: parameters.setPartialClassToResolvedClassProperty.map(
          (object) => new PartialClass(object),
        ),
        resolver: async () =>
          Either.of(
            parameters.setPartialClassToResolvedClassProperty as readonly LazilyResolvedBlankNodeOrIriIdentifierClass[],
          ),
      });
    } else if (
      typeof parameters.setPartialClassToResolvedClassProperty === "undefined"
    ) {
      this.setPartialClassToResolvedClassProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partials: [],
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      this.setPartialClassToResolvedClassProperty =
        parameters.setPartialClassToResolvedClassProperty satisfies never;
    }
  }

  get $identifier(): LazyPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: LazyPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          this.optionalLazyToResolvedClassProperty,
          other.optionalLazyToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalLazyToResolvedClassProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          this.optionalLazyToResolvedClassUnionProperty,
          other.optionalLazyToResolvedClassUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalLazyToResolvedClassUnionProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          this.optionalLazyToResolvedIriIdentifierClassProperty,
          other.optionalLazyToResolvedIriIdentifierClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalLazyToResolvedIriIdentifierClassProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          this.optionalPartialClassToResolvedClassProperty,
          other.optionalPartialClassToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalPartialClassToResolvedClassProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          this.optionalPartialClassToResolvedClassUnionProperty,
          other.optionalPartialClassToResolvedClassUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalPartialClassToResolvedClassUnionProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, PartialClassUnion.$equals))(
            left.partial,
            right.partial,
          ))(
          this.optionalPartialClassUnionToResolvedClassUnionProperty,
          other.optionalPartialClassUnionToResolvedClassUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalPartialClassUnionToResolvedClassUnionProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) => left.$equals(right))(left.partial, right.partial))(
          this.requiredLazyToResolvedClassProperty,
          other.requiredLazyToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "requiredLazyToResolvedClassProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) => left.$equals(right))(left.partial, right.partial))(
          this.requiredPartialClassToResolvedClassProperty,
          other.requiredPartialClassToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "requiredPartialClassToResolvedClassProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $arrayEquals(left, right, (left, right) => left.$equals(right)))(
            left.partials,
            right.partials,
          ))(
          this.setLazyToResolvedClassProperty,
          other.setLazyToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "setLazyToResolvedClassProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $arrayEquals(left, right, (left, right) => left.$equals(right)))(
            left.partials,
            right.partials,
          ))(
          this.setPartialClassToResolvedClassProperty,
          other.setPartialClassToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "setPartialClassToResolvedClassProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    this.optionalLazyToResolvedClassProperty.partial.ifJust((value1) => {
      value1.$hash(_hasher);
    });
    this.optionalLazyToResolvedClassUnionProperty.partial.ifJust((value1) => {
      value1.$hash(_hasher);
    });
    this.optionalLazyToResolvedIriIdentifierClassProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    this.optionalPartialClassToResolvedClassProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    this.optionalPartialClassToResolvedClassUnionProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    this.optionalPartialClassUnionToResolvedClassUnionProperty.partial.ifJust(
      (value1) => {
        PartialClassUnion.$hash(value1, _hasher);
      },
    );
    this.requiredLazyToResolvedClassProperty.partial.$hash(_hasher);
    this.requiredPartialClassToResolvedClassProperty.partial.$hash(_hasher);
    for (const item1 of this.setLazyToResolvedClassProperty.partials) {
      item1.$hash(_hasher);
    }
    for (const item1 of this.setPartialClassToResolvedClassProperty.partials) {
      item1.$hash(_hasher);
    }
    return _hasher;
  }

  $toJson(): LazyPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        optionalLazyToResolvedClassProperty:
          this.optionalLazyToResolvedClassProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalLazyToResolvedClassUnionProperty:
          this.optionalLazyToResolvedClassUnionProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalLazyToResolvedIriIdentifierClassProperty:
          this.optionalLazyToResolvedIriIdentifierClassProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalPartialClassToResolvedClassProperty:
          this.optionalPartialClassToResolvedClassProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalPartialClassToResolvedClassUnionProperty:
          this.optionalPartialClassToResolvedClassUnionProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalPartialClassUnionToResolvedClassUnionProperty:
          this.optionalPartialClassUnionToResolvedClassUnionProperty.partial
            .map((item) => PartialClassUnion.$toJson(item))
            .extract(),
        requiredLazyToResolvedClassProperty:
          this.requiredLazyToResolvedClassProperty.partial.$toJson(),
        requiredPartialClassToResolvedClassProperty:
          this.requiredPartialClassToResolvedClassProperty.partial.$toJson(),
        setLazyToResolvedClassProperty:
          this.setLazyToResolvedClassProperty.partials.map((item) =>
            item.$toJson(),
          ),
        setPartialClassToResolvedClassProperty:
          this.setPartialClassToResolvedClassProperty.partials.map((item) =>
            item.$toJson(),
          ),
      } satisfies LazyPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    resource.add(
      LazyPropertiesClass.$schema.properties.optionalLazyToResolvedClassProperty
        .identifier,
      this.optionalLazyToResolvedClassProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ graph: options?.graph, resourceSet: resourceSet })
            .identifier,
        ]),
      options?.graph,
    );
    resource.add(
      LazyPropertiesClass.$schema.properties
        .optionalLazyToResolvedClassUnionProperty.identifier,
      this.optionalLazyToResolvedClassUnionProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ graph: options?.graph, resourceSet: resourceSet })
            .identifier,
        ]),
      options?.graph,
    );
    resource.add(
      LazyPropertiesClass.$schema.properties
        .optionalLazyToResolvedIriIdentifierClassProperty.identifier,
      this.optionalLazyToResolvedIriIdentifierClassProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ graph: options?.graph, resourceSet: resourceSet })
            .identifier,
        ]),
      options?.graph,
    );
    resource.add(
      LazyPropertiesClass.$schema.properties
        .optionalPartialClassToResolvedClassProperty.identifier,
      this.optionalPartialClassToResolvedClassProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ graph: options?.graph, resourceSet: resourceSet })
            .identifier,
        ]),
      options?.graph,
    );
    resource.add(
      LazyPropertiesClass.$schema.properties
        .optionalPartialClassToResolvedClassUnionProperty.identifier,
      this.optionalPartialClassToResolvedClassUnionProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ graph: options?.graph, resourceSet: resourceSet })
            .identifier,
        ]),
      options?.graph,
    );
    resource.add(
      LazyPropertiesClass.$schema.properties
        .optionalPartialClassUnionToResolvedClassUnionProperty.identifier,
      this.optionalPartialClassUnionToResolvedClassUnionProperty.partial
        .toList()
        .flatMap((value) => [
          PartialClassUnion.$toRdf(value, {
            graph: options?.graph,
            resourceSet: resourceSet,
          }).identifier,
        ]),
      options?.graph,
    );
    resource.add(
      LazyPropertiesClass.$schema.properties.requiredLazyToResolvedClassProperty
        .identifier,
      [
        this.requiredLazyToResolvedClassProperty.partial.$toRdf({
          graph: options?.graph,
          resourceSet: resourceSet,
        }).identifier,
      ],
      options?.graph,
    );
    resource.add(
      LazyPropertiesClass.$schema.properties
        .requiredPartialClassToResolvedClassProperty.identifier,
      [
        this.requiredPartialClassToResolvedClassProperty.partial.$toRdf({
          graph: options?.graph,
          resourceSet: resourceSet,
        }).identifier,
      ],
      options?.graph,
    );
    resource.add(
      LazyPropertiesClass.$schema.properties.setLazyToResolvedClassProperty
        .identifier,
      this.setLazyToResolvedClassProperty.partials.flatMap((item) => [
        item.$toRdf({ graph: options?.graph, resourceSet: resourceSet })
          .identifier,
      ]),
      options?.graph,
    );
    resource.add(
      LazyPropertiesClass.$schema.properties
        .setPartialClassToResolvedClassProperty.identifier,
      this.setPartialClassToResolvedClassProperty.partials.flatMap((item) => [
        item.$toRdf({ graph: options?.graph, resourceSet: resourceSet })
          .identifier,
      ]),
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LazyPropertiesClass {
  export function $filter(
    filter: LazyPropertiesClass.$Filter,
    value: LazyPropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.optionalLazyToResolvedClassProperty !== "undefined" &&
      !((
        filter: $MaybeFilter<$DefaultPartial.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >,
      ) =>
        $filterMaybe<$DefaultPartial, $DefaultPartial.$Filter>(
          $DefaultPartial.$filter,
        )(filter, value.partial))(
        filter.optionalLazyToResolvedClassProperty,
        value.optionalLazyToResolvedClassProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.optionalLazyToResolvedClassUnionProperty !== "undefined" &&
      !((
        filter: $MaybeFilter<$DefaultPartial.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          $DefaultPartial,
          LazilyResolvedClassUnion
        >,
      ) =>
        $filterMaybe<$DefaultPartial, $DefaultPartial.$Filter>(
          $DefaultPartial.$filter,
        )(filter, value.partial))(
        filter.optionalLazyToResolvedClassUnionProperty,
        value.optionalLazyToResolvedClassUnionProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.optionalLazyToResolvedIriIdentifierClassProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<$NamedDefaultPartial.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedIriIdentifierClass.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierClass
        >,
      ) =>
        $filterMaybe<$NamedDefaultPartial, $NamedDefaultPartial.$Filter>(
          $NamedDefaultPartial.$filter,
        )(filter, value.partial))(
        filter.optionalLazyToResolvedIriIdentifierClassProperty,
        value.optionalLazyToResolvedIriIdentifierClassProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.optionalPartialClassToResolvedClassProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<PartialClass.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >,
      ) =>
        $filterMaybe<PartialClass, PartialClass.$Filter>(PartialClass.$filter)(
          filter,
          value.partial,
        ))(
        filter.optionalPartialClassToResolvedClassProperty,
        value.optionalPartialClassToResolvedClassProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.optionalPartialClassToResolvedClassUnionProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<PartialClass.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClass,
          LazilyResolvedClassUnion
        >,
      ) =>
        $filterMaybe<PartialClass, PartialClass.$Filter>(PartialClass.$filter)(
          filter,
          value.partial,
        ))(
        filter.optionalPartialClassToResolvedClassUnionProperty,
        value.optionalPartialClassToResolvedClassUnionProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.optionalPartialClassUnionToResolvedClassUnionProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<PartialClassUnion.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClassUnion,
          LazilyResolvedClassUnion
        >,
      ) =>
        $filterMaybe<PartialClassUnion, PartialClassUnion.$Filter>(
          PartialClassUnion.$filter,
        )(filter, value.partial))(
        filter.optionalPartialClassUnionToResolvedClassUnionProperty,
        value.optionalPartialClassUnionToResolvedClassUnionProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.requiredLazyToResolvedClassProperty !== "undefined" &&
      !((
        filter: $DefaultPartial.$Filter,
        value: $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >,
      ) => $DefaultPartial.$filter(filter, value.partial))(
        filter.requiredLazyToResolvedClassProperty,
        value.requiredLazyToResolvedClassProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.requiredPartialClassToResolvedClassProperty !==
        "undefined" &&
      !((
        filter: PartialClass.$Filter,
        value: $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >,
      ) => PartialClass.$filter(filter, value.partial))(
        filter.requiredPartialClassToResolvedClassProperty,
        value.requiredPartialClassToResolvedClassProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.setLazyToResolvedClassProperty !== "undefined" &&
      !((
        filter: $CollectionFilter<$DefaultPartial.$Filter>,
        value: $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >,
      ) =>
        $filterArray<$DefaultPartial, $DefaultPartial.$Filter>(
          $DefaultPartial.$filter,
        )(filter, value.partials))(
        filter.setLazyToResolvedClassProperty,
        value.setLazyToResolvedClassProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.setPartialClassToResolvedClassProperty !== "undefined" &&
      !((
        filter: $CollectionFilter<PartialClass.$Filter>,
        value: $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >,
      ) =>
        $filterArray<PartialClass, PartialClass.$Filter>(PartialClass.$filter)(
          filter,
          value.partials,
        ))(
        filter.setPartialClassToResolvedClassProperty,
        value.setPartialClassToResolvedClassProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly optionalLazyToResolvedClassProperty?: $MaybeFilter<$DefaultPartial.$Filter>;
    readonly optionalLazyToResolvedClassUnionProperty?: $MaybeFilter<$DefaultPartial.$Filter>;
    readonly optionalLazyToResolvedIriIdentifierClassProperty?: $MaybeFilter<$NamedDefaultPartial.$Filter>;
    readonly optionalPartialClassToResolvedClassProperty?: $MaybeFilter<PartialClass.$Filter>;
    readonly optionalPartialClassToResolvedClassUnionProperty?: $MaybeFilter<PartialClass.$Filter>;
    readonly optionalPartialClassUnionToResolvedClassUnionProperty?: $MaybeFilter<PartialClassUnion.$Filter>;
    readonly requiredLazyToResolvedClassProperty?: $DefaultPartial.$Filter;
    readonly requiredPartialClassToResolvedClassProperty?: PartialClass.$Filter;
    readonly setLazyToResolvedClassProperty?: $CollectionFilter<$DefaultPartial.$Filter>;
    readonly setPartialClassToResolvedClassProperty?: $CollectionFilter<PartialClass.$Filter>;
  };

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      optionalLazyToResolvedClassProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      optionalLazyToResolvedClassUnionProperty: $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >;
      optionalLazyToResolvedIriIdentifierClassProperty: $LazyObjectOption<
        LazilyResolvedIriIdentifierClass.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriIdentifierClass
      >;
      optionalPartialClassToResolvedClassProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      optionalPartialClassToResolvedClassUnionProperty: $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        PartialClass,
        LazilyResolvedClassUnion
      >;
      optionalPartialClassUnionToResolvedClassUnionProperty: $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        PartialClassUnion,
        LazilyResolvedClassUnion
      >;
      requiredLazyToResolvedClassProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      requiredPartialClassToResolvedClassProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      setLazyToResolvedClassProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      setPartialClassToResolvedClassProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const optionalLazyToResolvedClassProperty = new $LazyObjectOption<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierClass
    >({
      partial: Maybe.fromNullable(
        $jsonObject["optionalLazyToResolvedClassProperty"],
      ).map((item) => $DefaultPartial.$fromJson(item).unsafeCoerce()),
      resolver: (identifier) =>
        Promise.resolve(
          Left(
            new Error(
              `unable to resolve identifier ${Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const optionalLazyToResolvedClassUnionProperty = new $LazyObjectOption<
      LazilyResolvedClassUnion.$Identifier,
      $DefaultPartial,
      LazilyResolvedClassUnion
    >({
      partial: Maybe.fromNullable(
        $jsonObject["optionalLazyToResolvedClassUnionProperty"],
      ).map((item) => $DefaultPartial.$fromJson(item).unsafeCoerce()),
      resolver: (identifier) =>
        Promise.resolve(
          Left(
            new Error(
              `unable to resolve identifier ${Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const optionalLazyToResolvedIriIdentifierClassProperty =
      new $LazyObjectOption<
        LazilyResolvedIriIdentifierClass.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriIdentifierClass
      >({
        partial: Maybe.fromNullable(
          $jsonObject["optionalLazyToResolvedIriIdentifierClassProperty"],
        ).map((item) => $NamedDefaultPartial.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            Left(
              new Error(
                `unable to resolve identifier ${Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const optionalPartialClassToResolvedClassProperty = new $LazyObjectOption<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
      PartialClass,
      LazilyResolvedBlankNodeOrIriIdentifierClass
    >({
      partial: Maybe.fromNullable(
        $jsonObject["optionalPartialClassToResolvedClassProperty"],
      ).map((item) => PartialClass.$fromJson(item).unsafeCoerce()),
      resolver: (identifier) =>
        Promise.resolve(
          Left(
            new Error(
              `unable to resolve identifier ${Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const optionalPartialClassToResolvedClassUnionProperty =
      new $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        PartialClass,
        LazilyResolvedClassUnion
      >({
        partial: Maybe.fromNullable(
          $jsonObject["optionalPartialClassToResolvedClassUnionProperty"],
        ).map((item) => PartialClass.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            Left(
              new Error(
                `unable to resolve identifier ${Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const optionalPartialClassUnionToResolvedClassUnionProperty =
      new $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        PartialClassUnion,
        LazilyResolvedClassUnion
      >({
        partial: Maybe.fromNullable(
          $jsonObject["optionalPartialClassUnionToResolvedClassUnionProperty"],
        ).map((item) => PartialClassUnion.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            Left(
              new Error(
                `unable to resolve identifier ${Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const requiredLazyToResolvedClassProperty = new $LazyObject<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierClass
    >({
      partial: $DefaultPartial
        .$fromJson($jsonObject["requiredLazyToResolvedClassProperty"])
        .unsafeCoerce(),
      resolver: (identifier) =>
        Promise.resolve(
          Left(
            new Error(
              `unable to resolve identifier ${Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const requiredPartialClassToResolvedClassProperty = new $LazyObject<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
      PartialClass,
      LazilyResolvedBlankNodeOrIriIdentifierClass
    >({
      partial: PartialClass.$fromJson(
        $jsonObject["requiredPartialClassToResolvedClassProperty"],
      ).unsafeCoerce(),
      resolver: (identifier) =>
        Promise.resolve(
          Left(
            new Error(
              `unable to resolve identifier ${Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const setLazyToResolvedClassProperty = new $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierClass
    >({
      partials: $jsonObject["setLazyToResolvedClassProperty"].map((item) =>
        $DefaultPartial.$fromJson(item).unsafeCoerce(),
      ),
      resolver: () =>
        Promise.resolve(
          Left(
            new Error("unable to resolve identifiers deserialized from JSON"),
          ),
        ),
    });
    const setPartialClassToResolvedClassProperty = new $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
      PartialClass,
      LazilyResolvedBlankNodeOrIriIdentifierClass
    >({
      partials: $jsonObject["setPartialClassToResolvedClassProperty"].map(
        (item) => PartialClass.$fromJson(item).unsafeCoerce(),
      ),
      resolver: () =>
        Promise.resolve(
          Left(
            new Error("unable to resolve identifiers deserialized from JSON"),
          ),
        ),
    });
    return Either.of({
      $identifier,
      optionalLazyToResolvedClassProperty,
      optionalLazyToResolvedClassUnionProperty,
      optionalLazyToResolvedIriIdentifierClassProperty,
      optionalPartialClassToResolvedClassProperty,
      optionalPartialClassToResolvedClassUnionProperty,
      optionalPartialClassUnionToResolvedClassUnionProperty,
      requiredLazyToResolvedClassProperty,
      requiredPartialClassToResolvedClassProperty,
      setLazyToResolvedClassProperty,
      setPartialClassToResolvedClassProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, LazyPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new LazyPropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazyPropertiesClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedClassProperty`,
        }),
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedClassUnionProperty`,
        }),
        $NamedDefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedIriIdentifierClassProperty`,
        }),
        PartialClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalPartialClassToResolvedClassProperty`,
        }),
        PartialClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalPartialClassToResolvedClassUnionProperty`,
        }),
        {
          scope: `${scopePrefix}/properties/optionalPartialClassUnionToResolvedClassUnionProperty`,
          type: "Control",
        },
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/requiredLazyToResolvedClassProperty`,
        }),
        PartialClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/requiredPartialClassToResolvedClassProperty`,
        }),
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/setLazyToResolvedClassProperty`,
        }),
        PartialClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/setPartialClassToResolvedClassProperty`,
        }),
      ],
      label: "LazyPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("LazyPropertiesClass"),
      optionalLazyToResolvedClassProperty: $DefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalLazyToResolvedClassUnionProperty: $DefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalLazyToResolvedIriIdentifierClassProperty: $NamedDefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalPartialClassToResolvedClassProperty:
        PartialClass.$jsonZodSchema().optional(),
      optionalPartialClassToResolvedClassUnionProperty:
        PartialClass.$jsonZodSchema().optional(),
      optionalPartialClassUnionToResolvedClassUnionProperty:
        PartialClassUnion.$jsonZodSchema().optional(),
      requiredLazyToResolvedClassProperty: $DefaultPartial.$jsonZodSchema(),
      requiredPartialClassToResolvedClassProperty:
        PartialClass.$jsonZodSchema(),
      setLazyToResolvedClassProperty: $DefaultPartial
        .$jsonZodSchema()
        .array()
        .default(() => []),
      setPartialClassToResolvedClassProperty: PartialClass.$jsonZodSchema()
        .array()
        .default(() => []),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazyPropertiesClass";
    readonly optionalLazyToResolvedClassProperty?: $DefaultPartial.$Json;
    readonly optionalLazyToResolvedClassUnionProperty?: $DefaultPartial.$Json;
    readonly optionalLazyToResolvedIriIdentifierClassProperty?: $NamedDefaultPartial.$Json;
    readonly optionalPartialClassToResolvedClassProperty?: PartialClass.$Json;
    readonly optionalPartialClassToResolvedClassUnionProperty?: PartialClass.$Json;
    readonly optionalPartialClassUnionToResolvedClassUnionProperty?:
      | PartialClassUnionMember1.$Json
      | PartialClassUnionMember2.$Json;
    readonly requiredLazyToResolvedClassProperty: $DefaultPartial.$Json;
    readonly requiredPartialClassToResolvedClassProperty: PartialClass.$Json;
    readonly setLazyToResolvedClassProperty?: readonly $DefaultPartial.$Json[];
    readonly setPartialClassToResolvedClassProperty?: readonly PartialClass.$Json[];
  };

  export function isLazyPropertiesClass(
    object: $Object,
  ): object is LazyPropertiesClass {
    switch (object.$type) {
      case "LazyPropertiesClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, LazyPropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return LazyPropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new LazyPropertiesClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      optionalLazyToResolvedClassProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      optionalLazyToResolvedClassUnionProperty: $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >;
      optionalLazyToResolvedIriIdentifierClassProperty: $LazyObjectOption<
        LazilyResolvedIriIdentifierClass.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriIdentifierClass
      >;
      optionalPartialClassToResolvedClassProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      optionalPartialClassToResolvedClassUnionProperty: $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        PartialClass,
        LazilyResolvedClassUnion
      >;
      optionalPartialClassUnionToResolvedClassUnionProperty: $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        PartialClassUnion,
        LazilyResolvedClassUnion
      >;
      requiredLazyToResolvedClassProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      requiredPartialClassToResolvedClassProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      setLazyToResolvedClassProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      setPartialClassToResolvedClassProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
    }
  > {
    return Either.of<Error, LazyPropertiesClass.$Identifier>(
      $parameters.resource.identifier as LazyPropertiesClass.$Identifier,
    ).chain(($identifier) =>
      Either.of<Error, Resource.Values<Resource.TermValue>>(
        $parameters.resource.values(
          $schema.properties.optionalLazyToResolvedClassProperty.identifier,
          {
            unique: true,
          },
        ),
      )
        .chain((values) =>
          values.chainMap((value) =>
            value.toResource().chain((resource) =>
              $DefaultPartial.$fromRdf(resource, {
                context: $parameters.context,
                ignoreRdfType: true,
                objectSet: $parameters.objectSet,
                preferredLanguages: $parameters.preferredLanguages,
              }),
            ),
          ),
        )
        .map((values) =>
          values.length > 0
            ? values.map((value) => Maybe.of(value))
            : Resource.Values.fromValue<Maybe<$DefaultPartial>>({
                focusResource: $parameters.resource,
                predicate:
                  LazyPropertiesClass.$schema.properties
                    .optionalLazyToResolvedClassProperty.identifier,
                value: Maybe.empty(),
              }),
        )
        .map((values) =>
          values.map(
            (partial) =>
              new $LazyObjectOption<
                LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
                $DefaultPartial,
                LazilyResolvedBlankNodeOrIriIdentifierClass
              >({
                partial,
                resolver: (identifier) =>
                  $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierClass(
                    identifier,
                  ),
              }),
          ),
        )
        .chain((values) => values.head())
        .chain((optionalLazyToResolvedClassProperty) =>
          Either.of<Error, Resource.Values<Resource.TermValue>>(
            $parameters.resource.values(
              $schema.properties.optionalLazyToResolvedClassUnionProperty
                .identifier,
              {
                unique: true,
              },
            ),
          )
            .chain((values) =>
              values.chainMap((value) =>
                value.toResource().chain((resource) =>
                  $DefaultPartial.$fromRdf(resource, {
                    context: $parameters.context,
                    ignoreRdfType: true,
                    objectSet: $parameters.objectSet,
                    preferredLanguages: $parameters.preferredLanguages,
                  }),
                ),
              ),
            )
            .map((values) =>
              values.length > 0
                ? values.map((value) => Maybe.of(value))
                : Resource.Values.fromValue<Maybe<$DefaultPartial>>({
                    focusResource: $parameters.resource,
                    predicate:
                      LazyPropertiesClass.$schema.properties
                        .optionalLazyToResolvedClassUnionProperty.identifier,
                    value: Maybe.empty(),
                  }),
            )
            .map((values) =>
              values.map(
                (partial) =>
                  new $LazyObjectOption<
                    LazilyResolvedClassUnion.$Identifier,
                    $DefaultPartial,
                    LazilyResolvedClassUnion
                  >({
                    partial,
                    resolver: (identifier) =>
                      $parameters.objectSet.lazilyResolvedClassUnion(
                        identifier,
                      ),
                  }),
              ),
            )
            .chain((values) => values.head())
            .chain((optionalLazyToResolvedClassUnionProperty) =>
              Either.of<Error, Resource.Values<Resource.TermValue>>(
                $parameters.resource.values(
                  $schema.properties
                    .optionalLazyToResolvedIriIdentifierClassProperty
                    .identifier,
                  { unique: true },
                ),
              )
                .chain((values) =>
                  values.chainMap((value) =>
                    value.toResource().chain((resource) =>
                      $NamedDefaultPartial.$fromRdf(resource, {
                        context: $parameters.context,
                        ignoreRdfType: true,
                        objectSet: $parameters.objectSet,
                        preferredLanguages: $parameters.preferredLanguages,
                      }),
                    ),
                  ),
                )
                .map((values) =>
                  values.length > 0
                    ? values.map((value) => Maybe.of(value))
                    : Resource.Values.fromValue<Maybe<$NamedDefaultPartial>>({
                        focusResource: $parameters.resource,
                        predicate:
                          LazyPropertiesClass.$schema.properties
                            .optionalLazyToResolvedIriIdentifierClassProperty
                            .identifier,
                        value: Maybe.empty(),
                      }),
                )
                .map((values) =>
                  values.map(
                    (partial) =>
                      new $LazyObjectOption<
                        LazilyResolvedIriIdentifierClass.$Identifier,
                        $NamedDefaultPartial,
                        LazilyResolvedIriIdentifierClass
                      >({
                        partial,
                        resolver: (identifier) =>
                          $parameters.objectSet.lazilyResolvedIriIdentifierClass(
                            identifier,
                          ),
                      }),
                  ),
                )
                .chain((values) => values.head())
                .chain((optionalLazyToResolvedIriIdentifierClassProperty) =>
                  Either.of<Error, Resource.Values<Resource.TermValue>>(
                    $parameters.resource.values(
                      $schema.properties
                        .optionalPartialClassToResolvedClassProperty.identifier,
                      {
                        unique: true,
                      },
                    ),
                  )
                    .chain((values) =>
                      values.chainMap((value) =>
                        value.toResource().chain((resource) =>
                          PartialClass.$fromRdf(resource, {
                            context: $parameters.context,
                            ignoreRdfType: true,
                            objectSet: $parameters.objectSet,
                            preferredLanguages: $parameters.preferredLanguages,
                          }),
                        ),
                      ),
                    )
                    .map((values) =>
                      values.length > 0
                        ? values.map((value) => Maybe.of(value))
                        : Resource.Values.fromValue<Maybe<PartialClass>>({
                            focusResource: $parameters.resource,
                            predicate:
                              LazyPropertiesClass.$schema.properties
                                .optionalPartialClassToResolvedClassProperty
                                .identifier,
                            value: Maybe.empty(),
                          }),
                    )
                    .map((values) =>
                      values.map(
                        (partial) =>
                          new $LazyObjectOption<
                            LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
                            PartialClass,
                            LazilyResolvedBlankNodeOrIriIdentifierClass
                          >({
                            partial,
                            resolver: (identifier) =>
                              $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierClass(
                                identifier,
                              ),
                          }),
                      ),
                    )
                    .chain((values) => values.head())
                    .chain((optionalPartialClassToResolvedClassProperty) =>
                      Either.of<Error, Resource.Values<Resource.TermValue>>(
                        $parameters.resource.values(
                          $schema.properties
                            .optionalPartialClassToResolvedClassUnionProperty
                            .identifier,
                          { unique: true },
                        ),
                      )
                        .chain((values) =>
                          values.chainMap((value) =>
                            value.toResource().chain((resource) =>
                              PartialClass.$fromRdf(resource, {
                                context: $parameters.context,
                                ignoreRdfType: true,
                                objectSet: $parameters.objectSet,
                                preferredLanguages:
                                  $parameters.preferredLanguages,
                              }),
                            ),
                          ),
                        )
                        .map((values) =>
                          values.length > 0
                            ? values.map((value) => Maybe.of(value))
                            : Resource.Values.fromValue<Maybe<PartialClass>>({
                                focusResource: $parameters.resource,
                                predicate:
                                  LazyPropertiesClass.$schema.properties
                                    .optionalPartialClassToResolvedClassUnionProperty
                                    .identifier,
                                value: Maybe.empty(),
                              }),
                        )
                        .map((values) =>
                          values.map(
                            (partial) =>
                              new $LazyObjectOption<
                                LazilyResolvedClassUnion.$Identifier,
                                PartialClass,
                                LazilyResolvedClassUnion
                              >({
                                partial,
                                resolver: (identifier) =>
                                  $parameters.objectSet.lazilyResolvedClassUnion(
                                    identifier,
                                  ),
                              }),
                          ),
                        )
                        .chain((values) => values.head())
                        .chain(
                          (optionalPartialClassToResolvedClassUnionProperty) =>
                            Either.of<
                              Error,
                              Resource.Values<Resource.TermValue>
                            >(
                              $parameters.resource.values(
                                $schema.properties
                                  .optionalPartialClassUnionToResolvedClassUnionProperty
                                  .identifier,
                                { unique: true },
                              ),
                            )
                              .chain((values) =>
                                values.chainMap((value) =>
                                  value.toResource().chain((resource) =>
                                    PartialClassUnion.$fromRdf(resource, {
                                      context: $parameters.context,
                                      ignoreRdfType: false,
                                      objectSet: $parameters.objectSet,
                                      preferredLanguages:
                                        $parameters.preferredLanguages,
                                    }),
                                  ),
                                ),
                              )
                              .map((values) =>
                                values.length > 0
                                  ? values.map((value) => Maybe.of(value))
                                  : Resource.Values.fromValue<
                                      Maybe<PartialClassUnion>
                                    >({
                                      focusResource: $parameters.resource,
                                      predicate:
                                        LazyPropertiesClass.$schema.properties
                                          .optionalPartialClassUnionToResolvedClassUnionProperty
                                          .identifier,
                                      value: Maybe.empty(),
                                    }),
                              )
                              .map((values) =>
                                values.map(
                                  (partial) =>
                                    new $LazyObjectOption<
                                      LazilyResolvedClassUnion.$Identifier,
                                      PartialClassUnion,
                                      LazilyResolvedClassUnion
                                    >({
                                      partial,
                                      resolver: (identifier) =>
                                        $parameters.objectSet.lazilyResolvedClassUnion(
                                          identifier,
                                        ),
                                    }),
                                ),
                              )
                              .chain((values) => values.head())
                              .chain(
                                (
                                  optionalPartialClassUnionToResolvedClassUnionProperty,
                                ) =>
                                  Either.of<
                                    Error,
                                    Resource.Values<Resource.TermValue>
                                  >(
                                    $parameters.resource.values(
                                      $schema.properties
                                        .requiredLazyToResolvedClassProperty
                                        .identifier,
                                      {
                                        unique: true,
                                      },
                                    ),
                                  )
                                    .chain((values) =>
                                      values.chainMap((value) =>
                                        value.toResource().chain((resource) =>
                                          $DefaultPartial.$fromRdf(resource, {
                                            context: $parameters.context,
                                            ignoreRdfType: true,
                                            objectSet: $parameters.objectSet,
                                            preferredLanguages:
                                              $parameters.preferredLanguages,
                                          }),
                                        ),
                                      ),
                                    )
                                    .map((values) =>
                                      values.map(
                                        (partial) =>
                                          new $LazyObject<
                                            LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
                                            $DefaultPartial,
                                            LazilyResolvedBlankNodeOrIriIdentifierClass
                                          >({
                                            partial,
                                            resolver: (identifier) =>
                                              $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierClass(
                                                identifier,
                                              ),
                                          }),
                                      ),
                                    )
                                    .chain((values) => values.head())
                                    .chain(
                                      (requiredLazyToResolvedClassProperty) =>
                                        Either.of<
                                          Error,
                                          Resource.Values<Resource.TermValue>
                                        >(
                                          $parameters.resource.values(
                                            $schema.properties
                                              .requiredPartialClassToResolvedClassProperty
                                              .identifier,
                                            { unique: true },
                                          ),
                                        )
                                          .chain((values) =>
                                            values.chainMap((value) =>
                                              value
                                                .toResource()
                                                .chain((resource) =>
                                                  PartialClass.$fromRdf(
                                                    resource,
                                                    {
                                                      context:
                                                        $parameters.context,
                                                      ignoreRdfType: true,
                                                      objectSet:
                                                        $parameters.objectSet,
                                                      preferredLanguages:
                                                        $parameters.preferredLanguages,
                                                    },
                                                  ),
                                                ),
                                            ),
                                          )
                                          .map((values) =>
                                            values.map(
                                              (partial) =>
                                                new $LazyObject<
                                                  LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
                                                  PartialClass,
                                                  LazilyResolvedBlankNodeOrIriIdentifierClass
                                                >({
                                                  partial,
                                                  resolver: (identifier) =>
                                                    $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierClass(
                                                      identifier,
                                                    ),
                                                }),
                                            ),
                                          )
                                          .chain((values) => values.head())
                                          .chain(
                                            (
                                              requiredPartialClassToResolvedClassProperty,
                                            ) =>
                                              Either.of<
                                                Error,
                                                Resource.Values<Resource.TermValue>
                                              >(
                                                $parameters.resource.values(
                                                  $schema.properties
                                                    .setLazyToResolvedClassProperty
                                                    .identifier,
                                                  {
                                                    unique: true,
                                                  },
                                                ),
                                              )
                                                .chain((values) =>
                                                  values.chainMap((value) =>
                                                    value
                                                      .toResource()
                                                      .chain((resource) =>
                                                        $DefaultPartial.$fromRdf(
                                                          resource,
                                                          {
                                                            context:
                                                              $parameters.context,
                                                            ignoreRdfType: true,
                                                            objectSet:
                                                              $parameters.objectSet,
                                                            preferredLanguages:
                                                              $parameters.preferredLanguages,
                                                          },
                                                        ),
                                                      ),
                                                  ),
                                                )
                                                .map((values) =>
                                                  values.toArray(),
                                                )
                                                .map((valuesArray) =>
                                                  Resource.Values.fromValue({
                                                    focusResource:
                                                      $parameters.resource,
                                                    predicate:
                                                      LazyPropertiesClass
                                                        .$schema.properties
                                                        .setLazyToResolvedClassProperty
                                                        .identifier,
                                                    value: valuesArray,
                                                  }),
                                                )
                                                .map((values) =>
                                                  values.map(
                                                    (partials) =>
                                                      new $LazyObjectSet<
                                                        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
                                                        $DefaultPartial,
                                                        LazilyResolvedBlankNodeOrIriIdentifierClass
                                                      >({
                                                        partials,
                                                        resolver: (
                                                          identifiers,
                                                        ) =>
                                                          $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierClasses(
                                                            { identifiers },
                                                          ),
                                                      }),
                                                  ),
                                                )
                                                .chain((values) =>
                                                  values.head(),
                                                )
                                                .chain(
                                                  (
                                                    setLazyToResolvedClassProperty,
                                                  ) =>
                                                    Either.of<
                                                      Error,
                                                      Resource.Values<Resource.TermValue>
                                                    >(
                                                      $parameters.resource.values(
                                                        $schema.properties
                                                          .setPartialClassToResolvedClassProperty
                                                          .identifier,
                                                        { unique: true },
                                                      ),
                                                    )
                                                      .chain((values) =>
                                                        values.chainMap(
                                                          (value) =>
                                                            value
                                                              .toResource()
                                                              .chain(
                                                                (resource) =>
                                                                  PartialClass.$fromRdf(
                                                                    resource,
                                                                    {
                                                                      context:
                                                                        $parameters.context,
                                                                      ignoreRdfType: true,
                                                                      objectSet:
                                                                        $parameters.objectSet,
                                                                      preferredLanguages:
                                                                        $parameters.preferredLanguages,
                                                                    },
                                                                  ),
                                                              ),
                                                        ),
                                                      )
                                                      .map((values) =>
                                                        values.toArray(),
                                                      )
                                                      .map((valuesArray) =>
                                                        Resource.Values.fromValue(
                                                          {
                                                            focusResource:
                                                              $parameters.resource,
                                                            predicate:
                                                              LazyPropertiesClass
                                                                .$schema
                                                                .properties
                                                                .setPartialClassToResolvedClassProperty
                                                                .identifier,
                                                            value: valuesArray,
                                                          },
                                                        ),
                                                      )
                                                      .map((values) =>
                                                        values.map(
                                                          (partials) =>
                                                            new $LazyObjectSet<
                                                              LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
                                                              PartialClass,
                                                              LazilyResolvedBlankNodeOrIriIdentifierClass
                                                            >({
                                                              partials,
                                                              resolver: (
                                                                identifiers,
                                                              ) =>
                                                                $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierClasses(
                                                                  {
                                                                    identifiers,
                                                                  },
                                                                ),
                                                            }),
                                                        ),
                                                      )
                                                      .chain((values) =>
                                                        values.head(),
                                                      )
                                                      .map(
                                                        (
                                                          setPartialClassToResolvedClassProperty,
                                                        ) => ({
                                                          $identifier,
                                                          optionalLazyToResolvedClassProperty,
                                                          optionalLazyToResolvedClassUnionProperty,
                                                          optionalLazyToResolvedIriIdentifierClassProperty,
                                                          optionalPartialClassToResolvedClassProperty,
                                                          optionalPartialClassToResolvedClassUnionProperty,
                                                          optionalPartialClassUnionToResolvedClassUnionProperty,
                                                          requiredLazyToResolvedClassProperty,
                                                          requiredPartialClassToResolvedClassProperty,
                                                          setLazyToResolvedClassProperty,
                                                          setPartialClassToResolvedClassProperty,
                                                        }),
                                                      ),
                                                ),
                                          ),
                                    ),
                              ),
                        ),
                    ),
                ),
            ),
        ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["LazyPropertiesClass"],
        }),
      },
      optionalLazyToResolvedClassProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "LazyObjectOption" as const,
          partial: () => ({
            kind: "Maybe" as const,
            item: () => $DefaultPartial.$schema,
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/optionalLazyToResolvedClassProperty",
        ),
      },
      optionalLazyToResolvedClassUnionProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "LazyObjectOption" as const,
          partial: () => ({
            kind: "Maybe" as const,
            item: () => $DefaultPartial.$schema,
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/optionalLazyToResolvedClassUnionProperty",
        ),
      },
      optionalLazyToResolvedIriIdentifierClassProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "LazyObjectOption" as const,
          partial: () => ({
            kind: "Maybe" as const,
            item: () => $NamedDefaultPartial.$schema,
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/optionalLazyToResolvedIriIdentifierClassProperty",
        ),
      },
      optionalPartialClassToResolvedClassProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "LazyObjectOption" as const,
          partial: () => ({
            kind: "Maybe" as const,
            item: () => PartialClass.$schema,
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/optionalPartialClassToResolvedClassProperty",
        ),
      },
      optionalPartialClassToResolvedClassUnionProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "LazyObjectOption" as const,
          partial: () => ({
            kind: "Maybe" as const,
            item: () => PartialClass.$schema,
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/optionalPartialClassToResolvedClassUnionProperty",
        ),
      },
      optionalPartialClassUnionToResolvedClassUnionProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "LazyObjectOption" as const,
          partial: () => ({
            kind: "Maybe" as const,
            item: () => PartialClassUnion.$schema,
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/optionalPartialClassUnionToResolvedClassUnionProperty",
        ),
      },
      requiredLazyToResolvedClassProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "LazyObject" as const,
          partial: () => $DefaultPartial.$schema,
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/requiredLazyToResolvedClassProperty",
        ),
      },
      requiredPartialClassToResolvedClassProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "LazyObject" as const,
          partial: () => PartialClass.$schema,
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/requiredPartialClassToResolvedClassProperty",
        ),
      },
      setLazyToResolvedClassProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "LazyObjectSet" as const,
          partial: () => ({
            kind: "Set" as const,
            item: () => $DefaultPartial.$schema,
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/setLazyToResolvedClassProperty",
        ),
      },
      setPartialClassToResolvedClassProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "LazyObjectSet" as const,
          partial: () => ({
            kind: "Set" as const,
            item: () => PartialClass.$schema,
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/setPartialClassToResolvedClassProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazyPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazyPropertiesClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          LazyPropertiesClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazyPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazyPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("lazyPropertiesClass");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }OptionalLazyToResolvedClassProperty`,
        ),
        predicate:
          LazyPropertiesClass.$schema.properties
            .optionalLazyToResolvedClassProperty.identifier,
        subject: subject,
      },
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }OptionalLazyToResolvedClassProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesClass")
        }OptionalLazyToResolvedClassProperty`,
      }),
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }OptionalLazyToResolvedClassUnionProperty`,
        ),
        predicate:
          LazyPropertiesClass.$schema.properties
            .optionalLazyToResolvedClassUnionProperty.identifier,
        subject: subject,
      },
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }OptionalLazyToResolvedClassUnionProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesClass")
        }OptionalLazyToResolvedClassUnionProperty`,
      }),
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }OptionalLazyToResolvedIriIdentifierClassProperty`,
        ),
        predicate:
          LazyPropertiesClass.$schema.properties
            .optionalLazyToResolvedIriIdentifierClassProperty.identifier,
        subject: subject,
      },
      ...$NamedDefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }OptionalLazyToResolvedIriIdentifierClassProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesClass")
        }OptionalLazyToResolvedIriIdentifierClassProperty`,
      }),
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }OptionalPartialClassToResolvedClassProperty`,
        ),
        predicate:
          LazyPropertiesClass.$schema.properties
            .optionalPartialClassToResolvedClassProperty.identifier,
        subject: subject,
      },
      ...PartialClass.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }OptionalPartialClassToResolvedClassProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesClass")
        }OptionalPartialClassToResolvedClassProperty`,
      }),
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }OptionalPartialClassToResolvedClassUnionProperty`,
        ),
        predicate:
          LazyPropertiesClass.$schema.properties
            .optionalPartialClassToResolvedClassUnionProperty.identifier,
        subject: subject,
      },
      ...PartialClass.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }OptionalPartialClassToResolvedClassUnionProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesClass")
        }OptionalPartialClassToResolvedClassUnionProperty`,
      }),
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }OptionalPartialClassUnionToResolvedClassUnionProperty`,
        ),
        predicate:
          LazyPropertiesClass.$schema.properties
            .optionalPartialClassUnionToResolvedClassUnionProperty.identifier,
        subject: subject,
      },
      ...PartialClassUnion.$sparqlConstructTriples({
        subject: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }OptionalPartialClassUnionToResolvedClassUnionProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesClass")
        }OptionalPartialClassUnionToResolvedClassUnionProperty`,
      }),
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }RequiredLazyToResolvedClassProperty`,
        ),
        predicate:
          LazyPropertiesClass.$schema.properties
            .requiredLazyToResolvedClassProperty.identifier,
        subject: subject,
      },
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }RequiredLazyToResolvedClassProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesClass")
        }RequiredLazyToResolvedClassProperty`,
      }),
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }RequiredPartialClassToResolvedClassProperty`,
        ),
        predicate:
          LazyPropertiesClass.$schema.properties
            .requiredPartialClassToResolvedClassProperty.identifier,
        subject: subject,
      },
      ...PartialClass.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }RequiredPartialClassToResolvedClassProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesClass")
        }RequiredPartialClassToResolvedClassProperty`,
      }),
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }SetLazyToResolvedClassProperty`,
        ),
        predicate:
          LazyPropertiesClass.$schema.properties.setLazyToResolvedClassProperty
            .identifier,
        subject: subject,
      },
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }SetLazyToResolvedClassProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesClass")
        }SetLazyToResolvedClassProperty`,
      }),
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }SetPartialClassToResolvedClassProperty`,
        ),
        predicate:
          LazyPropertiesClass.$schema.properties
            .setPartialClassToResolvedClassProperty.identifier,
        subject: subject,
      },
      ...PartialClass.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }SetPartialClassToResolvedClassProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesClass")
        }SetPartialClassToResolvedClassProperty`,
      }),
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazyPropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("lazyPropertiesClass");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: LazyPropertiesClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass"),
        }),
      );
    }
    patterns = patterns.concat(
      (({ schema, ...otherParameters }) =>
        $maybeSparqlWherePatterns<
          $DefaultPartial.$Filter,
          typeof $DefaultPartial.$schema
        >(
          ({
            ignoreRdfType,
            propertyPatterns,
            valueVariable,
            ...otherParameters
          }: $SparqlWherePatternsFunctionParameters<
            $DefaultPartial.$Filter,
            typeof $DefaultPartial.$schema
          >) =>
            (propertyPatterns as readonly $SparqlPattern[]).concat(
              $DefaultPartial.$sparqlWherePatterns({
                ignoreRdfType: ignoreRdfType ?? true,
                subject: valueVariable,
                ...otherParameters,
              }),
            ),
        )({ schema: schema.partial(), ...otherParameters }))({
        filter: parameters?.filter?.optionalLazyToResolvedClassProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazyPropertiesClass")
                  }OptionalLazyToResolvedClassProperty`,
                ),
                predicate:
                  LazyPropertiesClass.$schema.properties
                    .optionalLazyToResolvedClassProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazyPropertiesClass.$schema.properties.optionalLazyToResolvedClassProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }OptionalLazyToResolvedClassProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesClass")
        }OptionalLazyToResolvedClassProperty`,
      }),
    );
    patterns = patterns.concat(
      (({ schema, ...otherParameters }) =>
        $maybeSparqlWherePatterns<
          $DefaultPartial.$Filter,
          typeof $DefaultPartial.$schema
        >(
          ({
            ignoreRdfType,
            propertyPatterns,
            valueVariable,
            ...otherParameters
          }: $SparqlWherePatternsFunctionParameters<
            $DefaultPartial.$Filter,
            typeof $DefaultPartial.$schema
          >) =>
            (propertyPatterns as readonly $SparqlPattern[]).concat(
              $DefaultPartial.$sparqlWherePatterns({
                ignoreRdfType: ignoreRdfType ?? true,
                subject: valueVariable,
                ...otherParameters,
              }),
            ),
        )({ schema: schema.partial(), ...otherParameters }))({
        filter: parameters?.filter?.optionalLazyToResolvedClassUnionProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazyPropertiesClass")
                  }OptionalLazyToResolvedClassUnionProperty`,
                ),
                predicate:
                  LazyPropertiesClass.$schema.properties
                    .optionalLazyToResolvedClassUnionProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazyPropertiesClass.$schema.properties.optionalLazyToResolvedClassUnionProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }OptionalLazyToResolvedClassUnionProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesClass")
        }OptionalLazyToResolvedClassUnionProperty`,
      }),
    );
    patterns = patterns.concat(
      (({ schema, ...otherParameters }) =>
        $maybeSparqlWherePatterns<
          $NamedDefaultPartial.$Filter,
          typeof $NamedDefaultPartial.$schema
        >(
          ({
            ignoreRdfType,
            propertyPatterns,
            valueVariable,
            ...otherParameters
          }: $SparqlWherePatternsFunctionParameters<
            $NamedDefaultPartial.$Filter,
            typeof $NamedDefaultPartial.$schema
          >) =>
            (propertyPatterns as readonly $SparqlPattern[]).concat(
              $NamedDefaultPartial.$sparqlWherePatterns({
                ignoreRdfType: ignoreRdfType ?? true,
                subject: valueVariable,
                ...otherParameters,
              }),
            ),
        )({ schema: schema.partial(), ...otherParameters }))({
        filter:
          parameters?.filter?.optionalLazyToResolvedIriIdentifierClassProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazyPropertiesClass")
                  }OptionalLazyToResolvedIriIdentifierClassProperty`,
                ),
                predicate:
                  LazyPropertiesClass.$schema.properties
                    .optionalLazyToResolvedIriIdentifierClassProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazyPropertiesClass.$schema.properties.optionalLazyToResolvedIriIdentifierClassProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }OptionalLazyToResolvedIriIdentifierClassProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesClass")
        }OptionalLazyToResolvedIriIdentifierClassProperty`,
      }),
    );
    patterns = patterns.concat(
      (({ schema, ...otherParameters }) =>
        $maybeSparqlWherePatterns<
          PartialClass.$Filter,
          typeof PartialClass.$schema
        >(
          ({
            ignoreRdfType,
            propertyPatterns,
            valueVariable,
            ...otherParameters
          }: $SparqlWherePatternsFunctionParameters<
            PartialClass.$Filter,
            typeof PartialClass.$schema
          >) =>
            (propertyPatterns as readonly $SparqlPattern[]).concat(
              PartialClass.$sparqlWherePatterns({
                ignoreRdfType: ignoreRdfType ?? true,
                subject: valueVariable,
                ...otherParameters,
              }),
            ),
        )({ schema: schema.partial(), ...otherParameters }))({
        filter: parameters?.filter?.optionalPartialClassToResolvedClassProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazyPropertiesClass")
                  }OptionalPartialClassToResolvedClassProperty`,
                ),
                predicate:
                  LazyPropertiesClass.$schema.properties
                    .optionalPartialClassToResolvedClassProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazyPropertiesClass.$schema.properties.optionalPartialClassToResolvedClassProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }OptionalPartialClassToResolvedClassProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesClass")
        }OptionalPartialClassToResolvedClassProperty`,
      }),
    );
    patterns = patterns.concat(
      (({ schema, ...otherParameters }) =>
        $maybeSparqlWherePatterns<
          PartialClass.$Filter,
          typeof PartialClass.$schema
        >(
          ({
            ignoreRdfType,
            propertyPatterns,
            valueVariable,
            ...otherParameters
          }: $SparqlWherePatternsFunctionParameters<
            PartialClass.$Filter,
            typeof PartialClass.$schema
          >) =>
            (propertyPatterns as readonly $SparqlPattern[]).concat(
              PartialClass.$sparqlWherePatterns({
                ignoreRdfType: ignoreRdfType ?? true,
                subject: valueVariable,
                ...otherParameters,
              }),
            ),
        )({ schema: schema.partial(), ...otherParameters }))({
        filter:
          parameters?.filter?.optionalPartialClassToResolvedClassUnionProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazyPropertiesClass")
                  }OptionalPartialClassToResolvedClassUnionProperty`,
                ),
                predicate:
                  LazyPropertiesClass.$schema.properties
                    .optionalPartialClassToResolvedClassUnionProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazyPropertiesClass.$schema.properties.optionalPartialClassToResolvedClassUnionProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }OptionalPartialClassToResolvedClassUnionProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesClass")
        }OptionalPartialClassToResolvedClassUnionProperty`,
      }),
    );
    patterns = patterns.concat(
      (({ schema, ...otherParameters }) =>
        $maybeSparqlWherePatterns<
          PartialClassUnion.$Filter,
          typeof PartialClassUnion.$schema
        >(({ propertyPatterns, valueVariable, ...otherParameters }) =>
          (propertyPatterns as readonly $SparqlPattern[]).concat(
            PartialClassUnion.$sparqlWherePatterns({
              subject: valueVariable,
              ...otherParameters,
            }),
          ),
        )({ schema: schema.partial(), ...otherParameters }))({
        filter:
          parameters?.filter
            ?.optionalPartialClassUnionToResolvedClassUnionProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazyPropertiesClass")
                  }OptionalPartialClassUnionToResolvedClassUnionProperty`,
                ),
                predicate:
                  LazyPropertiesClass.$schema.properties
                    .optionalPartialClassUnionToResolvedClassUnionProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazyPropertiesClass.$schema.properties.optionalPartialClassUnionToResolvedClassUnionProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }OptionalPartialClassUnionToResolvedClassUnionProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesClass")
        }OptionalPartialClassUnionToResolvedClassUnionProperty`,
      }),
    );
    patterns = patterns.concat(
      (({ schema, ...otherParameters }) =>
        (({
          ignoreRdfType,
          propertyPatterns,
          valueVariable,
          ...otherParameters
        }: $SparqlWherePatternsFunctionParameters<
          $DefaultPartial.$Filter,
          typeof $DefaultPartial.$schema
        >) =>
          (propertyPatterns as readonly $SparqlPattern[]).concat(
            $DefaultPartial.$sparqlWherePatterns({
              ignoreRdfType: ignoreRdfType ?? true,
              subject: valueVariable,
              ...otherParameters,
            }),
          ))({ schema: schema.partial(), ...otherParameters }))({
        filter: parameters?.filter?.requiredLazyToResolvedClassProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazyPropertiesClass")
                  }RequiredLazyToResolvedClassProperty`,
                ),
                predicate:
                  LazyPropertiesClass.$schema.properties
                    .requiredLazyToResolvedClassProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazyPropertiesClass.$schema.properties.requiredLazyToResolvedClassProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }RequiredLazyToResolvedClassProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesClass")
        }RequiredLazyToResolvedClassProperty`,
      }),
    );
    patterns = patterns.concat(
      (({ schema, ...otherParameters }) =>
        (({
          ignoreRdfType,
          propertyPatterns,
          valueVariable,
          ...otherParameters
        }: $SparqlWherePatternsFunctionParameters<
          PartialClass.$Filter,
          typeof PartialClass.$schema
        >) =>
          (propertyPatterns as readonly $SparqlPattern[]).concat(
            PartialClass.$sparqlWherePatterns({
              ignoreRdfType: ignoreRdfType ?? true,
              subject: valueVariable,
              ...otherParameters,
            }),
          ))({ schema: schema.partial(), ...otherParameters }))({
        filter: parameters?.filter?.requiredPartialClassToResolvedClassProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazyPropertiesClass")
                  }RequiredPartialClassToResolvedClassProperty`,
                ),
                predicate:
                  LazyPropertiesClass.$schema.properties
                    .requiredPartialClassToResolvedClassProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazyPropertiesClass.$schema.properties.requiredPartialClassToResolvedClassProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }RequiredPartialClassToResolvedClassProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesClass")
        }RequiredPartialClassToResolvedClassProperty`,
      }),
    );
    patterns = patterns.concat(
      (({ schema, ...otherParameters }) =>
        $setSparqlWherePatterns<
          $DefaultPartial.$Filter,
          typeof $DefaultPartial.$schema
        >(
          ({
            ignoreRdfType,
            propertyPatterns,
            valueVariable,
            ...otherParameters
          }: $SparqlWherePatternsFunctionParameters<
            $DefaultPartial.$Filter,
            typeof $DefaultPartial.$schema
          >) =>
            (propertyPatterns as readonly $SparqlPattern[]).concat(
              $DefaultPartial.$sparqlWherePatterns({
                ignoreRdfType: ignoreRdfType ?? true,
                subject: valueVariable,
                ...otherParameters,
              }),
            ),
        )({ schema: schema.partial(), ...otherParameters }))({
        filter: parameters?.filter?.setLazyToResolvedClassProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazyPropertiesClass")
                  }SetLazyToResolvedClassProperty`,
                ),
                predicate:
                  LazyPropertiesClass.$schema.properties
                    .setLazyToResolvedClassProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazyPropertiesClass.$schema.properties.setLazyToResolvedClassProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }SetLazyToResolvedClassProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesClass")
        }SetLazyToResolvedClassProperty`,
      }),
    );
    patterns = patterns.concat(
      (({ schema, ...otherParameters }) =>
        $setSparqlWherePatterns<
          PartialClass.$Filter,
          typeof PartialClass.$schema
        >(
          ({
            ignoreRdfType,
            propertyPatterns,
            valueVariable,
            ...otherParameters
          }: $SparqlWherePatternsFunctionParameters<
            PartialClass.$Filter,
            typeof PartialClass.$schema
          >) =>
            (propertyPatterns as readonly $SparqlPattern[]).concat(
              PartialClass.$sparqlWherePatterns({
                ignoreRdfType: ignoreRdfType ?? true,
                subject: valueVariable,
                ...otherParameters,
              }),
            ),
        )({ schema: schema.partial(), ...otherParameters }))({
        filter: parameters?.filter?.setPartialClassToResolvedClassProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazyPropertiesClass")
                  }SetPartialClassToResolvedClassProperty`,
                ),
                predicate:
                  LazyPropertiesClass.$schema.properties
                    .setPartialClassToResolvedClassProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazyPropertiesClass.$schema.properties.setPartialClassToResolvedClassProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazyPropertiesClass")
          }SetPartialClassToResolvedClassProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazyPropertiesClass")
        }SetPartialClassToResolvedClassProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Node shape resolved by LazyPropertiesInterface
 */

export interface LazilyResolvedIriIdentifierInterface {
  readonly $identifier: LazilyResolvedIriIdentifierInterface.$Identifier;
  readonly $type: "LazilyResolvedIriIdentifierInterface";
  readonly lazilyResolvedStringProperty: string;
}

export namespace LazilyResolvedIriIdentifierInterface {
  export function $create(parameters: {
    readonly $identifier: NamedNode | string;
    readonly lazilyResolvedStringProperty: string;
  }): LazilyResolvedIriIdentifierInterface {
    let $identifier: LazilyResolvedIriIdentifierInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      $identifier = parameters.$identifier satisfies never;
    }
    const $type = "LazilyResolvedIriIdentifierInterface" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: LazilyResolvedIriIdentifierInterface,
    right: LazilyResolvedIriIdentifierInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  export function $hash<HasherT extends $Hasher>(
    _lazilyResolvedIriIdentifierInterface: LazilyResolvedIriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    LazilyResolvedIriIdentifierInterface.$hashShaclProperties(
      _lazilyResolvedIriIdentifierInterface,
      _hasher,
    );
    _hasher.update(_lazilyResolvedIriIdentifierInterface.$identifier.value);
    _hasher.update(_lazilyResolvedIriIdentifierInterface.$type);
    return _hasher;
  }

  export function $hashShaclProperties<HasherT extends $Hasher>(
    _lazilyResolvedIriIdentifierInterface: LazilyResolvedIriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _lazilyResolvedIriIdentifierInterface.lazilyResolvedStringProperty,
    );
    return _hasher;
  }

  export function $filter(
    filter: LazilyResolvedIriIdentifierInterface.$Filter,
    value: LazilyResolvedIriIdentifierInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export type $Identifier = NamedNode;

  export namespace $Identifier {
    export function fromString(identifier: string): Either<Error, NamedNode> {
      return Either.encase(() =>
        Resource.Identifier.fromString({ dataFactory, identifier }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? Either.of(identifier)
          : Left(new Error("expected identifier to be NamedNode")),
      ) as Either<Error, NamedNode>;
    } // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: NamedNode;
      $type: "LazilyResolvedIriIdentifierInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const $type = "LazilyResolvedIriIdentifierInterface" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return Either.of({ $identifier, $type, lazilyResolvedStringProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, LazilyResolvedIriIdentifierInterface> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: {
                const: "LazilyResolvedIriIdentifierInterface" as const,
              },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedIriIdentifierInterface",
      type: "Group",
    };
  }

  export function $toJson(
    _lazilyResolvedIriIdentifierInterface: LazilyResolvedIriIdentifierInterface,
  ): LazilyResolvedIriIdentifierInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": _lazilyResolvedIriIdentifierInterface.$identifier.value,
        $type: _lazilyResolvedIriIdentifierInterface.$type,
        lazilyResolvedStringProperty:
          _lazilyResolvedIriIdentifierInterface.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedIriIdentifierInterface.$Json),
    );
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("LazilyResolvedIriIdentifierInterface"),
      lazilyResolvedStringProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedIriIdentifierInterface";
    readonly lazilyResolvedStringProperty: string;
  };

  export function isLazilyResolvedIriIdentifierInterface(
    object: $Object,
  ): object is LazilyResolvedIriIdentifierInterface {
    switch (object.$type) {
      case "LazilyResolvedIriIdentifierInterface":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, LazilyResolvedIriIdentifierInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return LazilyResolvedIriIdentifierInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: NamedNode;
      $type: "LazilyResolvedIriIdentifierInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    return (
      $parameters.resource.identifier.termType === "NamedNode"
        ? Either.of<Error, LazilyResolvedIriIdentifierInterface.$Identifier>(
            $parameters.resource.identifier,
          )
        : Left(
            new Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "NamedNode",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
    ).chain(($identifier) =>
      Either.of<Error, "LazilyResolvedIriIdentifierInterface">(
        "LazilyResolvedIriIdentifierInterface" as const,
      ).chain(($type) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.lazilyResolvedStringProperty.identifier,
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                LazilyResolvedIriIdentifierInterface.$schema.properties
                  .lazilyResolvedStringProperty.identifier,
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((lazilyResolvedStringProperty) => ({
            $identifier,
            $type,
            lazilyResolvedStringProperty,
          })),
      ),
    );
  }

  export function $toRdf(
    _lazilyResolvedIriIdentifierInterface: LazilyResolvedIriIdentifierInterface,
    options?: {
      ignoreRdfType?: boolean;
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource<NamedNode> {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(
      _lazilyResolvedIriIdentifierInterface.$identifier,
    );
    resource.add(
      LazilyResolvedIriIdentifierInterface.$schema.properties
        .lazilyResolvedStringProperty.identifier,
      [
        $literalFactory.string(
          _lazilyResolvedIriIdentifierInterface.lazilyResolvedStringProperty,
        ),
      ],
      options?.graph,
    );
    return resource;
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "NamedNode" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["LazilyResolvedIriIdentifierInterface"],
        }),
      },
      lazilyResolvedStringProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/lazilyResolvedStringProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedIriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedIriIdentifierInterface.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          LazilyResolvedIriIdentifierInterface.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedIriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedIriIdentifierInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedIriIdentifierInterface");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedIriIdentifierInterface")
          }LazilyResolvedStringProperty`,
        ),
        predicate:
          LazilyResolvedIriIdentifierInterface.$schema.properties
            .lazilyResolvedStringProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedIriIdentifierInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedIriIdentifierInterface");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $namedNodeSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            LazilyResolvedIriIdentifierInterface.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedIriIdentifierInterface"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.lazilyResolvedStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazilyResolvedIriIdentifierInterface")
                  }LazilyResolvedStringProperty`,
                ),
                predicate:
                  LazilyResolvedIriIdentifierInterface.$schema.properties
                    .lazilyResolvedStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazilyResolvedIriIdentifierInterface.$schema.properties.lazilyResolvedStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedIriIdentifierInterface")
          }LazilyResolvedStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazilyResolvedIriIdentifierInterface")
        }LazilyResolvedStringProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Node shape resolved by LazyPropertiesClass
 */

export class LazilyResolvedIriIdentifierClass {
  readonly $identifier: LazilyResolvedIriIdentifierClass.$Identifier;

  readonly $type: "LazilyResolvedIriIdentifierClass" =
    "LazilyResolvedIriIdentifierClass" as const;

  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier: NamedNode | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this.$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this.$identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      this.$identifier = parameters.$identifier satisfies never;
    }
    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  $equals(other: LazilyResolvedIriIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): LazilyResolvedIriIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedIriIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource<NamedNode> {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    resource.add(
      LazilyResolvedIriIdentifierClass.$schema.properties
        .lazilyResolvedStringProperty.identifier,
      [$literalFactory.string(this.lazilyResolvedStringProperty)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LazilyResolvedIriIdentifierClass {
  export function $filter(
    filter: LazilyResolvedIriIdentifierClass.$Filter,
    value: LazilyResolvedIriIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export type $Identifier = NamedNode;

  export namespace $Identifier {
    export function fromString(identifier: string): Either<Error, NamedNode> {
      return Either.encase(() =>
        Resource.Identifier.fromString({ dataFactory, identifier }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? Either.of(identifier)
          : Left(new Error("expected identifier to be NamedNode")),
      ) as Either<Error, NamedNode>;
    } // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<
    z.ZodError,
    { $identifier: NamedNode; lazilyResolvedStringProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, LazilyResolvedIriIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new LazilyResolvedIriIdentifierClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedIriIdentifierClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedIriIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("LazilyResolvedIriIdentifierClass"),
      lazilyResolvedStringProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedIriIdentifierClass";
    readonly lazilyResolvedStringProperty: string;
  };

  export function isLazilyResolvedIriIdentifierClass(
    object: $Object,
  ): object is LazilyResolvedIriIdentifierClass {
    switch (object.$type) {
      case "LazilyResolvedIriIdentifierClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, LazilyResolvedIriIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return LazilyResolvedIriIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new LazilyResolvedIriIdentifierClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    { $identifier: NamedNode; lazilyResolvedStringProperty: string }
  > {
    return (
      $parameters.resource.identifier.termType === "NamedNode"
        ? Either.of<Error, LazilyResolvedIriIdentifierClass.$Identifier>(
            $parameters.resource.identifier,
          )
        : Left(
            new Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "NamedNode",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
    ).chain(($identifier) =>
      Either.of<Error, Resource.Values<Resource.TermValue>>(
        $parameters.resource.values(
          $schema.properties.lazilyResolvedStringProperty.identifier,
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              LazilyResolvedIriIdentifierClass.$schema.properties
                .lazilyResolvedStringProperty.identifier,
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((lazilyResolvedStringProperty) => ({
          $identifier,
          lazilyResolvedStringProperty,
        })),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "NamedNode" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["LazilyResolvedIriIdentifierClass"],
        }),
      },
      lazilyResolvedStringProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/lazilyResolvedStringProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedIriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedIriIdentifierClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          LazilyResolvedIriIdentifierClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedIriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedIriIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedIriIdentifierClass");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedIriIdentifierClass")
          }LazilyResolvedStringProperty`,
        ),
        predicate:
          LazilyResolvedIriIdentifierClass.$schema.properties
            .lazilyResolvedStringProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedIriIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedIriIdentifierClass");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $namedNodeSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            LazilyResolvedIriIdentifierClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedIriIdentifierClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.lazilyResolvedStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazilyResolvedIriIdentifierClass")
                  }LazilyResolvedStringProperty`,
                ),
                predicate:
                  LazilyResolvedIriIdentifierClass.$schema.properties
                    .lazilyResolvedStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazilyResolvedIriIdentifierClass.$schema.properties.lazilyResolvedStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedIriIdentifierClass")
          }LazilyResolvedStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazilyResolvedIriIdentifierClass")
        }LazilyResolvedStringProperty`,
      }),
    );
    return patterns;
  }
}
export interface LazilyResolvedInterfaceUnionMember2 {
  readonly $identifier: LazilyResolvedInterfaceUnionMember2.$Identifier;
  readonly $type: "LazilyResolvedInterfaceUnionMember2";
  readonly lazilyResolvedStringProperty: string;
}

export namespace LazilyResolvedInterfaceUnionMember2 {
  export function $create(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): LazilyResolvedInterfaceUnionMember2 {
    let $identifier: LazilyResolvedInterfaceUnionMember2.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }
    const $type = "LazilyResolvedInterfaceUnionMember2" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: LazilyResolvedInterfaceUnionMember2,
    right: LazilyResolvedInterfaceUnionMember2,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  export function $hash<HasherT extends $Hasher>(
    _lazilyResolvedInterfaceUnionMember2: LazilyResolvedInterfaceUnionMember2,
    _hasher: HasherT,
  ): HasherT {
    LazilyResolvedInterfaceUnionMember2.$hashShaclProperties(
      _lazilyResolvedInterfaceUnionMember2,
      _hasher,
    );
    _hasher.update(_lazilyResolvedInterfaceUnionMember2.$identifier.value);
    _hasher.update(_lazilyResolvedInterfaceUnionMember2.$type);
    return _hasher;
  }

  export function $hashShaclProperties<HasherT extends $Hasher>(
    _lazilyResolvedInterfaceUnionMember2: LazilyResolvedInterfaceUnionMember2,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _lazilyResolvedInterfaceUnionMember2.lazilyResolvedStringProperty,
    );
    return _hasher;
  }

  export function $filter(
    filter: LazilyResolvedInterfaceUnionMember2.$Filter,
    value: LazilyResolvedInterfaceUnionMember2,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedInterfaceUnionMember2",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      $type: "LazilyResolvedInterfaceUnionMember2";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "LazilyResolvedInterfaceUnionMember2" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return Either.of({ $identifier, $type, lazilyResolvedStringProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, LazilyResolvedInterfaceUnionMember2> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedInterfaceUnionMember2" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedInterfaceUnionMember2",
      type: "Group",
    };
  }

  export function $toJson(
    _lazilyResolvedInterfaceUnionMember2: LazilyResolvedInterfaceUnionMember2,
  ): LazilyResolvedInterfaceUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _lazilyResolvedInterfaceUnionMember2.$identifier.termType ===
          "BlankNode"
            ? `_:${_lazilyResolvedInterfaceUnionMember2.$identifier.value}`
            : _lazilyResolvedInterfaceUnionMember2.$identifier.value,
        $type: _lazilyResolvedInterfaceUnionMember2.$type,
        lazilyResolvedStringProperty:
          _lazilyResolvedInterfaceUnionMember2.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedInterfaceUnionMember2.$Json),
    );
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("LazilyResolvedInterfaceUnionMember2"),
      lazilyResolvedStringProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedInterfaceUnionMember2";
    readonly lazilyResolvedStringProperty: string;
  };

  export function isLazilyResolvedInterfaceUnionMember2(
    object: $Object,
  ): object is LazilyResolvedInterfaceUnionMember2 {
    switch (object.$type) {
      case "LazilyResolvedInterfaceUnionMember2":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, LazilyResolvedInterfaceUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return LazilyResolvedInterfaceUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      $type: "LazilyResolvedInterfaceUnionMember2";
      lazilyResolvedStringProperty: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/LazilyResolvedInterfaceUnionMember2":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  LazilyResolvedInterfaceUnionMember2.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedInterfaceUnionMember2)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, LazilyResolvedInterfaceUnionMember2.$Identifier>(
        $parameters.resource
          .identifier as LazilyResolvedInterfaceUnionMember2.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, "LazilyResolvedInterfaceUnionMember2">(
          "LazilyResolvedInterfaceUnionMember2" as const,
        ).chain(($type) =>
          Either.of<Error, Resource.Values<Resource.TermValue>>(
            $parameters.resource.values(
              $schema.properties.lazilyResolvedStringProperty.identifier,
              {
                unique: true,
              },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  LazilyResolvedInterfaceUnionMember2.$schema.properties
                    .lazilyResolvedStringProperty.identifier,
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((lazilyResolvedStringProperty) => ({
              $identifier,
              $type,
              lazilyResolvedStringProperty,
            })),
        ),
      ),
    );
  }

  export function $toRdf(
    _lazilyResolvedInterfaceUnionMember2: LazilyResolvedInterfaceUnionMember2,
    options?: {
      ignoreRdfType?: boolean;
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(
      _lazilyResolvedInterfaceUnionMember2.$identifier,
    );
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode(
          "http://example.com/LazilyResolvedInterfaceUnionMember2",
        ),
        options?.graph,
      );
    }
    resource.add(
      LazilyResolvedInterfaceUnionMember2.$schema.properties
        .lazilyResolvedStringProperty.identifier,
      [
        $literalFactory.string(
          _lazilyResolvedInterfaceUnionMember2.lazilyResolvedStringProperty,
        ),
      ],
      options?.graph,
    );
    return resource;
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["LazilyResolvedInterfaceUnionMember2"],
        }),
      },
      lazilyResolvedStringProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/lazilyResolvedStringProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedInterfaceUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedInterfaceUnionMember2.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          LazilyResolvedInterfaceUnionMember2.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedInterfaceUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedInterfaceUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedInterfaceUnionMember2");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "lazilyResolvedInterfaceUnionMember2")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "lazilyResolvedInterfaceUnionMember2")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "lazilyResolvedInterfaceUnionMember2")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedInterfaceUnionMember2")
          }LazilyResolvedStringProperty`,
        ),
        predicate:
          LazilyResolvedInterfaceUnionMember2.$schema.properties
            .lazilyResolvedStringProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedInterfaceUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedInterfaceUnionMember2");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "lazilyResolvedInterfaceUnionMember2")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedInterfaceUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "lazilyResolvedInterfaceUnionMember2")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            LazilyResolvedInterfaceUnionMember2.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedInterfaceUnionMember2"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.lazilyResolvedStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazilyResolvedInterfaceUnionMember2")
                  }LazilyResolvedStringProperty`,
                ),
                predicate:
                  LazilyResolvedInterfaceUnionMember2.$schema.properties
                    .lazilyResolvedStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazilyResolvedInterfaceUnionMember2.$schema.properties.lazilyResolvedStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedInterfaceUnionMember2")
          }LazilyResolvedStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazilyResolvedInterfaceUnionMember2")
        }LazilyResolvedStringProperty`,
      }),
    );
    return patterns;
  }
}
export interface LazilyResolvedInterfaceUnionMember1 {
  readonly $identifier: LazilyResolvedInterfaceUnionMember1.$Identifier;
  readonly $type: "LazilyResolvedInterfaceUnionMember1";
  readonly lazilyResolvedStringProperty: string;
}

export namespace LazilyResolvedInterfaceUnionMember1 {
  export function $create(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): LazilyResolvedInterfaceUnionMember1 {
    let $identifier: LazilyResolvedInterfaceUnionMember1.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }
    const $type = "LazilyResolvedInterfaceUnionMember1" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: LazilyResolvedInterfaceUnionMember1,
    right: LazilyResolvedInterfaceUnionMember1,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  export function $hash<HasherT extends $Hasher>(
    _lazilyResolvedInterfaceUnionMember1: LazilyResolvedInterfaceUnionMember1,
    _hasher: HasherT,
  ): HasherT {
    LazilyResolvedInterfaceUnionMember1.$hashShaclProperties(
      _lazilyResolvedInterfaceUnionMember1,
      _hasher,
    );
    _hasher.update(_lazilyResolvedInterfaceUnionMember1.$identifier.value);
    _hasher.update(_lazilyResolvedInterfaceUnionMember1.$type);
    return _hasher;
  }

  export function $hashShaclProperties<HasherT extends $Hasher>(
    _lazilyResolvedInterfaceUnionMember1: LazilyResolvedInterfaceUnionMember1,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _lazilyResolvedInterfaceUnionMember1.lazilyResolvedStringProperty,
    );
    return _hasher;
  }

  export function $filter(
    filter: LazilyResolvedInterfaceUnionMember1.$Filter,
    value: LazilyResolvedInterfaceUnionMember1,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedInterfaceUnionMember1",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      $type: "LazilyResolvedInterfaceUnionMember1";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "LazilyResolvedInterfaceUnionMember1" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return Either.of({ $identifier, $type, lazilyResolvedStringProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, LazilyResolvedInterfaceUnionMember1> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedInterfaceUnionMember1" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedInterfaceUnionMember1",
      type: "Group",
    };
  }

  export function $toJson(
    _lazilyResolvedInterfaceUnionMember1: LazilyResolvedInterfaceUnionMember1,
  ): LazilyResolvedInterfaceUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _lazilyResolvedInterfaceUnionMember1.$identifier.termType ===
          "BlankNode"
            ? `_:${_lazilyResolvedInterfaceUnionMember1.$identifier.value}`
            : _lazilyResolvedInterfaceUnionMember1.$identifier.value,
        $type: _lazilyResolvedInterfaceUnionMember1.$type,
        lazilyResolvedStringProperty:
          _lazilyResolvedInterfaceUnionMember1.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedInterfaceUnionMember1.$Json),
    );
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("LazilyResolvedInterfaceUnionMember1"),
      lazilyResolvedStringProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedInterfaceUnionMember1";
    readonly lazilyResolvedStringProperty: string;
  };

  export function isLazilyResolvedInterfaceUnionMember1(
    object: $Object,
  ): object is LazilyResolvedInterfaceUnionMember1 {
    switch (object.$type) {
      case "LazilyResolvedInterfaceUnionMember1":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, LazilyResolvedInterfaceUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return LazilyResolvedInterfaceUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      $type: "LazilyResolvedInterfaceUnionMember1";
      lazilyResolvedStringProperty: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/LazilyResolvedInterfaceUnionMember1":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  LazilyResolvedInterfaceUnionMember1.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedInterfaceUnionMember1)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, LazilyResolvedInterfaceUnionMember1.$Identifier>(
        $parameters.resource
          .identifier as LazilyResolvedInterfaceUnionMember1.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, "LazilyResolvedInterfaceUnionMember1">(
          "LazilyResolvedInterfaceUnionMember1" as const,
        ).chain(($type) =>
          Either.of<Error, Resource.Values<Resource.TermValue>>(
            $parameters.resource.values(
              $schema.properties.lazilyResolvedStringProperty.identifier,
              {
                unique: true,
              },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  LazilyResolvedInterfaceUnionMember1.$schema.properties
                    .lazilyResolvedStringProperty.identifier,
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((lazilyResolvedStringProperty) => ({
              $identifier,
              $type,
              lazilyResolvedStringProperty,
            })),
        ),
      ),
    );
  }

  export function $toRdf(
    _lazilyResolvedInterfaceUnionMember1: LazilyResolvedInterfaceUnionMember1,
    options?: {
      ignoreRdfType?: boolean;
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(
      _lazilyResolvedInterfaceUnionMember1.$identifier,
    );
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode(
          "http://example.com/LazilyResolvedInterfaceUnionMember1",
        ),
        options?.graph,
      );
    }
    resource.add(
      LazilyResolvedInterfaceUnionMember1.$schema.properties
        .lazilyResolvedStringProperty.identifier,
      [
        $literalFactory.string(
          _lazilyResolvedInterfaceUnionMember1.lazilyResolvedStringProperty,
        ),
      ],
      options?.graph,
    );
    return resource;
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["LazilyResolvedInterfaceUnionMember1"],
        }),
      },
      lazilyResolvedStringProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/lazilyResolvedStringProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedInterfaceUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedInterfaceUnionMember1.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          LazilyResolvedInterfaceUnionMember1.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedInterfaceUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedInterfaceUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedInterfaceUnionMember1");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "lazilyResolvedInterfaceUnionMember1")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "lazilyResolvedInterfaceUnionMember1")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "lazilyResolvedInterfaceUnionMember1")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedInterfaceUnionMember1")
          }LazilyResolvedStringProperty`,
        ),
        predicate:
          LazilyResolvedInterfaceUnionMember1.$schema.properties
            .lazilyResolvedStringProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedInterfaceUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedInterfaceUnionMember1");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "lazilyResolvedInterfaceUnionMember1")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedInterfaceUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "lazilyResolvedInterfaceUnionMember1")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            LazilyResolvedInterfaceUnionMember1.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedInterfaceUnionMember1"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.lazilyResolvedStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazilyResolvedInterfaceUnionMember1")
                  }LazilyResolvedStringProperty`,
                ),
                predicate:
                  LazilyResolvedInterfaceUnionMember1.$schema.properties
                    .lazilyResolvedStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazilyResolvedInterfaceUnionMember1.$schema.properties.lazilyResolvedStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedInterfaceUnionMember1")
          }LazilyResolvedStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazilyResolvedInterfaceUnionMember1")
        }LazilyResolvedStringProperty`,
      }),
    );
    return patterns;
  }
}
export class LazilyResolvedClassUnionMember2 {
  private _$identifier?: LazilyResolvedClassUnionMember2.$Identifier;

  readonly $type: "LazilyResolvedClassUnionMember2" =
    "LazilyResolvedClassUnionMember2" as const;

  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): LazilyResolvedClassUnionMember2.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: LazilyResolvedClassUnionMember2): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): LazilyResolvedClassUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedClassUnionMember2.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode(
          "http://example.com/LazilyResolvedClassUnionMember2",
        ),
        options?.graph,
      );
    }
    resource.add(
      LazilyResolvedClassUnionMember2.$schema.properties
        .lazilyResolvedStringProperty.identifier,
      [$literalFactory.string(this.lazilyResolvedStringProperty)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LazilyResolvedClassUnionMember2 {
  export function $filter(
    filter: LazilyResolvedClassUnionMember2.$Filter,
    value: LazilyResolvedClassUnionMember2,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedClassUnionMember2",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<
    z.ZodError,
    { $identifier: BlankNode | NamedNode; lazilyResolvedStringProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, LazilyResolvedClassUnionMember2> {
    return $propertiesFromJson(json).map(
      (properties) => new LazilyResolvedClassUnionMember2(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedClassUnionMember2" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedClassUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("LazilyResolvedClassUnionMember2"),
      lazilyResolvedStringProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedClassUnionMember2";
    readonly lazilyResolvedStringProperty: string;
  };

  export function isLazilyResolvedClassUnionMember2(
    object: $Object,
  ): object is LazilyResolvedClassUnionMember2 {
    switch (object.$type) {
      case "LazilyResolvedClassUnionMember2":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, LazilyResolvedClassUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return LazilyResolvedClassUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new LazilyResolvedClassUnionMember2(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    { $identifier: BlankNode | NamedNode; lazilyResolvedStringProperty: string }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/LazilyResolvedClassUnionMember2":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  LazilyResolvedClassUnionMember2.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedClassUnionMember2)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, LazilyResolvedClassUnionMember2.$Identifier>(
        $parameters.resource
          .identifier as LazilyResolvedClassUnionMember2.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.lazilyResolvedStringProperty.identifier,
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                LazilyResolvedClassUnionMember2.$schema.properties
                  .lazilyResolvedStringProperty.identifier,
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((lazilyResolvedStringProperty) => ({
            $identifier,
            lazilyResolvedStringProperty,
          })),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["LazilyResolvedClassUnionMember2"],
        }),
      },
      lazilyResolvedStringProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/lazilyResolvedStringProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedClassUnionMember2.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          LazilyResolvedClassUnionMember2.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedClassUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedClassUnionMember2");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "lazilyResolvedClassUnionMember2")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "lazilyResolvedClassUnionMember2")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "lazilyResolvedClassUnionMember2")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedClassUnionMember2")
          }LazilyResolvedStringProperty`,
        ),
        predicate:
          LazilyResolvedClassUnionMember2.$schema.properties
            .lazilyResolvedStringProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedClassUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedClassUnionMember2");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "lazilyResolvedClassUnionMember2")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedClassUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "lazilyResolvedClassUnionMember2")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            LazilyResolvedClassUnionMember2.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedClassUnionMember2"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.lazilyResolvedStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazilyResolvedClassUnionMember2")
                  }LazilyResolvedStringProperty`,
                ),
                predicate:
                  LazilyResolvedClassUnionMember2.$schema.properties
                    .lazilyResolvedStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazilyResolvedClassUnionMember2.$schema.properties.lazilyResolvedStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedClassUnionMember2")
          }LazilyResolvedStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazilyResolvedClassUnionMember2")
        }LazilyResolvedStringProperty`,
      }),
    );
    return patterns;
  }
}
export class LazilyResolvedClassUnionMember1 {
  private _$identifier?: LazilyResolvedClassUnionMember1.$Identifier;

  readonly $type: "LazilyResolvedClassUnionMember1" =
    "LazilyResolvedClassUnionMember1" as const;

  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): LazilyResolvedClassUnionMember1.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: LazilyResolvedClassUnionMember1): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): LazilyResolvedClassUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedClassUnionMember1.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode(
          "http://example.com/LazilyResolvedClassUnionMember1",
        ),
        options?.graph,
      );
    }
    resource.add(
      LazilyResolvedClassUnionMember1.$schema.properties
        .lazilyResolvedStringProperty.identifier,
      [$literalFactory.string(this.lazilyResolvedStringProperty)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LazilyResolvedClassUnionMember1 {
  export function $filter(
    filter: LazilyResolvedClassUnionMember1.$Filter,
    value: LazilyResolvedClassUnionMember1,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedClassUnionMember1",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<
    z.ZodError,
    { $identifier: BlankNode | NamedNode; lazilyResolvedStringProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, LazilyResolvedClassUnionMember1> {
    return $propertiesFromJson(json).map(
      (properties) => new LazilyResolvedClassUnionMember1(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedClassUnionMember1" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedClassUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("LazilyResolvedClassUnionMember1"),
      lazilyResolvedStringProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedClassUnionMember1";
    readonly lazilyResolvedStringProperty: string;
  };

  export function isLazilyResolvedClassUnionMember1(
    object: $Object,
  ): object is LazilyResolvedClassUnionMember1 {
    switch (object.$type) {
      case "LazilyResolvedClassUnionMember1":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, LazilyResolvedClassUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return LazilyResolvedClassUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new LazilyResolvedClassUnionMember1(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    { $identifier: BlankNode | NamedNode; lazilyResolvedStringProperty: string }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/LazilyResolvedClassUnionMember1":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  LazilyResolvedClassUnionMember1.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedClassUnionMember1)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, LazilyResolvedClassUnionMember1.$Identifier>(
        $parameters.resource
          .identifier as LazilyResolvedClassUnionMember1.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.lazilyResolvedStringProperty.identifier,
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                LazilyResolvedClassUnionMember1.$schema.properties
                  .lazilyResolvedStringProperty.identifier,
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((lazilyResolvedStringProperty) => ({
            $identifier,
            lazilyResolvedStringProperty,
          })),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["LazilyResolvedClassUnionMember1"],
        }),
      },
      lazilyResolvedStringProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/lazilyResolvedStringProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedClassUnionMember1.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          LazilyResolvedClassUnionMember1.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedClassUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedClassUnionMember1");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "lazilyResolvedClassUnionMember1")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "lazilyResolvedClassUnionMember1")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "lazilyResolvedClassUnionMember1")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedClassUnionMember1")
          }LazilyResolvedStringProperty`,
        ),
        predicate:
          LazilyResolvedClassUnionMember1.$schema.properties
            .lazilyResolvedStringProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedClassUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedClassUnionMember1");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "lazilyResolvedClassUnionMember1")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedClassUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "lazilyResolvedClassUnionMember1")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            LazilyResolvedClassUnionMember1.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedClassUnionMember1"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.lazilyResolvedStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazilyResolvedClassUnionMember1")
                  }LazilyResolvedStringProperty`,
                ),
                predicate:
                  LazilyResolvedClassUnionMember1.$schema.properties
                    .lazilyResolvedStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazilyResolvedClassUnionMember1.$schema.properties.lazilyResolvedStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedClassUnionMember1")
          }LazilyResolvedStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazilyResolvedClassUnionMember1")
        }LazilyResolvedStringProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Node shape resolved by LazyPropertiesInterface
 */

export interface LazilyResolvedBlankNodeOrIriIdentifierInterface {
  readonly $identifier: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier;
  readonly $type: "LazilyResolvedBlankNodeOrIriIdentifierInterface";
  readonly lazilyResolvedStringProperty: string;
}

export namespace LazilyResolvedBlankNodeOrIriIdentifierInterface {
  export function $create(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): LazilyResolvedBlankNodeOrIriIdentifierInterface {
    let $identifier: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }
    const $type = "LazilyResolvedBlankNodeOrIriIdentifierInterface" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: LazilyResolvedBlankNodeOrIriIdentifierInterface,
    right: LazilyResolvedBlankNodeOrIriIdentifierInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  export function $hash<HasherT extends $Hasher>(
    _lazilyResolvedBlankNodeOrIriIdentifierInterface: LazilyResolvedBlankNodeOrIriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    LazilyResolvedBlankNodeOrIriIdentifierInterface.$hashShaclProperties(
      _lazilyResolvedBlankNodeOrIriIdentifierInterface,
      _hasher,
    );
    _hasher.update(
      _lazilyResolvedBlankNodeOrIriIdentifierInterface.$identifier.value,
    );
    _hasher.update(_lazilyResolvedBlankNodeOrIriIdentifierInterface.$type);
    return _hasher;
  }

  export function $hashShaclProperties<HasherT extends $Hasher>(
    _lazilyResolvedBlankNodeOrIriIdentifierInterface: LazilyResolvedBlankNodeOrIriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _lazilyResolvedBlankNodeOrIriIdentifierInterface.lazilyResolvedStringProperty,
    );
    return _hasher;
  }

  export function $filter(
    filter: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
    value: LazilyResolvedBlankNodeOrIriIdentifierInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedBlankNodeOrIriIdentifierInterface",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      $type: "LazilyResolvedBlankNodeOrIriIdentifierInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "LazilyResolvedBlankNodeOrIriIdentifierInterface" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return Either.of({ $identifier, $type, lazilyResolvedStringProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, LazilyResolvedBlankNodeOrIriIdentifierInterface> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: {
                const:
                  "LazilyResolvedBlankNodeOrIriIdentifierInterface" as const,
              },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedBlankNodeOrIriIdentifierInterface",
      type: "Group",
    };
  }

  export function $toJson(
    _lazilyResolvedBlankNodeOrIriIdentifierInterface: LazilyResolvedBlankNodeOrIriIdentifierInterface,
  ): LazilyResolvedBlankNodeOrIriIdentifierInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _lazilyResolvedBlankNodeOrIriIdentifierInterface.$identifier
            .termType === "BlankNode"
            ? `_:${_lazilyResolvedBlankNodeOrIriIdentifierInterface.$identifier.value}`
            : _lazilyResolvedBlankNodeOrIriIdentifierInterface.$identifier
                .value,
        $type: _lazilyResolvedBlankNodeOrIriIdentifierInterface.$type,
        lazilyResolvedStringProperty:
          _lazilyResolvedBlankNodeOrIriIdentifierInterface.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedBlankNodeOrIriIdentifierInterface.$Json),
    );
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("LazilyResolvedBlankNodeOrIriIdentifierInterface"),
      lazilyResolvedStringProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedBlankNodeOrIriIdentifierInterface";
    readonly lazilyResolvedStringProperty: string;
  };

  export function isLazilyResolvedBlankNodeOrIriIdentifierInterface(
    object: $Object,
  ): object is LazilyResolvedBlankNodeOrIriIdentifierInterface {
    switch (object.$type) {
      case "LazilyResolvedBlankNodeOrIriIdentifierInterface":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, LazilyResolvedBlankNodeOrIriIdentifierInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return LazilyResolvedBlankNodeOrIriIdentifierInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      $type: "LazilyResolvedBlankNodeOrIriIdentifierInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/LazilyResolvedBlankNodeOrIriIdentifierInterface":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedBlankNodeOrIriIdentifierInterface)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<
        Error,
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
      >(
        $parameters.resource
          .identifier as LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, "LazilyResolvedBlankNodeOrIriIdentifierInterface">(
          "LazilyResolvedBlankNodeOrIriIdentifierInterface" as const,
        ).chain(($type) =>
          Either.of<Error, Resource.Values<Resource.TermValue>>(
            $parameters.resource.values(
              $schema.properties.lazilyResolvedStringProperty.identifier,
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  LazilyResolvedBlankNodeOrIriIdentifierInterface.$schema
                    .properties.lazilyResolvedStringProperty.identifier,
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((lazilyResolvedStringProperty) => ({
              $identifier,
              $type,
              lazilyResolvedStringProperty,
            })),
        ),
      ),
    );
  }

  export function $toRdf(
    _lazilyResolvedBlankNodeOrIriIdentifierInterface: LazilyResolvedBlankNodeOrIriIdentifierInterface,
    options?: {
      ignoreRdfType?: boolean;
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(
      _lazilyResolvedBlankNodeOrIriIdentifierInterface.$identifier,
    );
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode(
          "http://example.com/LazilyResolvedBlankNodeOrIriIdentifierInterface",
        ),
        options?.graph,
      );
    }
    resource.add(
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$schema.properties
        .lazilyResolvedStringProperty.identifier,
      [
        $literalFactory.string(
          _lazilyResolvedBlankNodeOrIriIdentifierInterface.lazilyResolvedStringProperty,
        ),
      ],
      options?.graph,
    );
    return resource;
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["LazilyResolvedBlankNodeOrIriIdentifierInterface"],
        }),
      },
      lazilyResolvedStringProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/lazilyResolvedStringProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$sparqlConstructTriples(
          { ignoreRdfType, subject },
        ),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$sparqlConstructQuery(
        parameters,
      ),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedBlankNodeOrIriIdentifierInterface");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "lazilyResolvedBlankNodeOrIriIdentifierInterface")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "lazilyResolvedBlankNodeOrIriIdentifierInterface")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "lazilyResolvedBlankNodeOrIriIdentifierInterface")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedBlankNodeOrIriIdentifierInterface")
          }LazilyResolvedStringProperty`,
        ),
        predicate:
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$schema.properties
            .lazilyResolvedStringProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedBlankNodeOrIriIdentifierInterface");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "lazilyResolvedBlankNodeOrIriIdentifierInterface")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "lazilyResolvedBlankNodeOrIriIdentifierInterface")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            LazilyResolvedBlankNodeOrIriIdentifierInterface.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedBlankNodeOrIriIdentifierInterface"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.lazilyResolvedStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazilyResolvedBlankNodeOrIriIdentifierInterface")
                  }LazilyResolvedStringProperty`,
                ),
                predicate:
                  LazilyResolvedBlankNodeOrIriIdentifierInterface.$schema
                    .properties.lazilyResolvedStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$schema.properties.lazilyResolvedStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedBlankNodeOrIriIdentifierInterface")
          }LazilyResolvedStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazilyResolvedBlankNodeOrIriIdentifierInterface")
        }LazilyResolvedStringProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Node shape resolved by LazyPropertiesClass
 */

export class LazilyResolvedBlankNodeOrIriIdentifierClass {
  private _$identifier?: LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier;

  readonly $type: "LazilyResolvedBlankNodeOrIriIdentifierClass" =
    "LazilyResolvedBlankNodeOrIriIdentifierClass" as const;

  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: LazilyResolvedBlankNodeOrIriIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): LazilyResolvedBlankNodeOrIriIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedBlankNodeOrIriIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode(
          "http://example.com/LazilyResolvedBlankNodeOrIriIdentifierClass",
        ),
        options?.graph,
      );
    }
    resource.add(
      LazilyResolvedBlankNodeOrIriIdentifierClass.$schema.properties
        .lazilyResolvedStringProperty.identifier,
      [$literalFactory.string(this.lazilyResolvedStringProperty)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LazilyResolvedBlankNodeOrIriIdentifierClass {
  export function $filter(
    filter: LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
    value: LazilyResolvedBlankNodeOrIriIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedBlankNodeOrIriIdentifierClass",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<
    z.ZodError,
    { $identifier: BlankNode | NamedNode; lazilyResolvedStringProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, LazilyResolvedBlankNodeOrIriIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) =>
        new LazilyResolvedBlankNodeOrIriIdentifierClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: {
                const: "LazilyResolvedBlankNodeOrIriIdentifierClass" as const,
              },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedBlankNodeOrIriIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("LazilyResolvedBlankNodeOrIriIdentifierClass"),
      lazilyResolvedStringProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedBlankNodeOrIriIdentifierClass";
    readonly lazilyResolvedStringProperty: string;
  };

  export function isLazilyResolvedBlankNodeOrIriIdentifierClass(
    object: $Object,
  ): object is LazilyResolvedBlankNodeOrIriIdentifierClass {
    switch (object.$type) {
      case "LazilyResolvedBlankNodeOrIriIdentifierClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, LazilyResolvedBlankNodeOrIriIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return LazilyResolvedBlankNodeOrIriIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map(
      (properties) =>
        new LazilyResolvedBlankNodeOrIriIdentifierClass(properties),
    );
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    { $identifier: BlankNode | NamedNode; lazilyResolvedStringProperty: string }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/LazilyResolvedBlankNodeOrIriIdentifierClass":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedBlankNodeOrIriIdentifierClass)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier>(
        $parameters.resource
          .identifier as LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.lazilyResolvedStringProperty.identifier,
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                LazilyResolvedBlankNodeOrIriIdentifierClass.$schema.properties
                  .lazilyResolvedStringProperty.identifier,
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((lazilyResolvedStringProperty) => ({
            $identifier,
            lazilyResolvedStringProperty,
          })),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["LazilyResolvedBlankNodeOrIriIdentifierClass"],
        }),
      },
      lazilyResolvedStringProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/lazilyResolvedStringProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedBlankNodeOrIriIdentifierClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          LazilyResolvedBlankNodeOrIriIdentifierClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedBlankNodeOrIriIdentifierClass.$sparqlConstructQuery(
        parameters,
      ),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedBlankNodeOrIriIdentifierClass");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "lazilyResolvedBlankNodeOrIriIdentifierClass")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "lazilyResolvedBlankNodeOrIriIdentifierClass")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "lazilyResolvedBlankNodeOrIriIdentifierClass")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedBlankNodeOrIriIdentifierClass")
          }LazilyResolvedStringProperty`,
        ),
        predicate:
          LazilyResolvedBlankNodeOrIriIdentifierClass.$schema.properties
            .lazilyResolvedStringProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedBlankNodeOrIriIdentifierClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "lazilyResolvedBlankNodeOrIriIdentifierClass")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "lazilyResolvedBlankNodeOrIriIdentifierClass")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            LazilyResolvedBlankNodeOrIriIdentifierClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedBlankNodeOrIriIdentifierClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.lazilyResolvedStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "lazilyResolvedBlankNodeOrIriIdentifierClass")
                  }LazilyResolvedStringProperty`,
                ),
                predicate:
                  LazilyResolvedBlankNodeOrIriIdentifierClass.$schema.properties
                    .lazilyResolvedStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LazilyResolvedBlankNodeOrIriIdentifierClass.$schema.properties.lazilyResolvedStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedBlankNodeOrIriIdentifierClass")
          }LazilyResolvedStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "lazilyResolvedBlankNodeOrIriIdentifierClass")
        }LazilyResolvedStringProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Shape that uses the StringList in a property.
 */

export class LanguageInPropertiesClass {
  private _$identifier?: LanguageInPropertiesClass.$Identifier;

  readonly $type: "LanguageInPropertiesClass" =
    "LanguageInPropertiesClass" as const;

  /**
   * literal property for testing languageIn
   */
  readonly languageInLiteralProperty: NonEmptyList<Literal>;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly languageInLiteralProperty: NonEmptyList<Literal>;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this.languageInLiteralProperty = parameters.languageInLiteralProperty;
  }

  get $identifier(): LanguageInPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: LanguageInPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.languageInLiteralProperty,
          other.languageInLiteralProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "languageInLiteralProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    for (const item0 of this.languageInLiteralProperty) {
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
      _hasher.update(item0.datatype.value);
      _hasher.update(item0.language);
    }
    return _hasher;
  }

  $toJson(): LanguageInPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        languageInLiteralProperty: this.languageInLiteralProperty.map(
          (item) => ({
            "@language": item.language.length > 0 ? item.language : undefined,
            "@type":
              item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? item.datatype.value
                : undefined,
            "@value": item.value,
          }),
        ),
      } satisfies LanguageInPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    resource.add(
      LanguageInPropertiesClass.$schema.properties.languageInLiteralProperty
        .identifier,
      this.languageInLiteralProperty.flatMap((item) => [item]),
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LanguageInPropertiesClass {
  export function $filter(
    filter: LanguageInPropertiesClass.$Filter,
    value: LanguageInPropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.languageInLiteralProperty !== "undefined" &&
      !$filterArray<Literal, $LiteralFilter>($filterLiteral)(
        filter.languageInLiteralProperty,
        value.languageInLiteralProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly languageInLiteralProperty?: $CollectionFilter<$LiteralFilter>;
  };

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      languageInLiteralProperty: NonEmptyList<Literal>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const languageInLiteralProperty = NonEmptyList.fromArray(
      $jsonObject["languageInLiteralProperty"],
    )
      .unsafeCoerce()
      .map((item) =>
        dataFactory.literal(
          item["@value"],
          typeof item["@language"] !== "undefined"
            ? item["@language"]
            : typeof item["@type"] !== "undefined"
              ? dataFactory.namedNode(item["@type"])
              : undefined,
        ),
      );
    return Either.of({ $identifier, languageInLiteralProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, LanguageInPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new LanguageInPropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LanguageInPropertiesClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/languageInLiteralProperty`,
          type: "Control",
        },
      ],
      label: "LanguageInPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("LanguageInPropertiesClass"),
      languageInLiteralProperty: z
        .object({
          "@language": z.string().optional(),
          "@type": z.string().optional(),
          "@value": z.string(),
        })
        .array()
        .nonempty()
        .min(1)
        .describe("literal property for testing languageIn"),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LanguageInPropertiesClass";
    readonly languageInLiteralProperty: readonly {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    }[];
  };

  export function isLanguageInPropertiesClass(
    object: $Object,
  ): object is LanguageInPropertiesClass {
    switch (object.$type) {
      case "LanguageInPropertiesClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, LanguageInPropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return LanguageInPropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new LanguageInPropertiesClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      languageInLiteralProperty: NonEmptyList<Literal>;
    }
  > {
    return Either.of<Error, LanguageInPropertiesClass.$Identifier>(
      $parameters.resource.identifier as LanguageInPropertiesClass.$Identifier,
    ).chain(($identifier) =>
      Either.of<Error, Resource.Values<Resource.TermValue>>(
        $parameters.resource.values(
          $schema.properties.languageInLiteralProperty.identifier,
          { unique: true },
        ),
      )
        .chain((values) =>
          values.chainMap((value) =>
            value.toLiteral().chain((literalValue) => {
              switch (literalValue.language) {
                case "en":
                case "fr":
                  return Either.of(value);
                default:
                  return Left(
                    new Resource.MistypedTermValueError({
                      actualValue: literalValue,
                      expectedValueType: "Literal",
                      focusResource: $parameters.resource,
                      predicate:
                        LanguageInPropertiesClass.$schema.properties
                          .languageInLiteralProperty.identifier,
                    }),
                  );
              }
            }),
          ),
        )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              LanguageInPropertiesClass.$schema.properties
                .languageInLiteralProperty.identifier,
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toLiteral()))
        .chain((values) =>
          NonEmptyList.fromArray(values.toArray()).toEither(
            new Error(
              `${Resource.Identifier.toString($parameters.resource.identifier)} is an empty set`,
            ),
          ),
        )
        .map((valuesArray) =>
          Resource.Values.fromValue({
            focusResource: $parameters.resource,
            predicate:
              LanguageInPropertiesClass.$schema.properties
                .languageInLiteralProperty.identifier,
            value: valuesArray,
          }),
        )
        .chain((values) => values.head())
        .map((languageInLiteralProperty) => ({
          $identifier,
          languageInLiteralProperty,
        })),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["LanguageInPropertiesClass"],
        }),
      },
      languageInLiteralProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Set" as const,
          item: () => ({ kind: "Literal" as const, languageIn: ["en", "fr"] }),
          minCount: 1,
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/languageInLiteralProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LanguageInPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LanguageInPropertiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          LanguageInPropertiesClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LanguageInPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LanguageInPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("languageInPropertiesClass");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "languageInPropertiesClass")
          }LanguageInLiteralProperty`,
        ),
        predicate:
          LanguageInPropertiesClass.$schema.properties.languageInLiteralProperty
            .identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LanguageInPropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("languageInPropertiesClass");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            LanguageInPropertiesClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "languageInPropertiesClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $setSparqlWherePatterns<$LiteralFilter, $LiteralSchema>(
        $literalSparqlWherePatterns,
      )({
        filter: parameters?.filter?.languageInLiteralProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "languageInPropertiesClass")
                  }LanguageInLiteralProperty`,
                ),
                predicate:
                  LanguageInPropertiesClass.$schema.properties
                    .languageInLiteralProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          LanguageInPropertiesClass.$schema.properties.languageInLiteralProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "languageInPropertiesClass")
          }LanguageInLiteralProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "languageInPropertiesClass")
        }LanguageInLiteralProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Shape with sh:xone (union) properties with JavaScript primitive types (e.g., boolean, number, et al.). Unions of these are common in actual models.
 */

export class JsPrimitiveUnionPropertyClass {
  private _$identifier?: JsPrimitiveUnionPropertyClass.$Identifier;

  readonly $type: "JsPrimitiveUnionPropertyClass" =
    "JsPrimitiveUnionPropertyClass" as const;

  readonly jsPrimitiveUnionProperty: readonly (boolean | number | string)[];

  constructor(parameters?: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly jsPrimitiveUnionProperty?: readonly (boolean | number | string)[];
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }
    if (typeof parameters?.jsPrimitiveUnionProperty === "undefined") {
      this.jsPrimitiveUnionProperty = [];
    } else if (typeof parameters?.jsPrimitiveUnionProperty === "object") {
      this.jsPrimitiveUnionProperty = parameters?.jsPrimitiveUnionProperty;
    } else {
      this.jsPrimitiveUnionProperty =
        parameters?.jsPrimitiveUnionProperty satisfies never;
    }
  }

  get $identifier(): JsPrimitiveUnionPropertyClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: JsPrimitiveUnionPropertyClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(
            left,
            right,
            (
              left: boolean | number | string,
              right: boolean | number | string,
            ) => {
              if (typeof left === "boolean" && typeof right === "boolean") {
                return $strictEquals(left, right);
              }
              if (typeof left === "number" && typeof right === "number") {
                return $strictEquals(left, right);
              }
              if (typeof left === "string" && typeof right === "string") {
                return $strictEquals(left, right);
              }

              return Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "boolean" as const,
                },
                type: "property" as const,
              });
            },
          ))(
          this.jsPrimitiveUnionProperty,
          other.jsPrimitiveUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "jsPrimitiveUnionProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    for (const item0 of this.jsPrimitiveUnionProperty) {
      switch (typeof item0) {
        case "boolean": {
          _hasher.update(item0.toString());
          break;
        }
        case "number": {
          _hasher.update(item0.toString());
          break;
        }
        case "string": {
          _hasher.update(item0);
          break;
        }
        default:
          item0 satisfies never;
          throw new Error("unrecognized type");
      }
    }
    return _hasher;
  }

  $toJson(): JsPrimitiveUnionPropertyClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        jsPrimitiveUnionProperty: this.jsPrimitiveUnionProperty.map(
          (item) => item,
        ),
      } satisfies JsPrimitiveUnionPropertyClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode(
          "http://example.com/JsPrimitiveUnionPropertyClass",
        ),
        options?.graph,
      );
    }
    resource.add(
      JsPrimitiveUnionPropertyClass.$schema.properties.jsPrimitiveUnionProperty
        .identifier,
      this.jsPrimitiveUnionProperty.flatMap((item) =>
        typeof item === "string"
          ? ([$literalFactory.string(item)] as (
              | bigint
              | boolean
              | number
              | string
              | BlankNode
              | Literal
              | NamedNode
            )[])
          : typeof item === "number"
            ? ([$literalFactory.number(item, $RdfVocabularies.xsd.decimal)] as (
                | bigint
                | boolean
                | number
                | string
                | BlankNode
                | Literal
                | NamedNode
              )[])
            : ([$literalFactory.boolean(item)] as (
                | bigint
                | boolean
                | number
                | string
                | BlankNode
                | Literal
                | NamedNode
              )[]),
      ),
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace JsPrimitiveUnionPropertyClass {
  export function $filter(
    filter: JsPrimitiveUnionPropertyClass.$Filter,
    value: JsPrimitiveUnionPropertyClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.jsPrimitiveUnionProperty !== "undefined" &&
      !$filterArray<
        boolean | number | string,
        {
          readonly on?: {
            readonly boolean?: $BooleanFilter;
            readonly number?: $NumberFilter;
            readonly string?: $StringFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly boolean?: $BooleanFilter;
              readonly number?: $NumberFilter;
              readonly string?: $StringFilter;
            };
          },
          value: boolean | number | string,
        ) => {
          if (typeof filter.on?.["boolean"] !== "undefined") {
            switch (typeof value) {
              case "boolean":
                if (!$filterBoolean(filter.on["boolean"], value)) {
                  return false;
                }
                break;
            }
          }
          if (typeof filter.on?.["number"] !== "undefined") {
            switch (typeof value) {
              case "number":
                if (!$filterNumber(filter.on["number"], value)) {
                  return false;
                }
                break;
            }
          }
          if (typeof filter.on?.["string"] !== "undefined") {
            switch (typeof value) {
              case "string":
                if (!$filterString(filter.on["string"], value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.jsPrimitiveUnionProperty, value.jsPrimitiveUnionProperty)
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly jsPrimitiveUnionProperty?: $CollectionFilter<{
      readonly on?: {
        readonly boolean?: $BooleanFilter;
        readonly number?: $NumberFilter;
        readonly string?: $StringFilter;
      };
    }>;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/JsPrimitiveUnionPropertyClass",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      jsPrimitiveUnionProperty: readonly (boolean | number | string)[];
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const jsPrimitiveUnionProperty = $jsonObject["jsPrimitiveUnionProperty"];
    return Either.of({ $identifier, jsPrimitiveUnionProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, JsPrimitiveUnionPropertyClass> {
    return $propertiesFromJson(json).map(
      (properties) => new JsPrimitiveUnionPropertyClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "JsPrimitiveUnionPropertyClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/jsPrimitiveUnionProperty`,
          type: "Control",
        },
      ],
      label: "JsPrimitiveUnionPropertyClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("JsPrimitiveUnionPropertyClass"),
      jsPrimitiveUnionProperty: z
        .union([z.boolean(), z.number(), z.string()])
        .array()
        .default(() => []),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "JsPrimitiveUnionPropertyClass";
    readonly jsPrimitiveUnionProperty?: readonly (boolean | number | string)[];
  };

  export function isJsPrimitiveUnionPropertyClass(
    object: $Object,
  ): object is JsPrimitiveUnionPropertyClass {
    switch (object.$type) {
      case "JsPrimitiveUnionPropertyClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, JsPrimitiveUnionPropertyClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return JsPrimitiveUnionPropertyClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new JsPrimitiveUnionPropertyClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      jsPrimitiveUnionProperty: readonly (boolean | number | string)[];
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/JsPrimitiveUnionPropertyClass":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  JsPrimitiveUnionPropertyClass.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/JsPrimitiveUnionPropertyClass)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, JsPrimitiveUnionPropertyClass.$Identifier>(
        $parameters.resource
          .identifier as JsPrimitiveUnionPropertyClass.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.jsPrimitiveUnionProperty.identifier,
            { unique: true },
          ),
        )
          .chain((values) =>
            values.chainMap((value) => {
              const valueAsValues = Either.of(value.toValues());
              return (
                valueAsValues.chain((values) =>
                  values.chainMap((value) => value.toBoolean()),
                ) as Either<Error, Resource.Values<boolean | number | string>>
              )
                .altLazy(
                  () =>
                    valueAsValues.chain((values) =>
                      values.chainMap((value) => value.toNumber()),
                    ) as Either<
                      Error,
                      Resource.Values<boolean | number | string>
                    >,
                )
                .altLazy(
                  () =>
                    valueAsValues
                      .chain((values) =>
                        $fromRdfPreferredLanguages({
                          focusResource: $parameters.resource,
                          predicate:
                            JsPrimitiveUnionPropertyClass.$schema.properties
                              .jsPrimitiveUnionProperty.identifier,
                          preferredLanguages: $parameters.preferredLanguages,
                          values,
                        }),
                      )
                      .chain((values) =>
                        values.chainMap((value) => value.toString()),
                      ) as Either<
                      Error,
                      Resource.Values<boolean | number | string>
                    >,
                )
                .chain((values) => values.head());
            }),
          )
          .map((values) => values.toArray())
          .map((valuesArray) =>
            Resource.Values.fromValue({
              focusResource: $parameters.resource,
              predicate:
                JsPrimitiveUnionPropertyClass.$schema.properties
                  .jsPrimitiveUnionProperty.identifier,
              value: valuesArray,
            }),
          )
          .chain((values) => values.head())
          .map((jsPrimitiveUnionProperty) => ({
            $identifier,
            jsPrimitiveUnionProperty,
          })),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["JsPrimitiveUnionPropertyClass"],
        }),
      },
      jsPrimitiveUnionProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Set" as const,
          item: () => ({
            kind: "Union" as const,
            members: {
              boolean: {
                discriminantValues: ["boolean"],
                type: { kind: "Boolean" as const },
              },
              number: {
                discriminantValues: ["number"],
                type: { kind: "Float" as const },
              },
              string: {
                discriminantValues: ["string"],
                type: { kind: "String" as const },
              },
            },
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/jsPrimitiveUnionProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: JsPrimitiveUnionPropertyClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        JsPrimitiveUnionPropertyClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          JsPrimitiveUnionPropertyClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: JsPrimitiveUnionPropertyClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      JsPrimitiveUnionPropertyClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("jsPrimitiveUnionPropertyClass");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "jsPrimitiveUnionPropertyClass")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "jsPrimitiveUnionPropertyClass")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "jsPrimitiveUnionPropertyClass")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "jsPrimitiveUnionPropertyClass")
          }JsPrimitiveUnionProperty`,
        ),
        predicate:
          JsPrimitiveUnionPropertyClass.$schema.properties
            .jsPrimitiveUnionProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: JsPrimitiveUnionPropertyClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("jsPrimitiveUnionPropertyClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "jsPrimitiveUnionPropertyClass")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: JsPrimitiveUnionPropertyClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "jsPrimitiveUnionPropertyClass")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            JsPrimitiveUnionPropertyClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "jsPrimitiveUnionPropertyClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $setSparqlWherePatterns<
        {
          readonly on?: {
            readonly boolean?: $BooleanFilter;
            readonly number?: $NumberFilter;
            readonly string?: $StringFilter;
          };
        },
        {
          kind: "Union";
          members: {
            readonly boolean: {
              discriminantValues: readonly string[];
              type: $BooleanSchema;
            };
            readonly number: {
              discriminantValues: readonly string[];
              type: $NumberSchema;
            };
            readonly string: {
              discriminantValues: readonly string[];
              type: $StringSchema;
            };
          };
        }
      >(({ filter, schema, ...otherParameters }) => {
        const unionPatterns: sparqljs.GroupPattern[] = [];

        unionPatterns.push({
          patterns: $booleanSparqlWherePatterns({
            filter: filter?.on?.["boolean"],
            schema: schema.members["boolean"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });
        unionPatterns.push({
          patterns: $numberSparqlWherePatterns({
            filter: filter?.on?.["number"],
            schema: schema.members["number"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });
        unionPatterns.push({
          patterns: $stringSparqlWherePatterns({
            filter: filter?.on?.["string"],
            schema: schema.members["string"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });

        return [{ patterns: unionPatterns, type: "union" }];
      })({
        filter: parameters?.filter?.jsPrimitiveUnionProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "jsPrimitiveUnionPropertyClass")
                  }JsPrimitiveUnionProperty`,
                ),
                predicate:
                  JsPrimitiveUnionPropertyClass.$schema.properties
                    .jsPrimitiveUnionProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          JsPrimitiveUnionPropertyClass.$schema.properties.jsPrimitiveUnionProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "jsPrimitiveUnionPropertyClass")
          }JsPrimitiveUnionProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "jsPrimitiveUnionPropertyClass")
        }JsPrimitiveUnionProperty`,
      }),
    );
    return patterns;
  }
} /**
 * A node shape that only allows IRI identifiers.
 */

export interface IriIdentifierInterface {
  readonly $identifier: IriIdentifierInterface.$Identifier;
  readonly $type: "IriIdentifierInterface";
}

export namespace IriIdentifierInterface {
  export function $create(parameters: {
    readonly $identifier: NamedNode | string;
  }): IriIdentifierInterface {
    let $identifier: IriIdentifierInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      $identifier = parameters.$identifier satisfies never;
    }
    const $type = "IriIdentifierInterface" as const;
    return { $identifier, $type };
  }

  export function $equals(
    left: IriIdentifierInterface,
    right: IriIdentifierInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      );
  }

  export function $hash<HasherT extends $Hasher>(
    _iriIdentifierInterface: IriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    IriIdentifierInterface.$hashShaclProperties(
      _iriIdentifierInterface,
      _hasher,
    );
    _hasher.update(_iriIdentifierInterface.$identifier.value);
    _hasher.update(_iriIdentifierInterface.$type);
    return _hasher;
  }

  export function $hashShaclProperties<HasherT extends $Hasher>(
    _iriIdentifierInterface: IriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    return _hasher;
  }

  export function $filter(
    filter: IriIdentifierInterface.$Filter,
    value: IriIdentifierInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = { readonly $identifier?: $NamedNodeFilter };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/IriIdentifierInterface",
  );

  export type $Identifier = NamedNode;

  export namespace $Identifier {
    export function fromString(identifier: string): Either<Error, NamedNode> {
      return Either.encase(() =>
        Resource.Identifier.fromString({ dataFactory, identifier }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? Either.of(identifier)
          : Left(new Error("expected identifier to be NamedNode")),
      ) as Either<Error, NamedNode>;
    } // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<
    z.ZodError,
    { $identifier: NamedNode; $type: "IriIdentifierInterface" }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const $type = "IriIdentifierInterface" as const;
    return Either.of({ $identifier, $type });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, IriIdentifierInterface> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "IriIdentifierInterface" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "IriIdentifierInterface",
      type: "Group",
    };
  }

  export function $toJson(
    _iriIdentifierInterface: IriIdentifierInterface,
  ): IriIdentifierInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": _iriIdentifierInterface.$identifier.value,
        $type: _iriIdentifierInterface.$type,
      } satisfies IriIdentifierInterface.$Json),
    );
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("IriIdentifierInterface"),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "IriIdentifierInterface";
  };

  export function isIriIdentifierInterface(
    object: $Object,
  ): object is IriIdentifierInterface {
    switch (object.$type) {
      case "IriIdentifierInterface":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, IriIdentifierInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return IriIdentifierInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    { $identifier: NamedNode; $type: "IriIdentifierInterface" }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/IriIdentifierInterface":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  IriIdentifierInterface.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/IriIdentifierInterface)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      ($parameters.resource.identifier.termType === "NamedNode"
        ? Either.of<Error, IriIdentifierInterface.$Identifier>(
            $parameters.resource.identifier,
          )
        : Left(
            new Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "NamedNode",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
      ).chain(($identifier) =>
        Either.of<Error, "IriIdentifierInterface">(
          "IriIdentifierInterface" as const,
        ).map(($type) => ({
          $identifier,
          $type,
        })),
      ),
    );
  }

  export function $toRdf(
    _iriIdentifierInterface: IriIdentifierInterface,
    options?: {
      ignoreRdfType?: boolean;
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource<NamedNode> {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(_iriIdentifierInterface.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/IriIdentifierInterface"),
        options?.graph,
      );
    }
    return resource;
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "NamedNode" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["IriIdentifierInterface"],
        }),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IriIdentifierInterface.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          IriIdentifierInterface.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IriIdentifierInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("iriIdentifierInterface");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "iriIdentifierInterface")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "iriIdentifierInterface")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "iriIdentifierInterface")
            }RdfClass`,
          ),
        },
      );
    }
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IriIdentifierInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("iriIdentifierInterface");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "iriIdentifierInterface")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: IriIdentifierInterface.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "iriIdentifierInterface")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $namedNodeSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: IriIdentifierInterface.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "iriIdentifierInterface"),
        }),
      );
    }
    return patterns;
  }
} /**
 * A node shape that only allows IRI identifiers.
 */

export class IriIdentifierClass {
  readonly $identifier: IriIdentifierClass.$Identifier;

  readonly $type: "IriIdentifierClass" = "IriIdentifierClass" as const;

  constructor(parameters: { readonly $identifier: NamedNode | string }) {
    if (typeof parameters.$identifier === "object") {
      this.$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this.$identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      this.$identifier = parameters.$identifier satisfies never;
    }
  }

  $equals(other: IriIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    return _hasher;
  }

  $toJson(): IriIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
      } satisfies IriIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource<NamedNode> {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/IriIdentifierClass"),
        options?.graph,
      );
    }
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IriIdentifierClass {
  export function $filter(
    filter: IriIdentifierClass.$Filter,
    value: IriIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = { readonly $identifier?: $NamedNodeFilter };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/IriIdentifierClass",
  );

  export type $Identifier = NamedNode;

  export namespace $Identifier {
    export function fromString(identifier: string): Either<Error, NamedNode> {
      return Either.encase(() =>
        Resource.Identifier.fromString({ dataFactory, identifier }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? Either.of(identifier)
          : Left(new Error("expected identifier to be NamedNode")),
      ) as Either<Error, NamedNode>;
    } // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<z.ZodError, { $identifier: NamedNode }> {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    return Either.of({ $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, IriIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new IriIdentifierClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "IriIdentifierClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "IriIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("IriIdentifierClass"),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "IriIdentifierClass";
  };

  export function isIriIdentifierClass(
    object: $Object,
  ): object is IriIdentifierClass {
    switch (object.$type) {
      case "IriIdentifierClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, IriIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return IriIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new IriIdentifierClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<Error, { $identifier: NamedNode }> {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/IriIdentifierClass":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  IriIdentifierClass.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/IriIdentifierClass)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      ($parameters.resource.identifier.termType === "NamedNode"
        ? Either.of<Error, IriIdentifierClass.$Identifier>(
            $parameters.resource.identifier,
          )
        : Left(
            new Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "NamedNode",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
      ).map(($identifier) => ({ $identifier })),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "NamedNode" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["IriIdentifierClass"],
        }),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IriIdentifierClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          IriIdentifierClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IriIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("iriIdentifierClass");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "iriIdentifierClass")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "iriIdentifierClass")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "iriIdentifierClass")
            }RdfClass`,
          ),
        },
      );
    }
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IriIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("iriIdentifierClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable" ? subject.value : "iriIdentifierClass")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: IriIdentifierClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "iriIdentifierClass")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $namedNodeSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: IriIdentifierClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "iriIdentifierClass"),
        }),
      );
    }
    return patterns;
  }
}
export interface InterfaceUnionMemberCommonParent {
  readonly $identifier: InterfaceUnionMemberCommonParentStatic.$Identifier;
  readonly $type: "InterfaceUnionMember1" | "InterfaceUnionMember2";
  readonly interfaceUnionMemberCommonParentProperty: string;
}

export namespace InterfaceUnionMemberCommonParentStatic {
  export function $create(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly interfaceUnionMemberCommonParentProperty: string;
  }): Omit<InterfaceUnionMemberCommonParent, "$type"> {
    let $identifier: InterfaceUnionMemberCommonParentStatic.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }
    const interfaceUnionMemberCommonParentProperty =
      parameters.interfaceUnionMemberCommonParentProperty;
    return { $identifier, interfaceUnionMemberCommonParentProperty };
  }

  export function $equals(
    left: InterfaceUnionMemberCommonParent,
    right: InterfaceUnionMemberCommonParent,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.interfaceUnionMemberCommonParentProperty,
          right.interfaceUnionMemberCommonParentProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "interfaceUnionMemberCommonParentProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  export function $hash<HasherT extends $Hasher>(
    _interfaceUnionMemberCommonParent: InterfaceUnionMemberCommonParent,
    _hasher: HasherT,
  ): HasherT {
    InterfaceUnionMemberCommonParentStatic.$hashShaclProperties(
      _interfaceUnionMemberCommonParent,
      _hasher,
    );
    _hasher.update(_interfaceUnionMemberCommonParent.$identifier.value);
    _hasher.update(_interfaceUnionMemberCommonParent.$type);
    return _hasher;
  }

  export function $hashShaclProperties<HasherT extends $Hasher>(
    _interfaceUnionMemberCommonParent: InterfaceUnionMemberCommonParent,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _interfaceUnionMemberCommonParent.interfaceUnionMemberCommonParentProperty,
    );
    return _hasher;
  }

  export function $filter(
    filter: InterfaceUnionMemberCommonParentStatic.$Filter,
    value: InterfaceUnionMemberCommonParent,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.interfaceUnionMemberCommonParentProperty !== "undefined" &&
      !$filterString(
        filter.interfaceUnionMemberCommonParentProperty,
        value.interfaceUnionMemberCommonParentProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly interfaceUnionMemberCommonParentProperty?: $StringFilter;
  };

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      interfaceUnionMemberCommonParentProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const interfaceUnionMemberCommonParentProperty =
      $jsonObject["interfaceUnionMemberCommonParentProperty"];
    return Either.of({ $identifier, interfaceUnionMemberCommonParentProperty });
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "InterfaceUnionMemberCommonParent" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/interfaceUnionMemberCommonParentProperty`,
          type: "Control",
        },
      ],
      label: "InterfaceUnionMemberCommonParent",
      type: "Group",
    };
  }

  export function $toJson(
    _interfaceUnionMemberCommonParent: InterfaceUnionMemberCommonParent,
  ): InterfaceUnionMemberCommonParentStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _interfaceUnionMemberCommonParent.$identifier.termType === "BlankNode"
            ? `_:${_interfaceUnionMemberCommonParent.$identifier.value}`
            : _interfaceUnionMemberCommonParent.$identifier.value,
        $type: _interfaceUnionMemberCommonParent.$type,
        interfaceUnionMemberCommonParentProperty:
          _interfaceUnionMemberCommonParent.interfaceUnionMemberCommonParentProperty,
      } satisfies InterfaceUnionMemberCommonParentStatic.$Json),
    );
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.enum(["InterfaceUnionMember1", "InterfaceUnionMember2"]),
      interfaceUnionMemberCommonParentProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "InterfaceUnionMember1" | "InterfaceUnionMember2";
    readonly interfaceUnionMemberCommonParentProperty: string;
  };

  export function isInterfaceUnionMemberCommonParent(
    object: $Object,
  ): object is InterfaceUnionMemberCommonParent {
    switch (object.$type) {
      case "InterfaceUnionMember1":
      case "InterfaceUnionMember2":
        return true;
      default:
        return false;
    }
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      interfaceUnionMemberCommonParentProperty: string;
    }
  > {
    return Either.of<Error, InterfaceUnionMemberCommonParentStatic.$Identifier>(
      $parameters.resource
        .identifier as InterfaceUnionMemberCommonParentStatic.$Identifier,
    ).chain(($identifier) =>
      Either.of<Error, Resource.Values<Resource.TermValue>>(
        $parameters.resource.values(
          $schema.properties.interfaceUnionMemberCommonParentProperty
            .identifier,
          {
            unique: true,
          },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              InterfaceUnionMemberCommonParentStatic.$schema.properties
                .interfaceUnionMemberCommonParentProperty.identifier,
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((interfaceUnionMemberCommonParentProperty) => ({
          $identifier,
          interfaceUnionMemberCommonParentProperty,
        })),
    );
  }

  export function $toRdf(
    _interfaceUnionMemberCommonParent: InterfaceUnionMemberCommonParent,
    options?: {
      ignoreRdfType?: boolean;
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(
      _interfaceUnionMemberCommonParent.$identifier,
    );
    resource.add(
      InterfaceUnionMemberCommonParentStatic.$schema.properties
        .interfaceUnionMemberCommonParentProperty.identifier,
      [
        $literalFactory.string(
          _interfaceUnionMemberCommonParent.interfaceUnionMemberCommonParentProperty,
        ),
      ],
      options?.graph,
    );
    return resource;
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          descendantValues: ["InterfaceUnionMember1", "InterfaceUnionMember2"],
          kind: "TypeDiscriminant" as const,
        }),
      },
      interfaceUnionMemberCommonParentProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/interfaceUnionMemberCommonParentProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: InterfaceUnionMemberCommonParentStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InterfaceUnionMemberCommonParentStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          InterfaceUnionMemberCommonParentStatic.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: InterfaceUnionMemberCommonParentStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InterfaceUnionMemberCommonParentStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("interfaceUnionMemberCommonParent");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "interfaceUnionMemberCommonParent")
          }InterfaceUnionMemberCommonParentProperty`,
        ),
        predicate:
          InterfaceUnionMemberCommonParentStatic.$schema.properties
            .interfaceUnionMemberCommonParentProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: InterfaceUnionMemberCommonParentStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("interfaceUnionMemberCommonParent");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            InterfaceUnionMemberCommonParentStatic.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "interfaceUnionMemberCommonParent"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.interfaceUnionMemberCommonParentProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "interfaceUnionMemberCommonParent")
                  }InterfaceUnionMemberCommonParentProperty`,
                ),
                predicate:
                  InterfaceUnionMemberCommonParentStatic.$schema.properties
                    .interfaceUnionMemberCommonParentProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          InterfaceUnionMemberCommonParentStatic.$schema.properties.interfaceUnionMemberCommonParentProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "interfaceUnionMemberCommonParent")
          }InterfaceUnionMemberCommonParentProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "interfaceUnionMemberCommonParent")
        }InterfaceUnionMemberCommonParentProperty`,
      }),
    );
    return patterns;
  }
}
export interface InterfaceUnionMember2
  extends InterfaceUnionMemberCommonParent {
  readonly $identifier: InterfaceUnionMember2.$Identifier;
  readonly $type: "InterfaceUnionMember2";
  readonly interfaceUnionMember2Property: string;
}

export namespace InterfaceUnionMember2 {
  export function $create(
    parameters: {
      readonly $identifier?: (BlankNode | NamedNode) | string;
      readonly interfaceUnionMember2Property: string;
    } & Parameters<typeof InterfaceUnionMemberCommonParentStatic.$create>[0],
  ): InterfaceUnionMember2 {
    let $identifier: InterfaceUnionMember2.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }
    const $type = "InterfaceUnionMember2" as const;
    const interfaceUnionMember2Property =
      parameters.interfaceUnionMember2Property;
    return {
      ...InterfaceUnionMemberCommonParentStatic.$create(parameters),
      $identifier,
      $type,
      interfaceUnionMember2Property,
    };
  }

  export function $equals(
    left: InterfaceUnionMember2,
    right: InterfaceUnionMember2,
  ): $EqualsResult {
    return InterfaceUnionMemberCommonParentStatic.$equals(left, right).chain(
      () =>
        $strictEquals(
          left.interfaceUnionMember2Property,
          right.interfaceUnionMember2Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "interfaceUnionMember2Property",
          propertyValuesUnequal,
          type: "property" as const,
        })),
    );
  }

  export function $hash<HasherT extends $Hasher>(
    _interfaceUnionMember2: InterfaceUnionMember2,
    _hasher: HasherT,
  ): HasherT {
    InterfaceUnionMember2.$hashShaclProperties(_interfaceUnionMember2, _hasher);
    return _hasher;
  }

  export function $hashShaclProperties<HasherT extends $Hasher>(
    _interfaceUnionMember2: InterfaceUnionMember2,
    _hasher: HasherT,
  ): HasherT {
    InterfaceUnionMemberCommonParentStatic.$hashShaclProperties(
      _interfaceUnionMember2,
      _hasher,
    );
    _hasher.update(_interfaceUnionMember2.interfaceUnionMember2Property);
    return _hasher;
  }

  export function $filter(
    filter: InterfaceUnionMember2.$Filter,
    value: InterfaceUnionMember2,
  ): boolean {
    if (!InterfaceUnionMemberCommonParentStatic.$filter(filter, value)) {
      return false;
    }
    if (
      typeof filter.interfaceUnionMember2Property !== "undefined" &&
      !$filterString(
        filter.interfaceUnionMember2Property,
        value.interfaceUnionMember2Property,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly interfaceUnionMember2Property?: $StringFilter;
  } & InterfaceUnionMemberCommonParentStatic.$Filter;

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/InterfaceUnionMember2",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      $type: "InterfaceUnionMember2";
      interfaceUnionMember2Property: string;
    } & $UnwrapR<
      ReturnType<
        typeof InterfaceUnionMemberCommonParentStatic.$propertiesFromJson
      >
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "InterfaceUnionMember2" as const;
    const interfaceUnionMember2Property =
      $jsonObject["interfaceUnionMember2Property"];
    return InterfaceUnionMemberCommonParentStatic.$propertiesFromJson(
      $jsonObject,
    ).map(($super0) => ({
      ...$super0,
      $identifier,
      $type,
      interfaceUnionMember2Property,
    }));
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, InterfaceUnionMember2> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InterfaceUnionMemberCommonParentStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/interfaceUnionMember2Property`,
          type: "Control",
        },
      ],
      label: "InterfaceUnionMember2",
      type: "Group",
    };
  }

  export function $toJson(
    _interfaceUnionMember2: InterfaceUnionMember2,
  ): InterfaceUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        ...InterfaceUnionMemberCommonParentStatic.$toJson(
          _interfaceUnionMember2,
        ),
        interfaceUnionMember2Property:
          _interfaceUnionMember2.interfaceUnionMember2Property,
      } satisfies InterfaceUnionMember2.$Json),
    );
  }

  export function $jsonZodSchema() {
    return InterfaceUnionMemberCommonParentStatic.$jsonZodSchema().merge(
      z.object({
        "@id": z.string().min(1),
        $type: z.literal("InterfaceUnionMember2"),
        interfaceUnionMember2Property: z.string(),
      }),
    ) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly interfaceUnionMember2Property: string;
  } & InterfaceUnionMemberCommonParentStatic.$Json;

  export function isInterfaceUnionMember2(
    object: $Object,
  ): object is InterfaceUnionMember2 {
    switch (object.$type) {
      case "InterfaceUnionMember2":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, InterfaceUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return InterfaceUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      $type: "InterfaceUnionMember2";
      interfaceUnionMember2Property: string;
    } & $UnwrapR<
      ReturnType<
        typeof InterfaceUnionMemberCommonParentStatic.$propertiesFromRdf
      >
    >
  > {
    return InterfaceUnionMemberCommonParentStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/InterfaceUnionMember2":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  InterfaceUnionMember2.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/InterfaceUnionMember2)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        Either.of<Error, InterfaceUnionMember2.$Identifier>(
          $parameters.resource.identifier as InterfaceUnionMember2.$Identifier,
        ).chain(($identifier) =>
          Either.of<Error, "InterfaceUnionMember2">(
            "InterfaceUnionMember2" as const,
          ).chain(($type) =>
            Either.of<Error, Resource.Values<Resource.TermValue>>(
              $parameters.resource.values(
                $schema.properties.interfaceUnionMember2Property.identifier,
                {
                  unique: true,
                },
              ),
            )
              .chain((values) =>
                $fromRdfPreferredLanguages({
                  focusResource: $parameters.resource,
                  predicate:
                    InterfaceUnionMember2.$schema.properties
                      .interfaceUnionMember2Property.identifier,
                  preferredLanguages: $parameters.preferredLanguages,
                  values,
                }),
              )
              .chain((values) => values.chainMap((value) => value.toString()))
              .chain((values) => values.head())
              .map((interfaceUnionMember2Property) => ({
                ...$super0,
                $identifier,
                $type,
                interfaceUnionMember2Property,
              })),
          ),
        ),
      ),
    );
  }

  export function $toRdf(
    _interfaceUnionMember2: InterfaceUnionMember2,
    options?: {
      ignoreRdfType?: boolean;
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = InterfaceUnionMemberCommonParentStatic.$toRdf(
      _interfaceUnionMember2,
      {
        ignoreRdfType: true,
        graph: options?.graph,
        resourceSet,
      },
    );
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/InterfaceUnionMember2"),
        options?.graph,
      );
    }
    resource.add(
      InterfaceUnionMember2.$schema.properties.interfaceUnionMember2Property
        .identifier,
      [
        $literalFactory.string(
          _interfaceUnionMember2.interfaceUnionMember2Property,
        ),
      ],
      options?.graph,
    );
    return resource;
  }

  export const $schema = {
    properties: {
      ...InterfaceUnionMemberCommonParentStatic.$schema.properties,
      interfaceUnionMember2Property: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/interfaceUnionMember2Property",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: InterfaceUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InterfaceUnionMember2.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          InterfaceUnionMember2.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: InterfaceUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InterfaceUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("interfaceUnionMember2");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat(
      InterfaceUnionMemberCommonParentStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "interfaceUnionMember2"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "interfaceUnionMember2")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "interfaceUnionMember2")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "interfaceUnionMember2")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "interfaceUnionMember2")
          }InterfaceUnionMember2Property`,
        ),
        predicate:
          InterfaceUnionMember2.$schema.properties.interfaceUnionMember2Property
            .identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: InterfaceUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("interfaceUnionMember2");
    patterns = patterns.concat(
      InterfaceUnionMemberCommonParentStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "interfaceUnionMember2"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "interfaceUnionMember2")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: InterfaceUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "interfaceUnionMember2")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.interfaceUnionMember2Property,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "interfaceUnionMember2")
                  }InterfaceUnionMember2Property`,
                ),
                predicate:
                  InterfaceUnionMember2.$schema.properties
                    .interfaceUnionMember2Property.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          InterfaceUnionMember2.$schema.properties.interfaceUnionMember2Property.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "interfaceUnionMember2")
          }InterfaceUnionMember2Property`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "interfaceUnionMember2")
        }InterfaceUnionMember2Property`,
      }),
    );
    return patterns;
  }
}
export interface InterfaceUnionMember1
  extends InterfaceUnionMemberCommonParent {
  readonly $identifier: InterfaceUnionMember1.$Identifier;
  readonly $type: "InterfaceUnionMember1";
  readonly interfaceUnionMember1Property: string;
}

export namespace InterfaceUnionMember1 {
  export function $create(
    parameters: {
      readonly $identifier?: (BlankNode | NamedNode) | string;
      readonly interfaceUnionMember1Property: string;
    } & Parameters<typeof InterfaceUnionMemberCommonParentStatic.$create>[0],
  ): InterfaceUnionMember1 {
    let $identifier: InterfaceUnionMember1.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }
    const $type = "InterfaceUnionMember1" as const;
    const interfaceUnionMember1Property =
      parameters.interfaceUnionMember1Property;
    return {
      ...InterfaceUnionMemberCommonParentStatic.$create(parameters),
      $identifier,
      $type,
      interfaceUnionMember1Property,
    };
  }

  export function $equals(
    left: InterfaceUnionMember1,
    right: InterfaceUnionMember1,
  ): $EqualsResult {
    return InterfaceUnionMemberCommonParentStatic.$equals(left, right).chain(
      () =>
        $strictEquals(
          left.interfaceUnionMember1Property,
          right.interfaceUnionMember1Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "interfaceUnionMember1Property",
          propertyValuesUnequal,
          type: "property" as const,
        })),
    );
  }

  export function $hash<HasherT extends $Hasher>(
    _interfaceUnionMember1: InterfaceUnionMember1,
    _hasher: HasherT,
  ): HasherT {
    InterfaceUnionMember1.$hashShaclProperties(_interfaceUnionMember1, _hasher);
    return _hasher;
  }

  export function $hashShaclProperties<HasherT extends $Hasher>(
    _interfaceUnionMember1: InterfaceUnionMember1,
    _hasher: HasherT,
  ): HasherT {
    InterfaceUnionMemberCommonParentStatic.$hashShaclProperties(
      _interfaceUnionMember1,
      _hasher,
    );
    _hasher.update(_interfaceUnionMember1.interfaceUnionMember1Property);
    return _hasher;
  }

  export function $filter(
    filter: InterfaceUnionMember1.$Filter,
    value: InterfaceUnionMember1,
  ): boolean {
    if (!InterfaceUnionMemberCommonParentStatic.$filter(filter, value)) {
      return false;
    }
    if (
      typeof filter.interfaceUnionMember1Property !== "undefined" &&
      !$filterString(
        filter.interfaceUnionMember1Property,
        value.interfaceUnionMember1Property,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly interfaceUnionMember1Property?: $StringFilter;
  } & InterfaceUnionMemberCommonParentStatic.$Filter;

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/InterfaceUnionMember1",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      $type: "InterfaceUnionMember1";
      interfaceUnionMember1Property: string;
    } & $UnwrapR<
      ReturnType<
        typeof InterfaceUnionMemberCommonParentStatic.$propertiesFromJson
      >
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "InterfaceUnionMember1" as const;
    const interfaceUnionMember1Property =
      $jsonObject["interfaceUnionMember1Property"];
    return InterfaceUnionMemberCommonParentStatic.$propertiesFromJson(
      $jsonObject,
    ).map(($super0) => ({
      ...$super0,
      $identifier,
      $type,
      interfaceUnionMember1Property,
    }));
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, InterfaceUnionMember1> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InterfaceUnionMemberCommonParentStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/interfaceUnionMember1Property`,
          type: "Control",
        },
      ],
      label: "InterfaceUnionMember1",
      type: "Group",
    };
  }

  export function $toJson(
    _interfaceUnionMember1: InterfaceUnionMember1,
  ): InterfaceUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        ...InterfaceUnionMemberCommonParentStatic.$toJson(
          _interfaceUnionMember1,
        ),
        interfaceUnionMember1Property:
          _interfaceUnionMember1.interfaceUnionMember1Property,
      } satisfies InterfaceUnionMember1.$Json),
    );
  }

  export function $jsonZodSchema() {
    return InterfaceUnionMemberCommonParentStatic.$jsonZodSchema().merge(
      z.object({
        "@id": z.string().min(1),
        $type: z.literal("InterfaceUnionMember1"),
        interfaceUnionMember1Property: z.string(),
      }),
    ) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly interfaceUnionMember1Property: string;
  } & InterfaceUnionMemberCommonParentStatic.$Json;

  export function isInterfaceUnionMember1(
    object: $Object,
  ): object is InterfaceUnionMember1 {
    switch (object.$type) {
      case "InterfaceUnionMember1":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, InterfaceUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return InterfaceUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      $type: "InterfaceUnionMember1";
      interfaceUnionMember1Property: string;
    } & $UnwrapR<
      ReturnType<
        typeof InterfaceUnionMemberCommonParentStatic.$propertiesFromRdf
      >
    >
  > {
    return InterfaceUnionMemberCommonParentStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/InterfaceUnionMember1":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  InterfaceUnionMember1.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/InterfaceUnionMember1)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        Either.of<Error, InterfaceUnionMember1.$Identifier>(
          $parameters.resource.identifier as InterfaceUnionMember1.$Identifier,
        ).chain(($identifier) =>
          Either.of<Error, "InterfaceUnionMember1">(
            "InterfaceUnionMember1" as const,
          ).chain(($type) =>
            Either.of<Error, Resource.Values<Resource.TermValue>>(
              $parameters.resource.values(
                $schema.properties.interfaceUnionMember1Property.identifier,
                {
                  unique: true,
                },
              ),
            )
              .chain((values) =>
                $fromRdfPreferredLanguages({
                  focusResource: $parameters.resource,
                  predicate:
                    InterfaceUnionMember1.$schema.properties
                      .interfaceUnionMember1Property.identifier,
                  preferredLanguages: $parameters.preferredLanguages,
                  values,
                }),
              )
              .chain((values) => values.chainMap((value) => value.toString()))
              .chain((values) => values.head())
              .map((interfaceUnionMember1Property) => ({
                ...$super0,
                $identifier,
                $type,
                interfaceUnionMember1Property,
              })),
          ),
        ),
      ),
    );
  }

  export function $toRdf(
    _interfaceUnionMember1: InterfaceUnionMember1,
    options?: {
      ignoreRdfType?: boolean;
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = InterfaceUnionMemberCommonParentStatic.$toRdf(
      _interfaceUnionMember1,
      {
        ignoreRdfType: true,
        graph: options?.graph,
        resourceSet,
      },
    );
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/InterfaceUnionMember1"),
        options?.graph,
      );
    }
    resource.add(
      InterfaceUnionMember1.$schema.properties.interfaceUnionMember1Property
        .identifier,
      [
        $literalFactory.string(
          _interfaceUnionMember1.interfaceUnionMember1Property,
        ),
      ],
      options?.graph,
    );
    return resource;
  }

  export const $schema = {
    properties: {
      ...InterfaceUnionMemberCommonParentStatic.$schema.properties,
      interfaceUnionMember1Property: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/interfaceUnionMember1Property",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: InterfaceUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InterfaceUnionMember1.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          InterfaceUnionMember1.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: InterfaceUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InterfaceUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("interfaceUnionMember1");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat(
      InterfaceUnionMemberCommonParentStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "interfaceUnionMember1"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "interfaceUnionMember1")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "interfaceUnionMember1")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "interfaceUnionMember1")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "interfaceUnionMember1")
          }InterfaceUnionMember1Property`,
        ),
        predicate:
          InterfaceUnionMember1.$schema.properties.interfaceUnionMember1Property
            .identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: InterfaceUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("interfaceUnionMember1");
    patterns = patterns.concat(
      InterfaceUnionMemberCommonParentStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "interfaceUnionMember1"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "interfaceUnionMember1")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: InterfaceUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "interfaceUnionMember1")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.interfaceUnionMember1Property,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "interfaceUnionMember1")
                  }InterfaceUnionMember1Property`,
                ),
                predicate:
                  InterfaceUnionMember1.$schema.properties
                    .interfaceUnionMember1Property.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          InterfaceUnionMember1.$schema.properties.interfaceUnionMember1Property.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "interfaceUnionMember1")
          }InterfaceUnionMember1Property`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "interfaceUnionMember1")
        }InterfaceUnionMember1Property`,
      }),
    );
    return patterns;
  }
} /**
 * A node shape that's generated as a TypeScript interface instead of a class.
 */

export interface Interface {
  readonly $identifier: Interface.$Identifier;
  readonly $type: "Interface";
  readonly interfaceProperty: string;
}

export namespace Interface {
  export function $create(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly interfaceProperty: string;
  }): Interface {
    let $identifier: Interface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }
    const $type = "Interface" as const;
    const interfaceProperty = parameters.interfaceProperty;
    return { $identifier, $type, interfaceProperty };
  }

  export function $equals(left: Interface, right: Interface): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(left.interfaceProperty, right.interfaceProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "interfaceProperty",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      );
  }

  export function $hash<HasherT extends $Hasher>(
    _interface: Interface,
    _hasher: HasherT,
  ): HasherT {
    Interface.$hashShaclProperties(_interface, _hasher);
    _hasher.update(_interface.$identifier.value);
    _hasher.update(_interface.$type);
    return _hasher;
  }

  export function $hashShaclProperties<HasherT extends $Hasher>(
    _interface: Interface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_interface.interfaceProperty);
    return _hasher;
  }

  export function $filter(
    filter: Interface.$Filter,
    value: Interface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.interfaceProperty !== "undefined" &&
      !$filterString(filter.interfaceProperty, value.interfaceProperty)
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly interfaceProperty?: $StringFilter;
  };

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      $type: "Interface";
      interfaceProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "Interface" as const;
    const interfaceProperty = $jsonObject["interfaceProperty"];
    return Either.of({ $identifier, $type, interfaceProperty });
  }

  export function $fromJson(json: unknown): Either<z.ZodError, Interface> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "Interface" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/interfaceProperty`,
          type: "Control",
        },
      ],
      label: "Interface",
      type: "Group",
    };
  }

  export function $toJson(_interface: Interface): Interface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _interface.$identifier.termType === "BlankNode"
            ? `_:${_interface.$identifier.value}`
            : _interface.$identifier.value,
        $type: _interface.$type,
        interfaceProperty: _interface.interfaceProperty,
      } satisfies Interface.$Json),
    );
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("Interface"),
      interfaceProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "Interface";
    readonly interfaceProperty: string;
  };

  export function isInterface(object: $Object): object is Interface {
    switch (object.$type) {
      case "Interface":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, Interface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return Interface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      $type: "Interface";
      interfaceProperty: string;
    }
  > {
    return Either.of<Error, Interface.$Identifier>(
      $parameters.resource.identifier as Interface.$Identifier,
    ).chain(($identifier) =>
      Either.of<Error, "Interface">("Interface" as const).chain(($type) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.interfaceProperty.identifier,
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                Interface.$schema.properties.interfaceProperty.identifier,
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((interfaceProperty) => ({
            $identifier,
            $type,
            interfaceProperty,
          })),
      ),
    );
  }

  export function $toRdf(
    _interface: Interface,
    options?: {
      ignoreRdfType?: boolean;
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(_interface.$identifier);
    resource.add(
      Interface.$schema.properties.interfaceProperty.identifier,
      [$literalFactory.string(_interface.interfaceProperty)],
      options?.graph,
    );
    return resource;
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["Interface"],
        }),
      },
      interfaceProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/interfaceProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: Interface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Interface.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          Interface.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: Interface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Interface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("interface");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable" ? subject.value : "interface")
          }InterfaceProperty`,
        ),
        predicate: Interface.$schema.properties.interfaceProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: Interface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("interface");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: Interface.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable" ? subject.value : "interface"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.interfaceProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "interface")
                  }InterfaceProperty`,
                ),
                predicate:
                  Interface.$schema.properties.interfaceProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema: Interface.$schema.properties.interfaceProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable" ? subject.value : "interface")
          }InterfaceProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable" ? subject.value : "interface")
        }InterfaceProperty`,
      }),
    );
    return patterns;
  }
}
export class IndirectRecursiveHelperClass {
  private _$identifier?: IndirectRecursiveHelperClass.$Identifier;

  readonly $type: "IndirectRecursiveHelperClass" =
    "IndirectRecursiveHelperClass" as const;

  readonly indirectRecursiveProperty: Maybe<IndirectRecursiveClass>;

  constructor(parameters?: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly indirectRecursiveProperty?:
      | Maybe<IndirectRecursiveClass>
      | IndirectRecursiveClass;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }
    if (Maybe.isMaybe(parameters?.indirectRecursiveProperty)) {
      this.indirectRecursiveProperty = parameters?.indirectRecursiveProperty;
    } else if (
      typeof parameters?.indirectRecursiveProperty === "object" &&
      parameters?.indirectRecursiveProperty instanceof IndirectRecursiveClass
    ) {
      this.indirectRecursiveProperty = Maybe.of(
        parameters?.indirectRecursiveProperty,
      );
    } else if (typeof parameters?.indirectRecursiveProperty === "undefined") {
      this.indirectRecursiveProperty = Maybe.empty();
    } else {
      this.indirectRecursiveProperty =
        parameters?.indirectRecursiveProperty satisfies never;
    }
  }

  get $identifier(): IndirectRecursiveHelperClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: IndirectRecursiveHelperClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.indirectRecursiveProperty,
          other.indirectRecursiveProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "indirectRecursiveProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    this.indirectRecursiveProperty.ifJust((value0) => {
      value0.$hash(_hasher);
    });
    return _hasher;
  }

  $toJson(): IndirectRecursiveHelperClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        indirectRecursiveProperty: this.indirectRecursiveProperty
          .map((item) => item.$toJson())
          .extract(),
      } satisfies IndirectRecursiveHelperClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode(
          "http://example.com/IndirectRecursiveHelperClass",
        ),
        options?.graph,
      );
    }
    resource.add(
      IndirectRecursiveHelperClass.$schema.properties.indirectRecursiveProperty
        .identifier,
      this.indirectRecursiveProperty
        .toList()
        .flatMap((value) => [
          value.$toRdf({ graph: options?.graph, resourceSet: resourceSet })
            .identifier,
        ]),
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IndirectRecursiveHelperClass {
  export function $filter(
    filter: IndirectRecursiveHelperClass.$Filter,
    value: IndirectRecursiveHelperClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.indirectRecursiveProperty !== "undefined" &&
      !$filterMaybe<IndirectRecursiveClass, IndirectRecursiveClass.$Filter>(
        IndirectRecursiveClass.$filter,
      )(filter.indirectRecursiveProperty, value.indirectRecursiveProperty)
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly indirectRecursiveProperty?: $MaybeFilter<IndirectRecursiveClass.$Filter>;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/IndirectRecursiveHelperClass",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      indirectRecursiveProperty: Maybe<IndirectRecursiveClass>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const indirectRecursiveProperty = Maybe.fromNullable(
      $jsonObject["indirectRecursiveProperty"],
    ).map((item) => IndirectRecursiveClass.$fromJson(item).unsafeCoerce());
    return Either.of({ $identifier, indirectRecursiveProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, IndirectRecursiveHelperClass> {
    return $propertiesFromJson(json).map(
      (properties) => new IndirectRecursiveHelperClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "IndirectRecursiveHelperClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        IndirectRecursiveClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/indirectRecursiveProperty`,
        }),
      ],
      label: "IndirectRecursiveHelperClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("IndirectRecursiveHelperClass"),
      indirectRecursiveProperty: z
        .lazy(
          (): z.ZodType<IndirectRecursiveClass.$Json> =>
            IndirectRecursiveClass.$jsonZodSchema(),
        )
        .optional(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "IndirectRecursiveHelperClass";
    readonly indirectRecursiveProperty?: IndirectRecursiveClass.$Json;
  };

  export function isIndirectRecursiveHelperClass(
    object: $Object,
  ): object is IndirectRecursiveHelperClass {
    switch (object.$type) {
      case "IndirectRecursiveHelperClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, IndirectRecursiveHelperClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return IndirectRecursiveHelperClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new IndirectRecursiveHelperClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      indirectRecursiveProperty: Maybe<IndirectRecursiveClass>;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/IndirectRecursiveHelperClass":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  IndirectRecursiveHelperClass.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/IndirectRecursiveHelperClass)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, IndirectRecursiveHelperClass.$Identifier>(
        $parameters.resource
          .identifier as IndirectRecursiveHelperClass.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.indirectRecursiveProperty.identifier,
            { unique: true },
          ),
        )
          .chain((values) =>
            values.chainMap((value) =>
              value.toResource().chain((resource) =>
                IndirectRecursiveClass.$fromRdf(resource, {
                  context: $parameters.context,
                  ignoreRdfType: true,
                  objectSet: $parameters.objectSet,
                  preferredLanguages: $parameters.preferredLanguages,
                }),
              ),
            ),
          )
          .map((values) =>
            values.length > 0
              ? values.map((value) => Maybe.of(value))
              : Resource.Values.fromValue<Maybe<IndirectRecursiveClass>>({
                  focusResource: $parameters.resource,
                  predicate:
                    IndirectRecursiveHelperClass.$schema.properties
                      .indirectRecursiveProperty.identifier,
                  value: Maybe.empty(),
                }),
          )
          .chain((values) => values.head())
          .map((indirectRecursiveProperty) => ({
            $identifier,
            indirectRecursiveProperty,
          })),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["IndirectRecursiveHelperClass"],
        }),
      },
      indirectRecursiveProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => IndirectRecursiveClass.$schema,
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/indirectRecursiveProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IndirectRecursiveHelperClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IndirectRecursiveHelperClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          IndirectRecursiveHelperClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IndirectRecursiveHelperClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IndirectRecursiveHelperClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("indirectRecursiveHelperClass");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "indirectRecursiveHelperClass")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "indirectRecursiveHelperClass")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "indirectRecursiveHelperClass")
            }RdfClass`,
          ),
        },
      );
    }
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IndirectRecursiveHelperClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("indirectRecursiveHelperClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "indirectRecursiveHelperClass")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: IndirectRecursiveHelperClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "indirectRecursiveHelperClass")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            IndirectRecursiveHelperClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "indirectRecursiveHelperClass"),
        }),
      );
    }
    return patterns;
  }
}
export class IndirectRecursiveClass {
  private _$identifier?: IndirectRecursiveClass.$Identifier;

  readonly $type: "IndirectRecursiveClass" = "IndirectRecursiveClass" as const;

  readonly indirectRecursiveHelperProperty: Maybe<IndirectRecursiveHelperClass>;

  constructor(parameters?: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly indirectRecursiveHelperProperty?:
      | Maybe<IndirectRecursiveHelperClass>
      | IndirectRecursiveHelperClass;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }
    if (Maybe.isMaybe(parameters?.indirectRecursiveHelperProperty)) {
      this.indirectRecursiveHelperProperty =
        parameters?.indirectRecursiveHelperProperty;
    } else if (
      typeof parameters?.indirectRecursiveHelperProperty === "object" &&
      parameters?.indirectRecursiveHelperProperty instanceof
        IndirectRecursiveHelperClass
    ) {
      this.indirectRecursiveHelperProperty = Maybe.of(
        parameters?.indirectRecursiveHelperProperty,
      );
    } else if (
      typeof parameters?.indirectRecursiveHelperProperty === "undefined"
    ) {
      this.indirectRecursiveHelperProperty = Maybe.empty();
    } else {
      this.indirectRecursiveHelperProperty =
        parameters?.indirectRecursiveHelperProperty satisfies never;
    }
  }

  get $identifier(): IndirectRecursiveClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: IndirectRecursiveClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.indirectRecursiveHelperProperty,
          other.indirectRecursiveHelperProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "indirectRecursiveHelperProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    this.indirectRecursiveHelperProperty.ifJust((value0) => {
      value0.$hash(_hasher);
    });
    return _hasher;
  }

  $toJson(): IndirectRecursiveClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        indirectRecursiveHelperProperty: this.indirectRecursiveHelperProperty
          .map((item) => item.$toJson())
          .extract(),
      } satisfies IndirectRecursiveClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/IndirectRecursiveClass"),
        options?.graph,
      );
    }
    resource.add(
      IndirectRecursiveClass.$schema.properties.indirectRecursiveHelperProperty
        .identifier,
      this.indirectRecursiveHelperProperty
        .toList()
        .flatMap((value) => [
          value.$toRdf({ graph: options?.graph, resourceSet: resourceSet })
            .identifier,
        ]),
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IndirectRecursiveClass {
  export function $filter(
    filter: IndirectRecursiveClass.$Filter,
    value: IndirectRecursiveClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.indirectRecursiveHelperProperty !== "undefined" &&
      !$filterMaybe<
        IndirectRecursiveHelperClass,
        IndirectRecursiveHelperClass.$Filter
      >(IndirectRecursiveHelperClass.$filter)(
        filter.indirectRecursiveHelperProperty,
        value.indirectRecursiveHelperProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly indirectRecursiveHelperProperty?: $MaybeFilter<IndirectRecursiveHelperClass.$Filter>;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/IndirectRecursiveClass",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      indirectRecursiveHelperProperty: Maybe<IndirectRecursiveHelperClass>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const indirectRecursiveHelperProperty = Maybe.fromNullable(
      $jsonObject["indirectRecursiveHelperProperty"],
    ).map((item) =>
      IndirectRecursiveHelperClass.$fromJson(item).unsafeCoerce(),
    );
    return Either.of({ $identifier, indirectRecursiveHelperProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, IndirectRecursiveClass> {
    return $propertiesFromJson(json).map(
      (properties) => new IndirectRecursiveClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "IndirectRecursiveClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        IndirectRecursiveHelperClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/indirectRecursiveHelperProperty`,
        }),
      ],
      label: "IndirectRecursiveClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("IndirectRecursiveClass"),
      indirectRecursiveHelperProperty: z
        .lazy(
          (): z.ZodType<IndirectRecursiveHelperClass.$Json> =>
            IndirectRecursiveHelperClass.$jsonZodSchema(),
        )
        .optional(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "IndirectRecursiveClass";
    readonly indirectRecursiveHelperProperty?: IndirectRecursiveHelperClass.$Json;
  };

  export function isIndirectRecursiveClass(
    object: $Object,
  ): object is IndirectRecursiveClass {
    switch (object.$type) {
      case "IndirectRecursiveClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, IndirectRecursiveClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return IndirectRecursiveClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new IndirectRecursiveClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      indirectRecursiveHelperProperty: Maybe<IndirectRecursiveHelperClass>;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/IndirectRecursiveClass":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  IndirectRecursiveClass.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/IndirectRecursiveClass)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, IndirectRecursiveClass.$Identifier>(
        $parameters.resource.identifier as IndirectRecursiveClass.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.indirectRecursiveHelperProperty.identifier,
            {
              unique: true,
            },
          ),
        )
          .chain((values) =>
            values.chainMap((value) =>
              value.toResource().chain((resource) =>
                IndirectRecursiveHelperClass.$fromRdf(resource, {
                  context: $parameters.context,
                  ignoreRdfType: true,
                  objectSet: $parameters.objectSet,
                  preferredLanguages: $parameters.preferredLanguages,
                }),
              ),
            ),
          )
          .map((values) =>
            values.length > 0
              ? values.map((value) => Maybe.of(value))
              : Resource.Values.fromValue<Maybe<IndirectRecursiveHelperClass>>({
                  focusResource: $parameters.resource,
                  predicate:
                    IndirectRecursiveClass.$schema.properties
                      .indirectRecursiveHelperProperty.identifier,
                  value: Maybe.empty(),
                }),
          )
          .chain((values) => values.head())
          .map((indirectRecursiveHelperProperty) => ({
            $identifier,
            indirectRecursiveHelperProperty,
          })),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["IndirectRecursiveClass"],
        }),
      },
      indirectRecursiveHelperProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => IndirectRecursiveHelperClass.$schema,
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/indirectRecursiveHelperProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IndirectRecursiveClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IndirectRecursiveClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          IndirectRecursiveClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IndirectRecursiveClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IndirectRecursiveClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("indirectRecursiveClass");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "indirectRecursiveClass")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "indirectRecursiveClass")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "indirectRecursiveClass")
            }RdfClass`,
          ),
        },
      );
    }
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IndirectRecursiveClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("indirectRecursiveClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "indirectRecursiveClass")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: IndirectRecursiveClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "indirectRecursiveClass")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: IndirectRecursiveClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "indirectRecursiveClass"),
        }),
      );
    }
    return patterns;
  }
} /**
 * Shape with sh:in properties.
 */

export class InPropertiesClass {
  private _$identifier?: InPropertiesClass.$Identifier;

  readonly $type: "InPropertiesClass" = "InPropertiesClass" as const;

  readonly inBooleansProperty: Maybe<true>;

  readonly inDateTimesProperty: Maybe<Date>;

  readonly inIrisProperty: Maybe<
    NamedNode<
      | "http://example.com/InPropertiesIri1"
      | "http://example.com/InPropertiesIri2"
    >
  >;

  readonly inNumbersProperty: Maybe<1 | 2>;

  readonly inStringsProperty: Maybe<"text" | "html">;

  constructor(parameters?: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly inBooleansProperty?: Maybe<true> | true;
    readonly inDateTimesProperty?: Maybe<Date> | Date;
    readonly inIrisProperty?:
      | Maybe<
          NamedNode<
            | "http://example.com/InPropertiesIri1"
            | "http://example.com/InPropertiesIri2"
          >
        >
      | NamedNode<
          | "http://example.com/InPropertiesIri1"
          | "http://example.com/InPropertiesIri2"
        >
      | "http://example.com/InPropertiesIri1"
      | "http://example.com/InPropertiesIri2";
    readonly inNumbersProperty?: Maybe<1 | 2> | 1 | 2;
    readonly inStringsProperty?: Maybe<"text" | "html"> | "text" | "html";
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }
    if (Maybe.isMaybe(parameters?.inBooleansProperty)) {
      this.inBooleansProperty = parameters?.inBooleansProperty;
    } else if (typeof parameters?.inBooleansProperty === "boolean") {
      this.inBooleansProperty = Maybe.of(parameters?.inBooleansProperty);
    } else if (typeof parameters?.inBooleansProperty === "undefined") {
      this.inBooleansProperty = Maybe.empty();
    } else {
      this.inBooleansProperty = parameters?.inBooleansProperty satisfies never;
    }
    if (Maybe.isMaybe(parameters?.inDateTimesProperty)) {
      this.inDateTimesProperty = parameters?.inDateTimesProperty;
    } else if (
      typeof parameters?.inDateTimesProperty === "object" &&
      parameters?.inDateTimesProperty instanceof Date
    ) {
      this.inDateTimesProperty = Maybe.of(parameters?.inDateTimesProperty);
    } else if (typeof parameters?.inDateTimesProperty === "undefined") {
      this.inDateTimesProperty = Maybe.empty();
    } else {
      this.inDateTimesProperty =
        parameters?.inDateTimesProperty satisfies never;
    }
    if (Maybe.isMaybe(parameters?.inIrisProperty)) {
      this.inIrisProperty = parameters?.inIrisProperty;
    } else if (typeof parameters?.inIrisProperty === "object") {
      this.inIrisProperty = Maybe.of(parameters?.inIrisProperty);
    } else if (typeof parameters?.inIrisProperty === "string") {
      this.inIrisProperty = Maybe.of(
        dataFactory.namedNode(parameters?.inIrisProperty),
      );
    } else if (typeof parameters?.inIrisProperty === "undefined") {
      this.inIrisProperty = Maybe.empty();
    } else {
      this.inIrisProperty = parameters?.inIrisProperty satisfies never;
    }
    if (Maybe.isMaybe(parameters?.inNumbersProperty)) {
      this.inNumbersProperty = parameters?.inNumbersProperty;
    } else if (typeof parameters?.inNumbersProperty === "number") {
      this.inNumbersProperty = Maybe.of(parameters?.inNumbersProperty);
    } else if (typeof parameters?.inNumbersProperty === "undefined") {
      this.inNumbersProperty = Maybe.empty();
    } else {
      this.inNumbersProperty = parameters?.inNumbersProperty satisfies never;
    }
    if (Maybe.isMaybe(parameters?.inStringsProperty)) {
      this.inStringsProperty = parameters?.inStringsProperty;
    } else if (typeof parameters?.inStringsProperty === "string") {
      this.inStringsProperty = Maybe.of(parameters?.inStringsProperty);
    } else if (typeof parameters?.inStringsProperty === "undefined") {
      this.inStringsProperty = Maybe.empty();
    } else {
      this.inStringsProperty = parameters?.inStringsProperty satisfies never;
    }
  }

  get $identifier(): InPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: InPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.inBooleansProperty,
          other.inBooleansProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inBooleansProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.inDateTimesProperty,
          other.inDateTimesProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inDateTimesProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.inIrisProperty,
          other.inIrisProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inIrisProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.inNumbersProperty,
          other.inNumbersProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inNumbersProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.inStringsProperty,
          other.inStringsProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inStringsProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    this.inBooleansProperty.ifJust((value0) => {
      _hasher.update(value0.toString());
    });
    this.inDateTimesProperty.ifJust((value0) => {
      _hasher.update(value0.toISOString());
    });
    this.inIrisProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    this.inNumbersProperty.ifJust((value0) => {
      _hasher.update(value0.toString());
    });
    this.inStringsProperty.ifJust((value0) => {
      _hasher.update(value0);
    });
    return _hasher;
  }

  $toJson(): InPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        inBooleansProperty: this.inBooleansProperty
          .map((item) => item)
          .extract(),
        inDateTimesProperty: this.inDateTimesProperty
          .map((item) => item.toISOString())
          .extract(),
        inIrisProperty: this.inIrisProperty
          .map((item) => ({ "@id": item.value }))
          .extract(),
        inNumbersProperty: this.inNumbersProperty.map((item) => item).extract(),
        inStringsProperty: this.inStringsProperty.map((item) => item).extract(),
      } satisfies InPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/InPropertiesClass"),
        options?.graph,
      );
    }
    resource.add(
      InPropertiesClass.$schema.properties.inBooleansProperty.identifier,
      this.inBooleansProperty
        .toList()
        .flatMap((value) => [$literalFactory.boolean(value)]),
      options?.graph,
    );
    resource.add(
      InPropertiesClass.$schema.properties.inDateTimesProperty.identifier,
      this.inDateTimesProperty
        .toList()
        .flatMap((value) => [
          $literalFactory.date(value, $RdfVocabularies.xsd.dateTime),
        ]),
      options?.graph,
    );
    resource.add(
      InPropertiesClass.$schema.properties.inIrisProperty.identifier,
      this.inIrisProperty.toList(),
      options?.graph,
    );
    resource.add(
      InPropertiesClass.$schema.properties.inNumbersProperty.identifier,
      this.inNumbersProperty
        .toList()
        .flatMap((value) => [
          $literalFactory.number(value, $RdfVocabularies.xsd.integer),
        ]),
      options?.graph,
    );
    resource.add(
      InPropertiesClass.$schema.properties.inStringsProperty.identifier,
      this.inStringsProperty
        .toList()
        .flatMap((value) => [$literalFactory.string(value)]),
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace InPropertiesClass {
  export function $filter(
    filter: InPropertiesClass.$Filter,
    value: InPropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.inBooleansProperty !== "undefined" &&
      !$filterMaybe<true, $BooleanFilter>($filterBoolean)(
        filter.inBooleansProperty,
        value.inBooleansProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.inDateTimesProperty !== "undefined" &&
      !$filterMaybe<Date, $DateFilter>($filterDate)(
        filter.inDateTimesProperty,
        value.inDateTimesProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.inIrisProperty !== "undefined" &&
      !$filterMaybe<
        NamedNode<
          | "http://example.com/InPropertiesIri1"
          | "http://example.com/InPropertiesIri2"
        >,
        $NamedNodeFilter
      >($filterNamedNode)(filter.inIrisProperty, value.inIrisProperty)
    ) {
      return false;
    }
    if (
      typeof filter.inNumbersProperty !== "undefined" &&
      !$filterMaybe<1 | 2, $NumberFilter>($filterNumber)(
        filter.inNumbersProperty,
        value.inNumbersProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.inStringsProperty !== "undefined" &&
      !$filterMaybe<"text" | "html", $StringFilter>($filterString)(
        filter.inStringsProperty,
        value.inStringsProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly inBooleansProperty?: $MaybeFilter<$BooleanFilter>;
    readonly inDateTimesProperty?: $MaybeFilter<$DateFilter>;
    readonly inIrisProperty?: $MaybeFilter<$NamedNodeFilter>;
    readonly inNumbersProperty?: $MaybeFilter<$NumberFilter>;
    readonly inStringsProperty?: $MaybeFilter<$StringFilter>;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/InPropertiesClass",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      inBooleansProperty: Maybe<true>;
      inDateTimesProperty: Maybe<Date>;
      inIrisProperty: Maybe<
        NamedNode<
          | "http://example.com/InPropertiesIri1"
          | "http://example.com/InPropertiesIri2"
        >
      >;
      inNumbersProperty: Maybe<1 | 2>;
      inStringsProperty: Maybe<"text" | "html">;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const inBooleansProperty = Maybe.fromNullable(
      $jsonObject["inBooleansProperty"],
    );
    const inDateTimesProperty = Maybe.fromNullable(
      $jsonObject["inDateTimesProperty"],
    ).map((item) => new Date(item));
    const inIrisProperty = Maybe.fromNullable(
      $jsonObject["inIrisProperty"],
    ).map((item) => dataFactory.namedNode(item["@id"]));
    const inNumbersProperty = Maybe.fromNullable(
      $jsonObject["inNumbersProperty"],
    );
    const inStringsProperty = Maybe.fromNullable(
      $jsonObject["inStringsProperty"],
    );
    return Either.of({
      $identifier,
      inBooleansProperty,
      inDateTimesProperty,
      inIrisProperty,
      inNumbersProperty,
      inStringsProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, InPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new InPropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "InPropertiesClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/inBooleansProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/inDateTimesProperty`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/inIrisProperty`, type: "Control" },
        {
          scope: `${scopePrefix}/properties/inNumbersProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/inStringsProperty`,
          type: "Control",
        },
      ],
      label: "InPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("InPropertiesClass"),
      inBooleansProperty: z.literal(true).optional(),
      inDateTimesProperty: z.iso.datetime().optional(),
      inIrisProperty: z
        .object({
          "@id": z.enum([
            "http://example.com/InPropertiesIri1",
            "http://example.com/InPropertiesIri2",
          ]),
        })
        .optional(),
      inNumbersProperty: z.union([z.literal(1), z.literal(2)]).optional(),
      inStringsProperty: z.enum(["text", "html"]).optional(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "InPropertiesClass";
    readonly inBooleansProperty?: true;
    readonly inDateTimesProperty?: string;
    readonly inIrisProperty?: {
      readonly "@id":
        | "http://example.com/InPropertiesIri1"
        | "http://example.com/InPropertiesIri2";
    };
    readonly inNumbersProperty?: 1 | 2;
    readonly inStringsProperty?: "text" | "html";
  };

  export function isInPropertiesClass(
    object: $Object,
  ): object is InPropertiesClass {
    switch (object.$type) {
      case "InPropertiesClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, InPropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return InPropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new InPropertiesClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      inBooleansProperty: Maybe<true>;
      inDateTimesProperty: Maybe<Date>;
      inIrisProperty: Maybe<
        NamedNode<
          | "http://example.com/InPropertiesIri1"
          | "http://example.com/InPropertiesIri2"
        >
      >;
      inNumbersProperty: Maybe<1 | 2>;
      inStringsProperty: Maybe<"text" | "html">;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/InPropertiesClass":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  InPropertiesClass.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/InPropertiesClass)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, InPropertiesClass.$Identifier>(
        $parameters.resource.identifier as InPropertiesClass.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.inBooleansProperty.identifier,
            { unique: true },
          ),
        )
          .chain((values) =>
            values.chainMap((value) =>
              value.toBoolean().chain((primitiveValue) =>
                primitiveValue === true
                  ? Either.of<Error, true>(primitiveValue)
                  : Left<Error, true>(
                      new Resource.MistypedTermValueError({
                        actualValue: value.toTerm(),
                        expectedValueType: "true",
                        focusResource: $parameters.resource,
                        predicate:
                          InPropertiesClass.$schema.properties
                            .inBooleansProperty.identifier,
                      }),
                    ),
              ),
            ),
          )
          .map((values) =>
            values.length > 0
              ? values.map((value) => Maybe.of(value))
              : Resource.Values.fromValue<Maybe<true>>({
                  focusResource: $parameters.resource,
                  predicate:
                    InPropertiesClass.$schema.properties.inBooleansProperty
                      .identifier,
                  value: Maybe.empty(),
                }),
          )
          .chain((values) => values.head())
          .chain((inBooleansProperty) =>
            Either.of<Error, Resource.Values<Resource.TermValue>>(
              $parameters.resource.values(
                $schema.properties.inDateTimesProperty.identifier,
                { unique: true },
              ),
            )
              .chain((values) =>
                values.chainMap((value) =>
                  value.toDate().chain((primitiveValue) => {
                    if (primitiveValue.getTime() === 1523268000000) {
                      return Either.of<Error, Date>(primitiveValue);
                    }
                    return Left<Error, Date>(
                      new Resource.MistypedTermValueError({
                        actualValue: value.toTerm(),
                        expectedValueType: "Date",
                        focusResource: $parameters.resource,
                        predicate:
                          InPropertiesClass.$schema.properties
                            .inDateTimesProperty.identifier,
                      }),
                    );
                  }),
                ),
              )
              .map((values) =>
                values.length > 0
                  ? values.map((value) => Maybe.of(value))
                  : Resource.Values.fromValue<Maybe<Date>>({
                      focusResource: $parameters.resource,
                      predicate:
                        InPropertiesClass.$schema.properties.inDateTimesProperty
                          .identifier,
                      value: Maybe.empty(),
                    }),
              )
              .chain((values) => values.head())
              .chain((inDateTimesProperty) =>
                Either.of<Error, Resource.Values<Resource.TermValue>>(
                  $parameters.resource.values(
                    $schema.properties.inIrisProperty.identifier,
                    { unique: true },
                  ),
                )
                  .chain((values) =>
                    values.chainMap((value) =>
                      value.toIri().chain((iri) => {
                        switch (iri.value) {
                          case "http://example.com/InPropertiesIri1":
                            return Either.of<
                              Error,
                              NamedNode<
                                | "http://example.com/InPropertiesIri1"
                                | "http://example.com/InPropertiesIri2"
                              >
                            >(
                              iri as NamedNode<"http://example.com/InPropertiesIri1">,
                            );
                          case "http://example.com/InPropertiesIri2":
                            return Either.of<
                              Error,
                              NamedNode<
                                | "http://example.com/InPropertiesIri1"
                                | "http://example.com/InPropertiesIri2"
                              >
                            >(
                              iri as NamedNode<"http://example.com/InPropertiesIri2">,
                            );
                          default:
                            return Left<
                              Error,
                              NamedNode<
                                | "http://example.com/InPropertiesIri1"
                                | "http://example.com/InPropertiesIri2"
                              >
                            >(
                              new Resource.MistypedTermValueError({
                                actualValue: iri,
                                expectedValueType:
                                  'NamedNode<"http://example.com/InPropertiesIri1" | "http://example.com/InPropertiesIri2">',
                                focusResource: $parameters.resource,
                                predicate:
                                  InPropertiesClass.$schema.properties
                                    .inIrisProperty.identifier,
                              }),
                            );
                        }
                      }),
                    ),
                  )
                  .map((values) =>
                    values.length > 0
                      ? values.map((value) => Maybe.of(value))
                      : Resource.Values.fromValue<
                          Maybe<
                            NamedNode<
                              | "http://example.com/InPropertiesIri1"
                              | "http://example.com/InPropertiesIri2"
                            >
                          >
                        >({
                          focusResource: $parameters.resource,
                          predicate:
                            InPropertiesClass.$schema.properties.inIrisProperty
                              .identifier,
                          value: Maybe.empty(),
                        }),
                  )
                  .chain((values) => values.head())
                  .chain((inIrisProperty) =>
                    Either.of<Error, Resource.Values<Resource.TermValue>>(
                      $parameters.resource.values(
                        $schema.properties.inNumbersProperty.identifier,
                        { unique: true },
                      ),
                    )
                      .chain((values) =>
                        values.chainMap((value) =>
                          value.toNumber().chain((primitiveValue) => {
                            switch (primitiveValue) {
                              case 1:
                              case 2:
                                return Either.of<Error, 1 | 2>(primitiveValue);
                              default:
                                return Left<Error, 1 | 2>(
                                  new Resource.MistypedTermValueError({
                                    actualValue: value.toTerm(),
                                    expectedValueType: "1 | 2",
                                    focusResource: $parameters.resource,
                                    predicate:
                                      InPropertiesClass.$schema.properties
                                        .inNumbersProperty.identifier,
                                  }),
                                );
                            }
                          }),
                        ),
                      )
                      .map((values) =>
                        values.length > 0
                          ? values.map((value) => Maybe.of(value))
                          : Resource.Values.fromValue<Maybe<1 | 2>>({
                              focusResource: $parameters.resource,
                              predicate:
                                InPropertiesClass.$schema.properties
                                  .inNumbersProperty.identifier,
                              value: Maybe.empty(),
                            }),
                      )
                      .chain((values) => values.head())
                      .chain((inNumbersProperty) =>
                        Either.of<Error, Resource.Values<Resource.TermValue>>(
                          $parameters.resource.values(
                            $schema.properties.inStringsProperty.identifier,
                            { unique: true },
                          ),
                        )
                          .chain((values) =>
                            $fromRdfPreferredLanguages({
                              focusResource: $parameters.resource,
                              predicate:
                                InPropertiesClass.$schema.properties
                                  .inStringsProperty.identifier,
                              preferredLanguages:
                                $parameters.preferredLanguages,
                              values,
                            }),
                          )
                          .chain((values) =>
                            values.chainMap((value) =>
                              value.toString().chain((string_) => {
                                switch (string_) {
                                  case "text":
                                  case "html":
                                    return Either.of<Error, "text" | "html">(
                                      string_,
                                    );
                                  default:
                                    return Left<Error, "text" | "html">(
                                      new Resource.MistypedTermValueError({
                                        actualValue: value.toTerm(),
                                        expectedValueType: '"text" | "html"',
                                        focusResource: $parameters.resource,
                                        predicate:
                                          InPropertiesClass.$schema.properties
                                            .inStringsProperty.identifier,
                                      }),
                                    );
                                }
                              }),
                            ),
                          )
                          .map((values) =>
                            values.length > 0
                              ? values.map((value) => Maybe.of(value))
                              : Resource.Values.fromValue<
                                  Maybe<"text" | "html">
                                >({
                                  focusResource: $parameters.resource,
                                  predicate:
                                    InPropertiesClass.$schema.properties
                                      .inStringsProperty.identifier,
                                  value: Maybe.empty(),
                                }),
                          )
                          .chain((values) => values.head())
                          .map((inStringsProperty) => ({
                            $identifier,
                            inBooleansProperty,
                            inDateTimesProperty,
                            inIrisProperty,
                            inNumbersProperty,
                            inStringsProperty,
                          })),
                      ),
                  ),
              ),
          ),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["InPropertiesClass"],
        }),
      },
      inBooleansProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({ kind: "Boolean" as const, in: [true] }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/inBooleansProperty",
        ),
      },
      inDateTimesProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({
            kind: "DateTime" as const,
            in: [new Date("2018-04-09T10:00:00.000Z")],
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/inDateTimesProperty",
        ),
      },
      inIrisProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({
            kind: "NamedNode" as const,
            in: [
              dataFactory.namedNode("http://example.com/InPropertiesIri1"),
              dataFactory.namedNode("http://example.com/InPropertiesIri2"),
            ],
          }),
        }),
        identifier: dataFactory.namedNode("http://example.com/inIrisProperty"),
      },
      inNumbersProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({ kind: "Int" as const, in: [1, 2] }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/inNumbersProperty",
        ),
      },
      inStringsProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({ kind: "String" as const, in: ["text", "html"] }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/inStringsProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: InPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InPropertiesClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          InPropertiesClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: InPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("inPropertiesClass");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "inPropertiesClass")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "inPropertiesClass")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "inPropertiesClass")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "inPropertiesClass")
          }InBooleansProperty`,
        ),
        predicate:
          InPropertiesClass.$schema.properties.inBooleansProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "inPropertiesClass")
          }InDateTimesProperty`,
        ),
        predicate:
          InPropertiesClass.$schema.properties.inDateTimesProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "inPropertiesClass")
          }InIrisProperty`,
        ),
        predicate:
          InPropertiesClass.$schema.properties.inIrisProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "inPropertiesClass")
          }InNumbersProperty`,
        ),
        predicate:
          InPropertiesClass.$schema.properties.inNumbersProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "inPropertiesClass")
          }InStringsProperty`,
        ),
        predicate:
          InPropertiesClass.$schema.properties.inStringsProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: InPropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("inPropertiesClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable" ? subject.value : "inPropertiesClass")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: InPropertiesClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "inPropertiesClass")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: InPropertiesClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "inPropertiesClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<$BooleanFilter, $BooleanSchema>(
        $booleanSparqlWherePatterns,
      )({
        filter: parameters?.filter?.inBooleansProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "inPropertiesClass")
                  }InBooleansProperty`,
                ),
                predicate:
                  InPropertiesClass.$schema.properties.inBooleansProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema: InPropertiesClass.$schema.properties.inBooleansProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "inPropertiesClass")
          }InBooleansProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "inPropertiesClass")
        }InBooleansProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<$DateFilter, $DateSchema>(
        $dateSparqlWherePatterns,
      )({
        filter: parameters?.filter?.inDateTimesProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "inPropertiesClass")
                  }InDateTimesProperty`,
                ),
                predicate:
                  InPropertiesClass.$schema.properties.inDateTimesProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema: InPropertiesClass.$schema.properties.inDateTimesProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "inPropertiesClass")
          }InDateTimesProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "inPropertiesClass")
        }InDateTimesProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<$NamedNodeFilter, $NamedNodeSchema>(
        $namedNodeSparqlWherePatterns,
      )({
        filter: parameters?.filter?.inIrisProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "inPropertiesClass")
                  }InIrisProperty`,
                ),
                predicate:
                  InPropertiesClass.$schema.properties.inIrisProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema: InPropertiesClass.$schema.properties.inIrisProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "inPropertiesClass")
          }InIrisProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "inPropertiesClass")
        }InIrisProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<$NumberFilter, $NumberSchema>(
        $numberSparqlWherePatterns,
      )({
        filter: parameters?.filter?.inNumbersProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "inPropertiesClass")
                  }InNumbersProperty`,
                ),
                predicate:
                  InPropertiesClass.$schema.properties.inNumbersProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema: InPropertiesClass.$schema.properties.inNumbersProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "inPropertiesClass")
          }InNumbersProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "inPropertiesClass")
        }InNumbersProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<$StringFilter, $StringSchema>(
        $stringSparqlWherePatterns,
      )({
        filter: parameters?.filter?.inStringsProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "inPropertiesClass")
                  }InStringsProperty`,
                ),
                predicate:
                  InPropertiesClass.$schema.properties.inStringsProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema: InPropertiesClass.$schema.properties.inStringsProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "inPropertiesClass")
          }InStringsProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "inPropertiesClass")
        }InStringsProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Shape with sh:in constraining its identifier.
 */

export class InIdentifierClass {
  readonly $identifier: InIdentifierClass.$Identifier;

  readonly $type: "InIdentifierClass" = "InIdentifierClass" as const;

  readonly inIdentifierProperty: Maybe<string>;

  constructor(parameters: {
    readonly $identifier:
      | NamedNode<
          | "http://example.com/InIdentifierInstance1"
          | "http://example.com/InIdentifierInstance2"
        >
      | "http://example.com/InIdentifierInstance1"
      | "http://example.com/InIdentifierInstance2";
    readonly inIdentifierProperty?: Maybe<string> | string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this.$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this.$identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      this.$identifier = parameters.$identifier satisfies never;
    }
    if (Maybe.isMaybe(parameters.inIdentifierProperty)) {
      this.inIdentifierProperty = parameters.inIdentifierProperty;
    } else if (typeof parameters.inIdentifierProperty === "string") {
      this.inIdentifierProperty = Maybe.of(parameters.inIdentifierProperty);
    } else if (typeof parameters.inIdentifierProperty === "undefined") {
      this.inIdentifierProperty = Maybe.empty();
    } else {
      this.inIdentifierProperty =
        parameters.inIdentifierProperty satisfies never;
    }
  }

  $equals(other: InIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.inIdentifierProperty,
          other.inIdentifierProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inIdentifierProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    this.inIdentifierProperty.ifJust((value0) => {
      _hasher.update(value0);
    });
    return _hasher;
  }

  $toJson(): InIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
        inIdentifierProperty: this.inIdentifierProperty
          .map((item) => item)
          .extract(),
      } satisfies InIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource<NamedNode> {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/InIdentifierClass"),
        options?.graph,
      );
    }
    resource.add(
      InIdentifierClass.$schema.properties.inIdentifierProperty.identifier,
      this.inIdentifierProperty
        .toList()
        .flatMap((value) => [$literalFactory.string(value)]),
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace InIdentifierClass {
  export function $filter(
    filter: InIdentifierClass.$Filter,
    value: InIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.inIdentifierProperty !== "undefined" &&
      !$filterMaybe<string, $StringFilter>($filterString)(
        filter.inIdentifierProperty,
        value.inIdentifierProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
    readonly inIdentifierProperty?: $MaybeFilter<$StringFilter>;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/InIdentifierClass",
  );

  export type $Identifier = NamedNode<
    | "http://example.com/InIdentifierInstance1"
    | "http://example.com/InIdentifierInstance2"
  >;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): Either<
      Error,
      NamedNode<
        | "http://example.com/InIdentifierInstance1"
        | "http://example.com/InIdentifierInstance2"
      >
    > {
      return Either.encase(() =>
        Resource.Identifier.fromString({ dataFactory, identifier }),
      )
        .chain((identifier) =>
          identifier.termType === "NamedNode"
            ? Either.of(identifier)
            : Left(new Error("expected identifier to be NamedNode")),
        )
        .chain((identifier) => {
          switch (identifier.value) {
            case "http://example.com/InIdentifierInstance1":
              return Either.of(
                identifier as NamedNode<"http://example.com/InIdentifierInstance1">,
              );
            case "http://example.com/InIdentifierInstance2":
              return Either.of(
                identifier as NamedNode<"http://example.com/InIdentifierInstance2">,
              );
            default:
              return Left(
                new Error(
                  "expected NamedNode identifier to be one of http://example.com/InIdentifierInstance1 http://example.com/InIdentifierInstance2",
                ),
              );
          }
        }) as Either<
        Error,
        NamedNode<
          | "http://example.com/InIdentifierInstance1"
          | "http://example.com/InIdentifierInstance2"
        >
      >;
    } // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: NamedNode<
        | "http://example.com/InIdentifierInstance1"
        | "http://example.com/InIdentifierInstance2"
      >;
      inIdentifierProperty: Maybe<string>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const inIdentifierProperty = Maybe.fromNullable(
      $jsonObject["inIdentifierProperty"],
    );
    return Either.of({ $identifier, inIdentifierProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, InIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new InIdentifierClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "InIdentifierClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/inIdentifierProperty`,
          type: "Control",
        },
      ],
      label: "InIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.enum([
        "http://example.com/InIdentifierInstance1",
        "http://example.com/InIdentifierInstance2",
      ]),
      $type: z.literal("InIdentifierClass"),
      inIdentifierProperty: z.string().optional(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "InIdentifierClass";
    readonly inIdentifierProperty?: string;
  };

  export function isInIdentifierClass(
    object: $Object,
  ): object is InIdentifierClass {
    switch (object.$type) {
      case "InIdentifierClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, InIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return InIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new InIdentifierClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: NamedNode<
        | "http://example.com/InIdentifierInstance1"
        | "http://example.com/InIdentifierInstance2"
      >;
      inIdentifierProperty: Maybe<string>;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/InIdentifierClass":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  InIdentifierClass.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/InIdentifierClass)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      ($parameters.resource.identifier.value ===
        "http://example.com/InIdentifierInstance1" ||
      $parameters.resource.identifier.value ===
        "http://example.com/InIdentifierInstance2"
        ? Either.of<Error, InIdentifierClass.$Identifier>(
            $parameters.resource.identifier as InIdentifierClass.$Identifier,
          )
        : Left(
            new Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType:
                'NamedNode<"http://example.com/InIdentifierInstance1" | "http://example.com/InIdentifierInstance2">',
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.inIdentifierProperty.identifier,
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                InIdentifierClass.$schema.properties.inIdentifierProperty
                  .identifier,
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .map((values) =>
            values.length > 0
              ? values.map((value) => Maybe.of(value))
              : Resource.Values.fromValue<Maybe<string>>({
                  focusResource: $parameters.resource,
                  predicate:
                    InIdentifierClass.$schema.properties.inIdentifierProperty
                      .identifier,
                  value: Maybe.empty(),
                }),
          )
          .chain((values) => values.head())
          .map((inIdentifierProperty) => ({
            $identifier,
            inIdentifierProperty,
          })),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({
          kind: "NamedNode" as const,
          in: [
            dataFactory.namedNode("http://example.com/InIdentifierInstance1"),
            dataFactory.namedNode("http://example.com/InIdentifierInstance2"),
          ],
        }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["InIdentifierClass"],
        }),
      },
      inIdentifierProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({ kind: "String" as const }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/inIdentifierProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: InIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InIdentifierClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          InIdentifierClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: InIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("inIdentifierClass");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "inIdentifierClass")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "inIdentifierClass")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "inIdentifierClass")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "inIdentifierClass")
          }InIdentifierProperty`,
        ),
        predicate:
          InIdentifierClass.$schema.properties.inIdentifierProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: InIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("inIdentifierClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable" ? subject.value : "inIdentifierClass")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: InIdentifierClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "inIdentifierClass")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $namedNodeSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: InIdentifierClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "inIdentifierClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<$StringFilter, $StringSchema>(
        $stringSparqlWherePatterns,
      )({
        filter: parameters?.filter?.inIdentifierProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "inIdentifierClass")
                  }InIdentifierProperty`,
                ),
                predicate:
                  InIdentifierClass.$schema.properties.inIdentifierProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          InIdentifierClass.$schema.properties.inIdentifierProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "inIdentifierClass")
          }InIdentifierProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "inIdentifierClass")
        }InIdentifierProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Node shape for testing identifier type overriding: blank node or IRI identifier, abstract
 */

export abstract class IdentifierOverride1Class {
  protected _$identifier?: IdentifierOverride1ClassStatic.$Identifier;

  abstract readonly $type:
    | "IdentifierOverride3Class"
    | "IdentifierOverride4Class"
    | "IdentifierOverride5Class";

  readonly identifierOverrideProperty: string;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly identifierOverrideProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this.identifierOverrideProperty = parameters.identifierOverrideProperty;
  }

  get $identifier(): IdentifierOverride1ClassStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: IdentifierOverride1Class): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.identifierOverrideProperty,
          other.identifierOverrideProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "identifierOverrideProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.identifierOverrideProperty);
    return _hasher;
  }

  $toJson(): IdentifierOverride1ClassStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        identifierOverrideProperty: this.identifierOverrideProperty,
      } satisfies IdentifierOverride1ClassStatic.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    resource.add(
      IdentifierOverride1ClassStatic.$schema.properties
        .identifierOverrideProperty.identifier,
      [$literalFactory.string(this.identifierOverrideProperty)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IdentifierOverride1ClassStatic {
  export function $filter(
    filter: IdentifierOverride1ClassStatic.$Filter,
    value: IdentifierOverride1Class,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.identifierOverrideProperty !== "undefined" &&
      !$filterString(
        filter.identifierOverrideProperty,
        value.identifierOverrideProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly identifierOverrideProperty?: $StringFilter;
  };

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<
    z.ZodError,
    { $identifier: BlankNode | NamedNode; identifierOverrideProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const identifierOverrideProperty =
      $jsonObject["identifierOverrideProperty"];
    return Either.of({ $identifier, identifierOverrideProperty });
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "IdentifierOverride1Class" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/identifierOverrideProperty`,
          type: "Control",
        },
      ],
      label: "IdentifierOverride1Class",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.enum([
        "IdentifierOverride3Class",
        "IdentifierOverride4Class",
        "IdentifierOverride5Class",
      ]),
      identifierOverrideProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type:
      | "IdentifierOverride3Class"
      | "IdentifierOverride4Class"
      | "IdentifierOverride5Class";
    readonly identifierOverrideProperty: string;
  };

  export function isIdentifierOverride1Class(
    object: $Object,
  ): object is IdentifierOverride1Class {
    switch (object.$type) {
      case "IdentifierOverride3Class":
      case "IdentifierOverride4Class":
      case "IdentifierOverride5Class":
        return true;
      default:
        return false;
    }
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    { $identifier: BlankNode | NamedNode; identifierOverrideProperty: string }
  > {
    return Either.of<Error, IdentifierOverride1ClassStatic.$Identifier>(
      $parameters.resource
        .identifier as IdentifierOverride1ClassStatic.$Identifier,
    ).chain(($identifier) =>
      Either.of<Error, Resource.Values<Resource.TermValue>>(
        $parameters.resource.values(
          $schema.properties.identifierOverrideProperty.identifier,
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              IdentifierOverride1ClassStatic.$schema.properties
                .identifierOverrideProperty.identifier,
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((identifierOverrideProperty) => ({
          $identifier,
          identifierOverrideProperty,
        })),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          descendantValues: [
            "IdentifierOverride3Class",
            "IdentifierOverride4Class",
            "IdentifierOverride5Class",
          ],
          kind: "TypeDiscriminant" as const,
        }),
      },
      identifierOverrideProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/identifierOverrideProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IdentifierOverride1ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IdentifierOverride1ClassStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          IdentifierOverride1ClassStatic.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IdentifierOverride1ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IdentifierOverride1ClassStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride1Class");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "identifierOverride1Class")
          }IdentifierOverrideProperty`,
        ),
        predicate:
          IdentifierOverride1ClassStatic.$schema.properties
            .identifierOverrideProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IdentifierOverride1ClassStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride1Class");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            IdentifierOverride1ClassStatic.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "identifierOverride1Class"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.identifierOverrideProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "identifierOverride1Class")
                  }IdentifierOverrideProperty`,
                ),
                predicate:
                  IdentifierOverride1ClassStatic.$schema.properties
                    .identifierOverrideProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          IdentifierOverride1ClassStatic.$schema.properties.identifierOverrideProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "identifierOverride1Class")
          }IdentifierOverrideProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride1Class")
        }IdentifierOverrideProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Node shape for testing identifier type overriding: blank node or IRI identifier, abstract
 */

export abstract class IdentifierOverride2Class extends IdentifierOverride1Class {
  abstract override readonly $type:
    | "IdentifierOverride3Class"
    | "IdentifierOverride4Class"
    | "IdentifierOverride5Class";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: ConstructorParameters<typeof IdentifierOverride1Class>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): IdentifierOverride2ClassStatic.$Identifier {
    const identifier = super.$identifier;
    if (identifier.termType !== "NamedNode") {
      throw new Error(
        `expected identifier to be NamedNode, not ${identifier.termType}`,
      );
    }
    return identifier;
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      graph: options?.graph,
      resourceSet,
    });
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IdentifierOverride2ClassStatic {
  export function $filter(
    filter: IdentifierOverride2ClassStatic.$Filter,
    value: IdentifierOverride2Class,
  ): boolean {
    if (!IdentifierOverride1ClassStatic.$filter(filter, value)) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
  } & IdentifierOverride1ClassStatic.$Filter;

  export type $Identifier = NamedNode;

  export namespace $Identifier {
    export function fromString(identifier: string): Either<Error, NamedNode> {
      return Either.encase(() =>
        Resource.Identifier.fromString({ dataFactory, identifier }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? Either.of(identifier)
          : Left(new Error("expected identifier to be NamedNode")),
      ) as Either<Error, NamedNode>;
    } // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<
    z.ZodError,
    { $identifier: NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride1ClassStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    return IdentifierOverride1ClassStatic.$propertiesFromJson($jsonObject).map(
      ($super0) => ({
        ...$super0,
        $identifier,
      }),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [IdentifierOverride1ClassStatic.$jsonUiSchema({ scopePrefix })],
      label: "IdentifierOverride2Class",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IdentifierOverride1ClassStatic.$jsonZodSchema().merge(
      z.object({
        "@id": z.string().min(1),
        $type: z.enum([
          "IdentifierOverride3Class",
          "IdentifierOverride4Class",
          "IdentifierOverride5Class",
        ]),
      }),
    ) satisfies z.ZodType<$Json>;
  }

  export type $Json = IdentifierOverride1ClassStatic.$Json;

  export function isIdentifierOverride2Class(
    object: $Object,
  ): object is IdentifierOverride2Class {
    switch (object.$type) {
      case "IdentifierOverride3Class":
      case "IdentifierOverride4Class":
      case "IdentifierOverride5Class":
        return true;
      default:
        return false;
    }
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    { $identifier: NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride1ClassStatic.$propertiesFromRdf>
    >
  > {
    return IdentifierOverride1ClassStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      ($parameters.resource.identifier.termType === "NamedNode"
        ? Either.of<Error, IdentifierOverride2ClassStatic.$Identifier>(
            $parameters.resource.identifier,
          )
        : Left(
            new Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "NamedNode",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
      ).map(($identifier) => ({ ...$super0, $identifier })),
    );
  }

  export const $schema = {
    properties: { ...IdentifierOverride1ClassStatic.$schema.properties },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IdentifierOverride2ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IdentifierOverride2ClassStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          IdentifierOverride2ClassStatic.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IdentifierOverride2ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IdentifierOverride2ClassStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride2Class");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat(
      IdentifierOverride1ClassStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride2Class"),
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IdentifierOverride2ClassStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride2Class");
    patterns = patterns.concat(
      IdentifierOverride1ClassStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride2Class"),
      }),
    );
    return patterns;
  }
} /**
 * Node shape for testing identifier type overriding: IRI identifier, concrete
 */

export class IdentifierOverride3Class extends IdentifierOverride2Class {
  override readonly $type:
    | "IdentifierOverride3Class"
    | "IdentifierOverride4Class"
    | "IdentifierOverride5Class" = "IdentifierOverride3Class" as const;

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: NamedNode | string;
    } & ConstructorParameters<typeof IdentifierOverride2Class>[0],
  ) {
    super(parameters);
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      graph: options?.graph,
      resourceSet,
    });
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/IdentifierOverride3Class"),
        options?.graph,
      );
    }
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IdentifierOverride3ClassStatic {
  export function $filter(
    filter: IdentifierOverride3ClassStatic.$Filter,
    value: IdentifierOverride3Class,
  ): boolean {
    if (!IdentifierOverride2ClassStatic.$filter(filter, value)) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
  } & IdentifierOverride2ClassStatic.$Filter;

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/IdentifierOverride3Class",
  );

  export type $Identifier = NamedNode;

  export namespace $Identifier {
    export function fromString(identifier: string): Either<Error, NamedNode> {
      return Either.encase(() =>
        Resource.Identifier.fromString({ dataFactory, identifier }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? Either.of(identifier)
          : Left(new Error("expected identifier to be NamedNode")),
      ) as Either<Error, NamedNode>;
    } // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<
    z.ZodError,
    { $identifier: NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride2ClassStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    return IdentifierOverride2ClassStatic.$propertiesFromJson($jsonObject).map(
      ($super0) => ({
        ...$super0,
        $identifier,
      }),
    );
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, IdentifierOverride3Class> {
    return $propertiesFromJson(json).map(
      (properties) => new IdentifierOverride3Class(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [IdentifierOverride2ClassStatic.$jsonUiSchema({ scopePrefix })],
      label: "IdentifierOverride3Class",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IdentifierOverride2ClassStatic.$jsonZodSchema().merge(
      z.object({
        "@id": z.string().min(1),
        $type: z.enum([
          "IdentifierOverride3Class",
          "IdentifierOverride4Class",
          "IdentifierOverride5Class",
        ]),
      }),
    ) satisfies z.ZodType<$Json>;
  }

  export type $Json = IdentifierOverride2ClassStatic.$Json;

  export function isIdentifierOverride3Class(
    object: $Object,
  ): object is IdentifierOverride3Class {
    switch (object.$type) {
      case "IdentifierOverride4Class":
      case "IdentifierOverride5Class":
      case "IdentifierOverride3Class":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, IdentifierOverride3Class> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return IdentifierOverride3ClassStatic.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new IdentifierOverride3Class(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    { $identifier: NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride2ClassStatic.$propertiesFromRdf>
    >
  > {
    return IdentifierOverride2ClassStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/IdentifierOverride3Class":
                case "http://example.com/IdentifierOverride4Class":
                case "http://example.com/IdentifierOverride5Class":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  IdentifierOverride3ClassStatic.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/IdentifierOverride3Class)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        ($parameters.resource.identifier.termType === "NamedNode"
          ? Either.of<Error, IdentifierOverride3ClassStatic.$Identifier>(
              $parameters.resource.identifier,
            )
          : Left(
              new Resource.MistypedTermValueError({
                actualValue: $parameters.resource.identifier,
                expectedValueType: "NamedNode",
                focusResource: $parameters.resource,
                predicate: $RdfVocabularies.rdf.subject,
              }),
            )
        ).map(($identifier) => ({ ...$super0, $identifier })),
      ),
    );
  }

  export const $schema = {
    properties: { ...IdentifierOverride2ClassStatic.$schema.properties },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IdentifierOverride3ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IdentifierOverride3ClassStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          IdentifierOverride3ClassStatic.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IdentifierOverride3ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IdentifierOverride3ClassStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride3Class");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat(
      IdentifierOverride2ClassStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride3Class"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "identifierOverride3Class")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "identifierOverride3Class")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "identifierOverride3Class")
            }RdfClass`,
          ),
        },
      );
    }
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IdentifierOverride3ClassStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride3Class");
    patterns = patterns.concat(
      IdentifierOverride2ClassStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride3Class"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "identifierOverride3Class")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        {
          type: "values" as const,
          values: [
            IdentifierOverride3ClassStatic.$fromRdfType,
            IdentifierOverride4ClassStatic.$fromRdfType,
            IdentifierOverride5Class.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[
              `?${
                parameters?.variablePrefix ??
                (subject.termType === "Variable"
                  ? subject.value
                  : "identifierOverride3Class")
              }FromRdfType`
            ] = identifier as NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "identifierOverride3Class")
            }FromRdfType`,
          ),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "identifierOverride3Class")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    return patterns;
  }
} /**
 * Node shape for testing identifier type overriding: IRI identifier, concrete, UUIDv4 minting
 */

export class IdentifierOverride4Class extends IdentifierOverride3Class {
  protected readonly _$identifierPrefix?: string;

  override readonly $type:
    | "IdentifierOverride4Class"
    | "IdentifierOverride5Class" = "IdentifierOverride4Class" as const;

  constructor(
    parameters: {
      readonly $identifier?: NamedNode | string;
      readonly $identifierPrefix?: string;
    } & ConstructorParameters<typeof IdentifierOverride3Class>[0],
  ) {
    super(parameters);
    this._$identifierPrefix = parameters.$identifierPrefix;
  }

  override get $identifier(): IdentifierOverride4ClassStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${uuid.v4()}`,
      );
    }
    if (this._$identifier.termType !== "NamedNode") {
      throw new Error(
        `expected identifier to be NamedNode, not ${this._$identifier.termType}`,
      );
    }
    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      graph: options?.graph,
      resourceSet,
    });
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/IdentifierOverride4Class"),
        options?.graph,
      );
    }
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IdentifierOverride4ClassStatic {
  export function $filter(
    filter: IdentifierOverride4ClassStatic.$Filter,
    value: IdentifierOverride4Class,
  ): boolean {
    if (!IdentifierOverride3ClassStatic.$filter(filter, value)) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
  } & IdentifierOverride3ClassStatic.$Filter;

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/IdentifierOverride4Class",
  );

  export type $Identifier = NamedNode;

  export namespace $Identifier {
    export function fromString(identifier: string): Either<Error, NamedNode> {
      return Either.encase(() =>
        Resource.Identifier.fromString({ dataFactory, identifier }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? Either.of(identifier)
          : Left(new Error("expected identifier to be NamedNode")),
      ) as Either<Error, NamedNode>;
    } // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<
    z.ZodError,
    { $identifier: NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride3ClassStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    return IdentifierOverride3ClassStatic.$propertiesFromJson($jsonObject).map(
      ($super0) => ({
        ...$super0,
        $identifier,
      }),
    );
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, IdentifierOverride4Class> {
    return $propertiesFromJson(json).map(
      (properties) => new IdentifierOverride4Class(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [IdentifierOverride3ClassStatic.$jsonUiSchema({ scopePrefix })],
      label: "IdentifierOverride4Class",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IdentifierOverride3ClassStatic.$jsonZodSchema().merge(
      z.object({
        "@id": z.string().min(1),
        $type: z.enum(["IdentifierOverride4Class", "IdentifierOverride5Class"]),
      }),
    ) satisfies z.ZodType<$Json>;
  }

  export type $Json = IdentifierOverride3ClassStatic.$Json;

  export function isIdentifierOverride4Class(
    object: $Object,
  ): object is IdentifierOverride4Class {
    switch (object.$type) {
      case "IdentifierOverride5Class":
      case "IdentifierOverride4Class":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, IdentifierOverride4Class> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return IdentifierOverride4ClassStatic.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new IdentifierOverride4Class(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    { $identifier: NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride3ClassStatic.$propertiesFromRdf>
    >
  > {
    return IdentifierOverride3ClassStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/IdentifierOverride4Class":
                case "http://example.com/IdentifierOverride5Class":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  IdentifierOverride4ClassStatic.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/IdentifierOverride4Class)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        ($parameters.resource.identifier.termType === "NamedNode"
          ? Either.of<Error, IdentifierOverride4ClassStatic.$Identifier>(
              $parameters.resource.identifier,
            )
          : Left(
              new Resource.MistypedTermValueError({
                actualValue: $parameters.resource.identifier,
                expectedValueType: "NamedNode",
                focusResource: $parameters.resource,
                predicate: $RdfVocabularies.rdf.subject,
              }),
            )
        ).map(($identifier) => ({ ...$super0, $identifier })),
      ),
    );
  }

  export const $schema = {
    properties: { ...IdentifierOverride3ClassStatic.$schema.properties },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IdentifierOverride4ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IdentifierOverride4ClassStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          IdentifierOverride4ClassStatic.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IdentifierOverride4ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IdentifierOverride4ClassStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride4Class");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat(
      IdentifierOverride3ClassStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride4Class"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "identifierOverride4Class")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "identifierOverride4Class")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "identifierOverride4Class")
            }RdfClass`,
          ),
        },
      );
    }
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IdentifierOverride4ClassStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride4Class");
    patterns = patterns.concat(
      IdentifierOverride3ClassStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride4Class"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "identifierOverride4Class")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        {
          type: "values" as const,
          values: [
            IdentifierOverride4ClassStatic.$fromRdfType,
            IdentifierOverride5Class.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[
              `?${
                parameters?.variablePrefix ??
                (subject.termType === "Variable"
                  ? subject.value
                  : "identifierOverride4Class")
              }FromRdfType`
            ] = identifier as NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "identifierOverride4Class")
            }FromRdfType`,
          ),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "identifierOverride4Class")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    return patterns;
  }
} /**
 * Node shape for testing identifier type overriding: IRI identifier, concrete, SHA-256 minting
 */

export class IdentifierOverride5Class extends IdentifierOverride4Class {
  override readonly $type: "IdentifierOverride5Class" =
    "IdentifierOverride5Class" as const;

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: NamedNode | string;
      readonly $identifierPrefix?: string;
    } & ConstructorParameters<typeof IdentifierOverride4Class>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): IdentifierOverride5Class.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }
    if (this._$identifier.termType !== "NamedNode") {
      throw new Error(
        `expected identifier to be NamedNode, not ${this._$identifier.termType}`,
      );
    }
    return this._$identifier;
  }

  protected override get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      graph: options?.graph,
      resourceSet,
    });
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/IdentifierOverride5Class"),
        options?.graph,
      );
    }
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IdentifierOverride5Class {
  export function $filter(
    filter: IdentifierOverride5Class.$Filter,
    value: IdentifierOverride5Class,
  ): boolean {
    if (!IdentifierOverride4ClassStatic.$filter(filter, value)) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
  } & IdentifierOverride4ClassStatic.$Filter;

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/IdentifierOverride5Class",
  );

  export type $Identifier = NamedNode;

  export namespace $Identifier {
    export function fromString(identifier: string): Either<Error, NamedNode> {
      return Either.encase(() =>
        Resource.Identifier.fromString({ dataFactory, identifier }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? Either.of(identifier)
          : Left(new Error("expected identifier to be NamedNode")),
      ) as Either<Error, NamedNode>;
    } // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<
    z.ZodError,
    { $identifier: NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride4ClassStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    return IdentifierOverride4ClassStatic.$propertiesFromJson($jsonObject).map(
      ($super0) => ({
        ...$super0,
        $identifier,
      }),
    );
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, IdentifierOverride5Class> {
    return $propertiesFromJson(json).map(
      (properties) => new IdentifierOverride5Class(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [IdentifierOverride4ClassStatic.$jsonUiSchema({ scopePrefix })],
      label: "IdentifierOverride5Class",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IdentifierOverride4ClassStatic.$jsonZodSchema().merge(
      z.object({
        "@id": z.string().min(1),
        $type: z.literal("IdentifierOverride5Class"),
      }),
    ) satisfies z.ZodType<$Json>;
  }

  export type $Json = IdentifierOverride4ClassStatic.$Json;

  export function isIdentifierOverride5Class(
    object: $Object,
  ): object is IdentifierOverride5Class {
    switch (object.$type) {
      case "IdentifierOverride5Class":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, IdentifierOverride5Class> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return IdentifierOverride5Class.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new IdentifierOverride5Class(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    { $identifier: NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride4ClassStatic.$propertiesFromRdf>
    >
  > {
    return IdentifierOverride4ClassStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/IdentifierOverride5Class":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  IdentifierOverride5Class.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/IdentifierOverride5Class)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        ($parameters.resource.identifier.termType === "NamedNode"
          ? Either.of<Error, IdentifierOverride5Class.$Identifier>(
              $parameters.resource.identifier,
            )
          : Left(
              new Resource.MistypedTermValueError({
                actualValue: $parameters.resource.identifier,
                expectedValueType: "NamedNode",
                focusResource: $parameters.resource,
                predicate: $RdfVocabularies.rdf.subject,
              }),
            )
        ).map(($identifier) => ({ ...$super0, $identifier })),
      ),
    );
  }

  export const $schema = {
    properties: { ...IdentifierOverride4ClassStatic.$schema.properties },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IdentifierOverride5Class.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IdentifierOverride5Class.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          IdentifierOverride5Class.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IdentifierOverride5Class.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IdentifierOverride5Class.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride5Class");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat(
      IdentifierOverride4ClassStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride5Class"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "identifierOverride5Class")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "identifierOverride5Class")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "identifierOverride5Class")
            }RdfClass`,
          ),
        },
      );
    }
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IdentifierOverride5Class.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride5Class");
    patterns = patterns.concat(
      IdentifierOverride4ClassStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride5Class"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "identifierOverride5Class")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: IdentifierOverride5Class.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "identifierOverride5Class")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    return patterns;
  }
} /**
 * Shape with sh:hasValue properties.
 */

export class HasValuePropertiesClass {
  private _$identifier?: HasValuePropertiesClass.$Identifier;

  readonly $type: "HasValuePropertiesClass" =
    "HasValuePropertiesClass" as const;

  readonly hasIriValueProperty: NamedNode;

  readonly hasLiteralValueProperty: string;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly hasIriValueProperty: NamedNode | string;
    readonly hasLiteralValueProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    if (typeof parameters.hasIriValueProperty === "object") {
      this.hasIriValueProperty = parameters.hasIriValueProperty;
    } else if (typeof parameters.hasIriValueProperty === "string") {
      this.hasIriValueProperty = dataFactory.namedNode(
        parameters.hasIriValueProperty,
      );
    } else {
      this.hasIriValueProperty = parameters.hasIriValueProperty satisfies never;
    }
    this.hasLiteralValueProperty = parameters.hasLiteralValueProperty;
  }

  get $identifier(): HasValuePropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: HasValuePropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $booleanEquals(
          this.hasIriValueProperty,
          other.hasIriValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "hasIriValueProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.hasLiteralValueProperty,
          other.hasLiteralValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "hasLiteralValueProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.hasIriValueProperty.termType);
    _hasher.update(this.hasIriValueProperty.value);
    _hasher.update(this.hasLiteralValueProperty);
    return _hasher;
  }

  $toJson(): HasValuePropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        hasIriValueProperty: { "@id": this.hasIriValueProperty.value },
        hasLiteralValueProperty: this.hasLiteralValueProperty,
      } satisfies HasValuePropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    resource.add(
      HasValuePropertiesClass.$schema.properties.hasIriValueProperty.identifier,
      [this.hasIriValueProperty],
      options?.graph,
    );
    resource.add(
      HasValuePropertiesClass.$schema.properties.hasLiteralValueProperty
        .identifier,
      [$literalFactory.string(this.hasLiteralValueProperty)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace HasValuePropertiesClass {
  export function $filter(
    filter: HasValuePropertiesClass.$Filter,
    value: HasValuePropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.hasIriValueProperty !== "undefined" &&
      !$filterNamedNode(filter.hasIriValueProperty, value.hasIriValueProperty)
    ) {
      return false;
    }
    if (
      typeof filter.hasLiteralValueProperty !== "undefined" &&
      !$filterString(
        filter.hasLiteralValueProperty,
        value.hasLiteralValueProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly hasIriValueProperty?: $NamedNodeFilter;
    readonly hasLiteralValueProperty?: $StringFilter;
  };

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      hasIriValueProperty: NamedNode;
      hasLiteralValueProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const hasIriValueProperty = dataFactory.namedNode(
      $jsonObject["hasIriValueProperty"]["@id"],
    );
    const hasLiteralValueProperty = $jsonObject["hasLiteralValueProperty"];
    return Either.of({
      $identifier,
      hasIriValueProperty,
      hasLiteralValueProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, HasValuePropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new HasValuePropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "HasValuePropertiesClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/hasIriValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/hasLiteralValueProperty`,
          type: "Control",
        },
      ],
      label: "HasValuePropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("HasValuePropertiesClass"),
      hasIriValueProperty: z.object({ "@id": z.string().min(1) }),
      hasLiteralValueProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "HasValuePropertiesClass";
    readonly hasIriValueProperty: { readonly "@id": string };
    readonly hasLiteralValueProperty: string;
  };

  export function isHasValuePropertiesClass(
    object: $Object,
  ): object is HasValuePropertiesClass {
    switch (object.$type) {
      case "HasValuePropertiesClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, HasValuePropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return HasValuePropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new HasValuePropertiesClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      hasIriValueProperty: NamedNode;
      hasLiteralValueProperty: string;
    }
  > {
    return Either.of<Error, HasValuePropertiesClass.$Identifier>(
      $parameters.resource.identifier as HasValuePropertiesClass.$Identifier,
    ).chain(($identifier) =>
      Either.of<Error, Resource.Values<Resource.TermValue>>(
        $parameters.resource.values(
          $schema.properties.hasIriValueProperty.identifier,
          { unique: true },
        ),
      )
        .chain((values) =>
          Either.sequence(
            [
              dataFactory.namedNode(
                "http://example.com/HasValuePropertiesClassIri1",
              ),
            ].map((hasValue) =>
              values.find((value) => value.toTerm().equals(hasValue)),
            ),
          ).map(() => values),
        )
        .chain((values) => values.chainMap((value) => value.toIri()))
        .chain((values) => values.head())
        .chain((hasIriValueProperty) =>
          Either.of<Error, Resource.Values<Resource.TermValue>>(
            $parameters.resource.values(
              $schema.properties.hasLiteralValueProperty.identifier,
              { unique: true },
            ),
          )
            .chain((values) =>
              Either.sequence(
                [dataFactory.literal("test")].map((hasValue) =>
                  values.find((value) => value.toTerm().equals(hasValue)),
                ),
              ).map(() => values),
            )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  HasValuePropertiesClass.$schema.properties
                    .hasLiteralValueProperty.identifier,
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((hasLiteralValueProperty) => ({
              $identifier,
              hasIriValueProperty,
              hasLiteralValueProperty,
            })),
        ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["HasValuePropertiesClass"],
        }),
      },
      hasIriValueProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "NamedNode" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/hasIriValueProperty",
        ),
      },
      hasLiteralValueProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/hasLiteralValueProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: HasValuePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        HasValuePropertiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          HasValuePropertiesClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: HasValuePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      HasValuePropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("hasValuePropertiesClass");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "hasValuePropertiesClass")
          }HasIriValueProperty`,
        ),
        predicate:
          HasValuePropertiesClass.$schema.properties.hasIriValueProperty
            .identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "hasValuePropertiesClass")
          }HasLiteralValueProperty`,
        ),
        predicate:
          HasValuePropertiesClass.$schema.properties.hasLiteralValueProperty
            .identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: HasValuePropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("hasValuePropertiesClass");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: HasValuePropertiesClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "hasValuePropertiesClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $namedNodeSparqlWherePatterns({
        filter: parameters?.filter?.hasIriValueProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "hasValuePropertiesClass")
                  }HasIriValueProperty`,
                ),
                predicate:
                  HasValuePropertiesClass.$schema.properties.hasIriValueProperty
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          HasValuePropertiesClass.$schema.properties.hasIriValueProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "hasValuePropertiesClass")
          }HasIriValueProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "hasValuePropertiesClass")
        }HasIriValueProperty`,
      }),
    );
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.hasLiteralValueProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "hasValuePropertiesClass")
                  }HasLiteralValueProperty`,
                ),
                predicate:
                  HasValuePropertiesClass.$schema.properties
                    .hasLiteralValueProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          HasValuePropertiesClass.$schema.properties.hasLiteralValueProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "hasValuePropertiesClass")
          }HasLiteralValueProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "hasValuePropertiesClass")
        }HasLiteralValueProperty`,
      }),
    );
    return patterns;
  }
}
export class FlattenClassUnionMember3 {
  private _$identifier?: FlattenClassUnionMember3.$Identifier;

  readonly $type: "FlattenClassUnionMember3" =
    "FlattenClassUnionMember3" as const;

  readonly flattenClassUnionMember3Property: string;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly flattenClassUnionMember3Property: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this.flattenClassUnionMember3Property =
      parameters.flattenClassUnionMember3Property;
  }

  get $identifier(): FlattenClassUnionMember3.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: FlattenClassUnionMember3): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.flattenClassUnionMember3Property,
          other.flattenClassUnionMember3Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "flattenClassUnionMember3Property",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.flattenClassUnionMember3Property);
    return _hasher;
  }

  $toJson(): FlattenClassUnionMember3.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        flattenClassUnionMember3Property: this.flattenClassUnionMember3Property,
      } satisfies FlattenClassUnionMember3.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/FlattenClassUnionMember3"),
        options?.graph,
      );
    }
    resource.add(
      FlattenClassUnionMember3.$schema.properties
        .flattenClassUnionMember3Property.identifier,
      [$literalFactory.string(this.flattenClassUnionMember3Property)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace FlattenClassUnionMember3 {
  export function $filter(
    filter: FlattenClassUnionMember3.$Filter,
    value: FlattenClassUnionMember3,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.flattenClassUnionMember3Property !== "undefined" &&
      !$filterString(
        filter.flattenClassUnionMember3Property,
        value.flattenClassUnionMember3Property,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly flattenClassUnionMember3Property?: $StringFilter;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/FlattenClassUnionMember3",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      flattenClassUnionMember3Property: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const flattenClassUnionMember3Property =
      $jsonObject["flattenClassUnionMember3Property"];
    return Either.of({ $identifier, flattenClassUnionMember3Property });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, FlattenClassUnionMember3> {
    return $propertiesFromJson(json).map(
      (properties) => new FlattenClassUnionMember3(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "FlattenClassUnionMember3" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/flattenClassUnionMember3Property`,
          type: "Control",
        },
      ],
      label: "FlattenClassUnionMember3",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("FlattenClassUnionMember3"),
      flattenClassUnionMember3Property: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "FlattenClassUnionMember3";
    readonly flattenClassUnionMember3Property: string;
  };

  export function isFlattenClassUnionMember3(
    object: $Object,
  ): object is FlattenClassUnionMember3 {
    switch (object.$type) {
      case "FlattenClassUnionMember3":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, FlattenClassUnionMember3> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return FlattenClassUnionMember3.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new FlattenClassUnionMember3(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      flattenClassUnionMember3Property: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/FlattenClassUnionMember3":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  FlattenClassUnionMember3.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/FlattenClassUnionMember3)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, FlattenClassUnionMember3.$Identifier>(
        $parameters.resource.identifier as FlattenClassUnionMember3.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.flattenClassUnionMember3Property.identifier,
            {
              unique: true,
            },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                FlattenClassUnionMember3.$schema.properties
                  .flattenClassUnionMember3Property.identifier,
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((flattenClassUnionMember3Property) => ({
            $identifier,
            flattenClassUnionMember3Property,
          })),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["FlattenClassUnionMember3"],
        }),
      },
      flattenClassUnionMember3Property: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/flattenClassUnionMember3Property",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: FlattenClassUnionMember3.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        FlattenClassUnionMember3.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          FlattenClassUnionMember3.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: FlattenClassUnionMember3.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      FlattenClassUnionMember3.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("flattenClassUnionMember3");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "flattenClassUnionMember3")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "flattenClassUnionMember3")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "flattenClassUnionMember3")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "flattenClassUnionMember3")
          }FlattenClassUnionMember3Property`,
        ),
        predicate:
          FlattenClassUnionMember3.$schema.properties
            .flattenClassUnionMember3Property.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: FlattenClassUnionMember3.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("flattenClassUnionMember3");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "flattenClassUnionMember3")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: FlattenClassUnionMember3.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "flattenClassUnionMember3")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            FlattenClassUnionMember3.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "flattenClassUnionMember3"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.flattenClassUnionMember3Property,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "flattenClassUnionMember3")
                  }FlattenClassUnionMember3Property`,
                ),
                predicate:
                  FlattenClassUnionMember3.$schema.properties
                    .flattenClassUnionMember3Property.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          FlattenClassUnionMember3.$schema.properties.flattenClassUnionMember3Property.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "flattenClassUnionMember3")
          }FlattenClassUnionMember3Property`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "flattenClassUnionMember3")
        }FlattenClassUnionMember3Property`,
      }),
    );
    return patterns;
  }
} /**
 * Node shape that references the ExternClass in a property.
 */

export class ExternClassPropertyClass {
  private _$identifier?: ExternClassPropertyClass.$Identifier;

  readonly $type: "ExternClassPropertyClass" =
    "ExternClassPropertyClass" as const;

  readonly externClassProperty: Maybe<ExternClass>;

  constructor(parameters?: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly externClassProperty?: Maybe<ExternClass> | ExternClass;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }
    if (Maybe.isMaybe(parameters?.externClassProperty)) {
      this.externClassProperty = parameters?.externClassProperty;
    } else if (
      typeof parameters?.externClassProperty === "object" &&
      parameters?.externClassProperty instanceof ExternClass
    ) {
      this.externClassProperty = Maybe.of(parameters?.externClassProperty);
    } else if (typeof parameters?.externClassProperty === "undefined") {
      this.externClassProperty = Maybe.empty();
    } else {
      this.externClassProperty =
        parameters?.externClassProperty satisfies never;
    }
  }

  get $identifier(): ExternClassPropertyClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: ExternClassPropertyClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.externClassProperty,
          other.externClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "externClassProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    this.externClassProperty.ifJust((value0) => {
      value0.$hash(_hasher);
    });
    return _hasher;
  }

  $toJson(): ExternClassPropertyClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        externClassProperty: this.externClassProperty
          .map((item) => item.$toJson())
          .extract(),
      } satisfies ExternClassPropertyClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/ExternClassPropertyClass"),
        options?.graph,
      );
    }
    resource.add(
      ExternClassPropertyClass.$schema.properties.externClassProperty
        .identifier,
      this.externClassProperty
        .toList()
        .flatMap((value) => [
          value.$toRdf({ graph: options?.graph, resourceSet: resourceSet })
            .identifier,
        ]),
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ExternClassPropertyClass {
  export function $filter(
    filter: ExternClassPropertyClass.$Filter,
    value: ExternClassPropertyClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.externClassProperty !== "undefined" &&
      !$filterMaybe<ExternClass, ExternClass.$Filter>(ExternClass.$filter)(
        filter.externClassProperty,
        value.externClassProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly externClassProperty?: $MaybeFilter<ExternClass.$Filter>;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ExternClassPropertyClass",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      externClassProperty: Maybe<ExternClass>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const externClassProperty = Maybe.fromNullable(
      $jsonObject["externClassProperty"],
    ).map((item) => ExternClass.$fromJson(item).unsafeCoerce());
    return Either.of({ $identifier, externClassProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, ExternClassPropertyClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ExternClassPropertyClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ExternClassPropertyClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        ExternClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/externClassProperty`,
        }),
      ],
      label: "ExternClassPropertyClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("ExternClassPropertyClass"),
      externClassProperty: ExternClass.$jsonZodSchema().optional(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ExternClassPropertyClass";
    readonly externClassProperty?: ExternClass.$Json;
  };

  export function isExternClassPropertyClass(
    object: $Object,
  ): object is ExternClassPropertyClass {
    switch (object.$type) {
      case "ExternClassPropertyClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, ExternClassPropertyClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return ExternClassPropertyClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ExternClassPropertyClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      externClassProperty: Maybe<ExternClass>;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/ExternClassPropertyClass":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  ExternClassPropertyClass.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ExternClassPropertyClass)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, ExternClassPropertyClass.$Identifier>(
        $parameters.resource.identifier as ExternClassPropertyClass.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.externClassProperty.identifier,
            { unique: true },
          ),
        )
          .chain((values) =>
            values.chainMap((value) =>
              value.toResource().chain((resource) =>
                ExternClass.$fromRdf(resource, {
                  context: $parameters.context,
                  ignoreRdfType: true,
                  objectSet: $parameters.objectSet,
                  preferredLanguages: $parameters.preferredLanguages,
                }),
              ),
            ),
          )
          .map((values) =>
            values.length > 0
              ? values.map((value) => Maybe.of(value))
              : Resource.Values.fromValue<Maybe<ExternClass>>({
                  focusResource: $parameters.resource,
                  predicate:
                    ExternClassPropertyClass.$schema.properties
                      .externClassProperty.identifier,
                  value: Maybe.empty(),
                }),
          )
          .chain((values) => values.head())
          .map((externClassProperty) => ({ $identifier, externClassProperty })),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["ExternClassPropertyClass"],
        }),
      },
      externClassProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ExternClass.$schema,
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/externClassProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ExternClassPropertyClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ExternClassPropertyClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          ExternClassPropertyClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ExternClassPropertyClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ExternClassPropertyClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("externClassPropertyClass");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "externClassPropertyClass")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "externClassPropertyClass")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "externClassPropertyClass")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "externClassPropertyClass")
          }ExternClassProperty`,
        ),
        predicate:
          ExternClassPropertyClass.$schema.properties.externClassProperty
            .identifier,
        subject: subject,
      },
      ...ExternClass.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "externClassPropertyClass")
          }ExternClassProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "externClassPropertyClass")
        }ExternClassProperty`,
      }),
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ExternClassPropertyClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("externClassPropertyClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "externClassPropertyClass")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ExternClassPropertyClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "externClassPropertyClass")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            ExternClassPropertyClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "externClassPropertyClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<
        ExternClass.$Filter,
        typeof ExternClass.$schema
      >(
        ({
          ignoreRdfType,
          propertyPatterns,
          valueVariable,
          ...otherParameters
        }: $SparqlWherePatternsFunctionParameters<
          ExternClass.$Filter,
          typeof ExternClass.$schema
        >) =>
          (propertyPatterns as readonly $SparqlPattern[]).concat(
            ExternClass.$sparqlWherePatterns({
              ignoreRdfType: ignoreRdfType ?? true,
              subject: valueVariable,
              ...otherParameters,
            }),
          ),
      )({
        filter: parameters?.filter?.externClassProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "externClassPropertyClass")
                  }ExternClassProperty`,
                ),
                predicate:
                  ExternClassPropertyClass.$schema.properties
                    .externClassProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ExternClassPropertyClass.$schema.properties.externClassProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "externClassPropertyClass")
          }ExternClassProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "externClassPropertyClass")
        }ExternClassProperty`,
      }),
    );
    return patterns;
  }
} /**
 * An abstract base class that will be inherited by the extern object type, showing how to mix generated and hand-written code.
 */

export abstract class AbstractBaseClassForExternClass {
  protected _$identifier?: AbstractBaseClassForExternClassStatic.$Identifier;

  abstract readonly $type: "ExternClass";

  readonly abstractBaseClassForExternClassProperty: string;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly abstractBaseClassForExternClassProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this.abstractBaseClassForExternClassProperty =
      parameters.abstractBaseClassForExternClassProperty;
  }

  get $identifier(): AbstractBaseClassForExternClassStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: AbstractBaseClassForExternClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.abstractBaseClassForExternClassProperty,
          other.abstractBaseClassForExternClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "abstractBaseClassForExternClassProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.abstractBaseClassForExternClassProperty);
    return _hasher;
  }

  $toJson(): AbstractBaseClassForExternClassStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        abstractBaseClassForExternClassProperty:
          this.abstractBaseClassForExternClassProperty,
      } satisfies AbstractBaseClassForExternClassStatic.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    resource.add(
      AbstractBaseClassForExternClassStatic.$schema.properties
        .abstractBaseClassForExternClassProperty.identifier,
      [$literalFactory.string(this.abstractBaseClassForExternClassProperty)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace AbstractBaseClassForExternClassStatic {
  export function $filter(
    filter: AbstractBaseClassForExternClassStatic.$Filter,
    value: AbstractBaseClassForExternClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.abstractBaseClassForExternClassProperty !== "undefined" &&
      !$filterString(
        filter.abstractBaseClassForExternClassProperty,
        value.abstractBaseClassForExternClassProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly abstractBaseClassForExternClassProperty?: $StringFilter;
  };

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      abstractBaseClassForExternClassProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const abstractBaseClassForExternClassProperty =
      $jsonObject["abstractBaseClassForExternClassProperty"];
    return Either.of({ $identifier, abstractBaseClassForExternClassProperty });
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "AbstractBaseClassForExternClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/abstractBaseClassForExternClassProperty`,
          type: "Control",
        },
      ],
      label: "AbstractBaseClassForExternClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("ExternClass"),
      abstractBaseClassForExternClassProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ExternClass";
    readonly abstractBaseClassForExternClassProperty: string;
  };

  export function isAbstractBaseClassForExternClass(
    object: $Object,
  ): object is AbstractBaseClassForExternClass {
    switch (object.$type) {
      case "ExternClass":
        return true;
      default:
        return false;
    }
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      abstractBaseClassForExternClassProperty: string;
    }
  > {
    return Either.of<Error, AbstractBaseClassForExternClassStatic.$Identifier>(
      $parameters.resource
        .identifier as AbstractBaseClassForExternClassStatic.$Identifier,
    ).chain(($identifier) =>
      Either.of<Error, Resource.Values<Resource.TermValue>>(
        $parameters.resource.values(
          $schema.properties.abstractBaseClassForExternClassProperty.identifier,
          {
            unique: true,
          },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              AbstractBaseClassForExternClassStatic.$schema.properties
                .abstractBaseClassForExternClassProperty.identifier,
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((abstractBaseClassForExternClassProperty) => ({
          $identifier,
          abstractBaseClassForExternClassProperty,
        })),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          descendantValues: ["ExternClass"],
          kind: "TypeDiscriminant" as const,
        }),
      },
      abstractBaseClassForExternClassProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/abstractBaseClassForExternClassProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: AbstractBaseClassForExternClassStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        AbstractBaseClassForExternClassStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          AbstractBaseClassForExternClassStatic.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: AbstractBaseClassForExternClassStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      AbstractBaseClassForExternClassStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassForExternClass");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "abstractBaseClassForExternClass")
          }AbstractBaseClassForExternClassProperty`,
        ),
        predicate:
          AbstractBaseClassForExternClassStatic.$schema.properties
            .abstractBaseClassForExternClassProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: AbstractBaseClassForExternClassStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassForExternClass");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            AbstractBaseClassForExternClassStatic.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "abstractBaseClassForExternClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.abstractBaseClassForExternClassProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "abstractBaseClassForExternClass")
                  }AbstractBaseClassForExternClassProperty`,
                ),
                predicate:
                  AbstractBaseClassForExternClassStatic.$schema.properties
                    .abstractBaseClassForExternClassProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          AbstractBaseClassForExternClassStatic.$schema.properties.abstractBaseClassForExternClassProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "abstractBaseClassForExternClass")
          }AbstractBaseClassForExternClassProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "abstractBaseClassForExternClass")
        }AbstractBaseClassForExternClassProperty`,
      }),
    );
    return patterns;
  }
}

import { ExternClass } from "./ExternClass.js"; /**
 * Shape with custom rdf:type's.
 *
 * The shaclmate:rdfType is expected on deserialization and added on serialization.
 */

export class ExplicitRdfTypeClass {
  private _$identifier?: ExplicitRdfTypeClass.$Identifier;

  readonly $type: "ExplicitRdfTypeClass" = "ExplicitRdfTypeClass" as const;

  readonly explicitRdfTypeProperty: string;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly explicitRdfTypeProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this.explicitRdfTypeProperty = parameters.explicitRdfTypeProperty;
  }

  get $identifier(): ExplicitRdfTypeClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: ExplicitRdfTypeClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.explicitRdfTypeProperty,
          other.explicitRdfTypeProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "explicitRdfTypeProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.explicitRdfTypeProperty);
    return _hasher;
  }

  $toJson(): ExplicitRdfTypeClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        explicitRdfTypeProperty: this.explicitRdfTypeProperty,
      } satisfies ExplicitRdfTypeClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/RdfType"),
        options?.graph,
      );
    }
    resource.add(
      ExplicitRdfTypeClass.$schema.properties.explicitRdfTypeProperty
        .identifier,
      [$literalFactory.string(this.explicitRdfTypeProperty)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ExplicitRdfTypeClass {
  export function $filter(
    filter: ExplicitRdfTypeClass.$Filter,
    value: ExplicitRdfTypeClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.explicitRdfTypeProperty !== "undefined" &&
      !$filterString(
        filter.explicitRdfTypeProperty,
        value.explicitRdfTypeProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly explicitRdfTypeProperty?: $StringFilter;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/RdfType",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<
    z.ZodError,
    { $identifier: BlankNode | NamedNode; explicitRdfTypeProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const explicitRdfTypeProperty = $jsonObject["explicitRdfTypeProperty"];
    return Either.of({ $identifier, explicitRdfTypeProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, ExplicitRdfTypeClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ExplicitRdfTypeClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ExplicitRdfTypeClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/explicitRdfTypeProperty`,
          type: "Control",
        },
      ],
      label: "ExplicitRdfTypeClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("ExplicitRdfTypeClass"),
      explicitRdfTypeProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ExplicitRdfTypeClass";
    readonly explicitRdfTypeProperty: string;
  };

  export function isExplicitRdfTypeClass(
    object: $Object,
  ): object is ExplicitRdfTypeClass {
    switch (object.$type) {
      case "ExplicitRdfTypeClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, ExplicitRdfTypeClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return ExplicitRdfTypeClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ExplicitRdfTypeClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    { $identifier: BlankNode | NamedNode; explicitRdfTypeProperty: string }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/RdfType":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  ExplicitRdfTypeClass.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/RdfType)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, ExplicitRdfTypeClass.$Identifier>(
        $parameters.resource.identifier as ExplicitRdfTypeClass.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.explicitRdfTypeProperty.identifier,
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                ExplicitRdfTypeClass.$schema.properties.explicitRdfTypeProperty
                  .identifier,
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((explicitRdfTypeProperty) => ({
            $identifier,
            explicitRdfTypeProperty,
          })),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["ExplicitRdfTypeClass"],
        }),
      },
      explicitRdfTypeProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/explicitRdfTypeProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ExplicitRdfTypeClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ExplicitRdfTypeClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          ExplicitRdfTypeClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ExplicitRdfTypeClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ExplicitRdfTypeClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("explicitRdfTypeClass");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "explicitRdfTypeClass")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "explicitRdfTypeClass")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "explicitRdfTypeClass")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "explicitRdfTypeClass")
          }ExplicitRdfTypeProperty`,
        ),
        predicate:
          ExplicitRdfTypeClass.$schema.properties.explicitRdfTypeProperty
            .identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ExplicitRdfTypeClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("explicitRdfTypeClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "explicitRdfTypeClass")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ExplicitRdfTypeClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "explicitRdfTypeClass")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: ExplicitRdfTypeClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "explicitRdfTypeClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.explicitRdfTypeProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "explicitRdfTypeClass")
                  }ExplicitRdfTypeProperty`,
                ),
                predicate:
                  ExplicitRdfTypeClass.$schema.properties
                    .explicitRdfTypeProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ExplicitRdfTypeClass.$schema.properties.explicitRdfTypeProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "explicitRdfTypeClass")
          }ExplicitRdfTypeProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "explicitRdfTypeClass")
        }ExplicitRdfTypeProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Shape with custom rdf:type's.
 *
 * The shaclmate:fromRdfType is expected on deserialization.
 * shaclmate:toRdfType's are added an serialization.
 */

export class ExplicitFromToRdfTypesClass {
  private _$identifier?: ExplicitFromToRdfTypesClass.$Identifier;

  readonly $type: "ExplicitFromToRdfTypesClass" =
    "ExplicitFromToRdfTypesClass" as const;

  readonly explicitFromToRdfTypesProperty: string;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly explicitFromToRdfTypesProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this.explicitFromToRdfTypesProperty =
      parameters.explicitFromToRdfTypesProperty;
  }

  get $identifier(): ExplicitFromToRdfTypesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: ExplicitFromToRdfTypesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.explicitFromToRdfTypesProperty,
          other.explicitFromToRdfTypesProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "explicitFromToRdfTypesProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.explicitFromToRdfTypesProperty);
    return _hasher;
  }

  $toJson(): ExplicitFromToRdfTypesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        explicitFromToRdfTypesProperty: this.explicitFromToRdfTypesProperty,
      } satisfies ExplicitFromToRdfTypesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/ToRdfType"),
        options?.graph,
      );
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/FromRdfType"),
        options?.graph,
      );
    }
    resource.add(
      ExplicitFromToRdfTypesClass.$schema.properties
        .explicitFromToRdfTypesProperty.identifier,
      [$literalFactory.string(this.explicitFromToRdfTypesProperty)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ExplicitFromToRdfTypesClass {
  export function $filter(
    filter: ExplicitFromToRdfTypesClass.$Filter,
    value: ExplicitFromToRdfTypesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.explicitFromToRdfTypesProperty !== "undefined" &&
      !$filterString(
        filter.explicitFromToRdfTypesProperty,
        value.explicitFromToRdfTypesProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly explicitFromToRdfTypesProperty?: $StringFilter;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/FromRdfType",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      explicitFromToRdfTypesProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const explicitFromToRdfTypesProperty =
      $jsonObject["explicitFromToRdfTypesProperty"];
    return Either.of({ $identifier, explicitFromToRdfTypesProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, ExplicitFromToRdfTypesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ExplicitFromToRdfTypesClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ExplicitFromToRdfTypesClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/explicitFromToRdfTypesProperty`,
          type: "Control",
        },
      ],
      label: "ExplicitFromToRdfTypesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("ExplicitFromToRdfTypesClass"),
      explicitFromToRdfTypesProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ExplicitFromToRdfTypesClass";
    readonly explicitFromToRdfTypesProperty: string;
  };

  export function isExplicitFromToRdfTypesClass(
    object: $Object,
  ): object is ExplicitFromToRdfTypesClass {
    switch (object.$type) {
      case "ExplicitFromToRdfTypesClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, ExplicitFromToRdfTypesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return ExplicitFromToRdfTypesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ExplicitFromToRdfTypesClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      explicitFromToRdfTypesProperty: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/FromRdfType":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  ExplicitFromToRdfTypesClass.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/FromRdfType)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, ExplicitFromToRdfTypesClass.$Identifier>(
        $parameters.resource
          .identifier as ExplicitFromToRdfTypesClass.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.explicitFromToRdfTypesProperty.identifier,
            { unique: true },
          ),
        )
          .chain((values) =>
            $fromRdfPreferredLanguages({
              focusResource: $parameters.resource,
              predicate:
                ExplicitFromToRdfTypesClass.$schema.properties
                  .explicitFromToRdfTypesProperty.identifier,
              preferredLanguages: $parameters.preferredLanguages,
              values,
            }),
          )
          .chain((values) => values.chainMap((value) => value.toString()))
          .chain((values) => values.head())
          .map((explicitFromToRdfTypesProperty) => ({
            $identifier,
            explicitFromToRdfTypesProperty,
          })),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["ExplicitFromToRdfTypesClass"],
        }),
      },
      explicitFromToRdfTypesProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/explicitFromToRdfTypesProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ExplicitFromToRdfTypesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ExplicitFromToRdfTypesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          ExplicitFromToRdfTypesClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ExplicitFromToRdfTypesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ExplicitFromToRdfTypesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("explicitFromToRdfTypesClass");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "explicitFromToRdfTypesClass")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "explicitFromToRdfTypesClass")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "explicitFromToRdfTypesClass")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "explicitFromToRdfTypesClass")
          }ExplicitFromToRdfTypesProperty`,
        ),
        predicate:
          ExplicitFromToRdfTypesClass.$schema.properties
            .explicitFromToRdfTypesProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ExplicitFromToRdfTypesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("explicitFromToRdfTypesClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "explicitFromToRdfTypesClass")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ExplicitFromToRdfTypesClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "explicitFromToRdfTypesClass")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            ExplicitFromToRdfTypesClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "explicitFromToRdfTypesClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.explicitFromToRdfTypesProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "explicitFromToRdfTypesClass")
                  }ExplicitFromToRdfTypesProperty`,
                ),
                predicate:
                  ExplicitFromToRdfTypesClass.$schema.properties
                    .explicitFromToRdfTypesProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ExplicitFromToRdfTypesClass.$schema.properties.explicitFromToRdfTypesProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "explicitFromToRdfTypesClass")
          }ExplicitFromToRdfTypesProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "explicitFromToRdfTypesClass")
        }ExplicitFromToRdfTypesProperty`,
      }),
    );
    return patterns;
  }
}
export class DirectRecursiveClass {
  private _$identifier?: DirectRecursiveClass.$Identifier;

  readonly $type: "DirectRecursiveClass" = "DirectRecursiveClass" as const;

  readonly directRecursiveProperty: Maybe<DirectRecursiveClass>;

  constructor(parameters?: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly directRecursiveProperty?:
      | Maybe<DirectRecursiveClass>
      | DirectRecursiveClass;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }
    if (Maybe.isMaybe(parameters?.directRecursiveProperty)) {
      this.directRecursiveProperty = parameters?.directRecursiveProperty;
    } else if (
      typeof parameters?.directRecursiveProperty === "object" &&
      parameters?.directRecursiveProperty instanceof DirectRecursiveClass
    ) {
      this.directRecursiveProperty = Maybe.of(
        parameters?.directRecursiveProperty,
      );
    } else if (typeof parameters?.directRecursiveProperty === "undefined") {
      this.directRecursiveProperty = Maybe.empty();
    } else {
      this.directRecursiveProperty =
        parameters?.directRecursiveProperty satisfies never;
    }
  }

  get $identifier(): DirectRecursiveClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: DirectRecursiveClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.directRecursiveProperty,
          other.directRecursiveProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "directRecursiveProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    this.directRecursiveProperty.ifJust((value0) => {
      value0.$hash(_hasher);
    });
    return _hasher;
  }

  $toJson(): DirectRecursiveClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        directRecursiveProperty: this.directRecursiveProperty
          .map((item) => item.$toJson())
          .extract(),
      } satisfies DirectRecursiveClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/DirectRecursiveClass"),
        options?.graph,
      );
    }
    resource.add(
      DirectRecursiveClass.$schema.properties.directRecursiveProperty
        .identifier,
      this.directRecursiveProperty
        .toList()
        .flatMap((value) => [
          value.$toRdf({ graph: options?.graph, resourceSet: resourceSet })
            .identifier,
        ]),
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace DirectRecursiveClass {
  export function $filter(
    filter: DirectRecursiveClass.$Filter,
    value: DirectRecursiveClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.directRecursiveProperty !== "undefined" &&
      !$filterMaybe<DirectRecursiveClass, DirectRecursiveClass.$Filter>(
        DirectRecursiveClass.$filter,
      )(filter.directRecursiveProperty, value.directRecursiveProperty)
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly directRecursiveProperty?: $MaybeFilter<DirectRecursiveClass.$Filter>;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/DirectRecursiveClass",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      directRecursiveProperty: Maybe<DirectRecursiveClass>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const directRecursiveProperty = Maybe.fromNullable(
      $jsonObject["directRecursiveProperty"],
    ).map((item) => DirectRecursiveClass.$fromJson(item).unsafeCoerce());
    return Either.of({ $identifier, directRecursiveProperty });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, DirectRecursiveClass> {
    return $propertiesFromJson(json).map(
      (properties) => new DirectRecursiveClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "DirectRecursiveClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        DirectRecursiveClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/directRecursiveProperty`,
        }),
      ],
      label: "DirectRecursiveClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("DirectRecursiveClass"),
      directRecursiveProperty: z
        .lazy(
          (): z.ZodType<DirectRecursiveClass.$Json> =>
            DirectRecursiveClass.$jsonZodSchema(),
        )
        .optional(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "DirectRecursiveClass";
    readonly directRecursiveProperty?: DirectRecursiveClass.$Json;
  };

  export function isDirectRecursiveClass(
    object: $Object,
  ): object is DirectRecursiveClass {
    switch (object.$type) {
      case "DirectRecursiveClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, DirectRecursiveClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return DirectRecursiveClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new DirectRecursiveClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      directRecursiveProperty: Maybe<DirectRecursiveClass>;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/DirectRecursiveClass":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  DirectRecursiveClass.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/DirectRecursiveClass)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, DirectRecursiveClass.$Identifier>(
        $parameters.resource.identifier as DirectRecursiveClass.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.directRecursiveProperty.identifier,
            { unique: true },
          ),
        )
          .chain((values) =>
            values.chainMap((value) =>
              value.toResource().chain((resource) =>
                DirectRecursiveClass.$fromRdf(resource, {
                  context: $parameters.context,
                  ignoreRdfType: true,
                  objectSet: $parameters.objectSet,
                  preferredLanguages: $parameters.preferredLanguages,
                }),
              ),
            ),
          )
          .map((values) =>
            values.length > 0
              ? values.map((value) => Maybe.of(value))
              : Resource.Values.fromValue<Maybe<DirectRecursiveClass>>({
                  focusResource: $parameters.resource,
                  predicate:
                    DirectRecursiveClass.$schema.properties
                      .directRecursiveProperty.identifier,
                  value: Maybe.empty(),
                }),
          )
          .chain((values) => values.head())
          .map((directRecursiveProperty) => ({
            $identifier,
            directRecursiveProperty,
          })),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["DirectRecursiveClass"],
        }),
      },
      directRecursiveProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => DirectRecursiveClass.$schema,
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/directRecursiveProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: DirectRecursiveClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        DirectRecursiveClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          DirectRecursiveClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: DirectRecursiveClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      DirectRecursiveClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("directRecursiveClass");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "directRecursiveClass")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "directRecursiveClass")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "directRecursiveClass")
            }RdfClass`,
          ),
        },
      );
    }
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: DirectRecursiveClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("directRecursiveClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "directRecursiveClass")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: DirectRecursiveClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "directRecursiveClass")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: DirectRecursiveClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "directRecursiveClass"),
        }),
      );
    }
    return patterns;
  }
} /**
 * Shape with sh:defaultValue properties.
 */

export class DefaultValuePropertiesClass {
  private _$identifier?: DefaultValuePropertiesClass.$Identifier;

  protected readonly _$identifierPrefix?: string;

  readonly $type: "DefaultValuePropertiesClass" =
    "DefaultValuePropertiesClass" as const;

  readonly dateDefaultValueProperty: Date;

  readonly dateTimeDefaultValueProperty: Date;

  readonly falseBooleanDefaultValueProperty: boolean;

  readonly numberDefaultValueProperty: number;

  readonly stringDefaultValueProperty: string;

  readonly trueBooleanDefaultValueProperty: boolean;

  constructor(parameters?: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly $identifierPrefix?: string;
    readonly dateDefaultValueProperty?: Date;
    readonly dateTimeDefaultValueProperty?: Date;
    readonly falseBooleanDefaultValueProperty?: boolean;
    readonly numberDefaultValueProperty?: number;
    readonly stringDefaultValueProperty?: string;
    readonly trueBooleanDefaultValueProperty?: boolean;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }
    this._$identifierPrefix = parameters?.$identifierPrefix;
    if (
      typeof parameters?.dateDefaultValueProperty === "object" &&
      parameters?.dateDefaultValueProperty instanceof Date
    ) {
      this.dateDefaultValueProperty = parameters?.dateDefaultValueProperty;
    } else if (typeof parameters?.dateDefaultValueProperty === "undefined") {
      this.dateDefaultValueProperty = new Date("2018-04-09T00:00:00.000Z");
    } else {
      this.dateDefaultValueProperty =
        parameters?.dateDefaultValueProperty satisfies never;
    }
    if (
      typeof parameters?.dateTimeDefaultValueProperty === "object" &&
      parameters?.dateTimeDefaultValueProperty instanceof Date
    ) {
      this.dateTimeDefaultValueProperty =
        parameters?.dateTimeDefaultValueProperty;
    } else if (
      typeof parameters?.dateTimeDefaultValueProperty === "undefined"
    ) {
      this.dateTimeDefaultValueProperty = new Date("2018-04-09T10:00:00.000Z");
    } else {
      this.dateTimeDefaultValueProperty =
        parameters?.dateTimeDefaultValueProperty satisfies never;
    }
    if (typeof parameters?.falseBooleanDefaultValueProperty === "boolean") {
      this.falseBooleanDefaultValueProperty =
        parameters?.falseBooleanDefaultValueProperty;
    } else if (
      typeof parameters?.falseBooleanDefaultValueProperty === "undefined"
    ) {
      this.falseBooleanDefaultValueProperty = false;
    } else {
      this.falseBooleanDefaultValueProperty =
        parameters?.falseBooleanDefaultValueProperty satisfies never;
    }
    if (typeof parameters?.numberDefaultValueProperty === "number") {
      this.numberDefaultValueProperty = parameters?.numberDefaultValueProperty;
    } else if (typeof parameters?.numberDefaultValueProperty === "undefined") {
      this.numberDefaultValueProperty = 0;
    } else {
      this.numberDefaultValueProperty =
        parameters?.numberDefaultValueProperty satisfies never;
    }
    if (typeof parameters?.stringDefaultValueProperty === "string") {
      this.stringDefaultValueProperty = parameters?.stringDefaultValueProperty;
    } else if (typeof parameters?.stringDefaultValueProperty === "undefined") {
      this.stringDefaultValueProperty = "";
    } else {
      this.stringDefaultValueProperty =
        parameters?.stringDefaultValueProperty satisfies never;
    }
    if (typeof parameters?.trueBooleanDefaultValueProperty === "boolean") {
      this.trueBooleanDefaultValueProperty =
        parameters?.trueBooleanDefaultValueProperty;
    } else if (
      typeof parameters?.trueBooleanDefaultValueProperty === "undefined"
    ) {
      this.trueBooleanDefaultValueProperty = true;
    } else {
      this.trueBooleanDefaultValueProperty =
        parameters?.trueBooleanDefaultValueProperty satisfies never;
    }
  }

  get $identifier(): DefaultValuePropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }
    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  $equals(other: DefaultValuePropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$identifierPrefix, other.$identifierPrefix).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$identifierPrefix",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $dateEquals(
          this.dateDefaultValueProperty,
          other.dateDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "dateDefaultValueProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        $dateEquals(
          this.dateTimeDefaultValueProperty,
          other.dateTimeDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "dateTimeDefaultValueProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.falseBooleanDefaultValueProperty,
          other.falseBooleanDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "falseBooleanDefaultValueProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.numberDefaultValueProperty,
          other.numberDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "numberDefaultValueProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.stringDefaultValueProperty,
          other.stringDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "stringDefaultValueProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.trueBooleanDefaultValueProperty,
          other.trueBooleanDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "trueBooleanDefaultValueProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.dateDefaultValueProperty.toISOString());
    _hasher.update(this.dateTimeDefaultValueProperty.toISOString());
    _hasher.update(this.falseBooleanDefaultValueProperty.toString());
    _hasher.update(this.numberDefaultValueProperty.toString());
    _hasher.update(this.stringDefaultValueProperty);
    _hasher.update(this.trueBooleanDefaultValueProperty.toString());
    return _hasher;
  }

  $toJson(): DefaultValuePropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        dateDefaultValueProperty: this.dateDefaultValueProperty
          .toISOString()
          .replace(/T.*$/, ""),
        dateTimeDefaultValueProperty:
          this.dateTimeDefaultValueProperty.toISOString(),
        falseBooleanDefaultValueProperty: this.falseBooleanDefaultValueProperty,
        numberDefaultValueProperty: this.numberDefaultValueProperty,
        stringDefaultValueProperty: this.stringDefaultValueProperty,
        trueBooleanDefaultValueProperty: this.trueBooleanDefaultValueProperty,
      } satisfies DefaultValuePropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/DefaultValuePropertiesClass"),
        options?.graph,
      );
    }
    resource.add(
      DefaultValuePropertiesClass.$schema.properties.dateDefaultValueProperty
        .identifier,
      $dateEquals(
        this.dateDefaultValueProperty,
        new Date("2018-04-09T00:00:00.000Z"),
      ).isLeft()
        ? [
            $literalFactory.date(
              this.dateDefaultValueProperty,
              $RdfVocabularies.xsd.date,
            ),
          ]
        : [],
      options?.graph,
    );
    resource.add(
      DefaultValuePropertiesClass.$schema.properties
        .dateTimeDefaultValueProperty.identifier,
      $dateEquals(
        this.dateTimeDefaultValueProperty,
        new Date("2018-04-09T10:00:00.000Z"),
      ).isLeft()
        ? [
            $literalFactory.date(
              this.dateTimeDefaultValueProperty,
              $RdfVocabularies.xsd.dateTime,
            ),
          ]
        : [],
      options?.graph,
    );
    resource.add(
      DefaultValuePropertiesClass.$schema.properties
        .falseBooleanDefaultValueProperty.identifier,
      $strictEquals(this.falseBooleanDefaultValueProperty, false).isLeft()
        ? [$literalFactory.boolean(this.falseBooleanDefaultValueProperty)]
        : [],
      options?.graph,
    );
    resource.add(
      DefaultValuePropertiesClass.$schema.properties.numberDefaultValueProperty
        .identifier,
      $strictEquals(this.numberDefaultValueProperty, 0).isLeft()
        ? [
            $literalFactory.number(
              this.numberDefaultValueProperty,
              $RdfVocabularies.xsd.integer,
            ),
          ]
        : [],
      options?.graph,
    );
    resource.add(
      DefaultValuePropertiesClass.$schema.properties.stringDefaultValueProperty
        .identifier,
      $strictEquals(this.stringDefaultValueProperty, "").isLeft()
        ? [$literalFactory.string(this.stringDefaultValueProperty)]
        : [],
      options?.graph,
    );
    resource.add(
      DefaultValuePropertiesClass.$schema.properties
        .trueBooleanDefaultValueProperty.identifier,
      $strictEquals(this.trueBooleanDefaultValueProperty, true).isLeft()
        ? [$literalFactory.boolean(this.trueBooleanDefaultValueProperty)]
        : [],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace DefaultValuePropertiesClass {
  export function $filter(
    filter: DefaultValuePropertiesClass.$Filter,
    value: DefaultValuePropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.dateDefaultValueProperty !== "undefined" &&
      !$filterDate(
        filter.dateDefaultValueProperty,
        value.dateDefaultValueProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.dateTimeDefaultValueProperty !== "undefined" &&
      !$filterDate(
        filter.dateTimeDefaultValueProperty,
        value.dateTimeDefaultValueProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.falseBooleanDefaultValueProperty !== "undefined" &&
      !$filterBoolean(
        filter.falseBooleanDefaultValueProperty,
        value.falseBooleanDefaultValueProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.numberDefaultValueProperty !== "undefined" &&
      !$filterNumber(
        filter.numberDefaultValueProperty,
        value.numberDefaultValueProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.stringDefaultValueProperty !== "undefined" &&
      !$filterString(
        filter.stringDefaultValueProperty,
        value.stringDefaultValueProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.trueBooleanDefaultValueProperty !== "undefined" &&
      !$filterBoolean(
        filter.trueBooleanDefaultValueProperty,
        value.trueBooleanDefaultValueProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly dateDefaultValueProperty?: $DateFilter;
    readonly dateTimeDefaultValueProperty?: $DateFilter;
    readonly falseBooleanDefaultValueProperty?: $BooleanFilter;
    readonly numberDefaultValueProperty?: $NumberFilter;
    readonly stringDefaultValueProperty?: $StringFilter;
    readonly trueBooleanDefaultValueProperty?: $BooleanFilter;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/DefaultValuePropertiesClass",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      dateDefaultValueProperty: Date;
      dateTimeDefaultValueProperty: Date;
      falseBooleanDefaultValueProperty: boolean;
      numberDefaultValueProperty: number;
      stringDefaultValueProperty: string;
      trueBooleanDefaultValueProperty: boolean;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const dateDefaultValueProperty = new Date(
      $jsonObject["dateDefaultValueProperty"],
    );
    const dateTimeDefaultValueProperty = new Date(
      $jsonObject["dateTimeDefaultValueProperty"],
    );
    const falseBooleanDefaultValueProperty =
      $jsonObject["falseBooleanDefaultValueProperty"];
    const numberDefaultValueProperty =
      $jsonObject["numberDefaultValueProperty"];
    const stringDefaultValueProperty =
      $jsonObject["stringDefaultValueProperty"];
    const trueBooleanDefaultValueProperty =
      $jsonObject["trueBooleanDefaultValueProperty"];
    return Either.of({
      $identifier,
      dateDefaultValueProperty,
      dateTimeDefaultValueProperty,
      falseBooleanDefaultValueProperty,
      numberDefaultValueProperty,
      stringDefaultValueProperty,
      trueBooleanDefaultValueProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, DefaultValuePropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new DefaultValuePropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "DefaultValuePropertiesClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateDefaultValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateTimeDefaultValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/falseBooleanDefaultValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/numberDefaultValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/stringDefaultValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/trueBooleanDefaultValueProperty`,
          type: "Control",
        },
      ],
      label: "DefaultValuePropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("DefaultValuePropertiesClass"),
      dateDefaultValueProperty: z.iso.date(),
      dateTimeDefaultValueProperty: z.iso.datetime(),
      falseBooleanDefaultValueProperty: z.boolean(),
      numberDefaultValueProperty: z.number(),
      stringDefaultValueProperty: z.string(),
      trueBooleanDefaultValueProperty: z.boolean(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "DefaultValuePropertiesClass";
    readonly dateDefaultValueProperty: string;
    readonly dateTimeDefaultValueProperty: string;
    readonly falseBooleanDefaultValueProperty: boolean;
    readonly numberDefaultValueProperty: number;
    readonly stringDefaultValueProperty: string;
    readonly trueBooleanDefaultValueProperty: boolean;
  };

  export function isDefaultValuePropertiesClass(
    object: $Object,
  ): object is DefaultValuePropertiesClass {
    switch (object.$type) {
      case "DefaultValuePropertiesClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, DefaultValuePropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return DefaultValuePropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new DefaultValuePropertiesClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      dateDefaultValueProperty: Date;
      dateTimeDefaultValueProperty: Date;
      falseBooleanDefaultValueProperty: boolean;
      numberDefaultValueProperty: number;
      stringDefaultValueProperty: string;
      trueBooleanDefaultValueProperty: boolean;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/DefaultValuePropertiesClass":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  DefaultValuePropertiesClass.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/DefaultValuePropertiesClass)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, DefaultValuePropertiesClass.$Identifier>(
        $parameters.resource
          .identifier as DefaultValuePropertiesClass.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.dateDefaultValueProperty.identifier,
            { unique: true },
          ),
        )
          .map((values) =>
            values.length > 0
              ? values
              : new Resource.TermValue({
                  focusResource: $parameters.resource,
                  predicate:
                    DefaultValuePropertiesClass.$schema.properties
                      .dateDefaultValueProperty.identifier,
                  term: dataFactory.literal(
                    "2018-04-09",
                    $RdfVocabularies.xsd.date,
                  ),
                }).toValues(),
          )
          .chain((values) => values.chainMap((value) => value.toDate()))
          .chain((values) => values.head())
          .chain((dateDefaultValueProperty) =>
            Either.of<Error, Resource.Values<Resource.TermValue>>(
              $parameters.resource.values(
                $schema.properties.dateTimeDefaultValueProperty.identifier,
                {
                  unique: true,
                },
              ),
            )
              .map((values) =>
                values.length > 0
                  ? values
                  : new Resource.TermValue({
                      focusResource: $parameters.resource,
                      predicate:
                        DefaultValuePropertiesClass.$schema.properties
                          .dateTimeDefaultValueProperty.identifier,
                      term: dataFactory.literal(
                        "2018-04-09T10:00:00Z",
                        $RdfVocabularies.xsd.dateTime,
                      ),
                    }).toValues(),
              )
              .chain((values) => values.chainMap((value) => value.toDate()))
              .chain((values) => values.head())
              .chain((dateTimeDefaultValueProperty) =>
                Either.of<Error, Resource.Values<Resource.TermValue>>(
                  $parameters.resource.values(
                    $schema.properties.falseBooleanDefaultValueProperty
                      .identifier,
                    {
                      unique: true,
                    },
                  ),
                )
                  .map((values) =>
                    values.length > 0
                      ? values
                      : new Resource.TermValue({
                          focusResource: $parameters.resource,
                          predicate:
                            DefaultValuePropertiesClass.$schema.properties
                              .falseBooleanDefaultValueProperty.identifier,
                          term: dataFactory.literal(
                            "false",
                            $RdfVocabularies.xsd.boolean,
                          ),
                        }).toValues(),
                  )
                  .chain((values) =>
                    values.chainMap((value) => value.toBoolean()),
                  )
                  .chain((values) => values.head())
                  .chain((falseBooleanDefaultValueProperty) =>
                    Either.of<Error, Resource.Values<Resource.TermValue>>(
                      $parameters.resource.values(
                        $schema.properties.numberDefaultValueProperty
                          .identifier,
                        {
                          unique: true,
                        },
                      ),
                    )
                      .map((values) =>
                        values.length > 0
                          ? values
                          : new Resource.TermValue({
                              focusResource: $parameters.resource,
                              predicate:
                                DefaultValuePropertiesClass.$schema.properties
                                  .numberDefaultValueProperty.identifier,
                              term: dataFactory.literal(
                                "0",
                                $RdfVocabularies.xsd.integer,
                              ),
                            }).toValues(),
                      )
                      .chain((values) =>
                        values.chainMap((value) => value.toNumber()),
                      )
                      .chain((values) => values.head())
                      .chain((numberDefaultValueProperty) =>
                        Either.of<Error, Resource.Values<Resource.TermValue>>(
                          $parameters.resource.values(
                            $schema.properties.stringDefaultValueProperty
                              .identifier,
                            {
                              unique: true,
                            },
                          ),
                        )
                          .map((values) =>
                            values.length > 0
                              ? values
                              : new Resource.TermValue({
                                  focusResource: $parameters.resource,
                                  predicate:
                                    DefaultValuePropertiesClass.$schema
                                      .properties.stringDefaultValueProperty
                                      .identifier,
                                  term: dataFactory.literal(""),
                                }).toValues(),
                          )
                          .chain((values) =>
                            $fromRdfPreferredLanguages({
                              focusResource: $parameters.resource,
                              predicate:
                                DefaultValuePropertiesClass.$schema.properties
                                  .stringDefaultValueProperty.identifier,
                              preferredLanguages:
                                $parameters.preferredLanguages,
                              values,
                            }),
                          )
                          .chain((values) =>
                            values.chainMap((value) => value.toString()),
                          )
                          .chain((values) => values.head())
                          .chain((stringDefaultValueProperty) =>
                            Either.of<
                              Error,
                              Resource.Values<Resource.TermValue>
                            >(
                              $parameters.resource.values(
                                $schema.properties
                                  .trueBooleanDefaultValueProperty.identifier,
                                {
                                  unique: true,
                                },
                              ),
                            )
                              .map((values) =>
                                values.length > 0
                                  ? values
                                  : new Resource.TermValue({
                                      focusResource: $parameters.resource,
                                      predicate:
                                        DefaultValuePropertiesClass.$schema
                                          .properties
                                          .trueBooleanDefaultValueProperty
                                          .identifier,
                                      term: dataFactory.literal(
                                        "true",
                                        $RdfVocabularies.xsd.boolean,
                                      ),
                                    }).toValues(),
                              )
                              .chain((values) =>
                                values.chainMap((value) => value.toBoolean()),
                              )
                              .chain((values) => values.head())
                              .map((trueBooleanDefaultValueProperty) => ({
                                $identifier,
                                dateDefaultValueProperty,
                                dateTimeDefaultValueProperty,
                                falseBooleanDefaultValueProperty,
                                numberDefaultValueProperty,
                                stringDefaultValueProperty,
                                trueBooleanDefaultValueProperty,
                              })),
                          ),
                      ),
                  ),
              ),
          ),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $identifierPrefix: {
        kind: "IdentifierPrefix" as const,
        type: () => ({ kind: "String" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["DefaultValuePropertiesClass"],
        }),
      },
      dateDefaultValueProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "DefaultValue" as const,
          item: () => ({ kind: "Date" as const }),
          defaultValue: dataFactory.literal(
            "2018-04-09",
            $RdfVocabularies.xsd.date,
          ),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/dateDefaultValueProperty",
        ),
      },
      dateTimeDefaultValueProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "DefaultValue" as const,
          item: () => ({ kind: "DateTime" as const }),
          defaultValue: dataFactory.literal(
            "2018-04-09T10:00:00Z",
            $RdfVocabularies.xsd.dateTime,
          ),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/dateTimeDefaultValueProperty",
        ),
      },
      falseBooleanDefaultValueProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "DefaultValue" as const,
          item: () => ({ kind: "Boolean" as const }),
          defaultValue: dataFactory.literal(
            "false",
            $RdfVocabularies.xsd.boolean,
          ),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/falseBooleanDefaultValueProperty",
        ),
      },
      numberDefaultValueProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "DefaultValue" as const,
          item: () => ({ kind: "Int" as const }),
          defaultValue: dataFactory.literal("0", $RdfVocabularies.xsd.integer),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/numberDefaultValueProperty",
        ),
      },
      stringDefaultValueProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "DefaultValue" as const,
          item: () => ({ kind: "String" as const }),
          defaultValue: dataFactory.literal(""),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/stringDefaultValueProperty",
        ),
      },
      trueBooleanDefaultValueProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "DefaultValue" as const,
          item: () => ({ kind: "Boolean" as const }),
          defaultValue: dataFactory.literal(
            "true",
            $RdfVocabularies.xsd.boolean,
          ),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/trueBooleanDefaultValueProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: DefaultValuePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        DefaultValuePropertiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          DefaultValuePropertiesClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: DefaultValuePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      DefaultValuePropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("defaultValuePropertiesClass");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "defaultValuePropertiesClass")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "defaultValuePropertiesClass")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "defaultValuePropertiesClass")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "defaultValuePropertiesClass")
          }DateDefaultValueProperty`,
        ),
        predicate:
          DefaultValuePropertiesClass.$schema.properties
            .dateDefaultValueProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "defaultValuePropertiesClass")
          }DateTimeDefaultValueProperty`,
        ),
        predicate:
          DefaultValuePropertiesClass.$schema.properties
            .dateTimeDefaultValueProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "defaultValuePropertiesClass")
          }FalseBooleanDefaultValueProperty`,
        ),
        predicate:
          DefaultValuePropertiesClass.$schema.properties
            .falseBooleanDefaultValueProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "defaultValuePropertiesClass")
          }NumberDefaultValueProperty`,
        ),
        predicate:
          DefaultValuePropertiesClass.$schema.properties
            .numberDefaultValueProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "defaultValuePropertiesClass")
          }StringDefaultValueProperty`,
        ),
        predicate:
          DefaultValuePropertiesClass.$schema.properties
            .stringDefaultValueProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "defaultValuePropertiesClass")
          }TrueBooleanDefaultValueProperty`,
        ),
        predicate:
          DefaultValuePropertiesClass.$schema.properties
            .trueBooleanDefaultValueProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: DefaultValuePropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("defaultValuePropertiesClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "defaultValuePropertiesClass")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: DefaultValuePropertiesClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "defaultValuePropertiesClass")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            DefaultValuePropertiesClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "defaultValuePropertiesClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $defaultValueSparqlWherePatterns<$DateFilter, $DateSchema>(
        $dateSparqlWherePatterns,
      )({
        filter: parameters?.filter?.dateDefaultValueProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "defaultValuePropertiesClass")
                  }DateDefaultValueProperty`,
                ),
                predicate:
                  DefaultValuePropertiesClass.$schema.properties
                    .dateDefaultValueProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          DefaultValuePropertiesClass.$schema.properties.dateDefaultValueProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "defaultValuePropertiesClass")
          }DateDefaultValueProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "defaultValuePropertiesClass")
        }DateDefaultValueProperty`,
      }),
    );
    patterns = patterns.concat(
      $defaultValueSparqlWherePatterns<$DateFilter, $DateSchema>(
        $dateSparqlWherePatterns,
      )({
        filter: parameters?.filter?.dateTimeDefaultValueProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "defaultValuePropertiesClass")
                  }DateTimeDefaultValueProperty`,
                ),
                predicate:
                  DefaultValuePropertiesClass.$schema.properties
                    .dateTimeDefaultValueProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          DefaultValuePropertiesClass.$schema.properties.dateTimeDefaultValueProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "defaultValuePropertiesClass")
          }DateTimeDefaultValueProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "defaultValuePropertiesClass")
        }DateTimeDefaultValueProperty`,
      }),
    );
    patterns = patterns.concat(
      $defaultValueSparqlWherePatterns<$BooleanFilter, $BooleanSchema>(
        $booleanSparqlWherePatterns,
      )({
        filter: parameters?.filter?.falseBooleanDefaultValueProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "defaultValuePropertiesClass")
                  }FalseBooleanDefaultValueProperty`,
                ),
                predicate:
                  DefaultValuePropertiesClass.$schema.properties
                    .falseBooleanDefaultValueProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          DefaultValuePropertiesClass.$schema.properties.falseBooleanDefaultValueProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "defaultValuePropertiesClass")
          }FalseBooleanDefaultValueProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "defaultValuePropertiesClass")
        }FalseBooleanDefaultValueProperty`,
      }),
    );
    patterns = patterns.concat(
      $defaultValueSparqlWherePatterns<$NumberFilter, $NumberSchema>(
        $numberSparqlWherePatterns,
      )({
        filter: parameters?.filter?.numberDefaultValueProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "defaultValuePropertiesClass")
                  }NumberDefaultValueProperty`,
                ),
                predicate:
                  DefaultValuePropertiesClass.$schema.properties
                    .numberDefaultValueProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          DefaultValuePropertiesClass.$schema.properties.numberDefaultValueProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "defaultValuePropertiesClass")
          }NumberDefaultValueProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "defaultValuePropertiesClass")
        }NumberDefaultValueProperty`,
      }),
    );
    patterns = patterns.concat(
      $defaultValueSparqlWherePatterns<$StringFilter, $StringSchema>(
        $stringSparqlWherePatterns,
      )({
        filter: parameters?.filter?.stringDefaultValueProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "defaultValuePropertiesClass")
                  }StringDefaultValueProperty`,
                ),
                predicate:
                  DefaultValuePropertiesClass.$schema.properties
                    .stringDefaultValueProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          DefaultValuePropertiesClass.$schema.properties.stringDefaultValueProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "defaultValuePropertiesClass")
          }StringDefaultValueProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "defaultValuePropertiesClass")
        }StringDefaultValueProperty`,
      }),
    );
    patterns = patterns.concat(
      $defaultValueSparqlWherePatterns<$BooleanFilter, $BooleanSchema>(
        $booleanSparqlWherePatterns,
      )({
        filter: parameters?.filter?.trueBooleanDefaultValueProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "defaultValuePropertiesClass")
                  }TrueBooleanDefaultValueProperty`,
                ),
                predicate:
                  DefaultValuePropertiesClass.$schema.properties
                    .trueBooleanDefaultValueProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          DefaultValuePropertiesClass.$schema.properties.trueBooleanDefaultValueProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "defaultValuePropertiesClass")
          }TrueBooleanDefaultValueProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "defaultValuePropertiesClass")
        }TrueBooleanDefaultValueProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Shape with sh:xone (union) properties related to dates and date-times. Unions of these and strings are common in actual models.
 */

export class DateUnionPropertiesClass {
  private _$identifier?: DateUnionPropertiesClass.$Identifier;

  readonly $type: "DateUnionPropertiesClass" =
    "DateUnionPropertiesClass" as const;

  readonly dateOrDateTimeProperty: Maybe<
    { type: "date"; value: Date } | { type: "dateTime"; value: Date }
  >;

  readonly dateOrStringProperty: Maybe<
    { type: "date"; value: Date } | { type: "string"; value: string }
  >;

  readonly dateTimeOrDateProperty: Maybe<
    { type: "dateTime"; value: Date } | { type: "date"; value: Date }
  >;

  readonly stringOrDateProperty: Maybe<
    { type: "string"; value: string } | { type: "date"; value: Date }
  >;

  constructor(parameters?: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly dateOrDateTimeProperty?:
      | Maybe<{ type: "date"; value: Date } | { type: "dateTime"; value: Date }>
      | ({ type: "date"; value: Date } | { type: "dateTime"; value: Date });
    readonly dateOrStringProperty?:
      | Maybe<{ type: "date"; value: Date } | { type: "string"; value: string }>
      | ({ type: "date"; value: Date } | { type: "string"; value: string });
    readonly dateTimeOrDateProperty?:
      | Maybe<{ type: "dateTime"; value: Date } | { type: "date"; value: Date }>
      | ({ type: "dateTime"; value: Date } | { type: "date"; value: Date });
    readonly stringOrDateProperty?:
      | Maybe<{ type: "string"; value: string } | { type: "date"; value: Date }>
      | ({ type: "string"; value: string } | { type: "date"; value: Date });
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }
    if (Maybe.isMaybe(parameters?.dateOrDateTimeProperty)) {
      this.dateOrDateTimeProperty = parameters?.dateOrDateTimeProperty;
    } else if (typeof parameters?.dateOrDateTimeProperty === "object") {
      this.dateOrDateTimeProperty = Maybe.of(
        parameters?.dateOrDateTimeProperty,
      );
    } else if (typeof parameters?.dateOrDateTimeProperty === "undefined") {
      this.dateOrDateTimeProperty = Maybe.empty();
    } else {
      this.dateOrDateTimeProperty =
        parameters?.dateOrDateTimeProperty satisfies never;
    }
    if (Maybe.isMaybe(parameters?.dateOrStringProperty)) {
      this.dateOrStringProperty = parameters?.dateOrStringProperty;
    } else if (typeof parameters?.dateOrStringProperty === "object") {
      this.dateOrStringProperty = Maybe.of(parameters?.dateOrStringProperty);
    } else if (typeof parameters?.dateOrStringProperty === "undefined") {
      this.dateOrStringProperty = Maybe.empty();
    } else {
      this.dateOrStringProperty =
        parameters?.dateOrStringProperty satisfies never;
    }
    if (Maybe.isMaybe(parameters?.dateTimeOrDateProperty)) {
      this.dateTimeOrDateProperty = parameters?.dateTimeOrDateProperty;
    } else if (typeof parameters?.dateTimeOrDateProperty === "object") {
      this.dateTimeOrDateProperty = Maybe.of(
        parameters?.dateTimeOrDateProperty,
      );
    } else if (typeof parameters?.dateTimeOrDateProperty === "undefined") {
      this.dateTimeOrDateProperty = Maybe.empty();
    } else {
      this.dateTimeOrDateProperty =
        parameters?.dateTimeOrDateProperty satisfies never;
    }
    if (Maybe.isMaybe(parameters?.stringOrDateProperty)) {
      this.stringOrDateProperty = parameters?.stringOrDateProperty;
    } else if (typeof parameters?.stringOrDateProperty === "object") {
      this.stringOrDateProperty = Maybe.of(parameters?.stringOrDateProperty);
    } else if (typeof parameters?.stringOrDateProperty === "undefined") {
      this.stringOrDateProperty = Maybe.empty();
    } else {
      this.stringOrDateProperty =
        parameters?.stringOrDateProperty satisfies never;
    }
  }

  get $identifier(): DateUnionPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: DateUnionPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (
              left:
                | { type: "date"; value: Date }
                | { type: "dateTime"; value: Date },
              right:
                | { type: "date"; value: Date }
                | { type: "dateTime"; value: Date },
            ) => {
              if (left.type === "date" && right.type === "date") {
                return $dateEquals(left.value, right.value);
              }
              if (left.type === "dateTime" && right.type === "dateTime") {
                return $dateEquals(left.value, right.value);
              }

              return Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "boolean" as const,
                },
                type: "property" as const,
              });
            },
          ))(this.dateOrDateTimeProperty, other.dateOrDateTimeProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "dateOrDateTimeProperty",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (
              left:
                | { type: "date"; value: Date }
                | { type: "string"; value: string },
              right:
                | { type: "date"; value: Date }
                | { type: "string"; value: string },
            ) => {
              if (left.type === "date" && right.type === "date") {
                return $dateEquals(left.value, right.value);
              }
              if (left.type === "string" && right.type === "string") {
                return $strictEquals(left.value, right.value);
              }

              return Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "boolean" as const,
                },
                type: "property" as const,
              });
            },
          ))(this.dateOrStringProperty, other.dateOrStringProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "dateOrStringProperty",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (
              left:
                | { type: "dateTime"; value: Date }
                | { type: "date"; value: Date },
              right:
                | { type: "dateTime"; value: Date }
                | { type: "date"; value: Date },
            ) => {
              if (left.type === "dateTime" && right.type === "dateTime") {
                return $dateEquals(left.value, right.value);
              }
              if (left.type === "date" && right.type === "date") {
                return $dateEquals(left.value, right.value);
              }

              return Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "boolean" as const,
                },
                type: "property" as const,
              });
            },
          ))(this.dateTimeOrDateProperty, other.dateTimeOrDateProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "dateTimeOrDateProperty",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (
              left:
                | { type: "string"; value: string }
                | { type: "date"; value: Date },
              right:
                | { type: "string"; value: string }
                | { type: "date"; value: Date },
            ) => {
              if (left.type === "string" && right.type === "string") {
                return $strictEquals(left.value, right.value);
              }
              if (left.type === "date" && right.type === "date") {
                return $dateEquals(left.value, right.value);
              }

              return Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "boolean" as const,
                },
                type: "property" as const,
              });
            },
          ))(this.stringOrDateProperty, other.stringOrDateProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "stringOrDateProperty",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    this.dateOrDateTimeProperty.ifJust((value0) => {
      switch (value0.type) {
        case "date": {
          _hasher.update(value0.value.toISOString());
          break;
        }
        case "dateTime": {
          _hasher.update(value0.value.toISOString());
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    this.dateOrStringProperty.ifJust((value0) => {
      switch (value0.type) {
        case "date": {
          _hasher.update(value0.value.toISOString());
          break;
        }
        case "string": {
          _hasher.update(value0.value);
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    this.dateTimeOrDateProperty.ifJust((value0) => {
      switch (value0.type) {
        case "dateTime": {
          _hasher.update(value0.value.toISOString());
          break;
        }
        case "date": {
          _hasher.update(value0.value.toISOString());
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    this.stringOrDateProperty.ifJust((value0) => {
      switch (value0.type) {
        case "string": {
          _hasher.update(value0.value);
          break;
        }
        case "date": {
          _hasher.update(value0.value.toISOString());
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    return _hasher;
  }

  $toJson(): DateUnionPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        dateOrDateTimeProperty: this.dateOrDateTimeProperty
          .map((item) =>
            item.type === "dateTime"
              ? { type: "dateTime" as const, value: item.value.toISOString() }
              : {
                  type: "date" as const,
                  value: item.value.toISOString().replace(/T.*$/, ""),
                },
          )
          .extract(),
        dateOrStringProperty: this.dateOrStringProperty
          .map((item) =>
            item.type === "string"
              ? { type: "string" as const, value: item.value }
              : {
                  type: "date" as const,
                  value: item.value.toISOString().replace(/T.*$/, ""),
                },
          )
          .extract(),
        dateTimeOrDateProperty: this.dateTimeOrDateProperty
          .map((item) =>
            item.type === "date"
              ? {
                  type: "date" as const,
                  value: item.value.toISOString().replace(/T.*$/, ""),
                }
              : { type: "dateTime" as const, value: item.value.toISOString() },
          )
          .extract(),
        stringOrDateProperty: this.stringOrDateProperty
          .map((item) =>
            item.type === "date"
              ? {
                  type: "date" as const,
                  value: item.value.toISOString().replace(/T.*$/, ""),
                }
              : { type: "string" as const, value: item.value },
          )
          .extract(),
      } satisfies DateUnionPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/DateUnionPropertiesClass"),
        options?.graph,
      );
    }
    resource.add(
      DateUnionPropertiesClass.$schema.properties.dateOrDateTimeProperty
        .identifier,
      this.dateOrDateTimeProperty
        .toList()
        .flatMap((value) =>
          value.type === "dateTime"
            ? ([
                $literalFactory.date(
                  value.value,
                  $RdfVocabularies.xsd.dateTime,
                ),
              ] as (
                | bigint
                | boolean
                | number
                | string
                | BlankNode
                | Literal
                | NamedNode
              )[])
            : ([
                $literalFactory.date(value.value, $RdfVocabularies.xsd.date),
              ] as (
                | bigint
                | boolean
                | number
                | string
                | BlankNode
                | Literal
                | NamedNode
              )[]),
        ),
      options?.graph,
    );
    resource.add(
      DateUnionPropertiesClass.$schema.properties.dateOrStringProperty
        .identifier,
      this.dateOrStringProperty
        .toList()
        .flatMap((value) =>
          value.type === "string"
            ? ([$literalFactory.string(value.value)] as (
                | bigint
                | boolean
                | number
                | string
                | BlankNode
                | Literal
                | NamedNode
              )[])
            : ([
                $literalFactory.date(value.value, $RdfVocabularies.xsd.date),
              ] as (
                | bigint
                | boolean
                | number
                | string
                | BlankNode
                | Literal
                | NamedNode
              )[]),
        ),
      options?.graph,
    );
    resource.add(
      DateUnionPropertiesClass.$schema.properties.dateTimeOrDateProperty
        .identifier,
      this.dateTimeOrDateProperty
        .toList()
        .flatMap((value) =>
          value.type === "date"
            ? ([
                $literalFactory.date(value.value, $RdfVocabularies.xsd.date),
              ] as (
                | bigint
                | boolean
                | number
                | string
                | BlankNode
                | Literal
                | NamedNode
              )[])
            : ([
                $literalFactory.date(
                  value.value,
                  $RdfVocabularies.xsd.dateTime,
                ),
              ] as (
                | bigint
                | boolean
                | number
                | string
                | BlankNode
                | Literal
                | NamedNode
              )[]),
        ),
      options?.graph,
    );
    resource.add(
      DateUnionPropertiesClass.$schema.properties.stringOrDateProperty
        .identifier,
      this.stringOrDateProperty
        .toList()
        .flatMap((value) =>
          value.type === "date"
            ? ([
                $literalFactory.date(value.value, $RdfVocabularies.xsd.date),
              ] as (
                | bigint
                | boolean
                | number
                | string
                | BlankNode
                | Literal
                | NamedNode
              )[])
            : ([$literalFactory.string(value.value)] as (
                | bigint
                | boolean
                | number
                | string
                | BlankNode
                | Literal
                | NamedNode
              )[]),
        ),
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace DateUnionPropertiesClass {
  export function $filter(
    filter: DateUnionPropertiesClass.$Filter,
    value: DateUnionPropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.dateOrDateTimeProperty !== "undefined" &&
      !$filterMaybe<
        { type: "date"; value: Date } | { type: "dateTime"; value: Date },
        {
          readonly on?: {
            readonly date?: $DateFilter;
            readonly dateTime?: $DateFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly date?: $DateFilter;
              readonly dateTime?: $DateFilter;
            };
          },
          value:
            | { type: "date"; value: Date }
            | { type: "dateTime"; value: Date },
        ) => {
          if (typeof filter.on?.["date"] !== "undefined") {
            switch (value.type) {
              case "date":
                if (!$filterDate(filter.on["date"], value.value)) {
                  return false;
                }
                break;
            }
          }
          if (typeof filter.on?.["dateTime"] !== "undefined") {
            switch (value.type) {
              case "dateTime":
                if (!$filterDate(filter.on["dateTime"], value.value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.dateOrDateTimeProperty, value.dateOrDateTimeProperty)
    ) {
      return false;
    }
    if (
      typeof filter.dateOrStringProperty !== "undefined" &&
      !$filterMaybe<
        { type: "date"; value: Date } | { type: "string"; value: string },
        {
          readonly on?: {
            readonly date?: $DateFilter;
            readonly string?: $StringFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly date?: $DateFilter;
              readonly string?: $StringFilter;
            };
          },
          value:
            | { type: "date"; value: Date }
            | { type: "string"; value: string },
        ) => {
          if (typeof filter.on?.["date"] !== "undefined") {
            switch (value.type) {
              case "date":
                if (!$filterDate(filter.on["date"], value.value)) {
                  return false;
                }
                break;
            }
          }
          if (typeof filter.on?.["string"] !== "undefined") {
            switch (value.type) {
              case "string":
                if (!$filterString(filter.on["string"], value.value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.dateOrStringProperty, value.dateOrStringProperty)
    ) {
      return false;
    }
    if (
      typeof filter.dateTimeOrDateProperty !== "undefined" &&
      !$filterMaybe<
        { type: "dateTime"; value: Date } | { type: "date"; value: Date },
        {
          readonly on?: {
            readonly dateTime?: $DateFilter;
            readonly date?: $DateFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly dateTime?: $DateFilter;
              readonly date?: $DateFilter;
            };
          },
          value:
            | { type: "dateTime"; value: Date }
            | { type: "date"; value: Date },
        ) => {
          if (typeof filter.on?.["dateTime"] !== "undefined") {
            switch (value.type) {
              case "dateTime":
                if (!$filterDate(filter.on["dateTime"], value.value)) {
                  return false;
                }
                break;
            }
          }
          if (typeof filter.on?.["date"] !== "undefined") {
            switch (value.type) {
              case "date":
                if (!$filterDate(filter.on["date"], value.value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.dateTimeOrDateProperty, value.dateTimeOrDateProperty)
    ) {
      return false;
    }
    if (
      typeof filter.stringOrDateProperty !== "undefined" &&
      !$filterMaybe<
        { type: "string"; value: string } | { type: "date"; value: Date },
        {
          readonly on?: {
            readonly string?: $StringFilter;
            readonly date?: $DateFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly string?: $StringFilter;
              readonly date?: $DateFilter;
            };
          },
          value:
            | { type: "string"; value: string }
            | { type: "date"; value: Date },
        ) => {
          if (typeof filter.on?.["string"] !== "undefined") {
            switch (value.type) {
              case "string":
                if (!$filterString(filter.on["string"], value.value)) {
                  return false;
                }
                break;
            }
          }
          if (typeof filter.on?.["date"] !== "undefined") {
            switch (value.type) {
              case "date":
                if (!$filterDate(filter.on["date"], value.value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.stringOrDateProperty, value.stringOrDateProperty)
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly dateOrDateTimeProperty?: $MaybeFilter<{
      readonly on?: {
        readonly date?: $DateFilter;
        readonly dateTime?: $DateFilter;
      };
    }>;
    readonly dateOrStringProperty?: $MaybeFilter<{
      readonly on?: {
        readonly date?: $DateFilter;
        readonly string?: $StringFilter;
      };
    }>;
    readonly dateTimeOrDateProperty?: $MaybeFilter<{
      readonly on?: {
        readonly dateTime?: $DateFilter;
        readonly date?: $DateFilter;
      };
    }>;
    readonly stringOrDateProperty?: $MaybeFilter<{
      readonly on?: {
        readonly string?: $StringFilter;
        readonly date?: $DateFilter;
      };
    }>;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/DateUnionPropertiesClass",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      dateOrDateTimeProperty: Maybe<
        { type: "date"; value: Date } | { type: "dateTime"; value: Date }
      >;
      dateOrStringProperty: Maybe<
        { type: "date"; value: Date } | { type: "string"; value: string }
      >;
      dateTimeOrDateProperty: Maybe<
        { type: "dateTime"; value: Date } | { type: "date"; value: Date }
      >;
      stringOrDateProperty: Maybe<
        { type: "string"; value: string } | { type: "date"; value: Date }
      >;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const dateOrDateTimeProperty = Maybe.fromNullable(
      $jsonObject["dateOrDateTimeProperty"],
    ).map((item) =>
      item.type === "dateTime"
        ? { type: "dateTime" as const, value: new Date(item.value) }
        : { type: "date" as const, value: new Date(item.value) },
    );
    const dateOrStringProperty = Maybe.fromNullable(
      $jsonObject["dateOrStringProperty"],
    ).map((item) =>
      item.type === "string"
        ? { type: "string" as const, value: item.value }
        : { type: "date" as const, value: new Date(item.value) },
    );
    const dateTimeOrDateProperty = Maybe.fromNullable(
      $jsonObject["dateTimeOrDateProperty"],
    ).map((item) =>
      item.type === "date"
        ? { type: "date" as const, value: new Date(item.value) }
        : { type: "dateTime" as const, value: new Date(item.value) },
    );
    const stringOrDateProperty = Maybe.fromNullable(
      $jsonObject["stringOrDateProperty"],
    ).map((item) =>
      item.type === "date"
        ? { type: "date" as const, value: new Date(item.value) }
        : { type: "string" as const, value: item.value },
    );
    return Either.of({
      $identifier,
      dateOrDateTimeProperty,
      dateOrStringProperty,
      dateTimeOrDateProperty,
      stringOrDateProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, DateUnionPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new DateUnionPropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "DateUnionPropertiesClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateOrDateTimeProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateOrStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateTimeOrDateProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/stringOrDateProperty`,
          type: "Control",
        },
      ],
      label: "DateUnionPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("DateUnionPropertiesClass"),
      dateOrDateTimeProperty: z
        .discriminatedUnion("type", [
          z.object({ type: z.literal("date"), value: z.iso.date() }),
          z.object({ type: z.literal("dateTime"), value: z.iso.datetime() }),
        ])
        .optional(),
      dateOrStringProperty: z
        .discriminatedUnion("type", [
          z.object({ type: z.literal("date"), value: z.iso.date() }),
          z.object({ type: z.literal("string"), value: z.string() }),
        ])
        .optional(),
      dateTimeOrDateProperty: z
        .discriminatedUnion("type", [
          z.object({ type: z.literal("dateTime"), value: z.iso.datetime() }),
          z.object({ type: z.literal("date"), value: z.iso.date() }),
        ])
        .optional(),
      stringOrDateProperty: z
        .discriminatedUnion("type", [
          z.object({ type: z.literal("string"), value: z.string() }),
          z.object({ type: z.literal("date"), value: z.iso.date() }),
        ])
        .optional(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "DateUnionPropertiesClass";
    readonly dateOrDateTimeProperty?:
      | { type: "date"; value: string }
      | { type: "dateTime"; value: string };
    readonly dateOrStringProperty?:
      | { type: "date"; value: string }
      | { type: "string"; value: string };
    readonly dateTimeOrDateProperty?:
      | { type: "dateTime"; value: string }
      | { type: "date"; value: string };
    readonly stringOrDateProperty?:
      | { type: "string"; value: string }
      | { type: "date"; value: string };
  };

  export function isDateUnionPropertiesClass(
    object: $Object,
  ): object is DateUnionPropertiesClass {
    switch (object.$type) {
      case "DateUnionPropertiesClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, DateUnionPropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return DateUnionPropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new DateUnionPropertiesClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      dateOrDateTimeProperty: Maybe<
        { type: "date"; value: Date } | { type: "dateTime"; value: Date }
      >;
      dateOrStringProperty: Maybe<
        { type: "date"; value: Date } | { type: "string"; value: string }
      >;
      dateTimeOrDateProperty: Maybe<
        { type: "dateTime"; value: Date } | { type: "date"; value: Date }
      >;
      stringOrDateProperty: Maybe<
        { type: "string"; value: string } | { type: "date"; value: Date }
      >;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/DateUnionPropertiesClass":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  DateUnionPropertiesClass.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/DateUnionPropertiesClass)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, DateUnionPropertiesClass.$Identifier>(
        $parameters.resource.identifier as DateUnionPropertiesClass.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.dateOrDateTimeProperty.identifier,
            { unique: true },
          ),
        )
          .chain((values) =>
            values.chainMap((value) => {
              const valueAsValues = Either.of(value.toValues());
              return (
                valueAsValues
                  .chain((values) => values.chainMap((value) => value.toDate()))
                  .map((values) =>
                    values.map(
                      (value) =>
                        ({
                          type: "date" as const,
                          value,
                        }) as
                          | { type: "date"; value: Date }
                          | { type: "dateTime"; value: Date },
                    ),
                  ) as Either<
                  Error,
                  Resource.Values<
                    | { type: "date"; value: Date }
                    | { type: "dateTime"; value: Date }
                  >
                >
              )
                .altLazy(
                  () =>
                    valueAsValues
                      .chain((values) =>
                        values.chainMap((value) => value.toDate()),
                      )
                      .map((values) =>
                        values.map(
                          (value) =>
                            ({
                              type: "dateTime" as const,
                              value,
                            }) as
                              | { type: "date"; value: Date }
                              | { type: "dateTime"; value: Date },
                        ),
                      ) as Either<
                      Error,
                      Resource.Values<
                        | { type: "date"; value: Date }
                        | { type: "dateTime"; value: Date }
                      >
                    >,
                )
                .chain((values) => values.head());
            }),
          )
          .map((values) =>
            values.length > 0
              ? values.map((value) => Maybe.of(value))
              : Resource.Values.fromValue<
                  Maybe<
                    | { type: "date"; value: Date }
                    | { type: "dateTime"; value: Date }
                  >
                >({
                  focusResource: $parameters.resource,
                  predicate:
                    DateUnionPropertiesClass.$schema.properties
                      .dateOrDateTimeProperty.identifier,
                  value: Maybe.empty(),
                }),
          )
          .chain((values) => values.head())
          .chain((dateOrDateTimeProperty) =>
            Either.of<Error, Resource.Values<Resource.TermValue>>(
              $parameters.resource.values(
                $schema.properties.dateOrStringProperty.identifier,
                { unique: true },
              ),
            )
              .chain((values) =>
                values.chainMap((value) => {
                  const valueAsValues = Either.of(value.toValues());
                  return (
                    valueAsValues
                      .chain((values) =>
                        values.chainMap((value) => value.toDate()),
                      )
                      .map((values) =>
                        values.map(
                          (value) =>
                            ({
                              type: "date" as const,
                              value,
                            }) as
                              | { type: "date"; value: Date }
                              | { type: "string"; value: string },
                        ),
                      ) as Either<
                      Error,
                      Resource.Values<
                        | { type: "date"; value: Date }
                        | { type: "string"; value: string }
                      >
                    >
                  )
                    .altLazy(
                      () =>
                        valueAsValues
                          .chain((values) =>
                            $fromRdfPreferredLanguages({
                              focusResource: $parameters.resource,
                              predicate:
                                DateUnionPropertiesClass.$schema.properties
                                  .dateOrStringProperty.identifier,
                              preferredLanguages:
                                $parameters.preferredLanguages,
                              values,
                            }),
                          )
                          .chain((values) =>
                            values.chainMap((value) => value.toString()),
                          )
                          .map((values) =>
                            values.map(
                              (value) =>
                                ({
                                  type: "string" as const,
                                  value,
                                }) as
                                  | { type: "date"; value: Date }
                                  | { type: "string"; value: string },
                            ),
                          ) as Either<
                          Error,
                          Resource.Values<
                            | { type: "date"; value: Date }
                            | { type: "string"; value: string }
                          >
                        >,
                    )
                    .chain((values) => values.head());
                }),
              )
              .map((values) =>
                values.length > 0
                  ? values.map((value) => Maybe.of(value))
                  : Resource.Values.fromValue<
                      Maybe<
                        | { type: "date"; value: Date }
                        | { type: "string"; value: string }
                      >
                    >({
                      focusResource: $parameters.resource,
                      predicate:
                        DateUnionPropertiesClass.$schema.properties
                          .dateOrStringProperty.identifier,
                      value: Maybe.empty(),
                    }),
              )
              .chain((values) => values.head())
              .chain((dateOrStringProperty) =>
                Either.of<Error, Resource.Values<Resource.TermValue>>(
                  $parameters.resource.values(
                    $schema.properties.dateTimeOrDateProperty.identifier,
                    { unique: true },
                  ),
                )
                  .chain((values) =>
                    values.chainMap((value) => {
                      const valueAsValues = Either.of(value.toValues());
                      return (
                        valueAsValues
                          .chain((values) =>
                            values.chainMap((value) => value.toDate()),
                          )
                          .map((values) =>
                            values.map(
                              (value) =>
                                ({
                                  type: "dateTime" as const,
                                  value,
                                }) as
                                  | { type: "dateTime"; value: Date }
                                  | { type: "date"; value: Date },
                            ),
                          ) as Either<
                          Error,
                          Resource.Values<
                            | { type: "dateTime"; value: Date }
                            | { type: "date"; value: Date }
                          >
                        >
                      )
                        .altLazy(
                          () =>
                            valueAsValues
                              .chain((values) =>
                                values.chainMap((value) => value.toDate()),
                              )
                              .map((values) =>
                                values.map(
                                  (value) =>
                                    ({
                                      type: "date" as const,
                                      value,
                                    }) as
                                      | { type: "dateTime"; value: Date }
                                      | { type: "date"; value: Date },
                                ),
                              ) as Either<
                              Error,
                              Resource.Values<
                                | { type: "dateTime"; value: Date }
                                | { type: "date"; value: Date }
                              >
                            >,
                        )
                        .chain((values) => values.head());
                    }),
                  )
                  .map((values) =>
                    values.length > 0
                      ? values.map((value) => Maybe.of(value))
                      : Resource.Values.fromValue<
                          Maybe<
                            | { type: "dateTime"; value: Date }
                            | { type: "date"; value: Date }
                          >
                        >({
                          focusResource: $parameters.resource,
                          predicate:
                            DateUnionPropertiesClass.$schema.properties
                              .dateTimeOrDateProperty.identifier,
                          value: Maybe.empty(),
                        }),
                  )
                  .chain((values) => values.head())
                  .chain((dateTimeOrDateProperty) =>
                    Either.of<Error, Resource.Values<Resource.TermValue>>(
                      $parameters.resource.values(
                        $schema.properties.stringOrDateProperty.identifier,
                        { unique: true },
                      ),
                    )
                      .chain((values) =>
                        values.chainMap((value) => {
                          const valueAsValues = Either.of(value.toValues());
                          return (
                            valueAsValues
                              .chain((values) =>
                                $fromRdfPreferredLanguages({
                                  focusResource: $parameters.resource,
                                  predicate:
                                    DateUnionPropertiesClass.$schema.properties
                                      .stringOrDateProperty.identifier,
                                  preferredLanguages:
                                    $parameters.preferredLanguages,
                                  values,
                                }),
                              )
                              .chain((values) =>
                                values.chainMap((value) => value.toString()),
                              )
                              .map((values) =>
                                values.map(
                                  (value) =>
                                    ({
                                      type: "string" as const,
                                      value,
                                    }) as
                                      | { type: "string"; value: string }
                                      | { type: "date"; value: Date },
                                ),
                              ) as Either<
                              Error,
                              Resource.Values<
                                | { type: "string"; value: string }
                                | { type: "date"; value: Date }
                              >
                            >
                          )
                            .altLazy(
                              () =>
                                valueAsValues
                                  .chain((values) =>
                                    values.chainMap((value) => value.toDate()),
                                  )
                                  .map((values) =>
                                    values.map(
                                      (value) =>
                                        ({
                                          type: "date" as const,
                                          value,
                                        }) as
                                          | { type: "string"; value: string }
                                          | { type: "date"; value: Date },
                                    ),
                                  ) as Either<
                                  Error,
                                  Resource.Values<
                                    | { type: "string"; value: string }
                                    | { type: "date"; value: Date }
                                  >
                                >,
                            )
                            .chain((values) => values.head());
                        }),
                      )
                      .map((values) =>
                        values.length > 0
                          ? values.map((value) => Maybe.of(value))
                          : Resource.Values.fromValue<
                              Maybe<
                                | { type: "string"; value: string }
                                | { type: "date"; value: Date }
                              >
                            >({
                              focusResource: $parameters.resource,
                              predicate:
                                DateUnionPropertiesClass.$schema.properties
                                  .stringOrDateProperty.identifier,
                              value: Maybe.empty(),
                            }),
                      )
                      .chain((values) => values.head())
                      .map((stringOrDateProperty) => ({
                        $identifier,
                        dateOrDateTimeProperty,
                        dateOrStringProperty,
                        dateTimeOrDateProperty,
                        stringOrDateProperty,
                      })),
                  ),
              ),
          ),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["DateUnionPropertiesClass"],
        }),
      },
      dateOrDateTimeProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({
            kind: "Union" as const,
            members: {
              date: {
                discriminantValues: ["date"],
                type: { kind: "Date" as const },
              },
              dateTime: {
                discriminantValues: ["dateTime"],
                type: { kind: "DateTime" as const },
              },
            },
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/dateOrDateTimeProperty",
        ),
      },
      dateOrStringProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({
            kind: "Union" as const,
            members: {
              date: {
                discriminantValues: ["date"],
                type: { kind: "Date" as const },
              },
              string: {
                discriminantValues: ["string"],
                type: { kind: "String" as const },
              },
            },
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/dateOrStringProperty",
        ),
      },
      dateTimeOrDateProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({
            kind: "Union" as const,
            members: {
              dateTime: {
                discriminantValues: ["dateTime"],
                type: { kind: "DateTime" as const },
              },
              date: {
                discriminantValues: ["date"],
                type: { kind: "Date" as const },
              },
            },
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/dateTimeOrDateProperty",
        ),
      },
      stringOrDateProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({
            kind: "Union" as const,
            members: {
              string: {
                discriminantValues: ["string"],
                type: { kind: "String" as const },
              },
              date: {
                discriminantValues: ["date"],
                type: { kind: "Date" as const },
              },
            },
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/stringOrDateProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: DateUnionPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        DateUnionPropertiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          DateUnionPropertiesClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: DateUnionPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      DateUnionPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("dateUnionPropertiesClass");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "dateUnionPropertiesClass")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "dateUnionPropertiesClass")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "dateUnionPropertiesClass")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "dateUnionPropertiesClass")
          }DateOrDateTimeProperty`,
        ),
        predicate:
          DateUnionPropertiesClass.$schema.properties.dateOrDateTimeProperty
            .identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "dateUnionPropertiesClass")
          }DateOrStringProperty`,
        ),
        predicate:
          DateUnionPropertiesClass.$schema.properties.dateOrStringProperty
            .identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "dateUnionPropertiesClass")
          }DateTimeOrDateProperty`,
        ),
        predicate:
          DateUnionPropertiesClass.$schema.properties.dateTimeOrDateProperty
            .identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "dateUnionPropertiesClass")
          }StringOrDateProperty`,
        ),
        predicate:
          DateUnionPropertiesClass.$schema.properties.stringOrDateProperty
            .identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: DateUnionPropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("dateUnionPropertiesClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "dateUnionPropertiesClass")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: DateUnionPropertiesClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "dateUnionPropertiesClass")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            DateUnionPropertiesClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "dateUnionPropertiesClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<
        {
          readonly on?: {
            readonly date?: $DateFilter;
            readonly dateTime?: $DateFilter;
          };
        },
        {
          kind: "Union";
          members: {
            readonly date: {
              discriminantValues: readonly string[];
              type: $DateSchema;
            };
            readonly dateTime: {
              discriminantValues: readonly string[];
              type: $DateSchema;
            };
          };
        }
      >(({ filter, schema, ...otherParameters }) => {
        const unionPatterns: sparqljs.GroupPattern[] = [];

        unionPatterns.push({
          patterns: $dateSparqlWherePatterns({
            filter: filter?.on?.["date"],
            schema: schema.members["date"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });
        unionPatterns.push({
          patterns: $dateSparqlWherePatterns({
            filter: filter?.on?.["dateTime"],
            schema: schema.members["dateTime"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });

        return [{ patterns: unionPatterns, type: "union" }];
      })({
        filter: parameters?.filter?.dateOrDateTimeProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "dateUnionPropertiesClass")
                  }DateOrDateTimeProperty`,
                ),
                predicate:
                  DateUnionPropertiesClass.$schema.properties
                    .dateOrDateTimeProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          DateUnionPropertiesClass.$schema.properties.dateOrDateTimeProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "dateUnionPropertiesClass")
          }DateOrDateTimeProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "dateUnionPropertiesClass")
        }DateOrDateTimeProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<
        {
          readonly on?: {
            readonly date?: $DateFilter;
            readonly string?: $StringFilter;
          };
        },
        {
          kind: "Union";
          members: {
            readonly date: {
              discriminantValues: readonly string[];
              type: $DateSchema;
            };
            readonly string: {
              discriminantValues: readonly string[];
              type: $StringSchema;
            };
          };
        }
      >(({ filter, schema, ...otherParameters }) => {
        const unionPatterns: sparqljs.GroupPattern[] = [];

        unionPatterns.push({
          patterns: $dateSparqlWherePatterns({
            filter: filter?.on?.["date"],
            schema: schema.members["date"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });
        unionPatterns.push({
          patterns: $stringSparqlWherePatterns({
            filter: filter?.on?.["string"],
            schema: schema.members["string"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });

        return [{ patterns: unionPatterns, type: "union" }];
      })({
        filter: parameters?.filter?.dateOrStringProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "dateUnionPropertiesClass")
                  }DateOrStringProperty`,
                ),
                predicate:
                  DateUnionPropertiesClass.$schema.properties
                    .dateOrStringProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          DateUnionPropertiesClass.$schema.properties.dateOrStringProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "dateUnionPropertiesClass")
          }DateOrStringProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "dateUnionPropertiesClass")
        }DateOrStringProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<
        {
          readonly on?: {
            readonly dateTime?: $DateFilter;
            readonly date?: $DateFilter;
          };
        },
        {
          kind: "Union";
          members: {
            readonly dateTime: {
              discriminantValues: readonly string[];
              type: $DateSchema;
            };
            readonly date: {
              discriminantValues: readonly string[];
              type: $DateSchema;
            };
          };
        }
      >(({ filter, schema, ...otherParameters }) => {
        const unionPatterns: sparqljs.GroupPattern[] = [];

        unionPatterns.push({
          patterns: $dateSparqlWherePatterns({
            filter: filter?.on?.["dateTime"],
            schema: schema.members["dateTime"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });
        unionPatterns.push({
          patterns: $dateSparqlWherePatterns({
            filter: filter?.on?.["date"],
            schema: schema.members["date"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });

        return [{ patterns: unionPatterns, type: "union" }];
      })({
        filter: parameters?.filter?.dateTimeOrDateProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "dateUnionPropertiesClass")
                  }DateTimeOrDateProperty`,
                ),
                predicate:
                  DateUnionPropertiesClass.$schema.properties
                    .dateTimeOrDateProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          DateUnionPropertiesClass.$schema.properties.dateTimeOrDateProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "dateUnionPropertiesClass")
          }DateTimeOrDateProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "dateUnionPropertiesClass")
        }DateTimeOrDateProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<
        {
          readonly on?: {
            readonly string?: $StringFilter;
            readonly date?: $DateFilter;
          };
        },
        {
          kind: "Union";
          members: {
            readonly string: {
              discriminantValues: readonly string[];
              type: $StringSchema;
            };
            readonly date: {
              discriminantValues: readonly string[];
              type: $DateSchema;
            };
          };
        }
      >(({ filter, schema, ...otherParameters }) => {
        const unionPatterns: sparqljs.GroupPattern[] = [];

        unionPatterns.push({
          patterns: $stringSparqlWherePatterns({
            filter: filter?.on?.["string"],
            schema: schema.members["string"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });
        unionPatterns.push({
          patterns: $dateSparqlWherePatterns({
            filter: filter?.on?.["date"],
            schema: schema.members["date"].type,
            ...otherParameters,
          }).concat(),
          type: "group",
        });

        return [{ patterns: unionPatterns, type: "union" }];
      })({
        filter: parameters?.filter?.stringOrDateProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "dateUnionPropertiesClass")
                  }StringOrDateProperty`,
                ),
                predicate:
                  DateUnionPropertiesClass.$schema.properties
                    .stringOrDateProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          DateUnionPropertiesClass.$schema.properties.stringOrDateProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "dateUnionPropertiesClass")
          }StringOrDateProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "dateUnionPropertiesClass")
        }StringOrDateProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Node shape with properties whose types are convertible from other types on construction e.g., string to IRI.
 */

export class ConvertibleTypePropertiesClass {
  private _$identifier?: ConvertibleTypePropertiesClass.$Identifier;

  readonly $type: "ConvertibleTypePropertiesClass" =
    "ConvertibleTypePropertiesClass" as const;

  readonly convertibleIriNonEmptySetProperty: NonEmptyList<NamedNode>;

  readonly convertibleIriOptionProperty: Maybe<NamedNode>;

  readonly convertibleIriProperty: NamedNode;

  readonly convertibleIriSetProperty: readonly NamedNode[];

  readonly convertibleLiteralNonEmptySetProperty: NonEmptyList<Literal>;

  readonly convertibleLiteralOptionProperty: Maybe<Literal>;

  readonly convertibleLiteralProperty: Literal;

  readonly convertibleLiteralSetProperty: readonly Literal[];

  readonly convertibleTermNonEmptySetProperty: NonEmptyList<
    BlankNode | Literal | NamedNode
  >;

  readonly convertibleTermOptionProperty: Maybe<
    BlankNode | Literal | NamedNode
  >;

  readonly convertibleTermProperty: BlankNode | Literal | NamedNode;

  readonly convertibleTermSetProperty: readonly (
    | BlankNode
    | Literal
    | NamedNode
  )[];

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly convertibleIriNonEmptySetProperty: NonEmptyList<NamedNode>;
    readonly convertibleIriOptionProperty?:
      | Maybe<NamedNode>
      | NamedNode
      | string;
    readonly convertibleIriProperty: NamedNode | string;
    readonly convertibleIriSetProperty?:
      | readonly NamedNode[]
      | readonly string[];
    readonly convertibleLiteralNonEmptySetProperty: NonEmptyList<Literal>;
    readonly convertibleLiteralOptionProperty?:
      | Maybe<Literal>
      | bigint
      | boolean
      | Date
      | number
      | string
      | Literal;
    readonly convertibleLiteralProperty:
      | bigint
      | boolean
      | Date
      | number
      | string
      | Literal;
    readonly convertibleLiteralSetProperty?:
      | readonly Literal[]
      | readonly bigint[]
      | readonly boolean[]
      | readonly number[]
      | readonly string[];
    readonly convertibleTermNonEmptySetProperty: NonEmptyList<
      BlankNode | Literal | NamedNode
    >;
    readonly convertibleTermOptionProperty?:
      | Maybe<BlankNode | Literal | NamedNode>
      | bigint
      | boolean
      | Date
      | number
      | string
      | (BlankNode | Literal | NamedNode);
    readonly convertibleTermProperty:
      | bigint
      | boolean
      | Date
      | number
      | string
      | (BlankNode | Literal | NamedNode);
    readonly convertibleTermSetProperty?:
      | readonly (BlankNode | Literal | NamedNode)[]
      | readonly bigint[]
      | readonly boolean[]
      | readonly number[]
      | readonly string[];
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this.convertibleIriNonEmptySetProperty =
      parameters.convertibleIriNonEmptySetProperty;
    if (Maybe.isMaybe(parameters.convertibleIriOptionProperty)) {
      this.convertibleIriOptionProperty =
        parameters.convertibleIriOptionProperty;
    } else if (typeof parameters.convertibleIriOptionProperty === "object") {
      this.convertibleIriOptionProperty = Maybe.of(
        parameters.convertibleIriOptionProperty,
      );
    } else if (typeof parameters.convertibleIriOptionProperty === "string") {
      this.convertibleIriOptionProperty = Maybe.of(
        dataFactory.namedNode(parameters.convertibleIriOptionProperty),
      );
    } else if (typeof parameters.convertibleIriOptionProperty === "undefined") {
      this.convertibleIriOptionProperty = Maybe.empty();
    } else {
      this.convertibleIriOptionProperty =
        parameters.convertibleIriOptionProperty satisfies never;
    }
    if (typeof parameters.convertibleIriProperty === "object") {
      this.convertibleIriProperty = parameters.convertibleIriProperty;
    } else if (typeof parameters.convertibleIriProperty === "string") {
      this.convertibleIriProperty = dataFactory.namedNode(
        parameters.convertibleIriProperty,
      );
    } else {
      this.convertibleIriProperty =
        parameters.convertibleIriProperty satisfies never;
    }
    if (typeof parameters.convertibleIriSetProperty === "undefined") {
      this.convertibleIriSetProperty = [];
    } else if ($isReadonlyObjectArray(parameters.convertibleIriSetProperty)) {
      this.convertibleIriSetProperty = parameters.convertibleIriSetProperty;
    } else if ($isReadonlyStringArray(parameters.convertibleIriSetProperty)) {
      this.convertibleIriSetProperty = parameters.convertibleIriSetProperty.map(
        (item) => dataFactory.namedNode(item),
      );
    } else {
      this.convertibleIriSetProperty =
        parameters.convertibleIriSetProperty satisfies never;
    }
    this.convertibleLiteralNonEmptySetProperty =
      parameters.convertibleLiteralNonEmptySetProperty;
    if (Maybe.isMaybe(parameters.convertibleLiteralOptionProperty)) {
      this.convertibleLiteralOptionProperty =
        parameters.convertibleLiteralOptionProperty;
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "bigint"
    ) {
      this.convertibleLiteralOptionProperty = Maybe.of(
        $literalFactory.bigint(parameters.convertibleLiteralOptionProperty),
      );
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "boolean"
    ) {
      this.convertibleLiteralOptionProperty = Maybe.of(
        $literalFactory.boolean(parameters.convertibleLiteralOptionProperty),
      );
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "object" &&
      parameters.convertibleLiteralOptionProperty instanceof Date
    ) {
      this.convertibleLiteralOptionProperty = Maybe.of(
        $literalFactory.date(parameters.convertibleLiteralOptionProperty),
      );
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "number"
    ) {
      this.convertibleLiteralOptionProperty = Maybe.of(
        $literalFactory.number(parameters.convertibleLiteralOptionProperty),
      );
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "string"
    ) {
      this.convertibleLiteralOptionProperty = Maybe.of(
        $literalFactory.string(parameters.convertibleLiteralOptionProperty),
      );
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "object"
    ) {
      this.convertibleLiteralOptionProperty = Maybe.of(
        parameters.convertibleLiteralOptionProperty,
      );
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "undefined"
    ) {
      this.convertibleLiteralOptionProperty = Maybe.empty();
    } else {
      this.convertibleLiteralOptionProperty =
        parameters.convertibleLiteralOptionProperty satisfies never;
    }
    if (typeof parameters.convertibleLiteralProperty === "bigint") {
      this.convertibleLiteralProperty = $literalFactory.bigint(
        parameters.convertibleLiteralProperty,
      );
    } else if (typeof parameters.convertibleLiteralProperty === "boolean") {
      this.convertibleLiteralProperty = $literalFactory.boolean(
        parameters.convertibleLiteralProperty,
      );
    } else if (
      typeof parameters.convertibleLiteralProperty === "object" &&
      parameters.convertibleLiteralProperty instanceof Date
    ) {
      this.convertibleLiteralProperty = $literalFactory.date(
        parameters.convertibleLiteralProperty,
      );
    } else if (typeof parameters.convertibleLiteralProperty === "number") {
      this.convertibleLiteralProperty = $literalFactory.number(
        parameters.convertibleLiteralProperty,
      );
    } else if (typeof parameters.convertibleLiteralProperty === "string") {
      this.convertibleLiteralProperty = $literalFactory.string(
        parameters.convertibleLiteralProperty,
      );
    } else if (typeof parameters.convertibleLiteralProperty === "object") {
      this.convertibleLiteralProperty = parameters.convertibleLiteralProperty;
    } else {
      this.convertibleLiteralProperty =
        parameters.convertibleLiteralProperty satisfies never;
    }
    if (typeof parameters.convertibleLiteralSetProperty === "undefined") {
      this.convertibleLiteralSetProperty = [];
    } else if (
      $isReadonlyObjectArray(parameters.convertibleLiteralSetProperty)
    ) {
      this.convertibleLiteralSetProperty =
        parameters.convertibleLiteralSetProperty;
    } else if (
      $isReadonlyBigintArray(parameters.convertibleLiteralSetProperty)
    ) {
      this.convertibleLiteralSetProperty =
        parameters.convertibleLiteralSetProperty.map((item) =>
          $literalFactory.bigint(item),
        );
    } else if (
      $isReadonlyBooleanArray(parameters.convertibleLiteralSetProperty)
    ) {
      this.convertibleLiteralSetProperty =
        parameters.convertibleLiteralSetProperty.map((item) =>
          $literalFactory.boolean(item),
        );
    } else if (
      $isReadonlyNumberArray(parameters.convertibleLiteralSetProperty)
    ) {
      this.convertibleLiteralSetProperty =
        parameters.convertibleLiteralSetProperty.map((item) =>
          $literalFactory.number(item),
        );
    } else if (
      $isReadonlyStringArray(parameters.convertibleLiteralSetProperty)
    ) {
      this.convertibleLiteralSetProperty =
        parameters.convertibleLiteralSetProperty.map((item) =>
          $literalFactory.string(item),
        );
    } else {
      this.convertibleLiteralSetProperty =
        parameters.convertibleLiteralSetProperty satisfies never;
    }
    this.convertibleTermNonEmptySetProperty =
      parameters.convertibleTermNonEmptySetProperty;
    if (Maybe.isMaybe(parameters.convertibleTermOptionProperty)) {
      this.convertibleTermOptionProperty =
        parameters.convertibleTermOptionProperty;
    } else if (typeof parameters.convertibleTermOptionProperty === "bigint") {
      this.convertibleTermOptionProperty = Maybe.of(
        $literalFactory.bigint(parameters.convertibleTermOptionProperty),
      );
    } else if (typeof parameters.convertibleTermOptionProperty === "boolean") {
      this.convertibleTermOptionProperty = Maybe.of(
        $literalFactory.boolean(parameters.convertibleTermOptionProperty),
      );
    } else if (
      typeof parameters.convertibleTermOptionProperty === "object" &&
      parameters.convertibleTermOptionProperty instanceof Date
    ) {
      this.convertibleTermOptionProperty = Maybe.of(
        $literalFactory.date(parameters.convertibleTermOptionProperty),
      );
    } else if (typeof parameters.convertibleTermOptionProperty === "number") {
      this.convertibleTermOptionProperty = Maybe.of(
        $literalFactory.number(parameters.convertibleTermOptionProperty),
      );
    } else if (typeof parameters.convertibleTermOptionProperty === "string") {
      this.convertibleTermOptionProperty = Maybe.of(
        $literalFactory.string(parameters.convertibleTermOptionProperty),
      );
    } else if (typeof parameters.convertibleTermOptionProperty === "object") {
      this.convertibleTermOptionProperty = Maybe.of(
        parameters.convertibleTermOptionProperty,
      );
    } else if (
      typeof parameters.convertibleTermOptionProperty === "undefined"
    ) {
      this.convertibleTermOptionProperty = Maybe.empty();
    } else {
      this.convertibleTermOptionProperty =
        parameters.convertibleTermOptionProperty satisfies never;
    }
    if (typeof parameters.convertibleTermProperty === "bigint") {
      this.convertibleTermProperty = $literalFactory.bigint(
        parameters.convertibleTermProperty,
      );
    } else if (typeof parameters.convertibleTermProperty === "boolean") {
      this.convertibleTermProperty = $literalFactory.boolean(
        parameters.convertibleTermProperty,
      );
    } else if (
      typeof parameters.convertibleTermProperty === "object" &&
      parameters.convertibleTermProperty instanceof Date
    ) {
      this.convertibleTermProperty = $literalFactory.date(
        parameters.convertibleTermProperty,
      );
    } else if (typeof parameters.convertibleTermProperty === "number") {
      this.convertibleTermProperty = $literalFactory.number(
        parameters.convertibleTermProperty,
      );
    } else if (typeof parameters.convertibleTermProperty === "string") {
      this.convertibleTermProperty = $literalFactory.string(
        parameters.convertibleTermProperty,
      );
    } else if (typeof parameters.convertibleTermProperty === "object") {
      this.convertibleTermProperty = parameters.convertibleTermProperty;
    } else {
      this.convertibleTermProperty =
        parameters.convertibleTermProperty satisfies never;
    }
    if (typeof parameters.convertibleTermSetProperty === "undefined") {
      this.convertibleTermSetProperty = [];
    } else if ($isReadonlyObjectArray(parameters.convertibleTermSetProperty)) {
      this.convertibleTermSetProperty = parameters.convertibleTermSetProperty;
    } else if ($isReadonlyBigintArray(parameters.convertibleTermSetProperty)) {
      this.convertibleTermSetProperty =
        parameters.convertibleTermSetProperty.map((item) =>
          $literalFactory.bigint(item),
        );
    } else if ($isReadonlyBooleanArray(parameters.convertibleTermSetProperty)) {
      this.convertibleTermSetProperty =
        parameters.convertibleTermSetProperty.map((item) =>
          $literalFactory.boolean(item),
        );
    } else if ($isReadonlyNumberArray(parameters.convertibleTermSetProperty)) {
      this.convertibleTermSetProperty =
        parameters.convertibleTermSetProperty.map((item) =>
          $literalFactory.number(item),
        );
    } else if ($isReadonlyStringArray(parameters.convertibleTermSetProperty)) {
      this.convertibleTermSetProperty =
        parameters.convertibleTermSetProperty.map((item) =>
          $literalFactory.string(item),
        );
    } else {
      this.convertibleTermSetProperty =
        parameters.convertibleTermSetProperty satisfies never;
    }
  }

  get $identifier(): ConvertibleTypePropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: ConvertibleTypePropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleIriNonEmptySetProperty,
          other.convertibleIriNonEmptySetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleIriNonEmptySetProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.convertibleIriOptionProperty,
          other.convertibleIriOptionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleIriOptionProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        $booleanEquals(
          this.convertibleIriProperty,
          other.convertibleIriProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleIriProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleIriSetProperty,
          other.convertibleIriSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleIriSetProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleLiteralNonEmptySetProperty,
          other.convertibleLiteralNonEmptySetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleLiteralNonEmptySetProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.convertibleLiteralOptionProperty,
          other.convertibleLiteralOptionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleLiteralOptionProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        $booleanEquals(
          this.convertibleLiteralProperty,
          other.convertibleLiteralProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleLiteralProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleLiteralSetProperty,
          other.convertibleLiteralSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleLiteralSetProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleTermNonEmptySetProperty,
          other.convertibleTermNonEmptySetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleTermNonEmptySetProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.convertibleTermOptionProperty,
          other.convertibleTermOptionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleTermOptionProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        $booleanEquals(
          this.convertibleTermProperty,
          other.convertibleTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleTermProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleTermSetProperty,
          other.convertibleTermSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleTermSetProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    for (const item0 of this.convertibleIriNonEmptySetProperty) {
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }
    this.convertibleIriOptionProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    _hasher.update(this.convertibleIriProperty.termType);
    _hasher.update(this.convertibleIriProperty.value);
    for (const item0 of this.convertibleIriSetProperty) {
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }
    for (const item0 of this.convertibleLiteralNonEmptySetProperty) {
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
      _hasher.update(item0.datatype.value);
      _hasher.update(item0.language);
    }
    this.convertibleLiteralOptionProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
      _hasher.update(value0.datatype.value);
      _hasher.update(value0.language);
    });
    _hasher.update(this.convertibleLiteralProperty.termType);
    _hasher.update(this.convertibleLiteralProperty.value);
    _hasher.update(this.convertibleLiteralProperty.datatype.value);
    _hasher.update(this.convertibleLiteralProperty.language);
    for (const item0 of this.convertibleLiteralSetProperty) {
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
      _hasher.update(item0.datatype.value);
      _hasher.update(item0.language);
    }
    for (const item0 of this.convertibleTermNonEmptySetProperty) {
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }
    this.convertibleTermOptionProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    _hasher.update(this.convertibleTermProperty.termType);
    _hasher.update(this.convertibleTermProperty.value);
    for (const item0 of this.convertibleTermSetProperty) {
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }
    return _hasher;
  }

  $toJson(): ConvertibleTypePropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        convertibleIriNonEmptySetProperty:
          this.convertibleIriNonEmptySetProperty.map((item) => ({
            "@id": item.value,
          })),
        convertibleIriOptionProperty: this.convertibleIriOptionProperty
          .map((item) => ({ "@id": item.value }))
          .extract(),
        convertibleIriProperty: { "@id": this.convertibleIriProperty.value },
        convertibleIriSetProperty: this.convertibleIriSetProperty.map(
          (item) => ({ "@id": item.value }),
        ),
        convertibleLiteralNonEmptySetProperty:
          this.convertibleLiteralNonEmptySetProperty.map((item) => ({
            "@language": item.language.length > 0 ? item.language : undefined,
            "@type":
              item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? item.datatype.value
                : undefined,
            "@value": item.value,
          })),
        convertibleLiteralOptionProperty: this.convertibleLiteralOptionProperty
          .map((item) => ({
            "@language": item.language.length > 0 ? item.language : undefined,
            "@type":
              item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? item.datatype.value
                : undefined,
            "@value": item.value,
          }))
          .extract(),
        convertibleLiteralProperty: {
          "@language":
            this.convertibleLiteralProperty.language.length > 0
              ? this.convertibleLiteralProperty.language
              : undefined,
          "@type":
            this.convertibleLiteralProperty.datatype.value !==
            "http://www.w3.org/2001/XMLSchema#string"
              ? this.convertibleLiteralProperty.datatype.value
              : undefined,
          "@value": this.convertibleLiteralProperty.value,
        },
        convertibleLiteralSetProperty: this.convertibleLiteralSetProperty.map(
          (item) => ({
            "@language": item.language.length > 0 ? item.language : undefined,
            "@type":
              item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? item.datatype.value
                : undefined,
            "@value": item.value,
          }),
        ),
        convertibleTermNonEmptySetProperty:
          this.convertibleTermNonEmptySetProperty.map((item) =>
            item.termType === "NamedNode"
              ? { "@id": item.value, termType: "NamedNode" as const }
              : item.termType === "Literal"
                ? {
                    "@language":
                      item.language.length > 0 ? item.language : undefined,
                    "@type":
                      item.datatype.value !==
                      "http://www.w3.org/2001/XMLSchema#string"
                        ? item.datatype.value
                        : undefined,
                    "@value": item.value,
                    termType: "Literal" as const,
                  }
                : { "@id": `_:${item.value}`, termType: "BlankNode" as const },
          ),
        convertibleTermOptionProperty: this.convertibleTermOptionProperty
          .map((item) =>
            item.termType === "NamedNode"
              ? { "@id": item.value, termType: "NamedNode" as const }
              : item.termType === "Literal"
                ? {
                    "@language":
                      item.language.length > 0 ? item.language : undefined,
                    "@type":
                      item.datatype.value !==
                      "http://www.w3.org/2001/XMLSchema#string"
                        ? item.datatype.value
                        : undefined,
                    "@value": item.value,
                    termType: "Literal" as const,
                  }
                : { "@id": `_:${item.value}`, termType: "BlankNode" as const },
          )
          .extract(),
        convertibleTermProperty:
          this.convertibleTermProperty.termType === "NamedNode"
            ? {
                "@id": this.convertibleTermProperty.value,
                termType: "NamedNode" as const,
              }
            : this.convertibleTermProperty.termType === "Literal"
              ? {
                  "@language":
                    this.convertibleTermProperty.language.length > 0
                      ? this.convertibleTermProperty.language
                      : undefined,
                  "@type":
                    this.convertibleTermProperty.datatype.value !==
                    "http://www.w3.org/2001/XMLSchema#string"
                      ? this.convertibleTermProperty.datatype.value
                      : undefined,
                  "@value": this.convertibleTermProperty.value,
                  termType: "Literal" as const,
                }
              : {
                  "@id": `_:${this.convertibleTermProperty.value}`,
                  termType: "BlankNode" as const,
                },
        convertibleTermSetProperty: this.convertibleTermSetProperty.map(
          (item) =>
            item.termType === "NamedNode"
              ? { "@id": item.value, termType: "NamedNode" as const }
              : item.termType === "Literal"
                ? {
                    "@language":
                      item.language.length > 0 ? item.language : undefined,
                    "@type":
                      item.datatype.value !==
                      "http://www.w3.org/2001/XMLSchema#string"
                        ? item.datatype.value
                        : undefined,
                    "@value": item.value,
                    termType: "Literal" as const,
                  }
                : { "@id": `_:${item.value}`, termType: "BlankNode" as const },
        ),
      } satisfies ConvertibleTypePropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode(
          "http://example.com/ConvertibleTypePropertiesClass",
        ),
        options?.graph,
      );
    }
    resource.add(
      ConvertibleTypePropertiesClass.$schema.properties
        .convertibleIriNonEmptySetProperty.identifier,
      this.convertibleIriNonEmptySetProperty.flatMap((item) => [item]),
      options?.graph,
    );
    resource.add(
      ConvertibleTypePropertiesClass.$schema.properties
        .convertibleIriOptionProperty.identifier,
      this.convertibleIriOptionProperty.toList(),
      options?.graph,
    );
    resource.add(
      ConvertibleTypePropertiesClass.$schema.properties.convertibleIriProperty
        .identifier,
      [this.convertibleIriProperty],
      options?.graph,
    );
    resource.add(
      ConvertibleTypePropertiesClass.$schema.properties
        .convertibleIriSetProperty.identifier,
      this.convertibleIriSetProperty.flatMap((item) => [item]),
      options?.graph,
    );
    resource.add(
      ConvertibleTypePropertiesClass.$schema.properties
        .convertibleLiteralNonEmptySetProperty.identifier,
      this.convertibleLiteralNonEmptySetProperty.flatMap((item) => [item]),
      options?.graph,
    );
    resource.add(
      ConvertibleTypePropertiesClass.$schema.properties
        .convertibleLiteralOptionProperty.identifier,
      this.convertibleLiteralOptionProperty.toList(),
      options?.graph,
    );
    resource.add(
      ConvertibleTypePropertiesClass.$schema.properties
        .convertibleLiteralProperty.identifier,
      [this.convertibleLiteralProperty],
      options?.graph,
    );
    resource.add(
      ConvertibleTypePropertiesClass.$schema.properties
        .convertibleLiteralSetProperty.identifier,
      this.convertibleLiteralSetProperty.flatMap((item) => [item]),
      options?.graph,
    );
    resource.add(
      ConvertibleTypePropertiesClass.$schema.properties
        .convertibleTermNonEmptySetProperty.identifier,
      this.convertibleTermNonEmptySetProperty.flatMap((item) => [item]),
      options?.graph,
    );
    resource.add(
      ConvertibleTypePropertiesClass.$schema.properties
        .convertibleTermOptionProperty.identifier,
      this.convertibleTermOptionProperty.toList(),
      options?.graph,
    );
    resource.add(
      ConvertibleTypePropertiesClass.$schema.properties.convertibleTermProperty
        .identifier,
      [this.convertibleTermProperty],
      options?.graph,
    );
    resource.add(
      ConvertibleTypePropertiesClass.$schema.properties
        .convertibleTermSetProperty.identifier,
      this.convertibleTermSetProperty.flatMap((item) => [item]),
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ConvertibleTypePropertiesClass {
  export function $filter(
    filter: ConvertibleTypePropertiesClass.$Filter,
    value: ConvertibleTypePropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.convertibleIriNonEmptySetProperty !== "undefined" &&
      !$filterArray<NamedNode, $NamedNodeFilter>($filterNamedNode)(
        filter.convertibleIriNonEmptySetProperty,
        value.convertibleIriNonEmptySetProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.convertibleIriOptionProperty !== "undefined" &&
      !$filterMaybe<NamedNode, $NamedNodeFilter>($filterNamedNode)(
        filter.convertibleIriOptionProperty,
        value.convertibleIriOptionProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.convertibleIriProperty !== "undefined" &&
      !$filterNamedNode(
        filter.convertibleIriProperty,
        value.convertibleIriProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.convertibleIriSetProperty !== "undefined" &&
      !$filterArray<NamedNode, $NamedNodeFilter>($filterNamedNode)(
        filter.convertibleIriSetProperty,
        value.convertibleIriSetProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.convertibleLiteralNonEmptySetProperty !== "undefined" &&
      !$filterArray<Literal, $LiteralFilter>($filterLiteral)(
        filter.convertibleLiteralNonEmptySetProperty,
        value.convertibleLiteralNonEmptySetProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.convertibleLiteralOptionProperty !== "undefined" &&
      !$filterMaybe<Literal, $LiteralFilter>($filterLiteral)(
        filter.convertibleLiteralOptionProperty,
        value.convertibleLiteralOptionProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.convertibleLiteralProperty !== "undefined" &&
      !$filterLiteral(
        filter.convertibleLiteralProperty,
        value.convertibleLiteralProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.convertibleLiteralSetProperty !== "undefined" &&
      !$filterArray<Literal, $LiteralFilter>($filterLiteral)(
        filter.convertibleLiteralSetProperty,
        value.convertibleLiteralSetProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.convertibleTermNonEmptySetProperty !== "undefined" &&
      !$filterArray<BlankNode | Literal | NamedNode, $TermFilter>($filterTerm)(
        filter.convertibleTermNonEmptySetProperty,
        value.convertibleTermNonEmptySetProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.convertibleTermOptionProperty !== "undefined" &&
      !$filterMaybe<BlankNode | Literal | NamedNode, $TermFilter>($filterTerm)(
        filter.convertibleTermOptionProperty,
        value.convertibleTermOptionProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.convertibleTermProperty !== "undefined" &&
      !$filterTerm(
        filter.convertibleTermProperty,
        value.convertibleTermProperty,
      )
    ) {
      return false;
    }
    if (
      typeof filter.convertibleTermSetProperty !== "undefined" &&
      !$filterArray<BlankNode | Literal | NamedNode, $TermFilter>($filterTerm)(
        filter.convertibleTermSetProperty,
        value.convertibleTermSetProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly convertibleIriNonEmptySetProperty?: $CollectionFilter<$NamedNodeFilter>;
    readonly convertibleIriOptionProperty?: $MaybeFilter<$NamedNodeFilter>;
    readonly convertibleIriProperty?: $NamedNodeFilter;
    readonly convertibleIriSetProperty?: $CollectionFilter<$NamedNodeFilter>;
    readonly convertibleLiteralNonEmptySetProperty?: $CollectionFilter<$LiteralFilter>;
    readonly convertibleLiteralOptionProperty?: $MaybeFilter<$LiteralFilter>;
    readonly convertibleLiteralProperty?: $LiteralFilter;
    readonly convertibleLiteralSetProperty?: $CollectionFilter<$LiteralFilter>;
    readonly convertibleTermNonEmptySetProperty?: $CollectionFilter<$TermFilter>;
    readonly convertibleTermOptionProperty?: $MaybeFilter<$TermFilter>;
    readonly convertibleTermProperty?: $TermFilter;
    readonly convertibleTermSetProperty?: $CollectionFilter<$TermFilter>;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ConvertibleTypePropertiesClass",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      convertibleIriNonEmptySetProperty: NonEmptyList<NamedNode>;
      convertibleIriOptionProperty: Maybe<NamedNode>;
      convertibleIriProperty: NamedNode;
      convertibleIriSetProperty: readonly NamedNode[];
      convertibleLiteralNonEmptySetProperty: NonEmptyList<Literal>;
      convertibleLiteralOptionProperty: Maybe<Literal>;
      convertibleLiteralProperty: Literal;
      convertibleLiteralSetProperty: readonly Literal[];
      convertibleTermNonEmptySetProperty: NonEmptyList<
        BlankNode | Literal | NamedNode
      >;
      convertibleTermOptionProperty: Maybe<BlankNode | Literal | NamedNode>;
      convertibleTermProperty: BlankNode | Literal | NamedNode;
      convertibleTermSetProperty: readonly (BlankNode | Literal | NamedNode)[];
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const convertibleIriNonEmptySetProperty = NonEmptyList.fromArray(
      $jsonObject["convertibleIriNonEmptySetProperty"],
    )
      .unsafeCoerce()
      .map((item) => dataFactory.namedNode(item["@id"]));
    const convertibleIriOptionProperty = Maybe.fromNullable(
      $jsonObject["convertibleIriOptionProperty"],
    ).map((item) => dataFactory.namedNode(item["@id"]));
    const convertibleIriProperty = dataFactory.namedNode(
      $jsonObject["convertibleIriProperty"]["@id"],
    );
    const convertibleIriSetProperty = $jsonObject[
      "convertibleIriSetProperty"
    ].map((item) => dataFactory.namedNode(item["@id"]));
    const convertibleLiteralNonEmptySetProperty = NonEmptyList.fromArray(
      $jsonObject["convertibleLiteralNonEmptySetProperty"],
    )
      .unsafeCoerce()
      .map((item) =>
        dataFactory.literal(
          item["@value"],
          typeof item["@language"] !== "undefined"
            ? item["@language"]
            : typeof item["@type"] !== "undefined"
              ? dataFactory.namedNode(item["@type"])
              : undefined,
        ),
      );
    const convertibleLiteralOptionProperty = Maybe.fromNullable(
      $jsonObject["convertibleLiteralOptionProperty"],
    ).map((item) =>
      dataFactory.literal(
        item["@value"],
        typeof item["@language"] !== "undefined"
          ? item["@language"]
          : typeof item["@type"] !== "undefined"
            ? dataFactory.namedNode(item["@type"])
            : undefined,
      ),
    );
    const convertibleLiteralProperty = dataFactory.literal(
      $jsonObject["convertibleLiteralProperty"]["@value"],
      typeof $jsonObject["convertibleLiteralProperty"]["@language"] !==
        "undefined"
        ? $jsonObject["convertibleLiteralProperty"]["@language"]
        : typeof $jsonObject["convertibleLiteralProperty"]["@type"] !==
            "undefined"
          ? dataFactory.namedNode(
              $jsonObject["convertibleLiteralProperty"]["@type"],
            )
          : undefined,
    );
    const convertibleLiteralSetProperty = $jsonObject[
      "convertibleLiteralSetProperty"
    ].map((item) =>
      dataFactory.literal(
        item["@value"],
        typeof item["@language"] !== "undefined"
          ? item["@language"]
          : typeof item["@type"] !== "undefined"
            ? dataFactory.namedNode(item["@type"])
            : undefined,
      ),
    );
    const convertibleTermNonEmptySetProperty = NonEmptyList.fromArray(
      $jsonObject["convertibleTermNonEmptySetProperty"],
    )
      .unsafeCoerce()
      .map((item) =>
        item.termType === "NamedNode"
          ? dataFactory.namedNode(item["@id"])
          : item.termType === "Literal"
            ? dataFactory.literal(
                item["@value"],
                typeof item["@language"] !== "undefined"
                  ? item["@language"]
                  : typeof item["@type"] !== "undefined"
                    ? dataFactory.namedNode(item["@type"])
                    : undefined,
              )
            : dataFactory.blankNode(item["@id"].substring(2)),
      );
    const convertibleTermOptionProperty = Maybe.fromNullable(
      $jsonObject["convertibleTermOptionProperty"],
    ).map((item) =>
      item.termType === "NamedNode"
        ? dataFactory.namedNode(item["@id"])
        : item.termType === "Literal"
          ? dataFactory.literal(
              item["@value"],
              typeof item["@language"] !== "undefined"
                ? item["@language"]
                : typeof item["@type"] !== "undefined"
                  ? dataFactory.namedNode(item["@type"])
                  : undefined,
            )
          : dataFactory.blankNode(item["@id"].substring(2)),
    );
    const convertibleTermProperty =
      $jsonObject["convertibleTermProperty"].termType === "NamedNode"
        ? dataFactory.namedNode($jsonObject["convertibleTermProperty"]["@id"])
        : $jsonObject["convertibleTermProperty"].termType === "Literal"
          ? dataFactory.literal(
              $jsonObject["convertibleTermProperty"]["@value"],
              typeof $jsonObject["convertibleTermProperty"]["@language"] !==
                "undefined"
                ? $jsonObject["convertibleTermProperty"]["@language"]
                : typeof $jsonObject["convertibleTermProperty"]["@type"] !==
                    "undefined"
                  ? dataFactory.namedNode(
                      $jsonObject["convertibleTermProperty"]["@type"],
                    )
                  : undefined,
            )
          : dataFactory.blankNode(
              $jsonObject["convertibleTermProperty"]["@id"].substring(2),
            );
    const convertibleTermSetProperty = $jsonObject[
      "convertibleTermSetProperty"
    ].map((item) =>
      item.termType === "NamedNode"
        ? dataFactory.namedNode(item["@id"])
        : item.termType === "Literal"
          ? dataFactory.literal(
              item["@value"],
              typeof item["@language"] !== "undefined"
                ? item["@language"]
                : typeof item["@type"] !== "undefined"
                  ? dataFactory.namedNode(item["@type"])
                  : undefined,
            )
          : dataFactory.blankNode(item["@id"].substring(2)),
    );
    return Either.of({
      $identifier,
      convertibleIriNonEmptySetProperty,
      convertibleIriOptionProperty,
      convertibleIriProperty,
      convertibleIriSetProperty,
      convertibleLiteralNonEmptySetProperty,
      convertibleLiteralOptionProperty,
      convertibleLiteralProperty,
      convertibleLiteralSetProperty,
      convertibleTermNonEmptySetProperty,
      convertibleTermOptionProperty,
      convertibleTermProperty,
      convertibleTermSetProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, ConvertibleTypePropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ConvertibleTypePropertiesClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ConvertibleTypePropertiesClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleIriNonEmptySetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleIriOptionProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleIriProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleIriSetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleLiteralNonEmptySetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleLiteralOptionProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleLiteralProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleLiteralSetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleTermNonEmptySetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleTermOptionProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleTermSetProperty`,
          type: "Control",
        },
      ],
      label: "ConvertibleTypePropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("ConvertibleTypePropertiesClass"),
      convertibleIriNonEmptySetProperty: z
        .object({ "@id": z.string().min(1) })
        .array()
        .nonempty()
        .min(1),
      convertibleIriOptionProperty: z
        .object({ "@id": z.string().min(1) })
        .optional(),
      convertibleIriProperty: z.object({ "@id": z.string().min(1) }),
      convertibleIriSetProperty: z
        .object({ "@id": z.string().min(1) })
        .array()
        .default(() => []),
      convertibleLiteralNonEmptySetProperty: z
        .object({
          "@language": z.string().optional(),
          "@type": z.string().optional(),
          "@value": z.string(),
        })
        .array()
        .nonempty()
        .min(1),
      convertibleLiteralOptionProperty: z
        .object({
          "@language": z.string().optional(),
          "@type": z.string().optional(),
          "@value": z.string(),
        })
        .optional(),
      convertibleLiteralProperty: z.object({
        "@language": z.string().optional(),
        "@type": z.string().optional(),
        "@value": z.string(),
      }),
      convertibleLiteralSetProperty: z
        .object({
          "@language": z.string().optional(),
          "@type": z.string().optional(),
          "@value": z.string(),
        })
        .array()
        .default(() => []),
      convertibleTermNonEmptySetProperty: z
        .discriminatedUnion("termType", [
          z.object({
            "@id": z.string().min(1),
            termType: z.literal("BlankNode"),
          }),
          z.object({
            "@language": z.string().optional(),
            "@type": z.string().optional(),
            "@value": z.string(),
            termType: z.literal("Literal"),
          }),
          z.object({
            "@id": z.string().min(1),
            termType: z.literal("NamedNode"),
          }),
        ])
        .array()
        .nonempty()
        .min(1),
      convertibleTermOptionProperty: z
        .discriminatedUnion("termType", [
          z.object({
            "@id": z.string().min(1),
            termType: z.literal("BlankNode"),
          }),
          z.object({
            "@language": z.string().optional(),
            "@type": z.string().optional(),
            "@value": z.string(),
            termType: z.literal("Literal"),
          }),
          z.object({
            "@id": z.string().min(1),
            termType: z.literal("NamedNode"),
          }),
        ])
        .optional(),
      convertibleTermProperty: z.discriminatedUnion("termType", [
        z.object({
          "@id": z.string().min(1),
          termType: z.literal("BlankNode"),
        }),
        z.object({
          "@language": z.string().optional(),
          "@type": z.string().optional(),
          "@value": z.string(),
          termType: z.literal("Literal"),
        }),
        z.object({
          "@id": z.string().min(1),
          termType: z.literal("NamedNode"),
        }),
      ]),
      convertibleTermSetProperty: z
        .discriminatedUnion("termType", [
          z.object({
            "@id": z.string().min(1),
            termType: z.literal("BlankNode"),
          }),
          z.object({
            "@language": z.string().optional(),
            "@type": z.string().optional(),
            "@value": z.string(),
            termType: z.literal("Literal"),
          }),
          z.object({
            "@id": z.string().min(1),
            termType: z.literal("NamedNode"),
          }),
        ])
        .array()
        .default(() => []),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ConvertibleTypePropertiesClass";
    readonly convertibleIriNonEmptySetProperty: readonly {
      readonly "@id": string;
    }[];
    readonly convertibleIriOptionProperty?: { readonly "@id": string };
    readonly convertibleIriProperty: { readonly "@id": string };
    readonly convertibleIriSetProperty?: readonly { readonly "@id": string }[];
    readonly convertibleLiteralNonEmptySetProperty: readonly {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    }[];
    readonly convertibleLiteralOptionProperty?: {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    };
    readonly convertibleLiteralProperty: {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    };
    readonly convertibleLiteralSetProperty?: readonly {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    }[];
    readonly convertibleTermNonEmptySetProperty: readonly (
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly "@type"?: string;
          readonly "@value": string;
          readonly termType: "Literal";
        }
    )[];
    readonly convertibleTermOptionProperty?:
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly "@type"?: string;
          readonly "@value": string;
          readonly termType: "Literal";
        };
    readonly convertibleTermProperty:
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly "@type"?: string;
          readonly "@value": string;
          readonly termType: "Literal";
        };
    readonly convertibleTermSetProperty?: readonly (
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly "@type"?: string;
          readonly "@value": string;
          readonly termType: "Literal";
        }
    )[];
  };

  export function isConvertibleTypePropertiesClass(
    object: $Object,
  ): object is ConvertibleTypePropertiesClass {
    switch (object.$type) {
      case "ConvertibleTypePropertiesClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, ConvertibleTypePropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return ConvertibleTypePropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ConvertibleTypePropertiesClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      convertibleIriNonEmptySetProperty: NonEmptyList<NamedNode>;
      convertibleIriOptionProperty: Maybe<NamedNode>;
      convertibleIriProperty: NamedNode;
      convertibleIriSetProperty: readonly NamedNode[];
      convertibleLiteralNonEmptySetProperty: NonEmptyList<Literal>;
      convertibleLiteralOptionProperty: Maybe<Literal>;
      convertibleLiteralProperty: Literal;
      convertibleLiteralSetProperty: readonly Literal[];
      convertibleTermNonEmptySetProperty: NonEmptyList<
        BlankNode | Literal | NamedNode
      >;
      convertibleTermOptionProperty: Maybe<BlankNode | Literal | NamedNode>;
      convertibleTermProperty: BlankNode | Literal | NamedNode;
      convertibleTermSetProperty: readonly (BlankNode | Literal | NamedNode)[];
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/ConvertibleTypePropertiesClass":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  ConvertibleTypePropertiesClass.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ConvertibleTypePropertiesClass)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, ConvertibleTypePropertiesClass.$Identifier>(
        $parameters.resource
          .identifier as ConvertibleTypePropertiesClass.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, Resource.Values<Resource.TermValue>>(
          $parameters.resource.values(
            $schema.properties.convertibleIriNonEmptySetProperty.identifier,
            {
              unique: true,
            },
          ),
        )
          .chain((values) => values.chainMap((value) => value.toIri()))
          .chain((values) =>
            NonEmptyList.fromArray(values.toArray()).toEither(
              new Error(
                `${Resource.Identifier.toString($parameters.resource.identifier)} is an empty set`,
              ),
            ),
          )
          .map((valuesArray) =>
            Resource.Values.fromValue({
              focusResource: $parameters.resource,
              predicate:
                ConvertibleTypePropertiesClass.$schema.properties
                  .convertibleIriNonEmptySetProperty.identifier,
              value: valuesArray,
            }),
          )
          .chain((values) => values.head())
          .chain((convertibleIriNonEmptySetProperty) =>
            Either.of<Error, Resource.Values<Resource.TermValue>>(
              $parameters.resource.values(
                $schema.properties.convertibleIriOptionProperty.identifier,
                { unique: true },
              ),
            )
              .chain((values) => values.chainMap((value) => value.toIri()))
              .map((values) =>
                values.length > 0
                  ? values.map((value) => Maybe.of(value))
                  : Resource.Values.fromValue<Maybe<NamedNode>>({
                      focusResource: $parameters.resource,
                      predicate:
                        ConvertibleTypePropertiesClass.$schema.properties
                          .convertibleIriOptionProperty.identifier,
                      value: Maybe.empty(),
                    }),
              )
              .chain((values) => values.head())
              .chain((convertibleIriOptionProperty) =>
                Either.of<Error, Resource.Values<Resource.TermValue>>(
                  $parameters.resource.values(
                    $schema.properties.convertibleIriProperty.identifier,
                    { unique: true },
                  ),
                )
                  .chain((values) => values.chainMap((value) => value.toIri()))
                  .chain((values) => values.head())
                  .chain((convertibleIriProperty) =>
                    Either.of<Error, Resource.Values<Resource.TermValue>>(
                      $parameters.resource.values(
                        $schema.properties.convertibleIriSetProperty.identifier,
                        {
                          unique: true,
                        },
                      ),
                    )
                      .chain((values) =>
                        values.chainMap((value) => value.toIri()),
                      )
                      .map((values) => values.toArray())
                      .map((valuesArray) =>
                        Resource.Values.fromValue({
                          focusResource: $parameters.resource,
                          predicate:
                            ConvertibleTypePropertiesClass.$schema.properties
                              .convertibleIriSetProperty.identifier,
                          value: valuesArray,
                        }),
                      )
                      .chain((values) => values.head())
                      .chain((convertibleIriSetProperty) =>
                        Either.of<Error, Resource.Values<Resource.TermValue>>(
                          $parameters.resource.values(
                            $schema.properties
                              .convertibleLiteralNonEmptySetProperty.identifier,
                            {
                              unique: true,
                            },
                          ),
                        )
                          .chain((values) =>
                            $fromRdfPreferredLanguages({
                              focusResource: $parameters.resource,
                              predicate:
                                ConvertibleTypePropertiesClass.$schema
                                  .properties
                                  .convertibleLiteralNonEmptySetProperty
                                  .identifier,
                              preferredLanguages:
                                $parameters.preferredLanguages,
                              values,
                            }),
                          )
                          .chain((values) =>
                            values.chainMap((value) => value.toLiteral()),
                          )
                          .chain((values) =>
                            NonEmptyList.fromArray(values.toArray()).toEither(
                              new Error(
                                `${Resource.Identifier.toString($parameters.resource.identifier)} is an empty set`,
                              ),
                            ),
                          )
                          .map((valuesArray) =>
                            Resource.Values.fromValue({
                              focusResource: $parameters.resource,
                              predicate:
                                ConvertibleTypePropertiesClass.$schema
                                  .properties
                                  .convertibleLiteralNonEmptySetProperty
                                  .identifier,
                              value: valuesArray,
                            }),
                          )
                          .chain((values) => values.head())
                          .chain((convertibleLiteralNonEmptySetProperty) =>
                            Either.of<
                              Error,
                              Resource.Values<Resource.TermValue>
                            >(
                              $parameters.resource.values(
                                $schema.properties
                                  .convertibleLiteralOptionProperty.identifier,
                                {
                                  unique: true,
                                },
                              ),
                            )
                              .chain((values) =>
                                $fromRdfPreferredLanguages({
                                  focusResource: $parameters.resource,
                                  predicate:
                                    ConvertibleTypePropertiesClass.$schema
                                      .properties
                                      .convertibleLiteralOptionProperty
                                      .identifier,
                                  preferredLanguages:
                                    $parameters.preferredLanguages,
                                  values,
                                }),
                              )
                              .chain((values) =>
                                values.chainMap((value) => value.toLiteral()),
                              )
                              .map((values) =>
                                values.length > 0
                                  ? values.map((value) => Maybe.of(value))
                                  : Resource.Values.fromValue<Maybe<Literal>>({
                                      focusResource: $parameters.resource,
                                      predicate:
                                        ConvertibleTypePropertiesClass.$schema
                                          .properties
                                          .convertibleLiteralOptionProperty
                                          .identifier,
                                      value: Maybe.empty(),
                                    }),
                              )
                              .chain((values) => values.head())
                              .chain((convertibleLiteralOptionProperty) =>
                                Either.of<
                                  Error,
                                  Resource.Values<Resource.TermValue>
                                >(
                                  $parameters.resource.values(
                                    $schema.properties
                                      .convertibleLiteralProperty.identifier,
                                    {
                                      unique: true,
                                    },
                                  ),
                                )
                                  .chain((values) =>
                                    $fromRdfPreferredLanguages({
                                      focusResource: $parameters.resource,
                                      predicate:
                                        ConvertibleTypePropertiesClass.$schema
                                          .properties.convertibleLiteralProperty
                                          .identifier,
                                      preferredLanguages:
                                        $parameters.preferredLanguages,
                                      values,
                                    }),
                                  )
                                  .chain((values) =>
                                    values.chainMap((value) =>
                                      value.toLiteral(),
                                    ),
                                  )
                                  .chain((values) => values.head())
                                  .chain((convertibleLiteralProperty) =>
                                    Either.of<
                                      Error,
                                      Resource.Values<Resource.TermValue>
                                    >(
                                      $parameters.resource.values(
                                        $schema.properties
                                          .convertibleLiteralSetProperty
                                          .identifier,
                                        {
                                          unique: true,
                                        },
                                      ),
                                    )
                                      .chain((values) =>
                                        $fromRdfPreferredLanguages({
                                          focusResource: $parameters.resource,
                                          predicate:
                                            ConvertibleTypePropertiesClass
                                              .$schema.properties
                                              .convertibleLiteralSetProperty
                                              .identifier,
                                          preferredLanguages:
                                            $parameters.preferredLanguages,
                                          values,
                                        }),
                                      )
                                      .chain((values) =>
                                        values.chainMap((value) =>
                                          value.toLiteral(),
                                        ),
                                      )
                                      .map((values) => values.toArray())
                                      .map((valuesArray) =>
                                        Resource.Values.fromValue({
                                          focusResource: $parameters.resource,
                                          predicate:
                                            ConvertibleTypePropertiesClass
                                              .$schema.properties
                                              .convertibleLiteralSetProperty
                                              .identifier,
                                          value: valuesArray,
                                        }),
                                      )
                                      .chain((values) => values.head())
                                      .chain((convertibleLiteralSetProperty) =>
                                        Either.of<
                                          Error,
                                          Resource.Values<Resource.TermValue>
                                        >(
                                          $parameters.resource.values(
                                            $schema.properties
                                              .convertibleTermNonEmptySetProperty
                                              .identifier,
                                            { unique: true },
                                          ),
                                        )
                                          .chain((values) =>
                                            values.chainMap((value) =>
                                              Either.of<
                                                Error,
                                                BlankNode | Literal | NamedNode
                                              >(value.toTerm()),
                                            ),
                                          )
                                          .chain((values) =>
                                            NonEmptyList.fromArray(
                                              values.toArray(),
                                            ).toEither(
                                              new Error(
                                                `${Resource.Identifier.toString($parameters.resource.identifier)} is an empty set`,
                                              ),
                                            ),
                                          )
                                          .map((valuesArray) =>
                                            Resource.Values.fromValue({
                                              focusResource:
                                                $parameters.resource,
                                              predicate:
                                                ConvertibleTypePropertiesClass
                                                  .$schema.properties
                                                  .convertibleTermNonEmptySetProperty
                                                  .identifier,
                                              value: valuesArray,
                                            }),
                                          )
                                          .chain((values) => values.head())
                                          .chain(
                                            (
                                              convertibleTermNonEmptySetProperty,
                                            ) =>
                                              Either.of<
                                                Error,
                                                Resource.Values<Resource.TermValue>
                                              >(
                                                $parameters.resource.values(
                                                  $schema.properties
                                                    .convertibleTermOptionProperty
                                                    .identifier,
                                                  { unique: true },
                                                ),
                                              )
                                                .chain((values) =>
                                                  values.chainMap((value) =>
                                                    Either.of<
                                                      Error,
                                                      | BlankNode
                                                      | Literal
                                                      | NamedNode
                                                    >(value.toTerm()),
                                                  ),
                                                )
                                                .map((values) =>
                                                  values.length > 0
                                                    ? values.map((value) =>
                                                        Maybe.of(value),
                                                      )
                                                    : Resource.Values.fromValue<
                                                        Maybe<
                                                          | BlankNode
                                                          | Literal
                                                          | NamedNode
                                                        >
                                                      >({
                                                        focusResource:
                                                          $parameters.resource,
                                                        predicate:
                                                          ConvertibleTypePropertiesClass
                                                            .$schema.properties
                                                            .convertibleTermOptionProperty
                                                            .identifier,
                                                        value: Maybe.empty(),
                                                      }),
                                                )
                                                .chain((values) =>
                                                  values.head(),
                                                )
                                                .chain(
                                                  (
                                                    convertibleTermOptionProperty,
                                                  ) =>
                                                    Either.of<
                                                      Error,
                                                      Resource.Values<Resource.TermValue>
                                                    >(
                                                      $parameters.resource.values(
                                                        $schema.properties
                                                          .convertibleTermProperty
                                                          .identifier,
                                                        {
                                                          unique: true,
                                                        },
                                                      ),
                                                    )
                                                      .chain((values) =>
                                                        values.chainMap(
                                                          (value) =>
                                                            Either.of<
                                                              Error,
                                                              | BlankNode
                                                              | Literal
                                                              | NamedNode
                                                            >(value.toTerm()),
                                                        ),
                                                      )
                                                      .chain((values) =>
                                                        values.head(),
                                                      )
                                                      .chain(
                                                        (
                                                          convertibleTermProperty,
                                                        ) =>
                                                          Either.of<
                                                            Error,
                                                            Resource.Values<Resource.TermValue>
                                                          >(
                                                            $parameters.resource.values(
                                                              $schema.properties
                                                                .convertibleTermSetProperty
                                                                .identifier,
                                                              { unique: true },
                                                            ),
                                                          )
                                                            .chain((values) =>
                                                              values.chainMap(
                                                                (value) =>
                                                                  Either.of<
                                                                    Error,
                                                                    | BlankNode
                                                                    | Literal
                                                                    | NamedNode
                                                                  >(
                                                                    value.toTerm(),
                                                                  ),
                                                              ),
                                                            )
                                                            .map((values) =>
                                                              values.toArray(),
                                                            )
                                                            .map(
                                                              (valuesArray) =>
                                                                Resource.Values.fromValue(
                                                                  {
                                                                    focusResource:
                                                                      $parameters.resource,
                                                                    predicate:
                                                                      ConvertibleTypePropertiesClass
                                                                        .$schema
                                                                        .properties
                                                                        .convertibleTermSetProperty
                                                                        .identifier,
                                                                    value:
                                                                      valuesArray,
                                                                  },
                                                                ),
                                                            )
                                                            .chain((values) =>
                                                              values.head(),
                                                            )
                                                            .map(
                                                              (
                                                                convertibleTermSetProperty,
                                                              ) => ({
                                                                $identifier,
                                                                convertibleIriNonEmptySetProperty,
                                                                convertibleIriOptionProperty,
                                                                convertibleIriProperty,
                                                                convertibleIriSetProperty,
                                                                convertibleLiteralNonEmptySetProperty,
                                                                convertibleLiteralOptionProperty,
                                                                convertibleLiteralProperty,
                                                                convertibleLiteralSetProperty,
                                                                convertibleTermNonEmptySetProperty,
                                                                convertibleTermOptionProperty,
                                                                convertibleTermProperty,
                                                                convertibleTermSetProperty,
                                                              }),
                                                            ),
                                                      ),
                                                ),
                                          ),
                                      ),
                                  ),
                              ),
                          ),
                      ),
                  ),
              ),
          ),
      ),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["ConvertibleTypePropertiesClass"],
        }),
      },
      convertibleIriNonEmptySetProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Set" as const,
          item: () => ({ kind: "NamedNode" as const }),
          minCount: 1,
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/convertibleIriNonEmptySetProperty",
        ),
      },
      convertibleIriOptionProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({ kind: "NamedNode" as const }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/convertibleIriOptionProperty",
        ),
      },
      convertibleIriProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "NamedNode" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/convertibleIriProperty",
        ),
      },
      convertibleIriSetProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Set" as const,
          item: () => ({ kind: "NamedNode" as const }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/convertibleIriSetProperty",
        ),
      },
      convertibleLiteralNonEmptySetProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Set" as const,
          item: () => ({ kind: "Literal" as const }),
          minCount: 1,
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/convertibleLiteralNonEmptySetProperty",
        ),
      },
      convertibleLiteralOptionProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({ kind: "Literal" as const }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/convertibleLiteralOptionProperty",
        ),
      },
      convertibleLiteralProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "Literal" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/convertibleLiteralProperty",
        ),
      },
      convertibleLiteralSetProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Set" as const,
          item: () => ({ kind: "Literal" as const }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/convertibleLiteralSetProperty",
        ),
      },
      convertibleTermNonEmptySetProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Set" as const,
          item: () => ({
            kind: "Term" as const,
            nodeKinds: [
              "BlankNode" as const,
              "Literal" as const,
              "NamedNode" as const,
            ],
          }),
          minCount: 1,
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/convertibleTermNonEmptySetProperty",
        ),
      },
      convertibleTermOptionProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Maybe" as const,
          item: () => ({
            kind: "Term" as const,
            nodeKinds: [
              "BlankNode" as const,
              "Literal" as const,
              "NamedNode" as const,
            ],
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/convertibleTermOptionProperty",
        ),
      },
      convertibleTermProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Term" as const,
          nodeKinds: [
            "BlankNode" as const,
            "Literal" as const,
            "NamedNode" as const,
          ],
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/convertibleTermProperty",
        ),
      },
      convertibleTermSetProperty: {
        kind: "Shacl" as const,
        type: () => ({
          kind: "Set" as const,
          item: () => ({
            kind: "Term" as const,
            nodeKinds: [
              "BlankNode" as const,
              "Literal" as const,
              "NamedNode" as const,
            ],
          }),
        }),
        identifier: dataFactory.namedNode(
          "http://example.com/convertibleTermSetProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ConvertibleTypePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConvertibleTypePropertiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          ConvertibleTypePropertiesClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ConvertibleTypePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConvertibleTypePropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("convertibleTypePropertiesClass");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "convertibleTypePropertiesClass")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "convertibleTypePropertiesClass")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "convertibleTypePropertiesClass")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleIriNonEmptySetProperty`,
        ),
        predicate:
          ConvertibleTypePropertiesClass.$schema.properties
            .convertibleIriNonEmptySetProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleIriOptionProperty`,
        ),
        predicate:
          ConvertibleTypePropertiesClass.$schema.properties
            .convertibleIriOptionProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleIriProperty`,
        ),
        predicate:
          ConvertibleTypePropertiesClass.$schema.properties
            .convertibleIriProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleIriSetProperty`,
        ),
        predicate:
          ConvertibleTypePropertiesClass.$schema.properties
            .convertibleIriSetProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleLiteralNonEmptySetProperty`,
        ),
        predicate:
          ConvertibleTypePropertiesClass.$schema.properties
            .convertibleLiteralNonEmptySetProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleLiteralOptionProperty`,
        ),
        predicate:
          ConvertibleTypePropertiesClass.$schema.properties
            .convertibleLiteralOptionProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleLiteralProperty`,
        ),
        predicate:
          ConvertibleTypePropertiesClass.$schema.properties
            .convertibleLiteralProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleLiteralSetProperty`,
        ),
        predicate:
          ConvertibleTypePropertiesClass.$schema.properties
            .convertibleLiteralSetProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleTermNonEmptySetProperty`,
        ),
        predicate:
          ConvertibleTypePropertiesClass.$schema.properties
            .convertibleTermNonEmptySetProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleTermOptionProperty`,
        ),
        predicate:
          ConvertibleTypePropertiesClass.$schema.properties
            .convertibleTermOptionProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleTermProperty`,
        ),
        predicate:
          ConvertibleTypePropertiesClass.$schema.properties
            .convertibleTermProperty.identifier,
        subject: subject,
      },
    ]);
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleTermSetProperty`,
        ),
        predicate:
          ConvertibleTypePropertiesClass.$schema.properties
            .convertibleTermSetProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ConvertibleTypePropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("convertibleTypePropertiesClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "convertibleTypePropertiesClass")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ConvertibleTypePropertiesClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "convertibleTypePropertiesClass")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            ConvertibleTypePropertiesClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass"),
        }),
      );
    }
    patterns = patterns.concat(
      $setSparqlWherePatterns<$NamedNodeFilter, $NamedNodeSchema>(
        $namedNodeSparqlWherePatterns,
      )({
        filter: parameters?.filter?.convertibleIriNonEmptySetProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "convertibleTypePropertiesClass")
                  }ConvertibleIriNonEmptySetProperty`,
                ),
                predicate:
                  ConvertibleTypePropertiesClass.$schema.properties
                    .convertibleIriNonEmptySetProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ConvertibleTypePropertiesClass.$schema.properties.convertibleIriNonEmptySetProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleIriNonEmptySetProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "convertibleTypePropertiesClass")
        }ConvertibleIriNonEmptySetProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<$NamedNodeFilter, $NamedNodeSchema>(
        $namedNodeSparqlWherePatterns,
      )({
        filter: parameters?.filter?.convertibleIriOptionProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "convertibleTypePropertiesClass")
                  }ConvertibleIriOptionProperty`,
                ),
                predicate:
                  ConvertibleTypePropertiesClass.$schema.properties
                    .convertibleIriOptionProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ConvertibleTypePropertiesClass.$schema.properties.convertibleIriOptionProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleIriOptionProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "convertibleTypePropertiesClass")
        }ConvertibleIriOptionProperty`,
      }),
    );
    patterns = patterns.concat(
      $namedNodeSparqlWherePatterns({
        filter: parameters?.filter?.convertibleIriProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "convertibleTypePropertiesClass")
                  }ConvertibleIriProperty`,
                ),
                predicate:
                  ConvertibleTypePropertiesClass.$schema.properties
                    .convertibleIriProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ConvertibleTypePropertiesClass.$schema.properties.convertibleIriProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleIriProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "convertibleTypePropertiesClass")
        }ConvertibleIriProperty`,
      }),
    );
    patterns = patterns.concat(
      $setSparqlWherePatterns<$NamedNodeFilter, $NamedNodeSchema>(
        $namedNodeSparqlWherePatterns,
      )({
        filter: parameters?.filter?.convertibleIriSetProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "convertibleTypePropertiesClass")
                  }ConvertibleIriSetProperty`,
                ),
                predicate:
                  ConvertibleTypePropertiesClass.$schema.properties
                    .convertibleIriSetProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ConvertibleTypePropertiesClass.$schema.properties.convertibleIriSetProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleIriSetProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "convertibleTypePropertiesClass")
        }ConvertibleIriSetProperty`,
      }),
    );
    patterns = patterns.concat(
      $setSparqlWherePatterns<$LiteralFilter, $LiteralSchema>(
        $literalSparqlWherePatterns,
      )({
        filter: parameters?.filter?.convertibleLiteralNonEmptySetProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "convertibleTypePropertiesClass")
                  }ConvertibleLiteralNonEmptySetProperty`,
                ),
                predicate:
                  ConvertibleTypePropertiesClass.$schema.properties
                    .convertibleLiteralNonEmptySetProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ConvertibleTypePropertiesClass.$schema.properties.convertibleLiteralNonEmptySetProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleLiteralNonEmptySetProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "convertibleTypePropertiesClass")
        }ConvertibleLiteralNonEmptySetProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<$LiteralFilter, $LiteralSchema>(
        $literalSparqlWherePatterns,
      )({
        filter: parameters?.filter?.convertibleLiteralOptionProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "convertibleTypePropertiesClass")
                  }ConvertibleLiteralOptionProperty`,
                ),
                predicate:
                  ConvertibleTypePropertiesClass.$schema.properties
                    .convertibleLiteralOptionProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ConvertibleTypePropertiesClass.$schema.properties.convertibleLiteralOptionProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleLiteralOptionProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "convertibleTypePropertiesClass")
        }ConvertibleLiteralOptionProperty`,
      }),
    );
    patterns = patterns.concat(
      $literalSparqlWherePatterns({
        filter: parameters?.filter?.convertibleLiteralProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "convertibleTypePropertiesClass")
                  }ConvertibleLiteralProperty`,
                ),
                predicate:
                  ConvertibleTypePropertiesClass.$schema.properties
                    .convertibleLiteralProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ConvertibleTypePropertiesClass.$schema.properties.convertibleLiteralProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleLiteralProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "convertibleTypePropertiesClass")
        }ConvertibleLiteralProperty`,
      }),
    );
    patterns = patterns.concat(
      $setSparqlWherePatterns<$LiteralFilter, $LiteralSchema>(
        $literalSparqlWherePatterns,
      )({
        filter: parameters?.filter?.convertibleLiteralSetProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "convertibleTypePropertiesClass")
                  }ConvertibleLiteralSetProperty`,
                ),
                predicate:
                  ConvertibleTypePropertiesClass.$schema.properties
                    .convertibleLiteralSetProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ConvertibleTypePropertiesClass.$schema.properties.convertibleLiteralSetProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleLiteralSetProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "convertibleTypePropertiesClass")
        }ConvertibleLiteralSetProperty`,
      }),
    );
    patterns = patterns.concat(
      $setSparqlWherePatterns<$TermFilter, $TermSchema>(
        $termSparqlWherePatterns,
      )({
        filter: parameters?.filter?.convertibleTermNonEmptySetProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "convertibleTypePropertiesClass")
                  }ConvertibleTermNonEmptySetProperty`,
                ),
                predicate:
                  ConvertibleTypePropertiesClass.$schema.properties
                    .convertibleTermNonEmptySetProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ConvertibleTypePropertiesClass.$schema.properties.convertibleTermNonEmptySetProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleTermNonEmptySetProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "convertibleTypePropertiesClass")
        }ConvertibleTermNonEmptySetProperty`,
      }),
    );
    patterns = patterns.concat(
      $maybeSparqlWherePatterns<$TermFilter, $TermSchema>(
        $termSparqlWherePatterns,
      )({
        filter: parameters?.filter?.convertibleTermOptionProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "convertibleTypePropertiesClass")
                  }ConvertibleTermOptionProperty`,
                ),
                predicate:
                  ConvertibleTypePropertiesClass.$schema.properties
                    .convertibleTermOptionProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ConvertibleTypePropertiesClass.$schema.properties.convertibleTermOptionProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleTermOptionProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "convertibleTypePropertiesClass")
        }ConvertibleTermOptionProperty`,
      }),
    );
    patterns = patterns.concat(
      $termSparqlWherePatterns({
        filter: parameters?.filter?.convertibleTermProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "convertibleTypePropertiesClass")
                  }ConvertibleTermProperty`,
                ),
                predicate:
                  ConvertibleTypePropertiesClass.$schema.properties
                    .convertibleTermProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ConvertibleTypePropertiesClass.$schema.properties.convertibleTermProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleTermProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "convertibleTypePropertiesClass")
        }ConvertibleTermProperty`,
      }),
    );
    patterns = patterns.concat(
      $setSparqlWherePatterns<$TermFilter, $TermSchema>(
        $termSparqlWherePatterns,
      )({
        filter: parameters?.filter?.convertibleTermSetProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "convertibleTypePropertiesClass")
                  }ConvertibleTermSetProperty`,
                ),
                predicate:
                  ConvertibleTypePropertiesClass.$schema.properties
                    .convertibleTermSetProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ConvertibleTypePropertiesClass.$schema.properties.convertibleTermSetProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "convertibleTypePropertiesClass")
          }ConvertibleTermSetProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "convertibleTypePropertiesClass")
        }ConvertibleTermSetProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Base interface for other node shapes.
 */

export interface BaseInterfaceWithProperties {
  readonly $identifier: BaseInterfaceWithPropertiesStatic.$Identifier;
  readonly $type:
    | "BaseInterfaceWithProperties"
    | "BaseInterfaceWithoutProperties"
    | "ConcreteChildInterface"
    | "ConcreteParentInterface";
  readonly baseInterfaceWithPropertiesProperty: string;
}

export namespace BaseInterfaceWithPropertiesStatic {
  export function $create(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly baseInterfaceWithPropertiesProperty: string;
  }): BaseInterfaceWithProperties {
    let $identifier: BaseInterfaceWithPropertiesStatic.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }
    const $type = "BaseInterfaceWithProperties" as const;
    const baseInterfaceWithPropertiesProperty =
      parameters.baseInterfaceWithPropertiesProperty;
    return { $identifier, $type, baseInterfaceWithPropertiesProperty };
  }

  export function $equals(
    left: BaseInterfaceWithProperties,
    right: BaseInterfaceWithProperties,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.baseInterfaceWithPropertiesProperty,
          right.baseInterfaceWithPropertiesProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "baseInterfaceWithPropertiesProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  export function $hash<HasherT extends $Hasher>(
    _baseInterfaceWithProperties: BaseInterfaceWithProperties,
    _hasher: HasherT,
  ): HasherT {
    BaseInterfaceWithPropertiesStatic.$hashShaclProperties(
      _baseInterfaceWithProperties,
      _hasher,
    );
    _hasher.update(_baseInterfaceWithProperties.$identifier.value);
    _hasher.update(_baseInterfaceWithProperties.$type);
    return _hasher;
  }

  export function $hashShaclProperties<HasherT extends $Hasher>(
    _baseInterfaceWithProperties: BaseInterfaceWithProperties,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _baseInterfaceWithProperties.baseInterfaceWithPropertiesProperty,
    );
    return _hasher;
  }

  export function $filter(
    filter: BaseInterfaceWithPropertiesStatic.$Filter,
    value: BaseInterfaceWithProperties,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.baseInterfaceWithPropertiesProperty !== "undefined" &&
      !$filterString(
        filter.baseInterfaceWithPropertiesProperty,
        value.baseInterfaceWithPropertiesProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly baseInterfaceWithPropertiesProperty?: $StringFilter;
  };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/BaseInterfaceWithProperties",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      $type:
        | "BaseInterfaceWithProperties"
        | "BaseInterfaceWithoutProperties"
        | "ConcreteChildInterface"
        | "ConcreteParentInterface";
      baseInterfaceWithPropertiesProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "BaseInterfaceWithProperties" as const;
    const baseInterfaceWithPropertiesProperty =
      $jsonObject["baseInterfaceWithPropertiesProperty"];
    return Either.of({
      $identifier,
      $type,
      baseInterfaceWithPropertiesProperty,
    });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, BaseInterfaceWithProperties> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "BaseInterfaceWithProperties" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/baseInterfaceWithPropertiesProperty`,
          type: "Control",
        },
      ],
      label: "BaseInterfaceWithProperties",
      type: "Group",
    };
  }

  export function $toJson(
    _baseInterfaceWithProperties: BaseInterfaceWithProperties,
  ): BaseInterfaceWithPropertiesStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _baseInterfaceWithProperties.$identifier.termType === "BlankNode"
            ? `_:${_baseInterfaceWithProperties.$identifier.value}`
            : _baseInterfaceWithProperties.$identifier.value,
        $type: _baseInterfaceWithProperties.$type,
        baseInterfaceWithPropertiesProperty:
          _baseInterfaceWithProperties.baseInterfaceWithPropertiesProperty,
      } satisfies BaseInterfaceWithPropertiesStatic.$Json),
    );
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.enum([
        "BaseInterfaceWithProperties",
        "BaseInterfaceWithoutProperties",
        "ConcreteChildInterface",
        "ConcreteParentInterface",
      ]),
      baseInterfaceWithPropertiesProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type:
      | "BaseInterfaceWithProperties"
      | "BaseInterfaceWithoutProperties"
      | "ConcreteChildInterface"
      | "ConcreteParentInterface";
    readonly baseInterfaceWithPropertiesProperty: string;
  };

  export function isBaseInterfaceWithProperties(
    object: $Object,
  ): object is BaseInterfaceWithProperties {
    switch (object.$type) {
      case "BaseInterfaceWithoutProperties":
      case "ConcreteChildInterface":
      case "ConcreteParentInterface":
      case "BaseInterfaceWithProperties":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, BaseInterfaceWithProperties> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return BaseInterfaceWithPropertiesStatic.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      $type:
        | "BaseInterfaceWithProperties"
        | "BaseInterfaceWithoutProperties"
        | "ConcreteChildInterface"
        | "ConcreteParentInterface";
      baseInterfaceWithPropertiesProperty: string;
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/BaseInterfaceWithProperties":
                case "http://example.com/BaseInterfaceWithoutProperties":
                case "http://example.com/ConcreteParentInterface":
                case "http://example.com/ConcreteChildInterface":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  BaseInterfaceWithPropertiesStatic.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/BaseInterfaceWithProperties)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, BaseInterfaceWithPropertiesStatic.$Identifier>(
        $parameters.resource
          .identifier as BaseInterfaceWithPropertiesStatic.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, "BaseInterfaceWithProperties">(
          "BaseInterfaceWithProperties" as const,
        ).chain(($type) =>
          Either.of<Error, Resource.Values<Resource.TermValue>>(
            $parameters.resource.values(
              $schema.properties.baseInterfaceWithPropertiesProperty.identifier,
              {
                unique: true,
              },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  BaseInterfaceWithPropertiesStatic.$schema.properties
                    .baseInterfaceWithPropertiesProperty.identifier,
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((baseInterfaceWithPropertiesProperty) => ({
              $identifier,
              $type,
              baseInterfaceWithPropertiesProperty,
            })),
        ),
      ),
    );
  }

  export function $toRdf(
    _baseInterfaceWithProperties: BaseInterfaceWithProperties,
    options?: {
      ignoreRdfType?: boolean;
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(
      _baseInterfaceWithProperties.$identifier,
    );
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/BaseInterfaceWithProperties"),
        options?.graph,
      );
    }
    resource.add(
      BaseInterfaceWithPropertiesStatic.$schema.properties
        .baseInterfaceWithPropertiesProperty.identifier,
      [
        $literalFactory.string(
          _baseInterfaceWithProperties.baseInterfaceWithPropertiesProperty,
        ),
      ],
      options?.graph,
    );
    return resource;
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          descendantValues: [
            "BaseInterfaceWithoutProperties",
            "ConcreteChildInterface",
            "ConcreteParentInterface",
          ],
          kind: "TypeDiscriminant" as const,
          ownValues: ["BaseInterfaceWithProperties"],
        }),
      },
      baseInterfaceWithPropertiesProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/baseInterfaceWithPropertiesProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: BaseInterfaceWithPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BaseInterfaceWithPropertiesStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          BaseInterfaceWithPropertiesStatic.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: BaseInterfaceWithPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BaseInterfaceWithPropertiesStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("baseInterfaceWithProperties");
    let triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "baseInterfaceWithProperties")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "baseInterfaceWithProperties")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "baseInterfaceWithProperties")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "baseInterfaceWithProperties")
          }BaseInterfaceWithPropertiesProperty`,
        ),
        predicate:
          BaseInterfaceWithPropertiesStatic.$schema.properties
            .baseInterfaceWithPropertiesProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: BaseInterfaceWithPropertiesStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("baseInterfaceWithProperties");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "baseInterfaceWithProperties")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        {
          type: "values" as const,
          values: [
            BaseInterfaceWithPropertiesStatic.$fromRdfType,
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[
              `?${
                parameters?.variablePrefix ??
                (subject.termType === "Variable"
                  ? subject.value
                  : "baseInterfaceWithProperties")
              }FromRdfType`
            ] = identifier as NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "baseInterfaceWithProperties")
            }FromRdfType`,
          ),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "baseInterfaceWithProperties")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            BaseInterfaceWithPropertiesStatic.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "baseInterfaceWithProperties"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.baseInterfaceWithPropertiesProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "baseInterfaceWithProperties")
                  }BaseInterfaceWithPropertiesProperty`,
                ),
                predicate:
                  BaseInterfaceWithPropertiesStatic.$schema.properties
                    .baseInterfaceWithPropertiesProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          BaseInterfaceWithPropertiesStatic.$schema.properties.baseInterfaceWithPropertiesProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "baseInterfaceWithProperties")
          }BaseInterfaceWithPropertiesProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "baseInterfaceWithProperties")
        }BaseInterfaceWithPropertiesProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Base interface for other node shapes. Put the base interface with properties above the base interface without.
 */

export interface BaseInterfaceWithoutProperties
  extends BaseInterfaceWithProperties {
  readonly $identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier;
  readonly $type:
    | "BaseInterfaceWithoutProperties"
    | "ConcreteChildInterface"
    | "ConcreteParentInterface";
}

export namespace BaseInterfaceWithoutPropertiesStatic {
  export function $create(
    parameters: {
      readonly $identifier?: (BlankNode | NamedNode) | string;
    } & Parameters<typeof BaseInterfaceWithPropertiesStatic.$create>[0],
  ): BaseInterfaceWithoutProperties {
    let $identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }
    const $type = "BaseInterfaceWithoutProperties" as const;
    return {
      ...BaseInterfaceWithPropertiesStatic.$create(parameters),
      $identifier,
      $type,
    };
  }

  export function $equals(
    left: BaseInterfaceWithoutProperties,
    right: BaseInterfaceWithoutProperties,
  ): $EqualsResult {
    return BaseInterfaceWithPropertiesStatic.$equals(left, right);
  }

  export function $hash<HasherT extends $Hasher>(
    _baseInterfaceWithoutProperties: BaseInterfaceWithoutProperties,
    _hasher: HasherT,
  ): HasherT {
    BaseInterfaceWithoutPropertiesStatic.$hashShaclProperties(
      _baseInterfaceWithoutProperties,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<HasherT extends $Hasher>(
    _baseInterfaceWithoutProperties: BaseInterfaceWithoutProperties,
    _hasher: HasherT,
  ): HasherT {
    BaseInterfaceWithPropertiesStatic.$hashShaclProperties(
      _baseInterfaceWithoutProperties,
      _hasher,
    );
    return _hasher;
  }

  export function $filter(
    filter: BaseInterfaceWithoutPropertiesStatic.$Filter,
    value: BaseInterfaceWithoutProperties,
  ): boolean {
    if (!BaseInterfaceWithPropertiesStatic.$filter(filter, value)) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
  } & BaseInterfaceWithPropertiesStatic.$Filter;

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/BaseInterfaceWithoutProperties",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      $type:
        | "BaseInterfaceWithoutProperties"
        | "ConcreteChildInterface"
        | "ConcreteParentInterface";
    } & $UnwrapR<
      ReturnType<typeof BaseInterfaceWithPropertiesStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "BaseInterfaceWithoutProperties" as const;
    return BaseInterfaceWithPropertiesStatic.$propertiesFromJson(
      $jsonObject,
    ).map(($super0) => ({
      ...$super0,
      $identifier,
      $type,
    }));
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, BaseInterfaceWithoutProperties> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseInterfaceWithPropertiesStatic.$jsonUiSchema({ scopePrefix }),
      ],
      label: "BaseInterfaceWithoutProperties",
      type: "Group",
    };
  }

  export function $toJson(
    _baseInterfaceWithoutProperties: BaseInterfaceWithoutProperties,
  ): BaseInterfaceWithoutPropertiesStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...BaseInterfaceWithPropertiesStatic.$toJson(
          _baseInterfaceWithoutProperties,
        ),
      } satisfies BaseInterfaceWithoutPropertiesStatic.$Json),
    );
  }

  export function $jsonZodSchema() {
    return BaseInterfaceWithPropertiesStatic.$jsonZodSchema().merge(
      z.object({
        "@id": z.string().min(1),
        $type: z.enum([
          "BaseInterfaceWithoutProperties",
          "ConcreteChildInterface",
          "ConcreteParentInterface",
        ]),
      }),
    ) satisfies z.ZodType<$Json>;
  }

  export type $Json = BaseInterfaceWithPropertiesStatic.$Json;

  export function isBaseInterfaceWithoutProperties(
    object: $Object,
  ): object is BaseInterfaceWithoutProperties {
    switch (object.$type) {
      case "ConcreteChildInterface":
      case "ConcreteParentInterface":
      case "BaseInterfaceWithoutProperties":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, BaseInterfaceWithoutProperties> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return BaseInterfaceWithoutPropertiesStatic.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      $type:
        | "BaseInterfaceWithoutProperties"
        | "ConcreteChildInterface"
        | "ConcreteParentInterface";
    } & $UnwrapR<
      ReturnType<typeof BaseInterfaceWithPropertiesStatic.$propertiesFromRdf>
    >
  > {
    return BaseInterfaceWithPropertiesStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/BaseInterfaceWithoutProperties":
                case "http://example.com/ConcreteParentInterface":
                case "http://example.com/ConcreteChildInterface":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/BaseInterfaceWithoutProperties)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        Either.of<Error, BaseInterfaceWithoutPropertiesStatic.$Identifier>(
          $parameters.resource
            .identifier as BaseInterfaceWithoutPropertiesStatic.$Identifier,
        ).chain(($identifier) =>
          Either.of<Error, "BaseInterfaceWithoutProperties">(
            "BaseInterfaceWithoutProperties" as const,
          ).map(($type) => ({ ...$super0, $identifier, $type })),
        ),
      ),
    );
  }

  export function $toRdf(
    _baseInterfaceWithoutProperties: BaseInterfaceWithoutProperties,
    options?: {
      ignoreRdfType?: boolean;
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = BaseInterfaceWithPropertiesStatic.$toRdf(
      _baseInterfaceWithoutProperties,
      {
        ignoreRdfType: true,
        graph: options?.graph,
        resourceSet,
      },
    );
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode(
          "http://example.com/BaseInterfaceWithoutProperties",
        ),
        options?.graph,
      );
    }
    return resource;
  }

  export const $schema = {
    properties: { ...BaseInterfaceWithPropertiesStatic.$schema.properties },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: BaseInterfaceWithoutPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BaseInterfaceWithoutPropertiesStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          BaseInterfaceWithoutPropertiesStatic.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: BaseInterfaceWithoutPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BaseInterfaceWithoutPropertiesStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("baseInterfaceWithoutProperties");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat(
      BaseInterfaceWithPropertiesStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "baseInterfaceWithoutProperties"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "baseInterfaceWithoutProperties")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "baseInterfaceWithoutProperties")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "baseInterfaceWithoutProperties")
            }RdfClass`,
          ),
        },
      );
    }
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: BaseInterfaceWithoutPropertiesStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("baseInterfaceWithoutProperties");
    patterns = patterns.concat(
      BaseInterfaceWithPropertiesStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "baseInterfaceWithoutProperties"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "baseInterfaceWithoutProperties")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        {
          type: "values" as const,
          values: [
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[
              `?${
                parameters?.variablePrefix ??
                (subject.termType === "Variable"
                  ? subject.value
                  : "baseInterfaceWithoutProperties")
              }FromRdfType`
            ] = identifier as NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "baseInterfaceWithoutProperties")
            }FromRdfType`,
          ),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "baseInterfaceWithoutProperties")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    return patterns;
  }
} /**
 * Interface node shape that inherits the base interface and is the parent of the ConcreteChildInterface.
 */

export interface ConcreteParentInterface
  extends BaseInterfaceWithoutProperties {
  readonly $identifier: ConcreteParentInterfaceStatic.$Identifier;
  readonly $type: "ConcreteParentInterface" | "ConcreteChildInterface";
  readonly concreteParentInterfaceProperty: string;
}

export namespace ConcreteParentInterfaceStatic {
  export function $create(
    parameters: {
      readonly $identifier?: (BlankNode | NamedNode) | string;
      readonly concreteParentInterfaceProperty: string;
    } & Parameters<typeof BaseInterfaceWithoutPropertiesStatic.$create>[0],
  ): ConcreteParentInterface {
    let $identifier: ConcreteParentInterfaceStatic.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }
    const $type = "ConcreteParentInterface" as const;
    const concreteParentInterfaceProperty =
      parameters.concreteParentInterfaceProperty;
    return {
      ...BaseInterfaceWithoutPropertiesStatic.$create(parameters),
      $identifier,
      $type,
      concreteParentInterfaceProperty,
    };
  }

  export function $equals(
    left: ConcreteParentInterface,
    right: ConcreteParentInterface,
  ): $EqualsResult {
    return BaseInterfaceWithoutPropertiesStatic.$equals(left, right).chain(() =>
      $strictEquals(
        left.concreteParentInterfaceProperty,
        right.concreteParentInterfaceProperty,
      ).mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "concreteParentInterfaceProperty",
        propertyValuesUnequal,
        type: "property" as const,
      })),
    );
  }

  export function $hash<HasherT extends $Hasher>(
    _concreteParentInterface: ConcreteParentInterface,
    _hasher: HasherT,
  ): HasherT {
    ConcreteParentInterfaceStatic.$hashShaclProperties(
      _concreteParentInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<HasherT extends $Hasher>(
    _concreteParentInterface: ConcreteParentInterface,
    _hasher: HasherT,
  ): HasherT {
    BaseInterfaceWithoutPropertiesStatic.$hashShaclProperties(
      _concreteParentInterface,
      _hasher,
    );
    _hasher.update(_concreteParentInterface.concreteParentInterfaceProperty);
    return _hasher;
  }

  export function $filter(
    filter: ConcreteParentInterfaceStatic.$Filter,
    value: ConcreteParentInterface,
  ): boolean {
    if (!BaseInterfaceWithoutPropertiesStatic.$filter(filter, value)) {
      return false;
    }
    if (
      typeof filter.concreteParentInterfaceProperty !== "undefined" &&
      !$filterString(
        filter.concreteParentInterfaceProperty,
        value.concreteParentInterfaceProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly concreteParentInterfaceProperty?: $StringFilter;
  } & BaseInterfaceWithoutPropertiesStatic.$Filter;

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ConcreteParentInterface",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      $type: "ConcreteParentInterface" | "ConcreteChildInterface";
      concreteParentInterfaceProperty: string;
    } & $UnwrapR<
      ReturnType<
        typeof BaseInterfaceWithoutPropertiesStatic.$propertiesFromJson
      >
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "ConcreteParentInterface" as const;
    const concreteParentInterfaceProperty =
      $jsonObject["concreteParentInterfaceProperty"];
    return BaseInterfaceWithoutPropertiesStatic.$propertiesFromJson(
      $jsonObject,
    ).map(($super0) => ({
      ...$super0,
      $identifier,
      $type,
      concreteParentInterfaceProperty,
    }));
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, ConcreteParentInterface> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseInterfaceWithoutPropertiesStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/concreteParentInterfaceProperty`,
          type: "Control",
        },
      ],
      label: "ConcreteParentInterface",
      type: "Group",
    };
  }

  export function $toJson(
    _concreteParentInterface: ConcreteParentInterface,
  ): ConcreteParentInterfaceStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...BaseInterfaceWithoutPropertiesStatic.$toJson(
          _concreteParentInterface,
        ),
        concreteParentInterfaceProperty:
          _concreteParentInterface.concreteParentInterfaceProperty,
      } satisfies ConcreteParentInterfaceStatic.$Json),
    );
  }

  export function $jsonZodSchema() {
    return BaseInterfaceWithoutPropertiesStatic.$jsonZodSchema().merge(
      z.object({
        "@id": z.string().min(1),
        $type: z.enum(["ConcreteParentInterface", "ConcreteChildInterface"]),
        concreteParentInterfaceProperty: z.string(),
      }),
    ) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly concreteParentInterfaceProperty: string;
  } & BaseInterfaceWithoutPropertiesStatic.$Json;

  export function isConcreteParentInterface(
    object: $Object,
  ): object is ConcreteParentInterface {
    switch (object.$type) {
      case "ConcreteChildInterface":
      case "ConcreteParentInterface":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, ConcreteParentInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return ConcreteParentInterfaceStatic.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      $type: "ConcreteParentInterface" | "ConcreteChildInterface";
      concreteParentInterfaceProperty: string;
    } & $UnwrapR<
      ReturnType<typeof BaseInterfaceWithoutPropertiesStatic.$propertiesFromRdf>
    >
  > {
    return BaseInterfaceWithoutPropertiesStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/ConcreteParentInterface":
                case "http://example.com/ConcreteChildInterface":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  ConcreteParentInterfaceStatic.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ConcreteParentInterface)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        Either.of<Error, ConcreteParentInterfaceStatic.$Identifier>(
          $parameters.resource
            .identifier as ConcreteParentInterfaceStatic.$Identifier,
        ).chain(($identifier) =>
          Either.of<Error, "ConcreteParentInterface">(
            "ConcreteParentInterface" as const,
          ).chain(($type) =>
            Either.of<Error, Resource.Values<Resource.TermValue>>(
              $parameters.resource.values(
                $schema.properties.concreteParentInterfaceProperty.identifier,
                {
                  unique: true,
                },
              ),
            )
              .chain((values) =>
                $fromRdfPreferredLanguages({
                  focusResource: $parameters.resource,
                  predicate:
                    ConcreteParentInterfaceStatic.$schema.properties
                      .concreteParentInterfaceProperty.identifier,
                  preferredLanguages: $parameters.preferredLanguages,
                  values,
                }),
              )
              .chain((values) => values.chainMap((value) => value.toString()))
              .chain((values) => values.head())
              .map((concreteParentInterfaceProperty) => ({
                ...$super0,
                $identifier,
                $type,
                concreteParentInterfaceProperty,
              })),
          ),
        ),
      ),
    );
  }

  export function $toRdf(
    _concreteParentInterface: ConcreteParentInterface,
    options?: {
      ignoreRdfType?: boolean;
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = BaseInterfaceWithoutPropertiesStatic.$toRdf(
      _concreteParentInterface,
      {
        ignoreRdfType: true,
        graph: options?.graph,
        resourceSet,
      },
    );
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/ConcreteParentInterface"),
        options?.graph,
      );
    }
    resource.add(
      ConcreteParentInterfaceStatic.$schema.properties
        .concreteParentInterfaceProperty.identifier,
      [
        $literalFactory.string(
          _concreteParentInterface.concreteParentInterfaceProperty,
        ),
      ],
      options?.graph,
    );
    return resource;
  }

  export const $schema = {
    properties: {
      ...BaseInterfaceWithoutPropertiesStatic.$schema.properties,
      concreteParentInterfaceProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/concreteParentInterfaceProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ConcreteParentInterfaceStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConcreteParentInterfaceStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          ConcreteParentInterfaceStatic.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ConcreteParentInterfaceStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConcreteParentInterfaceStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteParentInterface");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat(
      BaseInterfaceWithoutPropertiesStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteParentInterface"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "concreteParentInterface")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "concreteParentInterface")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "concreteParentInterface")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "concreteParentInterface")
          }ConcreteParentInterfaceProperty`,
        ),
        predicate:
          ConcreteParentInterfaceStatic.$schema.properties
            .concreteParentInterfaceProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ConcreteParentInterfaceStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteParentInterface");
    patterns = patterns.concat(
      BaseInterfaceWithoutPropertiesStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteParentInterface"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "concreteParentInterface")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        {
          type: "values" as const,
          values: [
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[
              `?${
                parameters?.variablePrefix ??
                (subject.termType === "Variable"
                  ? subject.value
                  : "concreteParentInterface")
              }FromRdfType`
            ] = identifier as NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "concreteParentInterface")
            }FromRdfType`,
          ),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "concreteParentInterface")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.concreteParentInterfaceProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "concreteParentInterface")
                  }ConcreteParentInterfaceProperty`,
                ),
                predicate:
                  ConcreteParentInterfaceStatic.$schema.properties
                    .concreteParentInterfaceProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ConcreteParentInterfaceStatic.$schema.properties.concreteParentInterfaceProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "concreteParentInterface")
          }ConcreteParentInterfaceProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteParentInterface")
        }ConcreteParentInterfaceProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Child interface of ConcreteParentInterface. Should inherit properties and node kinds.
 */

export interface ConcreteChildInterface extends ConcreteParentInterface {
  readonly $identifier: ConcreteChildInterface.$Identifier;
  readonly $type: "ConcreteChildInterface";
  readonly concreteChildInterfaceProperty: string;
}

export namespace ConcreteChildInterface {
  export function $create(
    parameters: {
      readonly $identifier?: (BlankNode | NamedNode) | string;
      readonly concreteChildInterfaceProperty: string;
    } & Parameters<typeof ConcreteParentInterfaceStatic.$create>[0],
  ): ConcreteChildInterface {
    let $identifier: ConcreteChildInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }
    const $type = "ConcreteChildInterface" as const;
    const concreteChildInterfaceProperty =
      parameters.concreteChildInterfaceProperty;
    return {
      ...ConcreteParentInterfaceStatic.$create(parameters),
      $identifier,
      $type,
      concreteChildInterfaceProperty,
    };
  }

  export function $equals(
    left: ConcreteChildInterface,
    right: ConcreteChildInterface,
  ): $EqualsResult {
    return ConcreteParentInterfaceStatic.$equals(left, right).chain(() =>
      $strictEquals(
        left.concreteChildInterfaceProperty,
        right.concreteChildInterfaceProperty,
      ).mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "concreteChildInterfaceProperty",
        propertyValuesUnequal,
        type: "property" as const,
      })),
    );
  }

  export function $hash<HasherT extends $Hasher>(
    _concreteChildInterface: ConcreteChildInterface,
    _hasher: HasherT,
  ): HasherT {
    ConcreteChildInterface.$hashShaclProperties(
      _concreteChildInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<HasherT extends $Hasher>(
    _concreteChildInterface: ConcreteChildInterface,
    _hasher: HasherT,
  ): HasherT {
    ConcreteParentInterfaceStatic.$hashShaclProperties(
      _concreteChildInterface,
      _hasher,
    );
    _hasher.update(_concreteChildInterface.concreteChildInterfaceProperty);
    return _hasher;
  }

  export function $filter(
    filter: ConcreteChildInterface.$Filter,
    value: ConcreteChildInterface,
  ): boolean {
    if (!ConcreteParentInterfaceStatic.$filter(filter, value)) {
      return false;
    }
    if (
      typeof filter.concreteChildInterfaceProperty !== "undefined" &&
      !$filterString(
        filter.concreteChildInterfaceProperty,
        value.concreteChildInterfaceProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly concreteChildInterfaceProperty?: $StringFilter;
  } & ConcreteParentInterfaceStatic.$Filter;

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ConcreteChildInterface",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      $type: "ConcreteChildInterface";
      concreteChildInterfaceProperty: string;
    } & $UnwrapR<
      ReturnType<typeof ConcreteParentInterfaceStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "ConcreteChildInterface" as const;
    const concreteChildInterfaceProperty =
      $jsonObject["concreteChildInterfaceProperty"];
    return ConcreteParentInterfaceStatic.$propertiesFromJson($jsonObject).map(
      ($super0) => ({
        ...$super0,
        $identifier,
        $type,
        concreteChildInterfaceProperty,
      }),
    );
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, ConcreteChildInterface> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ConcreteParentInterfaceStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/concreteChildInterfaceProperty`,
          type: "Control",
        },
      ],
      label: "ConcreteChildInterface",
      type: "Group",
    };
  }

  export function $toJson(
    _concreteChildInterface: ConcreteChildInterface,
  ): ConcreteChildInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        ...ConcreteParentInterfaceStatic.$toJson(_concreteChildInterface),
        concreteChildInterfaceProperty:
          _concreteChildInterface.concreteChildInterfaceProperty,
      } satisfies ConcreteChildInterface.$Json),
    );
  }

  export function $jsonZodSchema() {
    return ConcreteParentInterfaceStatic.$jsonZodSchema().merge(
      z.object({
        "@id": z.string().min(1),
        $type: z.literal("ConcreteChildInterface"),
        concreteChildInterfaceProperty: z.string(),
      }),
    ) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly concreteChildInterfaceProperty: string;
  } & ConcreteParentInterfaceStatic.$Json;

  export function isConcreteChildInterface(
    object: $Object,
  ): object is ConcreteChildInterface {
    switch (object.$type) {
      case "ConcreteChildInterface":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, ConcreteChildInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return ConcreteChildInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      $type: "ConcreteChildInterface";
      concreteChildInterfaceProperty: string;
    } & $UnwrapR<
      ReturnType<typeof ConcreteParentInterfaceStatic.$propertiesFromRdf>
    >
  > {
    return ConcreteParentInterfaceStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/ConcreteChildInterface":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  ConcreteChildInterface.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ConcreteChildInterface)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        Either.of<Error, ConcreteChildInterface.$Identifier>(
          $parameters.resource.identifier as ConcreteChildInterface.$Identifier,
        ).chain(($identifier) =>
          Either.of<Error, "ConcreteChildInterface">(
            "ConcreteChildInterface" as const,
          ).chain(($type) =>
            Either.of<Error, Resource.Values<Resource.TermValue>>(
              $parameters.resource.values(
                $schema.properties.concreteChildInterfaceProperty.identifier,
                {
                  unique: true,
                },
              ),
            )
              .chain((values) =>
                $fromRdfPreferredLanguages({
                  focusResource: $parameters.resource,
                  predicate:
                    ConcreteChildInterface.$schema.properties
                      .concreteChildInterfaceProperty.identifier,
                  preferredLanguages: $parameters.preferredLanguages,
                  values,
                }),
              )
              .chain((values) => values.chainMap((value) => value.toString()))
              .chain((values) => values.head())
              .map((concreteChildInterfaceProperty) => ({
                ...$super0,
                $identifier,
                $type,
                concreteChildInterfaceProperty,
              })),
          ),
        ),
      ),
    );
  }

  export function $toRdf(
    _concreteChildInterface: ConcreteChildInterface,
    options?: {
      ignoreRdfType?: boolean;
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = ConcreteParentInterfaceStatic.$toRdf(
      _concreteChildInterface,
      {
        ignoreRdfType: true,
        graph: options?.graph,
        resourceSet,
      },
    );
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/ConcreteChildInterface"),
        options?.graph,
      );
    }
    resource.add(
      ConcreteChildInterface.$schema.properties.concreteChildInterfaceProperty
        .identifier,
      [
        $literalFactory.string(
          _concreteChildInterface.concreteChildInterfaceProperty,
        ),
      ],
      options?.graph,
    );
    return resource;
  }

  export const $schema = {
    properties: {
      ...ConcreteParentInterfaceStatic.$schema.properties,
      concreteChildInterfaceProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/concreteChildInterfaceProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ConcreteChildInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConcreteChildInterface.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          ConcreteChildInterface.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ConcreteChildInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConcreteChildInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteChildInterface");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat(
      ConcreteParentInterfaceStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteChildInterface"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "concreteChildInterface")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "concreteChildInterface")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "concreteChildInterface")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "concreteChildInterface")
          }ConcreteChildInterfaceProperty`,
        ),
        predicate:
          ConcreteChildInterface.$schema.properties
            .concreteChildInterfaceProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ConcreteChildInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteChildInterface");
    patterns = patterns.concat(
      ConcreteParentInterfaceStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteChildInterface"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "concreteChildInterface")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ConcreteChildInterface.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "concreteChildInterface")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.concreteChildInterfaceProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "concreteChildInterface")
                  }ConcreteChildInterfaceProperty`,
                ),
                predicate:
                  ConcreteChildInterface.$schema.properties
                    .concreteChildInterfaceProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ConcreteChildInterface.$schema.properties.concreteChildInterfaceProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "concreteChildInterface")
          }ConcreteChildInterfaceProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteChildInterface")
        }ConcreteChildInterfaceProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Node shape that serves as an abstract base class for child node shapes.
 *
 * It's marked abstract in TypeScript and not exported from the module.
 *
 * Common pattern: put the minting strategy and nodeKind on an ABC.
 */

export abstract class AbstractBaseClassWithProperties {
  protected _$identifier?: AbstractBaseClassWithPropertiesStatic.$Identifier;

  protected readonly _$identifierPrefix?: string;

  abstract readonly $type: "ConcreteChildClass" | "ConcreteParentClass";

  readonly abstractBaseClassWithPropertiesProperty: string;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly $identifierPrefix?: string;
    readonly abstractBaseClassWithPropertiesProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this._$identifierPrefix = parameters.$identifierPrefix;
    this.abstractBaseClassWithPropertiesProperty =
      parameters.abstractBaseClassWithPropertiesProperty;
  }

  get $identifier(): AbstractBaseClassWithPropertiesStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }
    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  $equals(other: AbstractBaseClassWithProperties): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$identifierPrefix, other.$identifierPrefix).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$identifierPrefix",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.abstractBaseClassWithPropertiesProperty,
          other.abstractBaseClassWithPropertiesProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "abstractBaseClassWithPropertiesProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.abstractBaseClassWithPropertiesProperty);
    return _hasher;
  }

  $toJson(): AbstractBaseClassWithPropertiesStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        abstractBaseClassWithPropertiesProperty:
          this.abstractBaseClassWithPropertiesProperty,
      } satisfies AbstractBaseClassWithPropertiesStatic.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    resource.add(
      AbstractBaseClassWithPropertiesStatic.$schema.properties
        .abstractBaseClassWithPropertiesProperty.identifier,
      [$literalFactory.string(this.abstractBaseClassWithPropertiesProperty)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace AbstractBaseClassWithPropertiesStatic {
  export function $filter(
    filter: AbstractBaseClassWithPropertiesStatic.$Filter,
    value: AbstractBaseClassWithProperties,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.abstractBaseClassWithPropertiesProperty !== "undefined" &&
      !$filterString(
        filter.abstractBaseClassWithPropertiesProperty,
        value.abstractBaseClassWithPropertiesProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly abstractBaseClassWithPropertiesProperty?: $StringFilter;
  };

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      abstractBaseClassWithPropertiesProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const abstractBaseClassWithPropertiesProperty =
      $jsonObject["abstractBaseClassWithPropertiesProperty"];
    return Either.of({ $identifier, abstractBaseClassWithPropertiesProperty });
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "AbstractBaseClassWithProperties" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/abstractBaseClassWithPropertiesProperty`,
          type: "Control",
        },
      ],
      label: "AbstractBaseClassWithProperties",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.enum(["ConcreteChildClass", "ConcreteParentClass"]),
      abstractBaseClassWithPropertiesProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ConcreteChildClass" | "ConcreteParentClass";
    readonly abstractBaseClassWithPropertiesProperty: string;
  };

  export function isAbstractBaseClassWithProperties(
    object: $Object,
  ): object is AbstractBaseClassWithProperties {
    switch (object.$type) {
      case "ConcreteChildClass":
      case "ConcreteParentClass":
        return true;
      default:
        return false;
    }
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      abstractBaseClassWithPropertiesProperty: string;
    }
  > {
    return Either.of<Error, AbstractBaseClassWithPropertiesStatic.$Identifier>(
      $parameters.resource
        .identifier as AbstractBaseClassWithPropertiesStatic.$Identifier,
    ).chain(($identifier) =>
      Either.of<Error, Resource.Values<Resource.TermValue>>(
        $parameters.resource.values(
          $schema.properties.abstractBaseClassWithPropertiesProperty.identifier,
          {
            unique: true,
          },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              AbstractBaseClassWithPropertiesStatic.$schema.properties
                .abstractBaseClassWithPropertiesProperty.identifier,
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((abstractBaseClassWithPropertiesProperty) => ({
          $identifier,
          abstractBaseClassWithPropertiesProperty,
        })),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $identifierPrefix: {
        kind: "IdentifierPrefix" as const,
        type: () => ({ kind: "String" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          descendantValues: ["ConcreteChildClass", "ConcreteParentClass"],
          kind: "TypeDiscriminant" as const,
        }),
      },
      abstractBaseClassWithPropertiesProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/abstractBaseClassWithPropertiesProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: AbstractBaseClassWithPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        AbstractBaseClassWithPropertiesStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          AbstractBaseClassWithPropertiesStatic.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: AbstractBaseClassWithPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      AbstractBaseClassWithPropertiesStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassWithProperties");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "abstractBaseClassWithProperties")
          }AbstractBaseClassWithPropertiesProperty`,
        ),
        predicate:
          AbstractBaseClassWithPropertiesStatic.$schema.properties
            .abstractBaseClassWithPropertiesProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: AbstractBaseClassWithPropertiesStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassWithProperties");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            AbstractBaseClassWithPropertiesStatic.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "abstractBaseClassWithProperties"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.abstractBaseClassWithPropertiesProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "abstractBaseClassWithProperties")
                  }AbstractBaseClassWithPropertiesProperty`,
                ),
                predicate:
                  AbstractBaseClassWithPropertiesStatic.$schema.properties
                    .abstractBaseClassWithPropertiesProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          AbstractBaseClassWithPropertiesStatic.$schema.properties.abstractBaseClassWithPropertiesProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "abstractBaseClassWithProperties")
          }AbstractBaseClassWithPropertiesProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "abstractBaseClassWithProperties")
        }AbstractBaseClassWithPropertiesProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Abstract base for other node shapes. Put the ABC with properties above the ABC without.
 */

export abstract class AbstractBaseClassWithoutProperties extends AbstractBaseClassWithProperties {
  abstract override readonly $type:
    | "ConcreteChildClass"
    | "ConcreteParentClass";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: { readonly $identifierPrefix?: string } & ConstructorParameters<
      typeof AbstractBaseClassWithProperties
    >[0],
  ) {
    super(parameters);
  }

  override get $identifier(): AbstractBaseClassWithoutPropertiesStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }
    return this._$identifier;
  }

  protected override get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      graph: options?.graph,
      resourceSet,
    });
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace AbstractBaseClassWithoutPropertiesStatic {
  export function $filter(
    filter: AbstractBaseClassWithoutPropertiesStatic.$Filter,
    value: AbstractBaseClassWithoutProperties,
  ): boolean {
    if (!AbstractBaseClassWithPropertiesStatic.$filter(filter, value)) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
  } & AbstractBaseClassWithPropertiesStatic.$Filter;

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<
    z.ZodError,
    { $identifier: BlankNode | NamedNode } & $UnwrapR<
      ReturnType<
        typeof AbstractBaseClassWithPropertiesStatic.$propertiesFromJson
      >
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    return AbstractBaseClassWithPropertiesStatic.$propertiesFromJson(
      $jsonObject,
    ).map(($super0) => ({
      ...$super0,
      $identifier,
    }));
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        AbstractBaseClassWithPropertiesStatic.$jsonUiSchema({ scopePrefix }),
      ],
      label: "AbstractBaseClassWithoutProperties",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return AbstractBaseClassWithPropertiesStatic.$jsonZodSchema().merge(
      z.object({
        "@id": z.string().min(1),
        $type: z.enum(["ConcreteChildClass", "ConcreteParentClass"]),
      }),
    ) satisfies z.ZodType<$Json>;
  }

  export type $Json = AbstractBaseClassWithPropertiesStatic.$Json;

  export function isAbstractBaseClassWithoutProperties(
    object: $Object,
  ): object is AbstractBaseClassWithoutProperties {
    switch (object.$type) {
      case "ConcreteChildClass":
      case "ConcreteParentClass":
        return true;
      default:
        return false;
    }
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    { $identifier: BlankNode | NamedNode } & $UnwrapR<
      ReturnType<
        typeof AbstractBaseClassWithPropertiesStatic.$propertiesFromRdf
      >
    >
  > {
    return AbstractBaseClassWithPropertiesStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      Either.of<Error, AbstractBaseClassWithoutPropertiesStatic.$Identifier>(
        $parameters.resource
          .identifier as AbstractBaseClassWithoutPropertiesStatic.$Identifier,
      ).map(($identifier) => ({ ...$super0, $identifier })),
    );
  }

  export const $schema = {
    properties: { ...AbstractBaseClassWithPropertiesStatic.$schema.properties },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: AbstractBaseClassWithoutPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        AbstractBaseClassWithoutPropertiesStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          AbstractBaseClassWithoutPropertiesStatic.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: AbstractBaseClassWithoutPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      AbstractBaseClassWithoutPropertiesStatic.$sparqlConstructQuery(
        parameters,
      ),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassWithoutProperties");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat(
      AbstractBaseClassWithPropertiesStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "abstractBaseClassWithoutProperties"),
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: AbstractBaseClassWithoutPropertiesStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassWithoutProperties");
    patterns = patterns.concat(
      AbstractBaseClassWithPropertiesStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "abstractBaseClassWithoutProperties"),
      }),
    );
    return patterns;
  }
} /**
 * Class node shape that inherits the abstract base class and is the parent of the ConcreteChildClass.
 */

export class ConcreteParentClass extends AbstractBaseClassWithoutProperties {
  override readonly $type: "ConcreteParentClass" | "ConcreteChildClass" =
    "ConcreteParentClass" as const;

  readonly concreteParentClassProperty: string;

  constructor(
    parameters: {
      readonly $identifier?: (BlankNode | NamedNode) | string;
      readonly $identifierPrefix?: string;
      readonly concreteParentClassProperty: string;
    } & ConstructorParameters<typeof AbstractBaseClassWithoutProperties>[0],
  ) {
    super(parameters);
    this.concreteParentClassProperty = parameters.concreteParentClassProperty;
  }

  override get $identifier(): ConcreteParentClassStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }
    return this._$identifier;
  }

  protected override get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  override $equals(other: ConcreteParentClass): $EqualsResult {
    return super.$equals(other).chain(() =>
      $strictEquals(
        this.concreteParentClassProperty,
        other.concreteParentClassProperty,
      ).mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "concreteParentClassProperty",
        propertyValuesUnequal,
        type: "property" as const,
      })),
    );
  }

  override $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    super.$hashShaclProperties(_hasher);
    _hasher.update(this.concreteParentClassProperty);
    return _hasher;
  }

  override $toJson(): ConcreteParentClassStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        concreteParentClassProperty: this.concreteParentClassProperty,
      } satisfies ConcreteParentClassStatic.$Json),
    );
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      graph: options?.graph,
      resourceSet,
    });
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/ConcreteParentClass"),
        options?.graph,
      );
    }
    resource.add(
      ConcreteParentClassStatic.$schema.properties.concreteParentClassProperty
        .identifier,
      [$literalFactory.string(this.concreteParentClassProperty)],
      options?.graph,
    );
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ConcreteParentClassStatic {
  export function $filter(
    filter: ConcreteParentClassStatic.$Filter,
    value: ConcreteParentClass,
  ): boolean {
    if (!AbstractBaseClassWithoutPropertiesStatic.$filter(filter, value)) {
      return false;
    }
    if (
      typeof filter.concreteParentClassProperty !== "undefined" &&
      !$filterString(
        filter.concreteParentClassProperty,
        value.concreteParentClassProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly concreteParentClassProperty?: $StringFilter;
  } & AbstractBaseClassWithoutPropertiesStatic.$Filter;

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ConcreteParentClass",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      concreteParentClassProperty: string;
    } & $UnwrapR<
      ReturnType<
        typeof AbstractBaseClassWithoutPropertiesStatic.$propertiesFromJson
      >
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const concreteParentClassProperty =
      $jsonObject["concreteParentClassProperty"];
    return AbstractBaseClassWithoutPropertiesStatic.$propertiesFromJson(
      $jsonObject,
    ).map(($super0) => ({
      ...$super0,
      $identifier,
      concreteParentClassProperty,
    }));
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, ConcreteParentClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ConcreteParentClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        AbstractBaseClassWithoutPropertiesStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/concreteParentClassProperty`,
          type: "Control",
        },
      ],
      label: "ConcreteParentClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return AbstractBaseClassWithoutPropertiesStatic.$jsonZodSchema().merge(
      z.object({
        "@id": z.string().min(1),
        $type: z.enum(["ConcreteParentClass", "ConcreteChildClass"]),
        concreteParentClassProperty: z.string(),
      }),
    ) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly concreteParentClassProperty: string;
  } & AbstractBaseClassWithoutPropertiesStatic.$Json;

  export function isConcreteParentClass(
    object: $Object,
  ): object is ConcreteParentClass {
    switch (object.$type) {
      case "ConcreteChildClass":
      case "ConcreteParentClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, ConcreteParentClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return ConcreteParentClassStatic.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ConcreteParentClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      concreteParentClassProperty: string;
    } & $UnwrapR<
      ReturnType<
        typeof AbstractBaseClassWithoutPropertiesStatic.$propertiesFromRdf
      >
    >
  > {
    return AbstractBaseClassWithoutPropertiesStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/ConcreteParentClass":
                case "http://example.com/ConcreteChildClass":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  ConcreteParentClassStatic.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ConcreteParentClass)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        Either.of<Error, ConcreteParentClassStatic.$Identifier>(
          $parameters.resource
            .identifier as ConcreteParentClassStatic.$Identifier,
        ).chain(($identifier) =>
          Either.of<Error, Resource.Values<Resource.TermValue>>(
            $parameters.resource.values(
              $schema.properties.concreteParentClassProperty.identifier,
              {
                unique: true,
              },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  ConcreteParentClassStatic.$schema.properties
                    .concreteParentClassProperty.identifier,
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((concreteParentClassProperty) => ({
              ...$super0,
              $identifier,
              concreteParentClassProperty,
            })),
        ),
      ),
    );
  }

  export const $schema = {
    properties: {
      ...AbstractBaseClassWithoutPropertiesStatic.$schema.properties,
      concreteParentClassProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/concreteParentClassProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ConcreteParentClassStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConcreteParentClassStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          ConcreteParentClassStatic.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ConcreteParentClassStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConcreteParentClassStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteParentClass");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat(
      AbstractBaseClassWithoutPropertiesStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteParentClass"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "concreteParentClass")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "concreteParentClass")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "concreteParentClass")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "concreteParentClass")
          }ConcreteParentClassProperty`,
        ),
        predicate:
          ConcreteParentClassStatic.$schema.properties
            .concreteParentClassProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ConcreteParentClassStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteParentClass");
    patterns = patterns.concat(
      AbstractBaseClassWithoutPropertiesStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteParentClass"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "concreteParentClass")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        {
          type: "values" as const,
          values: [
            ConcreteParentClassStatic.$fromRdfType,
            ConcreteChildClass.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[
              `?${
                parameters?.variablePrefix ??
                (subject.termType === "Variable"
                  ? subject.value
                  : "concreteParentClass")
              }FromRdfType`
            ] = identifier as NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "concreteParentClass")
            }FromRdfType`,
          ),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "concreteParentClass")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.concreteParentClassProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "concreteParentClass")
                  }ConcreteParentClassProperty`,
                ),
                predicate:
                  ConcreteParentClassStatic.$schema.properties
                    .concreteParentClassProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ConcreteParentClassStatic.$schema.properties.concreteParentClassProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "concreteParentClass")
          }ConcreteParentClassProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteParentClass")
        }ConcreteParentClassProperty`,
      }),
    );
    return patterns;
  }
} /**
 * Child (class) of ConcreteParentClass. Should inherit properties, node kinds, and minting strategy.
 */

export class ConcreteChildClass extends ConcreteParentClass {
  override readonly $type: "ConcreteChildClass" = "ConcreteChildClass" as const;

  readonly concreteChildClassProperty: string;

  constructor(
    parameters: {
      readonly $identifier?: (BlankNode | NamedNode) | string;
      readonly $identifierPrefix?: string;
      readonly concreteChildClassProperty: string;
    } & ConstructorParameters<typeof ConcreteParentClass>[0],
  ) {
    super(parameters);
    this.concreteChildClassProperty = parameters.concreteChildClassProperty;
  }

  override get $identifier(): ConcreteChildClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }
    return this._$identifier;
  }

  protected override get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  override $equals(other: ConcreteChildClass): $EqualsResult {
    return super.$equals(other).chain(() =>
      $strictEquals(
        this.concreteChildClassProperty,
        other.concreteChildClassProperty,
      ).mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "concreteChildClassProperty",
        propertyValuesUnequal,
        type: "property" as const,
      })),
    );
  }

  override $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    super.$hashShaclProperties(_hasher);
    _hasher.update(this.concreteChildClassProperty);
    return _hasher;
  }

  override $toJson(): ConcreteChildClass.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        concreteChildClassProperty: this.concreteChildClassProperty,
      } satisfies ConcreteChildClass.$Json),
    );
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      graph: options?.graph,
      resourceSet,
    });
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/ConcreteChildClass"),
        options?.graph,
      );
    }
    resource.add(
      ConcreteChildClass.$schema.properties.concreteChildClassProperty
        .identifier,
      [$literalFactory.string(this.concreteChildClassProperty)],
      options?.graph,
    );
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ConcreteChildClass {
  export function $filter(
    filter: ConcreteChildClass.$Filter,
    value: ConcreteChildClass,
  ): boolean {
    if (!ConcreteParentClassStatic.$filter(filter, value)) {
      return false;
    }
    if (
      typeof filter.concreteChildClassProperty !== "undefined" &&
      !$filterString(
        filter.concreteChildClassProperty,
        value.concreteChildClassProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly concreteChildClassProperty?: $StringFilter;
  } & ConcreteParentClassStatic.$Filter;

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ConcreteChildClass",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      concreteChildClassProperty: string;
    } & $UnwrapR<
      ReturnType<typeof ConcreteParentClassStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const concreteChildClassProperty =
      $jsonObject["concreteChildClassProperty"];
    return ConcreteParentClassStatic.$propertiesFromJson($jsonObject).map(
      ($super0) => ({
        ...$super0,
        $identifier,
        concreteChildClassProperty,
      }),
    );
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, ConcreteChildClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ConcreteChildClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ConcreteParentClassStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/concreteChildClassProperty`,
          type: "Control",
        },
      ],
      label: "ConcreteChildClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ConcreteParentClassStatic.$jsonZodSchema().merge(
      z.object({
        "@id": z.string().min(1),
        $type: z.literal("ConcreteChildClass"),
        concreteChildClassProperty: z.string(),
      }),
    ) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly concreteChildClassProperty: string;
  } & ConcreteParentClassStatic.$Json;

  export function isConcreteChildClass(
    object: $Object,
  ): object is ConcreteChildClass {
    switch (object.$type) {
      case "ConcreteChildClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, ConcreteChildClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return ConcreteChildClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ConcreteChildClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      concreteChildClassProperty: string;
    } & $UnwrapR<
      ReturnType<typeof ConcreteParentClassStatic.$propertiesFromRdf>
    >
  > {
    return ConcreteParentClassStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/ConcreteChildClass":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  ConcreteChildClass.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ConcreteChildClass)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        Either.of<Error, ConcreteChildClass.$Identifier>(
          $parameters.resource.identifier as ConcreteChildClass.$Identifier,
        ).chain(($identifier) =>
          Either.of<Error, Resource.Values<Resource.TermValue>>(
            $parameters.resource.values(
              $schema.properties.concreteChildClassProperty.identifier,
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  ConcreteChildClass.$schema.properties
                    .concreteChildClassProperty.identifier,
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((concreteChildClassProperty) => ({
              ...$super0,
              $identifier,
              concreteChildClassProperty,
            })),
        ),
      ),
    );
  }

  export const $schema = {
    properties: {
      ...ConcreteParentClassStatic.$schema.properties,
      concreteChildClassProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/concreteChildClassProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ConcreteChildClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConcreteChildClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          ConcreteChildClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ConcreteChildClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConcreteChildClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteChildClass");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat(
      ConcreteParentClassStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteChildClass"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "concreteChildClass")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "concreteChildClass")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "concreteChildClass")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "concreteChildClass")
          }ConcreteChildClassProperty`,
        ),
        predicate:
          ConcreteChildClass.$schema.properties.concreteChildClassProperty
            .identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ConcreteChildClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteChildClass");
    patterns = patterns.concat(
      ConcreteParentClassStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteChildClass"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable" ? subject.value : "concreteChildClass")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ConcreteChildClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "concreteChildClass")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.concreteChildClassProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "concreteChildClass")
                  }ConcreteChildClassProperty`,
                ),
                predicate:
                  ConcreteChildClass.$schema.properties
                    .concreteChildClassProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ConcreteChildClass.$schema.properties.concreteChildClassProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "concreteChildClass")
          }ConcreteChildClassProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteChildClass")
        }ConcreteChildClassProperty`,
      }),
    );
    return patterns;
  }
}
export abstract class ClassUnionMemberCommonParent {
  protected _$identifier?: ClassUnionMemberCommonParentStatic.$Identifier;

  abstract readonly $type: "ClassUnionMember1" | "ClassUnionMember2";

  readonly classUnionMemberCommonParentProperty: string;

  constructor(parameters: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
    readonly classUnionMemberCommonParentProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }
    this.classUnionMemberCommonParentProperty =
      parameters.classUnionMemberCommonParentProperty;
  }

  get $identifier(): ClassUnionMemberCommonParentStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: ClassUnionMemberCommonParent): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.classUnionMemberCommonParentProperty,
          other.classUnionMemberCommonParentProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "classUnionMemberCommonParentProperty",
          propertyValuesUnequal,
          type: "property" as const,
        })),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(this.classUnionMemberCommonParentProperty);
    return _hasher;
  }

  $toJson(): ClassUnionMemberCommonParentStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        classUnionMemberCommonParentProperty:
          this.classUnionMemberCommonParentProperty,
      } satisfies ClassUnionMemberCommonParentStatic.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    resource.add(
      ClassUnionMemberCommonParentStatic.$schema.properties
        .classUnionMemberCommonParentProperty.identifier,
      [$literalFactory.string(this.classUnionMemberCommonParentProperty)],
      options?.graph,
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ClassUnionMemberCommonParentStatic {
  export function $filter(
    filter: ClassUnionMemberCommonParentStatic.$Filter,
    value: ClassUnionMemberCommonParent,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      typeof filter.classUnionMemberCommonParentProperty !== "undefined" &&
      !$filterString(
        filter.classUnionMemberCommonParentProperty,
        value.classUnionMemberCommonParentProperty,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly classUnionMemberCommonParentProperty?: $StringFilter;
  };

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      classUnionMemberCommonParentProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const classUnionMemberCommonParentProperty =
      $jsonObject["classUnionMemberCommonParentProperty"];
    return Either.of({ $identifier, classUnionMemberCommonParentProperty });
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ClassUnionMemberCommonParent" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/classUnionMemberCommonParentProperty`,
          type: "Control",
        },
      ],
      label: "ClassUnionMemberCommonParent",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.enum(["ClassUnionMember1", "ClassUnionMember2"]),
      classUnionMemberCommonParentProperty: z.string(),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ClassUnionMember1" | "ClassUnionMember2";
    readonly classUnionMemberCommonParentProperty: string;
  };

  export function isClassUnionMemberCommonParent(
    object: $Object,
  ): object is ClassUnionMemberCommonParent {
    switch (object.$type) {
      case "ClassUnionMember1":
      case "ClassUnionMember2":
        return true;
      default:
        return false;
    }
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      classUnionMemberCommonParentProperty: string;
    }
  > {
    return Either.of<Error, ClassUnionMemberCommonParentStatic.$Identifier>(
      $parameters.resource
        .identifier as ClassUnionMemberCommonParentStatic.$Identifier,
    ).chain(($identifier) =>
      Either.of<Error, Resource.Values<Resource.TermValue>>(
        $parameters.resource.values(
          $schema.properties.classUnionMemberCommonParentProperty.identifier,
          {
            unique: true,
          },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              ClassUnionMemberCommonParentStatic.$schema.properties
                .classUnionMemberCommonParentProperty.identifier,
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head())
        .map((classUnionMemberCommonParentProperty) => ({
          $identifier,
          classUnionMemberCommonParentProperty,
        })),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          descendantValues: ["ClassUnionMember1", "ClassUnionMember2"],
          kind: "TypeDiscriminant" as const,
        }),
      },
      classUnionMemberCommonParentProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/classUnionMemberCommonParentProperty",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ClassUnionMemberCommonParentStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ClassUnionMemberCommonParentStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          ClassUnionMemberCommonParentStatic.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ClassUnionMemberCommonParentStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ClassUnionMemberCommonParentStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("classUnionMemberCommonParent");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "classUnionMemberCommonParent")
          }ClassUnionMemberCommonParentProperty`,
        ),
        predicate:
          ClassUnionMemberCommonParentStatic.$schema.properties
            .classUnionMemberCommonParentProperty.identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ClassUnionMemberCommonParentStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("classUnionMemberCommonParent");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            ClassUnionMemberCommonParentStatic.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "classUnionMemberCommonParent"),
        }),
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.classUnionMemberCommonParentProperty,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "classUnionMemberCommonParent")
                  }ClassUnionMemberCommonParentProperty`,
                ),
                predicate:
                  ClassUnionMemberCommonParentStatic.$schema.properties
                    .classUnionMemberCommonParentProperty.identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ClassUnionMemberCommonParentStatic.$schema.properties.classUnionMemberCommonParentProperty.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "classUnionMemberCommonParent")
          }ClassUnionMemberCommonParentProperty`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "classUnionMemberCommonParent")
        }ClassUnionMemberCommonParentProperty`,
      }),
    );
    return patterns;
  }
}
export class ClassUnionMember2 extends ClassUnionMemberCommonParent {
  override readonly $type: "ClassUnionMember2" = "ClassUnionMember2" as const;

  readonly classUnionMember2Property: string;

  constructor(
    parameters: {
      readonly $identifier?: (BlankNode | NamedNode) | string;
      readonly classUnionMember2Property: string;
    } & ConstructorParameters<typeof ClassUnionMemberCommonParent>[0],
  ) {
    super(parameters);
    this.classUnionMember2Property = parameters.classUnionMember2Property;
  }

  override get $identifier(): ClassUnionMember2.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: ClassUnionMember2): $EqualsResult {
    return super.$equals(other).chain(() =>
      $strictEquals(
        this.classUnionMember2Property,
        other.classUnionMember2Property,
      ).mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "classUnionMember2Property",
        propertyValuesUnequal,
        type: "property" as const,
      })),
    );
  }

  override $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    super.$hashShaclProperties(_hasher);
    _hasher.update(this.classUnionMember2Property);
    return _hasher;
  }

  override $toJson(): ClassUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        classUnionMember2Property: this.classUnionMember2Property,
      } satisfies ClassUnionMember2.$Json),
    );
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      graph: options?.graph,
      resourceSet,
    });
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/ClassUnionMember2"),
        options?.graph,
      );
    }
    resource.add(
      ClassUnionMember2.$schema.properties.classUnionMember2Property.identifier,
      [$literalFactory.string(this.classUnionMember2Property)],
      options?.graph,
    );
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ClassUnionMember2 {
  export function $filter(
    filter: ClassUnionMember2.$Filter,
    value: ClassUnionMember2,
  ): boolean {
    if (!ClassUnionMemberCommonParentStatic.$filter(filter, value)) {
      return false;
    }
    if (
      typeof filter.classUnionMember2Property !== "undefined" &&
      !$filterString(
        filter.classUnionMember2Property,
        value.classUnionMember2Property,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly classUnionMember2Property?: $StringFilter;
  } & ClassUnionMemberCommonParentStatic.$Filter;

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ClassUnionMember2",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      classUnionMember2Property: string;
    } & $UnwrapR<
      ReturnType<typeof ClassUnionMemberCommonParentStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const classUnionMember2Property = $jsonObject["classUnionMember2Property"];
    return ClassUnionMemberCommonParentStatic.$propertiesFromJson(
      $jsonObject,
    ).map(($super0) => ({
      ...$super0,
      $identifier,
      classUnionMember2Property,
    }));
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, ClassUnionMember2> {
    return $propertiesFromJson(json).map(
      (properties) => new ClassUnionMember2(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ClassUnionMemberCommonParentStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/classUnionMember2Property`,
          type: "Control",
        },
      ],
      label: "ClassUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ClassUnionMemberCommonParentStatic.$jsonZodSchema().merge(
      z.object({
        "@id": z.string().min(1),
        $type: z.literal("ClassUnionMember2"),
        classUnionMember2Property: z.string(),
      }),
    ) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly classUnionMember2Property: string;
  } & ClassUnionMemberCommonParentStatic.$Json;

  export function isClassUnionMember2(
    object: $Object,
  ): object is ClassUnionMember2 {
    switch (object.$type) {
      case "ClassUnionMember2":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, ClassUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return ClassUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ClassUnionMember2(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      classUnionMember2Property: string;
    } & $UnwrapR<
      ReturnType<typeof ClassUnionMemberCommonParentStatic.$propertiesFromRdf>
    >
  > {
    return ClassUnionMemberCommonParentStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/ClassUnionMember2":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  ClassUnionMember2.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ClassUnionMember2)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        Either.of<Error, ClassUnionMember2.$Identifier>(
          $parameters.resource.identifier as ClassUnionMember2.$Identifier,
        ).chain(($identifier) =>
          Either.of<Error, Resource.Values<Resource.TermValue>>(
            $parameters.resource.values(
              $schema.properties.classUnionMember2Property.identifier,
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  ClassUnionMember2.$schema.properties.classUnionMember2Property
                    .identifier,
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((classUnionMember2Property) => ({
              ...$super0,
              $identifier,
              classUnionMember2Property,
            })),
        ),
      ),
    );
  }

  export const $schema = {
    properties: {
      ...ClassUnionMemberCommonParentStatic.$schema.properties,
      classUnionMember2Property: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/classUnionMember2Property",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ClassUnionMember2.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          ClassUnionMember2.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ClassUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("classUnionMember2");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat(
      ClassUnionMemberCommonParentStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "classUnionMember2"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "classUnionMember2")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "classUnionMember2")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "classUnionMember2")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "classUnionMember2")
          }ClassUnionMember2Property`,
        ),
        predicate:
          ClassUnionMember2.$schema.properties.classUnionMember2Property
            .identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ClassUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("classUnionMember2");
    patterns = patterns.concat(
      ClassUnionMemberCommonParentStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "classUnionMember2"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable" ? subject.value : "classUnionMember2")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ClassUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "classUnionMember2")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.classUnionMember2Property,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "classUnionMember2")
                  }ClassUnionMember2Property`,
                ),
                predicate:
                  ClassUnionMember2.$schema.properties.classUnionMember2Property
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ClassUnionMember2.$schema.properties.classUnionMember2Property.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "classUnionMember2")
          }ClassUnionMember2Property`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "classUnionMember2")
        }ClassUnionMember2Property`,
      }),
    );
    return patterns;
  }
}
export class ClassUnionMember1 extends ClassUnionMemberCommonParent {
  override readonly $type: "ClassUnionMember1" = "ClassUnionMember1" as const;

  readonly classUnionMember1Property: string;

  constructor(
    parameters: {
      readonly $identifier?: (BlankNode | NamedNode) | string;
      readonly classUnionMember1Property: string;
    } & ConstructorParameters<typeof ClassUnionMemberCommonParent>[0],
  ) {
    super(parameters);
    this.classUnionMember1Property = parameters.classUnionMember1Property;
  }

  override get $identifier(): ClassUnionMember1.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: ClassUnionMember1): $EqualsResult {
    return super.$equals(other).chain(() =>
      $strictEquals(
        this.classUnionMember1Property,
        other.classUnionMember1Property,
      ).mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "classUnionMember1Property",
        propertyValuesUnequal,
        type: "property" as const,
      })),
    );
  }

  override $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    super.$hashShaclProperties(_hasher);
    _hasher.update(this.classUnionMember1Property);
    return _hasher;
  }

  override $toJson(): ClassUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        classUnionMember1Property: this.classUnionMember1Property,
      } satisfies ClassUnionMember1.$Json),
    );
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      graph: options?.graph,
      resourceSet,
    });
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/ClassUnionMember1"),
        options?.graph,
      );
    }
    resource.add(
      ClassUnionMember1.$schema.properties.classUnionMember1Property.identifier,
      [$literalFactory.string(this.classUnionMember1Property)],
      options?.graph,
    );
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ClassUnionMember1 {
  export function $filter(
    filter: ClassUnionMember1.$Filter,
    value: ClassUnionMember1,
  ): boolean {
    if (!ClassUnionMemberCommonParentStatic.$filter(filter, value)) {
      return false;
    }
    if (
      typeof filter.classUnionMember1Property !== "undefined" &&
      !$filterString(
        filter.classUnionMember1Property,
        value.classUnionMember1Property,
      )
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly classUnionMember1Property?: $StringFilter;
  } & ClassUnionMemberCommonParentStatic.$Filter;

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ClassUnionMember1",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      classUnionMember1Property: string;
    } & $UnwrapR<
      ReturnType<typeof ClassUnionMemberCommonParentStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const classUnionMember1Property = $jsonObject["classUnionMember1Property"];
    return ClassUnionMemberCommonParentStatic.$propertiesFromJson(
      $jsonObject,
    ).map(($super0) => ({
      ...$super0,
      $identifier,
      classUnionMember1Property,
    }));
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, ClassUnionMember1> {
    return $propertiesFromJson(json).map(
      (properties) => new ClassUnionMember1(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ClassUnionMemberCommonParentStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/classUnionMember1Property`,
          type: "Control",
        },
      ],
      label: "ClassUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ClassUnionMemberCommonParentStatic.$jsonZodSchema().merge(
      z.object({
        "@id": z.string().min(1),
        $type: z.literal("ClassUnionMember1"),
        classUnionMember1Property: z.string(),
      }),
    ) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly classUnionMember1Property: string;
  } & ClassUnionMemberCommonParentStatic.$Json;

  export function isClassUnionMember1(
    object: $Object,
  ): object is ClassUnionMember1 {
    switch (object.$type) {
      case "ClassUnionMember1":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, ClassUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return ClassUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ClassUnionMember1(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      classUnionMember1Property: string;
    } & $UnwrapR<
      ReturnType<typeof ClassUnionMemberCommonParentStatic.$propertiesFromRdf>
    >
  > {
    return ClassUnionMemberCommonParentStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    }).chain(($super0) =>
      (!$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/ClassUnionMember1":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  ClassUnionMember1.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ClassUnionMember1)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
      ).chain((_rdfTypeCheck) =>
        Either.of<Error, ClassUnionMember1.$Identifier>(
          $parameters.resource.identifier as ClassUnionMember1.$Identifier,
        ).chain(($identifier) =>
          Either.of<Error, Resource.Values<Resource.TermValue>>(
            $parameters.resource.values(
              $schema.properties.classUnionMember1Property.identifier,
              { unique: true },
            ),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  ClassUnionMember1.$schema.properties.classUnionMember1Property
                    .identifier,
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString()))
            .chain((values) => values.head())
            .map((classUnionMember1Property) => ({
              ...$super0,
              $identifier,
              classUnionMember1Property,
            })),
        ),
      ),
    );
  }

  export const $schema = {
    properties: {
      ...ClassUnionMemberCommonParentStatic.$schema.properties,
      classUnionMember1Property: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/classUnionMember1Property",
        ),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ClassUnionMember1.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          ClassUnionMember1.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ClassUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("classUnionMember1");
    let triples: sparqljs.Triple[] = [];
    triples = triples.concat(
      ClassUnionMemberCommonParentStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "classUnionMember1"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "classUnionMember1")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "classUnionMember1")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "classUnionMember1")
            }RdfClass`,
          ),
        },
      );
    }
    triples = triples.concat([
      {
        object: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "classUnionMember1")
          }ClassUnionMember1Property`,
        ),
        predicate:
          ClassUnionMember1.$schema.properties.classUnionMember1Property
            .identifier,
        subject: subject,
      },
    ]);
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ClassUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("classUnionMember1");
    patterns = patterns.concat(
      ClassUnionMemberCommonParentStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject: subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "classUnionMember1"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable" ? subject.value : "classUnionMember1")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ClassUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "classUnionMember1")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    patterns = patterns.concat(
      $stringSparqlWherePatterns({
        filter: parameters?.filter?.classUnionMember1Property,
        preferredLanguages: parameters?.preferredLanguages,
        propertyPatterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${
                    parameters?.variablePrefix ??
                    (subject.termType === "Variable"
                      ? subject.value
                      : "classUnionMember1")
                  }ClassUnionMember1Property`,
                ),
                predicate:
                  ClassUnionMember1.$schema.properties.classUnionMember1Property
                    .identifier,
                subject: subject,
              },
            ],
            type: "bgp",
          } satisfies sparqljs.BgpPattern,
        ],
        schema:
          ClassUnionMember1.$schema.properties.classUnionMember1Property.type(),
        valueVariable: dataFactory.variable!(
          `${
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "classUnionMember1")
          }ClassUnionMember1Property`,
        ),
        variablePrefix: `${
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "classUnionMember1")
        }ClassUnionMember1Property`,
      }),
    );
    return patterns;
  }
} /**
 * Node shape that can have a blank node or IRI as an identifier
 */

export interface BlankNodeOrIriIdentifierInterface {
  readonly $identifier: BlankNodeOrIriIdentifierInterface.$Identifier;
  readonly $type: "BlankNodeOrIriIdentifierInterface";
}

export namespace BlankNodeOrIriIdentifierInterface {
  export function $create(parameters?: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
  }): BlankNodeOrIriIdentifierInterface {
    let $identifier: BlankNodeOrIriIdentifierInterface.$Identifier;
    if (typeof parameters?.$identifier === "object") {
      $identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters?.$identifier satisfies never;
    }
    const $type = "BlankNodeOrIriIdentifierInterface" as const;
    return { $identifier, $type };
  }

  export function $equals(
    left: BlankNodeOrIriIdentifierInterface,
    right: BlankNodeOrIriIdentifierInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      );
  }

  export function $hash<HasherT extends $Hasher>(
    _blankNodeOrIriIdentifierInterface: BlankNodeOrIriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    BlankNodeOrIriIdentifierInterface.$hashShaclProperties(
      _blankNodeOrIriIdentifierInterface,
      _hasher,
    );
    _hasher.update(_blankNodeOrIriIdentifierInterface.$identifier.value);
    _hasher.update(_blankNodeOrIriIdentifierInterface.$type);
    return _hasher;
  }

  export function $hashShaclProperties<HasherT extends $Hasher>(
    _blankNodeOrIriIdentifierInterface: BlankNodeOrIriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    return _hasher;
  }

  export function $filter(
    filter: BlankNodeOrIriIdentifierInterface.$Filter,
    value: BlankNodeOrIriIdentifierInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = { readonly $identifier?: $IdentifierFilter };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/BlankNodeOrIriIdentifierInterface",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(_json: unknown): Either<
    z.ZodError,
    {
      $identifier: BlankNode | NamedNode;
      $type: "BlankNodeOrIriIdentifierInterface";
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "BlankNodeOrIriIdentifierInterface" as const;
    return Either.of({ $identifier, $type });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, BlankNodeOrIriIdentifierInterface> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "BlankNodeOrIriIdentifierInterface" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "BlankNodeOrIriIdentifierInterface",
      type: "Group",
    };
  }

  export function $toJson(
    _blankNodeOrIriIdentifierInterface: BlankNodeOrIriIdentifierInterface,
  ): BlankNodeOrIriIdentifierInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _blankNodeOrIriIdentifierInterface.$identifier.termType ===
          "BlankNode"
            ? `_:${_blankNodeOrIriIdentifierInterface.$identifier.value}`
            : _blankNodeOrIriIdentifierInterface.$identifier.value,
        $type: _blankNodeOrIriIdentifierInterface.$type,
      } satisfies BlankNodeOrIriIdentifierInterface.$Json),
    );
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("BlankNodeOrIriIdentifierInterface"),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "BlankNodeOrIriIdentifierInterface";
  };

  export function isBlankNodeOrIriIdentifierInterface(
    object: $Object,
  ): object is BlankNodeOrIriIdentifierInterface {
    switch (object.$type) {
      case "BlankNodeOrIriIdentifierInterface":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, BlankNodeOrIriIdentifierInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return BlankNodeOrIriIdentifierInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    {
      $identifier: BlankNode | NamedNode;
      $type: "BlankNodeOrIriIdentifierInterface";
    }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/BlankNodeOrIriIdentifierInterface":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  BlankNodeOrIriIdentifierInterface.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/BlankNodeOrIriIdentifierInterface)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, BlankNodeOrIriIdentifierInterface.$Identifier>(
        $parameters.resource
          .identifier as BlankNodeOrIriIdentifierInterface.$Identifier,
      ).chain(($identifier) =>
        Either.of<Error, "BlankNodeOrIriIdentifierInterface">(
          "BlankNodeOrIriIdentifierInterface" as const,
        ).map(($type) => ({ $identifier, $type })),
      ),
    );
  }

  export function $toRdf(
    _blankNodeOrIriIdentifierInterface: BlankNodeOrIriIdentifierInterface,
    options?: {
      ignoreRdfType?: boolean;
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(
      _blankNodeOrIriIdentifierInterface.$identifier,
    );
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode(
          "http://example.com/BlankNodeOrIriIdentifierInterface",
        ),
        options?.graph,
      );
    }
    return resource;
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["BlankNodeOrIriIdentifierInterface"],
        }),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: BlankNodeOrIriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BlankNodeOrIriIdentifierInterface.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          BlankNodeOrIriIdentifierInterface.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: BlankNodeOrIriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BlankNodeOrIriIdentifierInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("blankNodeOrIriIdentifierInterface");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "blankNodeOrIriIdentifierInterface")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "blankNodeOrIriIdentifierInterface")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "blankNodeOrIriIdentifierInterface")
            }RdfClass`,
          ),
        },
      );
    }
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: BlankNodeOrIriIdentifierInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("blankNodeOrIriIdentifierInterface");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "blankNodeOrIriIdentifierInterface")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: BlankNodeOrIriIdentifierInterface.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "blankNodeOrIriIdentifierInterface")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            BlankNodeOrIriIdentifierInterface.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "blankNodeOrIriIdentifierInterface"),
        }),
      );
    }
    return patterns;
  }
} /**
 * Node shape that can have a blank node or IRI as an identifier
 */

export class BlankNodeOrIriIdentifierClass {
  private _$identifier?: BlankNodeOrIriIdentifierClass.$Identifier;

  readonly $type: "BlankNodeOrIriIdentifierClass" =
    "BlankNodeOrIriIdentifierClass" as const;

  constructor(parameters?: {
    readonly $identifier?: (BlankNode | NamedNode) | string;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }
  }

  get $identifier(): BlankNodeOrIriIdentifierClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  $equals(other: BlankNodeOrIriIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    return _hasher;
  }

  $toJson(): BlankNodeOrIriIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
      } satisfies BlankNodeOrIriIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode(
          "http://example.com/BlankNodeOrIriIdentifierClass",
        ),
        options?.graph,
      );
    }
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace BlankNodeOrIriIdentifierClass {
  export function $filter(
    filter: BlankNodeOrIriIdentifierClass.$Filter,
    value: BlankNodeOrIriIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = { readonly $identifier?: $IdentifierFilter };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/BlankNodeOrIriIdentifierClass",
  );

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<z.ZodError, { $identifier: BlankNode | NamedNode }> {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    return Either.of({ $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, BlankNodeOrIriIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new BlankNodeOrIriIdentifierClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "BlankNodeOrIriIdentifierClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "BlankNodeOrIriIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("BlankNodeOrIriIdentifierClass"),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "BlankNodeOrIriIdentifierClass";
  };

  export function isBlankNodeOrIriIdentifierClass(
    object: $Object,
  ): object is BlankNodeOrIriIdentifierClass {
    switch (object.$type) {
      case "BlankNodeOrIriIdentifierClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, BlankNodeOrIriIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return BlankNodeOrIriIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new BlankNodeOrIriIdentifierClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<Error, { $identifier: BlankNode | NamedNode }> {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/BlankNodeOrIriIdentifierClass":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  BlankNodeOrIriIdentifierClass.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/BlankNodeOrIriIdentifierClass)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      Either.of<Error, BlankNodeOrIriIdentifierClass.$Identifier>(
        $parameters.resource
          .identifier as BlankNodeOrIriIdentifierClass.$Identifier,
      ).map(($identifier) => ({ $identifier })),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "Identifier" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["BlankNodeOrIriIdentifierClass"],
        }),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: BlankNodeOrIriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BlankNodeOrIriIdentifierClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          BlankNodeOrIriIdentifierClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: BlankNodeOrIriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BlankNodeOrIriIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("blankNodeOrIriIdentifierClass");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "blankNodeOrIriIdentifierClass")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "blankNodeOrIriIdentifierClass")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "blankNodeOrIriIdentifierClass")
            }RdfClass`,
          ),
        },
      );
    }
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: BlankNodeOrIriIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("blankNodeOrIriIdentifierClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "blankNodeOrIriIdentifierClass")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: BlankNodeOrIriIdentifierClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "blankNodeOrIriIdentifierClass")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            BlankNodeOrIriIdentifierClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "blankNodeOrIriIdentifierClass"),
        }),
      );
    }
    return patterns;
  }
} /**
 * Node shape that can only have a blank node as an identifier
 */

export interface BlankNodeIdentifierInterface {
  readonly $identifier: BlankNodeIdentifierInterface.$Identifier;
  readonly $type: "BlankNodeIdentifierInterface";
}

export namespace BlankNodeIdentifierInterface {
  export function $create(parameters?: {
    readonly $identifier?: BlankNode;
  }): BlankNodeIdentifierInterface {
    let $identifier: BlankNodeIdentifierInterface.$Identifier;
    if (typeof parameters?.$identifier === "object") {
      $identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters?.$identifier satisfies never;
    }
    const $type = "BlankNodeIdentifierInterface" as const;
    return { $identifier, $type };
  }

  export function $equals(
    left: BlankNodeIdentifierInterface,
    right: BlankNodeIdentifierInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      );
  }

  export function $hash<HasherT extends $Hasher>(
    _blankNodeIdentifierInterface: BlankNodeIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    BlankNodeIdentifierInterface.$hashShaclProperties(
      _blankNodeIdentifierInterface,
      _hasher,
    );
    _hasher.update(_blankNodeIdentifierInterface.$identifier.value);
    _hasher.update(_blankNodeIdentifierInterface.$type);
    return _hasher;
  }

  export function $hashShaclProperties<HasherT extends $Hasher>(
    _blankNodeIdentifierInterface: BlankNodeIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    return _hasher;
  }

  export function $filter(
    filter: BlankNodeIdentifierInterface.$Filter,
    value: BlankNodeIdentifierInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterBlankNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = { readonly $identifier?: $BlankNodeFilter };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/BlankNodeIdentifierInterface",
  );

  export type $Identifier = BlankNode;

  export namespace $Identifier {
    export const fromString = $blankNodeFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<
    z.ZodError,
    { $identifier: BlankNode; $type: "BlankNodeIdentifierInterface" }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.blankNode($jsonObject["@id"].substring(2));
    const $type = "BlankNodeIdentifierInterface" as const;
    return Either.of({ $identifier, $type });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, BlankNodeIdentifierInterface> {
    return $propertiesFromJson(json);
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "BlankNodeIdentifierInterface" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "BlankNodeIdentifierInterface",
      type: "Group",
    };
  }

  export function $toJson(
    _blankNodeIdentifierInterface: BlankNodeIdentifierInterface,
  ): BlankNodeIdentifierInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": `_:${_blankNodeIdentifierInterface.$identifier.value}`,
        $type: _blankNodeIdentifierInterface.$type,
      } satisfies BlankNodeIdentifierInterface.$Json),
    );
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("BlankNodeIdentifierInterface"),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "BlankNodeIdentifierInterface";
  };

  export function isBlankNodeIdentifierInterface(
    object: $Object,
  ): object is BlankNodeIdentifierInterface {
    switch (object.$type) {
      case "BlankNodeIdentifierInterface":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, BlankNodeIdentifierInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return BlankNodeIdentifierInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<
    Error,
    { $identifier: BlankNode; $type: "BlankNodeIdentifierInterface" }
  > {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/BlankNodeIdentifierInterface":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  BlankNodeIdentifierInterface.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/BlankNodeIdentifierInterface)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      ($parameters.resource.identifier.termType === "BlankNode"
        ? Either.of<Error, BlankNodeIdentifierInterface.$Identifier>(
            $parameters.resource.identifier,
          )
        : Left(
            new Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "BlankNode",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
      ).chain(($identifier) =>
        Either.of<Error, "BlankNodeIdentifierInterface">(
          "BlankNodeIdentifierInterface" as const,
        ).map(($type) => ({ $identifier, $type })),
      ),
    );
  }

  export function $toRdf(
    _blankNodeIdentifierInterface: BlankNodeIdentifierInterface,
    options?: {
      ignoreRdfType?: boolean;
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(
      _blankNodeIdentifierInterface.$identifier,
    );
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode(
          "http://example.com/BlankNodeIdentifierInterface",
        ),
        options?.graph,
      );
    }
    return resource;
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "BlankNode" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["BlankNodeIdentifierInterface"],
        }),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: BlankNodeIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BlankNodeIdentifierInterface.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          BlankNodeIdentifierInterface.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: BlankNodeIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BlankNodeIdentifierInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("blankNodeIdentifierInterface");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "blankNodeIdentifierInterface")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "blankNodeIdentifierInterface")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "blankNodeIdentifierInterface")
            }RdfClass`,
          ),
        },
      );
    }
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: BlankNodeIdentifierInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("blankNodeIdentifierInterface");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "blankNodeIdentifierInterface")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: BlankNodeIdentifierInterface.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "blankNodeIdentifierInterface")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $blankNodeSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            BlankNodeIdentifierInterface.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "blankNodeIdentifierInterface"),
        }),
      );
    }
    return patterns;
  }
} /**
 * Node shape that can only have a blank node as an identifier
 */

export class BlankNodeIdentifierClass {
  private _$identifier?: BlankNodeIdentifierClass.$Identifier;

  readonly $type: "BlankNodeIdentifierClass" =
    "BlankNodeIdentifierClass" as const;

  constructor(parameters?: { readonly $identifier?: BlankNode }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }
  }

  get $identifier(): BlankNodeIdentifierClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    if (this._$identifier.termType !== "BlankNode") {
      throw new Error(
        `expected identifier to be BlankNode, not ${this._$identifier.termType}`,
      );
    }
    return this._$identifier;
  }

  $equals(other: BlankNodeIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "property" as const,
          }),
        ),
      );
  }

  $hash<HasherT extends $Hasher>(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    return _hasher;
  }

  protected $hashShaclProperties<HasherT extends $Hasher>(
    _hasher: HasherT,
  ): HasherT {
    return _hasher;
  }

  $toJson(): BlankNodeIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": `_:${this.$identifier.value}`,
        $type: this.$type,
      } satisfies BlankNodeIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    graph?: Exclude<Quad_Graph, Variable>;
    resourceSet?: ResourceSet;
  }): Resource {
    const resourceSet =
      options?.resourceSet ??
      new ResourceSet($datasetFactory.dataset(), { dataFactory: dataFactory });
    const resource = resourceSet.resource(this.$identifier);
    if (!options?.ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        dataFactory.namedNode("http://example.com/BlankNodeIdentifierClass"),
        options?.graph,
      );
    }
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace BlankNodeIdentifierClass {
  export function $filter(
    filter: BlankNodeIdentifierClass.$Filter,
    value: BlankNodeIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterBlankNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    return true;
  }

  export type $Filter = { readonly $identifier?: $BlankNodeFilter };

  export const $fromRdfType: NamedNode<string> = dataFactory.namedNode(
    "http://example.com/BlankNodeIdentifierClass",
  );

  export type $Identifier = BlankNode;

  export namespace $Identifier {
    export const fromString = $blankNodeFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $propertiesFromJson(
    _json: unknown,
  ): Either<z.ZodError, { $identifier: BlankNode }> {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return Left($jsonSafeParseResult.error);
    }
    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.blankNode($jsonObject["@id"].substring(2));
    return Either.of({ $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, BlankNodeIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new BlankNodeIdentifierClass(properties),
    );
  }

  export function $jsonSchema() {
    return z.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "BlankNodeIdentifierClass" as const },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "BlankNodeIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return z.object({
      "@id": z.string().min(1),
      $type: z.literal("BlankNodeIdentifierClass"),
    }) satisfies z.ZodType<$Json>;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "BlankNodeIdentifierClass";
  };

  export function isBlankNodeIdentifierClass(
    object: $Object,
  ): object is BlankNodeIdentifierClass {
    switch (object.$type) {
      case "BlankNodeIdentifierClass":
        return true;
      default:
        return false;
    }
  }

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, BlankNodeIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet(resource.dataset);
    }
    return BlankNodeIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new BlankNodeIdentifierClass(properties));
  }

  export function $propertiesFromRdf(
    $parameters: $PropertiesFromRdfParameters,
  ): Either<Error, { $identifier: BlankNode }> {
    return (
      !$parameters.ignoreRdfType
        ? $parameters.resource
            .value($RdfVocabularies.rdf.type)
            .chain((actualRdfType) => actualRdfType.toIri())
            .chain((actualRdfType) => {
              // Check the expected type and its known subtypes
              switch (actualRdfType.value) {
                case "http://example.com/BlankNodeIdentifierClass":
                  return Either.of<Error, true>(true);
              }

              // Check arbitrary rdfs:subClassOf's of the expected type
              if (
                $parameters.resource.isInstanceOf(
                  BlankNodeIdentifierClass.$fromRdfType,
                )
              ) {
                return Either.of<Error, true>(true);
              }

              return Left(
                new Error(
                  `${Resource.Identifier.toString(
                    $parameters.resource.identifier,
                  )} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/BlankNodeIdentifierClass)`,
                ),
              );
            })
        : Either.of<Error, true>(true)
    ).chain((_rdfTypeCheck) =>
      ($parameters.resource.identifier.termType === "BlankNode"
        ? Either.of<Error, BlankNodeIdentifierClass.$Identifier>(
            $parameters.resource.identifier,
          )
        : Left(
            new Resource.MistypedTermValueError({
              actualValue: $parameters.resource.identifier,
              expectedValueType: "BlankNode",
              focusResource: $parameters.resource,
              predicate: $RdfVocabularies.rdf.subject,
            }),
          )
      ).map(($identifier) => ({ $identifier })),
    );
  }

  export const $schema = {
    properties: {
      $identifier: {
        kind: "Identifier" as const,
        type: () => ({ kind: "BlankNode" as const }),
      },
      $type: {
        kind: "TypeDiscriminant" as const,
        type: () => ({
          kind: "TypeDiscriminant" as const,
          ownValues: ["BlankNodeIdentifierClass"],
        }),
      },
    },
  } as const;

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: BlankNodeIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BlankNodeIdentifierClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          BlankNodeIdentifierClass.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: BlankNodeIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BlankNodeIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("blankNodeIdentifierClass");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "blankNodeIdentifierClass")
            }RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "blankNodeIdentifierClass")
            }RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${
              parameters?.variablePrefix ??
              (subject.termType === "Variable"
                ? subject.value
                : "blankNodeIdentifierClass")
            }RdfClass`,
          ),
        },
      );
    }
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: BlankNodeIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("blankNodeIdentifierClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${
        parameters?.variablePrefix ??
        (subject.termType === "Variable"
          ? subject.value
          : "blankNodeIdentifierClass")
      }RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: BlankNodeIdentifierClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${
                      parameters?.variablePrefix ??
                      (subject.termType === "Variable"
                        ? subject.value
                        : "blankNodeIdentifierClass")
                    }RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $blankNodeSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema:
            BlankNodeIdentifierClass.$schema.properties.$identifier.type(),
          valueVariable: subject,
          variablePrefix:
            parameters?.variablePrefix ??
            (subject.termType === "Variable"
              ? subject.value
              : "blankNodeIdentifierClass"),
        }),
      );
    }
    return patterns;
  }
} /**
 * Node shape sh:xone's other node shapes. This will usually be generated as a discriminated union.
 */

export type ClassUnion = ClassUnionMember1 | ClassUnionMember2;

export namespace ClassUnion {
  export function $equals(left: ClassUnion, right: ClassUnion): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      if (ClassUnionMember1.isClassUnionMember1(left)) {
        return left.$equals(right as unknown as ClassUnionMember1);
      }
      if (ClassUnionMember2.isClassUnionMember2(left)) {
        return left.$equals(right as unknown as ClassUnionMember2);
      }
      return $EqualsResult.Equal;
    });
  }

  export function $filter(
    filter: ClassUnion.$Filter,
    value: ClassUnion,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      ClassUnionMember1.isClassUnionMember1(value) &&
      filter.on?.ClassUnionMember1 &&
      !ClassUnionMember1.$filter(
        filter.on.ClassUnionMember1,
        value as ClassUnionMember1,
      )
    ) {
      return false;
    }
    if (
      ClassUnionMember2.isClassUnionMember2(value) &&
      filter.on?.ClassUnionMember2 &&
      !ClassUnionMember2.$filter(
        filter.on.ClassUnionMember2,
        value as ClassUnionMember2,
      )
    ) {
      return false;
    }
    return true;
  }

  export interface $Filter {
    readonly $identifier?: $IdentifierFilter;
    readonly on?: {
      readonly ClassUnionMember1?: Omit<
        ClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly ClassUnionMember2?: Omit<
        ClassUnionMember2.$Filter,
        "$identifier"
      >;
    };
  }

  export function $hash<HasherT extends $Hasher>(
    _classUnion: ClassUnion,
    _hasher: HasherT,
  ): HasherT {
    if (ClassUnionMember1.isClassUnionMember1(_classUnion)) {
      return _classUnion.$hash(_hasher);
    }
    if (ClassUnionMember2.isClassUnionMember2(_classUnion)) {
      return _classUnion.$hash(_hasher);
    }
    throw new Error("unrecognized type");
  }

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $fromJson(json: unknown): Either<z.ZodError, ClassUnion> {
    return (
      ClassUnionMember1.$fromJson(json) as Either<z.ZodError, ClassUnion>
    ).altLazy(
      () => ClassUnionMember2.$fromJson(json) as Either<z.ZodError, ClassUnion>,
    );
  }

  export function $jsonZodSchema() {
    return z.discriminatedUnion("$type", [
      ClassUnionMember1.$jsonZodSchema(),
      ClassUnionMember2.$jsonZodSchema(),
    ]);
  }

  export function $toJson(
    _classUnion: ClassUnion,
  ): ClassUnionMember1.$Json | ClassUnionMember2.$Json {
    if (ClassUnionMember1.isClassUnionMember1(_classUnion)) {
      return _classUnion.$toJson();
    }
    if (ClassUnionMember2.isClassUnionMember2(_classUnion)) {
      return _classUnion.$toJson();
    }
    throw new Error("unrecognized type");
  }

  export type $Json = ClassUnionMember1.$Json | ClassUnionMember2.$Json;

  export function isClassUnion(object: $Object): object is ClassUnion {
    return (
      ClassUnionMember1.isClassUnionMember1(object) ||
      ClassUnionMember2.isClassUnionMember2(object)
    );
  }

  export const $schema = {
    properties: {
      classUnionMemberCommonParentProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/classUnionMemberCommonParentProperty",
        ),
      },
    },
  } as const;

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, ClassUnion> {
    return (
      ClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as Either<Error, ClassUnion>
    ).altLazy(
      () =>
        ClassUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as Either<Error, ClassUnion>,
    );
  }

  export function $toRdf(
    _classUnion: ClassUnion,
    _parameters?: {
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    if (ClassUnionMember1.isClassUnionMember1(_classUnion)) {
      return _classUnion.$toRdf(_parameters);
    }
    if (ClassUnionMember2.isClassUnionMember2(_classUnion)) {
      return _classUnion.$toRdf(_parameters);
    }
    throw new Error("unrecognized type");
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ClassUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ClassUnion.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          ClassUnion.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ClassUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...ClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("classUnionClassUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ClassUnionMember1`
          : "classUnionClassUnionMember1",
      }).concat(),
      ...ClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("classUnionClassUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ClassUnionMember2`
          : "classUnionClassUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ClassUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("classUnion");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          ignoreRdfType: false,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: { kind: "Identifier" as const },
          valueVariable: subject,
          variablePrefix:
            subject.termType === "Variable" ? subject.value : "classUnion",
        }),
      );
    }
    patterns.push({
      patterns: [
        {
          patterns: ClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!("classUnionClassUnionMember1"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ClassUnionMember1`
              : "classUnionClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: ClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!("classUnionClassUnionMember2"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ClassUnionMember2`
              : "classUnionClassUnionMember2",
          }).concat(),
          type: "group",
        },
      ],
      type: "union",
    });
    return patterns;
  }
} /**
 * Node shape that unions a node shape and another union of node shapes. Generated code will usually flatten these.
 */

export type FlattenClassUnion =
  | ClassUnionMember1
  | ClassUnionMember2
  | FlattenClassUnionMember3;

export namespace FlattenClassUnion {
  export function $equals(
    left: FlattenClassUnion,
    right: FlattenClassUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      if (ClassUnionMember1.isClassUnionMember1(left)) {
        return left.$equals(right as unknown as ClassUnionMember1);
      }
      if (ClassUnionMember2.isClassUnionMember2(left)) {
        return left.$equals(right as unknown as ClassUnionMember2);
      }
      if (FlattenClassUnionMember3.isFlattenClassUnionMember3(left)) {
        return left.$equals(right as unknown as FlattenClassUnionMember3);
      }
      return $EqualsResult.Equal;
    });
  }

  export function $filter(
    filter: FlattenClassUnion.$Filter,
    value: FlattenClassUnion,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      ClassUnionMember1.isClassUnionMember1(value) &&
      filter.on?.ClassUnionMember1 &&
      !ClassUnionMember1.$filter(
        filter.on.ClassUnionMember1,
        value as ClassUnionMember1,
      )
    ) {
      return false;
    }
    if (
      ClassUnionMember2.isClassUnionMember2(value) &&
      filter.on?.ClassUnionMember2 &&
      !ClassUnionMember2.$filter(
        filter.on.ClassUnionMember2,
        value as ClassUnionMember2,
      )
    ) {
      return false;
    }
    if (
      FlattenClassUnionMember3.isFlattenClassUnionMember3(value) &&
      filter.on?.FlattenClassUnionMember3 &&
      !FlattenClassUnionMember3.$filter(
        filter.on.FlattenClassUnionMember3,
        value as FlattenClassUnionMember3,
      )
    ) {
      return false;
    }
    return true;
  }

  export interface $Filter {
    readonly $identifier?: $IdentifierFilter;
    readonly on?: {
      readonly ClassUnionMember1?: Omit<
        ClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly ClassUnionMember2?: Omit<
        ClassUnionMember2.$Filter,
        "$identifier"
      >;
      readonly FlattenClassUnionMember3?: Omit<
        FlattenClassUnionMember3.$Filter,
        "$identifier"
      >;
    };
  }

  export function $hash<HasherT extends $Hasher>(
    _flattenClassUnion: FlattenClassUnion,
    _hasher: HasherT,
  ): HasherT {
    if (ClassUnionMember1.isClassUnionMember1(_flattenClassUnion)) {
      return _flattenClassUnion.$hash(_hasher);
    }
    if (ClassUnionMember2.isClassUnionMember2(_flattenClassUnion)) {
      return _flattenClassUnion.$hash(_hasher);
    }
    if (
      FlattenClassUnionMember3.isFlattenClassUnionMember3(_flattenClassUnion)
    ) {
      return _flattenClassUnion.$hash(_hasher);
    }
    throw new Error("unrecognized type");
  }

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, FlattenClassUnion> {
    return (
      ClassUnionMember1.$fromJson(json) as Either<z.ZodError, FlattenClassUnion>
    )
      .altLazy(
        () =>
          ClassUnionMember2.$fromJson(json) as Either<
            z.ZodError,
            FlattenClassUnion
          >,
      )
      .altLazy(
        () =>
          FlattenClassUnionMember3.$fromJson(json) as Either<
            z.ZodError,
            FlattenClassUnion
          >,
      );
  }

  export function $jsonZodSchema() {
    return z.discriminatedUnion("$type", [
      ClassUnionMember1.$jsonZodSchema(),
      ClassUnionMember2.$jsonZodSchema(),
      FlattenClassUnionMember3.$jsonZodSchema(),
    ]);
  }

  export function $toJson(
    _flattenClassUnion: FlattenClassUnion,
  ):
    | ClassUnionMember1.$Json
    | ClassUnionMember2.$Json
    | FlattenClassUnionMember3.$Json {
    if (ClassUnionMember1.isClassUnionMember1(_flattenClassUnion)) {
      return _flattenClassUnion.$toJson();
    }
    if (ClassUnionMember2.isClassUnionMember2(_flattenClassUnion)) {
      return _flattenClassUnion.$toJson();
    }
    if (
      FlattenClassUnionMember3.isFlattenClassUnionMember3(_flattenClassUnion)
    ) {
      return _flattenClassUnion.$toJson();
    }
    throw new Error("unrecognized type");
  }

  export type $Json =
    | ClassUnionMember1.$Json
    | ClassUnionMember2.$Json
    | FlattenClassUnionMember3.$Json;

  export function isFlattenClassUnion(
    object: $Object,
  ): object is FlattenClassUnion {
    return (
      ClassUnionMember1.isClassUnionMember1(object) ||
      ClassUnionMember2.isClassUnionMember2(object) ||
      FlattenClassUnionMember3.isFlattenClassUnionMember3(object)
    );
  }

  export const $schema = { properties: {} } as const;

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, FlattenClassUnion> {
    return (
      ClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as Either<Error, FlattenClassUnion>
    )
      .altLazy(
        () =>
          ClassUnionMember2.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, FlattenClassUnion>,
      )
      .altLazy(
        () =>
          FlattenClassUnionMember3.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, FlattenClassUnion>,
      );
  }

  export function $toRdf(
    _flattenClassUnion: FlattenClassUnion,
    _parameters?: {
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    if (ClassUnionMember1.isClassUnionMember1(_flattenClassUnion)) {
      return _flattenClassUnion.$toRdf(_parameters);
    }
    if (ClassUnionMember2.isClassUnionMember2(_flattenClassUnion)) {
      return _flattenClassUnion.$toRdf(_parameters);
    }
    if (
      FlattenClassUnionMember3.isFlattenClassUnionMember3(_flattenClassUnion)
    ) {
      return _flattenClassUnion.$toRdf(_parameters);
    }
    throw new Error("unrecognized type");
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: FlattenClassUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        FlattenClassUnion.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          FlattenClassUnion.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: FlattenClassUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      FlattenClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...ClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("flattenClassUnionClassUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ClassUnionMember1`
          : "flattenClassUnionClassUnionMember1",
      }).concat(),
      ...ClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("flattenClassUnionClassUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ClassUnionMember2`
          : "flattenClassUnionClassUnionMember2",
      }).concat(),
      ...FlattenClassUnionMember3.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("flattenClassUnionFlattenClassUnionMember3"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}FlattenClassUnionMember3`
          : "flattenClassUnionFlattenClassUnionMember3",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: FlattenClassUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("flattenClassUnion");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          ignoreRdfType: false,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: { kind: "Identifier" as const },
          valueVariable: subject,
          variablePrefix:
            subject.termType === "Variable"
              ? subject.value
              : "flattenClassUnion",
        }),
      );
    }
    patterns.push({
      patterns: [
        {
          patterns: ClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!("flattenClassUnionClassUnionMember1"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ClassUnionMember1`
              : "flattenClassUnionClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: ClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!("flattenClassUnionClassUnionMember2"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ClassUnionMember2`
              : "flattenClassUnionClassUnionMember2",
          }).concat(),
          type: "group",
        },
        {
          patterns: FlattenClassUnionMember3.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.FlattenClassUnionMember3,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "flattenClassUnionFlattenClassUnionMember3",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}FlattenClassUnionMember3`
              : "flattenClassUnionFlattenClassUnionMember3",
          }).concat(),
          type: "group",
        },
      ],
      type: "union",
    });
    return patterns;
  }
} /**
 * Node shape that sh:xone's other node shapes. This will usually be generated as a discriminated union.
 */

export type InterfaceUnion = InterfaceUnionMember1 | InterfaceUnionMember2;

export namespace InterfaceUnion {
  export function $equals(
    left: InterfaceUnion,
    right: InterfaceUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      if (InterfaceUnionMember1.isInterfaceUnionMember1(left)) {
        return InterfaceUnionMember1.$equals(
          left,
          right as unknown as InterfaceUnionMember1,
        );
      }
      if (InterfaceUnionMember2.isInterfaceUnionMember2(left)) {
        return InterfaceUnionMember2.$equals(
          left,
          right as unknown as InterfaceUnionMember2,
        );
      }
      return $EqualsResult.Equal;
    });
  }

  export function $filter(
    filter: InterfaceUnion.$Filter,
    value: InterfaceUnion,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      InterfaceUnionMember1.isInterfaceUnionMember1(value) &&
      filter.on?.InterfaceUnionMember1 &&
      !InterfaceUnionMember1.$filter(
        filter.on.InterfaceUnionMember1,
        value as InterfaceUnionMember1,
      )
    ) {
      return false;
    }
    if (
      InterfaceUnionMember2.isInterfaceUnionMember2(value) &&
      filter.on?.InterfaceUnionMember2 &&
      !InterfaceUnionMember2.$filter(
        filter.on.InterfaceUnionMember2,
        value as InterfaceUnionMember2,
      )
    ) {
      return false;
    }
    return true;
  }

  export interface $Filter {
    readonly $identifier?: $IdentifierFilter;
    readonly on?: {
      readonly InterfaceUnionMember1?: Omit<
        InterfaceUnionMember1.$Filter,
        "$identifier"
      >;
      readonly InterfaceUnionMember2?: Omit<
        InterfaceUnionMember2.$Filter,
        "$identifier"
      >;
    };
  }

  export function $hash<HasherT extends $Hasher>(
    _interfaceUnion: InterfaceUnion,
    _hasher: HasherT,
  ): HasherT {
    if (InterfaceUnionMember1.isInterfaceUnionMember1(_interfaceUnion)) {
      return InterfaceUnionMember1.$hash(_interfaceUnion, _hasher);
    }
    if (InterfaceUnionMember2.isInterfaceUnionMember2(_interfaceUnion)) {
      return InterfaceUnionMember2.$hash(_interfaceUnion, _hasher);
    }
    throw new Error("unrecognized type");
  }

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $fromJson(json: unknown): Either<z.ZodError, InterfaceUnion> {
    return (
      InterfaceUnionMember1.$fromJson(json) as Either<
        z.ZodError,
        InterfaceUnion
      >
    ).altLazy(
      () =>
        InterfaceUnionMember2.$fromJson(json) as Either<
          z.ZodError,
          InterfaceUnion
        >,
    );
  }

  export function $jsonZodSchema() {
    return z.discriminatedUnion("$type", [
      InterfaceUnionMember1.$jsonZodSchema(),
      InterfaceUnionMember2.$jsonZodSchema(),
    ]);
  }

  export function $toJson(
    _interfaceUnion: InterfaceUnion,
  ): InterfaceUnionMember1.$Json | InterfaceUnionMember2.$Json {
    if (InterfaceUnionMember1.isInterfaceUnionMember1(_interfaceUnion)) {
      return InterfaceUnionMember1.$toJson(_interfaceUnion);
    }
    if (InterfaceUnionMember2.isInterfaceUnionMember2(_interfaceUnion)) {
      return InterfaceUnionMember2.$toJson(_interfaceUnion);
    }
    throw new Error("unrecognized type");
  }

  export type $Json = InterfaceUnionMember1.$Json | InterfaceUnionMember2.$Json;

  export function isInterfaceUnion(object: $Object): object is InterfaceUnion {
    return (
      InterfaceUnionMember1.isInterfaceUnionMember1(object) ||
      InterfaceUnionMember2.isInterfaceUnionMember2(object)
    );
  }

  export const $schema = {
    properties: {
      interfaceUnionMemberCommonParentProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/interfaceUnionMemberCommonParentProperty",
        ),
      },
    },
  } as const;

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, InterfaceUnion> {
    return (
      InterfaceUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as Either<Error, InterfaceUnion>
    ).altLazy(
      () =>
        InterfaceUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as Either<Error, InterfaceUnion>,
    );
  }

  export function $toRdf(
    _interfaceUnion: InterfaceUnion,
    _parameters?: {
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    if (InterfaceUnionMember1.isInterfaceUnionMember1(_interfaceUnion)) {
      return InterfaceUnionMember1.$toRdf(_interfaceUnion, _parameters);
    }
    if (InterfaceUnionMember2.isInterfaceUnionMember2(_interfaceUnion)) {
      return InterfaceUnionMember2.$toRdf(_interfaceUnion, _parameters);
    }
    throw new Error("unrecognized type");
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: InterfaceUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InterfaceUnion.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          InterfaceUnion.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: InterfaceUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InterfaceUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...InterfaceUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("interfaceUnionInterfaceUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}InterfaceUnionMember1`
          : "interfaceUnionInterfaceUnionMember1",
      }).concat(),
      ...InterfaceUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("interfaceUnionInterfaceUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}InterfaceUnionMember2`
          : "interfaceUnionInterfaceUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: InterfaceUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("interfaceUnion");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          ignoreRdfType: false,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: { kind: "Identifier" as const },
          valueVariable: subject,
          variablePrefix:
            subject.termType === "Variable" ? subject.value : "interfaceUnion",
        }),
      );
    }
    patterns.push({
      patterns: [
        {
          patterns: InterfaceUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.InterfaceUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!("interfaceUnionInterfaceUnionMember1"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}InterfaceUnionMember1`
              : "interfaceUnionInterfaceUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: InterfaceUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.InterfaceUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!("interfaceUnionInterfaceUnionMember2"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}InterfaceUnionMember2`
              : "interfaceUnionInterfaceUnionMember2",
          }).concat(),
          type: "group",
        },
      ],
      type: "union",
    });
    return patterns;
  }
} /**
 * Node shape sh:xone's other node shapes. This will usually be generated as a discriminated union.
 */

export type LazilyResolvedClassUnion =
  | LazilyResolvedClassUnionMember1
  | LazilyResolvedClassUnionMember2;

export namespace LazilyResolvedClassUnion {
  export function $equals(
    left: LazilyResolvedClassUnion,
    right: LazilyResolvedClassUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      if (
        LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(left)
      ) {
        return left.$equals(
          right as unknown as LazilyResolvedClassUnionMember1,
        );
      }
      if (
        LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(left)
      ) {
        return left.$equals(
          right as unknown as LazilyResolvedClassUnionMember2,
        );
      }
      return $EqualsResult.Equal;
    });
  }

  export function $filter(
    filter: LazilyResolvedClassUnion.$Filter,
    value: LazilyResolvedClassUnion,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(
        value,
      ) &&
      filter.on?.LazilyResolvedClassUnionMember1 &&
      !LazilyResolvedClassUnionMember1.$filter(
        filter.on.LazilyResolvedClassUnionMember1,
        value as LazilyResolvedClassUnionMember1,
      )
    ) {
      return false;
    }
    if (
      LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(
        value,
      ) &&
      filter.on?.LazilyResolvedClassUnionMember2 &&
      !LazilyResolvedClassUnionMember2.$filter(
        filter.on.LazilyResolvedClassUnionMember2,
        value as LazilyResolvedClassUnionMember2,
      )
    ) {
      return false;
    }
    return true;
  }

  export interface $Filter {
    readonly $identifier?: $IdentifierFilter;
    readonly on?: {
      readonly LazilyResolvedClassUnionMember1?: Omit<
        LazilyResolvedClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly LazilyResolvedClassUnionMember2?: Omit<
        LazilyResolvedClassUnionMember2.$Filter,
        "$identifier"
      >;
    };
  }

  export function $hash<HasherT extends $Hasher>(
    _lazilyResolvedClassUnion: LazilyResolvedClassUnion,
    _hasher: HasherT,
  ): HasherT {
    if (
      LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(
        _lazilyResolvedClassUnion,
      )
    ) {
      return _lazilyResolvedClassUnion.$hash(_hasher);
    }
    if (
      LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(
        _lazilyResolvedClassUnion,
      )
    ) {
      return _lazilyResolvedClassUnion.$hash(_hasher);
    }
    throw new Error("unrecognized type");
  }

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, LazilyResolvedClassUnion> {
    return (
      LazilyResolvedClassUnionMember1.$fromJson(json) as Either<
        z.ZodError,
        LazilyResolvedClassUnion
      >
    ).altLazy(
      () =>
        LazilyResolvedClassUnionMember2.$fromJson(json) as Either<
          z.ZodError,
          LazilyResolvedClassUnion
        >,
    );
  }

  export function $jsonZodSchema() {
    return z.discriminatedUnion("$type", [
      LazilyResolvedClassUnionMember1.$jsonZodSchema(),
      LazilyResolvedClassUnionMember2.$jsonZodSchema(),
    ]);
  }

  export function $toJson(
    _lazilyResolvedClassUnion: LazilyResolvedClassUnion,
  ):
    | LazilyResolvedClassUnionMember1.$Json
    | LazilyResolvedClassUnionMember2.$Json {
    if (
      LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(
        _lazilyResolvedClassUnion,
      )
    ) {
      return _lazilyResolvedClassUnion.$toJson();
    }
    if (
      LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(
        _lazilyResolvedClassUnion,
      )
    ) {
      return _lazilyResolvedClassUnion.$toJson();
    }
    throw new Error("unrecognized type");
  }

  export type $Json =
    | LazilyResolvedClassUnionMember1.$Json
    | LazilyResolvedClassUnionMember2.$Json;

  export function isLazilyResolvedClassUnion(
    object: $Object,
  ): object is LazilyResolvedClassUnion {
    return (
      LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(
        object,
      ) ||
      LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(object)
    );
  }

  export const $schema = {
    properties: {
      lazilyResolvedStringProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/lazilyResolvedStringProperty",
        ),
      },
    },
  } as const;

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, LazilyResolvedClassUnion> {
    return (
      LazilyResolvedClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as Either<Error, LazilyResolvedClassUnion>
    ).altLazy(
      () =>
        LazilyResolvedClassUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as Either<Error, LazilyResolvedClassUnion>,
    );
  }

  export function $toRdf(
    _lazilyResolvedClassUnion: LazilyResolvedClassUnion,
    _parameters?: {
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    if (
      LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(
        _lazilyResolvedClassUnion,
      )
    ) {
      return _lazilyResolvedClassUnion.$toRdf(_parameters);
    }
    if (
      LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(
        _lazilyResolvedClassUnion,
      )
    ) {
      return _lazilyResolvedClassUnion.$toRdf(_parameters);
    }
    throw new Error("unrecognized type");
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedClassUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedClassUnion.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          LazilyResolvedClassUnion.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedClassUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...LazilyResolvedClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "lazilyResolvedClassUnionLazilyResolvedClassUnionMember1",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember1`
          : "lazilyResolvedClassUnionLazilyResolvedClassUnionMember1",
      }).concat(),
      ...LazilyResolvedClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "lazilyResolvedClassUnionLazilyResolvedClassUnionMember2",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember2`
          : "lazilyResolvedClassUnionLazilyResolvedClassUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedClassUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("lazilyResolvedClassUnion");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          ignoreRdfType: false,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: { kind: "Identifier" as const },
          valueVariable: subject,
          variablePrefix:
            subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedClassUnion",
        }),
      );
    }
    patterns.push({
      patterns: [
        {
          patterns: LazilyResolvedClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazilyResolvedClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "lazilyResolvedClassUnionLazilyResolvedClassUnionMember1",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember1`
              : "lazilyResolvedClassUnionLazilyResolvedClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: LazilyResolvedClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazilyResolvedClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "lazilyResolvedClassUnionLazilyResolvedClassUnionMember2",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember2`
              : "lazilyResolvedClassUnionLazilyResolvedClassUnionMember2",
          }).concat(),
          type: "group",
        },
      ],
      type: "union",
    });
    return patterns;
  }
} /**
 * Node shape sh:xone's other node shapes. This will usually be generated as a discriminated union.
 */

export type LazilyResolvedInterfaceUnion =
  | LazilyResolvedInterfaceUnionMember1
  | LazilyResolvedInterfaceUnionMember2;

export namespace LazilyResolvedInterfaceUnion {
  export function $equals(
    left: LazilyResolvedInterfaceUnion,
    right: LazilyResolvedInterfaceUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      if (
        LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
          left,
        )
      ) {
        return LazilyResolvedInterfaceUnionMember1.$equals(
          left,
          right as unknown as LazilyResolvedInterfaceUnionMember1,
        );
      }
      if (
        LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
          left,
        )
      ) {
        return LazilyResolvedInterfaceUnionMember2.$equals(
          left,
          right as unknown as LazilyResolvedInterfaceUnionMember2,
        );
      }
      return $EqualsResult.Equal;
    });
  }

  export function $filter(
    filter: LazilyResolvedInterfaceUnion.$Filter,
    value: LazilyResolvedInterfaceUnion,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
        value,
      ) &&
      filter.on?.LazilyResolvedInterfaceUnionMember1 &&
      !LazilyResolvedInterfaceUnionMember1.$filter(
        filter.on.LazilyResolvedInterfaceUnionMember1,
        value as LazilyResolvedInterfaceUnionMember1,
      )
    ) {
      return false;
    }
    if (
      LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
        value,
      ) &&
      filter.on?.LazilyResolvedInterfaceUnionMember2 &&
      !LazilyResolvedInterfaceUnionMember2.$filter(
        filter.on.LazilyResolvedInterfaceUnionMember2,
        value as LazilyResolvedInterfaceUnionMember2,
      )
    ) {
      return false;
    }
    return true;
  }

  export interface $Filter {
    readonly $identifier?: $IdentifierFilter;
    readonly on?: {
      readonly LazilyResolvedInterfaceUnionMember1?: Omit<
        LazilyResolvedInterfaceUnionMember1.$Filter,
        "$identifier"
      >;
      readonly LazilyResolvedInterfaceUnionMember2?: Omit<
        LazilyResolvedInterfaceUnionMember2.$Filter,
        "$identifier"
      >;
    };
  }

  export function $hash<HasherT extends $Hasher>(
    _lazilyResolvedInterfaceUnion: LazilyResolvedInterfaceUnion,
    _hasher: HasherT,
  ): HasherT {
    if (
      LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
        _lazilyResolvedInterfaceUnion,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember1.$hash(
        _lazilyResolvedInterfaceUnion,
        _hasher,
      );
    }
    if (
      LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
        _lazilyResolvedInterfaceUnion,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember2.$hash(
        _lazilyResolvedInterfaceUnion,
        _hasher,
      );
    }
    throw new Error("unrecognized type");
  }

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, LazilyResolvedInterfaceUnion> {
    return (
      LazilyResolvedInterfaceUnionMember1.$fromJson(json) as Either<
        z.ZodError,
        LazilyResolvedInterfaceUnion
      >
    ).altLazy(
      () =>
        LazilyResolvedInterfaceUnionMember2.$fromJson(json) as Either<
          z.ZodError,
          LazilyResolvedInterfaceUnion
        >,
    );
  }

  export function $jsonZodSchema() {
    return z.discriminatedUnion("$type", [
      LazilyResolvedInterfaceUnionMember1.$jsonZodSchema(),
      LazilyResolvedInterfaceUnionMember2.$jsonZodSchema(),
    ]);
  }

  export function $toJson(
    _lazilyResolvedInterfaceUnion: LazilyResolvedInterfaceUnion,
  ):
    | LazilyResolvedInterfaceUnionMember1.$Json
    | LazilyResolvedInterfaceUnionMember2.$Json {
    if (
      LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
        _lazilyResolvedInterfaceUnion,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember1.$toJson(
        _lazilyResolvedInterfaceUnion,
      );
    }
    if (
      LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
        _lazilyResolvedInterfaceUnion,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember2.$toJson(
        _lazilyResolvedInterfaceUnion,
      );
    }
    throw new Error("unrecognized type");
  }

  export type $Json =
    | LazilyResolvedInterfaceUnionMember1.$Json
    | LazilyResolvedInterfaceUnionMember2.$Json;

  export function isLazilyResolvedInterfaceUnion(
    object: $Object,
  ): object is LazilyResolvedInterfaceUnion {
    return (
      LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
        object,
      ) ||
      LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
        object,
      )
    );
  }

  export const $schema = {
    properties: {
      lazilyResolvedStringProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/lazilyResolvedStringProperty",
        ),
      },
    },
  } as const;

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, LazilyResolvedInterfaceUnion> {
    return (
      LazilyResolvedInterfaceUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as Either<Error, LazilyResolvedInterfaceUnion>
    ).altLazy(
      () =>
        LazilyResolvedInterfaceUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as Either<Error, LazilyResolvedInterfaceUnion>,
    );
  }

  export function $toRdf(
    _lazilyResolvedInterfaceUnion: LazilyResolvedInterfaceUnion,
    _parameters?: {
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    if (
      LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
        _lazilyResolvedInterfaceUnion,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember1.$toRdf(
        _lazilyResolvedInterfaceUnion,
        _parameters,
      );
    }
    if (
      LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
        _lazilyResolvedInterfaceUnion,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember2.$toRdf(
        _lazilyResolvedInterfaceUnion,
        _parameters,
      );
    }
    throw new Error("unrecognized type");
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedInterfaceUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedInterfaceUnion.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          LazilyResolvedInterfaceUnion.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedInterfaceUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedInterfaceUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...LazilyResolvedInterfaceUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember1",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember1`
          : "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember1",
      }).concat(),
      ...LazilyResolvedInterfaceUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember2",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember2`
          : "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedInterfaceUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedInterfaceUnion");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          ignoreRdfType: false,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: { kind: "Identifier" as const },
          valueVariable: subject,
          variablePrefix:
            subject.termType === "Variable"
              ? subject.value
              : "lazilyResolvedInterfaceUnion",
        }),
      );
    }
    patterns.push({
      patterns: [
        {
          patterns: LazilyResolvedInterfaceUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazilyResolvedInterfaceUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember1",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember1`
              : "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: LazilyResolvedInterfaceUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazilyResolvedInterfaceUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember2",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember2`
              : "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember2",
          }).concat(),
          type: "group",
        },
      ],
      type: "union",
    });
    return patterns;
  }
} /**
 * Counterpart of ClassUnion for lazy resolution. The partial union must have the same number of members, in the corresponding order, as the 'full' union.
 */

export type PartialClassUnion =
  | PartialClassUnionMember1
  | PartialClassUnionMember2;

export namespace PartialClassUnion {
  export function $equals(
    left: PartialClassUnion,
    right: PartialClassUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      if (PartialClassUnionMember1.isPartialClassUnionMember1(left)) {
        return left.$equals(right as unknown as PartialClassUnionMember1);
      }
      if (PartialClassUnionMember2.isPartialClassUnionMember2(left)) {
        return left.$equals(right as unknown as PartialClassUnionMember2);
      }
      return $EqualsResult.Equal;
    });
  }

  export function $filter(
    filter: PartialClassUnion.$Filter,
    value: PartialClassUnion,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      PartialClassUnionMember1.isPartialClassUnionMember1(value) &&
      filter.on?.PartialClassUnionMember1 &&
      !PartialClassUnionMember1.$filter(
        filter.on.PartialClassUnionMember1,
        value as PartialClassUnionMember1,
      )
    ) {
      return false;
    }
    if (
      PartialClassUnionMember2.isPartialClassUnionMember2(value) &&
      filter.on?.PartialClassUnionMember2 &&
      !PartialClassUnionMember2.$filter(
        filter.on.PartialClassUnionMember2,
        value as PartialClassUnionMember2,
      )
    ) {
      return false;
    }
    return true;
  }

  export interface $Filter {
    readonly $identifier?: $IdentifierFilter;
    readonly on?: {
      readonly PartialClassUnionMember1?: Omit<
        PartialClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly PartialClassUnionMember2?: Omit<
        PartialClassUnionMember2.$Filter,
        "$identifier"
      >;
    };
  }

  export function $hash<HasherT extends $Hasher>(
    _partialClassUnion: PartialClassUnion,
    _hasher: HasherT,
  ): HasherT {
    if (
      PartialClassUnionMember1.isPartialClassUnionMember1(_partialClassUnion)
    ) {
      return _partialClassUnion.$hash(_hasher);
    }
    if (
      PartialClassUnionMember2.isPartialClassUnionMember2(_partialClassUnion)
    ) {
      return _partialClassUnion.$hash(_hasher);
    }
    throw new Error("unrecognized type");
  }

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, PartialClassUnion> {
    return (
      PartialClassUnionMember1.$fromJson(json) as Either<
        z.ZodError,
        PartialClassUnion
      >
    ).altLazy(
      () =>
        PartialClassUnionMember2.$fromJson(json) as Either<
          z.ZodError,
          PartialClassUnion
        >,
    );
  }

  export function $jsonZodSchema() {
    return z.discriminatedUnion("$type", [
      PartialClassUnionMember1.$jsonZodSchema(),
      PartialClassUnionMember2.$jsonZodSchema(),
    ]);
  }

  export function $toJson(
    _partialClassUnion: PartialClassUnion,
  ): PartialClassUnionMember1.$Json | PartialClassUnionMember2.$Json {
    if (
      PartialClassUnionMember1.isPartialClassUnionMember1(_partialClassUnion)
    ) {
      return _partialClassUnion.$toJson();
    }
    if (
      PartialClassUnionMember2.isPartialClassUnionMember2(_partialClassUnion)
    ) {
      return _partialClassUnion.$toJson();
    }
    throw new Error("unrecognized type");
  }

  export type $Json =
    | PartialClassUnionMember1.$Json
    | PartialClassUnionMember2.$Json;

  export function isPartialClassUnion(
    object: $Object,
  ): object is PartialClassUnion {
    return (
      PartialClassUnionMember1.isPartialClassUnionMember1(object) ||
      PartialClassUnionMember2.isPartialClassUnionMember2(object)
    );
  }

  export const $schema = {
    properties: {
      lazilyResolvedStringProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/lazilyResolvedStringProperty",
        ),
      },
    },
  } as const;

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, PartialClassUnion> {
    return (
      PartialClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as Either<Error, PartialClassUnion>
    ).altLazy(
      () =>
        PartialClassUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as Either<Error, PartialClassUnion>,
    );
  }

  export function $toRdf(
    _partialClassUnion: PartialClassUnion,
    _parameters?: {
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    if (
      PartialClassUnionMember1.isPartialClassUnionMember1(_partialClassUnion)
    ) {
      return _partialClassUnion.$toRdf(_parameters);
    }
    if (
      PartialClassUnionMember2.isPartialClassUnionMember2(_partialClassUnion)
    ) {
      return _partialClassUnion.$toRdf(_parameters);
    }
    throw new Error("unrecognized type");
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialClassUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialClassUnion.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          PartialClassUnion.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialClassUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...PartialClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("partialClassUnionPartialClassUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialClassUnionMember1`
          : "partialClassUnionPartialClassUnionMember1",
      }).concat(),
      ...PartialClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("partialClassUnionPartialClassUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialClassUnionMember2`
          : "partialClassUnionPartialClassUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialClassUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClassUnion");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          ignoreRdfType: false,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: { kind: "Identifier" as const },
          valueVariable: subject,
          variablePrefix:
            subject.termType === "Variable"
              ? subject.value
              : "partialClassUnion",
        }),
      );
    }
    patterns.push({
      patterns: [
        {
          patterns: PartialClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PartialClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "partialClassUnionPartialClassUnionMember1",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PartialClassUnionMember1`
              : "partialClassUnionPartialClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: PartialClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PartialClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "partialClassUnionPartialClassUnionMember2",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PartialClassUnionMember2`
              : "partialClassUnionPartialClassUnionMember2",
          }).concat(),
          type: "group",
        },
      ],
      type: "union",
    });
    return patterns;
  }
} /**
 * Counterpart of InterfaceUnion for lazy resolution. The partial union must have the same number of members, in the corresponding order, as the 'full' union.
 */

export type PartialInterfaceUnion =
  | PartialInterfaceUnionMember1
  | PartialInterfaceUnionMember2;

export namespace PartialInterfaceUnion {
  export function $equals(
    left: PartialInterfaceUnion,
    right: PartialInterfaceUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      if (PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(left)) {
        return PartialInterfaceUnionMember1.$equals(
          left,
          right as unknown as PartialInterfaceUnionMember1,
        );
      }
      if (PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(left)) {
        return PartialInterfaceUnionMember2.$equals(
          left,
          right as unknown as PartialInterfaceUnionMember2,
        );
      }
      return $EqualsResult.Equal;
    });
  }

  export function $filter(
    filter: PartialInterfaceUnion.$Filter,
    value: PartialInterfaceUnion,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(value) &&
      filter.on?.PartialInterfaceUnionMember1 &&
      !PartialInterfaceUnionMember1.$filter(
        filter.on.PartialInterfaceUnionMember1,
        value as PartialInterfaceUnionMember1,
      )
    ) {
      return false;
    }
    if (
      PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(value) &&
      filter.on?.PartialInterfaceUnionMember2 &&
      !PartialInterfaceUnionMember2.$filter(
        filter.on.PartialInterfaceUnionMember2,
        value as PartialInterfaceUnionMember2,
      )
    ) {
      return false;
    }
    return true;
  }

  export interface $Filter {
    readonly $identifier?: $IdentifierFilter;
    readonly on?: {
      readonly PartialInterfaceUnionMember1?: Omit<
        PartialInterfaceUnionMember1.$Filter,
        "$identifier"
      >;
      readonly PartialInterfaceUnionMember2?: Omit<
        PartialInterfaceUnionMember2.$Filter,
        "$identifier"
      >;
    };
  }

  export function $hash<HasherT extends $Hasher>(
    _partialInterfaceUnion: PartialInterfaceUnion,
    _hasher: HasherT,
  ): HasherT {
    if (
      PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(
        _partialInterfaceUnion,
      )
    ) {
      return PartialInterfaceUnionMember1.$hash(
        _partialInterfaceUnion,
        _hasher,
      );
    }
    if (
      PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(
        _partialInterfaceUnion,
      )
    ) {
      return PartialInterfaceUnionMember2.$hash(
        _partialInterfaceUnion,
        _hasher,
      );
    }
    throw new Error("unrecognized type");
  }

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, PartialInterfaceUnion> {
    return (
      PartialInterfaceUnionMember1.$fromJson(json) as Either<
        z.ZodError,
        PartialInterfaceUnion
      >
    ).altLazy(
      () =>
        PartialInterfaceUnionMember2.$fromJson(json) as Either<
          z.ZodError,
          PartialInterfaceUnion
        >,
    );
  }

  export function $jsonZodSchema() {
    return z.discriminatedUnion("$type", [
      PartialInterfaceUnionMember1.$jsonZodSchema(),
      PartialInterfaceUnionMember2.$jsonZodSchema(),
    ]);
  }

  export function $toJson(
    _partialInterfaceUnion: PartialInterfaceUnion,
  ): PartialInterfaceUnionMember1.$Json | PartialInterfaceUnionMember2.$Json {
    if (
      PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(
        _partialInterfaceUnion,
      )
    ) {
      return PartialInterfaceUnionMember1.$toJson(_partialInterfaceUnion);
    }
    if (
      PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(
        _partialInterfaceUnion,
      )
    ) {
      return PartialInterfaceUnionMember2.$toJson(_partialInterfaceUnion);
    }
    throw new Error("unrecognized type");
  }

  export type $Json =
    | PartialInterfaceUnionMember1.$Json
    | PartialInterfaceUnionMember2.$Json;

  export function isPartialInterfaceUnion(
    object: $Object,
  ): object is PartialInterfaceUnion {
    return (
      PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(object) ||
      PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(object)
    );
  }

  export const $schema = {
    properties: {
      lazilyResolvedStringProperty: {
        kind: "Shacl" as const,
        type: () => ({ kind: "String" as const }),
        identifier: dataFactory.namedNode(
          "http://example.com/lazilyResolvedStringProperty",
        ),
      },
    },
  } as const;

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, PartialInterfaceUnion> {
    return (
      PartialInterfaceUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as Either<Error, PartialInterfaceUnion>
    ).altLazy(
      () =>
        PartialInterfaceUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as Either<Error, PartialInterfaceUnion>,
    );
  }

  export function $toRdf(
    _partialInterfaceUnion: PartialInterfaceUnion,
    _parameters?: {
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    if (
      PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(
        _partialInterfaceUnion,
      )
    ) {
      return PartialInterfaceUnionMember1.$toRdf(
        _partialInterfaceUnion,
        _parameters,
      );
    }
    if (
      PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(
        _partialInterfaceUnion,
      )
    ) {
      return PartialInterfaceUnionMember2.$toRdf(
        _partialInterfaceUnion,
        _parameters,
      );
    }
    throw new Error("unrecognized type");
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialInterfaceUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialInterfaceUnion.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          PartialInterfaceUnion.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialInterfaceUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialInterfaceUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...PartialInterfaceUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "partialInterfaceUnionPartialInterfaceUnionMember1",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialInterfaceUnionMember1`
          : "partialInterfaceUnionPartialInterfaceUnionMember1",
      }).concat(),
      ...PartialInterfaceUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "partialInterfaceUnionPartialInterfaceUnionMember2",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialInterfaceUnionMember2`
          : "partialInterfaceUnionPartialInterfaceUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialInterfaceUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialInterfaceUnion");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          ignoreRdfType: false,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: { kind: "Identifier" as const },
          valueVariable: subject,
          variablePrefix:
            subject.termType === "Variable"
              ? subject.value
              : "partialInterfaceUnion",
        }),
      );
    }
    patterns.push({
      patterns: [
        {
          patterns: PartialInterfaceUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PartialInterfaceUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "partialInterfaceUnionPartialInterfaceUnionMember1",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PartialInterfaceUnionMember1`
              : "partialInterfaceUnionPartialInterfaceUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: PartialInterfaceUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PartialInterfaceUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "partialInterfaceUnionPartialInterfaceUnionMember2",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PartialInterfaceUnionMember2`
              : "partialInterfaceUnionPartialInterfaceUnionMember2",
          }).concat(),
          type: "group",
        },
      ],
      type: "union",
    });
    return patterns;
  }
} /**
 * Node shape sh:xone's other node shapes. These don't have RDF types since they're not owl:Class's
 */

export type NoRdfTypeClassUnion =
  | NoRdfTypeClassUnionMember1
  | NoRdfTypeClassUnionMember2;

export namespace NoRdfTypeClassUnion {
  export function $equals(
    left: NoRdfTypeClassUnion,
    right: NoRdfTypeClassUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      if (NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(left)) {
        return left.$equals(right as unknown as NoRdfTypeClassUnionMember1);
      }
      if (NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(left)) {
        return left.$equals(right as unknown as NoRdfTypeClassUnionMember2);
      }
      return $EqualsResult.Equal;
    });
  }

  export function $filter(
    filter: NoRdfTypeClassUnion.$Filter,
    value: NoRdfTypeClassUnion,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(value) &&
      filter.on?.NoRdfTypeClassUnionMember1 &&
      !NoRdfTypeClassUnionMember1.$filter(
        filter.on.NoRdfTypeClassUnionMember1,
        value as NoRdfTypeClassUnionMember1,
      )
    ) {
      return false;
    }
    if (
      NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(value) &&
      filter.on?.NoRdfTypeClassUnionMember2 &&
      !NoRdfTypeClassUnionMember2.$filter(
        filter.on.NoRdfTypeClassUnionMember2,
        value as NoRdfTypeClassUnionMember2,
      )
    ) {
      return false;
    }
    return true;
  }

  export interface $Filter {
    readonly $identifier?: $IdentifierFilter;
    readonly on?: {
      readonly NoRdfTypeClassUnionMember1?: Omit<
        NoRdfTypeClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly NoRdfTypeClassUnionMember2?: Omit<
        NoRdfTypeClassUnionMember2.$Filter,
        "$identifier"
      >;
    };
  }

  export function $hash<HasherT extends $Hasher>(
    _noRdfTypeClassUnion: NoRdfTypeClassUnion,
    _hasher: HasherT,
  ): HasherT {
    if (
      NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(
        _noRdfTypeClassUnion,
      )
    ) {
      return _noRdfTypeClassUnion.$hash(_hasher);
    }
    if (
      NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(
        _noRdfTypeClassUnion,
      )
    ) {
      return _noRdfTypeClassUnion.$hash(_hasher);
    }
    throw new Error("unrecognized type");
  }

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, NoRdfTypeClassUnion> {
    return (
      NoRdfTypeClassUnionMember1.$fromJson(json) as Either<
        z.ZodError,
        NoRdfTypeClassUnion
      >
    ).altLazy(
      () =>
        NoRdfTypeClassUnionMember2.$fromJson(json) as Either<
          z.ZodError,
          NoRdfTypeClassUnion
        >,
    );
  }

  export function $jsonZodSchema() {
    return z.discriminatedUnion("$type", [
      NoRdfTypeClassUnionMember1.$jsonZodSchema(),
      NoRdfTypeClassUnionMember2.$jsonZodSchema(),
    ]);
  }

  export function $toJson(
    _noRdfTypeClassUnion: NoRdfTypeClassUnion,
  ): NoRdfTypeClassUnionMember1.$Json | NoRdfTypeClassUnionMember2.$Json {
    if (
      NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(
        _noRdfTypeClassUnion,
      )
    ) {
      return _noRdfTypeClassUnion.$toJson();
    }
    if (
      NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(
        _noRdfTypeClassUnion,
      )
    ) {
      return _noRdfTypeClassUnion.$toJson();
    }
    throw new Error("unrecognized type");
  }

  export type $Json =
    | NoRdfTypeClassUnionMember1.$Json
    | NoRdfTypeClassUnionMember2.$Json;

  export function isNoRdfTypeClassUnion(
    object: $Object,
  ): object is NoRdfTypeClassUnion {
    return (
      NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(object) ||
      NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(object)
    );
  }

  export const $schema = { properties: {} } as const;

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, NoRdfTypeClassUnion> {
    return (
      NoRdfTypeClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as Either<Error, NoRdfTypeClassUnion>
    ).altLazy(
      () =>
        NoRdfTypeClassUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as Either<Error, NoRdfTypeClassUnion>,
    );
  }

  export function $toRdf(
    _noRdfTypeClassUnion: NoRdfTypeClassUnion,
    _parameters?: {
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    if (
      NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(
        _noRdfTypeClassUnion,
      )
    ) {
      return _noRdfTypeClassUnion.$toRdf(_parameters);
    }
    if (
      NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(
        _noRdfTypeClassUnion,
      )
    ) {
      return _noRdfTypeClassUnion.$toRdf(_parameters);
    }
    throw new Error("unrecognized type");
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: NoRdfTypeClassUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        NoRdfTypeClassUnion.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          NoRdfTypeClassUnion.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: NoRdfTypeClassUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      NoRdfTypeClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...NoRdfTypeClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "noRdfTypeClassUnionNoRdfTypeClassUnionMember1",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}NoRdfTypeClassUnionMember1`
          : "noRdfTypeClassUnionNoRdfTypeClassUnionMember1",
      }).concat(),
      ...NoRdfTypeClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "noRdfTypeClassUnionNoRdfTypeClassUnionMember2",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}NoRdfTypeClassUnionMember2`
          : "noRdfTypeClassUnionNoRdfTypeClassUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: NoRdfTypeClassUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("noRdfTypeClassUnion");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          ignoreRdfType: false,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: { kind: "Identifier" as const },
          valueVariable: subject,
          variablePrefix:
            subject.termType === "Variable"
              ? subject.value
              : "noRdfTypeClassUnion",
        }),
      );
    }
    patterns.push({
      patterns: [
        {
          patterns: NoRdfTypeClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.NoRdfTypeClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "noRdfTypeClassUnionNoRdfTypeClassUnionMember1",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}NoRdfTypeClassUnionMember1`
              : "noRdfTypeClassUnionNoRdfTypeClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: NoRdfTypeClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.NoRdfTypeClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "noRdfTypeClassUnionNoRdfTypeClassUnionMember2",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}NoRdfTypeClassUnionMember2`
              : "noRdfTypeClassUnionNoRdfTypeClassUnionMember2",
          }).concat(),
          type: "group",
        },
      ],
      type: "union",
    });
    return patterns;
  }
} /**
 * Node shape sh:xone's node shapes that have properties with the union's type
 */

export type RecursiveClassUnion =
  | RecursiveClassUnionMember1
  | RecursiveClassUnionMember2;

export namespace RecursiveClassUnion {
  export function $equals(
    left: RecursiveClassUnion,
    right: RecursiveClassUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      if (RecursiveClassUnionMember1.isRecursiveClassUnionMember1(left)) {
        return left.$equals(right as unknown as RecursiveClassUnionMember1);
      }
      if (RecursiveClassUnionMember2.isRecursiveClassUnionMember2(left)) {
        return left.$equals(right as unknown as RecursiveClassUnionMember2);
      }
      return $EqualsResult.Equal;
    });
  }

  export function $filter(
    filter: RecursiveClassUnion.$Filter,
    value: RecursiveClassUnion,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      RecursiveClassUnionMember1.isRecursiveClassUnionMember1(value) &&
      filter.on?.RecursiveClassUnionMember1 &&
      !RecursiveClassUnionMember1.$filter(
        filter.on.RecursiveClassUnionMember1,
        value as RecursiveClassUnionMember1,
      )
    ) {
      return false;
    }
    if (
      RecursiveClassUnionMember2.isRecursiveClassUnionMember2(value) &&
      filter.on?.RecursiveClassUnionMember2 &&
      !RecursiveClassUnionMember2.$filter(
        filter.on.RecursiveClassUnionMember2,
        value as RecursiveClassUnionMember2,
      )
    ) {
      return false;
    }
    return true;
  }

  export interface $Filter {
    readonly $identifier?: $IdentifierFilter;
    readonly on?: {
      readonly RecursiveClassUnionMember1?: Omit<
        RecursiveClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly RecursiveClassUnionMember2?: Omit<
        RecursiveClassUnionMember2.$Filter,
        "$identifier"
      >;
    };
  }

  export function $hash<HasherT extends $Hasher>(
    _recursiveClassUnion: RecursiveClassUnion,
    _hasher: HasherT,
  ): HasherT {
    if (
      RecursiveClassUnionMember1.isRecursiveClassUnionMember1(
        _recursiveClassUnion,
      )
    ) {
      return _recursiveClassUnion.$hash(_hasher);
    }
    if (
      RecursiveClassUnionMember2.isRecursiveClassUnionMember2(
        _recursiveClassUnion,
      )
    ) {
      return _recursiveClassUnion.$hash(_hasher);
    }
    throw new Error("unrecognized type");
  }

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $fromJson(
    json: unknown,
  ): Either<z.ZodError, RecursiveClassUnion> {
    return (
      RecursiveClassUnionMember1.$fromJson(json) as Either<
        z.ZodError,
        RecursiveClassUnion
      >
    ).altLazy(
      () =>
        RecursiveClassUnionMember2.$fromJson(json) as Either<
          z.ZodError,
          RecursiveClassUnion
        >,
    );
  }

  export function $jsonZodSchema() {
    return z.discriminatedUnion("$type", [
      RecursiveClassUnionMember1.$jsonZodSchema(),
      RecursiveClassUnionMember2.$jsonZodSchema(),
    ]);
  }

  export function $toJson(
    _recursiveClassUnion: RecursiveClassUnion,
  ): RecursiveClassUnionMember1.$Json | RecursiveClassUnionMember2.$Json {
    if (
      RecursiveClassUnionMember1.isRecursiveClassUnionMember1(
        _recursiveClassUnion,
      )
    ) {
      return _recursiveClassUnion.$toJson();
    }
    if (
      RecursiveClassUnionMember2.isRecursiveClassUnionMember2(
        _recursiveClassUnion,
      )
    ) {
      return _recursiveClassUnion.$toJson();
    }
    throw new Error("unrecognized type");
  }

  export type $Json =
    | RecursiveClassUnionMember1.$Json
    | RecursiveClassUnionMember2.$Json;

  export function isRecursiveClassUnion(
    object: $Object,
  ): object is RecursiveClassUnion {
    return (
      RecursiveClassUnionMember1.isRecursiveClassUnionMember1(object) ||
      RecursiveClassUnionMember2.isRecursiveClassUnionMember2(object)
    );
  }

  export const $schema = { properties: {} } as const;

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, RecursiveClassUnion> {
    return (
      RecursiveClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as Either<Error, RecursiveClassUnion>
    ).altLazy(
      () =>
        RecursiveClassUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as Either<Error, RecursiveClassUnion>,
    );
  }

  export function $toRdf(
    _recursiveClassUnion: RecursiveClassUnion,
    _parameters?: {
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    if (
      RecursiveClassUnionMember1.isRecursiveClassUnionMember1(
        _recursiveClassUnion,
      )
    ) {
      return _recursiveClassUnion.$toRdf(_parameters);
    }
    if (
      RecursiveClassUnionMember2.isRecursiveClassUnionMember2(
        _recursiveClassUnion,
      )
    ) {
      return _recursiveClassUnion.$toRdf(_parameters);
    }
    throw new Error("unrecognized type");
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: RecursiveClassUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        RecursiveClassUnion.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          RecursiveClassUnion.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: RecursiveClassUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      RecursiveClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...RecursiveClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "recursiveClassUnionRecursiveClassUnionMember1",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}RecursiveClassUnionMember1`
          : "recursiveClassUnionRecursiveClassUnionMember1",
      }).concat(),
      ...RecursiveClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "recursiveClassUnionRecursiveClassUnionMember2",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}RecursiveClassUnionMember2`
          : "recursiveClassUnionRecursiveClassUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: RecursiveClassUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("recursiveClassUnion");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          ignoreRdfType: false,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: { kind: "Identifier" as const },
          valueVariable: subject,
          variablePrefix:
            subject.termType === "Variable"
              ? subject.value
              : "recursiveClassUnion",
        }),
      );
    }
    patterns.push({
      patterns: [
        {
          patterns: RecursiveClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.RecursiveClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "recursiveClassUnionRecursiveClassUnionMember1",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}RecursiveClassUnionMember1`
              : "recursiveClassUnionRecursiveClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: RecursiveClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.RecursiveClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "recursiveClassUnionRecursiveClassUnionMember2",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}RecursiveClassUnionMember2`
              : "recursiveClassUnionRecursiveClassUnionMember2",
          }).concat(),
          type: "group",
        },
      ],
      type: "union",
    });
    return patterns;
  }
}
export type $Object =
  | BlankNodeIdentifierClass
  | BlankNodeIdentifierInterface
  | BlankNodeOrIriIdentifierClass
  | BlankNodeOrIriIdentifierInterface
  | ClassUnionMember1
  | ClassUnionMember2
  | ClassUnionMemberCommonParent
  | ConcreteChildClass
  | ConcreteParentClass
  | AbstractBaseClassWithoutProperties
  | AbstractBaseClassWithProperties
  | ConcreteChildInterface
  | ConcreteParentInterface
  | BaseInterfaceWithoutProperties
  | BaseInterfaceWithProperties
  | ConvertibleTypePropertiesClass
  | DateUnionPropertiesClass
  | DefaultValuePropertiesClass
  | DirectRecursiveClass
  | ExplicitFromToRdfTypesClass
  | ExplicitRdfTypeClass
  | AbstractBaseClassForExternClass
  | ExternClassPropertyClass
  | FlattenClassUnionMember3
  | HasValuePropertiesClass
  | IdentifierOverride5Class
  | IdentifierOverride4Class
  | IdentifierOverride3Class
  | IdentifierOverride2Class
  | IdentifierOverride1Class
  | InIdentifierClass
  | InPropertiesClass
  | IndirectRecursiveClass
  | IndirectRecursiveHelperClass
  | Interface
  | InterfaceUnionMember1
  | InterfaceUnionMember2
  | InterfaceUnionMemberCommonParent
  | IriIdentifierClass
  | IriIdentifierInterface
  | JsPrimitiveUnionPropertyClass
  | LanguageInPropertiesClass
  | LazilyResolvedBlankNodeOrIriIdentifierClass
  | LazilyResolvedBlankNodeOrIriIdentifierInterface
  | LazilyResolvedClassUnionMember1
  | LazilyResolvedClassUnionMember2
  | LazilyResolvedInterfaceUnionMember1
  | LazilyResolvedInterfaceUnionMember2
  | LazilyResolvedIriIdentifierClass
  | LazilyResolvedIriIdentifierInterface
  | LazyPropertiesClass
  | PartialClass
  | LazyPropertiesInterface
  | PartialInterface
  | ListPropertiesClass
  | MutablePropertiesClass
  | NoRdfTypeClassUnionMember1
  | NoRdfTypeClassUnionMember2
  | NonClass
  | OrderedPropertiesClass
  | PartialClassUnionMember1
  | PartialClassUnionMember2
  | PartialInterfaceUnionMember1
  | PartialInterfaceUnionMember2
  | PropertyCardinalitiesClass
  | PropertyVisibilitiesClass
  | RecursiveClassUnionMember1
  | RecursiveClassUnionMember2
  | Sha256IriIdentifierClass
  | TermPropertiesClass
  | UnionDiscriminantsClass
  | UuidV4IriIdentifierClass
  | UuidV4IriIdentifierInterface
  | $DefaultPartial
  | $NamedDefaultPartial;

export namespace $Object {
  export function $equals(left: $Object, right: $Object): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      if (BlankNodeIdentifierClass.isBlankNodeIdentifierClass(left)) {
        return left.$equals(right as unknown as BlankNodeIdentifierClass);
      }
      if (BlankNodeIdentifierInterface.isBlankNodeIdentifierInterface(left)) {
        return BlankNodeIdentifierInterface.$equals(
          left,
          right as unknown as BlankNodeIdentifierInterface,
        );
      }
      if (BlankNodeOrIriIdentifierClass.isBlankNodeOrIriIdentifierClass(left)) {
        return left.$equals(right as unknown as BlankNodeOrIriIdentifierClass);
      }
      if (
        BlankNodeOrIriIdentifierInterface.isBlankNodeOrIriIdentifierInterface(
          left,
        )
      ) {
        return BlankNodeOrIriIdentifierInterface.$equals(
          left,
          right as unknown as BlankNodeOrIriIdentifierInterface,
        );
      }
      if (ClassUnionMember1.isClassUnionMember1(left)) {
        return left.$equals(right as unknown as ClassUnionMember1);
      }
      if (ClassUnionMember2.isClassUnionMember2(left)) {
        return left.$equals(right as unknown as ClassUnionMember2);
      }
      if (ConcreteChildClass.isConcreteChildClass(left)) {
        return left.$equals(right as unknown as ConcreteChildClass);
      }
      if (ConcreteParentClassStatic.isConcreteParentClass(left)) {
        return left.$equals(right as unknown as ConcreteParentClass);
      }
      if (ConcreteChildInterface.isConcreteChildInterface(left)) {
        return ConcreteChildInterface.$equals(
          left,
          right as unknown as ConcreteChildInterface,
        );
      }
      if (ConcreteParentInterfaceStatic.isConcreteParentInterface(left)) {
        return ConcreteParentInterfaceStatic.$equals(
          left,
          right as unknown as ConcreteParentInterface,
        );
      }
      if (
        BaseInterfaceWithoutPropertiesStatic.isBaseInterfaceWithoutProperties(
          left,
        )
      ) {
        return BaseInterfaceWithoutPropertiesStatic.$equals(
          left,
          right as unknown as BaseInterfaceWithoutProperties,
        );
      }
      if (
        BaseInterfaceWithPropertiesStatic.isBaseInterfaceWithProperties(left)
      ) {
        return BaseInterfaceWithPropertiesStatic.$equals(
          left,
          right as unknown as BaseInterfaceWithProperties,
        );
      }
      if (
        ConvertibleTypePropertiesClass.isConvertibleTypePropertiesClass(left)
      ) {
        return left.$equals(right as unknown as ConvertibleTypePropertiesClass);
      }
      if (DateUnionPropertiesClass.isDateUnionPropertiesClass(left)) {
        return left.$equals(right as unknown as DateUnionPropertiesClass);
      }
      if (DefaultValuePropertiesClass.isDefaultValuePropertiesClass(left)) {
        return left.$equals(right as unknown as DefaultValuePropertiesClass);
      }
      if (DirectRecursiveClass.isDirectRecursiveClass(left)) {
        return left.$equals(right as unknown as DirectRecursiveClass);
      }
      if (ExplicitFromToRdfTypesClass.isExplicitFromToRdfTypesClass(left)) {
        return left.$equals(right as unknown as ExplicitFromToRdfTypesClass);
      }
      if (ExplicitRdfTypeClass.isExplicitRdfTypeClass(left)) {
        return left.$equals(right as unknown as ExplicitRdfTypeClass);
      }
      if (ExternClassPropertyClass.isExternClassPropertyClass(left)) {
        return left.$equals(right as unknown as ExternClassPropertyClass);
      }
      if (FlattenClassUnionMember3.isFlattenClassUnionMember3(left)) {
        return left.$equals(right as unknown as FlattenClassUnionMember3);
      }
      if (HasValuePropertiesClass.isHasValuePropertiesClass(left)) {
        return left.$equals(right as unknown as HasValuePropertiesClass);
      }
      if (IdentifierOverride5Class.isIdentifierOverride5Class(left)) {
        return left.$equals(right as unknown as IdentifierOverride5Class);
      }
      if (IdentifierOverride4ClassStatic.isIdentifierOverride4Class(left)) {
        return left.$equals(right as unknown as IdentifierOverride4Class);
      }
      if (IdentifierOverride3ClassStatic.isIdentifierOverride3Class(left)) {
        return left.$equals(right as unknown as IdentifierOverride3Class);
      }
      if (InIdentifierClass.isInIdentifierClass(left)) {
        return left.$equals(right as unknown as InIdentifierClass);
      }
      if (InPropertiesClass.isInPropertiesClass(left)) {
        return left.$equals(right as unknown as InPropertiesClass);
      }
      if (IndirectRecursiveClass.isIndirectRecursiveClass(left)) {
        return left.$equals(right as unknown as IndirectRecursiveClass);
      }
      if (IndirectRecursiveHelperClass.isIndirectRecursiveHelperClass(left)) {
        return left.$equals(right as unknown as IndirectRecursiveHelperClass);
      }
      if (Interface.isInterface(left)) {
        return Interface.$equals(left, right as unknown as Interface);
      }
      if (InterfaceUnionMember1.isInterfaceUnionMember1(left)) {
        return InterfaceUnionMember1.$equals(
          left,
          right as unknown as InterfaceUnionMember1,
        );
      }
      if (InterfaceUnionMember2.isInterfaceUnionMember2(left)) {
        return InterfaceUnionMember2.$equals(
          left,
          right as unknown as InterfaceUnionMember2,
        );
      }
      if (IriIdentifierClass.isIriIdentifierClass(left)) {
        return left.$equals(right as unknown as IriIdentifierClass);
      }
      if (IriIdentifierInterface.isIriIdentifierInterface(left)) {
        return IriIdentifierInterface.$equals(
          left,
          right as unknown as IriIdentifierInterface,
        );
      }
      if (JsPrimitiveUnionPropertyClass.isJsPrimitiveUnionPropertyClass(left)) {
        return left.$equals(right as unknown as JsPrimitiveUnionPropertyClass);
      }
      if (LanguageInPropertiesClass.isLanguageInPropertiesClass(left)) {
        return left.$equals(right as unknown as LanguageInPropertiesClass);
      }
      if (
        LazilyResolvedBlankNodeOrIriIdentifierClass.isLazilyResolvedBlankNodeOrIriIdentifierClass(
          left,
        )
      ) {
        return left.$equals(
          right as unknown as LazilyResolvedBlankNodeOrIriIdentifierClass,
        );
      }
      if (
        LazilyResolvedBlankNodeOrIriIdentifierInterface.isLazilyResolvedBlankNodeOrIriIdentifierInterface(
          left,
        )
      ) {
        return LazilyResolvedBlankNodeOrIriIdentifierInterface.$equals(
          left,
          right as unknown as LazilyResolvedBlankNodeOrIriIdentifierInterface,
        );
      }
      if (
        LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(left)
      ) {
        return left.$equals(
          right as unknown as LazilyResolvedClassUnionMember1,
        );
      }
      if (
        LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(left)
      ) {
        return left.$equals(
          right as unknown as LazilyResolvedClassUnionMember2,
        );
      }
      if (
        LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
          left,
        )
      ) {
        return LazilyResolvedInterfaceUnionMember1.$equals(
          left,
          right as unknown as LazilyResolvedInterfaceUnionMember1,
        );
      }
      if (
        LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
          left,
        )
      ) {
        return LazilyResolvedInterfaceUnionMember2.$equals(
          left,
          right as unknown as LazilyResolvedInterfaceUnionMember2,
        );
      }
      if (
        LazilyResolvedIriIdentifierClass.isLazilyResolvedIriIdentifierClass(
          left,
        )
      ) {
        return left.$equals(
          right as unknown as LazilyResolvedIriIdentifierClass,
        );
      }
      if (
        LazilyResolvedIriIdentifierInterface.isLazilyResolvedIriIdentifierInterface(
          left,
        )
      ) {
        return LazilyResolvedIriIdentifierInterface.$equals(
          left,
          right as unknown as LazilyResolvedIriIdentifierInterface,
        );
      }
      if (LazyPropertiesClass.isLazyPropertiesClass(left)) {
        return left.$equals(right as unknown as LazyPropertiesClass);
      }
      if (PartialClass.isPartialClass(left)) {
        return left.$equals(right as unknown as PartialClass);
      }
      if (LazyPropertiesInterface.isLazyPropertiesInterface(left)) {
        return LazyPropertiesInterface.$equals(
          left,
          right as unknown as LazyPropertiesInterface,
        );
      }
      if (PartialInterface.isPartialInterface(left)) {
        return PartialInterface.$equals(
          left,
          right as unknown as PartialInterface,
        );
      }
      if (ListPropertiesClass.isListPropertiesClass(left)) {
        return left.$equals(right as unknown as ListPropertiesClass);
      }
      if (MutablePropertiesClass.isMutablePropertiesClass(left)) {
        return left.$equals(right as unknown as MutablePropertiesClass);
      }
      if (NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(left)) {
        return left.$equals(right as unknown as NoRdfTypeClassUnionMember1);
      }
      if (NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(left)) {
        return left.$equals(right as unknown as NoRdfTypeClassUnionMember2);
      }
      if (NonClass.isNonClass(left)) {
        return left.$equals(right as unknown as NonClass);
      }
      if (OrderedPropertiesClass.isOrderedPropertiesClass(left)) {
        return left.$equals(right as unknown as OrderedPropertiesClass);
      }
      if (PartialClassUnionMember1.isPartialClassUnionMember1(left)) {
        return left.$equals(right as unknown as PartialClassUnionMember1);
      }
      if (PartialClassUnionMember2.isPartialClassUnionMember2(left)) {
        return left.$equals(right as unknown as PartialClassUnionMember2);
      }
      if (PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(left)) {
        return PartialInterfaceUnionMember1.$equals(
          left,
          right as unknown as PartialInterfaceUnionMember1,
        );
      }
      if (PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(left)) {
        return PartialInterfaceUnionMember2.$equals(
          left,
          right as unknown as PartialInterfaceUnionMember2,
        );
      }
      if (PropertyCardinalitiesClass.isPropertyCardinalitiesClass(left)) {
        return left.$equals(right as unknown as PropertyCardinalitiesClass);
      }
      if (PropertyVisibilitiesClass.isPropertyVisibilitiesClass(left)) {
        return left.$equals(right as unknown as PropertyVisibilitiesClass);
      }
      if (RecursiveClassUnionMember1.isRecursiveClassUnionMember1(left)) {
        return left.$equals(right as unknown as RecursiveClassUnionMember1);
      }
      if (RecursiveClassUnionMember2.isRecursiveClassUnionMember2(left)) {
        return left.$equals(right as unknown as RecursiveClassUnionMember2);
      }
      if (Sha256IriIdentifierClass.isSha256IriIdentifierClass(left)) {
        return left.$equals(right as unknown as Sha256IriIdentifierClass);
      }
      if (TermPropertiesClass.isTermPropertiesClass(left)) {
        return left.$equals(right as unknown as TermPropertiesClass);
      }
      if (UnionDiscriminantsClass.isUnionDiscriminantsClass(left)) {
        return left.$equals(right as unknown as UnionDiscriminantsClass);
      }
      if (UuidV4IriIdentifierClass.isUuidV4IriIdentifierClass(left)) {
        return left.$equals(right as unknown as UuidV4IriIdentifierClass);
      }
      if (UuidV4IriIdentifierInterface.isUuidV4IriIdentifierInterface(left)) {
        return UuidV4IriIdentifierInterface.$equals(
          left,
          right as unknown as UuidV4IriIdentifierInterface,
        );
      }
      if ($DefaultPartial.is$DefaultPartial(left)) {
        return left.$equals(right as unknown as $DefaultPartial);
      }
      if ($NamedDefaultPartial.is$NamedDefaultPartial(left)) {
        return left.$equals(right as unknown as $NamedDefaultPartial);
      }
      return $EqualsResult.Equal;
    });
  }

  export function $filter(filter: $Object.$Filter, value: $Object): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }
    if (
      BlankNodeIdentifierClass.isBlankNodeIdentifierClass(value) &&
      filter.on?.BlankNodeIdentifierClass &&
      !BlankNodeIdentifierClass.$filter(
        filter.on.BlankNodeIdentifierClass,
        value as BlankNodeIdentifierClass,
      )
    ) {
      return false;
    }
    if (
      BlankNodeIdentifierInterface.isBlankNodeIdentifierInterface(value) &&
      filter.on?.BlankNodeIdentifierInterface &&
      !BlankNodeIdentifierInterface.$filter(
        filter.on.BlankNodeIdentifierInterface,
        value as BlankNodeIdentifierInterface,
      )
    ) {
      return false;
    }
    if (
      BlankNodeOrIriIdentifierClass.isBlankNodeOrIriIdentifierClass(value) &&
      filter.on?.BlankNodeOrIriIdentifierClass &&
      !BlankNodeOrIriIdentifierClass.$filter(
        filter.on.BlankNodeOrIriIdentifierClass,
        value as BlankNodeOrIriIdentifierClass,
      )
    ) {
      return false;
    }
    if (
      BlankNodeOrIriIdentifierInterface.isBlankNodeOrIriIdentifierInterface(
        value,
      ) &&
      filter.on?.BlankNodeOrIriIdentifierInterface &&
      !BlankNodeOrIriIdentifierInterface.$filter(
        filter.on.BlankNodeOrIriIdentifierInterface,
        value as BlankNodeOrIriIdentifierInterface,
      )
    ) {
      return false;
    }
    if (
      ClassUnionMember1.isClassUnionMember1(value) &&
      filter.on?.ClassUnionMember1 &&
      !ClassUnionMember1.$filter(
        filter.on.ClassUnionMember1,
        value as ClassUnionMember1,
      )
    ) {
      return false;
    }
    if (
      ClassUnionMember2.isClassUnionMember2(value) &&
      filter.on?.ClassUnionMember2 &&
      !ClassUnionMember2.$filter(
        filter.on.ClassUnionMember2,
        value as ClassUnionMember2,
      )
    ) {
      return false;
    }
    if (
      ClassUnionMemberCommonParentStatic.isClassUnionMemberCommonParent(
        value,
      ) &&
      filter.on?.ClassUnionMemberCommonParent &&
      !ClassUnionMemberCommonParentStatic.$filter(
        filter.on.ClassUnionMemberCommonParent,
        value as ClassUnionMemberCommonParent,
      )
    ) {
      return false;
    }
    if (
      ConcreteChildClass.isConcreteChildClass(value) &&
      filter.on?.ConcreteChildClass &&
      !ConcreteChildClass.$filter(
        filter.on.ConcreteChildClass,
        value as ConcreteChildClass,
      )
    ) {
      return false;
    }
    if (
      ConcreteParentClassStatic.isConcreteParentClass(value) &&
      filter.on?.ConcreteParentClass &&
      !ConcreteParentClassStatic.$filter(
        filter.on.ConcreteParentClass,
        value as ConcreteParentClass,
      )
    ) {
      return false;
    }
    if (
      AbstractBaseClassWithoutPropertiesStatic.isAbstractBaseClassWithoutProperties(
        value,
      ) &&
      filter.on?.AbstractBaseClassWithoutProperties &&
      !AbstractBaseClassWithoutPropertiesStatic.$filter(
        filter.on.AbstractBaseClassWithoutProperties,
        value as AbstractBaseClassWithoutProperties,
      )
    ) {
      return false;
    }
    if (
      AbstractBaseClassWithPropertiesStatic.isAbstractBaseClassWithProperties(
        value,
      ) &&
      filter.on?.AbstractBaseClassWithProperties &&
      !AbstractBaseClassWithPropertiesStatic.$filter(
        filter.on.AbstractBaseClassWithProperties,
        value as AbstractBaseClassWithProperties,
      )
    ) {
      return false;
    }
    if (
      ConcreteChildInterface.isConcreteChildInterface(value) &&
      filter.on?.ConcreteChildInterface &&
      !ConcreteChildInterface.$filter(
        filter.on.ConcreteChildInterface,
        value as ConcreteChildInterface,
      )
    ) {
      return false;
    }
    if (
      ConcreteParentInterfaceStatic.isConcreteParentInterface(value) &&
      filter.on?.ConcreteParentInterface &&
      !ConcreteParentInterfaceStatic.$filter(
        filter.on.ConcreteParentInterface,
        value as ConcreteParentInterface,
      )
    ) {
      return false;
    }
    if (
      BaseInterfaceWithoutPropertiesStatic.isBaseInterfaceWithoutProperties(
        value,
      ) &&
      filter.on?.BaseInterfaceWithoutProperties &&
      !BaseInterfaceWithoutPropertiesStatic.$filter(
        filter.on.BaseInterfaceWithoutProperties,
        value as BaseInterfaceWithoutProperties,
      )
    ) {
      return false;
    }
    if (
      BaseInterfaceWithPropertiesStatic.isBaseInterfaceWithProperties(value) &&
      filter.on?.BaseInterfaceWithProperties &&
      !BaseInterfaceWithPropertiesStatic.$filter(
        filter.on.BaseInterfaceWithProperties,
        value as BaseInterfaceWithProperties,
      )
    ) {
      return false;
    }
    if (
      ConvertibleTypePropertiesClass.isConvertibleTypePropertiesClass(value) &&
      filter.on?.ConvertibleTypePropertiesClass &&
      !ConvertibleTypePropertiesClass.$filter(
        filter.on.ConvertibleTypePropertiesClass,
        value as ConvertibleTypePropertiesClass,
      )
    ) {
      return false;
    }
    if (
      DateUnionPropertiesClass.isDateUnionPropertiesClass(value) &&
      filter.on?.DateUnionPropertiesClass &&
      !DateUnionPropertiesClass.$filter(
        filter.on.DateUnionPropertiesClass,
        value as DateUnionPropertiesClass,
      )
    ) {
      return false;
    }
    if (
      DefaultValuePropertiesClass.isDefaultValuePropertiesClass(value) &&
      filter.on?.DefaultValuePropertiesClass &&
      !DefaultValuePropertiesClass.$filter(
        filter.on.DefaultValuePropertiesClass,
        value as DefaultValuePropertiesClass,
      )
    ) {
      return false;
    }
    if (
      DirectRecursiveClass.isDirectRecursiveClass(value) &&
      filter.on?.DirectRecursiveClass &&
      !DirectRecursiveClass.$filter(
        filter.on.DirectRecursiveClass,
        value as DirectRecursiveClass,
      )
    ) {
      return false;
    }
    if (
      ExplicitFromToRdfTypesClass.isExplicitFromToRdfTypesClass(value) &&
      filter.on?.ExplicitFromToRdfTypesClass &&
      !ExplicitFromToRdfTypesClass.$filter(
        filter.on.ExplicitFromToRdfTypesClass,
        value as ExplicitFromToRdfTypesClass,
      )
    ) {
      return false;
    }
    if (
      ExplicitRdfTypeClass.isExplicitRdfTypeClass(value) &&
      filter.on?.ExplicitRdfTypeClass &&
      !ExplicitRdfTypeClass.$filter(
        filter.on.ExplicitRdfTypeClass,
        value as ExplicitRdfTypeClass,
      )
    ) {
      return false;
    }
    if (
      AbstractBaseClassForExternClassStatic.isAbstractBaseClassForExternClass(
        value,
      ) &&
      filter.on?.AbstractBaseClassForExternClass &&
      !AbstractBaseClassForExternClassStatic.$filter(
        filter.on.AbstractBaseClassForExternClass,
        value as AbstractBaseClassForExternClass,
      )
    ) {
      return false;
    }
    if (
      ExternClassPropertyClass.isExternClassPropertyClass(value) &&
      filter.on?.ExternClassPropertyClass &&
      !ExternClassPropertyClass.$filter(
        filter.on.ExternClassPropertyClass,
        value as ExternClassPropertyClass,
      )
    ) {
      return false;
    }
    if (
      FlattenClassUnionMember3.isFlattenClassUnionMember3(value) &&
      filter.on?.FlattenClassUnionMember3 &&
      !FlattenClassUnionMember3.$filter(
        filter.on.FlattenClassUnionMember3,
        value as FlattenClassUnionMember3,
      )
    ) {
      return false;
    }
    if (
      HasValuePropertiesClass.isHasValuePropertiesClass(value) &&
      filter.on?.HasValuePropertiesClass &&
      !HasValuePropertiesClass.$filter(
        filter.on.HasValuePropertiesClass,
        value as HasValuePropertiesClass,
      )
    ) {
      return false;
    }
    if (
      IdentifierOverride5Class.isIdentifierOverride5Class(value) &&
      filter.on?.IdentifierOverride5Class &&
      !IdentifierOverride5Class.$filter(
        filter.on.IdentifierOverride5Class,
        value as IdentifierOverride5Class,
      )
    ) {
      return false;
    }
    if (
      IdentifierOverride4ClassStatic.isIdentifierOverride4Class(value) &&
      filter.on?.IdentifierOverride4Class &&
      !IdentifierOverride4ClassStatic.$filter(
        filter.on.IdentifierOverride4Class,
        value as IdentifierOverride4Class,
      )
    ) {
      return false;
    }
    if (
      IdentifierOverride3ClassStatic.isIdentifierOverride3Class(value) &&
      filter.on?.IdentifierOverride3Class &&
      !IdentifierOverride3ClassStatic.$filter(
        filter.on.IdentifierOverride3Class,
        value as IdentifierOverride3Class,
      )
    ) {
      return false;
    }
    if (
      IdentifierOverride2ClassStatic.isIdentifierOverride2Class(value) &&
      filter.on?.IdentifierOverride2Class &&
      !IdentifierOverride2ClassStatic.$filter(
        filter.on.IdentifierOverride2Class,
        value as IdentifierOverride2Class,
      )
    ) {
      return false;
    }
    if (
      IdentifierOverride1ClassStatic.isIdentifierOverride1Class(value) &&
      filter.on?.IdentifierOverride1Class &&
      !IdentifierOverride1ClassStatic.$filter(
        filter.on.IdentifierOverride1Class,
        value as IdentifierOverride1Class,
      )
    ) {
      return false;
    }
    if (
      InIdentifierClass.isInIdentifierClass(value) &&
      filter.on?.InIdentifierClass &&
      !InIdentifierClass.$filter(
        filter.on.InIdentifierClass,
        value as InIdentifierClass,
      )
    ) {
      return false;
    }
    if (
      InPropertiesClass.isInPropertiesClass(value) &&
      filter.on?.InPropertiesClass &&
      !InPropertiesClass.$filter(
        filter.on.InPropertiesClass,
        value as InPropertiesClass,
      )
    ) {
      return false;
    }
    if (
      IndirectRecursiveClass.isIndirectRecursiveClass(value) &&
      filter.on?.IndirectRecursiveClass &&
      !IndirectRecursiveClass.$filter(
        filter.on.IndirectRecursiveClass,
        value as IndirectRecursiveClass,
      )
    ) {
      return false;
    }
    if (
      IndirectRecursiveHelperClass.isIndirectRecursiveHelperClass(value) &&
      filter.on?.IndirectRecursiveHelperClass &&
      !IndirectRecursiveHelperClass.$filter(
        filter.on.IndirectRecursiveHelperClass,
        value as IndirectRecursiveHelperClass,
      )
    ) {
      return false;
    }
    if (
      Interface.isInterface(value) &&
      filter.on?.Interface &&
      !Interface.$filter(filter.on.Interface, value as Interface)
    ) {
      return false;
    }
    if (
      InterfaceUnionMember1.isInterfaceUnionMember1(value) &&
      filter.on?.InterfaceUnionMember1 &&
      !InterfaceUnionMember1.$filter(
        filter.on.InterfaceUnionMember1,
        value as InterfaceUnionMember1,
      )
    ) {
      return false;
    }
    if (
      InterfaceUnionMember2.isInterfaceUnionMember2(value) &&
      filter.on?.InterfaceUnionMember2 &&
      !InterfaceUnionMember2.$filter(
        filter.on.InterfaceUnionMember2,
        value as InterfaceUnionMember2,
      )
    ) {
      return false;
    }
    if (
      InterfaceUnionMemberCommonParentStatic.isInterfaceUnionMemberCommonParent(
        value,
      ) &&
      filter.on?.InterfaceUnionMemberCommonParent &&
      !InterfaceUnionMemberCommonParentStatic.$filter(
        filter.on.InterfaceUnionMemberCommonParent,
        value as InterfaceUnionMemberCommonParent,
      )
    ) {
      return false;
    }
    if (
      IriIdentifierClass.isIriIdentifierClass(value) &&
      filter.on?.IriIdentifierClass &&
      !IriIdentifierClass.$filter(
        filter.on.IriIdentifierClass,
        value as IriIdentifierClass,
      )
    ) {
      return false;
    }
    if (
      IriIdentifierInterface.isIriIdentifierInterface(value) &&
      filter.on?.IriIdentifierInterface &&
      !IriIdentifierInterface.$filter(
        filter.on.IriIdentifierInterface,
        value as IriIdentifierInterface,
      )
    ) {
      return false;
    }
    if (
      JsPrimitiveUnionPropertyClass.isJsPrimitiveUnionPropertyClass(value) &&
      filter.on?.JsPrimitiveUnionPropertyClass &&
      !JsPrimitiveUnionPropertyClass.$filter(
        filter.on.JsPrimitiveUnionPropertyClass,
        value as JsPrimitiveUnionPropertyClass,
      )
    ) {
      return false;
    }
    if (
      LanguageInPropertiesClass.isLanguageInPropertiesClass(value) &&
      filter.on?.LanguageInPropertiesClass &&
      !LanguageInPropertiesClass.$filter(
        filter.on.LanguageInPropertiesClass,
        value as LanguageInPropertiesClass,
      )
    ) {
      return false;
    }
    if (
      LazilyResolvedBlankNodeOrIriIdentifierClass.isLazilyResolvedBlankNodeOrIriIdentifierClass(
        value,
      ) &&
      filter.on?.LazilyResolvedBlankNodeOrIriIdentifierClass &&
      !LazilyResolvedBlankNodeOrIriIdentifierClass.$filter(
        filter.on.LazilyResolvedBlankNodeOrIriIdentifierClass,
        value as LazilyResolvedBlankNodeOrIriIdentifierClass,
      )
    ) {
      return false;
    }
    if (
      LazilyResolvedBlankNodeOrIriIdentifierInterface.isLazilyResolvedBlankNodeOrIriIdentifierInterface(
        value,
      ) &&
      filter.on?.LazilyResolvedBlankNodeOrIriIdentifierInterface &&
      !LazilyResolvedBlankNodeOrIriIdentifierInterface.$filter(
        filter.on.LazilyResolvedBlankNodeOrIriIdentifierInterface,
        value as LazilyResolvedBlankNodeOrIriIdentifierInterface,
      )
    ) {
      return false;
    }
    if (
      LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(
        value,
      ) &&
      filter.on?.LazilyResolvedClassUnionMember1 &&
      !LazilyResolvedClassUnionMember1.$filter(
        filter.on.LazilyResolvedClassUnionMember1,
        value as LazilyResolvedClassUnionMember1,
      )
    ) {
      return false;
    }
    if (
      LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(
        value,
      ) &&
      filter.on?.LazilyResolvedClassUnionMember2 &&
      !LazilyResolvedClassUnionMember2.$filter(
        filter.on.LazilyResolvedClassUnionMember2,
        value as LazilyResolvedClassUnionMember2,
      )
    ) {
      return false;
    }
    if (
      LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
        value,
      ) &&
      filter.on?.LazilyResolvedInterfaceUnionMember1 &&
      !LazilyResolvedInterfaceUnionMember1.$filter(
        filter.on.LazilyResolvedInterfaceUnionMember1,
        value as LazilyResolvedInterfaceUnionMember1,
      )
    ) {
      return false;
    }
    if (
      LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
        value,
      ) &&
      filter.on?.LazilyResolvedInterfaceUnionMember2 &&
      !LazilyResolvedInterfaceUnionMember2.$filter(
        filter.on.LazilyResolvedInterfaceUnionMember2,
        value as LazilyResolvedInterfaceUnionMember2,
      )
    ) {
      return false;
    }
    if (
      LazilyResolvedIriIdentifierClass.isLazilyResolvedIriIdentifierClass(
        value,
      ) &&
      filter.on?.LazilyResolvedIriIdentifierClass &&
      !LazilyResolvedIriIdentifierClass.$filter(
        filter.on.LazilyResolvedIriIdentifierClass,
        value as LazilyResolvedIriIdentifierClass,
      )
    ) {
      return false;
    }
    if (
      LazilyResolvedIriIdentifierInterface.isLazilyResolvedIriIdentifierInterface(
        value,
      ) &&
      filter.on?.LazilyResolvedIriIdentifierInterface &&
      !LazilyResolvedIriIdentifierInterface.$filter(
        filter.on.LazilyResolvedIriIdentifierInterface,
        value as LazilyResolvedIriIdentifierInterface,
      )
    ) {
      return false;
    }
    if (
      LazyPropertiesClass.isLazyPropertiesClass(value) &&
      filter.on?.LazyPropertiesClass &&
      !LazyPropertiesClass.$filter(
        filter.on.LazyPropertiesClass,
        value as LazyPropertiesClass,
      )
    ) {
      return false;
    }
    if (
      PartialClass.isPartialClass(value) &&
      filter.on?.PartialClass &&
      !PartialClass.$filter(filter.on.PartialClass, value as PartialClass)
    ) {
      return false;
    }
    if (
      LazyPropertiesInterface.isLazyPropertiesInterface(value) &&
      filter.on?.LazyPropertiesInterface &&
      !LazyPropertiesInterface.$filter(
        filter.on.LazyPropertiesInterface,
        value as LazyPropertiesInterface,
      )
    ) {
      return false;
    }
    if (
      PartialInterface.isPartialInterface(value) &&
      filter.on?.PartialInterface &&
      !PartialInterface.$filter(
        filter.on.PartialInterface,
        value as PartialInterface,
      )
    ) {
      return false;
    }
    if (
      ListPropertiesClass.isListPropertiesClass(value) &&
      filter.on?.ListPropertiesClass &&
      !ListPropertiesClass.$filter(
        filter.on.ListPropertiesClass,
        value as ListPropertiesClass,
      )
    ) {
      return false;
    }
    if (
      MutablePropertiesClass.isMutablePropertiesClass(value) &&
      filter.on?.MutablePropertiesClass &&
      !MutablePropertiesClass.$filter(
        filter.on.MutablePropertiesClass,
        value as MutablePropertiesClass,
      )
    ) {
      return false;
    }
    if (
      NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(value) &&
      filter.on?.NoRdfTypeClassUnionMember1 &&
      !NoRdfTypeClassUnionMember1.$filter(
        filter.on.NoRdfTypeClassUnionMember1,
        value as NoRdfTypeClassUnionMember1,
      )
    ) {
      return false;
    }
    if (
      NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(value) &&
      filter.on?.NoRdfTypeClassUnionMember2 &&
      !NoRdfTypeClassUnionMember2.$filter(
        filter.on.NoRdfTypeClassUnionMember2,
        value as NoRdfTypeClassUnionMember2,
      )
    ) {
      return false;
    }
    if (
      NonClass.isNonClass(value) &&
      filter.on?.NonClass &&
      !NonClass.$filter(filter.on.NonClass, value as NonClass)
    ) {
      return false;
    }
    if (
      OrderedPropertiesClass.isOrderedPropertiesClass(value) &&
      filter.on?.OrderedPropertiesClass &&
      !OrderedPropertiesClass.$filter(
        filter.on.OrderedPropertiesClass,
        value as OrderedPropertiesClass,
      )
    ) {
      return false;
    }
    if (
      PartialClassUnionMember1.isPartialClassUnionMember1(value) &&
      filter.on?.PartialClassUnionMember1 &&
      !PartialClassUnionMember1.$filter(
        filter.on.PartialClassUnionMember1,
        value as PartialClassUnionMember1,
      )
    ) {
      return false;
    }
    if (
      PartialClassUnionMember2.isPartialClassUnionMember2(value) &&
      filter.on?.PartialClassUnionMember2 &&
      !PartialClassUnionMember2.$filter(
        filter.on.PartialClassUnionMember2,
        value as PartialClassUnionMember2,
      )
    ) {
      return false;
    }
    if (
      PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(value) &&
      filter.on?.PartialInterfaceUnionMember1 &&
      !PartialInterfaceUnionMember1.$filter(
        filter.on.PartialInterfaceUnionMember1,
        value as PartialInterfaceUnionMember1,
      )
    ) {
      return false;
    }
    if (
      PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(value) &&
      filter.on?.PartialInterfaceUnionMember2 &&
      !PartialInterfaceUnionMember2.$filter(
        filter.on.PartialInterfaceUnionMember2,
        value as PartialInterfaceUnionMember2,
      )
    ) {
      return false;
    }
    if (
      PropertyCardinalitiesClass.isPropertyCardinalitiesClass(value) &&
      filter.on?.PropertyCardinalitiesClass &&
      !PropertyCardinalitiesClass.$filter(
        filter.on.PropertyCardinalitiesClass,
        value as PropertyCardinalitiesClass,
      )
    ) {
      return false;
    }
    if (
      PropertyVisibilitiesClass.isPropertyVisibilitiesClass(value) &&
      filter.on?.PropertyVisibilitiesClass &&
      !PropertyVisibilitiesClass.$filter(
        filter.on.PropertyVisibilitiesClass,
        value as PropertyVisibilitiesClass,
      )
    ) {
      return false;
    }
    if (
      RecursiveClassUnionMember1.isRecursiveClassUnionMember1(value) &&
      filter.on?.RecursiveClassUnionMember1 &&
      !RecursiveClassUnionMember1.$filter(
        filter.on.RecursiveClassUnionMember1,
        value as RecursiveClassUnionMember1,
      )
    ) {
      return false;
    }
    if (
      RecursiveClassUnionMember2.isRecursiveClassUnionMember2(value) &&
      filter.on?.RecursiveClassUnionMember2 &&
      !RecursiveClassUnionMember2.$filter(
        filter.on.RecursiveClassUnionMember2,
        value as RecursiveClassUnionMember2,
      )
    ) {
      return false;
    }
    if (
      Sha256IriIdentifierClass.isSha256IriIdentifierClass(value) &&
      filter.on?.Sha256IriIdentifierClass &&
      !Sha256IriIdentifierClass.$filter(
        filter.on.Sha256IriIdentifierClass,
        value as Sha256IriIdentifierClass,
      )
    ) {
      return false;
    }
    if (
      TermPropertiesClass.isTermPropertiesClass(value) &&
      filter.on?.TermPropertiesClass &&
      !TermPropertiesClass.$filter(
        filter.on.TermPropertiesClass,
        value as TermPropertiesClass,
      )
    ) {
      return false;
    }
    if (
      UnionDiscriminantsClass.isUnionDiscriminantsClass(value) &&
      filter.on?.UnionDiscriminantsClass &&
      !UnionDiscriminantsClass.$filter(
        filter.on.UnionDiscriminantsClass,
        value as UnionDiscriminantsClass,
      )
    ) {
      return false;
    }
    if (
      UuidV4IriIdentifierClass.isUuidV4IriIdentifierClass(value) &&
      filter.on?.UuidV4IriIdentifierClass &&
      !UuidV4IriIdentifierClass.$filter(
        filter.on.UuidV4IriIdentifierClass,
        value as UuidV4IriIdentifierClass,
      )
    ) {
      return false;
    }
    if (
      UuidV4IriIdentifierInterface.isUuidV4IriIdentifierInterface(value) &&
      filter.on?.UuidV4IriIdentifierInterface &&
      !UuidV4IriIdentifierInterface.$filter(
        filter.on.UuidV4IriIdentifierInterface,
        value as UuidV4IriIdentifierInterface,
      )
    ) {
      return false;
    }
    if (
      $DefaultPartial.is$DefaultPartial(value) &&
      filter.on?.$DefaultPartial &&
      !$DefaultPartial.$filter(
        filter.on.$DefaultPartial,
        value as $DefaultPartial,
      )
    ) {
      return false;
    }
    if (
      $NamedDefaultPartial.is$NamedDefaultPartial(value) &&
      filter.on?.$NamedDefaultPartial &&
      !$NamedDefaultPartial.$filter(
        filter.on.$NamedDefaultPartial,
        value as $NamedDefaultPartial,
      )
    ) {
      return false;
    }
    return true;
  }

  export interface $Filter {
    readonly $identifier?: $IdentifierFilter;
    readonly on?: {
      readonly BlankNodeIdentifierClass?: Omit<
        BlankNodeIdentifierClass.$Filter,
        "$identifier"
      >;
      readonly BlankNodeIdentifierInterface?: Omit<
        BlankNodeIdentifierInterface.$Filter,
        "$identifier"
      >;
      readonly BlankNodeOrIriIdentifierClass?: Omit<
        BlankNodeOrIriIdentifierClass.$Filter,
        "$identifier"
      >;
      readonly BlankNodeOrIriIdentifierInterface?: Omit<
        BlankNodeOrIriIdentifierInterface.$Filter,
        "$identifier"
      >;
      readonly ClassUnionMember1?: Omit<
        ClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly ClassUnionMember2?: Omit<
        ClassUnionMember2.$Filter,
        "$identifier"
      >;
      readonly ClassUnionMemberCommonParent?: Omit<
        ClassUnionMemberCommonParentStatic.$Filter,
        "$identifier"
      >;
      readonly ConcreteChildClass?: Omit<
        ConcreteChildClass.$Filter,
        "$identifier"
      >;
      readonly ConcreteParentClass?: Omit<
        ConcreteParentClassStatic.$Filter,
        "$identifier"
      >;
      readonly AbstractBaseClassWithoutProperties?: Omit<
        AbstractBaseClassWithoutPropertiesStatic.$Filter,
        "$identifier"
      >;
      readonly AbstractBaseClassWithProperties?: Omit<
        AbstractBaseClassWithPropertiesStatic.$Filter,
        "$identifier"
      >;
      readonly ConcreteChildInterface?: Omit<
        ConcreteChildInterface.$Filter,
        "$identifier"
      >;
      readonly ConcreteParentInterface?: Omit<
        ConcreteParentInterfaceStatic.$Filter,
        "$identifier"
      >;
      readonly BaseInterfaceWithoutProperties?: Omit<
        BaseInterfaceWithoutPropertiesStatic.$Filter,
        "$identifier"
      >;
      readonly BaseInterfaceWithProperties?: Omit<
        BaseInterfaceWithPropertiesStatic.$Filter,
        "$identifier"
      >;
      readonly ConvertibleTypePropertiesClass?: Omit<
        ConvertibleTypePropertiesClass.$Filter,
        "$identifier"
      >;
      readonly DateUnionPropertiesClass?: Omit<
        DateUnionPropertiesClass.$Filter,
        "$identifier"
      >;
      readonly DefaultValuePropertiesClass?: Omit<
        DefaultValuePropertiesClass.$Filter,
        "$identifier"
      >;
      readonly DirectRecursiveClass?: Omit<
        DirectRecursiveClass.$Filter,
        "$identifier"
      >;
      readonly ExplicitFromToRdfTypesClass?: Omit<
        ExplicitFromToRdfTypesClass.$Filter,
        "$identifier"
      >;
      readonly ExplicitRdfTypeClass?: Omit<
        ExplicitRdfTypeClass.$Filter,
        "$identifier"
      >;
      readonly AbstractBaseClassForExternClass?: Omit<
        AbstractBaseClassForExternClassStatic.$Filter,
        "$identifier"
      >;
      readonly ExternClassPropertyClass?: Omit<
        ExternClassPropertyClass.$Filter,
        "$identifier"
      >;
      readonly FlattenClassUnionMember3?: Omit<
        FlattenClassUnionMember3.$Filter,
        "$identifier"
      >;
      readonly HasValuePropertiesClass?: Omit<
        HasValuePropertiesClass.$Filter,
        "$identifier"
      >;
      readonly IdentifierOverride5Class?: Omit<
        IdentifierOverride5Class.$Filter,
        "$identifier"
      >;
      readonly IdentifierOverride4Class?: Omit<
        IdentifierOverride4ClassStatic.$Filter,
        "$identifier"
      >;
      readonly IdentifierOverride3Class?: Omit<
        IdentifierOverride3ClassStatic.$Filter,
        "$identifier"
      >;
      readonly IdentifierOverride2Class?: Omit<
        IdentifierOverride2ClassStatic.$Filter,
        "$identifier"
      >;
      readonly IdentifierOverride1Class?: Omit<
        IdentifierOverride1ClassStatic.$Filter,
        "$identifier"
      >;
      readonly InIdentifierClass?: Omit<
        InIdentifierClass.$Filter,
        "$identifier"
      >;
      readonly InPropertiesClass?: Omit<
        InPropertiesClass.$Filter,
        "$identifier"
      >;
      readonly IndirectRecursiveClass?: Omit<
        IndirectRecursiveClass.$Filter,
        "$identifier"
      >;
      readonly IndirectRecursiveHelperClass?: Omit<
        IndirectRecursiveHelperClass.$Filter,
        "$identifier"
      >;
      readonly Interface?: Omit<Interface.$Filter, "$identifier">;
      readonly InterfaceUnionMember1?: Omit<
        InterfaceUnionMember1.$Filter,
        "$identifier"
      >;
      readonly InterfaceUnionMember2?: Omit<
        InterfaceUnionMember2.$Filter,
        "$identifier"
      >;
      readonly InterfaceUnionMemberCommonParent?: Omit<
        InterfaceUnionMemberCommonParentStatic.$Filter,
        "$identifier"
      >;
      readonly IriIdentifierClass?: Omit<
        IriIdentifierClass.$Filter,
        "$identifier"
      >;
      readonly IriIdentifierInterface?: Omit<
        IriIdentifierInterface.$Filter,
        "$identifier"
      >;
      readonly JsPrimitiveUnionPropertyClass?: Omit<
        JsPrimitiveUnionPropertyClass.$Filter,
        "$identifier"
      >;
      readonly LanguageInPropertiesClass?: Omit<
        LanguageInPropertiesClass.$Filter,
        "$identifier"
      >;
      readonly LazilyResolvedBlankNodeOrIriIdentifierClass?: Omit<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
        "$identifier"
      >;
      readonly LazilyResolvedBlankNodeOrIriIdentifierInterface?: Omit<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
        "$identifier"
      >;
      readonly LazilyResolvedClassUnionMember1?: Omit<
        LazilyResolvedClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly LazilyResolvedClassUnionMember2?: Omit<
        LazilyResolvedClassUnionMember2.$Filter,
        "$identifier"
      >;
      readonly LazilyResolvedInterfaceUnionMember1?: Omit<
        LazilyResolvedInterfaceUnionMember1.$Filter,
        "$identifier"
      >;
      readonly LazilyResolvedInterfaceUnionMember2?: Omit<
        LazilyResolvedInterfaceUnionMember2.$Filter,
        "$identifier"
      >;
      readonly LazilyResolvedIriIdentifierClass?: Omit<
        LazilyResolvedIriIdentifierClass.$Filter,
        "$identifier"
      >;
      readonly LazilyResolvedIriIdentifierInterface?: Omit<
        LazilyResolvedIriIdentifierInterface.$Filter,
        "$identifier"
      >;
      readonly LazyPropertiesClass?: Omit<
        LazyPropertiesClass.$Filter,
        "$identifier"
      >;
      readonly PartialClass?: Omit<PartialClass.$Filter, "$identifier">;
      readonly LazyPropertiesInterface?: Omit<
        LazyPropertiesInterface.$Filter,
        "$identifier"
      >;
      readonly PartialInterface?: Omit<PartialInterface.$Filter, "$identifier">;
      readonly ListPropertiesClass?: Omit<
        ListPropertiesClass.$Filter,
        "$identifier"
      >;
      readonly MutablePropertiesClass?: Omit<
        MutablePropertiesClass.$Filter,
        "$identifier"
      >;
      readonly NoRdfTypeClassUnionMember1?: Omit<
        NoRdfTypeClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly NoRdfTypeClassUnionMember2?: Omit<
        NoRdfTypeClassUnionMember2.$Filter,
        "$identifier"
      >;
      readonly NonClass?: Omit<NonClass.$Filter, "$identifier">;
      readonly OrderedPropertiesClass?: Omit<
        OrderedPropertiesClass.$Filter,
        "$identifier"
      >;
      readonly PartialClassUnionMember1?: Omit<
        PartialClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly PartialClassUnionMember2?: Omit<
        PartialClassUnionMember2.$Filter,
        "$identifier"
      >;
      readonly PartialInterfaceUnionMember1?: Omit<
        PartialInterfaceUnionMember1.$Filter,
        "$identifier"
      >;
      readonly PartialInterfaceUnionMember2?: Omit<
        PartialInterfaceUnionMember2.$Filter,
        "$identifier"
      >;
      readonly PropertyCardinalitiesClass?: Omit<
        PropertyCardinalitiesClass.$Filter,
        "$identifier"
      >;
      readonly PropertyVisibilitiesClass?: Omit<
        PropertyVisibilitiesClass.$Filter,
        "$identifier"
      >;
      readonly RecursiveClassUnionMember1?: Omit<
        RecursiveClassUnionMember1.$Filter,
        "$identifier"
      >;
      readonly RecursiveClassUnionMember2?: Omit<
        RecursiveClassUnionMember2.$Filter,
        "$identifier"
      >;
      readonly Sha256IriIdentifierClass?: Omit<
        Sha256IriIdentifierClass.$Filter,
        "$identifier"
      >;
      readonly TermPropertiesClass?: Omit<
        TermPropertiesClass.$Filter,
        "$identifier"
      >;
      readonly UnionDiscriminantsClass?: Omit<
        UnionDiscriminantsClass.$Filter,
        "$identifier"
      >;
      readonly UuidV4IriIdentifierClass?: Omit<
        UuidV4IriIdentifierClass.$Filter,
        "$identifier"
      >;
      readonly UuidV4IriIdentifierInterface?: Omit<
        UuidV4IriIdentifierInterface.$Filter,
        "$identifier"
      >;
      readonly $DefaultPartial?: Omit<$DefaultPartial.$Filter, "$identifier">;
      readonly $NamedDefaultPartial?: Omit<
        $NamedDefaultPartial.$Filter,
        "$identifier"
      >;
    };
  }

  export function $hash<HasherT extends $Hasher>(
    _object: $Object,
    _hasher: HasherT,
  ): HasherT {
    if (BlankNodeIdentifierClass.isBlankNodeIdentifierClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (BlankNodeIdentifierInterface.isBlankNodeIdentifierInterface(_object)) {
      return BlankNodeIdentifierInterface.$hash(_object, _hasher);
    }
    if (
      BlankNodeOrIriIdentifierClass.isBlankNodeOrIriIdentifierClass(_object)
    ) {
      return _object.$hash(_hasher);
    }
    if (
      BlankNodeOrIriIdentifierInterface.isBlankNodeOrIriIdentifierInterface(
        _object,
      )
    ) {
      return BlankNodeOrIriIdentifierInterface.$hash(_object, _hasher);
    }
    if (ClassUnionMember1.isClassUnionMember1(_object)) {
      return _object.$hash(_hasher);
    }
    if (ClassUnionMember2.isClassUnionMember2(_object)) {
      return _object.$hash(_hasher);
    }
    if (ConcreteChildClass.isConcreteChildClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (ConcreteParentClassStatic.isConcreteParentClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (ConcreteChildInterface.isConcreteChildInterface(_object)) {
      return ConcreteChildInterface.$hash(_object, _hasher);
    }
    if (ConcreteParentInterfaceStatic.isConcreteParentInterface(_object)) {
      return ConcreteParentInterfaceStatic.$hash(_object, _hasher);
    }
    if (
      BaseInterfaceWithoutPropertiesStatic.isBaseInterfaceWithoutProperties(
        _object,
      )
    ) {
      return BaseInterfaceWithoutPropertiesStatic.$hash(_object, _hasher);
    }
    if (
      BaseInterfaceWithPropertiesStatic.isBaseInterfaceWithProperties(_object)
    ) {
      return BaseInterfaceWithPropertiesStatic.$hash(_object, _hasher);
    }
    if (
      ConvertibleTypePropertiesClass.isConvertibleTypePropertiesClass(_object)
    ) {
      return _object.$hash(_hasher);
    }
    if (DateUnionPropertiesClass.isDateUnionPropertiesClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (DefaultValuePropertiesClass.isDefaultValuePropertiesClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (DirectRecursiveClass.isDirectRecursiveClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (ExplicitFromToRdfTypesClass.isExplicitFromToRdfTypesClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (ExplicitRdfTypeClass.isExplicitRdfTypeClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (ExternClassPropertyClass.isExternClassPropertyClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (FlattenClassUnionMember3.isFlattenClassUnionMember3(_object)) {
      return _object.$hash(_hasher);
    }
    if (HasValuePropertiesClass.isHasValuePropertiesClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (IdentifierOverride5Class.isIdentifierOverride5Class(_object)) {
      return _object.$hash(_hasher);
    }
    if (IdentifierOverride4ClassStatic.isIdentifierOverride4Class(_object)) {
      return _object.$hash(_hasher);
    }
    if (IdentifierOverride3ClassStatic.isIdentifierOverride3Class(_object)) {
      return _object.$hash(_hasher);
    }
    if (InIdentifierClass.isInIdentifierClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (InPropertiesClass.isInPropertiesClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (IndirectRecursiveClass.isIndirectRecursiveClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (IndirectRecursiveHelperClass.isIndirectRecursiveHelperClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (Interface.isInterface(_object)) {
      return Interface.$hash(_object, _hasher);
    }
    if (InterfaceUnionMember1.isInterfaceUnionMember1(_object)) {
      return InterfaceUnionMember1.$hash(_object, _hasher);
    }
    if (InterfaceUnionMember2.isInterfaceUnionMember2(_object)) {
      return InterfaceUnionMember2.$hash(_object, _hasher);
    }
    if (IriIdentifierClass.isIriIdentifierClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (IriIdentifierInterface.isIriIdentifierInterface(_object)) {
      return IriIdentifierInterface.$hash(_object, _hasher);
    }
    if (
      JsPrimitiveUnionPropertyClass.isJsPrimitiveUnionPropertyClass(_object)
    ) {
      return _object.$hash(_hasher);
    }
    if (LanguageInPropertiesClass.isLanguageInPropertiesClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (
      LazilyResolvedBlankNodeOrIriIdentifierClass.isLazilyResolvedBlankNodeOrIriIdentifierClass(
        _object,
      )
    ) {
      return _object.$hash(_hasher);
    }
    if (
      LazilyResolvedBlankNodeOrIriIdentifierInterface.isLazilyResolvedBlankNodeOrIriIdentifierInterface(
        _object,
      )
    ) {
      return LazilyResolvedBlankNodeOrIriIdentifierInterface.$hash(
        _object,
        _hasher,
      );
    }
    if (
      LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(_object)
    ) {
      return _object.$hash(_hasher);
    }
    if (
      LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(_object)
    ) {
      return _object.$hash(_hasher);
    }
    if (
      LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
        _object,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember1.$hash(_object, _hasher);
    }
    if (
      LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
        _object,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember2.$hash(_object, _hasher);
    }
    if (
      LazilyResolvedIriIdentifierClass.isLazilyResolvedIriIdentifierClass(
        _object,
      )
    ) {
      return _object.$hash(_hasher);
    }
    if (
      LazilyResolvedIriIdentifierInterface.isLazilyResolvedIriIdentifierInterface(
        _object,
      )
    ) {
      return LazilyResolvedIriIdentifierInterface.$hash(_object, _hasher);
    }
    if (LazyPropertiesClass.isLazyPropertiesClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (PartialClass.isPartialClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (LazyPropertiesInterface.isLazyPropertiesInterface(_object)) {
      return LazyPropertiesInterface.$hash(_object, _hasher);
    }
    if (PartialInterface.isPartialInterface(_object)) {
      return PartialInterface.$hash(_object, _hasher);
    }
    if (ListPropertiesClass.isListPropertiesClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (MutablePropertiesClass.isMutablePropertiesClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(_object)) {
      return _object.$hash(_hasher);
    }
    if (NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(_object)) {
      return _object.$hash(_hasher);
    }
    if (NonClass.isNonClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (OrderedPropertiesClass.isOrderedPropertiesClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (PartialClassUnionMember1.isPartialClassUnionMember1(_object)) {
      return _object.$hash(_hasher);
    }
    if (PartialClassUnionMember2.isPartialClassUnionMember2(_object)) {
      return _object.$hash(_hasher);
    }
    if (PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(_object)) {
      return PartialInterfaceUnionMember1.$hash(_object, _hasher);
    }
    if (PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(_object)) {
      return PartialInterfaceUnionMember2.$hash(_object, _hasher);
    }
    if (PropertyCardinalitiesClass.isPropertyCardinalitiesClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (PropertyVisibilitiesClass.isPropertyVisibilitiesClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (RecursiveClassUnionMember1.isRecursiveClassUnionMember1(_object)) {
      return _object.$hash(_hasher);
    }
    if (RecursiveClassUnionMember2.isRecursiveClassUnionMember2(_object)) {
      return _object.$hash(_hasher);
    }
    if (Sha256IriIdentifierClass.isSha256IriIdentifierClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (TermPropertiesClass.isTermPropertiesClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (UnionDiscriminantsClass.isUnionDiscriminantsClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (UuidV4IriIdentifierClass.isUuidV4IriIdentifierClass(_object)) {
      return _object.$hash(_hasher);
    }
    if (UuidV4IriIdentifierInterface.isUuidV4IriIdentifierInterface(_object)) {
      return UuidV4IriIdentifierInterface.$hash(_object, _hasher);
    }
    if ($DefaultPartial.is$DefaultPartial(_object)) {
      return _object.$hash(_hasher);
    }
    if ($NamedDefaultPartial.is$NamedDefaultPartial(_object)) {
      return _object.$hash(_hasher);
    }
    throw new Error("unrecognized type");
  }

  export type $Identifier = BlankNode | NamedNode;

  export namespace $Identifier {
    export const fromString = $identifierFromString; // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
    export const toString = Resource.Identifier.toString;
  }

  export function $fromJson(json: unknown): Either<z.ZodError, $Object> {
    return (
      BlankNodeIdentifierClass.$fromJson(json) as Either<z.ZodError, $Object>
    )
      .altLazy(
        () =>
          BlankNodeIdentifierInterface.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          BlankNodeOrIriIdentifierClass.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          BlankNodeOrIriIdentifierInterface.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () => ClassUnionMember1.$fromJson(json) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () => ClassUnionMember2.$fromJson(json) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () => ConcreteChildClass.$fromJson(json) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () =>
          ConcreteParentClassStatic.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          ConcreteChildInterface.$fromJson(json) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () =>
          ConcreteParentInterfaceStatic.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          BaseInterfaceWithoutPropertiesStatic.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          BaseInterfaceWithPropertiesStatic.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          ConvertibleTypePropertiesClass.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          DateUnionPropertiesClass.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          DefaultValuePropertiesClass.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          DirectRecursiveClass.$fromJson(json) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () =>
          ExplicitFromToRdfTypesClass.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          ExplicitRdfTypeClass.$fromJson(json) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () =>
          ExternClassPropertyClass.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          FlattenClassUnionMember3.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          HasValuePropertiesClass.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          IdentifierOverride5Class.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          IdentifierOverride4ClassStatic.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          IdentifierOverride3ClassStatic.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () => InIdentifierClass.$fromJson(json) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () => InPropertiesClass.$fromJson(json) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () =>
          IndirectRecursiveClass.$fromJson(json) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () =>
          IndirectRecursiveHelperClass.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(() => Interface.$fromJson(json) as Either<z.ZodError, $Object>)
      .altLazy(
        () =>
          InterfaceUnionMember1.$fromJson(json) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () =>
          InterfaceUnionMember2.$fromJson(json) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () => IriIdentifierClass.$fromJson(json) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () =>
          IriIdentifierInterface.$fromJson(json) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () =>
          JsPrimitiveUnionPropertyClass.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          LanguageInPropertiesClass.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          LazilyResolvedBlankNodeOrIriIdentifierClass.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromJson(
            json,
          ) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () =>
          LazilyResolvedClassUnionMember1.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          LazilyResolvedClassUnionMember2.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          LazilyResolvedInterfaceUnionMember1.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          LazilyResolvedInterfaceUnionMember2.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          LazilyResolvedIriIdentifierClass.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          LazilyResolvedIriIdentifierInterface.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          LazyPropertiesClass.$fromJson(json) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () => PartialClass.$fromJson(json) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () =>
          LazyPropertiesInterface.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () => PartialInterface.$fromJson(json) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () =>
          ListPropertiesClass.$fromJson(json) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () =>
          MutablePropertiesClass.$fromJson(json) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () =>
          NoRdfTypeClassUnionMember1.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          NoRdfTypeClassUnionMember2.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(() => NonClass.$fromJson(json) as Either<z.ZodError, $Object>)
      .altLazy(
        () =>
          OrderedPropertiesClass.$fromJson(json) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () =>
          PartialClassUnionMember1.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          PartialClassUnionMember2.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          PartialInterfaceUnionMember1.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          PartialInterfaceUnionMember2.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          PropertyCardinalitiesClass.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          PropertyVisibilitiesClass.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          RecursiveClassUnionMember1.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          RecursiveClassUnionMember2.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          Sha256IriIdentifierClass.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          TermPropertiesClass.$fromJson(json) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () =>
          UnionDiscriminantsClass.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          UuidV4IriIdentifierClass.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () =>
          UuidV4IriIdentifierInterface.$fromJson(json) as Either<
            z.ZodError,
            $Object
          >,
      )
      .altLazy(
        () => $DefaultPartial.$fromJson(json) as Either<z.ZodError, $Object>,
      )
      .altLazy(
        () =>
          $NamedDefaultPartial.$fromJson(json) as Either<z.ZodError, $Object>,
      );
  }

  export function $jsonZodSchema() {
    return z.discriminatedUnion("$type", [
      BlankNodeIdentifierClass.$jsonZodSchema(),
      BlankNodeIdentifierInterface.$jsonZodSchema(),
      BlankNodeOrIriIdentifierClass.$jsonZodSchema(),
      BlankNodeOrIriIdentifierInterface.$jsonZodSchema(),
      ClassUnionMember1.$jsonZodSchema(),
      ClassUnionMember2.$jsonZodSchema(),
      ConcreteChildClass.$jsonZodSchema(),
      ConcreteParentClassStatic.$jsonZodSchema(),
      ConcreteChildInterface.$jsonZodSchema(),
      ConcreteParentInterfaceStatic.$jsonZodSchema(),
      BaseInterfaceWithoutPropertiesStatic.$jsonZodSchema(),
      BaseInterfaceWithPropertiesStatic.$jsonZodSchema(),
      ConvertibleTypePropertiesClass.$jsonZodSchema(),
      DateUnionPropertiesClass.$jsonZodSchema(),
      DefaultValuePropertiesClass.$jsonZodSchema(),
      DirectRecursiveClass.$jsonZodSchema(),
      ExplicitFromToRdfTypesClass.$jsonZodSchema(),
      ExplicitRdfTypeClass.$jsonZodSchema(),
      ExternClassPropertyClass.$jsonZodSchema(),
      FlattenClassUnionMember3.$jsonZodSchema(),
      HasValuePropertiesClass.$jsonZodSchema(),
      IdentifierOverride5Class.$jsonZodSchema(),
      IdentifierOverride4ClassStatic.$jsonZodSchema(),
      IdentifierOverride3ClassStatic.$jsonZodSchema(),
      InIdentifierClass.$jsonZodSchema(),
      InPropertiesClass.$jsonZodSchema(),
      IndirectRecursiveClass.$jsonZodSchema(),
      IndirectRecursiveHelperClass.$jsonZodSchema(),
      Interface.$jsonZodSchema(),
      InterfaceUnionMember1.$jsonZodSchema(),
      InterfaceUnionMember2.$jsonZodSchema(),
      IriIdentifierClass.$jsonZodSchema(),
      IriIdentifierInterface.$jsonZodSchema(),
      JsPrimitiveUnionPropertyClass.$jsonZodSchema(),
      LanguageInPropertiesClass.$jsonZodSchema(),
      LazilyResolvedBlankNodeOrIriIdentifierClass.$jsonZodSchema(),
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$jsonZodSchema(),
      LazilyResolvedClassUnionMember1.$jsonZodSchema(),
      LazilyResolvedClassUnionMember2.$jsonZodSchema(),
      LazilyResolvedInterfaceUnionMember1.$jsonZodSchema(),
      LazilyResolvedInterfaceUnionMember2.$jsonZodSchema(),
      LazilyResolvedIriIdentifierClass.$jsonZodSchema(),
      LazilyResolvedIriIdentifierInterface.$jsonZodSchema(),
      LazyPropertiesClass.$jsonZodSchema(),
      PartialClass.$jsonZodSchema(),
      LazyPropertiesInterface.$jsonZodSchema(),
      PartialInterface.$jsonZodSchema(),
      ListPropertiesClass.$jsonZodSchema(),
      MutablePropertiesClass.$jsonZodSchema(),
      NoRdfTypeClassUnionMember1.$jsonZodSchema(),
      NoRdfTypeClassUnionMember2.$jsonZodSchema(),
      NonClass.$jsonZodSchema(),
      OrderedPropertiesClass.$jsonZodSchema(),
      PartialClassUnionMember1.$jsonZodSchema(),
      PartialClassUnionMember2.$jsonZodSchema(),
      PartialInterfaceUnionMember1.$jsonZodSchema(),
      PartialInterfaceUnionMember2.$jsonZodSchema(),
      PropertyCardinalitiesClass.$jsonZodSchema(),
      PropertyVisibilitiesClass.$jsonZodSchema(),
      RecursiveClassUnionMember1.$jsonZodSchema(),
      RecursiveClassUnionMember2.$jsonZodSchema(),
      Sha256IriIdentifierClass.$jsonZodSchema(),
      TermPropertiesClass.$jsonZodSchema(),
      UnionDiscriminantsClass.$jsonZodSchema(),
      UuidV4IriIdentifierClass.$jsonZodSchema(),
      UuidV4IriIdentifierInterface.$jsonZodSchema(),
      $DefaultPartial.$jsonZodSchema(),
      $NamedDefaultPartial.$jsonZodSchema(),
    ]);
  }

  export function $toJson(
    _object: $Object,
  ):
    | BlankNodeIdentifierClass.$Json
    | BlankNodeIdentifierInterface.$Json
    | BlankNodeOrIriIdentifierClass.$Json
    | BlankNodeOrIriIdentifierInterface.$Json
    | ClassUnionMember1.$Json
    | ClassUnionMember2.$Json
    | ClassUnionMemberCommonParentStatic.$Json
    | ConcreteChildClass.$Json
    | ConcreteParentClassStatic.$Json
    | AbstractBaseClassWithoutPropertiesStatic.$Json
    | AbstractBaseClassWithPropertiesStatic.$Json
    | ConcreteChildInterface.$Json
    | ConcreteParentInterfaceStatic.$Json
    | BaseInterfaceWithoutPropertiesStatic.$Json
    | BaseInterfaceWithPropertiesStatic.$Json
    | ConvertibleTypePropertiesClass.$Json
    | DateUnionPropertiesClass.$Json
    | DefaultValuePropertiesClass.$Json
    | DirectRecursiveClass.$Json
    | ExplicitFromToRdfTypesClass.$Json
    | ExplicitRdfTypeClass.$Json
    | AbstractBaseClassForExternClassStatic.$Json
    | ExternClassPropertyClass.$Json
    | FlattenClassUnionMember3.$Json
    | HasValuePropertiesClass.$Json
    | IdentifierOverride5Class.$Json
    | IdentifierOverride4ClassStatic.$Json
    | IdentifierOverride3ClassStatic.$Json
    | IdentifierOverride2ClassStatic.$Json
    | IdentifierOverride1ClassStatic.$Json
    | InIdentifierClass.$Json
    | InPropertiesClass.$Json
    | IndirectRecursiveClass.$Json
    | IndirectRecursiveHelperClass.$Json
    | Interface.$Json
    | InterfaceUnionMember1.$Json
    | InterfaceUnionMember2.$Json
    | InterfaceUnionMemberCommonParentStatic.$Json
    | IriIdentifierClass.$Json
    | IriIdentifierInterface.$Json
    | JsPrimitiveUnionPropertyClass.$Json
    | LanguageInPropertiesClass.$Json
    | LazilyResolvedBlankNodeOrIriIdentifierClass.$Json
    | LazilyResolvedBlankNodeOrIriIdentifierInterface.$Json
    | LazilyResolvedClassUnionMember1.$Json
    | LazilyResolvedClassUnionMember2.$Json
    | LazilyResolvedInterfaceUnionMember1.$Json
    | LazilyResolvedInterfaceUnionMember2.$Json
    | LazilyResolvedIriIdentifierClass.$Json
    | LazilyResolvedIriIdentifierInterface.$Json
    | LazyPropertiesClass.$Json
    | PartialClass.$Json
    | LazyPropertiesInterface.$Json
    | PartialInterface.$Json
    | ListPropertiesClass.$Json
    | MutablePropertiesClass.$Json
    | NoRdfTypeClassUnionMember1.$Json
    | NoRdfTypeClassUnionMember2.$Json
    | NonClass.$Json
    | OrderedPropertiesClass.$Json
    | PartialClassUnionMember1.$Json
    | PartialClassUnionMember2.$Json
    | PartialInterfaceUnionMember1.$Json
    | PartialInterfaceUnionMember2.$Json
    | PropertyCardinalitiesClass.$Json
    | PropertyVisibilitiesClass.$Json
    | RecursiveClassUnionMember1.$Json
    | RecursiveClassUnionMember2.$Json
    | Sha256IriIdentifierClass.$Json
    | TermPropertiesClass.$Json
    | UnionDiscriminantsClass.$Json
    | UuidV4IriIdentifierClass.$Json
    | UuidV4IriIdentifierInterface.$Json
    | $DefaultPartial.$Json
    | $NamedDefaultPartial.$Json {
    if (BlankNodeIdentifierClass.isBlankNodeIdentifierClass(_object)) {
      return _object.$toJson();
    }
    if (BlankNodeIdentifierInterface.isBlankNodeIdentifierInterface(_object)) {
      return BlankNodeIdentifierInterface.$toJson(_object);
    }
    if (
      BlankNodeOrIriIdentifierClass.isBlankNodeOrIriIdentifierClass(_object)
    ) {
      return _object.$toJson();
    }
    if (
      BlankNodeOrIriIdentifierInterface.isBlankNodeOrIriIdentifierInterface(
        _object,
      )
    ) {
      return BlankNodeOrIriIdentifierInterface.$toJson(_object);
    }
    if (ClassUnionMember1.isClassUnionMember1(_object)) {
      return _object.$toJson();
    }
    if (ClassUnionMember2.isClassUnionMember2(_object)) {
      return _object.$toJson();
    }
    if (ConcreteChildClass.isConcreteChildClass(_object)) {
      return _object.$toJson();
    }
    if (ConcreteParentClassStatic.isConcreteParentClass(_object)) {
      return _object.$toJson();
    }
    if (ConcreteChildInterface.isConcreteChildInterface(_object)) {
      return ConcreteChildInterface.$toJson(_object);
    }
    if (ConcreteParentInterfaceStatic.isConcreteParentInterface(_object)) {
      return ConcreteParentInterfaceStatic.$toJson(_object);
    }
    if (
      BaseInterfaceWithoutPropertiesStatic.isBaseInterfaceWithoutProperties(
        _object,
      )
    ) {
      return BaseInterfaceWithoutPropertiesStatic.$toJson(_object);
    }
    if (
      BaseInterfaceWithPropertiesStatic.isBaseInterfaceWithProperties(_object)
    ) {
      return BaseInterfaceWithPropertiesStatic.$toJson(_object);
    }
    if (
      ConvertibleTypePropertiesClass.isConvertibleTypePropertiesClass(_object)
    ) {
      return _object.$toJson();
    }
    if (DateUnionPropertiesClass.isDateUnionPropertiesClass(_object)) {
      return _object.$toJson();
    }
    if (DefaultValuePropertiesClass.isDefaultValuePropertiesClass(_object)) {
      return _object.$toJson();
    }
    if (DirectRecursiveClass.isDirectRecursiveClass(_object)) {
      return _object.$toJson();
    }
    if (ExplicitFromToRdfTypesClass.isExplicitFromToRdfTypesClass(_object)) {
      return _object.$toJson();
    }
    if (ExplicitRdfTypeClass.isExplicitRdfTypeClass(_object)) {
      return _object.$toJson();
    }
    if (ExternClassPropertyClass.isExternClassPropertyClass(_object)) {
      return _object.$toJson();
    }
    if (FlattenClassUnionMember3.isFlattenClassUnionMember3(_object)) {
      return _object.$toJson();
    }
    if (HasValuePropertiesClass.isHasValuePropertiesClass(_object)) {
      return _object.$toJson();
    }
    if (IdentifierOverride5Class.isIdentifierOverride5Class(_object)) {
      return _object.$toJson();
    }
    if (IdentifierOverride4ClassStatic.isIdentifierOverride4Class(_object)) {
      return _object.$toJson();
    }
    if (IdentifierOverride3ClassStatic.isIdentifierOverride3Class(_object)) {
      return _object.$toJson();
    }
    if (InIdentifierClass.isInIdentifierClass(_object)) {
      return _object.$toJson();
    }
    if (InPropertiesClass.isInPropertiesClass(_object)) {
      return _object.$toJson();
    }
    if (IndirectRecursiveClass.isIndirectRecursiveClass(_object)) {
      return _object.$toJson();
    }
    if (IndirectRecursiveHelperClass.isIndirectRecursiveHelperClass(_object)) {
      return _object.$toJson();
    }
    if (Interface.isInterface(_object)) {
      return Interface.$toJson(_object);
    }
    if (InterfaceUnionMember1.isInterfaceUnionMember1(_object)) {
      return InterfaceUnionMember1.$toJson(_object);
    }
    if (InterfaceUnionMember2.isInterfaceUnionMember2(_object)) {
      return InterfaceUnionMember2.$toJson(_object);
    }
    if (IriIdentifierClass.isIriIdentifierClass(_object)) {
      return _object.$toJson();
    }
    if (IriIdentifierInterface.isIriIdentifierInterface(_object)) {
      return IriIdentifierInterface.$toJson(_object);
    }
    if (
      JsPrimitiveUnionPropertyClass.isJsPrimitiveUnionPropertyClass(_object)
    ) {
      return _object.$toJson();
    }
    if (LanguageInPropertiesClass.isLanguageInPropertiesClass(_object)) {
      return _object.$toJson();
    }
    if (
      LazilyResolvedBlankNodeOrIriIdentifierClass.isLazilyResolvedBlankNodeOrIriIdentifierClass(
        _object,
      )
    ) {
      return _object.$toJson();
    }
    if (
      LazilyResolvedBlankNodeOrIriIdentifierInterface.isLazilyResolvedBlankNodeOrIriIdentifierInterface(
        _object,
      )
    ) {
      return LazilyResolvedBlankNodeOrIriIdentifierInterface.$toJson(_object);
    }
    if (
      LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(_object)
    ) {
      return _object.$toJson();
    }
    if (
      LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(_object)
    ) {
      return _object.$toJson();
    }
    if (
      LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
        _object,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember1.$toJson(_object);
    }
    if (
      LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
        _object,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember2.$toJson(_object);
    }
    if (
      LazilyResolvedIriIdentifierClass.isLazilyResolvedIriIdentifierClass(
        _object,
      )
    ) {
      return _object.$toJson();
    }
    if (
      LazilyResolvedIriIdentifierInterface.isLazilyResolvedIriIdentifierInterface(
        _object,
      )
    ) {
      return LazilyResolvedIriIdentifierInterface.$toJson(_object);
    }
    if (LazyPropertiesClass.isLazyPropertiesClass(_object)) {
      return _object.$toJson();
    }
    if (PartialClass.isPartialClass(_object)) {
      return _object.$toJson();
    }
    if (LazyPropertiesInterface.isLazyPropertiesInterface(_object)) {
      return LazyPropertiesInterface.$toJson(_object);
    }
    if (PartialInterface.isPartialInterface(_object)) {
      return PartialInterface.$toJson(_object);
    }
    if (ListPropertiesClass.isListPropertiesClass(_object)) {
      return _object.$toJson();
    }
    if (MutablePropertiesClass.isMutablePropertiesClass(_object)) {
      return _object.$toJson();
    }
    if (NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(_object)) {
      return _object.$toJson();
    }
    if (NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(_object)) {
      return _object.$toJson();
    }
    if (NonClass.isNonClass(_object)) {
      return _object.$toJson();
    }
    if (OrderedPropertiesClass.isOrderedPropertiesClass(_object)) {
      return _object.$toJson();
    }
    if (PartialClassUnionMember1.isPartialClassUnionMember1(_object)) {
      return _object.$toJson();
    }
    if (PartialClassUnionMember2.isPartialClassUnionMember2(_object)) {
      return _object.$toJson();
    }
    if (PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(_object)) {
      return PartialInterfaceUnionMember1.$toJson(_object);
    }
    if (PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(_object)) {
      return PartialInterfaceUnionMember2.$toJson(_object);
    }
    if (PropertyCardinalitiesClass.isPropertyCardinalitiesClass(_object)) {
      return _object.$toJson();
    }
    if (PropertyVisibilitiesClass.isPropertyVisibilitiesClass(_object)) {
      return _object.$toJson();
    }
    if (RecursiveClassUnionMember1.isRecursiveClassUnionMember1(_object)) {
      return _object.$toJson();
    }
    if (RecursiveClassUnionMember2.isRecursiveClassUnionMember2(_object)) {
      return _object.$toJson();
    }
    if (Sha256IriIdentifierClass.isSha256IriIdentifierClass(_object)) {
      return _object.$toJson();
    }
    if (TermPropertiesClass.isTermPropertiesClass(_object)) {
      return _object.$toJson();
    }
    if (UnionDiscriminantsClass.isUnionDiscriminantsClass(_object)) {
      return _object.$toJson();
    }
    if (UuidV4IriIdentifierClass.isUuidV4IriIdentifierClass(_object)) {
      return _object.$toJson();
    }
    if (UuidV4IriIdentifierInterface.isUuidV4IriIdentifierInterface(_object)) {
      return UuidV4IriIdentifierInterface.$toJson(_object);
    }
    if ($DefaultPartial.is$DefaultPartial(_object)) {
      return _object.$toJson();
    }
    if ($NamedDefaultPartial.is$NamedDefaultPartial(_object)) {
      return _object.$toJson();
    }
    throw new Error("unrecognized type");
  }

  export type $Json =
    | BlankNodeIdentifierClass.$Json
    | BlankNodeIdentifierInterface.$Json
    | BlankNodeOrIriIdentifierClass.$Json
    | BlankNodeOrIriIdentifierInterface.$Json
    | ClassUnionMember1.$Json
    | ClassUnionMember2.$Json
    | ConcreteChildClass.$Json
    | ConcreteParentClassStatic.$Json
    | ConcreteChildInterface.$Json
    | ConcreteParentInterfaceStatic.$Json
    | BaseInterfaceWithoutPropertiesStatic.$Json
    | BaseInterfaceWithPropertiesStatic.$Json
    | ConvertibleTypePropertiesClass.$Json
    | DateUnionPropertiesClass.$Json
    | DefaultValuePropertiesClass.$Json
    | DirectRecursiveClass.$Json
    | ExplicitFromToRdfTypesClass.$Json
    | ExplicitRdfTypeClass.$Json
    | ExternClassPropertyClass.$Json
    | FlattenClassUnionMember3.$Json
    | HasValuePropertiesClass.$Json
    | IdentifierOverride5Class.$Json
    | IdentifierOverride4ClassStatic.$Json
    | IdentifierOverride3ClassStatic.$Json
    | InIdentifierClass.$Json
    | InPropertiesClass.$Json
    | IndirectRecursiveClass.$Json
    | IndirectRecursiveHelperClass.$Json
    | Interface.$Json
    | InterfaceUnionMember1.$Json
    | InterfaceUnionMember2.$Json
    | IriIdentifierClass.$Json
    | IriIdentifierInterface.$Json
    | JsPrimitiveUnionPropertyClass.$Json
    | LanguageInPropertiesClass.$Json
    | LazilyResolvedBlankNodeOrIriIdentifierClass.$Json
    | LazilyResolvedBlankNodeOrIriIdentifierInterface.$Json
    | LazilyResolvedClassUnionMember1.$Json
    | LazilyResolvedClassUnionMember2.$Json
    | LazilyResolvedInterfaceUnionMember1.$Json
    | LazilyResolvedInterfaceUnionMember2.$Json
    | LazilyResolvedIriIdentifierClass.$Json
    | LazilyResolvedIriIdentifierInterface.$Json
    | LazyPropertiesClass.$Json
    | PartialClass.$Json
    | LazyPropertiesInterface.$Json
    | PartialInterface.$Json
    | ListPropertiesClass.$Json
    | MutablePropertiesClass.$Json
    | NoRdfTypeClassUnionMember1.$Json
    | NoRdfTypeClassUnionMember2.$Json
    | NonClass.$Json
    | OrderedPropertiesClass.$Json
    | PartialClassUnionMember1.$Json
    | PartialClassUnionMember2.$Json
    | PartialInterfaceUnionMember1.$Json
    | PartialInterfaceUnionMember2.$Json
    | PropertyCardinalitiesClass.$Json
    | PropertyVisibilitiesClass.$Json
    | RecursiveClassUnionMember1.$Json
    | RecursiveClassUnionMember2.$Json
    | Sha256IriIdentifierClass.$Json
    | TermPropertiesClass.$Json
    | UnionDiscriminantsClass.$Json
    | UuidV4IriIdentifierClass.$Json
    | UuidV4IriIdentifierInterface.$Json
    | $DefaultPartial.$Json
    | $NamedDefaultPartial.$Json;

  export const $schema = { properties: {} } as const;

  export function $fromRdf(
    resource: Resource,
    options?: $FromRdfOptions,
  ): Either<Error, $Object> {
    return (
      BlankNodeIdentifierClass.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as Either<Error, $Object>
    )
      .altLazy(
        () =>
          BlankNodeIdentifierInterface.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          BlankNodeOrIriIdentifierClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          BlankNodeOrIriIdentifierInterface.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ClassUnionMember1.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ClassUnionMember2.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ConcreteChildClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ConcreteParentClassStatic.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ConcreteChildInterface.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ConcreteParentInterfaceStatic.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          BaseInterfaceWithoutPropertiesStatic.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          BaseInterfaceWithPropertiesStatic.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ConvertibleTypePropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          DateUnionPropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          DefaultValuePropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          DirectRecursiveClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ExplicitFromToRdfTypesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ExplicitRdfTypeClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ExternClassPropertyClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          FlattenClassUnionMember3.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          HasValuePropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          IdentifierOverride5Class.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          IdentifierOverride4ClassStatic.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          IdentifierOverride3ClassStatic.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          InIdentifierClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          InPropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          IndirectRecursiveClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          IndirectRecursiveHelperClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          Interface.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          InterfaceUnionMember1.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          InterfaceUnionMember2.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          IriIdentifierClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          IriIdentifierInterface.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          JsPrimitiveUnionPropertyClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LanguageInPropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LazilyResolvedClassUnionMember1.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LazilyResolvedClassUnionMember2.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LazilyResolvedInterfaceUnionMember1.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LazilyResolvedInterfaceUnionMember2.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LazilyResolvedIriIdentifierClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LazilyResolvedIriIdentifierInterface.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LazyPropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          PartialClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          LazyPropertiesInterface.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          PartialInterface.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          ListPropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          MutablePropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          NoRdfTypeClassUnionMember1.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          NoRdfTypeClassUnionMember2.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          NonClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          OrderedPropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          PartialClassUnionMember1.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          PartialClassUnionMember2.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          PartialInterfaceUnionMember1.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          PartialInterfaceUnionMember2.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          PropertyCardinalitiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          PropertyVisibilitiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          RecursiveClassUnionMember1.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          RecursiveClassUnionMember2.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          Sha256IriIdentifierClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          TermPropertiesClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          UnionDiscriminantsClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          UuidV4IriIdentifierClass.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          UuidV4IriIdentifierInterface.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          $DefaultPartial.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      )
      .altLazy(
        () =>
          $NamedDefaultPartial.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as Either<Error, $Object>,
      );
  }

  export function $toRdf(
    _object: $Object,
    _parameters?: {
      graph?: Exclude<Quad_Graph, Variable>;
      resourceSet?: ResourceSet;
    },
  ): Resource {
    if (BlankNodeIdentifierClass.isBlankNodeIdentifierClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (BlankNodeIdentifierInterface.isBlankNodeIdentifierInterface(_object)) {
      return BlankNodeIdentifierInterface.$toRdf(_object, _parameters);
    }
    if (
      BlankNodeOrIriIdentifierClass.isBlankNodeOrIriIdentifierClass(_object)
    ) {
      return _object.$toRdf(_parameters);
    }
    if (
      BlankNodeOrIriIdentifierInterface.isBlankNodeOrIriIdentifierInterface(
        _object,
      )
    ) {
      return BlankNodeOrIriIdentifierInterface.$toRdf(_object, _parameters);
    }
    if (ClassUnionMember1.isClassUnionMember1(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (ClassUnionMember2.isClassUnionMember2(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (ConcreteChildClass.isConcreteChildClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (ConcreteParentClassStatic.isConcreteParentClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (ConcreteChildInterface.isConcreteChildInterface(_object)) {
      return ConcreteChildInterface.$toRdf(_object, _parameters);
    }
    if (ConcreteParentInterfaceStatic.isConcreteParentInterface(_object)) {
      return ConcreteParentInterfaceStatic.$toRdf(_object, _parameters);
    }
    if (
      BaseInterfaceWithoutPropertiesStatic.isBaseInterfaceWithoutProperties(
        _object,
      )
    ) {
      return BaseInterfaceWithoutPropertiesStatic.$toRdf(_object, _parameters);
    }
    if (
      BaseInterfaceWithPropertiesStatic.isBaseInterfaceWithProperties(_object)
    ) {
      return BaseInterfaceWithPropertiesStatic.$toRdf(_object, _parameters);
    }
    if (
      ConvertibleTypePropertiesClass.isConvertibleTypePropertiesClass(_object)
    ) {
      return _object.$toRdf(_parameters);
    }
    if (DateUnionPropertiesClass.isDateUnionPropertiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (DefaultValuePropertiesClass.isDefaultValuePropertiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (DirectRecursiveClass.isDirectRecursiveClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (ExplicitFromToRdfTypesClass.isExplicitFromToRdfTypesClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (ExplicitRdfTypeClass.isExplicitRdfTypeClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (ExternClassPropertyClass.isExternClassPropertyClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (FlattenClassUnionMember3.isFlattenClassUnionMember3(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (HasValuePropertiesClass.isHasValuePropertiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (IdentifierOverride5Class.isIdentifierOverride5Class(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (IdentifierOverride4ClassStatic.isIdentifierOverride4Class(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (IdentifierOverride3ClassStatic.isIdentifierOverride3Class(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (InIdentifierClass.isInIdentifierClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (InPropertiesClass.isInPropertiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (IndirectRecursiveClass.isIndirectRecursiveClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (IndirectRecursiveHelperClass.isIndirectRecursiveHelperClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (Interface.isInterface(_object)) {
      return Interface.$toRdf(_object, _parameters);
    }
    if (InterfaceUnionMember1.isInterfaceUnionMember1(_object)) {
      return InterfaceUnionMember1.$toRdf(_object, _parameters);
    }
    if (InterfaceUnionMember2.isInterfaceUnionMember2(_object)) {
      return InterfaceUnionMember2.$toRdf(_object, _parameters);
    }
    if (IriIdentifierClass.isIriIdentifierClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (IriIdentifierInterface.isIriIdentifierInterface(_object)) {
      return IriIdentifierInterface.$toRdf(_object, _parameters);
    }
    if (
      JsPrimitiveUnionPropertyClass.isJsPrimitiveUnionPropertyClass(_object)
    ) {
      return _object.$toRdf(_parameters);
    }
    if (LanguageInPropertiesClass.isLanguageInPropertiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (
      LazilyResolvedBlankNodeOrIriIdentifierClass.isLazilyResolvedBlankNodeOrIriIdentifierClass(
        _object,
      )
    ) {
      return _object.$toRdf(_parameters);
    }
    if (
      LazilyResolvedBlankNodeOrIriIdentifierInterface.isLazilyResolvedBlankNodeOrIriIdentifierInterface(
        _object,
      )
    ) {
      return LazilyResolvedBlankNodeOrIriIdentifierInterface.$toRdf(
        _object,
        _parameters,
      );
    }
    if (
      LazilyResolvedClassUnionMember1.isLazilyResolvedClassUnionMember1(_object)
    ) {
      return _object.$toRdf(_parameters);
    }
    if (
      LazilyResolvedClassUnionMember2.isLazilyResolvedClassUnionMember2(_object)
    ) {
      return _object.$toRdf(_parameters);
    }
    if (
      LazilyResolvedInterfaceUnionMember1.isLazilyResolvedInterfaceUnionMember1(
        _object,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember1.$toRdf(_object, _parameters);
    }
    if (
      LazilyResolvedInterfaceUnionMember2.isLazilyResolvedInterfaceUnionMember2(
        _object,
      )
    ) {
      return LazilyResolvedInterfaceUnionMember2.$toRdf(_object, _parameters);
    }
    if (
      LazilyResolvedIriIdentifierClass.isLazilyResolvedIriIdentifierClass(
        _object,
      )
    ) {
      return _object.$toRdf(_parameters);
    }
    if (
      LazilyResolvedIriIdentifierInterface.isLazilyResolvedIriIdentifierInterface(
        _object,
      )
    ) {
      return LazilyResolvedIriIdentifierInterface.$toRdf(_object, _parameters);
    }
    if (LazyPropertiesClass.isLazyPropertiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (PartialClass.isPartialClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (LazyPropertiesInterface.isLazyPropertiesInterface(_object)) {
      return LazyPropertiesInterface.$toRdf(_object, _parameters);
    }
    if (PartialInterface.isPartialInterface(_object)) {
      return PartialInterface.$toRdf(_object, _parameters);
    }
    if (ListPropertiesClass.isListPropertiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (MutablePropertiesClass.isMutablePropertiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (NoRdfTypeClassUnionMember1.isNoRdfTypeClassUnionMember1(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (NoRdfTypeClassUnionMember2.isNoRdfTypeClassUnionMember2(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (NonClass.isNonClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (OrderedPropertiesClass.isOrderedPropertiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (PartialClassUnionMember1.isPartialClassUnionMember1(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (PartialClassUnionMember2.isPartialClassUnionMember2(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (PartialInterfaceUnionMember1.isPartialInterfaceUnionMember1(_object)) {
      return PartialInterfaceUnionMember1.$toRdf(_object, _parameters);
    }
    if (PartialInterfaceUnionMember2.isPartialInterfaceUnionMember2(_object)) {
      return PartialInterfaceUnionMember2.$toRdf(_object, _parameters);
    }
    if (PropertyCardinalitiesClass.isPropertyCardinalitiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (PropertyVisibilitiesClass.isPropertyVisibilitiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (RecursiveClassUnionMember1.isRecursiveClassUnionMember1(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (RecursiveClassUnionMember2.isRecursiveClassUnionMember2(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (Sha256IriIdentifierClass.isSha256IriIdentifierClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (TermPropertiesClass.isTermPropertiesClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (UnionDiscriminantsClass.isUnionDiscriminantsClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (UuidV4IriIdentifierClass.isUuidV4IriIdentifierClass(_object)) {
      return _object.$toRdf(_parameters);
    }
    if (UuidV4IriIdentifierInterface.isUuidV4IriIdentifierInterface(_object)) {
      return UuidV4IriIdentifierInterface.$toRdf(_object, _parameters);
    }
    if ($DefaultPartial.is$DefaultPartial(_object)) {
      return _object.$toRdf(_parameters);
    }
    if ($NamedDefaultPartial.is$NamedDefaultPartial(_object)) {
      return _object.$toRdf(_parameters);
    }
    throw new Error("unrecognized type");
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: $Object.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};
    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        $Object.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $normalizeSparqlWherePatterns(
          $Object.$sparqlWherePatterns({
            filter,
            ignoreRdfType,
            preferredLanguages,
            subject,
          }),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: $Object.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      $Object.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...BlankNodeIdentifierClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectBlankNodeIdentifierClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}BlankNodeIdentifierClass`
          : "objectBlankNodeIdentifierClass",
      }).concat(),
      ...BlankNodeIdentifierInterface.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectBlankNodeIdentifierInterface"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}BlankNodeIdentifierInterface`
          : "objectBlankNodeIdentifierInterface",
      }).concat(),
      ...BlankNodeOrIriIdentifierClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectBlankNodeOrIriIdentifierClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}BlankNodeOrIriIdentifierClass`
          : "objectBlankNodeOrIriIdentifierClass",
      }).concat(),
      ...BlankNodeOrIriIdentifierInterface.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectBlankNodeOrIriIdentifierInterface"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}BlankNodeOrIriIdentifierInterface`
          : "objectBlankNodeOrIriIdentifierInterface",
      }).concat(),
      ...ClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectClassUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ClassUnionMember1`
          : "objectClassUnionMember1",
      }).concat(),
      ...ClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectClassUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ClassUnionMember2`
          : "objectClassUnionMember2",
      }).concat(),
      ...ConcreteChildClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectConcreteChildClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ConcreteChildClass`
          : "objectConcreteChildClass",
      }).concat(),
      ...ConcreteParentClassStatic.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectConcreteParentClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ConcreteParentClass`
          : "objectConcreteParentClass",
      }).concat(),
      ...ConcreteChildInterface.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectConcreteChildInterface"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ConcreteChildInterface`
          : "objectConcreteChildInterface",
      }).concat(),
      ...ConcreteParentInterfaceStatic.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectConcreteParentInterface"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ConcreteParentInterface`
          : "objectConcreteParentInterface",
      }).concat(),
      ...BaseInterfaceWithoutPropertiesStatic.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectBaseInterfaceWithoutProperties"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}BaseInterfaceWithoutProperties`
          : "objectBaseInterfaceWithoutProperties",
      }).concat(),
      ...BaseInterfaceWithPropertiesStatic.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectBaseInterfaceWithProperties"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}BaseInterfaceWithProperties`
          : "objectBaseInterfaceWithProperties",
      }).concat(),
      ...ConvertibleTypePropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectConvertibleTypePropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ConvertibleTypePropertiesClass`
          : "objectConvertibleTypePropertiesClass",
      }).concat(),
      ...DateUnionPropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectDateUnionPropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}DateUnionPropertiesClass`
          : "objectDateUnionPropertiesClass",
      }).concat(),
      ...DefaultValuePropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectDefaultValuePropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}DefaultValuePropertiesClass`
          : "objectDefaultValuePropertiesClass",
      }).concat(),
      ...DirectRecursiveClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectDirectRecursiveClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}DirectRecursiveClass`
          : "objectDirectRecursiveClass",
      }).concat(),
      ...ExplicitFromToRdfTypesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectExplicitFromToRdfTypesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ExplicitFromToRdfTypesClass`
          : "objectExplicitFromToRdfTypesClass",
      }).concat(),
      ...ExplicitRdfTypeClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectExplicitRdfTypeClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ExplicitRdfTypeClass`
          : "objectExplicitRdfTypeClass",
      }).concat(),
      ...ExternClassPropertyClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectExternClassPropertyClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ExternClassPropertyClass`
          : "objectExternClassPropertyClass",
      }).concat(),
      ...FlattenClassUnionMember3.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectFlattenClassUnionMember3"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}FlattenClassUnionMember3`
          : "objectFlattenClassUnionMember3",
      }).concat(),
      ...HasValuePropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectHasValuePropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}HasValuePropertiesClass`
          : "objectHasValuePropertiesClass",
      }).concat(),
      ...IdentifierOverride5Class.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectIdentifierOverride5Class"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}IdentifierOverride5Class`
          : "objectIdentifierOverride5Class",
      }).concat(),
      ...IdentifierOverride4ClassStatic.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectIdentifierOverride4Class"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}IdentifierOverride4Class`
          : "objectIdentifierOverride4Class",
      }).concat(),
      ...IdentifierOverride3ClassStatic.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectIdentifierOverride3Class"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}IdentifierOverride3Class`
          : "objectIdentifierOverride3Class",
      }).concat(),
      ...InIdentifierClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectInIdentifierClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}InIdentifierClass`
          : "objectInIdentifierClass",
      }).concat(),
      ...InPropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectInPropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}InPropertiesClass`
          : "objectInPropertiesClass",
      }).concat(),
      ...IndirectRecursiveClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectIndirectRecursiveClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}IndirectRecursiveClass`
          : "objectIndirectRecursiveClass",
      }).concat(),
      ...IndirectRecursiveHelperClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectIndirectRecursiveHelperClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}IndirectRecursiveHelperClass`
          : "objectIndirectRecursiveHelperClass",
      }).concat(),
      ...Interface.$sparqlConstructTriples({
        subject:
          parameters?.subject ?? dataFactory.variable!("objectInterface"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}Interface`
          : "objectInterface",
      }).concat(),
      ...InterfaceUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectInterfaceUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}InterfaceUnionMember1`
          : "objectInterfaceUnionMember1",
      }).concat(),
      ...InterfaceUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectInterfaceUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}InterfaceUnionMember2`
          : "objectInterfaceUnionMember2",
      }).concat(),
      ...IriIdentifierClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectIriIdentifierClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}IriIdentifierClass`
          : "objectIriIdentifierClass",
      }).concat(),
      ...IriIdentifierInterface.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectIriIdentifierInterface"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}IriIdentifierInterface`
          : "objectIriIdentifierInterface",
      }).concat(),
      ...JsPrimitiveUnionPropertyClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectJsPrimitiveUnionPropertyClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}JsPrimitiveUnionPropertyClass`
          : "objectJsPrimitiveUnionPropertyClass",
      }).concat(),
      ...LanguageInPropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectLanguageInPropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LanguageInPropertiesClass`
          : "objectLanguageInPropertiesClass",
      }).concat(),
      ...LazilyResolvedBlankNodeOrIriIdentifierClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "objectLazilyResolvedBlankNodeOrIriIdentifierClass",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedBlankNodeOrIriIdentifierClass`
          : "objectLazilyResolvedBlankNodeOrIriIdentifierClass",
      }).concat(),
      ...LazilyResolvedBlankNodeOrIriIdentifierInterface.$sparqlConstructTriples(
        {
          subject:
            parameters?.subject ??
            dataFactory.variable!(
              "objectLazilyResolvedBlankNodeOrIriIdentifierInterface",
            ),
          variablePrefix: parameters?.variablePrefix
            ? `${parameters.variablePrefix}LazilyResolvedBlankNodeOrIriIdentifierInterface`
            : "objectLazilyResolvedBlankNodeOrIriIdentifierInterface",
        },
      ).concat(),
      ...LazilyResolvedClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectLazilyResolvedClassUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember1`
          : "objectLazilyResolvedClassUnionMember1",
      }).concat(),
      ...LazilyResolvedClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectLazilyResolvedClassUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember2`
          : "objectLazilyResolvedClassUnionMember2",
      }).concat(),
      ...LazilyResolvedInterfaceUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectLazilyResolvedInterfaceUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember1`
          : "objectLazilyResolvedInterfaceUnionMember1",
      }).concat(),
      ...LazilyResolvedInterfaceUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectLazilyResolvedInterfaceUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember2`
          : "objectLazilyResolvedInterfaceUnionMember2",
      }).concat(),
      ...LazilyResolvedIriIdentifierClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectLazilyResolvedIriIdentifierClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedIriIdentifierClass`
          : "objectLazilyResolvedIriIdentifierClass",
      }).concat(),
      ...LazilyResolvedIriIdentifierInterface.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectLazilyResolvedIriIdentifierInterface"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedIriIdentifierInterface`
          : "objectLazilyResolvedIriIdentifierInterface",
      }).concat(),
      ...LazyPropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectLazyPropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazyPropertiesClass`
          : "objectLazyPropertiesClass",
      }).concat(),
      ...PartialClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ?? dataFactory.variable!("objectPartialClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialClass`
          : "objectPartialClass",
      }).concat(),
      ...LazyPropertiesInterface.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectLazyPropertiesInterface"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazyPropertiesInterface`
          : "objectLazyPropertiesInterface",
      }).concat(),
      ...PartialInterface.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectPartialInterface"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialInterface`
          : "objectPartialInterface",
      }).concat(),
      ...ListPropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectListPropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ListPropertiesClass`
          : "objectListPropertiesClass",
      }).concat(),
      ...MutablePropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectMutablePropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}MutablePropertiesClass`
          : "objectMutablePropertiesClass",
      }).concat(),
      ...NoRdfTypeClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectNoRdfTypeClassUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}NoRdfTypeClassUnionMember1`
          : "objectNoRdfTypeClassUnionMember1",
      }).concat(),
      ...NoRdfTypeClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectNoRdfTypeClassUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}NoRdfTypeClassUnionMember2`
          : "objectNoRdfTypeClassUnionMember2",
      }).concat(),
      ...NonClass.$sparqlConstructTriples({
        subject: parameters?.subject ?? dataFactory.variable!("objectNonClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}NonClass`
          : "objectNonClass",
      }).concat(),
      ...OrderedPropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectOrderedPropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}OrderedPropertiesClass`
          : "objectOrderedPropertiesClass",
      }).concat(),
      ...PartialClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectPartialClassUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialClassUnionMember1`
          : "objectPartialClassUnionMember1",
      }).concat(),
      ...PartialClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectPartialClassUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialClassUnionMember2`
          : "objectPartialClassUnionMember2",
      }).concat(),
      ...PartialInterfaceUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectPartialInterfaceUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialInterfaceUnionMember1`
          : "objectPartialInterfaceUnionMember1",
      }).concat(),
      ...PartialInterfaceUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectPartialInterfaceUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialInterfaceUnionMember2`
          : "objectPartialInterfaceUnionMember2",
      }).concat(),
      ...PropertyCardinalitiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectPropertyCardinalitiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PropertyCardinalitiesClass`
          : "objectPropertyCardinalitiesClass",
      }).concat(),
      ...PropertyVisibilitiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectPropertyVisibilitiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PropertyVisibilitiesClass`
          : "objectPropertyVisibilitiesClass",
      }).concat(),
      ...RecursiveClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectRecursiveClassUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}RecursiveClassUnionMember1`
          : "objectRecursiveClassUnionMember1",
      }).concat(),
      ...RecursiveClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectRecursiveClassUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}RecursiveClassUnionMember2`
          : "objectRecursiveClassUnionMember2",
      }).concat(),
      ...Sha256IriIdentifierClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectSha256IriIdentifierClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}Sha256IriIdentifierClass`
          : "objectSha256IriIdentifierClass",
      }).concat(),
      ...TermPropertiesClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectTermPropertiesClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}TermPropertiesClass`
          : "objectTermPropertiesClass",
      }).concat(),
      ...UnionDiscriminantsClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectUnionDiscriminantsClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}UnionDiscriminantsClass`
          : "objectUnionDiscriminantsClass",
      }).concat(),
      ...UuidV4IriIdentifierClass.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectUuidV4IriIdentifierClass"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}UuidV4IriIdentifierClass`
          : "objectUuidV4IriIdentifierClass",
      }).concat(),
      ...UuidV4IriIdentifierInterface.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("objectUuidV4IriIdentifierInterface"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}UuidV4IriIdentifierInterface`
          : "objectUuidV4IriIdentifierInterface",
      }).concat(),
      ...$DefaultPartial
        .$sparqlConstructTriples({
          subject:
            parameters?.subject ??
            dataFactory.variable!("objectDefaultPartial"),
          variablePrefix: parameters?.variablePrefix
            ? `${parameters.variablePrefix}DefaultPartial`
            : "objectDefaultPartial",
        })
        .concat(),
      ...$NamedDefaultPartial
        .$sparqlConstructTriples({
          subject:
            parameters?.subject ??
            dataFactory.variable!("objectNamedDefaultPartial"),
          variablePrefix: parameters?.variablePrefix
            ? `${parameters.variablePrefix}NamedDefaultPartial`
            : "objectNamedDefaultPartial",
        })
        .concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: $Object.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly $SparqlPattern[] {
    let patterns: $SparqlPattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("object");
    if (subject.termType === "Variable") {
      patterns = patterns.concat(
        $identifierSparqlWherePatterns({
          filter: parameters?.filter?.$identifier,
          ignoreRdfType: false,
          preferredLanguages: parameters?.preferredLanguages,
          propertyPatterns: [],
          schema: { kind: "Identifier" as const },
          valueVariable: subject,
          variablePrefix:
            subject.termType === "Variable" ? subject.value : "object",
        }),
      );
    }
    patterns.push({
      patterns: [
        {
          patterns: BlankNodeIdentifierClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.BlankNodeIdentifierClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectBlankNodeIdentifierClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}BlankNodeIdentifierClass`
              : "objectBlankNodeIdentifierClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: BlankNodeIdentifierInterface.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.BlankNodeIdentifierInterface,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectBlankNodeIdentifierInterface"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}BlankNodeIdentifierInterface`
              : "objectBlankNodeIdentifierInterface",
          }).concat(),
          type: "group",
        },
        {
          patterns: BlankNodeOrIriIdentifierClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.BlankNodeOrIriIdentifierClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectBlankNodeOrIriIdentifierClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}BlankNodeOrIriIdentifierClass`
              : "objectBlankNodeOrIriIdentifierClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: BlankNodeOrIriIdentifierInterface.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.BlankNodeOrIriIdentifierInterface,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectBlankNodeOrIriIdentifierInterface"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}BlankNodeOrIriIdentifierInterface`
              : "objectBlankNodeOrIriIdentifierInterface",
          }).concat(),
          type: "group",
        },
        {
          patterns: ClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectClassUnionMember1"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ClassUnionMember1`
              : "objectClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: ClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectClassUnionMember2"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ClassUnionMember2`
              : "objectClassUnionMember2",
          }).concat(),
          type: "group",
        },
        {
          patterns: ConcreteChildClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ConcreteChildClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectConcreteChildClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ConcreteChildClass`
              : "objectConcreteChildClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: ConcreteParentClassStatic.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ConcreteParentClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectConcreteParentClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ConcreteParentClass`
              : "objectConcreteParentClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: ConcreteChildInterface.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ConcreteChildInterface,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectConcreteChildInterface"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ConcreteChildInterface`
              : "objectConcreteChildInterface",
          }).concat(),
          type: "group",
        },
        {
          patterns: ConcreteParentInterfaceStatic.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ConcreteParentInterface,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectConcreteParentInterface"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ConcreteParentInterface`
              : "objectConcreteParentInterface",
          }).concat(),
          type: "group",
        },
        {
          patterns: BaseInterfaceWithoutPropertiesStatic.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.BaseInterfaceWithoutProperties,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectBaseInterfaceWithoutProperties"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}BaseInterfaceWithoutProperties`
              : "objectBaseInterfaceWithoutProperties",
          }).concat(),
          type: "group",
        },
        {
          patterns: BaseInterfaceWithPropertiesStatic.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.BaseInterfaceWithProperties,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectBaseInterfaceWithProperties"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}BaseInterfaceWithProperties`
              : "objectBaseInterfaceWithProperties",
          }).concat(),
          type: "group",
        },
        {
          patterns: ConvertibleTypePropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ConvertibleTypePropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectConvertibleTypePropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ConvertibleTypePropertiesClass`
              : "objectConvertibleTypePropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: DateUnionPropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.DateUnionPropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectDateUnionPropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}DateUnionPropertiesClass`
              : "objectDateUnionPropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: DefaultValuePropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.DefaultValuePropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectDefaultValuePropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}DefaultValuePropertiesClass`
              : "objectDefaultValuePropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: DirectRecursiveClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.DirectRecursiveClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectDirectRecursiveClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}DirectRecursiveClass`
              : "objectDirectRecursiveClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: ExplicitFromToRdfTypesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ExplicitFromToRdfTypesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectExplicitFromToRdfTypesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ExplicitFromToRdfTypesClass`
              : "objectExplicitFromToRdfTypesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: ExplicitRdfTypeClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ExplicitRdfTypeClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectExplicitRdfTypeClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ExplicitRdfTypeClass`
              : "objectExplicitRdfTypeClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: ExternClassPropertyClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ExternClassPropertyClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectExternClassPropertyClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ExternClassPropertyClass`
              : "objectExternClassPropertyClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: FlattenClassUnionMember3.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.FlattenClassUnionMember3,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectFlattenClassUnionMember3"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}FlattenClassUnionMember3`
              : "objectFlattenClassUnionMember3",
          }).concat(),
          type: "group",
        },
        {
          patterns: HasValuePropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.HasValuePropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectHasValuePropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}HasValuePropertiesClass`
              : "objectHasValuePropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: IdentifierOverride5Class.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.IdentifierOverride5Class,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectIdentifierOverride5Class"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}IdentifierOverride5Class`
              : "objectIdentifierOverride5Class",
          }).concat(),
          type: "group",
        },
        {
          patterns: IdentifierOverride4ClassStatic.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.IdentifierOverride4Class,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectIdentifierOverride4Class"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}IdentifierOverride4Class`
              : "objectIdentifierOverride4Class",
          }).concat(),
          type: "group",
        },
        {
          patterns: IdentifierOverride3ClassStatic.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.IdentifierOverride3Class,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectIdentifierOverride3Class"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}IdentifierOverride3Class`
              : "objectIdentifierOverride3Class",
          }).concat(),
          type: "group",
        },
        {
          patterns: InIdentifierClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.InIdentifierClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectInIdentifierClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}InIdentifierClass`
              : "objectInIdentifierClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: InPropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.InPropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectInPropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}InPropertiesClass`
              : "objectInPropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: IndirectRecursiveClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.IndirectRecursiveClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectIndirectRecursiveClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}IndirectRecursiveClass`
              : "objectIndirectRecursiveClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: IndirectRecursiveHelperClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.IndirectRecursiveHelperClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectIndirectRecursiveHelperClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}IndirectRecursiveHelperClass`
              : "objectIndirectRecursiveHelperClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: Interface.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.Interface,
            subject:
              parameters?.subject ?? dataFactory.variable!("objectInterface"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}Interface`
              : "objectInterface",
          }).concat(),
          type: "group",
        },
        {
          patterns: InterfaceUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.InterfaceUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectInterfaceUnionMember1"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}InterfaceUnionMember1`
              : "objectInterfaceUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: InterfaceUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.InterfaceUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectInterfaceUnionMember2"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}InterfaceUnionMember2`
              : "objectInterfaceUnionMember2",
          }).concat(),
          type: "group",
        },
        {
          patterns: IriIdentifierClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.IriIdentifierClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectIriIdentifierClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}IriIdentifierClass`
              : "objectIriIdentifierClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: IriIdentifierInterface.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.IriIdentifierInterface,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectIriIdentifierInterface"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}IriIdentifierInterface`
              : "objectIriIdentifierInterface",
          }).concat(),
          type: "group",
        },
        {
          patterns: JsPrimitiveUnionPropertyClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.JsPrimitiveUnionPropertyClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectJsPrimitiveUnionPropertyClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}JsPrimitiveUnionPropertyClass`
              : "objectJsPrimitiveUnionPropertyClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: LanguageInPropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LanguageInPropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectLanguageInPropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LanguageInPropertiesClass`
              : "objectLanguageInPropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns:
            LazilyResolvedBlankNodeOrIriIdentifierClass.$sparqlWherePatterns({
              filter:
                parameters?.filter?.on
                  ?.LazilyResolvedBlankNodeOrIriIdentifierClass,
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "objectLazilyResolvedBlankNodeOrIriIdentifierClass",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}LazilyResolvedBlankNodeOrIriIdentifierClass`
                : "objectLazilyResolvedBlankNodeOrIriIdentifierClass",
            }).concat(),
          type: "group",
        },
        {
          patterns:
            LazilyResolvedBlankNodeOrIriIdentifierInterface.$sparqlWherePatterns(
              {
                filter:
                  parameters?.filter?.on
                    ?.LazilyResolvedBlankNodeOrIriIdentifierInterface,
                subject:
                  parameters?.subject ??
                  dataFactory.variable!(
                    "objectLazilyResolvedBlankNodeOrIriIdentifierInterface",
                  ),
                variablePrefix: parameters?.variablePrefix
                  ? `${parameters.variablePrefix}LazilyResolvedBlankNodeOrIriIdentifierInterface`
                  : "objectLazilyResolvedBlankNodeOrIriIdentifierInterface",
              },
            ).concat(),
          type: "group",
        },
        {
          patterns: LazilyResolvedClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazilyResolvedClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectLazilyResolvedClassUnionMember1"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember1`
              : "objectLazilyResolvedClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: LazilyResolvedClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazilyResolvedClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectLazilyResolvedClassUnionMember2"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember2`
              : "objectLazilyResolvedClassUnionMember2",
          }).concat(),
          type: "group",
        },
        {
          patterns: LazilyResolvedInterfaceUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazilyResolvedInterfaceUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "objectLazilyResolvedInterfaceUnionMember1",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember1`
              : "objectLazilyResolvedInterfaceUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: LazilyResolvedInterfaceUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazilyResolvedInterfaceUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "objectLazilyResolvedInterfaceUnionMember2",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember2`
              : "objectLazilyResolvedInterfaceUnionMember2",
          }).concat(),
          type: "group",
        },
        {
          patterns: LazilyResolvedIriIdentifierClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazilyResolvedIriIdentifierClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectLazilyResolvedIriIdentifierClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazilyResolvedIriIdentifierClass`
              : "objectLazilyResolvedIriIdentifierClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: LazilyResolvedIriIdentifierInterface.$sparqlWherePatterns({
            filter:
              parameters?.filter?.on?.LazilyResolvedIriIdentifierInterface,
            subject:
              parameters?.subject ??
              dataFactory.variable!(
                "objectLazilyResolvedIriIdentifierInterface",
              ),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazilyResolvedIriIdentifierInterface`
              : "objectLazilyResolvedIriIdentifierInterface",
          }).concat(),
          type: "group",
        },
        {
          patterns: LazyPropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazyPropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectLazyPropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazyPropertiesClass`
              : "objectLazyPropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: PartialClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PartialClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectPartialClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PartialClass`
              : "objectPartialClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: LazyPropertiesInterface.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.LazyPropertiesInterface,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectLazyPropertiesInterface"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}LazyPropertiesInterface`
              : "objectLazyPropertiesInterface",
          }).concat(),
          type: "group",
        },
        {
          patterns: PartialInterface.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PartialInterface,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectPartialInterface"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PartialInterface`
              : "objectPartialInterface",
          }).concat(),
          type: "group",
        },
        {
          patterns: ListPropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.ListPropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectListPropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}ListPropertiesClass`
              : "objectListPropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: MutablePropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.MutablePropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectMutablePropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}MutablePropertiesClass`
              : "objectMutablePropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: NoRdfTypeClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.NoRdfTypeClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectNoRdfTypeClassUnionMember1"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}NoRdfTypeClassUnionMember1`
              : "objectNoRdfTypeClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: NoRdfTypeClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.NoRdfTypeClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectNoRdfTypeClassUnionMember2"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}NoRdfTypeClassUnionMember2`
              : "objectNoRdfTypeClassUnionMember2",
          }).concat(),
          type: "group",
        },
        {
          patterns: NonClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.NonClass,
            subject:
              parameters?.subject ?? dataFactory.variable!("objectNonClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}NonClass`
              : "objectNonClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: OrderedPropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.OrderedPropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectOrderedPropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}OrderedPropertiesClass`
              : "objectOrderedPropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: PartialClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PartialClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectPartialClassUnionMember1"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PartialClassUnionMember1`
              : "objectPartialClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: PartialClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PartialClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectPartialClassUnionMember2"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PartialClassUnionMember2`
              : "objectPartialClassUnionMember2",
          }).concat(),
          type: "group",
        },
        {
          patterns: PartialInterfaceUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PartialInterfaceUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectPartialInterfaceUnionMember1"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PartialInterfaceUnionMember1`
              : "objectPartialInterfaceUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: PartialInterfaceUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PartialInterfaceUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectPartialInterfaceUnionMember2"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PartialInterfaceUnionMember2`
              : "objectPartialInterfaceUnionMember2",
          }).concat(),
          type: "group",
        },
        {
          patterns: PropertyCardinalitiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PropertyCardinalitiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectPropertyCardinalitiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PropertyCardinalitiesClass`
              : "objectPropertyCardinalitiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: PropertyVisibilitiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.PropertyVisibilitiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectPropertyVisibilitiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}PropertyVisibilitiesClass`
              : "objectPropertyVisibilitiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: RecursiveClassUnionMember1.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.RecursiveClassUnionMember1,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectRecursiveClassUnionMember1"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}RecursiveClassUnionMember1`
              : "objectRecursiveClassUnionMember1",
          }).concat(),
          type: "group",
        },
        {
          patterns: RecursiveClassUnionMember2.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.RecursiveClassUnionMember2,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectRecursiveClassUnionMember2"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}RecursiveClassUnionMember2`
              : "objectRecursiveClassUnionMember2",
          }).concat(),
          type: "group",
        },
        {
          patterns: Sha256IriIdentifierClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.Sha256IriIdentifierClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectSha256IriIdentifierClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}Sha256IriIdentifierClass`
              : "objectSha256IriIdentifierClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: TermPropertiesClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.TermPropertiesClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectTermPropertiesClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}TermPropertiesClass`
              : "objectTermPropertiesClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: UnionDiscriminantsClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.UnionDiscriminantsClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectUnionDiscriminantsClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}UnionDiscriminantsClass`
              : "objectUnionDiscriminantsClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: UuidV4IriIdentifierClass.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.UuidV4IriIdentifierClass,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectUuidV4IriIdentifierClass"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}UuidV4IriIdentifierClass`
              : "objectUuidV4IriIdentifierClass",
          }).concat(),
          type: "group",
        },
        {
          patterns: UuidV4IriIdentifierInterface.$sparqlWherePatterns({
            filter: parameters?.filter?.on?.UuidV4IriIdentifierInterface,
            subject:
              parameters?.subject ??
              dataFactory.variable!("objectUuidV4IriIdentifierInterface"),
            variablePrefix: parameters?.variablePrefix
              ? `${parameters.variablePrefix}UuidV4IriIdentifierInterface`
              : "objectUuidV4IriIdentifierInterface",
          }).concat(),
          type: "group",
        },
        {
          patterns: $DefaultPartial
            .$sparqlWherePatterns({
              filter: parameters?.filter?.on?.$DefaultPartial,
              subject:
                parameters?.subject ??
                dataFactory.variable!("objectDefaultPartial"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}DefaultPartial`
                : "objectDefaultPartial",
            })
            .concat(),
          type: "group",
        },
        {
          patterns: $NamedDefaultPartial
            .$sparqlWherePatterns({
              filter: parameters?.filter?.on?.$NamedDefaultPartial,
              subject:
                parameters?.subject ??
                dataFactory.variable!("objectNamedDefaultPartial"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}NamedDefaultPartial`
                : "objectNamedDefaultPartial",
            })
            .concat(),
          type: "group",
        },
      ],
      type: "union",
    });
    return patterns;
  }
}
export interface $ObjectSet {
  baseInterfaceWithoutProperties(
    identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier,
  ): Promise<Either<Error, BaseInterfaceWithoutProperties>>;

  baseInterfaceWithoutPropertiesIdentifiers(
    query?: $ObjectSet.Query<
      BaseInterfaceWithoutPropertiesStatic.$Filter,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >,
  ): Promise<
    Either<Error, readonly BaseInterfaceWithoutPropertiesStatic.$Identifier[]>
  >;

  baseInterfaceWithoutPropertieses(
    query?: $ObjectSet.Query<
      BaseInterfaceWithoutPropertiesStatic.$Filter,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >,
  ): Promise<Either<Error, readonly BaseInterfaceWithoutProperties[]>>;

  baseInterfaceWithoutPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<
        BaseInterfaceWithoutPropertiesStatic.$Filter,
        BaseInterfaceWithoutPropertiesStatic.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  baseInterfaceWithProperties(
    identifier: BaseInterfaceWithPropertiesStatic.$Identifier,
  ): Promise<Either<Error, BaseInterfaceWithProperties>>;

  baseInterfaceWithPropertiesIdentifiers(
    query?: $ObjectSet.Query<
      BaseInterfaceWithPropertiesStatic.$Filter,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >,
  ): Promise<
    Either<Error, readonly BaseInterfaceWithPropertiesStatic.$Identifier[]>
  >;

  baseInterfaceWithPropertieses(
    query?: $ObjectSet.Query<
      BaseInterfaceWithPropertiesStatic.$Filter,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >,
  ): Promise<Either<Error, readonly BaseInterfaceWithProperties[]>>;

  baseInterfaceWithPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<
        BaseInterfaceWithPropertiesStatic.$Filter,
        BaseInterfaceWithPropertiesStatic.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  blankNodeIdentifierClass(
    identifier: BlankNodeIdentifierClass.$Identifier,
  ): Promise<Either<Error, BlankNodeIdentifierClass>>;

  blankNodeIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<
      BlankNodeIdentifierClass.$Filter,
      BlankNodeIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly BlankNodeIdentifierClass.$Identifier[]>>;

  blankNodeIdentifierClasses(
    query?: $ObjectSet.Query<
      BlankNodeIdentifierClass.$Filter,
      BlankNodeIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly BlankNodeIdentifierClass[]>>;

  blankNodeIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        BlankNodeIdentifierClass.$Filter,
        BlankNodeIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  blankNodeIdentifierInterface(
    identifier: BlankNodeIdentifierInterface.$Identifier,
  ): Promise<Either<Error, BlankNodeIdentifierInterface>>;

  blankNodeIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<
      BlankNodeIdentifierInterface.$Filter,
      BlankNodeIdentifierInterface.$Identifier
    >,
  ): Promise<
    Either<Error, readonly BlankNodeIdentifierInterface.$Identifier[]>
  >;

  blankNodeIdentifierInterfaces(
    query?: $ObjectSet.Query<
      BlankNodeIdentifierInterface.$Filter,
      BlankNodeIdentifierInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly BlankNodeIdentifierInterface[]>>;

  blankNodeIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<
        BlankNodeIdentifierInterface.$Filter,
        BlankNodeIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  blankNodeOrIriIdentifierClass(
    identifier: BlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<Either<Error, BlankNodeOrIriIdentifierClass>>;

  blankNodeOrIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<
      BlankNodeOrIriIdentifierClass.$Filter,
      BlankNodeOrIriIdentifierClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly BlankNodeOrIriIdentifierClass.$Identifier[]>
  >;

  blankNodeOrIriIdentifierClasses(
    query?: $ObjectSet.Query<
      BlankNodeOrIriIdentifierClass.$Filter,
      BlankNodeOrIriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly BlankNodeOrIriIdentifierClass[]>>;

  blankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        BlankNodeOrIriIdentifierClass.$Filter,
        BlankNodeOrIriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  blankNodeOrIriIdentifierInterface(
    identifier: BlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<Either<Error, BlankNodeOrIriIdentifierInterface>>;

  blankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<
      BlankNodeOrIriIdentifierInterface.$Filter,
      BlankNodeOrIriIdentifierInterface.$Identifier
    >,
  ): Promise<
    Either<Error, readonly BlankNodeOrIriIdentifierInterface.$Identifier[]>
  >;

  blankNodeOrIriIdentifierInterfaces(
    query?: $ObjectSet.Query<
      BlankNodeOrIriIdentifierInterface.$Filter,
      BlankNodeOrIriIdentifierInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly BlankNodeOrIriIdentifierInterface[]>>;

  blankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<
        BlankNodeOrIriIdentifierInterface.$Filter,
        BlankNodeOrIriIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  classUnionMember1(
    identifier: ClassUnionMember1.$Identifier,
  ): Promise<Either<Error, ClassUnionMember1>>;

  classUnionMember1Identifiers(
    query?: $ObjectSet.Query<
      ClassUnionMember1.$Filter,
      ClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly ClassUnionMember1.$Identifier[]>>;

  classUnionMember1s(
    query?: $ObjectSet.Query<
      ClassUnionMember1.$Filter,
      ClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly ClassUnionMember1[]>>;

  classUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<
        ClassUnionMember1.$Filter,
        ClassUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  classUnionMember2(
    identifier: ClassUnionMember2.$Identifier,
  ): Promise<Either<Error, ClassUnionMember2>>;

  classUnionMember2Identifiers(
    query?: $ObjectSet.Query<
      ClassUnionMember2.$Filter,
      ClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly ClassUnionMember2.$Identifier[]>>;

  classUnionMember2s(
    query?: $ObjectSet.Query<
      ClassUnionMember2.$Filter,
      ClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly ClassUnionMember2[]>>;

  classUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<
        ClassUnionMember2.$Filter,
        ClassUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  concreteChildClass(
    identifier: ConcreteChildClass.$Identifier,
  ): Promise<Either<Error, ConcreteChildClass>>;

  concreteChildClassIdentifiers(
    query?: $ObjectSet.Query<
      ConcreteChildClass.$Filter,
      ConcreteChildClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ConcreteChildClass.$Identifier[]>>;

  concreteChildClasses(
    query?: $ObjectSet.Query<
      ConcreteChildClass.$Filter,
      ConcreteChildClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ConcreteChildClass[]>>;

  concreteChildClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        ConcreteChildClass.$Filter,
        ConcreteChildClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  concreteChildInterface(
    identifier: ConcreteChildInterface.$Identifier,
  ): Promise<Either<Error, ConcreteChildInterface>>;

  concreteChildInterfaceIdentifiers(
    query?: $ObjectSet.Query<
      ConcreteChildInterface.$Filter,
      ConcreteChildInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly ConcreteChildInterface.$Identifier[]>>;

  concreteChildInterfaces(
    query?: $ObjectSet.Query<
      ConcreteChildInterface.$Filter,
      ConcreteChildInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly ConcreteChildInterface[]>>;

  concreteChildInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<
        ConcreteChildInterface.$Filter,
        ConcreteChildInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  concreteParentClass(
    identifier: ConcreteParentClassStatic.$Identifier,
  ): Promise<Either<Error, ConcreteParentClass>>;

  concreteParentClassIdentifiers(
    query?: $ObjectSet.Query<
      ConcreteParentClassStatic.$Filter,
      ConcreteParentClassStatic.$Identifier
    >,
  ): Promise<Either<Error, readonly ConcreteParentClassStatic.$Identifier[]>>;

  concreteParentClasses(
    query?: $ObjectSet.Query<
      ConcreteParentClassStatic.$Filter,
      ConcreteParentClassStatic.$Identifier
    >,
  ): Promise<Either<Error, readonly ConcreteParentClass[]>>;

  concreteParentClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        ConcreteParentClassStatic.$Filter,
        ConcreteParentClassStatic.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  concreteParentInterface(
    identifier: ConcreteParentInterfaceStatic.$Identifier,
  ): Promise<Either<Error, ConcreteParentInterface>>;

  concreteParentInterfaceIdentifiers(
    query?: $ObjectSet.Query<
      ConcreteParentInterfaceStatic.$Filter,
      ConcreteParentInterfaceStatic.$Identifier
    >,
  ): Promise<
    Either<Error, readonly ConcreteParentInterfaceStatic.$Identifier[]>
  >;

  concreteParentInterfaces(
    query?: $ObjectSet.Query<
      ConcreteParentInterfaceStatic.$Filter,
      ConcreteParentInterfaceStatic.$Identifier
    >,
  ): Promise<Either<Error, readonly ConcreteParentInterface[]>>;

  concreteParentInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<
        ConcreteParentInterfaceStatic.$Filter,
        ConcreteParentInterfaceStatic.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  convertibleTypePropertiesClass(
    identifier: ConvertibleTypePropertiesClass.$Identifier,
  ): Promise<Either<Error, ConvertibleTypePropertiesClass>>;

  convertibleTypePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      ConvertibleTypePropertiesClass.$Filter,
      ConvertibleTypePropertiesClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly ConvertibleTypePropertiesClass.$Identifier[]>
  >;

  convertibleTypePropertiesClasses(
    query?: $ObjectSet.Query<
      ConvertibleTypePropertiesClass.$Filter,
      ConvertibleTypePropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ConvertibleTypePropertiesClass[]>>;

  convertibleTypePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        ConvertibleTypePropertiesClass.$Filter,
        ConvertibleTypePropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  dateUnionPropertiesClass(
    identifier: DateUnionPropertiesClass.$Identifier,
  ): Promise<Either<Error, DateUnionPropertiesClass>>;

  dateUnionPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      DateUnionPropertiesClass.$Filter,
      DateUnionPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly DateUnionPropertiesClass.$Identifier[]>>;

  dateUnionPropertiesClasses(
    query?: $ObjectSet.Query<
      DateUnionPropertiesClass.$Filter,
      DateUnionPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly DateUnionPropertiesClass[]>>;

  dateUnionPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        DateUnionPropertiesClass.$Filter,
        DateUnionPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  defaultValuePropertiesClass(
    identifier: DefaultValuePropertiesClass.$Identifier,
  ): Promise<Either<Error, DefaultValuePropertiesClass>>;

  defaultValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      DefaultValuePropertiesClass.$Filter,
      DefaultValuePropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly DefaultValuePropertiesClass.$Identifier[]>>;

  defaultValuePropertiesClasses(
    query?: $ObjectSet.Query<
      DefaultValuePropertiesClass.$Filter,
      DefaultValuePropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly DefaultValuePropertiesClass[]>>;

  defaultValuePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        DefaultValuePropertiesClass.$Filter,
        DefaultValuePropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  directRecursiveClass(
    identifier: DirectRecursiveClass.$Identifier,
  ): Promise<Either<Error, DirectRecursiveClass>>;

  directRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<
      DirectRecursiveClass.$Filter,
      DirectRecursiveClass.$Identifier
    >,
  ): Promise<Either<Error, readonly DirectRecursiveClass.$Identifier[]>>;

  directRecursiveClasses(
    query?: $ObjectSet.Query<
      DirectRecursiveClass.$Filter,
      DirectRecursiveClass.$Identifier
    >,
  ): Promise<Either<Error, readonly DirectRecursiveClass[]>>;

  directRecursiveClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        DirectRecursiveClass.$Filter,
        DirectRecursiveClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  explicitFromToRdfTypesClass(
    identifier: ExplicitFromToRdfTypesClass.$Identifier,
  ): Promise<Either<Error, ExplicitFromToRdfTypesClass>>;

  explicitFromToRdfTypesClassIdentifiers(
    query?: $ObjectSet.Query<
      ExplicitFromToRdfTypesClass.$Filter,
      ExplicitFromToRdfTypesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ExplicitFromToRdfTypesClass.$Identifier[]>>;

  explicitFromToRdfTypesClasses(
    query?: $ObjectSet.Query<
      ExplicitFromToRdfTypesClass.$Filter,
      ExplicitFromToRdfTypesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ExplicitFromToRdfTypesClass[]>>;

  explicitFromToRdfTypesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        ExplicitFromToRdfTypesClass.$Filter,
        ExplicitFromToRdfTypesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  explicitRdfTypeClass(
    identifier: ExplicitRdfTypeClass.$Identifier,
  ): Promise<Either<Error, ExplicitRdfTypeClass>>;

  explicitRdfTypeClassIdentifiers(
    query?: $ObjectSet.Query<
      ExplicitRdfTypeClass.$Filter,
      ExplicitRdfTypeClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ExplicitRdfTypeClass.$Identifier[]>>;

  explicitRdfTypeClasses(
    query?: $ObjectSet.Query<
      ExplicitRdfTypeClass.$Filter,
      ExplicitRdfTypeClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ExplicitRdfTypeClass[]>>;

  explicitRdfTypeClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        ExplicitRdfTypeClass.$Filter,
        ExplicitRdfTypeClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  externClassPropertyClass(
    identifier: ExternClassPropertyClass.$Identifier,
  ): Promise<Either<Error, ExternClassPropertyClass>>;

  externClassPropertyClassIdentifiers(
    query?: $ObjectSet.Query<
      ExternClassPropertyClass.$Filter,
      ExternClassPropertyClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ExternClassPropertyClass.$Identifier[]>>;

  externClassPropertyClasses(
    query?: $ObjectSet.Query<
      ExternClassPropertyClass.$Filter,
      ExternClassPropertyClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ExternClassPropertyClass[]>>;

  externClassPropertyClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        ExternClassPropertyClass.$Filter,
        ExternClassPropertyClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  flattenClassUnionMember3(
    identifier: FlattenClassUnionMember3.$Identifier,
  ): Promise<Either<Error, FlattenClassUnionMember3>>;

  flattenClassUnionMember3Identifiers(
    query?: $ObjectSet.Query<
      FlattenClassUnionMember3.$Filter,
      FlattenClassUnionMember3.$Identifier
    >,
  ): Promise<Either<Error, readonly FlattenClassUnionMember3.$Identifier[]>>;

  flattenClassUnionMember3s(
    query?: $ObjectSet.Query<
      FlattenClassUnionMember3.$Filter,
      FlattenClassUnionMember3.$Identifier
    >,
  ): Promise<Either<Error, readonly FlattenClassUnionMember3[]>>;

  flattenClassUnionMember3sCount(
    query?: Pick<
      $ObjectSet.Query<
        FlattenClassUnionMember3.$Filter,
        FlattenClassUnionMember3.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  hasValuePropertiesClass(
    identifier: HasValuePropertiesClass.$Identifier,
  ): Promise<Either<Error, HasValuePropertiesClass>>;

  hasValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      HasValuePropertiesClass.$Filter,
      HasValuePropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly HasValuePropertiesClass.$Identifier[]>>;

  hasValuePropertiesClasses(
    query?: $ObjectSet.Query<
      HasValuePropertiesClass.$Filter,
      HasValuePropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly HasValuePropertiesClass[]>>;

  hasValuePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        HasValuePropertiesClass.$Filter,
        HasValuePropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  identifierOverride3Class(
    identifier: IdentifierOverride3ClassStatic.$Identifier,
  ): Promise<Either<Error, IdentifierOverride3Class>>;

  identifierOverride3ClassIdentifiers(
    query?: $ObjectSet.Query<
      IdentifierOverride3ClassStatic.$Filter,
      IdentifierOverride3ClassStatic.$Identifier
    >,
  ): Promise<
    Either<Error, readonly IdentifierOverride3ClassStatic.$Identifier[]>
  >;

  identifierOverride3Classes(
    query?: $ObjectSet.Query<
      IdentifierOverride3ClassStatic.$Filter,
      IdentifierOverride3ClassStatic.$Identifier
    >,
  ): Promise<Either<Error, readonly IdentifierOverride3Class[]>>;

  identifierOverride3ClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        IdentifierOverride3ClassStatic.$Filter,
        IdentifierOverride3ClassStatic.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  identifierOverride4Class(
    identifier: IdentifierOverride4ClassStatic.$Identifier,
  ): Promise<Either<Error, IdentifierOverride4Class>>;

  identifierOverride4ClassIdentifiers(
    query?: $ObjectSet.Query<
      IdentifierOverride4ClassStatic.$Filter,
      IdentifierOverride4ClassStatic.$Identifier
    >,
  ): Promise<
    Either<Error, readonly IdentifierOverride4ClassStatic.$Identifier[]>
  >;

  identifierOverride4Classes(
    query?: $ObjectSet.Query<
      IdentifierOverride4ClassStatic.$Filter,
      IdentifierOverride4ClassStatic.$Identifier
    >,
  ): Promise<Either<Error, readonly IdentifierOverride4Class[]>>;

  identifierOverride4ClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        IdentifierOverride4ClassStatic.$Filter,
        IdentifierOverride4ClassStatic.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  identifierOverride5Class(
    identifier: IdentifierOverride5Class.$Identifier,
  ): Promise<Either<Error, IdentifierOverride5Class>>;

  identifierOverride5ClassIdentifiers(
    query?: $ObjectSet.Query<
      IdentifierOverride5Class.$Filter,
      IdentifierOverride5Class.$Identifier
    >,
  ): Promise<Either<Error, readonly IdentifierOverride5Class.$Identifier[]>>;

  identifierOverride5Classes(
    query?: $ObjectSet.Query<
      IdentifierOverride5Class.$Filter,
      IdentifierOverride5Class.$Identifier
    >,
  ): Promise<Either<Error, readonly IdentifierOverride5Class[]>>;

  identifierOverride5ClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        IdentifierOverride5Class.$Filter,
        IdentifierOverride5Class.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  indirectRecursiveClass(
    identifier: IndirectRecursiveClass.$Identifier,
  ): Promise<Either<Error, IndirectRecursiveClass>>;

  indirectRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<
      IndirectRecursiveClass.$Filter,
      IndirectRecursiveClass.$Identifier
    >,
  ): Promise<Either<Error, readonly IndirectRecursiveClass.$Identifier[]>>;

  indirectRecursiveClasses(
    query?: $ObjectSet.Query<
      IndirectRecursiveClass.$Filter,
      IndirectRecursiveClass.$Identifier
    >,
  ): Promise<Either<Error, readonly IndirectRecursiveClass[]>>;

  indirectRecursiveClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        IndirectRecursiveClass.$Filter,
        IndirectRecursiveClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  indirectRecursiveHelperClass(
    identifier: IndirectRecursiveHelperClass.$Identifier,
  ): Promise<Either<Error, IndirectRecursiveHelperClass>>;

  indirectRecursiveHelperClassIdentifiers(
    query?: $ObjectSet.Query<
      IndirectRecursiveHelperClass.$Filter,
      IndirectRecursiveHelperClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly IndirectRecursiveHelperClass.$Identifier[]>
  >;

  indirectRecursiveHelperClasses(
    query?: $ObjectSet.Query<
      IndirectRecursiveHelperClass.$Filter,
      IndirectRecursiveHelperClass.$Identifier
    >,
  ): Promise<Either<Error, readonly IndirectRecursiveHelperClass[]>>;

  indirectRecursiveHelperClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        IndirectRecursiveHelperClass.$Filter,
        IndirectRecursiveHelperClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  inIdentifierClass(
    identifier: InIdentifierClass.$Identifier,
  ): Promise<Either<Error, InIdentifierClass>>;

  inIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<
      InIdentifierClass.$Filter,
      InIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly InIdentifierClass.$Identifier[]>>;

  inIdentifierClasses(
    query?: $ObjectSet.Query<
      InIdentifierClass.$Filter,
      InIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly InIdentifierClass[]>>;

  inIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        InIdentifierClass.$Filter,
        InIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  inPropertiesClass(
    identifier: InPropertiesClass.$Identifier,
  ): Promise<Either<Error, InPropertiesClass>>;

  inPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      InPropertiesClass.$Filter,
      InPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly InPropertiesClass.$Identifier[]>>;

  inPropertiesClasses(
    query?: $ObjectSet.Query<
      InPropertiesClass.$Filter,
      InPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly InPropertiesClass[]>>;

  inPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        InPropertiesClass.$Filter,
        InPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  interface(
    identifier: Interface.$Identifier,
  ): Promise<Either<Error, Interface>>;

  interfaceIdentifiers(
    query?: $ObjectSet.Query<Interface.$Filter, Interface.$Identifier>,
  ): Promise<Either<Error, readonly Interface.$Identifier[]>>;

  interfaces(
    query?: $ObjectSet.Query<Interface.$Filter, Interface.$Identifier>,
  ): Promise<Either<Error, readonly Interface[]>>;

  interfacesCount(
    query?: Pick<
      $ObjectSet.Query<Interface.$Filter, Interface.$Identifier>,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  interfaceUnionMember1(
    identifier: InterfaceUnionMember1.$Identifier,
  ): Promise<Either<Error, InterfaceUnionMember1>>;

  interfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<
      InterfaceUnionMember1.$Filter,
      InterfaceUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly InterfaceUnionMember1.$Identifier[]>>;

  interfaceUnionMember1s(
    query?: $ObjectSet.Query<
      InterfaceUnionMember1.$Filter,
      InterfaceUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly InterfaceUnionMember1[]>>;

  interfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<
        InterfaceUnionMember1.$Filter,
        InterfaceUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  interfaceUnionMember2(
    identifier: InterfaceUnionMember2.$Identifier,
  ): Promise<Either<Error, InterfaceUnionMember2>>;

  interfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<
      InterfaceUnionMember2.$Filter,
      InterfaceUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly InterfaceUnionMember2.$Identifier[]>>;

  interfaceUnionMember2s(
    query?: $ObjectSet.Query<
      InterfaceUnionMember2.$Filter,
      InterfaceUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly InterfaceUnionMember2[]>>;

  interfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<
        InterfaceUnionMember2.$Filter,
        InterfaceUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  iriIdentifierClass(
    identifier: IriIdentifierClass.$Identifier,
  ): Promise<Either<Error, IriIdentifierClass>>;

  iriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<
      IriIdentifierClass.$Filter,
      IriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly IriIdentifierClass.$Identifier[]>>;

  iriIdentifierClasses(
    query?: $ObjectSet.Query<
      IriIdentifierClass.$Filter,
      IriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly IriIdentifierClass[]>>;

  iriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        IriIdentifierClass.$Filter,
        IriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  iriIdentifierInterface(
    identifier: IriIdentifierInterface.$Identifier,
  ): Promise<Either<Error, IriIdentifierInterface>>;

  iriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<
      IriIdentifierInterface.$Filter,
      IriIdentifierInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly IriIdentifierInterface.$Identifier[]>>;

  iriIdentifierInterfaces(
    query?: $ObjectSet.Query<
      IriIdentifierInterface.$Filter,
      IriIdentifierInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly IriIdentifierInterface[]>>;

  iriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<
        IriIdentifierInterface.$Filter,
        IriIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  jsPrimitiveUnionPropertyClass(
    identifier: JsPrimitiveUnionPropertyClass.$Identifier,
  ): Promise<Either<Error, JsPrimitiveUnionPropertyClass>>;

  jsPrimitiveUnionPropertyClassIdentifiers(
    query?: $ObjectSet.Query<
      JsPrimitiveUnionPropertyClass.$Filter,
      JsPrimitiveUnionPropertyClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly JsPrimitiveUnionPropertyClass.$Identifier[]>
  >;

  jsPrimitiveUnionPropertyClasses(
    query?: $ObjectSet.Query<
      JsPrimitiveUnionPropertyClass.$Filter,
      JsPrimitiveUnionPropertyClass.$Identifier
    >,
  ): Promise<Either<Error, readonly JsPrimitiveUnionPropertyClass[]>>;

  jsPrimitiveUnionPropertyClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        JsPrimitiveUnionPropertyClass.$Filter,
        JsPrimitiveUnionPropertyClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  languageInPropertiesClass(
    identifier: LanguageInPropertiesClass.$Identifier,
  ): Promise<Either<Error, LanguageInPropertiesClass>>;

  languageInPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      LanguageInPropertiesClass.$Filter,
      LanguageInPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly LanguageInPropertiesClass.$Identifier[]>>;

  languageInPropertiesClasses(
    query?: $ObjectSet.Query<
      LanguageInPropertiesClass.$Filter,
      LanguageInPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly LanguageInPropertiesClass[]>>;

  languageInPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        LanguageInPropertiesClass.$Filter,
        LanguageInPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  lazilyResolvedBlankNodeOrIriIdentifierClass(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<Either<Error, LazilyResolvedBlankNodeOrIriIdentifierClass>>;

  lazilyResolvedBlankNodeOrIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
    >,
  ): Promise<
    Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier[]
    >
  >;

  lazilyResolvedBlankNodeOrIriIdentifierClasses(
    query?: $ObjectSet.Query<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedBlankNodeOrIriIdentifierClass[]>
  >;

  lazilyResolvedBlankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  lazilyResolvedBlankNodeOrIriIdentifierInterface(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<Either<Error, LazilyResolvedBlankNodeOrIriIdentifierInterface>>;

  lazilyResolvedBlankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
    >,
  ): Promise<
    Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier[]
    >
  >;

  lazilyResolvedBlankNodeOrIriIdentifierInterfaces(
    query?: $ObjectSet.Query<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[]>
  >;

  lazilyResolvedBlankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  lazilyResolvedClassUnionMember1(
    identifier: LazilyResolvedClassUnionMember1.$Identifier,
  ): Promise<Either<Error, LazilyResolvedClassUnionMember1>>;

  lazilyResolvedClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<
      LazilyResolvedClassUnionMember1.$Filter,
      LazilyResolvedClassUnionMember1.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedClassUnionMember1.$Identifier[]>
  >;

  lazilyResolvedClassUnionMember1s(
    query?: $ObjectSet.Query<
      LazilyResolvedClassUnionMember1.$Filter,
      LazilyResolvedClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedClassUnionMember1[]>>;

  lazilyResolvedClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedClassUnionMember1.$Filter,
        LazilyResolvedClassUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  lazilyResolvedClassUnionMember2(
    identifier: LazilyResolvedClassUnionMember2.$Identifier,
  ): Promise<Either<Error, LazilyResolvedClassUnionMember2>>;

  lazilyResolvedClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<
      LazilyResolvedClassUnionMember2.$Filter,
      LazilyResolvedClassUnionMember2.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedClassUnionMember2.$Identifier[]>
  >;

  lazilyResolvedClassUnionMember2s(
    query?: $ObjectSet.Query<
      LazilyResolvedClassUnionMember2.$Filter,
      LazilyResolvedClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedClassUnionMember2[]>>;

  lazilyResolvedClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedClassUnionMember2.$Filter,
        LazilyResolvedClassUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  lazilyResolvedInterfaceUnionMember1(
    identifier: LazilyResolvedInterfaceUnionMember1.$Identifier,
  ): Promise<Either<Error, LazilyResolvedInterfaceUnionMember1>>;

  lazilyResolvedInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<
      LazilyResolvedInterfaceUnionMember1.$Filter,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedInterfaceUnionMember1.$Identifier[]>
  >;

  lazilyResolvedInterfaceUnionMember1s(
    query?: $ObjectSet.Query<
      LazilyResolvedInterfaceUnionMember1.$Filter,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedInterfaceUnionMember1[]>>;

  lazilyResolvedInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedInterfaceUnionMember1.$Filter,
        LazilyResolvedInterfaceUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  lazilyResolvedInterfaceUnionMember2(
    identifier: LazilyResolvedInterfaceUnionMember2.$Identifier,
  ): Promise<Either<Error, LazilyResolvedInterfaceUnionMember2>>;

  lazilyResolvedInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<
      LazilyResolvedInterfaceUnionMember2.$Filter,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedInterfaceUnionMember2.$Identifier[]>
  >;

  lazilyResolvedInterfaceUnionMember2s(
    query?: $ObjectSet.Query<
      LazilyResolvedInterfaceUnionMember2.$Filter,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedInterfaceUnionMember2[]>>;

  lazilyResolvedInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedInterfaceUnionMember2.$Filter,
        LazilyResolvedInterfaceUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  lazilyResolvedIriIdentifierClass(
    identifier: LazilyResolvedIriIdentifierClass.$Identifier,
  ): Promise<Either<Error, LazilyResolvedIriIdentifierClass>>;

  lazilyResolvedIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<
      LazilyResolvedIriIdentifierClass.$Filter,
      LazilyResolvedIriIdentifierClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedIriIdentifierClass.$Identifier[]>
  >;

  lazilyResolvedIriIdentifierClasses(
    query?: $ObjectSet.Query<
      LazilyResolvedIriIdentifierClass.$Filter,
      LazilyResolvedIriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedIriIdentifierClass[]>>;

  lazilyResolvedIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedIriIdentifierClass.$Filter,
        LazilyResolvedIriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  lazilyResolvedIriIdentifierInterface(
    identifier: LazilyResolvedIriIdentifierInterface.$Identifier,
  ): Promise<Either<Error, LazilyResolvedIriIdentifierInterface>>;

  lazilyResolvedIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<
      LazilyResolvedIriIdentifierInterface.$Filter,
      LazilyResolvedIriIdentifierInterface.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedIriIdentifierInterface.$Identifier[]>
  >;

  lazilyResolvedIriIdentifierInterfaces(
    query?: $ObjectSet.Query<
      LazilyResolvedIriIdentifierInterface.$Filter,
      LazilyResolvedIriIdentifierInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedIriIdentifierInterface[]>>;

  lazilyResolvedIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedIriIdentifierInterface.$Filter,
        LazilyResolvedIriIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  lazyPropertiesClass(
    identifier: LazyPropertiesClass.$Identifier,
  ): Promise<Either<Error, LazyPropertiesClass>>;

  lazyPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      LazyPropertiesClass.$Filter,
      LazyPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly LazyPropertiesClass.$Identifier[]>>;

  lazyPropertiesClasses(
    query?: $ObjectSet.Query<
      LazyPropertiesClass.$Filter,
      LazyPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly LazyPropertiesClass[]>>;

  lazyPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        LazyPropertiesClass.$Filter,
        LazyPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  lazyPropertiesInterface(
    identifier: LazyPropertiesInterface.$Identifier,
  ): Promise<Either<Error, LazyPropertiesInterface>>;

  lazyPropertiesInterfaceIdentifiers(
    query?: $ObjectSet.Query<
      LazyPropertiesInterface.$Filter,
      LazyPropertiesInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly LazyPropertiesInterface.$Identifier[]>>;

  lazyPropertiesInterfaces(
    query?: $ObjectSet.Query<
      LazyPropertiesInterface.$Filter,
      LazyPropertiesInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly LazyPropertiesInterface[]>>;

  lazyPropertiesInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<
        LazyPropertiesInterface.$Filter,
        LazyPropertiesInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  listPropertiesClass(
    identifier: ListPropertiesClass.$Identifier,
  ): Promise<Either<Error, ListPropertiesClass>>;

  listPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      ListPropertiesClass.$Filter,
      ListPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ListPropertiesClass.$Identifier[]>>;

  listPropertiesClasses(
    query?: $ObjectSet.Query<
      ListPropertiesClass.$Filter,
      ListPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ListPropertiesClass[]>>;

  listPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        ListPropertiesClass.$Filter,
        ListPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  mutablePropertiesClass(
    identifier: MutablePropertiesClass.$Identifier,
  ): Promise<Either<Error, MutablePropertiesClass>>;

  mutablePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      MutablePropertiesClass.$Filter,
      MutablePropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly MutablePropertiesClass.$Identifier[]>>;

  mutablePropertiesClasses(
    query?: $ObjectSet.Query<
      MutablePropertiesClass.$Filter,
      MutablePropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly MutablePropertiesClass[]>>;

  mutablePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        MutablePropertiesClass.$Filter,
        MutablePropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  nonClass(identifier: NonClass.$Identifier): Promise<Either<Error, NonClass>>;

  nonClassIdentifiers(
    query?: $ObjectSet.Query<NonClass.$Filter, NonClass.$Identifier>,
  ): Promise<Either<Error, readonly NonClass.$Identifier[]>>;

  nonClasses(
    query?: $ObjectSet.Query<NonClass.$Filter, NonClass.$Identifier>,
  ): Promise<Either<Error, readonly NonClass[]>>;

  nonClassesCount(
    query?: Pick<
      $ObjectSet.Query<NonClass.$Filter, NonClass.$Identifier>,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  noRdfTypeClassUnionMember1(
    identifier: NoRdfTypeClassUnionMember1.$Identifier,
  ): Promise<Either<Error, NoRdfTypeClassUnionMember1>>;

  noRdfTypeClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<
      NoRdfTypeClassUnionMember1.$Filter,
      NoRdfTypeClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly NoRdfTypeClassUnionMember1.$Identifier[]>>;

  noRdfTypeClassUnionMember1s(
    query?: $ObjectSet.Query<
      NoRdfTypeClassUnionMember1.$Filter,
      NoRdfTypeClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly NoRdfTypeClassUnionMember1[]>>;

  noRdfTypeClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<
        NoRdfTypeClassUnionMember1.$Filter,
        NoRdfTypeClassUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  noRdfTypeClassUnionMember2(
    identifier: NoRdfTypeClassUnionMember2.$Identifier,
  ): Promise<Either<Error, NoRdfTypeClassUnionMember2>>;

  noRdfTypeClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<
      NoRdfTypeClassUnionMember2.$Filter,
      NoRdfTypeClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly NoRdfTypeClassUnionMember2.$Identifier[]>>;

  noRdfTypeClassUnionMember2s(
    query?: $ObjectSet.Query<
      NoRdfTypeClassUnionMember2.$Filter,
      NoRdfTypeClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly NoRdfTypeClassUnionMember2[]>>;

  noRdfTypeClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<
        NoRdfTypeClassUnionMember2.$Filter,
        NoRdfTypeClassUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  orderedPropertiesClass(
    identifier: OrderedPropertiesClass.$Identifier,
  ): Promise<Either<Error, OrderedPropertiesClass>>;

  orderedPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      OrderedPropertiesClass.$Filter,
      OrderedPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly OrderedPropertiesClass.$Identifier[]>>;

  orderedPropertiesClasses(
    query?: $ObjectSet.Query<
      OrderedPropertiesClass.$Filter,
      OrderedPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly OrderedPropertiesClass[]>>;

  orderedPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        OrderedPropertiesClass.$Filter,
        OrderedPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  partialClass(
    identifier: PartialClass.$Identifier,
  ): Promise<Either<Error, PartialClass>>;

  partialClassIdentifiers(
    query?: $ObjectSet.Query<PartialClass.$Filter, PartialClass.$Identifier>,
  ): Promise<Either<Error, readonly PartialClass.$Identifier[]>>;

  partialClasses(
    query?: $ObjectSet.Query<PartialClass.$Filter, PartialClass.$Identifier>,
  ): Promise<Either<Error, readonly PartialClass[]>>;

  partialClassesCount(
    query?: Pick<
      $ObjectSet.Query<PartialClass.$Filter, PartialClass.$Identifier>,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  partialClassUnionMember1(
    identifier: PartialClassUnionMember1.$Identifier,
  ): Promise<Either<Error, PartialClassUnionMember1>>;

  partialClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<
      PartialClassUnionMember1.$Filter,
      PartialClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialClassUnionMember1.$Identifier[]>>;

  partialClassUnionMember1s(
    query?: $ObjectSet.Query<
      PartialClassUnionMember1.$Filter,
      PartialClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialClassUnionMember1[]>>;

  partialClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<
        PartialClassUnionMember1.$Filter,
        PartialClassUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  partialClassUnionMember2(
    identifier: PartialClassUnionMember2.$Identifier,
  ): Promise<Either<Error, PartialClassUnionMember2>>;

  partialClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<
      PartialClassUnionMember2.$Filter,
      PartialClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialClassUnionMember2.$Identifier[]>>;

  partialClassUnionMember2s(
    query?: $ObjectSet.Query<
      PartialClassUnionMember2.$Filter,
      PartialClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialClassUnionMember2[]>>;

  partialClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<
        PartialClassUnionMember2.$Filter,
        PartialClassUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  partialInterface(
    identifier: PartialInterface.$Identifier,
  ): Promise<Either<Error, PartialInterface>>;

  partialInterfaceIdentifiers(
    query?: $ObjectSet.Query<
      PartialInterface.$Filter,
      PartialInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialInterface.$Identifier[]>>;

  partialInterfaces(
    query?: $ObjectSet.Query<
      PartialInterface.$Filter,
      PartialInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialInterface[]>>;

  partialInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<PartialInterface.$Filter, PartialInterface.$Identifier>,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  partialInterfaceUnionMember1(
    identifier: PartialInterfaceUnionMember1.$Identifier,
  ): Promise<Either<Error, PartialInterfaceUnionMember1>>;

  partialInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<
      PartialInterfaceUnionMember1.$Filter,
      PartialInterfaceUnionMember1.$Identifier
    >,
  ): Promise<
    Either<Error, readonly PartialInterfaceUnionMember1.$Identifier[]>
  >;

  partialInterfaceUnionMember1s(
    query?: $ObjectSet.Query<
      PartialInterfaceUnionMember1.$Filter,
      PartialInterfaceUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialInterfaceUnionMember1[]>>;

  partialInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<
        PartialInterfaceUnionMember1.$Filter,
        PartialInterfaceUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  partialInterfaceUnionMember2(
    identifier: PartialInterfaceUnionMember2.$Identifier,
  ): Promise<Either<Error, PartialInterfaceUnionMember2>>;

  partialInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<
      PartialInterfaceUnionMember2.$Filter,
      PartialInterfaceUnionMember2.$Identifier
    >,
  ): Promise<
    Either<Error, readonly PartialInterfaceUnionMember2.$Identifier[]>
  >;

  partialInterfaceUnionMember2s(
    query?: $ObjectSet.Query<
      PartialInterfaceUnionMember2.$Filter,
      PartialInterfaceUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialInterfaceUnionMember2[]>>;

  partialInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<
        PartialInterfaceUnionMember2.$Filter,
        PartialInterfaceUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  propertyCardinalitiesClass(
    identifier: PropertyCardinalitiesClass.$Identifier,
  ): Promise<Either<Error, PropertyCardinalitiesClass>>;

  propertyCardinalitiesClassIdentifiers(
    query?: $ObjectSet.Query<
      PropertyCardinalitiesClass.$Filter,
      PropertyCardinalitiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly PropertyCardinalitiesClass.$Identifier[]>>;

  propertyCardinalitiesClasses(
    query?: $ObjectSet.Query<
      PropertyCardinalitiesClass.$Filter,
      PropertyCardinalitiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly PropertyCardinalitiesClass[]>>;

  propertyCardinalitiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        PropertyCardinalitiesClass.$Filter,
        PropertyCardinalitiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  propertyVisibilitiesClass(
    identifier: PropertyVisibilitiesClass.$Identifier,
  ): Promise<Either<Error, PropertyVisibilitiesClass>>;

  propertyVisibilitiesClassIdentifiers(
    query?: $ObjectSet.Query<
      PropertyVisibilitiesClass.$Filter,
      PropertyVisibilitiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly PropertyVisibilitiesClass.$Identifier[]>>;

  propertyVisibilitiesClasses(
    query?: $ObjectSet.Query<
      PropertyVisibilitiesClass.$Filter,
      PropertyVisibilitiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly PropertyVisibilitiesClass[]>>;

  propertyVisibilitiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        PropertyVisibilitiesClass.$Filter,
        PropertyVisibilitiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  recursiveClassUnionMember1(
    identifier: RecursiveClassUnionMember1.$Identifier,
  ): Promise<Either<Error, RecursiveClassUnionMember1>>;

  recursiveClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<
      RecursiveClassUnionMember1.$Filter,
      RecursiveClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly RecursiveClassUnionMember1.$Identifier[]>>;

  recursiveClassUnionMember1s(
    query?: $ObjectSet.Query<
      RecursiveClassUnionMember1.$Filter,
      RecursiveClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly RecursiveClassUnionMember1[]>>;

  recursiveClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<
        RecursiveClassUnionMember1.$Filter,
        RecursiveClassUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  recursiveClassUnionMember2(
    identifier: RecursiveClassUnionMember2.$Identifier,
  ): Promise<Either<Error, RecursiveClassUnionMember2>>;

  recursiveClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<
      RecursiveClassUnionMember2.$Filter,
      RecursiveClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly RecursiveClassUnionMember2.$Identifier[]>>;

  recursiveClassUnionMember2s(
    query?: $ObjectSet.Query<
      RecursiveClassUnionMember2.$Filter,
      RecursiveClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly RecursiveClassUnionMember2[]>>;

  recursiveClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<
        RecursiveClassUnionMember2.$Filter,
        RecursiveClassUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  sha256IriIdentifierClass(
    identifier: Sha256IriIdentifierClass.$Identifier,
  ): Promise<Either<Error, Sha256IriIdentifierClass>>;

  sha256IriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<
      Sha256IriIdentifierClass.$Filter,
      Sha256IriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly Sha256IriIdentifierClass.$Identifier[]>>;

  sha256IriIdentifierClasses(
    query?: $ObjectSet.Query<
      Sha256IriIdentifierClass.$Filter,
      Sha256IriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly Sha256IriIdentifierClass[]>>;

  sha256IriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        Sha256IriIdentifierClass.$Filter,
        Sha256IriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  termPropertiesClass(
    identifier: TermPropertiesClass.$Identifier,
  ): Promise<Either<Error, TermPropertiesClass>>;

  termPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      TermPropertiesClass.$Filter,
      TermPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly TermPropertiesClass.$Identifier[]>>;

  termPropertiesClasses(
    query?: $ObjectSet.Query<
      TermPropertiesClass.$Filter,
      TermPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly TermPropertiesClass[]>>;

  termPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        TermPropertiesClass.$Filter,
        TermPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  unionDiscriminantsClass(
    identifier: UnionDiscriminantsClass.$Identifier,
  ): Promise<Either<Error, UnionDiscriminantsClass>>;

  unionDiscriminantsClassIdentifiers(
    query?: $ObjectSet.Query<
      UnionDiscriminantsClass.$Filter,
      UnionDiscriminantsClass.$Identifier
    >,
  ): Promise<Either<Error, readonly UnionDiscriminantsClass.$Identifier[]>>;

  unionDiscriminantsClasses(
    query?: $ObjectSet.Query<
      UnionDiscriminantsClass.$Filter,
      UnionDiscriminantsClass.$Identifier
    >,
  ): Promise<Either<Error, readonly UnionDiscriminantsClass[]>>;

  unionDiscriminantsClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        UnionDiscriminantsClass.$Filter,
        UnionDiscriminantsClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  uuidV4IriIdentifierClass(
    identifier: UuidV4IriIdentifierClass.$Identifier,
  ): Promise<Either<Error, UuidV4IriIdentifierClass>>;

  uuidV4IriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<
      UuidV4IriIdentifierClass.$Filter,
      UuidV4IriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly UuidV4IriIdentifierClass.$Identifier[]>>;

  uuidV4IriIdentifierClasses(
    query?: $ObjectSet.Query<
      UuidV4IriIdentifierClass.$Filter,
      UuidV4IriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly UuidV4IriIdentifierClass[]>>;

  uuidV4IriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        UuidV4IriIdentifierClass.$Filter,
        UuidV4IriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  uuidV4IriIdentifierInterface(
    identifier: UuidV4IriIdentifierInterface.$Identifier,
  ): Promise<Either<Error, UuidV4IriIdentifierInterface>>;

  uuidV4IriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<
      UuidV4IriIdentifierInterface.$Filter,
      UuidV4IriIdentifierInterface.$Identifier
    >,
  ): Promise<
    Either<Error, readonly UuidV4IriIdentifierInterface.$Identifier[]>
  >;

  uuidV4IriIdentifierInterfaces(
    query?: $ObjectSet.Query<
      UuidV4IriIdentifierInterface.$Filter,
      UuidV4IriIdentifierInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly UuidV4IriIdentifierInterface[]>>;

  uuidV4IriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<
        UuidV4IriIdentifierInterface.$Filter,
        UuidV4IriIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  classUnion(
    identifier: ClassUnion.$Identifier,
  ): Promise<Either<Error, ClassUnion>>;

  classUnionIdentifiers(
    query?: $ObjectSet.Query<ClassUnion.$Filter, ClassUnion.$Identifier>,
  ): Promise<Either<Error, readonly ClassUnion.$Identifier[]>>;

  classUnions(
    query?: $ObjectSet.Query<ClassUnion.$Filter, ClassUnion.$Identifier>,
  ): Promise<Either<Error, readonly ClassUnion[]>>;

  classUnionsCount(
    query?: Pick<
      $ObjectSet.Query<ClassUnion.$Filter, ClassUnion.$Identifier>,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  flattenClassUnion(
    identifier: FlattenClassUnion.$Identifier,
  ): Promise<Either<Error, FlattenClassUnion>>;

  flattenClassUnionIdentifiers(
    query?: $ObjectSet.Query<
      FlattenClassUnion.$Filter,
      FlattenClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly FlattenClassUnion.$Identifier[]>>;

  flattenClassUnions(
    query?: $ObjectSet.Query<
      FlattenClassUnion.$Filter,
      FlattenClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly FlattenClassUnion[]>>;

  flattenClassUnionsCount(
    query?: Pick<
      $ObjectSet.Query<
        FlattenClassUnion.$Filter,
        FlattenClassUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  interfaceUnion(
    identifier: InterfaceUnion.$Identifier,
  ): Promise<Either<Error, InterfaceUnion>>;

  interfaceUnionIdentifiers(
    query?: $ObjectSet.Query<
      InterfaceUnion.$Filter,
      InterfaceUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly InterfaceUnion.$Identifier[]>>;

  interfaceUnions(
    query?: $ObjectSet.Query<
      InterfaceUnion.$Filter,
      InterfaceUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly InterfaceUnion[]>>;

  interfaceUnionsCount(
    query?: Pick<
      $ObjectSet.Query<InterfaceUnion.$Filter, InterfaceUnion.$Identifier>,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  lazilyResolvedClassUnion(
    identifier: LazilyResolvedClassUnion.$Identifier,
  ): Promise<Either<Error, LazilyResolvedClassUnion>>;

  lazilyResolvedClassUnionIdentifiers(
    query?: $ObjectSet.Query<
      LazilyResolvedClassUnion.$Filter,
      LazilyResolvedClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedClassUnion.$Identifier[]>>;

  lazilyResolvedClassUnions(
    query?: $ObjectSet.Query<
      LazilyResolvedClassUnion.$Filter,
      LazilyResolvedClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedClassUnion[]>>;

  lazilyResolvedClassUnionsCount(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedClassUnion.$Filter,
        LazilyResolvedClassUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  lazilyResolvedInterfaceUnion(
    identifier: LazilyResolvedInterfaceUnion.$Identifier,
  ): Promise<Either<Error, LazilyResolvedInterfaceUnion>>;

  lazilyResolvedInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<
      LazilyResolvedInterfaceUnion.$Filter,
      LazilyResolvedInterfaceUnion.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedInterfaceUnion.$Identifier[]>
  >;

  lazilyResolvedInterfaceUnions(
    query?: $ObjectSet.Query<
      LazilyResolvedInterfaceUnion.$Filter,
      LazilyResolvedInterfaceUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedInterfaceUnion[]>>;

  lazilyResolvedInterfaceUnionsCount(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedInterfaceUnion.$Filter,
        LazilyResolvedInterfaceUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  noRdfTypeClassUnion(
    identifier: NoRdfTypeClassUnion.$Identifier,
  ): Promise<Either<Error, NoRdfTypeClassUnion>>;

  noRdfTypeClassUnionIdentifiers(
    query?: $ObjectSet.Query<
      NoRdfTypeClassUnion.$Filter,
      NoRdfTypeClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly NoRdfTypeClassUnion.$Identifier[]>>;

  noRdfTypeClassUnions(
    query?: $ObjectSet.Query<
      NoRdfTypeClassUnion.$Filter,
      NoRdfTypeClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly NoRdfTypeClassUnion[]>>;

  noRdfTypeClassUnionsCount(
    query?: Pick<
      $ObjectSet.Query<
        NoRdfTypeClassUnion.$Filter,
        NoRdfTypeClassUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  partialClassUnion(
    identifier: PartialClassUnion.$Identifier,
  ): Promise<Either<Error, PartialClassUnion>>;

  partialClassUnionIdentifiers(
    query?: $ObjectSet.Query<
      PartialClassUnion.$Filter,
      PartialClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialClassUnion.$Identifier[]>>;

  partialClassUnions(
    query?: $ObjectSet.Query<
      PartialClassUnion.$Filter,
      PartialClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialClassUnion[]>>;

  partialClassUnionsCount(
    query?: Pick<
      $ObjectSet.Query<
        PartialClassUnion.$Filter,
        PartialClassUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  partialInterfaceUnion(
    identifier: PartialInterfaceUnion.$Identifier,
  ): Promise<Either<Error, PartialInterfaceUnion>>;

  partialInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<
      PartialInterfaceUnion.$Filter,
      PartialInterfaceUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialInterfaceUnion.$Identifier[]>>;

  partialInterfaceUnions(
    query?: $ObjectSet.Query<
      PartialInterfaceUnion.$Filter,
      PartialInterfaceUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialInterfaceUnion[]>>;

  partialInterfaceUnionsCount(
    query?: Pick<
      $ObjectSet.Query<
        PartialInterfaceUnion.$Filter,
        PartialInterfaceUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  recursiveClassUnion(
    identifier: RecursiveClassUnion.$Identifier,
  ): Promise<Either<Error, RecursiveClassUnion>>;

  recursiveClassUnionIdentifiers(
    query?: $ObjectSet.Query<
      RecursiveClassUnion.$Filter,
      RecursiveClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly RecursiveClassUnion.$Identifier[]>>;

  recursiveClassUnions(
    query?: $ObjectSet.Query<
      RecursiveClassUnion.$Filter,
      RecursiveClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly RecursiveClassUnion[]>>;

  recursiveClassUnionsCount(
    query?: Pick<
      $ObjectSet.Query<
        RecursiveClassUnion.$Filter,
        RecursiveClassUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>>;

  object(identifier: $Object.$Identifier): Promise<Either<Error, $Object>>;

  objectIdentifiers(
    query?: $ObjectSet.Query<$Object.$Filter, $Object.$Identifier>,
  ): Promise<Either<Error, readonly $Object.$Identifier[]>>;

  objects(
    query?: $ObjectSet.Query<$Object.$Filter, $Object.$Identifier>,
  ): Promise<Either<Error, readonly $Object[]>>;

  objectsCount(
    query?: Pick<
      $ObjectSet.Query<$Object.$Filter, $Object.$Identifier>,
      "filter"
    >,
  ): Promise<Either<Error, number>>;
}

export namespace $ObjectSet {
  export interface Query<
    ObjectFilterT,
    ObjectIdentifierT extends BlankNode | NamedNode,
  > {
    readonly filter?: ObjectFilterT;
    readonly identifiers?: readonly ObjectIdentifierT[];
    readonly limit?: number;
    readonly offset?: number;
  }
}
export class $RdfjsDatasetObjectSet implements $ObjectSet {
  protected readonly resourceSet: ResourceSet;

  constructor(dataset: DatasetCore) {
    this.resourceSet = new ResourceSet(dataset, { dataFactory: dataFactory });
  }

  async baseInterfaceWithoutProperties(
    identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier,
  ): Promise<Either<Error, BaseInterfaceWithoutProperties>> {
    return this.baseInterfaceWithoutPropertiesSync(identifier);
  }

  baseInterfaceWithoutPropertiesSync(
    identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier,
  ): Either<Error, BaseInterfaceWithoutProperties> {
    return this.baseInterfaceWithoutPropertiesesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async baseInterfaceWithoutPropertiesIdentifiers(
    query?: $ObjectSet.Query<
      BaseInterfaceWithoutPropertiesStatic.$Filter,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >,
  ): Promise<
    Either<Error, readonly BaseInterfaceWithoutPropertiesStatic.$Identifier[]>
  > {
    return this.baseInterfaceWithoutPropertiesIdentifiersSync(query);
  }

  baseInterfaceWithoutPropertiesIdentifiersSync(
    query?: $ObjectSet.Query<
      BaseInterfaceWithoutPropertiesStatic.$Filter,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >,
  ): Either<
    Error,
    readonly BaseInterfaceWithoutPropertiesStatic.$Identifier[]
  > {
    return this.baseInterfaceWithoutPropertiesesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async baseInterfaceWithoutPropertieses(
    query?: $ObjectSet.Query<
      BaseInterfaceWithoutPropertiesStatic.$Filter,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >,
  ): Promise<Either<Error, readonly BaseInterfaceWithoutProperties[]>> {
    return this.baseInterfaceWithoutPropertiesesSync(query);
  }

  async baseInterfaceWithoutPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<
        BaseInterfaceWithoutPropertiesStatic.$Filter,
        BaseInterfaceWithoutPropertiesStatic.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.baseInterfaceWithoutPropertiesesCountSync(query);
  }

  baseInterfaceWithoutPropertiesesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        BaseInterfaceWithoutPropertiesStatic.$Filter,
        BaseInterfaceWithoutPropertiesStatic.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.baseInterfaceWithoutPropertiesesSync(query).map(
      (objects) => objects.length,
    );
  }

  baseInterfaceWithoutPropertiesesSync(
    query?: $ObjectSet.Query<
      BaseInterfaceWithoutPropertiesStatic.$Filter,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >,
  ): Either<Error, readonly BaseInterfaceWithoutProperties[]> {
    return this.$objectsSync<
      BaseInterfaceWithoutProperties,
      BaseInterfaceWithoutPropertiesStatic.$Filter,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >(
      {
        $filter: BaseInterfaceWithoutPropertiesStatic.$filter,
        $fromRdf: BaseInterfaceWithoutPropertiesStatic.$fromRdf,
        $fromRdfTypes: [
          BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
          ConcreteParentInterfaceStatic.$fromRdfType,
          ConcreteChildInterface.$fromRdfType,
        ],
      },
      query,
    );
  }

  async baseInterfaceWithProperties(
    identifier: BaseInterfaceWithPropertiesStatic.$Identifier,
  ): Promise<Either<Error, BaseInterfaceWithProperties>> {
    return this.baseInterfaceWithPropertiesSync(identifier);
  }

  baseInterfaceWithPropertiesSync(
    identifier: BaseInterfaceWithPropertiesStatic.$Identifier,
  ): Either<Error, BaseInterfaceWithProperties> {
    return this.baseInterfaceWithPropertiesesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async baseInterfaceWithPropertiesIdentifiers(
    query?: $ObjectSet.Query<
      BaseInterfaceWithPropertiesStatic.$Filter,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >,
  ): Promise<
    Either<Error, readonly BaseInterfaceWithPropertiesStatic.$Identifier[]>
  > {
    return this.baseInterfaceWithPropertiesIdentifiersSync(query);
  }

  baseInterfaceWithPropertiesIdentifiersSync(
    query?: $ObjectSet.Query<
      BaseInterfaceWithPropertiesStatic.$Filter,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >,
  ): Either<Error, readonly BaseInterfaceWithPropertiesStatic.$Identifier[]> {
    return this.baseInterfaceWithPropertiesesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async baseInterfaceWithPropertieses(
    query?: $ObjectSet.Query<
      BaseInterfaceWithPropertiesStatic.$Filter,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >,
  ): Promise<Either<Error, readonly BaseInterfaceWithProperties[]>> {
    return this.baseInterfaceWithPropertiesesSync(query);
  }

  async baseInterfaceWithPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<
        BaseInterfaceWithPropertiesStatic.$Filter,
        BaseInterfaceWithPropertiesStatic.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.baseInterfaceWithPropertiesesCountSync(query);
  }

  baseInterfaceWithPropertiesesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        BaseInterfaceWithPropertiesStatic.$Filter,
        BaseInterfaceWithPropertiesStatic.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.baseInterfaceWithPropertiesesSync(query).map(
      (objects) => objects.length,
    );
  }

  baseInterfaceWithPropertiesesSync(
    query?: $ObjectSet.Query<
      BaseInterfaceWithPropertiesStatic.$Filter,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >,
  ): Either<Error, readonly BaseInterfaceWithProperties[]> {
    return this.$objectsSync<
      BaseInterfaceWithProperties,
      BaseInterfaceWithPropertiesStatic.$Filter,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >(
      {
        $filter: BaseInterfaceWithPropertiesStatic.$filter,
        $fromRdf: BaseInterfaceWithPropertiesStatic.$fromRdf,
        $fromRdfTypes: [
          BaseInterfaceWithPropertiesStatic.$fromRdfType,
          BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
          ConcreteParentInterfaceStatic.$fromRdfType,
          ConcreteChildInterface.$fromRdfType,
        ],
      },
      query,
    );
  }

  async blankNodeIdentifierClass(
    identifier: BlankNodeIdentifierClass.$Identifier,
  ): Promise<Either<Error, BlankNodeIdentifierClass>> {
    return this.blankNodeIdentifierClassSync(identifier);
  }

  blankNodeIdentifierClassSync(
    identifier: BlankNodeIdentifierClass.$Identifier,
  ): Either<Error, BlankNodeIdentifierClass> {
    return this.blankNodeIdentifierClassesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async blankNodeIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<
      BlankNodeIdentifierClass.$Filter,
      BlankNodeIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly BlankNodeIdentifierClass.$Identifier[]>> {
    return this.blankNodeIdentifierClassIdentifiersSync(query);
  }

  blankNodeIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<
      BlankNodeIdentifierClass.$Filter,
      BlankNodeIdentifierClass.$Identifier
    >,
  ): Either<Error, readonly BlankNodeIdentifierClass.$Identifier[]> {
    return this.blankNodeIdentifierClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async blankNodeIdentifierClasses(
    query?: $ObjectSet.Query<
      BlankNodeIdentifierClass.$Filter,
      BlankNodeIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly BlankNodeIdentifierClass[]>> {
    return this.blankNodeIdentifierClassesSync(query);
  }

  async blankNodeIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        BlankNodeIdentifierClass.$Filter,
        BlankNodeIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.blankNodeIdentifierClassesCountSync(query);
  }

  blankNodeIdentifierClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        BlankNodeIdentifierClass.$Filter,
        BlankNodeIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.blankNodeIdentifierClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  blankNodeIdentifierClassesSync(
    query?: $ObjectSet.Query<
      BlankNodeIdentifierClass.$Filter,
      BlankNodeIdentifierClass.$Identifier
    >,
  ): Either<Error, readonly BlankNodeIdentifierClass[]> {
    return this.$objectsSync<
      BlankNodeIdentifierClass,
      BlankNodeIdentifierClass.$Filter,
      BlankNodeIdentifierClass.$Identifier
    >(
      {
        $filter: BlankNodeIdentifierClass.$filter,
        $fromRdf: BlankNodeIdentifierClass.$fromRdf,
        $fromRdfTypes: [BlankNodeIdentifierClass.$fromRdfType],
      },
      query,
    );
  }

  async blankNodeIdentifierInterface(
    identifier: BlankNodeIdentifierInterface.$Identifier,
  ): Promise<Either<Error, BlankNodeIdentifierInterface>> {
    return this.blankNodeIdentifierInterfaceSync(identifier);
  }

  blankNodeIdentifierInterfaceSync(
    identifier: BlankNodeIdentifierInterface.$Identifier,
  ): Either<Error, BlankNodeIdentifierInterface> {
    return this.blankNodeIdentifierInterfacesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async blankNodeIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<
      BlankNodeIdentifierInterface.$Filter,
      BlankNodeIdentifierInterface.$Identifier
    >,
  ): Promise<
    Either<Error, readonly BlankNodeIdentifierInterface.$Identifier[]>
  > {
    return this.blankNodeIdentifierInterfaceIdentifiersSync(query);
  }

  blankNodeIdentifierInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<
      BlankNodeIdentifierInterface.$Filter,
      BlankNodeIdentifierInterface.$Identifier
    >,
  ): Either<Error, readonly BlankNodeIdentifierInterface.$Identifier[]> {
    return this.blankNodeIdentifierInterfacesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async blankNodeIdentifierInterfaces(
    query?: $ObjectSet.Query<
      BlankNodeIdentifierInterface.$Filter,
      BlankNodeIdentifierInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly BlankNodeIdentifierInterface[]>> {
    return this.blankNodeIdentifierInterfacesSync(query);
  }

  async blankNodeIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<
        BlankNodeIdentifierInterface.$Filter,
        BlankNodeIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.blankNodeIdentifierInterfacesCountSync(query);
  }

  blankNodeIdentifierInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        BlankNodeIdentifierInterface.$Filter,
        BlankNodeIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.blankNodeIdentifierInterfacesSync(query).map(
      (objects) => objects.length,
    );
  }

  blankNodeIdentifierInterfacesSync(
    query?: $ObjectSet.Query<
      BlankNodeIdentifierInterface.$Filter,
      BlankNodeIdentifierInterface.$Identifier
    >,
  ): Either<Error, readonly BlankNodeIdentifierInterface[]> {
    return this.$objectsSync<
      BlankNodeIdentifierInterface,
      BlankNodeIdentifierInterface.$Filter,
      BlankNodeIdentifierInterface.$Identifier
    >(
      {
        $filter: BlankNodeIdentifierInterface.$filter,
        $fromRdf: BlankNodeIdentifierInterface.$fromRdf,
        $fromRdfTypes: [BlankNodeIdentifierInterface.$fromRdfType],
      },
      query,
    );
  }

  async blankNodeOrIriIdentifierClass(
    identifier: BlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<Either<Error, BlankNodeOrIriIdentifierClass>> {
    return this.blankNodeOrIriIdentifierClassSync(identifier);
  }

  blankNodeOrIriIdentifierClassSync(
    identifier: BlankNodeOrIriIdentifierClass.$Identifier,
  ): Either<Error, BlankNodeOrIriIdentifierClass> {
    return this.blankNodeOrIriIdentifierClassesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async blankNodeOrIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<
      BlankNodeOrIriIdentifierClass.$Filter,
      BlankNodeOrIriIdentifierClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly BlankNodeOrIriIdentifierClass.$Identifier[]>
  > {
    return this.blankNodeOrIriIdentifierClassIdentifiersSync(query);
  }

  blankNodeOrIriIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<
      BlankNodeOrIriIdentifierClass.$Filter,
      BlankNodeOrIriIdentifierClass.$Identifier
    >,
  ): Either<Error, readonly BlankNodeOrIriIdentifierClass.$Identifier[]> {
    return this.blankNodeOrIriIdentifierClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async blankNodeOrIriIdentifierClasses(
    query?: $ObjectSet.Query<
      BlankNodeOrIriIdentifierClass.$Filter,
      BlankNodeOrIriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly BlankNodeOrIriIdentifierClass[]>> {
    return this.blankNodeOrIriIdentifierClassesSync(query);
  }

  async blankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        BlankNodeOrIriIdentifierClass.$Filter,
        BlankNodeOrIriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.blankNodeOrIriIdentifierClassesCountSync(query);
  }

  blankNodeOrIriIdentifierClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        BlankNodeOrIriIdentifierClass.$Filter,
        BlankNodeOrIriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.blankNodeOrIriIdentifierClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  blankNodeOrIriIdentifierClassesSync(
    query?: $ObjectSet.Query<
      BlankNodeOrIriIdentifierClass.$Filter,
      BlankNodeOrIriIdentifierClass.$Identifier
    >,
  ): Either<Error, readonly BlankNodeOrIriIdentifierClass[]> {
    return this.$objectsSync<
      BlankNodeOrIriIdentifierClass,
      BlankNodeOrIriIdentifierClass.$Filter,
      BlankNodeOrIriIdentifierClass.$Identifier
    >(
      {
        $filter: BlankNodeOrIriIdentifierClass.$filter,
        $fromRdf: BlankNodeOrIriIdentifierClass.$fromRdf,
        $fromRdfTypes: [BlankNodeOrIriIdentifierClass.$fromRdfType],
      },
      query,
    );
  }

  async blankNodeOrIriIdentifierInterface(
    identifier: BlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<Either<Error, BlankNodeOrIriIdentifierInterface>> {
    return this.blankNodeOrIriIdentifierInterfaceSync(identifier);
  }

  blankNodeOrIriIdentifierInterfaceSync(
    identifier: BlankNodeOrIriIdentifierInterface.$Identifier,
  ): Either<Error, BlankNodeOrIriIdentifierInterface> {
    return this.blankNodeOrIriIdentifierInterfacesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async blankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<
      BlankNodeOrIriIdentifierInterface.$Filter,
      BlankNodeOrIriIdentifierInterface.$Identifier
    >,
  ): Promise<
    Either<Error, readonly BlankNodeOrIriIdentifierInterface.$Identifier[]>
  > {
    return this.blankNodeOrIriIdentifierInterfaceIdentifiersSync(query);
  }

  blankNodeOrIriIdentifierInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<
      BlankNodeOrIriIdentifierInterface.$Filter,
      BlankNodeOrIriIdentifierInterface.$Identifier
    >,
  ): Either<Error, readonly BlankNodeOrIriIdentifierInterface.$Identifier[]> {
    return this.blankNodeOrIriIdentifierInterfacesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async blankNodeOrIriIdentifierInterfaces(
    query?: $ObjectSet.Query<
      BlankNodeOrIriIdentifierInterface.$Filter,
      BlankNodeOrIriIdentifierInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly BlankNodeOrIriIdentifierInterface[]>> {
    return this.blankNodeOrIriIdentifierInterfacesSync(query);
  }

  async blankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<
        BlankNodeOrIriIdentifierInterface.$Filter,
        BlankNodeOrIriIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.blankNodeOrIriIdentifierInterfacesCountSync(query);
  }

  blankNodeOrIriIdentifierInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        BlankNodeOrIriIdentifierInterface.$Filter,
        BlankNodeOrIriIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.blankNodeOrIriIdentifierInterfacesSync(query).map(
      (objects) => objects.length,
    );
  }

  blankNodeOrIriIdentifierInterfacesSync(
    query?: $ObjectSet.Query<
      BlankNodeOrIriIdentifierInterface.$Filter,
      BlankNodeOrIriIdentifierInterface.$Identifier
    >,
  ): Either<Error, readonly BlankNodeOrIriIdentifierInterface[]> {
    return this.$objectsSync<
      BlankNodeOrIriIdentifierInterface,
      BlankNodeOrIriIdentifierInterface.$Filter,
      BlankNodeOrIriIdentifierInterface.$Identifier
    >(
      {
        $filter: BlankNodeOrIriIdentifierInterface.$filter,
        $fromRdf: BlankNodeOrIriIdentifierInterface.$fromRdf,
        $fromRdfTypes: [BlankNodeOrIriIdentifierInterface.$fromRdfType],
      },
      query,
    );
  }

  async classUnionMember1(
    identifier: ClassUnionMember1.$Identifier,
  ): Promise<Either<Error, ClassUnionMember1>> {
    return this.classUnionMember1Sync(identifier);
  }

  classUnionMember1Sync(
    identifier: ClassUnionMember1.$Identifier,
  ): Either<Error, ClassUnionMember1> {
    return this.classUnionMember1sSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async classUnionMember1Identifiers(
    query?: $ObjectSet.Query<
      ClassUnionMember1.$Filter,
      ClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly ClassUnionMember1.$Identifier[]>> {
    return this.classUnionMember1IdentifiersSync(query);
  }

  classUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<
      ClassUnionMember1.$Filter,
      ClassUnionMember1.$Identifier
    >,
  ): Either<Error, readonly ClassUnionMember1.$Identifier[]> {
    return this.classUnionMember1sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async classUnionMember1s(
    query?: $ObjectSet.Query<
      ClassUnionMember1.$Filter,
      ClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly ClassUnionMember1[]>> {
    return this.classUnionMember1sSync(query);
  }

  async classUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<
        ClassUnionMember1.$Filter,
        ClassUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.classUnionMember1sCountSync(query);
  }

  classUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<
        ClassUnionMember1.$Filter,
        ClassUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.classUnionMember1sSync(query).map((objects) => objects.length);
  }

  classUnionMember1sSync(
    query?: $ObjectSet.Query<
      ClassUnionMember1.$Filter,
      ClassUnionMember1.$Identifier
    >,
  ): Either<Error, readonly ClassUnionMember1[]> {
    return this.$objectsSync<
      ClassUnionMember1,
      ClassUnionMember1.$Filter,
      ClassUnionMember1.$Identifier
    >(
      {
        $filter: ClassUnionMember1.$filter,
        $fromRdf: ClassUnionMember1.$fromRdf,
        $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
      },
      query,
    );
  }

  async classUnionMember2(
    identifier: ClassUnionMember2.$Identifier,
  ): Promise<Either<Error, ClassUnionMember2>> {
    return this.classUnionMember2Sync(identifier);
  }

  classUnionMember2Sync(
    identifier: ClassUnionMember2.$Identifier,
  ): Either<Error, ClassUnionMember2> {
    return this.classUnionMember2sSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async classUnionMember2Identifiers(
    query?: $ObjectSet.Query<
      ClassUnionMember2.$Filter,
      ClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly ClassUnionMember2.$Identifier[]>> {
    return this.classUnionMember2IdentifiersSync(query);
  }

  classUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<
      ClassUnionMember2.$Filter,
      ClassUnionMember2.$Identifier
    >,
  ): Either<Error, readonly ClassUnionMember2.$Identifier[]> {
    return this.classUnionMember2sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async classUnionMember2s(
    query?: $ObjectSet.Query<
      ClassUnionMember2.$Filter,
      ClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly ClassUnionMember2[]>> {
    return this.classUnionMember2sSync(query);
  }

  async classUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<
        ClassUnionMember2.$Filter,
        ClassUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.classUnionMember2sCountSync(query);
  }

  classUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<
        ClassUnionMember2.$Filter,
        ClassUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.classUnionMember2sSync(query).map((objects) => objects.length);
  }

  classUnionMember2sSync(
    query?: $ObjectSet.Query<
      ClassUnionMember2.$Filter,
      ClassUnionMember2.$Identifier
    >,
  ): Either<Error, readonly ClassUnionMember2[]> {
    return this.$objectsSync<
      ClassUnionMember2,
      ClassUnionMember2.$Filter,
      ClassUnionMember2.$Identifier
    >(
      {
        $filter: ClassUnionMember2.$filter,
        $fromRdf: ClassUnionMember2.$fromRdf,
        $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
      },
      query,
    );
  }

  async concreteChildClass(
    identifier: ConcreteChildClass.$Identifier,
  ): Promise<Either<Error, ConcreteChildClass>> {
    return this.concreteChildClassSync(identifier);
  }

  concreteChildClassSync(
    identifier: ConcreteChildClass.$Identifier,
  ): Either<Error, ConcreteChildClass> {
    return this.concreteChildClassesSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async concreteChildClassIdentifiers(
    query?: $ObjectSet.Query<
      ConcreteChildClass.$Filter,
      ConcreteChildClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ConcreteChildClass.$Identifier[]>> {
    return this.concreteChildClassIdentifiersSync(query);
  }

  concreteChildClassIdentifiersSync(
    query?: $ObjectSet.Query<
      ConcreteChildClass.$Filter,
      ConcreteChildClass.$Identifier
    >,
  ): Either<Error, readonly ConcreteChildClass.$Identifier[]> {
    return this.concreteChildClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async concreteChildClasses(
    query?: $ObjectSet.Query<
      ConcreteChildClass.$Filter,
      ConcreteChildClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ConcreteChildClass[]>> {
    return this.concreteChildClassesSync(query);
  }

  async concreteChildClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        ConcreteChildClass.$Filter,
        ConcreteChildClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.concreteChildClassesCountSync(query);
  }

  concreteChildClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        ConcreteChildClass.$Filter,
        ConcreteChildClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.concreteChildClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  concreteChildClassesSync(
    query?: $ObjectSet.Query<
      ConcreteChildClass.$Filter,
      ConcreteChildClass.$Identifier
    >,
  ): Either<Error, readonly ConcreteChildClass[]> {
    return this.$objectsSync<
      ConcreteChildClass,
      ConcreteChildClass.$Filter,
      ConcreteChildClass.$Identifier
    >(
      {
        $filter: ConcreteChildClass.$filter,
        $fromRdf: ConcreteChildClass.$fromRdf,
        $fromRdfTypes: [ConcreteChildClass.$fromRdfType],
      },
      query,
    );
  }

  async concreteChildInterface(
    identifier: ConcreteChildInterface.$Identifier,
  ): Promise<Either<Error, ConcreteChildInterface>> {
    return this.concreteChildInterfaceSync(identifier);
  }

  concreteChildInterfaceSync(
    identifier: ConcreteChildInterface.$Identifier,
  ): Either<Error, ConcreteChildInterface> {
    return this.concreteChildInterfacesSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async concreteChildInterfaceIdentifiers(
    query?: $ObjectSet.Query<
      ConcreteChildInterface.$Filter,
      ConcreteChildInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly ConcreteChildInterface.$Identifier[]>> {
    return this.concreteChildInterfaceIdentifiersSync(query);
  }

  concreteChildInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<
      ConcreteChildInterface.$Filter,
      ConcreteChildInterface.$Identifier
    >,
  ): Either<Error, readonly ConcreteChildInterface.$Identifier[]> {
    return this.concreteChildInterfacesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async concreteChildInterfaces(
    query?: $ObjectSet.Query<
      ConcreteChildInterface.$Filter,
      ConcreteChildInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly ConcreteChildInterface[]>> {
    return this.concreteChildInterfacesSync(query);
  }

  async concreteChildInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<
        ConcreteChildInterface.$Filter,
        ConcreteChildInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.concreteChildInterfacesCountSync(query);
  }

  concreteChildInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        ConcreteChildInterface.$Filter,
        ConcreteChildInterface.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.concreteChildInterfacesSync(query).map(
      (objects) => objects.length,
    );
  }

  concreteChildInterfacesSync(
    query?: $ObjectSet.Query<
      ConcreteChildInterface.$Filter,
      ConcreteChildInterface.$Identifier
    >,
  ): Either<Error, readonly ConcreteChildInterface[]> {
    return this.$objectsSync<
      ConcreteChildInterface,
      ConcreteChildInterface.$Filter,
      ConcreteChildInterface.$Identifier
    >(
      {
        $filter: ConcreteChildInterface.$filter,
        $fromRdf: ConcreteChildInterface.$fromRdf,
        $fromRdfTypes: [ConcreteChildInterface.$fromRdfType],
      },
      query,
    );
  }

  async concreteParentClass(
    identifier: ConcreteParentClassStatic.$Identifier,
  ): Promise<Either<Error, ConcreteParentClass>> {
    return this.concreteParentClassSync(identifier);
  }

  concreteParentClassSync(
    identifier: ConcreteParentClassStatic.$Identifier,
  ): Either<Error, ConcreteParentClass> {
    return this.concreteParentClassesSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async concreteParentClassIdentifiers(
    query?: $ObjectSet.Query<
      ConcreteParentClassStatic.$Filter,
      ConcreteParentClassStatic.$Identifier
    >,
  ): Promise<Either<Error, readonly ConcreteParentClassStatic.$Identifier[]>> {
    return this.concreteParentClassIdentifiersSync(query);
  }

  concreteParentClassIdentifiersSync(
    query?: $ObjectSet.Query<
      ConcreteParentClassStatic.$Filter,
      ConcreteParentClassStatic.$Identifier
    >,
  ): Either<Error, readonly ConcreteParentClassStatic.$Identifier[]> {
    return this.concreteParentClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async concreteParentClasses(
    query?: $ObjectSet.Query<
      ConcreteParentClassStatic.$Filter,
      ConcreteParentClassStatic.$Identifier
    >,
  ): Promise<Either<Error, readonly ConcreteParentClass[]>> {
    return this.concreteParentClassesSync(query);
  }

  async concreteParentClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        ConcreteParentClassStatic.$Filter,
        ConcreteParentClassStatic.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.concreteParentClassesCountSync(query);
  }

  concreteParentClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        ConcreteParentClassStatic.$Filter,
        ConcreteParentClassStatic.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.concreteParentClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  concreteParentClassesSync(
    query?: $ObjectSet.Query<
      ConcreteParentClassStatic.$Filter,
      ConcreteParentClassStatic.$Identifier
    >,
  ): Either<Error, readonly ConcreteParentClass[]> {
    return this.$objectsSync<
      ConcreteParentClass,
      ConcreteParentClassStatic.$Filter,
      ConcreteParentClassStatic.$Identifier
    >(
      {
        $filter: ConcreteParentClassStatic.$filter,
        $fromRdf: ConcreteParentClassStatic.$fromRdf,
        $fromRdfTypes: [
          ConcreteParentClassStatic.$fromRdfType,
          ConcreteChildClass.$fromRdfType,
        ],
      },
      query,
    );
  }

  async concreteParentInterface(
    identifier: ConcreteParentInterfaceStatic.$Identifier,
  ): Promise<Either<Error, ConcreteParentInterface>> {
    return this.concreteParentInterfaceSync(identifier);
  }

  concreteParentInterfaceSync(
    identifier: ConcreteParentInterfaceStatic.$Identifier,
  ): Either<Error, ConcreteParentInterface> {
    return this.concreteParentInterfacesSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async concreteParentInterfaceIdentifiers(
    query?: $ObjectSet.Query<
      ConcreteParentInterfaceStatic.$Filter,
      ConcreteParentInterfaceStatic.$Identifier
    >,
  ): Promise<
    Either<Error, readonly ConcreteParentInterfaceStatic.$Identifier[]>
  > {
    return this.concreteParentInterfaceIdentifiersSync(query);
  }

  concreteParentInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<
      ConcreteParentInterfaceStatic.$Filter,
      ConcreteParentInterfaceStatic.$Identifier
    >,
  ): Either<Error, readonly ConcreteParentInterfaceStatic.$Identifier[]> {
    return this.concreteParentInterfacesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async concreteParentInterfaces(
    query?: $ObjectSet.Query<
      ConcreteParentInterfaceStatic.$Filter,
      ConcreteParentInterfaceStatic.$Identifier
    >,
  ): Promise<Either<Error, readonly ConcreteParentInterface[]>> {
    return this.concreteParentInterfacesSync(query);
  }

  async concreteParentInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<
        ConcreteParentInterfaceStatic.$Filter,
        ConcreteParentInterfaceStatic.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.concreteParentInterfacesCountSync(query);
  }

  concreteParentInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        ConcreteParentInterfaceStatic.$Filter,
        ConcreteParentInterfaceStatic.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.concreteParentInterfacesSync(query).map(
      (objects) => objects.length,
    );
  }

  concreteParentInterfacesSync(
    query?: $ObjectSet.Query<
      ConcreteParentInterfaceStatic.$Filter,
      ConcreteParentInterfaceStatic.$Identifier
    >,
  ): Either<Error, readonly ConcreteParentInterface[]> {
    return this.$objectsSync<
      ConcreteParentInterface,
      ConcreteParentInterfaceStatic.$Filter,
      ConcreteParentInterfaceStatic.$Identifier
    >(
      {
        $filter: ConcreteParentInterfaceStatic.$filter,
        $fromRdf: ConcreteParentInterfaceStatic.$fromRdf,
        $fromRdfTypes: [
          ConcreteParentInterfaceStatic.$fromRdfType,
          ConcreteChildInterface.$fromRdfType,
        ],
      },
      query,
    );
  }

  async convertibleTypePropertiesClass(
    identifier: ConvertibleTypePropertiesClass.$Identifier,
  ): Promise<Either<Error, ConvertibleTypePropertiesClass>> {
    return this.convertibleTypePropertiesClassSync(identifier);
  }

  convertibleTypePropertiesClassSync(
    identifier: ConvertibleTypePropertiesClass.$Identifier,
  ): Either<Error, ConvertibleTypePropertiesClass> {
    return this.convertibleTypePropertiesClassesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async convertibleTypePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      ConvertibleTypePropertiesClass.$Filter,
      ConvertibleTypePropertiesClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly ConvertibleTypePropertiesClass.$Identifier[]>
  > {
    return this.convertibleTypePropertiesClassIdentifiersSync(query);
  }

  convertibleTypePropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<
      ConvertibleTypePropertiesClass.$Filter,
      ConvertibleTypePropertiesClass.$Identifier
    >,
  ): Either<Error, readonly ConvertibleTypePropertiesClass.$Identifier[]> {
    return this.convertibleTypePropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async convertibleTypePropertiesClasses(
    query?: $ObjectSet.Query<
      ConvertibleTypePropertiesClass.$Filter,
      ConvertibleTypePropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ConvertibleTypePropertiesClass[]>> {
    return this.convertibleTypePropertiesClassesSync(query);
  }

  async convertibleTypePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        ConvertibleTypePropertiesClass.$Filter,
        ConvertibleTypePropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.convertibleTypePropertiesClassesCountSync(query);
  }

  convertibleTypePropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        ConvertibleTypePropertiesClass.$Filter,
        ConvertibleTypePropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.convertibleTypePropertiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  convertibleTypePropertiesClassesSync(
    query?: $ObjectSet.Query<
      ConvertibleTypePropertiesClass.$Filter,
      ConvertibleTypePropertiesClass.$Identifier
    >,
  ): Either<Error, readonly ConvertibleTypePropertiesClass[]> {
    return this.$objectsSync<
      ConvertibleTypePropertiesClass,
      ConvertibleTypePropertiesClass.$Filter,
      ConvertibleTypePropertiesClass.$Identifier
    >(
      {
        $filter: ConvertibleTypePropertiesClass.$filter,
        $fromRdf: ConvertibleTypePropertiesClass.$fromRdf,
        $fromRdfTypes: [ConvertibleTypePropertiesClass.$fromRdfType],
      },
      query,
    );
  }

  async dateUnionPropertiesClass(
    identifier: DateUnionPropertiesClass.$Identifier,
  ): Promise<Either<Error, DateUnionPropertiesClass>> {
    return this.dateUnionPropertiesClassSync(identifier);
  }

  dateUnionPropertiesClassSync(
    identifier: DateUnionPropertiesClass.$Identifier,
  ): Either<Error, DateUnionPropertiesClass> {
    return this.dateUnionPropertiesClassesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async dateUnionPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      DateUnionPropertiesClass.$Filter,
      DateUnionPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly DateUnionPropertiesClass.$Identifier[]>> {
    return this.dateUnionPropertiesClassIdentifiersSync(query);
  }

  dateUnionPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<
      DateUnionPropertiesClass.$Filter,
      DateUnionPropertiesClass.$Identifier
    >,
  ): Either<Error, readonly DateUnionPropertiesClass.$Identifier[]> {
    return this.dateUnionPropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async dateUnionPropertiesClasses(
    query?: $ObjectSet.Query<
      DateUnionPropertiesClass.$Filter,
      DateUnionPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly DateUnionPropertiesClass[]>> {
    return this.dateUnionPropertiesClassesSync(query);
  }

  async dateUnionPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        DateUnionPropertiesClass.$Filter,
        DateUnionPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.dateUnionPropertiesClassesCountSync(query);
  }

  dateUnionPropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        DateUnionPropertiesClass.$Filter,
        DateUnionPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.dateUnionPropertiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  dateUnionPropertiesClassesSync(
    query?: $ObjectSet.Query<
      DateUnionPropertiesClass.$Filter,
      DateUnionPropertiesClass.$Identifier
    >,
  ): Either<Error, readonly DateUnionPropertiesClass[]> {
    return this.$objectsSync<
      DateUnionPropertiesClass,
      DateUnionPropertiesClass.$Filter,
      DateUnionPropertiesClass.$Identifier
    >(
      {
        $filter: DateUnionPropertiesClass.$filter,
        $fromRdf: DateUnionPropertiesClass.$fromRdf,
        $fromRdfTypes: [DateUnionPropertiesClass.$fromRdfType],
      },
      query,
    );
  }

  async defaultValuePropertiesClass(
    identifier: DefaultValuePropertiesClass.$Identifier,
  ): Promise<Either<Error, DefaultValuePropertiesClass>> {
    return this.defaultValuePropertiesClassSync(identifier);
  }

  defaultValuePropertiesClassSync(
    identifier: DefaultValuePropertiesClass.$Identifier,
  ): Either<Error, DefaultValuePropertiesClass> {
    return this.defaultValuePropertiesClassesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async defaultValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      DefaultValuePropertiesClass.$Filter,
      DefaultValuePropertiesClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly DefaultValuePropertiesClass.$Identifier[]>
  > {
    return this.defaultValuePropertiesClassIdentifiersSync(query);
  }

  defaultValuePropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<
      DefaultValuePropertiesClass.$Filter,
      DefaultValuePropertiesClass.$Identifier
    >,
  ): Either<Error, readonly DefaultValuePropertiesClass.$Identifier[]> {
    return this.defaultValuePropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async defaultValuePropertiesClasses(
    query?: $ObjectSet.Query<
      DefaultValuePropertiesClass.$Filter,
      DefaultValuePropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly DefaultValuePropertiesClass[]>> {
    return this.defaultValuePropertiesClassesSync(query);
  }

  async defaultValuePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        DefaultValuePropertiesClass.$Filter,
        DefaultValuePropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.defaultValuePropertiesClassesCountSync(query);
  }

  defaultValuePropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        DefaultValuePropertiesClass.$Filter,
        DefaultValuePropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.defaultValuePropertiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  defaultValuePropertiesClassesSync(
    query?: $ObjectSet.Query<
      DefaultValuePropertiesClass.$Filter,
      DefaultValuePropertiesClass.$Identifier
    >,
  ): Either<Error, readonly DefaultValuePropertiesClass[]> {
    return this.$objectsSync<
      DefaultValuePropertiesClass,
      DefaultValuePropertiesClass.$Filter,
      DefaultValuePropertiesClass.$Identifier
    >(
      {
        $filter: DefaultValuePropertiesClass.$filter,
        $fromRdf: DefaultValuePropertiesClass.$fromRdf,
        $fromRdfTypes: [DefaultValuePropertiesClass.$fromRdfType],
      },
      query,
    );
  }

  async directRecursiveClass(
    identifier: DirectRecursiveClass.$Identifier,
  ): Promise<Either<Error, DirectRecursiveClass>> {
    return this.directRecursiveClassSync(identifier);
  }

  directRecursiveClassSync(
    identifier: DirectRecursiveClass.$Identifier,
  ): Either<Error, DirectRecursiveClass> {
    return this.directRecursiveClassesSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async directRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<
      DirectRecursiveClass.$Filter,
      DirectRecursiveClass.$Identifier
    >,
  ): Promise<Either<Error, readonly DirectRecursiveClass.$Identifier[]>> {
    return this.directRecursiveClassIdentifiersSync(query);
  }

  directRecursiveClassIdentifiersSync(
    query?: $ObjectSet.Query<
      DirectRecursiveClass.$Filter,
      DirectRecursiveClass.$Identifier
    >,
  ): Either<Error, readonly DirectRecursiveClass.$Identifier[]> {
    return this.directRecursiveClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async directRecursiveClasses(
    query?: $ObjectSet.Query<
      DirectRecursiveClass.$Filter,
      DirectRecursiveClass.$Identifier
    >,
  ): Promise<Either<Error, readonly DirectRecursiveClass[]>> {
    return this.directRecursiveClassesSync(query);
  }

  async directRecursiveClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        DirectRecursiveClass.$Filter,
        DirectRecursiveClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.directRecursiveClassesCountSync(query);
  }

  directRecursiveClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        DirectRecursiveClass.$Filter,
        DirectRecursiveClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.directRecursiveClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  directRecursiveClassesSync(
    query?: $ObjectSet.Query<
      DirectRecursiveClass.$Filter,
      DirectRecursiveClass.$Identifier
    >,
  ): Either<Error, readonly DirectRecursiveClass[]> {
    return this.$objectsSync<
      DirectRecursiveClass,
      DirectRecursiveClass.$Filter,
      DirectRecursiveClass.$Identifier
    >(
      {
        $filter: DirectRecursiveClass.$filter,
        $fromRdf: DirectRecursiveClass.$fromRdf,
        $fromRdfTypes: [DirectRecursiveClass.$fromRdfType],
      },
      query,
    );
  }

  async explicitFromToRdfTypesClass(
    identifier: ExplicitFromToRdfTypesClass.$Identifier,
  ): Promise<Either<Error, ExplicitFromToRdfTypesClass>> {
    return this.explicitFromToRdfTypesClassSync(identifier);
  }

  explicitFromToRdfTypesClassSync(
    identifier: ExplicitFromToRdfTypesClass.$Identifier,
  ): Either<Error, ExplicitFromToRdfTypesClass> {
    return this.explicitFromToRdfTypesClassesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async explicitFromToRdfTypesClassIdentifiers(
    query?: $ObjectSet.Query<
      ExplicitFromToRdfTypesClass.$Filter,
      ExplicitFromToRdfTypesClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly ExplicitFromToRdfTypesClass.$Identifier[]>
  > {
    return this.explicitFromToRdfTypesClassIdentifiersSync(query);
  }

  explicitFromToRdfTypesClassIdentifiersSync(
    query?: $ObjectSet.Query<
      ExplicitFromToRdfTypesClass.$Filter,
      ExplicitFromToRdfTypesClass.$Identifier
    >,
  ): Either<Error, readonly ExplicitFromToRdfTypesClass.$Identifier[]> {
    return this.explicitFromToRdfTypesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async explicitFromToRdfTypesClasses(
    query?: $ObjectSet.Query<
      ExplicitFromToRdfTypesClass.$Filter,
      ExplicitFromToRdfTypesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ExplicitFromToRdfTypesClass[]>> {
    return this.explicitFromToRdfTypesClassesSync(query);
  }

  async explicitFromToRdfTypesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        ExplicitFromToRdfTypesClass.$Filter,
        ExplicitFromToRdfTypesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.explicitFromToRdfTypesClassesCountSync(query);
  }

  explicitFromToRdfTypesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        ExplicitFromToRdfTypesClass.$Filter,
        ExplicitFromToRdfTypesClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.explicitFromToRdfTypesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  explicitFromToRdfTypesClassesSync(
    query?: $ObjectSet.Query<
      ExplicitFromToRdfTypesClass.$Filter,
      ExplicitFromToRdfTypesClass.$Identifier
    >,
  ): Either<Error, readonly ExplicitFromToRdfTypesClass[]> {
    return this.$objectsSync<
      ExplicitFromToRdfTypesClass,
      ExplicitFromToRdfTypesClass.$Filter,
      ExplicitFromToRdfTypesClass.$Identifier
    >(
      {
        $filter: ExplicitFromToRdfTypesClass.$filter,
        $fromRdf: ExplicitFromToRdfTypesClass.$fromRdf,
        $fromRdfTypes: [ExplicitFromToRdfTypesClass.$fromRdfType],
      },
      query,
    );
  }

  async explicitRdfTypeClass(
    identifier: ExplicitRdfTypeClass.$Identifier,
  ): Promise<Either<Error, ExplicitRdfTypeClass>> {
    return this.explicitRdfTypeClassSync(identifier);
  }

  explicitRdfTypeClassSync(
    identifier: ExplicitRdfTypeClass.$Identifier,
  ): Either<Error, ExplicitRdfTypeClass> {
    return this.explicitRdfTypeClassesSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async explicitRdfTypeClassIdentifiers(
    query?: $ObjectSet.Query<
      ExplicitRdfTypeClass.$Filter,
      ExplicitRdfTypeClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ExplicitRdfTypeClass.$Identifier[]>> {
    return this.explicitRdfTypeClassIdentifiersSync(query);
  }

  explicitRdfTypeClassIdentifiersSync(
    query?: $ObjectSet.Query<
      ExplicitRdfTypeClass.$Filter,
      ExplicitRdfTypeClass.$Identifier
    >,
  ): Either<Error, readonly ExplicitRdfTypeClass.$Identifier[]> {
    return this.explicitRdfTypeClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async explicitRdfTypeClasses(
    query?: $ObjectSet.Query<
      ExplicitRdfTypeClass.$Filter,
      ExplicitRdfTypeClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ExplicitRdfTypeClass[]>> {
    return this.explicitRdfTypeClassesSync(query);
  }

  async explicitRdfTypeClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        ExplicitRdfTypeClass.$Filter,
        ExplicitRdfTypeClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.explicitRdfTypeClassesCountSync(query);
  }

  explicitRdfTypeClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        ExplicitRdfTypeClass.$Filter,
        ExplicitRdfTypeClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.explicitRdfTypeClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  explicitRdfTypeClassesSync(
    query?: $ObjectSet.Query<
      ExplicitRdfTypeClass.$Filter,
      ExplicitRdfTypeClass.$Identifier
    >,
  ): Either<Error, readonly ExplicitRdfTypeClass[]> {
    return this.$objectsSync<
      ExplicitRdfTypeClass,
      ExplicitRdfTypeClass.$Filter,
      ExplicitRdfTypeClass.$Identifier
    >(
      {
        $filter: ExplicitRdfTypeClass.$filter,
        $fromRdf: ExplicitRdfTypeClass.$fromRdf,
        $fromRdfTypes: [ExplicitRdfTypeClass.$fromRdfType],
      },
      query,
    );
  }

  async externClassPropertyClass(
    identifier: ExternClassPropertyClass.$Identifier,
  ): Promise<Either<Error, ExternClassPropertyClass>> {
    return this.externClassPropertyClassSync(identifier);
  }

  externClassPropertyClassSync(
    identifier: ExternClassPropertyClass.$Identifier,
  ): Either<Error, ExternClassPropertyClass> {
    return this.externClassPropertyClassesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async externClassPropertyClassIdentifiers(
    query?: $ObjectSet.Query<
      ExternClassPropertyClass.$Filter,
      ExternClassPropertyClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ExternClassPropertyClass.$Identifier[]>> {
    return this.externClassPropertyClassIdentifiersSync(query);
  }

  externClassPropertyClassIdentifiersSync(
    query?: $ObjectSet.Query<
      ExternClassPropertyClass.$Filter,
      ExternClassPropertyClass.$Identifier
    >,
  ): Either<Error, readonly ExternClassPropertyClass.$Identifier[]> {
    return this.externClassPropertyClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async externClassPropertyClasses(
    query?: $ObjectSet.Query<
      ExternClassPropertyClass.$Filter,
      ExternClassPropertyClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ExternClassPropertyClass[]>> {
    return this.externClassPropertyClassesSync(query);
  }

  async externClassPropertyClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        ExternClassPropertyClass.$Filter,
        ExternClassPropertyClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.externClassPropertyClassesCountSync(query);
  }

  externClassPropertyClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        ExternClassPropertyClass.$Filter,
        ExternClassPropertyClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.externClassPropertyClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  externClassPropertyClassesSync(
    query?: $ObjectSet.Query<
      ExternClassPropertyClass.$Filter,
      ExternClassPropertyClass.$Identifier
    >,
  ): Either<Error, readonly ExternClassPropertyClass[]> {
    return this.$objectsSync<
      ExternClassPropertyClass,
      ExternClassPropertyClass.$Filter,
      ExternClassPropertyClass.$Identifier
    >(
      {
        $filter: ExternClassPropertyClass.$filter,
        $fromRdf: ExternClassPropertyClass.$fromRdf,
        $fromRdfTypes: [ExternClassPropertyClass.$fromRdfType],
      },
      query,
    );
  }

  async flattenClassUnionMember3(
    identifier: FlattenClassUnionMember3.$Identifier,
  ): Promise<Either<Error, FlattenClassUnionMember3>> {
    return this.flattenClassUnionMember3Sync(identifier);
  }

  flattenClassUnionMember3Sync(
    identifier: FlattenClassUnionMember3.$Identifier,
  ): Either<Error, FlattenClassUnionMember3> {
    return this.flattenClassUnionMember3sSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async flattenClassUnionMember3Identifiers(
    query?: $ObjectSet.Query<
      FlattenClassUnionMember3.$Filter,
      FlattenClassUnionMember3.$Identifier
    >,
  ): Promise<Either<Error, readonly FlattenClassUnionMember3.$Identifier[]>> {
    return this.flattenClassUnionMember3IdentifiersSync(query);
  }

  flattenClassUnionMember3IdentifiersSync(
    query?: $ObjectSet.Query<
      FlattenClassUnionMember3.$Filter,
      FlattenClassUnionMember3.$Identifier
    >,
  ): Either<Error, readonly FlattenClassUnionMember3.$Identifier[]> {
    return this.flattenClassUnionMember3sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async flattenClassUnionMember3s(
    query?: $ObjectSet.Query<
      FlattenClassUnionMember3.$Filter,
      FlattenClassUnionMember3.$Identifier
    >,
  ): Promise<Either<Error, readonly FlattenClassUnionMember3[]>> {
    return this.flattenClassUnionMember3sSync(query);
  }

  async flattenClassUnionMember3sCount(
    query?: Pick<
      $ObjectSet.Query<
        FlattenClassUnionMember3.$Filter,
        FlattenClassUnionMember3.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.flattenClassUnionMember3sCountSync(query);
  }

  flattenClassUnionMember3sCountSync(
    query?: Pick<
      $ObjectSet.Query<
        FlattenClassUnionMember3.$Filter,
        FlattenClassUnionMember3.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.flattenClassUnionMember3sSync(query).map(
      (objects) => objects.length,
    );
  }

  flattenClassUnionMember3sSync(
    query?: $ObjectSet.Query<
      FlattenClassUnionMember3.$Filter,
      FlattenClassUnionMember3.$Identifier
    >,
  ): Either<Error, readonly FlattenClassUnionMember3[]> {
    return this.$objectsSync<
      FlattenClassUnionMember3,
      FlattenClassUnionMember3.$Filter,
      FlattenClassUnionMember3.$Identifier
    >(
      {
        $filter: FlattenClassUnionMember3.$filter,
        $fromRdf: FlattenClassUnionMember3.$fromRdf,
        $fromRdfTypes: [FlattenClassUnionMember3.$fromRdfType],
      },
      query,
    );
  }

  async hasValuePropertiesClass(
    identifier: HasValuePropertiesClass.$Identifier,
  ): Promise<Either<Error, HasValuePropertiesClass>> {
    return this.hasValuePropertiesClassSync(identifier);
  }

  hasValuePropertiesClassSync(
    identifier: HasValuePropertiesClass.$Identifier,
  ): Either<Error, HasValuePropertiesClass> {
    return this.hasValuePropertiesClassesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async hasValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      HasValuePropertiesClass.$Filter,
      HasValuePropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly HasValuePropertiesClass.$Identifier[]>> {
    return this.hasValuePropertiesClassIdentifiersSync(query);
  }

  hasValuePropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<
      HasValuePropertiesClass.$Filter,
      HasValuePropertiesClass.$Identifier
    >,
  ): Either<Error, readonly HasValuePropertiesClass.$Identifier[]> {
    return this.hasValuePropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async hasValuePropertiesClasses(
    query?: $ObjectSet.Query<
      HasValuePropertiesClass.$Filter,
      HasValuePropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly HasValuePropertiesClass[]>> {
    return this.hasValuePropertiesClassesSync(query);
  }

  async hasValuePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        HasValuePropertiesClass.$Filter,
        HasValuePropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.hasValuePropertiesClassesCountSync(query);
  }

  hasValuePropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        HasValuePropertiesClass.$Filter,
        HasValuePropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.hasValuePropertiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  hasValuePropertiesClassesSync(
    query?: $ObjectSet.Query<
      HasValuePropertiesClass.$Filter,
      HasValuePropertiesClass.$Identifier
    >,
  ): Either<Error, readonly HasValuePropertiesClass[]> {
    return this.$objectsSync<
      HasValuePropertiesClass,
      HasValuePropertiesClass.$Filter,
      HasValuePropertiesClass.$Identifier
    >(
      {
        $filter: HasValuePropertiesClass.$filter,
        $fromRdf: HasValuePropertiesClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async identifierOverride3Class(
    identifier: IdentifierOverride3ClassStatic.$Identifier,
  ): Promise<Either<Error, IdentifierOverride3Class>> {
    return this.identifierOverride3ClassSync(identifier);
  }

  identifierOverride3ClassSync(
    identifier: IdentifierOverride3ClassStatic.$Identifier,
  ): Either<Error, IdentifierOverride3Class> {
    return this.identifierOverride3ClassesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async identifierOverride3ClassIdentifiers(
    query?: $ObjectSet.Query<
      IdentifierOverride3ClassStatic.$Filter,
      IdentifierOverride3ClassStatic.$Identifier
    >,
  ): Promise<
    Either<Error, readonly IdentifierOverride3ClassStatic.$Identifier[]>
  > {
    return this.identifierOverride3ClassIdentifiersSync(query);
  }

  identifierOverride3ClassIdentifiersSync(
    query?: $ObjectSet.Query<
      IdentifierOverride3ClassStatic.$Filter,
      IdentifierOverride3ClassStatic.$Identifier
    >,
  ): Either<Error, readonly IdentifierOverride3ClassStatic.$Identifier[]> {
    return this.identifierOverride3ClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async identifierOverride3Classes(
    query?: $ObjectSet.Query<
      IdentifierOverride3ClassStatic.$Filter,
      IdentifierOverride3ClassStatic.$Identifier
    >,
  ): Promise<Either<Error, readonly IdentifierOverride3Class[]>> {
    return this.identifierOverride3ClassesSync(query);
  }

  async identifierOverride3ClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        IdentifierOverride3ClassStatic.$Filter,
        IdentifierOverride3ClassStatic.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.identifierOverride3ClassesCountSync(query);
  }

  identifierOverride3ClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        IdentifierOverride3ClassStatic.$Filter,
        IdentifierOverride3ClassStatic.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.identifierOverride3ClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  identifierOverride3ClassesSync(
    query?: $ObjectSet.Query<
      IdentifierOverride3ClassStatic.$Filter,
      IdentifierOverride3ClassStatic.$Identifier
    >,
  ): Either<Error, readonly IdentifierOverride3Class[]> {
    return this.$objectsSync<
      IdentifierOverride3Class,
      IdentifierOverride3ClassStatic.$Filter,
      IdentifierOverride3ClassStatic.$Identifier
    >(
      {
        $filter: IdentifierOverride3ClassStatic.$filter,
        $fromRdf: IdentifierOverride3ClassStatic.$fromRdf,
        $fromRdfTypes: [
          IdentifierOverride3ClassStatic.$fromRdfType,
          IdentifierOverride4ClassStatic.$fromRdfType,
          IdentifierOverride5Class.$fromRdfType,
        ],
      },
      query,
    );
  }

  async identifierOverride4Class(
    identifier: IdentifierOverride4ClassStatic.$Identifier,
  ): Promise<Either<Error, IdentifierOverride4Class>> {
    return this.identifierOverride4ClassSync(identifier);
  }

  identifierOverride4ClassSync(
    identifier: IdentifierOverride4ClassStatic.$Identifier,
  ): Either<Error, IdentifierOverride4Class> {
    return this.identifierOverride4ClassesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async identifierOverride4ClassIdentifiers(
    query?: $ObjectSet.Query<
      IdentifierOverride4ClassStatic.$Filter,
      IdentifierOverride4ClassStatic.$Identifier
    >,
  ): Promise<
    Either<Error, readonly IdentifierOverride4ClassStatic.$Identifier[]>
  > {
    return this.identifierOverride4ClassIdentifiersSync(query);
  }

  identifierOverride4ClassIdentifiersSync(
    query?: $ObjectSet.Query<
      IdentifierOverride4ClassStatic.$Filter,
      IdentifierOverride4ClassStatic.$Identifier
    >,
  ): Either<Error, readonly IdentifierOverride4ClassStatic.$Identifier[]> {
    return this.identifierOverride4ClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async identifierOverride4Classes(
    query?: $ObjectSet.Query<
      IdentifierOverride4ClassStatic.$Filter,
      IdentifierOverride4ClassStatic.$Identifier
    >,
  ): Promise<Either<Error, readonly IdentifierOverride4Class[]>> {
    return this.identifierOverride4ClassesSync(query);
  }

  async identifierOverride4ClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        IdentifierOverride4ClassStatic.$Filter,
        IdentifierOverride4ClassStatic.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.identifierOverride4ClassesCountSync(query);
  }

  identifierOverride4ClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        IdentifierOverride4ClassStatic.$Filter,
        IdentifierOverride4ClassStatic.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.identifierOverride4ClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  identifierOverride4ClassesSync(
    query?: $ObjectSet.Query<
      IdentifierOverride4ClassStatic.$Filter,
      IdentifierOverride4ClassStatic.$Identifier
    >,
  ): Either<Error, readonly IdentifierOverride4Class[]> {
    return this.$objectsSync<
      IdentifierOverride4Class,
      IdentifierOverride4ClassStatic.$Filter,
      IdentifierOverride4ClassStatic.$Identifier
    >(
      {
        $filter: IdentifierOverride4ClassStatic.$filter,
        $fromRdf: IdentifierOverride4ClassStatic.$fromRdf,
        $fromRdfTypes: [
          IdentifierOverride4ClassStatic.$fromRdfType,
          IdentifierOverride5Class.$fromRdfType,
        ],
      },
      query,
    );
  }

  async identifierOverride5Class(
    identifier: IdentifierOverride5Class.$Identifier,
  ): Promise<Either<Error, IdentifierOverride5Class>> {
    return this.identifierOverride5ClassSync(identifier);
  }

  identifierOverride5ClassSync(
    identifier: IdentifierOverride5Class.$Identifier,
  ): Either<Error, IdentifierOverride5Class> {
    return this.identifierOverride5ClassesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async identifierOverride5ClassIdentifiers(
    query?: $ObjectSet.Query<
      IdentifierOverride5Class.$Filter,
      IdentifierOverride5Class.$Identifier
    >,
  ): Promise<Either<Error, readonly IdentifierOverride5Class.$Identifier[]>> {
    return this.identifierOverride5ClassIdentifiersSync(query);
  }

  identifierOverride5ClassIdentifiersSync(
    query?: $ObjectSet.Query<
      IdentifierOverride5Class.$Filter,
      IdentifierOverride5Class.$Identifier
    >,
  ): Either<Error, readonly IdentifierOverride5Class.$Identifier[]> {
    return this.identifierOverride5ClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async identifierOverride5Classes(
    query?: $ObjectSet.Query<
      IdentifierOverride5Class.$Filter,
      IdentifierOverride5Class.$Identifier
    >,
  ): Promise<Either<Error, readonly IdentifierOverride5Class[]>> {
    return this.identifierOverride5ClassesSync(query);
  }

  async identifierOverride5ClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        IdentifierOverride5Class.$Filter,
        IdentifierOverride5Class.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.identifierOverride5ClassesCountSync(query);
  }

  identifierOverride5ClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        IdentifierOverride5Class.$Filter,
        IdentifierOverride5Class.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.identifierOverride5ClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  identifierOverride5ClassesSync(
    query?: $ObjectSet.Query<
      IdentifierOverride5Class.$Filter,
      IdentifierOverride5Class.$Identifier
    >,
  ): Either<Error, readonly IdentifierOverride5Class[]> {
    return this.$objectsSync<
      IdentifierOverride5Class,
      IdentifierOverride5Class.$Filter,
      IdentifierOverride5Class.$Identifier
    >(
      {
        $filter: IdentifierOverride5Class.$filter,
        $fromRdf: IdentifierOverride5Class.$fromRdf,
        $fromRdfTypes: [IdentifierOverride5Class.$fromRdfType],
      },
      query,
    );
  }

  async indirectRecursiveClass(
    identifier: IndirectRecursiveClass.$Identifier,
  ): Promise<Either<Error, IndirectRecursiveClass>> {
    return this.indirectRecursiveClassSync(identifier);
  }

  indirectRecursiveClassSync(
    identifier: IndirectRecursiveClass.$Identifier,
  ): Either<Error, IndirectRecursiveClass> {
    return this.indirectRecursiveClassesSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async indirectRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<
      IndirectRecursiveClass.$Filter,
      IndirectRecursiveClass.$Identifier
    >,
  ): Promise<Either<Error, readonly IndirectRecursiveClass.$Identifier[]>> {
    return this.indirectRecursiveClassIdentifiersSync(query);
  }

  indirectRecursiveClassIdentifiersSync(
    query?: $ObjectSet.Query<
      IndirectRecursiveClass.$Filter,
      IndirectRecursiveClass.$Identifier
    >,
  ): Either<Error, readonly IndirectRecursiveClass.$Identifier[]> {
    return this.indirectRecursiveClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async indirectRecursiveClasses(
    query?: $ObjectSet.Query<
      IndirectRecursiveClass.$Filter,
      IndirectRecursiveClass.$Identifier
    >,
  ): Promise<Either<Error, readonly IndirectRecursiveClass[]>> {
    return this.indirectRecursiveClassesSync(query);
  }

  async indirectRecursiveClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        IndirectRecursiveClass.$Filter,
        IndirectRecursiveClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.indirectRecursiveClassesCountSync(query);
  }

  indirectRecursiveClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        IndirectRecursiveClass.$Filter,
        IndirectRecursiveClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.indirectRecursiveClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  indirectRecursiveClassesSync(
    query?: $ObjectSet.Query<
      IndirectRecursiveClass.$Filter,
      IndirectRecursiveClass.$Identifier
    >,
  ): Either<Error, readonly IndirectRecursiveClass[]> {
    return this.$objectsSync<
      IndirectRecursiveClass,
      IndirectRecursiveClass.$Filter,
      IndirectRecursiveClass.$Identifier
    >(
      {
        $filter: IndirectRecursiveClass.$filter,
        $fromRdf: IndirectRecursiveClass.$fromRdf,
        $fromRdfTypes: [IndirectRecursiveClass.$fromRdfType],
      },
      query,
    );
  }

  async indirectRecursiveHelperClass(
    identifier: IndirectRecursiveHelperClass.$Identifier,
  ): Promise<Either<Error, IndirectRecursiveHelperClass>> {
    return this.indirectRecursiveHelperClassSync(identifier);
  }

  indirectRecursiveHelperClassSync(
    identifier: IndirectRecursiveHelperClass.$Identifier,
  ): Either<Error, IndirectRecursiveHelperClass> {
    return this.indirectRecursiveHelperClassesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async indirectRecursiveHelperClassIdentifiers(
    query?: $ObjectSet.Query<
      IndirectRecursiveHelperClass.$Filter,
      IndirectRecursiveHelperClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly IndirectRecursiveHelperClass.$Identifier[]>
  > {
    return this.indirectRecursiveHelperClassIdentifiersSync(query);
  }

  indirectRecursiveHelperClassIdentifiersSync(
    query?: $ObjectSet.Query<
      IndirectRecursiveHelperClass.$Filter,
      IndirectRecursiveHelperClass.$Identifier
    >,
  ): Either<Error, readonly IndirectRecursiveHelperClass.$Identifier[]> {
    return this.indirectRecursiveHelperClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async indirectRecursiveHelperClasses(
    query?: $ObjectSet.Query<
      IndirectRecursiveHelperClass.$Filter,
      IndirectRecursiveHelperClass.$Identifier
    >,
  ): Promise<Either<Error, readonly IndirectRecursiveHelperClass[]>> {
    return this.indirectRecursiveHelperClassesSync(query);
  }

  async indirectRecursiveHelperClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        IndirectRecursiveHelperClass.$Filter,
        IndirectRecursiveHelperClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.indirectRecursiveHelperClassesCountSync(query);
  }

  indirectRecursiveHelperClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        IndirectRecursiveHelperClass.$Filter,
        IndirectRecursiveHelperClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.indirectRecursiveHelperClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  indirectRecursiveHelperClassesSync(
    query?: $ObjectSet.Query<
      IndirectRecursiveHelperClass.$Filter,
      IndirectRecursiveHelperClass.$Identifier
    >,
  ): Either<Error, readonly IndirectRecursiveHelperClass[]> {
    return this.$objectsSync<
      IndirectRecursiveHelperClass,
      IndirectRecursiveHelperClass.$Filter,
      IndirectRecursiveHelperClass.$Identifier
    >(
      {
        $filter: IndirectRecursiveHelperClass.$filter,
        $fromRdf: IndirectRecursiveHelperClass.$fromRdf,
        $fromRdfTypes: [IndirectRecursiveHelperClass.$fromRdfType],
      },
      query,
    );
  }

  async inIdentifierClass(
    identifier: InIdentifierClass.$Identifier,
  ): Promise<Either<Error, InIdentifierClass>> {
    return this.inIdentifierClassSync(identifier);
  }

  inIdentifierClassSync(
    identifier: InIdentifierClass.$Identifier,
  ): Either<Error, InIdentifierClass> {
    return this.inIdentifierClassesSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async inIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<
      InIdentifierClass.$Filter,
      InIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly InIdentifierClass.$Identifier[]>> {
    return this.inIdentifierClassIdentifiersSync(query);
  }

  inIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<
      InIdentifierClass.$Filter,
      InIdentifierClass.$Identifier
    >,
  ): Either<Error, readonly InIdentifierClass.$Identifier[]> {
    return this.inIdentifierClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async inIdentifierClasses(
    query?: $ObjectSet.Query<
      InIdentifierClass.$Filter,
      InIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly InIdentifierClass[]>> {
    return this.inIdentifierClassesSync(query);
  }

  async inIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        InIdentifierClass.$Filter,
        InIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.inIdentifierClassesCountSync(query);
  }

  inIdentifierClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        InIdentifierClass.$Filter,
        InIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.inIdentifierClassesSync(query).map((objects) => objects.length);
  }

  inIdentifierClassesSync(
    query?: $ObjectSet.Query<
      InIdentifierClass.$Filter,
      InIdentifierClass.$Identifier
    >,
  ): Either<Error, readonly InIdentifierClass[]> {
    return this.$objectsSync<
      InIdentifierClass,
      InIdentifierClass.$Filter,
      InIdentifierClass.$Identifier
    >(
      {
        $filter: InIdentifierClass.$filter,
        $fromRdf: InIdentifierClass.$fromRdf,
        $fromRdfTypes: [InIdentifierClass.$fromRdfType],
      },
      query,
    );
  }

  async inPropertiesClass(
    identifier: InPropertiesClass.$Identifier,
  ): Promise<Either<Error, InPropertiesClass>> {
    return this.inPropertiesClassSync(identifier);
  }

  inPropertiesClassSync(
    identifier: InPropertiesClass.$Identifier,
  ): Either<Error, InPropertiesClass> {
    return this.inPropertiesClassesSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async inPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      InPropertiesClass.$Filter,
      InPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly InPropertiesClass.$Identifier[]>> {
    return this.inPropertiesClassIdentifiersSync(query);
  }

  inPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<
      InPropertiesClass.$Filter,
      InPropertiesClass.$Identifier
    >,
  ): Either<Error, readonly InPropertiesClass.$Identifier[]> {
    return this.inPropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async inPropertiesClasses(
    query?: $ObjectSet.Query<
      InPropertiesClass.$Filter,
      InPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly InPropertiesClass[]>> {
    return this.inPropertiesClassesSync(query);
  }

  async inPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        InPropertiesClass.$Filter,
        InPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.inPropertiesClassesCountSync(query);
  }

  inPropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        InPropertiesClass.$Filter,
        InPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.inPropertiesClassesSync(query).map((objects) => objects.length);
  }

  inPropertiesClassesSync(
    query?: $ObjectSet.Query<
      InPropertiesClass.$Filter,
      InPropertiesClass.$Identifier
    >,
  ): Either<Error, readonly InPropertiesClass[]> {
    return this.$objectsSync<
      InPropertiesClass,
      InPropertiesClass.$Filter,
      InPropertiesClass.$Identifier
    >(
      {
        $filter: InPropertiesClass.$filter,
        $fromRdf: InPropertiesClass.$fromRdf,
        $fromRdfTypes: [InPropertiesClass.$fromRdfType],
      },
      query,
    );
  }

  async interface(
    identifier: Interface.$Identifier,
  ): Promise<Either<Error, Interface>> {
    return this.interfaceSync(identifier);
  }

  interfaceSync(identifier: Interface.$Identifier): Either<Error, Interface> {
    return this.interfacesSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async interfaceIdentifiers(
    query?: $ObjectSet.Query<Interface.$Filter, Interface.$Identifier>,
  ): Promise<Either<Error, readonly Interface.$Identifier[]>> {
    return this.interfaceIdentifiersSync(query);
  }

  interfaceIdentifiersSync(
    query?: $ObjectSet.Query<Interface.$Filter, Interface.$Identifier>,
  ): Either<Error, readonly Interface.$Identifier[]> {
    return this.interfacesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async interfaces(
    query?: $ObjectSet.Query<Interface.$Filter, Interface.$Identifier>,
  ): Promise<Either<Error, readonly Interface[]>> {
    return this.interfacesSync(query);
  }

  async interfacesCount(
    query?: Pick<
      $ObjectSet.Query<Interface.$Filter, Interface.$Identifier>,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.interfacesCountSync(query);
  }

  interfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<Interface.$Filter, Interface.$Identifier>,
      "filter"
    >,
  ): Either<Error, number> {
    return this.interfacesSync(query).map((objects) => objects.length);
  }

  interfacesSync(
    query?: $ObjectSet.Query<Interface.$Filter, Interface.$Identifier>,
  ): Either<Error, readonly Interface[]> {
    return this.$objectsSync<
      Interface,
      Interface.$Filter,
      Interface.$Identifier
    >(
      {
        $filter: Interface.$filter,
        $fromRdf: Interface.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async interfaceUnionMember1(
    identifier: InterfaceUnionMember1.$Identifier,
  ): Promise<Either<Error, InterfaceUnionMember1>> {
    return this.interfaceUnionMember1Sync(identifier);
  }

  interfaceUnionMember1Sync(
    identifier: InterfaceUnionMember1.$Identifier,
  ): Either<Error, InterfaceUnionMember1> {
    return this.interfaceUnionMember1sSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async interfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<
      InterfaceUnionMember1.$Filter,
      InterfaceUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly InterfaceUnionMember1.$Identifier[]>> {
    return this.interfaceUnionMember1IdentifiersSync(query);
  }

  interfaceUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<
      InterfaceUnionMember1.$Filter,
      InterfaceUnionMember1.$Identifier
    >,
  ): Either<Error, readonly InterfaceUnionMember1.$Identifier[]> {
    return this.interfaceUnionMember1sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async interfaceUnionMember1s(
    query?: $ObjectSet.Query<
      InterfaceUnionMember1.$Filter,
      InterfaceUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly InterfaceUnionMember1[]>> {
    return this.interfaceUnionMember1sSync(query);
  }

  async interfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<
        InterfaceUnionMember1.$Filter,
        InterfaceUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.interfaceUnionMember1sCountSync(query);
  }

  interfaceUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<
        InterfaceUnionMember1.$Filter,
        InterfaceUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.interfaceUnionMember1sSync(query).map(
      (objects) => objects.length,
    );
  }

  interfaceUnionMember1sSync(
    query?: $ObjectSet.Query<
      InterfaceUnionMember1.$Filter,
      InterfaceUnionMember1.$Identifier
    >,
  ): Either<Error, readonly InterfaceUnionMember1[]> {
    return this.$objectsSync<
      InterfaceUnionMember1,
      InterfaceUnionMember1.$Filter,
      InterfaceUnionMember1.$Identifier
    >(
      {
        $filter: InterfaceUnionMember1.$filter,
        $fromRdf: InterfaceUnionMember1.$fromRdf,
        $fromRdfTypes: [InterfaceUnionMember1.$fromRdfType],
      },
      query,
    );
  }

  async interfaceUnionMember2(
    identifier: InterfaceUnionMember2.$Identifier,
  ): Promise<Either<Error, InterfaceUnionMember2>> {
    return this.interfaceUnionMember2Sync(identifier);
  }

  interfaceUnionMember2Sync(
    identifier: InterfaceUnionMember2.$Identifier,
  ): Either<Error, InterfaceUnionMember2> {
    return this.interfaceUnionMember2sSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async interfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<
      InterfaceUnionMember2.$Filter,
      InterfaceUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly InterfaceUnionMember2.$Identifier[]>> {
    return this.interfaceUnionMember2IdentifiersSync(query);
  }

  interfaceUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<
      InterfaceUnionMember2.$Filter,
      InterfaceUnionMember2.$Identifier
    >,
  ): Either<Error, readonly InterfaceUnionMember2.$Identifier[]> {
    return this.interfaceUnionMember2sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async interfaceUnionMember2s(
    query?: $ObjectSet.Query<
      InterfaceUnionMember2.$Filter,
      InterfaceUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly InterfaceUnionMember2[]>> {
    return this.interfaceUnionMember2sSync(query);
  }

  async interfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<
        InterfaceUnionMember2.$Filter,
        InterfaceUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.interfaceUnionMember2sCountSync(query);
  }

  interfaceUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<
        InterfaceUnionMember2.$Filter,
        InterfaceUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.interfaceUnionMember2sSync(query).map(
      (objects) => objects.length,
    );
  }

  interfaceUnionMember2sSync(
    query?: $ObjectSet.Query<
      InterfaceUnionMember2.$Filter,
      InterfaceUnionMember2.$Identifier
    >,
  ): Either<Error, readonly InterfaceUnionMember2[]> {
    return this.$objectsSync<
      InterfaceUnionMember2,
      InterfaceUnionMember2.$Filter,
      InterfaceUnionMember2.$Identifier
    >(
      {
        $filter: InterfaceUnionMember2.$filter,
        $fromRdf: InterfaceUnionMember2.$fromRdf,
        $fromRdfTypes: [InterfaceUnionMember2.$fromRdfType],
      },
      query,
    );
  }

  async iriIdentifierClass(
    identifier: IriIdentifierClass.$Identifier,
  ): Promise<Either<Error, IriIdentifierClass>> {
    return this.iriIdentifierClassSync(identifier);
  }

  iriIdentifierClassSync(
    identifier: IriIdentifierClass.$Identifier,
  ): Either<Error, IriIdentifierClass> {
    return this.iriIdentifierClassesSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async iriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<
      IriIdentifierClass.$Filter,
      IriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly IriIdentifierClass.$Identifier[]>> {
    return this.iriIdentifierClassIdentifiersSync(query);
  }

  iriIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<
      IriIdentifierClass.$Filter,
      IriIdentifierClass.$Identifier
    >,
  ): Either<Error, readonly IriIdentifierClass.$Identifier[]> {
    return this.iriIdentifierClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async iriIdentifierClasses(
    query?: $ObjectSet.Query<
      IriIdentifierClass.$Filter,
      IriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly IriIdentifierClass[]>> {
    return this.iriIdentifierClassesSync(query);
  }

  async iriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        IriIdentifierClass.$Filter,
        IriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.iriIdentifierClassesCountSync(query);
  }

  iriIdentifierClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        IriIdentifierClass.$Filter,
        IriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.iriIdentifierClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  iriIdentifierClassesSync(
    query?: $ObjectSet.Query<
      IriIdentifierClass.$Filter,
      IriIdentifierClass.$Identifier
    >,
  ): Either<Error, readonly IriIdentifierClass[]> {
    return this.$objectsSync<
      IriIdentifierClass,
      IriIdentifierClass.$Filter,
      IriIdentifierClass.$Identifier
    >(
      {
        $filter: IriIdentifierClass.$filter,
        $fromRdf: IriIdentifierClass.$fromRdf,
        $fromRdfTypes: [IriIdentifierClass.$fromRdfType],
      },
      query,
    );
  }

  async iriIdentifierInterface(
    identifier: IriIdentifierInterface.$Identifier,
  ): Promise<Either<Error, IriIdentifierInterface>> {
    return this.iriIdentifierInterfaceSync(identifier);
  }

  iriIdentifierInterfaceSync(
    identifier: IriIdentifierInterface.$Identifier,
  ): Either<Error, IriIdentifierInterface> {
    return this.iriIdentifierInterfacesSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async iriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<
      IriIdentifierInterface.$Filter,
      IriIdentifierInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly IriIdentifierInterface.$Identifier[]>> {
    return this.iriIdentifierInterfaceIdentifiersSync(query);
  }

  iriIdentifierInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<
      IriIdentifierInterface.$Filter,
      IriIdentifierInterface.$Identifier
    >,
  ): Either<Error, readonly IriIdentifierInterface.$Identifier[]> {
    return this.iriIdentifierInterfacesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async iriIdentifierInterfaces(
    query?: $ObjectSet.Query<
      IriIdentifierInterface.$Filter,
      IriIdentifierInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly IriIdentifierInterface[]>> {
    return this.iriIdentifierInterfacesSync(query);
  }

  async iriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<
        IriIdentifierInterface.$Filter,
        IriIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.iriIdentifierInterfacesCountSync(query);
  }

  iriIdentifierInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        IriIdentifierInterface.$Filter,
        IriIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.iriIdentifierInterfacesSync(query).map(
      (objects) => objects.length,
    );
  }

  iriIdentifierInterfacesSync(
    query?: $ObjectSet.Query<
      IriIdentifierInterface.$Filter,
      IriIdentifierInterface.$Identifier
    >,
  ): Either<Error, readonly IriIdentifierInterface[]> {
    return this.$objectsSync<
      IriIdentifierInterface,
      IriIdentifierInterface.$Filter,
      IriIdentifierInterface.$Identifier
    >(
      {
        $filter: IriIdentifierInterface.$filter,
        $fromRdf: IriIdentifierInterface.$fromRdf,
        $fromRdfTypes: [IriIdentifierInterface.$fromRdfType],
      },
      query,
    );
  }

  async jsPrimitiveUnionPropertyClass(
    identifier: JsPrimitiveUnionPropertyClass.$Identifier,
  ): Promise<Either<Error, JsPrimitiveUnionPropertyClass>> {
    return this.jsPrimitiveUnionPropertyClassSync(identifier);
  }

  jsPrimitiveUnionPropertyClassSync(
    identifier: JsPrimitiveUnionPropertyClass.$Identifier,
  ): Either<Error, JsPrimitiveUnionPropertyClass> {
    return this.jsPrimitiveUnionPropertyClassesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async jsPrimitiveUnionPropertyClassIdentifiers(
    query?: $ObjectSet.Query<
      JsPrimitiveUnionPropertyClass.$Filter,
      JsPrimitiveUnionPropertyClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly JsPrimitiveUnionPropertyClass.$Identifier[]>
  > {
    return this.jsPrimitiveUnionPropertyClassIdentifiersSync(query);
  }

  jsPrimitiveUnionPropertyClassIdentifiersSync(
    query?: $ObjectSet.Query<
      JsPrimitiveUnionPropertyClass.$Filter,
      JsPrimitiveUnionPropertyClass.$Identifier
    >,
  ): Either<Error, readonly JsPrimitiveUnionPropertyClass.$Identifier[]> {
    return this.jsPrimitiveUnionPropertyClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async jsPrimitiveUnionPropertyClasses(
    query?: $ObjectSet.Query<
      JsPrimitiveUnionPropertyClass.$Filter,
      JsPrimitiveUnionPropertyClass.$Identifier
    >,
  ): Promise<Either<Error, readonly JsPrimitiveUnionPropertyClass[]>> {
    return this.jsPrimitiveUnionPropertyClassesSync(query);
  }

  async jsPrimitiveUnionPropertyClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        JsPrimitiveUnionPropertyClass.$Filter,
        JsPrimitiveUnionPropertyClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.jsPrimitiveUnionPropertyClassesCountSync(query);
  }

  jsPrimitiveUnionPropertyClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        JsPrimitiveUnionPropertyClass.$Filter,
        JsPrimitiveUnionPropertyClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.jsPrimitiveUnionPropertyClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  jsPrimitiveUnionPropertyClassesSync(
    query?: $ObjectSet.Query<
      JsPrimitiveUnionPropertyClass.$Filter,
      JsPrimitiveUnionPropertyClass.$Identifier
    >,
  ): Either<Error, readonly JsPrimitiveUnionPropertyClass[]> {
    return this.$objectsSync<
      JsPrimitiveUnionPropertyClass,
      JsPrimitiveUnionPropertyClass.$Filter,
      JsPrimitiveUnionPropertyClass.$Identifier
    >(
      {
        $filter: JsPrimitiveUnionPropertyClass.$filter,
        $fromRdf: JsPrimitiveUnionPropertyClass.$fromRdf,
        $fromRdfTypes: [JsPrimitiveUnionPropertyClass.$fromRdfType],
      },
      query,
    );
  }

  async languageInPropertiesClass(
    identifier: LanguageInPropertiesClass.$Identifier,
  ): Promise<Either<Error, LanguageInPropertiesClass>> {
    return this.languageInPropertiesClassSync(identifier);
  }

  languageInPropertiesClassSync(
    identifier: LanguageInPropertiesClass.$Identifier,
  ): Either<Error, LanguageInPropertiesClass> {
    return this.languageInPropertiesClassesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async languageInPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      LanguageInPropertiesClass.$Filter,
      LanguageInPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly LanguageInPropertiesClass.$Identifier[]>> {
    return this.languageInPropertiesClassIdentifiersSync(query);
  }

  languageInPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<
      LanguageInPropertiesClass.$Filter,
      LanguageInPropertiesClass.$Identifier
    >,
  ): Either<Error, readonly LanguageInPropertiesClass.$Identifier[]> {
    return this.languageInPropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async languageInPropertiesClasses(
    query?: $ObjectSet.Query<
      LanguageInPropertiesClass.$Filter,
      LanguageInPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly LanguageInPropertiesClass[]>> {
    return this.languageInPropertiesClassesSync(query);
  }

  async languageInPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        LanguageInPropertiesClass.$Filter,
        LanguageInPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.languageInPropertiesClassesCountSync(query);
  }

  languageInPropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        LanguageInPropertiesClass.$Filter,
        LanguageInPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.languageInPropertiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  languageInPropertiesClassesSync(
    query?: $ObjectSet.Query<
      LanguageInPropertiesClass.$Filter,
      LanguageInPropertiesClass.$Identifier
    >,
  ): Either<Error, readonly LanguageInPropertiesClass[]> {
    return this.$objectsSync<
      LanguageInPropertiesClass,
      LanguageInPropertiesClass.$Filter,
      LanguageInPropertiesClass.$Identifier
    >(
      {
        $filter: LanguageInPropertiesClass.$filter,
        $fromRdf: LanguageInPropertiesClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClass(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<Either<Error, LazilyResolvedBlankNodeOrIriIdentifierClass>> {
    return this.lazilyResolvedBlankNodeOrIriIdentifierClassSync(identifier);
  }

  lazilyResolvedBlankNodeOrIriIdentifierClassSync(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
  ): Either<Error, LazilyResolvedBlankNodeOrIriIdentifierClass> {
    return this.lazilyResolvedBlankNodeOrIriIdentifierClassesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
    >,
  ): Promise<
    Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier[]
    >
  > {
    return this.lazilyResolvedBlankNodeOrIriIdentifierClassIdentifiersSync(
      query,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
    >,
  ): Either<
    Error,
    readonly LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier[]
  > {
    return this.lazilyResolvedBlankNodeOrIriIdentifierClassesSync(query).map(
      (objects) => objects.map((object) => object.$identifier),
    );
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClasses(
    query?: $ObjectSet.Query<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedBlankNodeOrIriIdentifierClass[]>
  > {
    return this.lazilyResolvedBlankNodeOrIriIdentifierClassesSync(query);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.lazilyResolvedBlankNodeOrIriIdentifierClassesCountSync(query);
  }

  lazilyResolvedBlankNodeOrIriIdentifierClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.lazilyResolvedBlankNodeOrIriIdentifierClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierClassesSync(
    query?: $ObjectSet.Query<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
    >,
  ): Either<Error, readonly LazilyResolvedBlankNodeOrIriIdentifierClass[]> {
    return this.$objectsSync<
      LazilyResolvedBlankNodeOrIriIdentifierClass,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
    >(
      {
        $filter: LazilyResolvedBlankNodeOrIriIdentifierClass.$filter,
        $fromRdf: LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdf,
        $fromRdfTypes: [
          LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdfType,
        ],
      },
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterface(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<Either<Error, LazilyResolvedBlankNodeOrIriIdentifierInterface>> {
    return this.lazilyResolvedBlankNodeOrIriIdentifierInterfaceSync(identifier);
  }

  lazilyResolvedBlankNodeOrIriIdentifierInterfaceSync(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
  ): Either<Error, LazilyResolvedBlankNodeOrIriIdentifierInterface> {
    return this.lazilyResolvedBlankNodeOrIriIdentifierInterfacesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
    >,
  ): Promise<
    Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier[]
    >
  > {
    return this.lazilyResolvedBlankNodeOrIriIdentifierInterfaceIdentifiersSync(
      query,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
    >,
  ): Either<
    Error,
    readonly LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier[]
  > {
    return this.lazilyResolvedBlankNodeOrIriIdentifierInterfacesSync(query).map(
      (objects) => objects.map((object) => object.$identifier),
    );
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterfaces(
    query?: $ObjectSet.Query<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[]>
  > {
    return this.lazilyResolvedBlankNodeOrIriIdentifierInterfacesSync(query);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.lazilyResolvedBlankNodeOrIriIdentifierInterfacesCountSync(
      query,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.lazilyResolvedBlankNodeOrIriIdentifierInterfacesSync(query).map(
      (objects) => objects.length,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierInterfacesSync(
    query?: $ObjectSet.Query<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
    >,
  ): Either<Error, readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[]> {
    return this.$objectsSync<
      LazilyResolvedBlankNodeOrIriIdentifierInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
    >(
      {
        $filter: LazilyResolvedBlankNodeOrIriIdentifierInterface.$filter,
        $fromRdf: LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdf,
        $fromRdfTypes: [
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdfType,
        ],
      },
      query,
    );
  }

  async lazilyResolvedClassUnionMember1(
    identifier: LazilyResolvedClassUnionMember1.$Identifier,
  ): Promise<Either<Error, LazilyResolvedClassUnionMember1>> {
    return this.lazilyResolvedClassUnionMember1Sync(identifier);
  }

  lazilyResolvedClassUnionMember1Sync(
    identifier: LazilyResolvedClassUnionMember1.$Identifier,
  ): Either<Error, LazilyResolvedClassUnionMember1> {
    return this.lazilyResolvedClassUnionMember1sSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<
      LazilyResolvedClassUnionMember1.$Filter,
      LazilyResolvedClassUnionMember1.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedClassUnionMember1.$Identifier[]>
  > {
    return this.lazilyResolvedClassUnionMember1IdentifiersSync(query);
  }

  lazilyResolvedClassUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<
      LazilyResolvedClassUnionMember1.$Filter,
      LazilyResolvedClassUnionMember1.$Identifier
    >,
  ): Either<Error, readonly LazilyResolvedClassUnionMember1.$Identifier[]> {
    return this.lazilyResolvedClassUnionMember1sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async lazilyResolvedClassUnionMember1s(
    query?: $ObjectSet.Query<
      LazilyResolvedClassUnionMember1.$Filter,
      LazilyResolvedClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedClassUnionMember1[]>> {
    return this.lazilyResolvedClassUnionMember1sSync(query);
  }

  async lazilyResolvedClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedClassUnionMember1.$Filter,
        LazilyResolvedClassUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.lazilyResolvedClassUnionMember1sCountSync(query);
  }

  lazilyResolvedClassUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedClassUnionMember1.$Filter,
        LazilyResolvedClassUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.lazilyResolvedClassUnionMember1sSync(query).map(
      (objects) => objects.length,
    );
  }

  lazilyResolvedClassUnionMember1sSync(
    query?: $ObjectSet.Query<
      LazilyResolvedClassUnionMember1.$Filter,
      LazilyResolvedClassUnionMember1.$Identifier
    >,
  ): Either<Error, readonly LazilyResolvedClassUnionMember1[]> {
    return this.$objectsSync<
      LazilyResolvedClassUnionMember1,
      LazilyResolvedClassUnionMember1.$Filter,
      LazilyResolvedClassUnionMember1.$Identifier
    >(
      {
        $filter: LazilyResolvedClassUnionMember1.$filter,
        $fromRdf: LazilyResolvedClassUnionMember1.$fromRdf,
        $fromRdfTypes: [LazilyResolvedClassUnionMember1.$fromRdfType],
      },
      query,
    );
  }

  async lazilyResolvedClassUnionMember2(
    identifier: LazilyResolvedClassUnionMember2.$Identifier,
  ): Promise<Either<Error, LazilyResolvedClassUnionMember2>> {
    return this.lazilyResolvedClassUnionMember2Sync(identifier);
  }

  lazilyResolvedClassUnionMember2Sync(
    identifier: LazilyResolvedClassUnionMember2.$Identifier,
  ): Either<Error, LazilyResolvedClassUnionMember2> {
    return this.lazilyResolvedClassUnionMember2sSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<
      LazilyResolvedClassUnionMember2.$Filter,
      LazilyResolvedClassUnionMember2.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedClassUnionMember2.$Identifier[]>
  > {
    return this.lazilyResolvedClassUnionMember2IdentifiersSync(query);
  }

  lazilyResolvedClassUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<
      LazilyResolvedClassUnionMember2.$Filter,
      LazilyResolvedClassUnionMember2.$Identifier
    >,
  ): Either<Error, readonly LazilyResolvedClassUnionMember2.$Identifier[]> {
    return this.lazilyResolvedClassUnionMember2sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async lazilyResolvedClassUnionMember2s(
    query?: $ObjectSet.Query<
      LazilyResolvedClassUnionMember2.$Filter,
      LazilyResolvedClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedClassUnionMember2[]>> {
    return this.lazilyResolvedClassUnionMember2sSync(query);
  }

  async lazilyResolvedClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedClassUnionMember2.$Filter,
        LazilyResolvedClassUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.lazilyResolvedClassUnionMember2sCountSync(query);
  }

  lazilyResolvedClassUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedClassUnionMember2.$Filter,
        LazilyResolvedClassUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.lazilyResolvedClassUnionMember2sSync(query).map(
      (objects) => objects.length,
    );
  }

  lazilyResolvedClassUnionMember2sSync(
    query?: $ObjectSet.Query<
      LazilyResolvedClassUnionMember2.$Filter,
      LazilyResolvedClassUnionMember2.$Identifier
    >,
  ): Either<Error, readonly LazilyResolvedClassUnionMember2[]> {
    return this.$objectsSync<
      LazilyResolvedClassUnionMember2,
      LazilyResolvedClassUnionMember2.$Filter,
      LazilyResolvedClassUnionMember2.$Identifier
    >(
      {
        $filter: LazilyResolvedClassUnionMember2.$filter,
        $fromRdf: LazilyResolvedClassUnionMember2.$fromRdf,
        $fromRdfTypes: [LazilyResolvedClassUnionMember2.$fromRdfType],
      },
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember1(
    identifier: LazilyResolvedInterfaceUnionMember1.$Identifier,
  ): Promise<Either<Error, LazilyResolvedInterfaceUnionMember1>> {
    return this.lazilyResolvedInterfaceUnionMember1Sync(identifier);
  }

  lazilyResolvedInterfaceUnionMember1Sync(
    identifier: LazilyResolvedInterfaceUnionMember1.$Identifier,
  ): Either<Error, LazilyResolvedInterfaceUnionMember1> {
    return this.lazilyResolvedInterfaceUnionMember1sSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<
      LazilyResolvedInterfaceUnionMember1.$Filter,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedInterfaceUnionMember1.$Identifier[]>
  > {
    return this.lazilyResolvedInterfaceUnionMember1IdentifiersSync(query);
  }

  lazilyResolvedInterfaceUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<
      LazilyResolvedInterfaceUnionMember1.$Filter,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >,
  ): Either<Error, readonly LazilyResolvedInterfaceUnionMember1.$Identifier[]> {
    return this.lazilyResolvedInterfaceUnionMember1sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async lazilyResolvedInterfaceUnionMember1s(
    query?: $ObjectSet.Query<
      LazilyResolvedInterfaceUnionMember1.$Filter,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedInterfaceUnionMember1[]>> {
    return this.lazilyResolvedInterfaceUnionMember1sSync(query);
  }

  async lazilyResolvedInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedInterfaceUnionMember1.$Filter,
        LazilyResolvedInterfaceUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.lazilyResolvedInterfaceUnionMember1sCountSync(query);
  }

  lazilyResolvedInterfaceUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedInterfaceUnionMember1.$Filter,
        LazilyResolvedInterfaceUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.lazilyResolvedInterfaceUnionMember1sSync(query).map(
      (objects) => objects.length,
    );
  }

  lazilyResolvedInterfaceUnionMember1sSync(
    query?: $ObjectSet.Query<
      LazilyResolvedInterfaceUnionMember1.$Filter,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >,
  ): Either<Error, readonly LazilyResolvedInterfaceUnionMember1[]> {
    return this.$objectsSync<
      LazilyResolvedInterfaceUnionMember1,
      LazilyResolvedInterfaceUnionMember1.$Filter,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >(
      {
        $filter: LazilyResolvedInterfaceUnionMember1.$filter,
        $fromRdf: LazilyResolvedInterfaceUnionMember1.$fromRdf,
        $fromRdfTypes: [LazilyResolvedInterfaceUnionMember1.$fromRdfType],
      },
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember2(
    identifier: LazilyResolvedInterfaceUnionMember2.$Identifier,
  ): Promise<Either<Error, LazilyResolvedInterfaceUnionMember2>> {
    return this.lazilyResolvedInterfaceUnionMember2Sync(identifier);
  }

  lazilyResolvedInterfaceUnionMember2Sync(
    identifier: LazilyResolvedInterfaceUnionMember2.$Identifier,
  ): Either<Error, LazilyResolvedInterfaceUnionMember2> {
    return this.lazilyResolvedInterfaceUnionMember2sSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<
      LazilyResolvedInterfaceUnionMember2.$Filter,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedInterfaceUnionMember2.$Identifier[]>
  > {
    return this.lazilyResolvedInterfaceUnionMember2IdentifiersSync(query);
  }

  lazilyResolvedInterfaceUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<
      LazilyResolvedInterfaceUnionMember2.$Filter,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >,
  ): Either<Error, readonly LazilyResolvedInterfaceUnionMember2.$Identifier[]> {
    return this.lazilyResolvedInterfaceUnionMember2sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async lazilyResolvedInterfaceUnionMember2s(
    query?: $ObjectSet.Query<
      LazilyResolvedInterfaceUnionMember2.$Filter,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedInterfaceUnionMember2[]>> {
    return this.lazilyResolvedInterfaceUnionMember2sSync(query);
  }

  async lazilyResolvedInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedInterfaceUnionMember2.$Filter,
        LazilyResolvedInterfaceUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.lazilyResolvedInterfaceUnionMember2sCountSync(query);
  }

  lazilyResolvedInterfaceUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedInterfaceUnionMember2.$Filter,
        LazilyResolvedInterfaceUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.lazilyResolvedInterfaceUnionMember2sSync(query).map(
      (objects) => objects.length,
    );
  }

  lazilyResolvedInterfaceUnionMember2sSync(
    query?: $ObjectSet.Query<
      LazilyResolvedInterfaceUnionMember2.$Filter,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >,
  ): Either<Error, readonly LazilyResolvedInterfaceUnionMember2[]> {
    return this.$objectsSync<
      LazilyResolvedInterfaceUnionMember2,
      LazilyResolvedInterfaceUnionMember2.$Filter,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >(
      {
        $filter: LazilyResolvedInterfaceUnionMember2.$filter,
        $fromRdf: LazilyResolvedInterfaceUnionMember2.$fromRdf,
        $fromRdfTypes: [LazilyResolvedInterfaceUnionMember2.$fromRdfType],
      },
      query,
    );
  }

  async lazilyResolvedIriIdentifierClass(
    identifier: LazilyResolvedIriIdentifierClass.$Identifier,
  ): Promise<Either<Error, LazilyResolvedIriIdentifierClass>> {
    return this.lazilyResolvedIriIdentifierClassSync(identifier);
  }

  lazilyResolvedIriIdentifierClassSync(
    identifier: LazilyResolvedIriIdentifierClass.$Identifier,
  ): Either<Error, LazilyResolvedIriIdentifierClass> {
    return this.lazilyResolvedIriIdentifierClassesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<
      LazilyResolvedIriIdentifierClass.$Filter,
      LazilyResolvedIriIdentifierClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedIriIdentifierClass.$Identifier[]>
  > {
    return this.lazilyResolvedIriIdentifierClassIdentifiersSync(query);
  }

  lazilyResolvedIriIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<
      LazilyResolvedIriIdentifierClass.$Filter,
      LazilyResolvedIriIdentifierClass.$Identifier
    >,
  ): Either<Error, readonly LazilyResolvedIriIdentifierClass.$Identifier[]> {
    return this.lazilyResolvedIriIdentifierClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async lazilyResolvedIriIdentifierClasses(
    query?: $ObjectSet.Query<
      LazilyResolvedIriIdentifierClass.$Filter,
      LazilyResolvedIriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedIriIdentifierClass[]>> {
    return this.lazilyResolvedIriIdentifierClassesSync(query);
  }

  async lazilyResolvedIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedIriIdentifierClass.$Filter,
        LazilyResolvedIriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.lazilyResolvedIriIdentifierClassesCountSync(query);
  }

  lazilyResolvedIriIdentifierClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedIriIdentifierClass.$Filter,
        LazilyResolvedIriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.lazilyResolvedIriIdentifierClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  lazilyResolvedIriIdentifierClassesSync(
    query?: $ObjectSet.Query<
      LazilyResolvedIriIdentifierClass.$Filter,
      LazilyResolvedIriIdentifierClass.$Identifier
    >,
  ): Either<Error, readonly LazilyResolvedIriIdentifierClass[]> {
    return this.$objectsSync<
      LazilyResolvedIriIdentifierClass,
      LazilyResolvedIriIdentifierClass.$Filter,
      LazilyResolvedIriIdentifierClass.$Identifier
    >(
      {
        $filter: LazilyResolvedIriIdentifierClass.$filter,
        $fromRdf: LazilyResolvedIriIdentifierClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async lazilyResolvedIriIdentifierInterface(
    identifier: LazilyResolvedIriIdentifierInterface.$Identifier,
  ): Promise<Either<Error, LazilyResolvedIriIdentifierInterface>> {
    return this.lazilyResolvedIriIdentifierInterfaceSync(identifier);
  }

  lazilyResolvedIriIdentifierInterfaceSync(
    identifier: LazilyResolvedIriIdentifierInterface.$Identifier,
  ): Either<Error, LazilyResolvedIriIdentifierInterface> {
    return this.lazilyResolvedIriIdentifierInterfacesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<
      LazilyResolvedIriIdentifierInterface.$Filter,
      LazilyResolvedIriIdentifierInterface.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedIriIdentifierInterface.$Identifier[]>
  > {
    return this.lazilyResolvedIriIdentifierInterfaceIdentifiersSync(query);
  }

  lazilyResolvedIriIdentifierInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<
      LazilyResolvedIriIdentifierInterface.$Filter,
      LazilyResolvedIriIdentifierInterface.$Identifier
    >,
  ): Either<
    Error,
    readonly LazilyResolvedIriIdentifierInterface.$Identifier[]
  > {
    return this.lazilyResolvedIriIdentifierInterfacesSync(query).map(
      (objects) => objects.map((object) => object.$identifier),
    );
  }

  async lazilyResolvedIriIdentifierInterfaces(
    query?: $ObjectSet.Query<
      LazilyResolvedIriIdentifierInterface.$Filter,
      LazilyResolvedIriIdentifierInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedIriIdentifierInterface[]>> {
    return this.lazilyResolvedIriIdentifierInterfacesSync(query);
  }

  async lazilyResolvedIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedIriIdentifierInterface.$Filter,
        LazilyResolvedIriIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.lazilyResolvedIriIdentifierInterfacesCountSync(query);
  }

  lazilyResolvedIriIdentifierInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedIriIdentifierInterface.$Filter,
        LazilyResolvedIriIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.lazilyResolvedIriIdentifierInterfacesSync(query).map(
      (objects) => objects.length,
    );
  }

  lazilyResolvedIriIdentifierInterfacesSync(
    query?: $ObjectSet.Query<
      LazilyResolvedIriIdentifierInterface.$Filter,
      LazilyResolvedIriIdentifierInterface.$Identifier
    >,
  ): Either<Error, readonly LazilyResolvedIriIdentifierInterface[]> {
    return this.$objectsSync<
      LazilyResolvedIriIdentifierInterface,
      LazilyResolvedIriIdentifierInterface.$Filter,
      LazilyResolvedIriIdentifierInterface.$Identifier
    >(
      {
        $filter: LazilyResolvedIriIdentifierInterface.$filter,
        $fromRdf: LazilyResolvedIriIdentifierInterface.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async lazyPropertiesClass(
    identifier: LazyPropertiesClass.$Identifier,
  ): Promise<Either<Error, LazyPropertiesClass>> {
    return this.lazyPropertiesClassSync(identifier);
  }

  lazyPropertiesClassSync(
    identifier: LazyPropertiesClass.$Identifier,
  ): Either<Error, LazyPropertiesClass> {
    return this.lazyPropertiesClassesSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async lazyPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      LazyPropertiesClass.$Filter,
      LazyPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly LazyPropertiesClass.$Identifier[]>> {
    return this.lazyPropertiesClassIdentifiersSync(query);
  }

  lazyPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<
      LazyPropertiesClass.$Filter,
      LazyPropertiesClass.$Identifier
    >,
  ): Either<Error, readonly LazyPropertiesClass.$Identifier[]> {
    return this.lazyPropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async lazyPropertiesClasses(
    query?: $ObjectSet.Query<
      LazyPropertiesClass.$Filter,
      LazyPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly LazyPropertiesClass[]>> {
    return this.lazyPropertiesClassesSync(query);
  }

  async lazyPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        LazyPropertiesClass.$Filter,
        LazyPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.lazyPropertiesClassesCountSync(query);
  }

  lazyPropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        LazyPropertiesClass.$Filter,
        LazyPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.lazyPropertiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  lazyPropertiesClassesSync(
    query?: $ObjectSet.Query<
      LazyPropertiesClass.$Filter,
      LazyPropertiesClass.$Identifier
    >,
  ): Either<Error, readonly LazyPropertiesClass[]> {
    return this.$objectsSync<
      LazyPropertiesClass,
      LazyPropertiesClass.$Filter,
      LazyPropertiesClass.$Identifier
    >(
      {
        $filter: LazyPropertiesClass.$filter,
        $fromRdf: LazyPropertiesClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async lazyPropertiesInterface(
    identifier: LazyPropertiesInterface.$Identifier,
  ): Promise<Either<Error, LazyPropertiesInterface>> {
    return this.lazyPropertiesInterfaceSync(identifier);
  }

  lazyPropertiesInterfaceSync(
    identifier: LazyPropertiesInterface.$Identifier,
  ): Either<Error, LazyPropertiesInterface> {
    return this.lazyPropertiesInterfacesSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async lazyPropertiesInterfaceIdentifiers(
    query?: $ObjectSet.Query<
      LazyPropertiesInterface.$Filter,
      LazyPropertiesInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly LazyPropertiesInterface.$Identifier[]>> {
    return this.lazyPropertiesInterfaceIdentifiersSync(query);
  }

  lazyPropertiesInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<
      LazyPropertiesInterface.$Filter,
      LazyPropertiesInterface.$Identifier
    >,
  ): Either<Error, readonly LazyPropertiesInterface.$Identifier[]> {
    return this.lazyPropertiesInterfacesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async lazyPropertiesInterfaces(
    query?: $ObjectSet.Query<
      LazyPropertiesInterface.$Filter,
      LazyPropertiesInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly LazyPropertiesInterface[]>> {
    return this.lazyPropertiesInterfacesSync(query);
  }

  async lazyPropertiesInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<
        LazyPropertiesInterface.$Filter,
        LazyPropertiesInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.lazyPropertiesInterfacesCountSync(query);
  }

  lazyPropertiesInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        LazyPropertiesInterface.$Filter,
        LazyPropertiesInterface.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.lazyPropertiesInterfacesSync(query).map(
      (objects) => objects.length,
    );
  }

  lazyPropertiesInterfacesSync(
    query?: $ObjectSet.Query<
      LazyPropertiesInterface.$Filter,
      LazyPropertiesInterface.$Identifier
    >,
  ): Either<Error, readonly LazyPropertiesInterface[]> {
    return this.$objectsSync<
      LazyPropertiesInterface,
      LazyPropertiesInterface.$Filter,
      LazyPropertiesInterface.$Identifier
    >(
      {
        $filter: LazyPropertiesInterface.$filter,
        $fromRdf: LazyPropertiesInterface.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async listPropertiesClass(
    identifier: ListPropertiesClass.$Identifier,
  ): Promise<Either<Error, ListPropertiesClass>> {
    return this.listPropertiesClassSync(identifier);
  }

  listPropertiesClassSync(
    identifier: ListPropertiesClass.$Identifier,
  ): Either<Error, ListPropertiesClass> {
    return this.listPropertiesClassesSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async listPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      ListPropertiesClass.$Filter,
      ListPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ListPropertiesClass.$Identifier[]>> {
    return this.listPropertiesClassIdentifiersSync(query);
  }

  listPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<
      ListPropertiesClass.$Filter,
      ListPropertiesClass.$Identifier
    >,
  ): Either<Error, readonly ListPropertiesClass.$Identifier[]> {
    return this.listPropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async listPropertiesClasses(
    query?: $ObjectSet.Query<
      ListPropertiesClass.$Filter,
      ListPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ListPropertiesClass[]>> {
    return this.listPropertiesClassesSync(query);
  }

  async listPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        ListPropertiesClass.$Filter,
        ListPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.listPropertiesClassesCountSync(query);
  }

  listPropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        ListPropertiesClass.$Filter,
        ListPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.listPropertiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  listPropertiesClassesSync(
    query?: $ObjectSet.Query<
      ListPropertiesClass.$Filter,
      ListPropertiesClass.$Identifier
    >,
  ): Either<Error, readonly ListPropertiesClass[]> {
    return this.$objectsSync<
      ListPropertiesClass,
      ListPropertiesClass.$Filter,
      ListPropertiesClass.$Identifier
    >(
      {
        $filter: ListPropertiesClass.$filter,
        $fromRdf: ListPropertiesClass.$fromRdf,
        $fromRdfTypes: [ListPropertiesClass.$fromRdfType],
      },
      query,
    );
  }

  async mutablePropertiesClass(
    identifier: MutablePropertiesClass.$Identifier,
  ): Promise<Either<Error, MutablePropertiesClass>> {
    return this.mutablePropertiesClassSync(identifier);
  }

  mutablePropertiesClassSync(
    identifier: MutablePropertiesClass.$Identifier,
  ): Either<Error, MutablePropertiesClass> {
    return this.mutablePropertiesClassesSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async mutablePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      MutablePropertiesClass.$Filter,
      MutablePropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly MutablePropertiesClass.$Identifier[]>> {
    return this.mutablePropertiesClassIdentifiersSync(query);
  }

  mutablePropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<
      MutablePropertiesClass.$Filter,
      MutablePropertiesClass.$Identifier
    >,
  ): Either<Error, readonly MutablePropertiesClass.$Identifier[]> {
    return this.mutablePropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async mutablePropertiesClasses(
    query?: $ObjectSet.Query<
      MutablePropertiesClass.$Filter,
      MutablePropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly MutablePropertiesClass[]>> {
    return this.mutablePropertiesClassesSync(query);
  }

  async mutablePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        MutablePropertiesClass.$Filter,
        MutablePropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.mutablePropertiesClassesCountSync(query);
  }

  mutablePropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        MutablePropertiesClass.$Filter,
        MutablePropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.mutablePropertiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  mutablePropertiesClassesSync(
    query?: $ObjectSet.Query<
      MutablePropertiesClass.$Filter,
      MutablePropertiesClass.$Identifier
    >,
  ): Either<Error, readonly MutablePropertiesClass[]> {
    return this.$objectsSync<
      MutablePropertiesClass,
      MutablePropertiesClass.$Filter,
      MutablePropertiesClass.$Identifier
    >(
      {
        $filter: MutablePropertiesClass.$filter,
        $fromRdf: MutablePropertiesClass.$fromRdf,
        $fromRdfTypes: [MutablePropertiesClass.$fromRdfType],
      },
      query,
    );
  }

  async nonClass(
    identifier: NonClass.$Identifier,
  ): Promise<Either<Error, NonClass>> {
    return this.nonClassSync(identifier);
  }

  nonClassSync(identifier: NonClass.$Identifier): Either<Error, NonClass> {
    return this.nonClassesSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async nonClassIdentifiers(
    query?: $ObjectSet.Query<NonClass.$Filter, NonClass.$Identifier>,
  ): Promise<Either<Error, readonly NonClass.$Identifier[]>> {
    return this.nonClassIdentifiersSync(query);
  }

  nonClassIdentifiersSync(
    query?: $ObjectSet.Query<NonClass.$Filter, NonClass.$Identifier>,
  ): Either<Error, readonly NonClass.$Identifier[]> {
    return this.nonClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async nonClasses(
    query?: $ObjectSet.Query<NonClass.$Filter, NonClass.$Identifier>,
  ): Promise<Either<Error, readonly NonClass[]>> {
    return this.nonClassesSync(query);
  }

  async nonClassesCount(
    query?: Pick<
      $ObjectSet.Query<NonClass.$Filter, NonClass.$Identifier>,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.nonClassesCountSync(query);
  }

  nonClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<NonClass.$Filter, NonClass.$Identifier>,
      "filter"
    >,
  ): Either<Error, number> {
    return this.nonClassesSync(query).map((objects) => objects.length);
  }

  nonClassesSync(
    query?: $ObjectSet.Query<NonClass.$Filter, NonClass.$Identifier>,
  ): Either<Error, readonly NonClass[]> {
    return this.$objectsSync<NonClass, NonClass.$Filter, NonClass.$Identifier>(
      {
        $filter: NonClass.$filter,
        $fromRdf: NonClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async noRdfTypeClassUnionMember1(
    identifier: NoRdfTypeClassUnionMember1.$Identifier,
  ): Promise<Either<Error, NoRdfTypeClassUnionMember1>> {
    return this.noRdfTypeClassUnionMember1Sync(identifier);
  }

  noRdfTypeClassUnionMember1Sync(
    identifier: NoRdfTypeClassUnionMember1.$Identifier,
  ): Either<Error, NoRdfTypeClassUnionMember1> {
    return this.noRdfTypeClassUnionMember1sSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async noRdfTypeClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<
      NoRdfTypeClassUnionMember1.$Filter,
      NoRdfTypeClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly NoRdfTypeClassUnionMember1.$Identifier[]>> {
    return this.noRdfTypeClassUnionMember1IdentifiersSync(query);
  }

  noRdfTypeClassUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<
      NoRdfTypeClassUnionMember1.$Filter,
      NoRdfTypeClassUnionMember1.$Identifier
    >,
  ): Either<Error, readonly NoRdfTypeClassUnionMember1.$Identifier[]> {
    return this.noRdfTypeClassUnionMember1sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async noRdfTypeClassUnionMember1s(
    query?: $ObjectSet.Query<
      NoRdfTypeClassUnionMember1.$Filter,
      NoRdfTypeClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly NoRdfTypeClassUnionMember1[]>> {
    return this.noRdfTypeClassUnionMember1sSync(query);
  }

  async noRdfTypeClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<
        NoRdfTypeClassUnionMember1.$Filter,
        NoRdfTypeClassUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.noRdfTypeClassUnionMember1sCountSync(query);
  }

  noRdfTypeClassUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<
        NoRdfTypeClassUnionMember1.$Filter,
        NoRdfTypeClassUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.noRdfTypeClassUnionMember1sSync(query).map(
      (objects) => objects.length,
    );
  }

  noRdfTypeClassUnionMember1sSync(
    query?: $ObjectSet.Query<
      NoRdfTypeClassUnionMember1.$Filter,
      NoRdfTypeClassUnionMember1.$Identifier
    >,
  ): Either<Error, readonly NoRdfTypeClassUnionMember1[]> {
    return this.$objectsSync<
      NoRdfTypeClassUnionMember1,
      NoRdfTypeClassUnionMember1.$Filter,
      NoRdfTypeClassUnionMember1.$Identifier
    >(
      {
        $filter: NoRdfTypeClassUnionMember1.$filter,
        $fromRdf: NoRdfTypeClassUnionMember1.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async noRdfTypeClassUnionMember2(
    identifier: NoRdfTypeClassUnionMember2.$Identifier,
  ): Promise<Either<Error, NoRdfTypeClassUnionMember2>> {
    return this.noRdfTypeClassUnionMember2Sync(identifier);
  }

  noRdfTypeClassUnionMember2Sync(
    identifier: NoRdfTypeClassUnionMember2.$Identifier,
  ): Either<Error, NoRdfTypeClassUnionMember2> {
    return this.noRdfTypeClassUnionMember2sSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async noRdfTypeClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<
      NoRdfTypeClassUnionMember2.$Filter,
      NoRdfTypeClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly NoRdfTypeClassUnionMember2.$Identifier[]>> {
    return this.noRdfTypeClassUnionMember2IdentifiersSync(query);
  }

  noRdfTypeClassUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<
      NoRdfTypeClassUnionMember2.$Filter,
      NoRdfTypeClassUnionMember2.$Identifier
    >,
  ): Either<Error, readonly NoRdfTypeClassUnionMember2.$Identifier[]> {
    return this.noRdfTypeClassUnionMember2sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async noRdfTypeClassUnionMember2s(
    query?: $ObjectSet.Query<
      NoRdfTypeClassUnionMember2.$Filter,
      NoRdfTypeClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly NoRdfTypeClassUnionMember2[]>> {
    return this.noRdfTypeClassUnionMember2sSync(query);
  }

  async noRdfTypeClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<
        NoRdfTypeClassUnionMember2.$Filter,
        NoRdfTypeClassUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.noRdfTypeClassUnionMember2sCountSync(query);
  }

  noRdfTypeClassUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<
        NoRdfTypeClassUnionMember2.$Filter,
        NoRdfTypeClassUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.noRdfTypeClassUnionMember2sSync(query).map(
      (objects) => objects.length,
    );
  }

  noRdfTypeClassUnionMember2sSync(
    query?: $ObjectSet.Query<
      NoRdfTypeClassUnionMember2.$Filter,
      NoRdfTypeClassUnionMember2.$Identifier
    >,
  ): Either<Error, readonly NoRdfTypeClassUnionMember2[]> {
    return this.$objectsSync<
      NoRdfTypeClassUnionMember2,
      NoRdfTypeClassUnionMember2.$Filter,
      NoRdfTypeClassUnionMember2.$Identifier
    >(
      {
        $filter: NoRdfTypeClassUnionMember2.$filter,
        $fromRdf: NoRdfTypeClassUnionMember2.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async orderedPropertiesClass(
    identifier: OrderedPropertiesClass.$Identifier,
  ): Promise<Either<Error, OrderedPropertiesClass>> {
    return this.orderedPropertiesClassSync(identifier);
  }

  orderedPropertiesClassSync(
    identifier: OrderedPropertiesClass.$Identifier,
  ): Either<Error, OrderedPropertiesClass> {
    return this.orderedPropertiesClassesSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async orderedPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      OrderedPropertiesClass.$Filter,
      OrderedPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly OrderedPropertiesClass.$Identifier[]>> {
    return this.orderedPropertiesClassIdentifiersSync(query);
  }

  orderedPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<
      OrderedPropertiesClass.$Filter,
      OrderedPropertiesClass.$Identifier
    >,
  ): Either<Error, readonly OrderedPropertiesClass.$Identifier[]> {
    return this.orderedPropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async orderedPropertiesClasses(
    query?: $ObjectSet.Query<
      OrderedPropertiesClass.$Filter,
      OrderedPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly OrderedPropertiesClass[]>> {
    return this.orderedPropertiesClassesSync(query);
  }

  async orderedPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        OrderedPropertiesClass.$Filter,
        OrderedPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.orderedPropertiesClassesCountSync(query);
  }

  orderedPropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        OrderedPropertiesClass.$Filter,
        OrderedPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.orderedPropertiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  orderedPropertiesClassesSync(
    query?: $ObjectSet.Query<
      OrderedPropertiesClass.$Filter,
      OrderedPropertiesClass.$Identifier
    >,
  ): Either<Error, readonly OrderedPropertiesClass[]> {
    return this.$objectsSync<
      OrderedPropertiesClass,
      OrderedPropertiesClass.$Filter,
      OrderedPropertiesClass.$Identifier
    >(
      {
        $filter: OrderedPropertiesClass.$filter,
        $fromRdf: OrderedPropertiesClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async partialClass(
    identifier: PartialClass.$Identifier,
  ): Promise<Either<Error, PartialClass>> {
    return this.partialClassSync(identifier);
  }

  partialClassSync(
    identifier: PartialClass.$Identifier,
  ): Either<Error, PartialClass> {
    return this.partialClassesSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async partialClassIdentifiers(
    query?: $ObjectSet.Query<PartialClass.$Filter, PartialClass.$Identifier>,
  ): Promise<Either<Error, readonly PartialClass.$Identifier[]>> {
    return this.partialClassIdentifiersSync(query);
  }

  partialClassIdentifiersSync(
    query?: $ObjectSet.Query<PartialClass.$Filter, PartialClass.$Identifier>,
  ): Either<Error, readonly PartialClass.$Identifier[]> {
    return this.partialClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async partialClasses(
    query?: $ObjectSet.Query<PartialClass.$Filter, PartialClass.$Identifier>,
  ): Promise<Either<Error, readonly PartialClass[]>> {
    return this.partialClassesSync(query);
  }

  async partialClassesCount(
    query?: Pick<
      $ObjectSet.Query<PartialClass.$Filter, PartialClass.$Identifier>,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.partialClassesCountSync(query);
  }

  partialClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<PartialClass.$Filter, PartialClass.$Identifier>,
      "filter"
    >,
  ): Either<Error, number> {
    return this.partialClassesSync(query).map((objects) => objects.length);
  }

  partialClassesSync(
    query?: $ObjectSet.Query<PartialClass.$Filter, PartialClass.$Identifier>,
  ): Either<Error, readonly PartialClass[]> {
    return this.$objectsSync<
      PartialClass,
      PartialClass.$Filter,
      PartialClass.$Identifier
    >(
      {
        $filter: PartialClass.$filter,
        $fromRdf: PartialClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async partialClassUnionMember1(
    identifier: PartialClassUnionMember1.$Identifier,
  ): Promise<Either<Error, PartialClassUnionMember1>> {
    return this.partialClassUnionMember1Sync(identifier);
  }

  partialClassUnionMember1Sync(
    identifier: PartialClassUnionMember1.$Identifier,
  ): Either<Error, PartialClassUnionMember1> {
    return this.partialClassUnionMember1sSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async partialClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<
      PartialClassUnionMember1.$Filter,
      PartialClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialClassUnionMember1.$Identifier[]>> {
    return this.partialClassUnionMember1IdentifiersSync(query);
  }

  partialClassUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<
      PartialClassUnionMember1.$Filter,
      PartialClassUnionMember1.$Identifier
    >,
  ): Either<Error, readonly PartialClassUnionMember1.$Identifier[]> {
    return this.partialClassUnionMember1sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async partialClassUnionMember1s(
    query?: $ObjectSet.Query<
      PartialClassUnionMember1.$Filter,
      PartialClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialClassUnionMember1[]>> {
    return this.partialClassUnionMember1sSync(query);
  }

  async partialClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<
        PartialClassUnionMember1.$Filter,
        PartialClassUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.partialClassUnionMember1sCountSync(query);
  }

  partialClassUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<
        PartialClassUnionMember1.$Filter,
        PartialClassUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.partialClassUnionMember1sSync(query).map(
      (objects) => objects.length,
    );
  }

  partialClassUnionMember1sSync(
    query?: $ObjectSet.Query<
      PartialClassUnionMember1.$Filter,
      PartialClassUnionMember1.$Identifier
    >,
  ): Either<Error, readonly PartialClassUnionMember1[]> {
    return this.$objectsSync<
      PartialClassUnionMember1,
      PartialClassUnionMember1.$Filter,
      PartialClassUnionMember1.$Identifier
    >(
      {
        $filter: PartialClassUnionMember1.$filter,
        $fromRdf: PartialClassUnionMember1.$fromRdf,
        $fromRdfTypes: [PartialClassUnionMember1.$fromRdfType],
      },
      query,
    );
  }

  async partialClassUnionMember2(
    identifier: PartialClassUnionMember2.$Identifier,
  ): Promise<Either<Error, PartialClassUnionMember2>> {
    return this.partialClassUnionMember2Sync(identifier);
  }

  partialClassUnionMember2Sync(
    identifier: PartialClassUnionMember2.$Identifier,
  ): Either<Error, PartialClassUnionMember2> {
    return this.partialClassUnionMember2sSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async partialClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<
      PartialClassUnionMember2.$Filter,
      PartialClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialClassUnionMember2.$Identifier[]>> {
    return this.partialClassUnionMember2IdentifiersSync(query);
  }

  partialClassUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<
      PartialClassUnionMember2.$Filter,
      PartialClassUnionMember2.$Identifier
    >,
  ): Either<Error, readonly PartialClassUnionMember2.$Identifier[]> {
    return this.partialClassUnionMember2sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async partialClassUnionMember2s(
    query?: $ObjectSet.Query<
      PartialClassUnionMember2.$Filter,
      PartialClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialClassUnionMember2[]>> {
    return this.partialClassUnionMember2sSync(query);
  }

  async partialClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<
        PartialClassUnionMember2.$Filter,
        PartialClassUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.partialClassUnionMember2sCountSync(query);
  }

  partialClassUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<
        PartialClassUnionMember2.$Filter,
        PartialClassUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.partialClassUnionMember2sSync(query).map(
      (objects) => objects.length,
    );
  }

  partialClassUnionMember2sSync(
    query?: $ObjectSet.Query<
      PartialClassUnionMember2.$Filter,
      PartialClassUnionMember2.$Identifier
    >,
  ): Either<Error, readonly PartialClassUnionMember2[]> {
    return this.$objectsSync<
      PartialClassUnionMember2,
      PartialClassUnionMember2.$Filter,
      PartialClassUnionMember2.$Identifier
    >(
      {
        $filter: PartialClassUnionMember2.$filter,
        $fromRdf: PartialClassUnionMember2.$fromRdf,
        $fromRdfTypes: [PartialClassUnionMember2.$fromRdfType],
      },
      query,
    );
  }

  async partialInterface(
    identifier: PartialInterface.$Identifier,
  ): Promise<Either<Error, PartialInterface>> {
    return this.partialInterfaceSync(identifier);
  }

  partialInterfaceSync(
    identifier: PartialInterface.$Identifier,
  ): Either<Error, PartialInterface> {
    return this.partialInterfacesSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async partialInterfaceIdentifiers(
    query?: $ObjectSet.Query<
      PartialInterface.$Filter,
      PartialInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialInterface.$Identifier[]>> {
    return this.partialInterfaceIdentifiersSync(query);
  }

  partialInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<
      PartialInterface.$Filter,
      PartialInterface.$Identifier
    >,
  ): Either<Error, readonly PartialInterface.$Identifier[]> {
    return this.partialInterfacesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async partialInterfaces(
    query?: $ObjectSet.Query<
      PartialInterface.$Filter,
      PartialInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialInterface[]>> {
    return this.partialInterfacesSync(query);
  }

  async partialInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<PartialInterface.$Filter, PartialInterface.$Identifier>,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.partialInterfacesCountSync(query);
  }

  partialInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<PartialInterface.$Filter, PartialInterface.$Identifier>,
      "filter"
    >,
  ): Either<Error, number> {
    return this.partialInterfacesSync(query).map((objects) => objects.length);
  }

  partialInterfacesSync(
    query?: $ObjectSet.Query<
      PartialInterface.$Filter,
      PartialInterface.$Identifier
    >,
  ): Either<Error, readonly PartialInterface[]> {
    return this.$objectsSync<
      PartialInterface,
      PartialInterface.$Filter,
      PartialInterface.$Identifier
    >(
      {
        $filter: PartialInterface.$filter,
        $fromRdf: PartialInterface.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async partialInterfaceUnionMember1(
    identifier: PartialInterfaceUnionMember1.$Identifier,
  ): Promise<Either<Error, PartialInterfaceUnionMember1>> {
    return this.partialInterfaceUnionMember1Sync(identifier);
  }

  partialInterfaceUnionMember1Sync(
    identifier: PartialInterfaceUnionMember1.$Identifier,
  ): Either<Error, PartialInterfaceUnionMember1> {
    return this.partialInterfaceUnionMember1sSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async partialInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<
      PartialInterfaceUnionMember1.$Filter,
      PartialInterfaceUnionMember1.$Identifier
    >,
  ): Promise<
    Either<Error, readonly PartialInterfaceUnionMember1.$Identifier[]>
  > {
    return this.partialInterfaceUnionMember1IdentifiersSync(query);
  }

  partialInterfaceUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<
      PartialInterfaceUnionMember1.$Filter,
      PartialInterfaceUnionMember1.$Identifier
    >,
  ): Either<Error, readonly PartialInterfaceUnionMember1.$Identifier[]> {
    return this.partialInterfaceUnionMember1sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async partialInterfaceUnionMember1s(
    query?: $ObjectSet.Query<
      PartialInterfaceUnionMember1.$Filter,
      PartialInterfaceUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialInterfaceUnionMember1[]>> {
    return this.partialInterfaceUnionMember1sSync(query);
  }

  async partialInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<
        PartialInterfaceUnionMember1.$Filter,
        PartialInterfaceUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.partialInterfaceUnionMember1sCountSync(query);
  }

  partialInterfaceUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<
        PartialInterfaceUnionMember1.$Filter,
        PartialInterfaceUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.partialInterfaceUnionMember1sSync(query).map(
      (objects) => objects.length,
    );
  }

  partialInterfaceUnionMember1sSync(
    query?: $ObjectSet.Query<
      PartialInterfaceUnionMember1.$Filter,
      PartialInterfaceUnionMember1.$Identifier
    >,
  ): Either<Error, readonly PartialInterfaceUnionMember1[]> {
    return this.$objectsSync<
      PartialInterfaceUnionMember1,
      PartialInterfaceUnionMember1.$Filter,
      PartialInterfaceUnionMember1.$Identifier
    >(
      {
        $filter: PartialInterfaceUnionMember1.$filter,
        $fromRdf: PartialInterfaceUnionMember1.$fromRdf,
        $fromRdfTypes: [PartialInterfaceUnionMember1.$fromRdfType],
      },
      query,
    );
  }

  async partialInterfaceUnionMember2(
    identifier: PartialInterfaceUnionMember2.$Identifier,
  ): Promise<Either<Error, PartialInterfaceUnionMember2>> {
    return this.partialInterfaceUnionMember2Sync(identifier);
  }

  partialInterfaceUnionMember2Sync(
    identifier: PartialInterfaceUnionMember2.$Identifier,
  ): Either<Error, PartialInterfaceUnionMember2> {
    return this.partialInterfaceUnionMember2sSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async partialInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<
      PartialInterfaceUnionMember2.$Filter,
      PartialInterfaceUnionMember2.$Identifier
    >,
  ): Promise<
    Either<Error, readonly PartialInterfaceUnionMember2.$Identifier[]>
  > {
    return this.partialInterfaceUnionMember2IdentifiersSync(query);
  }

  partialInterfaceUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<
      PartialInterfaceUnionMember2.$Filter,
      PartialInterfaceUnionMember2.$Identifier
    >,
  ): Either<Error, readonly PartialInterfaceUnionMember2.$Identifier[]> {
    return this.partialInterfaceUnionMember2sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async partialInterfaceUnionMember2s(
    query?: $ObjectSet.Query<
      PartialInterfaceUnionMember2.$Filter,
      PartialInterfaceUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialInterfaceUnionMember2[]>> {
    return this.partialInterfaceUnionMember2sSync(query);
  }

  async partialInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<
        PartialInterfaceUnionMember2.$Filter,
        PartialInterfaceUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.partialInterfaceUnionMember2sCountSync(query);
  }

  partialInterfaceUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<
        PartialInterfaceUnionMember2.$Filter,
        PartialInterfaceUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.partialInterfaceUnionMember2sSync(query).map(
      (objects) => objects.length,
    );
  }

  partialInterfaceUnionMember2sSync(
    query?: $ObjectSet.Query<
      PartialInterfaceUnionMember2.$Filter,
      PartialInterfaceUnionMember2.$Identifier
    >,
  ): Either<Error, readonly PartialInterfaceUnionMember2[]> {
    return this.$objectsSync<
      PartialInterfaceUnionMember2,
      PartialInterfaceUnionMember2.$Filter,
      PartialInterfaceUnionMember2.$Identifier
    >(
      {
        $filter: PartialInterfaceUnionMember2.$filter,
        $fromRdf: PartialInterfaceUnionMember2.$fromRdf,
        $fromRdfTypes: [PartialInterfaceUnionMember2.$fromRdfType],
      },
      query,
    );
  }

  async propertyCardinalitiesClass(
    identifier: PropertyCardinalitiesClass.$Identifier,
  ): Promise<Either<Error, PropertyCardinalitiesClass>> {
    return this.propertyCardinalitiesClassSync(identifier);
  }

  propertyCardinalitiesClassSync(
    identifier: PropertyCardinalitiesClass.$Identifier,
  ): Either<Error, PropertyCardinalitiesClass> {
    return this.propertyCardinalitiesClassesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async propertyCardinalitiesClassIdentifiers(
    query?: $ObjectSet.Query<
      PropertyCardinalitiesClass.$Filter,
      PropertyCardinalitiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly PropertyCardinalitiesClass.$Identifier[]>> {
    return this.propertyCardinalitiesClassIdentifiersSync(query);
  }

  propertyCardinalitiesClassIdentifiersSync(
    query?: $ObjectSet.Query<
      PropertyCardinalitiesClass.$Filter,
      PropertyCardinalitiesClass.$Identifier
    >,
  ): Either<Error, readonly PropertyCardinalitiesClass.$Identifier[]> {
    return this.propertyCardinalitiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async propertyCardinalitiesClasses(
    query?: $ObjectSet.Query<
      PropertyCardinalitiesClass.$Filter,
      PropertyCardinalitiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly PropertyCardinalitiesClass[]>> {
    return this.propertyCardinalitiesClassesSync(query);
  }

  async propertyCardinalitiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        PropertyCardinalitiesClass.$Filter,
        PropertyCardinalitiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.propertyCardinalitiesClassesCountSync(query);
  }

  propertyCardinalitiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        PropertyCardinalitiesClass.$Filter,
        PropertyCardinalitiesClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.propertyCardinalitiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  propertyCardinalitiesClassesSync(
    query?: $ObjectSet.Query<
      PropertyCardinalitiesClass.$Filter,
      PropertyCardinalitiesClass.$Identifier
    >,
  ): Either<Error, readonly PropertyCardinalitiesClass[]> {
    return this.$objectsSync<
      PropertyCardinalitiesClass,
      PropertyCardinalitiesClass.$Filter,
      PropertyCardinalitiesClass.$Identifier
    >(
      {
        $filter: PropertyCardinalitiesClass.$filter,
        $fromRdf: PropertyCardinalitiesClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async propertyVisibilitiesClass(
    identifier: PropertyVisibilitiesClass.$Identifier,
  ): Promise<Either<Error, PropertyVisibilitiesClass>> {
    return this.propertyVisibilitiesClassSync(identifier);
  }

  propertyVisibilitiesClassSync(
    identifier: PropertyVisibilitiesClass.$Identifier,
  ): Either<Error, PropertyVisibilitiesClass> {
    return this.propertyVisibilitiesClassesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async propertyVisibilitiesClassIdentifiers(
    query?: $ObjectSet.Query<
      PropertyVisibilitiesClass.$Filter,
      PropertyVisibilitiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly PropertyVisibilitiesClass.$Identifier[]>> {
    return this.propertyVisibilitiesClassIdentifiersSync(query);
  }

  propertyVisibilitiesClassIdentifiersSync(
    query?: $ObjectSet.Query<
      PropertyVisibilitiesClass.$Filter,
      PropertyVisibilitiesClass.$Identifier
    >,
  ): Either<Error, readonly PropertyVisibilitiesClass.$Identifier[]> {
    return this.propertyVisibilitiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async propertyVisibilitiesClasses(
    query?: $ObjectSet.Query<
      PropertyVisibilitiesClass.$Filter,
      PropertyVisibilitiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly PropertyVisibilitiesClass[]>> {
    return this.propertyVisibilitiesClassesSync(query);
  }

  async propertyVisibilitiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        PropertyVisibilitiesClass.$Filter,
        PropertyVisibilitiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.propertyVisibilitiesClassesCountSync(query);
  }

  propertyVisibilitiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        PropertyVisibilitiesClass.$Filter,
        PropertyVisibilitiesClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.propertyVisibilitiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  propertyVisibilitiesClassesSync(
    query?: $ObjectSet.Query<
      PropertyVisibilitiesClass.$Filter,
      PropertyVisibilitiesClass.$Identifier
    >,
  ): Either<Error, readonly PropertyVisibilitiesClass[]> {
    return this.$objectsSync<
      PropertyVisibilitiesClass,
      PropertyVisibilitiesClass.$Filter,
      PropertyVisibilitiesClass.$Identifier
    >(
      {
        $filter: PropertyVisibilitiesClass.$filter,
        $fromRdf: PropertyVisibilitiesClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async recursiveClassUnionMember1(
    identifier: RecursiveClassUnionMember1.$Identifier,
  ): Promise<Either<Error, RecursiveClassUnionMember1>> {
    return this.recursiveClassUnionMember1Sync(identifier);
  }

  recursiveClassUnionMember1Sync(
    identifier: RecursiveClassUnionMember1.$Identifier,
  ): Either<Error, RecursiveClassUnionMember1> {
    return this.recursiveClassUnionMember1sSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async recursiveClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<
      RecursiveClassUnionMember1.$Filter,
      RecursiveClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly RecursiveClassUnionMember1.$Identifier[]>> {
    return this.recursiveClassUnionMember1IdentifiersSync(query);
  }

  recursiveClassUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<
      RecursiveClassUnionMember1.$Filter,
      RecursiveClassUnionMember1.$Identifier
    >,
  ): Either<Error, readonly RecursiveClassUnionMember1.$Identifier[]> {
    return this.recursiveClassUnionMember1sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async recursiveClassUnionMember1s(
    query?: $ObjectSet.Query<
      RecursiveClassUnionMember1.$Filter,
      RecursiveClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly RecursiveClassUnionMember1[]>> {
    return this.recursiveClassUnionMember1sSync(query);
  }

  async recursiveClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<
        RecursiveClassUnionMember1.$Filter,
        RecursiveClassUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.recursiveClassUnionMember1sCountSync(query);
  }

  recursiveClassUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<
        RecursiveClassUnionMember1.$Filter,
        RecursiveClassUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.recursiveClassUnionMember1sSync(query).map(
      (objects) => objects.length,
    );
  }

  recursiveClassUnionMember1sSync(
    query?: $ObjectSet.Query<
      RecursiveClassUnionMember1.$Filter,
      RecursiveClassUnionMember1.$Identifier
    >,
  ): Either<Error, readonly RecursiveClassUnionMember1[]> {
    return this.$objectsSync<
      RecursiveClassUnionMember1,
      RecursiveClassUnionMember1.$Filter,
      RecursiveClassUnionMember1.$Identifier
    >(
      {
        $filter: RecursiveClassUnionMember1.$filter,
        $fromRdf: RecursiveClassUnionMember1.$fromRdf,
        $fromRdfTypes: [RecursiveClassUnionMember1.$fromRdfType],
      },
      query,
    );
  }

  async recursiveClassUnionMember2(
    identifier: RecursiveClassUnionMember2.$Identifier,
  ): Promise<Either<Error, RecursiveClassUnionMember2>> {
    return this.recursiveClassUnionMember2Sync(identifier);
  }

  recursiveClassUnionMember2Sync(
    identifier: RecursiveClassUnionMember2.$Identifier,
  ): Either<Error, RecursiveClassUnionMember2> {
    return this.recursiveClassUnionMember2sSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async recursiveClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<
      RecursiveClassUnionMember2.$Filter,
      RecursiveClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly RecursiveClassUnionMember2.$Identifier[]>> {
    return this.recursiveClassUnionMember2IdentifiersSync(query);
  }

  recursiveClassUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<
      RecursiveClassUnionMember2.$Filter,
      RecursiveClassUnionMember2.$Identifier
    >,
  ): Either<Error, readonly RecursiveClassUnionMember2.$Identifier[]> {
    return this.recursiveClassUnionMember2sSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async recursiveClassUnionMember2s(
    query?: $ObjectSet.Query<
      RecursiveClassUnionMember2.$Filter,
      RecursiveClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly RecursiveClassUnionMember2[]>> {
    return this.recursiveClassUnionMember2sSync(query);
  }

  async recursiveClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<
        RecursiveClassUnionMember2.$Filter,
        RecursiveClassUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.recursiveClassUnionMember2sCountSync(query);
  }

  recursiveClassUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<
        RecursiveClassUnionMember2.$Filter,
        RecursiveClassUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.recursiveClassUnionMember2sSync(query).map(
      (objects) => objects.length,
    );
  }

  recursiveClassUnionMember2sSync(
    query?: $ObjectSet.Query<
      RecursiveClassUnionMember2.$Filter,
      RecursiveClassUnionMember2.$Identifier
    >,
  ): Either<Error, readonly RecursiveClassUnionMember2[]> {
    return this.$objectsSync<
      RecursiveClassUnionMember2,
      RecursiveClassUnionMember2.$Filter,
      RecursiveClassUnionMember2.$Identifier
    >(
      {
        $filter: RecursiveClassUnionMember2.$filter,
        $fromRdf: RecursiveClassUnionMember2.$fromRdf,
        $fromRdfTypes: [RecursiveClassUnionMember2.$fromRdfType],
      },
      query,
    );
  }

  async sha256IriIdentifierClass(
    identifier: Sha256IriIdentifierClass.$Identifier,
  ): Promise<Either<Error, Sha256IriIdentifierClass>> {
    return this.sha256IriIdentifierClassSync(identifier);
  }

  sha256IriIdentifierClassSync(
    identifier: Sha256IriIdentifierClass.$Identifier,
  ): Either<Error, Sha256IriIdentifierClass> {
    return this.sha256IriIdentifierClassesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async sha256IriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<
      Sha256IriIdentifierClass.$Filter,
      Sha256IriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly Sha256IriIdentifierClass.$Identifier[]>> {
    return this.sha256IriIdentifierClassIdentifiersSync(query);
  }

  sha256IriIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<
      Sha256IriIdentifierClass.$Filter,
      Sha256IriIdentifierClass.$Identifier
    >,
  ): Either<Error, readonly Sha256IriIdentifierClass.$Identifier[]> {
    return this.sha256IriIdentifierClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async sha256IriIdentifierClasses(
    query?: $ObjectSet.Query<
      Sha256IriIdentifierClass.$Filter,
      Sha256IriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly Sha256IriIdentifierClass[]>> {
    return this.sha256IriIdentifierClassesSync(query);
  }

  async sha256IriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        Sha256IriIdentifierClass.$Filter,
        Sha256IriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.sha256IriIdentifierClassesCountSync(query);
  }

  sha256IriIdentifierClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        Sha256IriIdentifierClass.$Filter,
        Sha256IriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.sha256IriIdentifierClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  sha256IriIdentifierClassesSync(
    query?: $ObjectSet.Query<
      Sha256IriIdentifierClass.$Filter,
      Sha256IriIdentifierClass.$Identifier
    >,
  ): Either<Error, readonly Sha256IriIdentifierClass[]> {
    return this.$objectsSync<
      Sha256IriIdentifierClass,
      Sha256IriIdentifierClass.$Filter,
      Sha256IriIdentifierClass.$Identifier
    >(
      {
        $filter: Sha256IriIdentifierClass.$filter,
        $fromRdf: Sha256IriIdentifierClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async termPropertiesClass(
    identifier: TermPropertiesClass.$Identifier,
  ): Promise<Either<Error, TermPropertiesClass>> {
    return this.termPropertiesClassSync(identifier);
  }

  termPropertiesClassSync(
    identifier: TermPropertiesClass.$Identifier,
  ): Either<Error, TermPropertiesClass> {
    return this.termPropertiesClassesSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async termPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<
      TermPropertiesClass.$Filter,
      TermPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly TermPropertiesClass.$Identifier[]>> {
    return this.termPropertiesClassIdentifiersSync(query);
  }

  termPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<
      TermPropertiesClass.$Filter,
      TermPropertiesClass.$Identifier
    >,
  ): Either<Error, readonly TermPropertiesClass.$Identifier[]> {
    return this.termPropertiesClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async termPropertiesClasses(
    query?: $ObjectSet.Query<
      TermPropertiesClass.$Filter,
      TermPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly TermPropertiesClass[]>> {
    return this.termPropertiesClassesSync(query);
  }

  async termPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        TermPropertiesClass.$Filter,
        TermPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.termPropertiesClassesCountSync(query);
  }

  termPropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        TermPropertiesClass.$Filter,
        TermPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.termPropertiesClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  termPropertiesClassesSync(
    query?: $ObjectSet.Query<
      TermPropertiesClass.$Filter,
      TermPropertiesClass.$Identifier
    >,
  ): Either<Error, readonly TermPropertiesClass[]> {
    return this.$objectsSync<
      TermPropertiesClass,
      TermPropertiesClass.$Filter,
      TermPropertiesClass.$Identifier
    >(
      {
        $filter: TermPropertiesClass.$filter,
        $fromRdf: TermPropertiesClass.$fromRdf,
        $fromRdfTypes: [TermPropertiesClass.$fromRdfType],
      },
      query,
    );
  }

  async unionDiscriminantsClass(
    identifier: UnionDiscriminantsClass.$Identifier,
  ): Promise<Either<Error, UnionDiscriminantsClass>> {
    return this.unionDiscriminantsClassSync(identifier);
  }

  unionDiscriminantsClassSync(
    identifier: UnionDiscriminantsClass.$Identifier,
  ): Either<Error, UnionDiscriminantsClass> {
    return this.unionDiscriminantsClassesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async unionDiscriminantsClassIdentifiers(
    query?: $ObjectSet.Query<
      UnionDiscriminantsClass.$Filter,
      UnionDiscriminantsClass.$Identifier
    >,
  ): Promise<Either<Error, readonly UnionDiscriminantsClass.$Identifier[]>> {
    return this.unionDiscriminantsClassIdentifiersSync(query);
  }

  unionDiscriminantsClassIdentifiersSync(
    query?: $ObjectSet.Query<
      UnionDiscriminantsClass.$Filter,
      UnionDiscriminantsClass.$Identifier
    >,
  ): Either<Error, readonly UnionDiscriminantsClass.$Identifier[]> {
    return this.unionDiscriminantsClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async unionDiscriminantsClasses(
    query?: $ObjectSet.Query<
      UnionDiscriminantsClass.$Filter,
      UnionDiscriminantsClass.$Identifier
    >,
  ): Promise<Either<Error, readonly UnionDiscriminantsClass[]>> {
    return this.unionDiscriminantsClassesSync(query);
  }

  async unionDiscriminantsClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        UnionDiscriminantsClass.$Filter,
        UnionDiscriminantsClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.unionDiscriminantsClassesCountSync(query);
  }

  unionDiscriminantsClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        UnionDiscriminantsClass.$Filter,
        UnionDiscriminantsClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.unionDiscriminantsClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  unionDiscriminantsClassesSync(
    query?: $ObjectSet.Query<
      UnionDiscriminantsClass.$Filter,
      UnionDiscriminantsClass.$Identifier
    >,
  ): Either<Error, readonly UnionDiscriminantsClass[]> {
    return this.$objectsSync<
      UnionDiscriminantsClass,
      UnionDiscriminantsClass.$Filter,
      UnionDiscriminantsClass.$Identifier
    >(
      {
        $filter: UnionDiscriminantsClass.$filter,
        $fromRdf: UnionDiscriminantsClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async uuidV4IriIdentifierClass(
    identifier: UuidV4IriIdentifierClass.$Identifier,
  ): Promise<Either<Error, UuidV4IriIdentifierClass>> {
    return this.uuidV4IriIdentifierClassSync(identifier);
  }

  uuidV4IriIdentifierClassSync(
    identifier: UuidV4IriIdentifierClass.$Identifier,
  ): Either<Error, UuidV4IriIdentifierClass> {
    return this.uuidV4IriIdentifierClassesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async uuidV4IriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<
      UuidV4IriIdentifierClass.$Filter,
      UuidV4IriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly UuidV4IriIdentifierClass.$Identifier[]>> {
    return this.uuidV4IriIdentifierClassIdentifiersSync(query);
  }

  uuidV4IriIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<
      UuidV4IriIdentifierClass.$Filter,
      UuidV4IriIdentifierClass.$Identifier
    >,
  ): Either<Error, readonly UuidV4IriIdentifierClass.$Identifier[]> {
    return this.uuidV4IriIdentifierClassesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async uuidV4IriIdentifierClasses(
    query?: $ObjectSet.Query<
      UuidV4IriIdentifierClass.$Filter,
      UuidV4IriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly UuidV4IriIdentifierClass[]>> {
    return this.uuidV4IriIdentifierClassesSync(query);
  }

  async uuidV4IriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<
        UuidV4IriIdentifierClass.$Filter,
        UuidV4IriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.uuidV4IriIdentifierClassesCountSync(query);
  }

  uuidV4IriIdentifierClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        UuidV4IriIdentifierClass.$Filter,
        UuidV4IriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.uuidV4IriIdentifierClassesSync(query).map(
      (objects) => objects.length,
    );
  }

  uuidV4IriIdentifierClassesSync(
    query?: $ObjectSet.Query<
      UuidV4IriIdentifierClass.$Filter,
      UuidV4IriIdentifierClass.$Identifier
    >,
  ): Either<Error, readonly UuidV4IriIdentifierClass[]> {
    return this.$objectsSync<
      UuidV4IriIdentifierClass,
      UuidV4IriIdentifierClass.$Filter,
      UuidV4IriIdentifierClass.$Identifier
    >(
      {
        $filter: UuidV4IriIdentifierClass.$filter,
        $fromRdf: UuidV4IriIdentifierClass.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async uuidV4IriIdentifierInterface(
    identifier: UuidV4IriIdentifierInterface.$Identifier,
  ): Promise<Either<Error, UuidV4IriIdentifierInterface>> {
    return this.uuidV4IriIdentifierInterfaceSync(identifier);
  }

  uuidV4IriIdentifierInterfaceSync(
    identifier: UuidV4IriIdentifierInterface.$Identifier,
  ): Either<Error, UuidV4IriIdentifierInterface> {
    return this.uuidV4IriIdentifierInterfacesSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async uuidV4IriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<
      UuidV4IriIdentifierInterface.$Filter,
      UuidV4IriIdentifierInterface.$Identifier
    >,
  ): Promise<
    Either<Error, readonly UuidV4IriIdentifierInterface.$Identifier[]>
  > {
    return this.uuidV4IriIdentifierInterfaceIdentifiersSync(query);
  }

  uuidV4IriIdentifierInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<
      UuidV4IriIdentifierInterface.$Filter,
      UuidV4IriIdentifierInterface.$Identifier
    >,
  ): Either<Error, readonly UuidV4IriIdentifierInterface.$Identifier[]> {
    return this.uuidV4IriIdentifierInterfacesSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async uuidV4IriIdentifierInterfaces(
    query?: $ObjectSet.Query<
      UuidV4IriIdentifierInterface.$Filter,
      UuidV4IriIdentifierInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly UuidV4IriIdentifierInterface[]>> {
    return this.uuidV4IriIdentifierInterfacesSync(query);
  }

  async uuidV4IriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<
        UuidV4IriIdentifierInterface.$Filter,
        UuidV4IriIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.uuidV4IriIdentifierInterfacesCountSync(query);
  }

  uuidV4IriIdentifierInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<
        UuidV4IriIdentifierInterface.$Filter,
        UuidV4IriIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.uuidV4IriIdentifierInterfacesSync(query).map(
      (objects) => objects.length,
    );
  }

  uuidV4IriIdentifierInterfacesSync(
    query?: $ObjectSet.Query<
      UuidV4IriIdentifierInterface.$Filter,
      UuidV4IriIdentifierInterface.$Identifier
    >,
  ): Either<Error, readonly UuidV4IriIdentifierInterface[]> {
    return this.$objectsSync<
      UuidV4IriIdentifierInterface,
      UuidV4IriIdentifierInterface.$Filter,
      UuidV4IriIdentifierInterface.$Identifier
    >(
      {
        $filter: UuidV4IriIdentifierInterface.$filter,
        $fromRdf: UuidV4IriIdentifierInterface.$fromRdf,
        $fromRdfTypes: [],
      },
      query,
    );
  }

  async classUnion(
    identifier: ClassUnion.$Identifier,
  ): Promise<Either<Error, ClassUnion>> {
    return this.classUnionSync(identifier);
  }

  classUnionSync(
    identifier: ClassUnion.$Identifier,
  ): Either<Error, ClassUnion> {
    return this.classUnionsSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async classUnionIdentifiers(
    query?: $ObjectSet.Query<ClassUnion.$Filter, ClassUnion.$Identifier>,
  ): Promise<Either<Error, readonly ClassUnion.$Identifier[]>> {
    return this.classUnionIdentifiersSync(query);
  }

  classUnionIdentifiersSync(
    query?: $ObjectSet.Query<ClassUnion.$Filter, ClassUnion.$Identifier>,
  ): Either<Error, readonly ClassUnion.$Identifier[]> {
    return this.classUnionsSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async classUnions(
    query?: $ObjectSet.Query<ClassUnion.$Filter, ClassUnion.$Identifier>,
  ): Promise<Either<Error, readonly ClassUnion[]>> {
    return this.classUnionsSync(query);
  }

  async classUnionsCount(
    query?: Pick<
      $ObjectSet.Query<ClassUnion.$Filter, ClassUnion.$Identifier>,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.classUnionsCountSync(query);
  }

  classUnionsCountSync(
    query?: Pick<
      $ObjectSet.Query<ClassUnion.$Filter, ClassUnion.$Identifier>,
      "filter"
    >,
  ): Either<Error, number> {
    return this.classUnionsSync(query).map((objects) => objects.length);
  }

  classUnionsSync(
    query?: $ObjectSet.Query<ClassUnion.$Filter, ClassUnion.$Identifier>,
  ): Either<Error, readonly ClassUnion[]> {
    return this.$objectUnionsSync<
      ClassUnion,
      ClassUnion.$Filter,
      ClassUnion.$Identifier
    >(
      [
        {
          $filter: ClassUnion.$filter,
          $fromRdf: ClassUnionMember1.$fromRdf,
          $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
        },
        {
          $filter: ClassUnion.$filter,
          $fromRdf: ClassUnionMember2.$fromRdf,
          $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async flattenClassUnion(
    identifier: FlattenClassUnion.$Identifier,
  ): Promise<Either<Error, FlattenClassUnion>> {
    return this.flattenClassUnionSync(identifier);
  }

  flattenClassUnionSync(
    identifier: FlattenClassUnion.$Identifier,
  ): Either<Error, FlattenClassUnion> {
    return this.flattenClassUnionsSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async flattenClassUnionIdentifiers(
    query?: $ObjectSet.Query<
      FlattenClassUnion.$Filter,
      FlattenClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly FlattenClassUnion.$Identifier[]>> {
    return this.flattenClassUnionIdentifiersSync(query);
  }

  flattenClassUnionIdentifiersSync(
    query?: $ObjectSet.Query<
      FlattenClassUnion.$Filter,
      FlattenClassUnion.$Identifier
    >,
  ): Either<Error, readonly FlattenClassUnion.$Identifier[]> {
    return this.flattenClassUnionsSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async flattenClassUnions(
    query?: $ObjectSet.Query<
      FlattenClassUnion.$Filter,
      FlattenClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly FlattenClassUnion[]>> {
    return this.flattenClassUnionsSync(query);
  }

  async flattenClassUnionsCount(
    query?: Pick<
      $ObjectSet.Query<
        FlattenClassUnion.$Filter,
        FlattenClassUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.flattenClassUnionsCountSync(query);
  }

  flattenClassUnionsCountSync(
    query?: Pick<
      $ObjectSet.Query<
        FlattenClassUnion.$Filter,
        FlattenClassUnion.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.flattenClassUnionsSync(query).map((objects) => objects.length);
  }

  flattenClassUnionsSync(
    query?: $ObjectSet.Query<
      FlattenClassUnion.$Filter,
      FlattenClassUnion.$Identifier
    >,
  ): Either<Error, readonly FlattenClassUnion[]> {
    return this.$objectUnionsSync<
      FlattenClassUnion,
      FlattenClassUnion.$Filter,
      FlattenClassUnion.$Identifier
    >(
      [
        {
          $filter: FlattenClassUnion.$filter,
          $fromRdf: ClassUnionMember1.$fromRdf,
          $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
        },
        {
          $filter: FlattenClassUnion.$filter,
          $fromRdf: ClassUnionMember2.$fromRdf,
          $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
        },
        {
          $filter: FlattenClassUnion.$filter,
          $fromRdf: FlattenClassUnionMember3.$fromRdf,
          $fromRdfTypes: [FlattenClassUnionMember3.$fromRdfType],
        },
      ],
      query,
    );
  }

  async interfaceUnion(
    identifier: InterfaceUnion.$Identifier,
  ): Promise<Either<Error, InterfaceUnion>> {
    return this.interfaceUnionSync(identifier);
  }

  interfaceUnionSync(
    identifier: InterfaceUnion.$Identifier,
  ): Either<Error, InterfaceUnion> {
    return this.interfaceUnionsSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async interfaceUnionIdentifiers(
    query?: $ObjectSet.Query<
      InterfaceUnion.$Filter,
      InterfaceUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly InterfaceUnion.$Identifier[]>> {
    return this.interfaceUnionIdentifiersSync(query);
  }

  interfaceUnionIdentifiersSync(
    query?: $ObjectSet.Query<
      InterfaceUnion.$Filter,
      InterfaceUnion.$Identifier
    >,
  ): Either<Error, readonly InterfaceUnion.$Identifier[]> {
    return this.interfaceUnionsSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async interfaceUnions(
    query?: $ObjectSet.Query<
      InterfaceUnion.$Filter,
      InterfaceUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly InterfaceUnion[]>> {
    return this.interfaceUnionsSync(query);
  }

  async interfaceUnionsCount(
    query?: Pick<
      $ObjectSet.Query<InterfaceUnion.$Filter, InterfaceUnion.$Identifier>,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.interfaceUnionsCountSync(query);
  }

  interfaceUnionsCountSync(
    query?: Pick<
      $ObjectSet.Query<InterfaceUnion.$Filter, InterfaceUnion.$Identifier>,
      "filter"
    >,
  ): Either<Error, number> {
    return this.interfaceUnionsSync(query).map((objects) => objects.length);
  }

  interfaceUnionsSync(
    query?: $ObjectSet.Query<
      InterfaceUnion.$Filter,
      InterfaceUnion.$Identifier
    >,
  ): Either<Error, readonly InterfaceUnion[]> {
    return this.$objectUnionsSync<
      InterfaceUnion,
      InterfaceUnion.$Filter,
      InterfaceUnion.$Identifier
    >(
      [
        {
          $filter: InterfaceUnion.$filter,
          $fromRdf: InterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [InterfaceUnionMember1.$fromRdfType],
        },
        {
          $filter: InterfaceUnion.$filter,
          $fromRdf: InterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [InterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedClassUnion(
    identifier: LazilyResolvedClassUnion.$Identifier,
  ): Promise<Either<Error, LazilyResolvedClassUnion>> {
    return this.lazilyResolvedClassUnionSync(identifier);
  }

  lazilyResolvedClassUnionSync(
    identifier: LazilyResolvedClassUnion.$Identifier,
  ): Either<Error, LazilyResolvedClassUnion> {
    return this.lazilyResolvedClassUnionsSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionIdentifiers(
    query?: $ObjectSet.Query<
      LazilyResolvedClassUnion.$Filter,
      LazilyResolvedClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedClassUnion.$Identifier[]>> {
    return this.lazilyResolvedClassUnionIdentifiersSync(query);
  }

  lazilyResolvedClassUnionIdentifiersSync(
    query?: $ObjectSet.Query<
      LazilyResolvedClassUnion.$Filter,
      LazilyResolvedClassUnion.$Identifier
    >,
  ): Either<Error, readonly LazilyResolvedClassUnion.$Identifier[]> {
    return this.lazilyResolvedClassUnionsSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async lazilyResolvedClassUnions(
    query?: $ObjectSet.Query<
      LazilyResolvedClassUnion.$Filter,
      LazilyResolvedClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedClassUnion[]>> {
    return this.lazilyResolvedClassUnionsSync(query);
  }

  async lazilyResolvedClassUnionsCount(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedClassUnion.$Filter,
        LazilyResolvedClassUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.lazilyResolvedClassUnionsCountSync(query);
  }

  lazilyResolvedClassUnionsCountSync(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedClassUnion.$Filter,
        LazilyResolvedClassUnion.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.lazilyResolvedClassUnionsSync(query).map(
      (objects) => objects.length,
    );
  }

  lazilyResolvedClassUnionsSync(
    query?: $ObjectSet.Query<
      LazilyResolvedClassUnion.$Filter,
      LazilyResolvedClassUnion.$Identifier
    >,
  ): Either<Error, readonly LazilyResolvedClassUnion[]> {
    return this.$objectUnionsSync<
      LazilyResolvedClassUnion,
      LazilyResolvedClassUnion.$Filter,
      LazilyResolvedClassUnion.$Identifier
    >(
      [
        {
          $filter: LazilyResolvedClassUnion.$filter,
          $fromRdf: LazilyResolvedClassUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember1.$fromRdfType],
        },
        {
          $filter: LazilyResolvedClassUnion.$filter,
          $fromRdf: LazilyResolvedClassUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedInterfaceUnion(
    identifier: LazilyResolvedInterfaceUnion.$Identifier,
  ): Promise<Either<Error, LazilyResolvedInterfaceUnion>> {
    return this.lazilyResolvedInterfaceUnionSync(identifier);
  }

  lazilyResolvedInterfaceUnionSync(
    identifier: LazilyResolvedInterfaceUnion.$Identifier,
  ): Either<Error, LazilyResolvedInterfaceUnion> {
    return this.lazilyResolvedInterfaceUnionsSync({
      identifiers: [identifier],
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<
      LazilyResolvedInterfaceUnion.$Filter,
      LazilyResolvedInterfaceUnion.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedInterfaceUnion.$Identifier[]>
  > {
    return this.lazilyResolvedInterfaceUnionIdentifiersSync(query);
  }

  lazilyResolvedInterfaceUnionIdentifiersSync(
    query?: $ObjectSet.Query<
      LazilyResolvedInterfaceUnion.$Filter,
      LazilyResolvedInterfaceUnion.$Identifier
    >,
  ): Either<Error, readonly LazilyResolvedInterfaceUnion.$Identifier[]> {
    return this.lazilyResolvedInterfaceUnionsSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async lazilyResolvedInterfaceUnions(
    query?: $ObjectSet.Query<
      LazilyResolvedInterfaceUnion.$Filter,
      LazilyResolvedInterfaceUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedInterfaceUnion[]>> {
    return this.lazilyResolvedInterfaceUnionsSync(query);
  }

  async lazilyResolvedInterfaceUnionsCount(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedInterfaceUnion.$Filter,
        LazilyResolvedInterfaceUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.lazilyResolvedInterfaceUnionsCountSync(query);
  }

  lazilyResolvedInterfaceUnionsCountSync(
    query?: Pick<
      $ObjectSet.Query<
        LazilyResolvedInterfaceUnion.$Filter,
        LazilyResolvedInterfaceUnion.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.lazilyResolvedInterfaceUnionsSync(query).map(
      (objects) => objects.length,
    );
  }

  lazilyResolvedInterfaceUnionsSync(
    query?: $ObjectSet.Query<
      LazilyResolvedInterfaceUnion.$Filter,
      LazilyResolvedInterfaceUnion.$Identifier
    >,
  ): Either<Error, readonly LazilyResolvedInterfaceUnion[]> {
    return this.$objectUnionsSync<
      LazilyResolvedInterfaceUnion,
      LazilyResolvedInterfaceUnion.$Filter,
      LazilyResolvedInterfaceUnion.$Identifier
    >(
      [
        {
          $filter: LazilyResolvedInterfaceUnion.$filter,
          $fromRdf: LazilyResolvedInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember1.$fromRdfType],
        },
        {
          $filter: LazilyResolvedInterfaceUnion.$filter,
          $fromRdf: LazilyResolvedInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async noRdfTypeClassUnion(
    identifier: NoRdfTypeClassUnion.$Identifier,
  ): Promise<Either<Error, NoRdfTypeClassUnion>> {
    return this.noRdfTypeClassUnionSync(identifier);
  }

  noRdfTypeClassUnionSync(
    identifier: NoRdfTypeClassUnion.$Identifier,
  ): Either<Error, NoRdfTypeClassUnion> {
    return this.noRdfTypeClassUnionsSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async noRdfTypeClassUnionIdentifiers(
    query?: $ObjectSet.Query<
      NoRdfTypeClassUnion.$Filter,
      NoRdfTypeClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly NoRdfTypeClassUnion.$Identifier[]>> {
    return this.noRdfTypeClassUnionIdentifiersSync(query);
  }

  noRdfTypeClassUnionIdentifiersSync(
    query?: $ObjectSet.Query<
      NoRdfTypeClassUnion.$Filter,
      NoRdfTypeClassUnion.$Identifier
    >,
  ): Either<Error, readonly NoRdfTypeClassUnion.$Identifier[]> {
    return this.noRdfTypeClassUnionsSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async noRdfTypeClassUnions(
    query?: $ObjectSet.Query<
      NoRdfTypeClassUnion.$Filter,
      NoRdfTypeClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly NoRdfTypeClassUnion[]>> {
    return this.noRdfTypeClassUnionsSync(query);
  }

  async noRdfTypeClassUnionsCount(
    query?: Pick<
      $ObjectSet.Query<
        NoRdfTypeClassUnion.$Filter,
        NoRdfTypeClassUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.noRdfTypeClassUnionsCountSync(query);
  }

  noRdfTypeClassUnionsCountSync(
    query?: Pick<
      $ObjectSet.Query<
        NoRdfTypeClassUnion.$Filter,
        NoRdfTypeClassUnion.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.noRdfTypeClassUnionsSync(query).map(
      (objects) => objects.length,
    );
  }

  noRdfTypeClassUnionsSync(
    query?: $ObjectSet.Query<
      NoRdfTypeClassUnion.$Filter,
      NoRdfTypeClassUnion.$Identifier
    >,
  ): Either<Error, readonly NoRdfTypeClassUnion[]> {
    return this.$objectUnionsSync<
      NoRdfTypeClassUnion,
      NoRdfTypeClassUnion.$Filter,
      NoRdfTypeClassUnion.$Identifier
    >(
      [
        {
          $filter: NoRdfTypeClassUnion.$filter,
          $fromRdf: NoRdfTypeClassUnionMember1.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: NoRdfTypeClassUnion.$filter,
          $fromRdf: NoRdfTypeClassUnionMember2.$fromRdf,
          $fromRdfTypes: [],
        },
      ],
      query,
    );
  }

  async partialClassUnion(
    identifier: PartialClassUnion.$Identifier,
  ): Promise<Either<Error, PartialClassUnion>> {
    return this.partialClassUnionSync(identifier);
  }

  partialClassUnionSync(
    identifier: PartialClassUnion.$Identifier,
  ): Either<Error, PartialClassUnion> {
    return this.partialClassUnionsSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async partialClassUnionIdentifiers(
    query?: $ObjectSet.Query<
      PartialClassUnion.$Filter,
      PartialClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialClassUnion.$Identifier[]>> {
    return this.partialClassUnionIdentifiersSync(query);
  }

  partialClassUnionIdentifiersSync(
    query?: $ObjectSet.Query<
      PartialClassUnion.$Filter,
      PartialClassUnion.$Identifier
    >,
  ): Either<Error, readonly PartialClassUnion.$Identifier[]> {
    return this.partialClassUnionsSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async partialClassUnions(
    query?: $ObjectSet.Query<
      PartialClassUnion.$Filter,
      PartialClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialClassUnion[]>> {
    return this.partialClassUnionsSync(query);
  }

  async partialClassUnionsCount(
    query?: Pick<
      $ObjectSet.Query<
        PartialClassUnion.$Filter,
        PartialClassUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.partialClassUnionsCountSync(query);
  }

  partialClassUnionsCountSync(
    query?: Pick<
      $ObjectSet.Query<
        PartialClassUnion.$Filter,
        PartialClassUnion.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.partialClassUnionsSync(query).map((objects) => objects.length);
  }

  partialClassUnionsSync(
    query?: $ObjectSet.Query<
      PartialClassUnion.$Filter,
      PartialClassUnion.$Identifier
    >,
  ): Either<Error, readonly PartialClassUnion[]> {
    return this.$objectUnionsSync<
      PartialClassUnion,
      PartialClassUnion.$Filter,
      PartialClassUnion.$Identifier
    >(
      [
        {
          $filter: PartialClassUnion.$filter,
          $fromRdf: PartialClassUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember1.$fromRdfType],
        },
        {
          $filter: PartialClassUnion.$filter,
          $fromRdf: PartialClassUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialInterfaceUnion(
    identifier: PartialInterfaceUnion.$Identifier,
  ): Promise<Either<Error, PartialInterfaceUnion>> {
    return this.partialInterfaceUnionSync(identifier);
  }

  partialInterfaceUnionSync(
    identifier: PartialInterfaceUnion.$Identifier,
  ): Either<Error, PartialInterfaceUnion> {
    return this.partialInterfaceUnionsSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async partialInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<
      PartialInterfaceUnion.$Filter,
      PartialInterfaceUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialInterfaceUnion.$Identifier[]>> {
    return this.partialInterfaceUnionIdentifiersSync(query);
  }

  partialInterfaceUnionIdentifiersSync(
    query?: $ObjectSet.Query<
      PartialInterfaceUnion.$Filter,
      PartialInterfaceUnion.$Identifier
    >,
  ): Either<Error, readonly PartialInterfaceUnion.$Identifier[]> {
    return this.partialInterfaceUnionsSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async partialInterfaceUnions(
    query?: $ObjectSet.Query<
      PartialInterfaceUnion.$Filter,
      PartialInterfaceUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialInterfaceUnion[]>> {
    return this.partialInterfaceUnionsSync(query);
  }

  async partialInterfaceUnionsCount(
    query?: Pick<
      $ObjectSet.Query<
        PartialInterfaceUnion.$Filter,
        PartialInterfaceUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.partialInterfaceUnionsCountSync(query);
  }

  partialInterfaceUnionsCountSync(
    query?: Pick<
      $ObjectSet.Query<
        PartialInterfaceUnion.$Filter,
        PartialInterfaceUnion.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.partialInterfaceUnionsSync(query).map(
      (objects) => objects.length,
    );
  }

  partialInterfaceUnionsSync(
    query?: $ObjectSet.Query<
      PartialInterfaceUnion.$Filter,
      PartialInterfaceUnion.$Identifier
    >,
  ): Either<Error, readonly PartialInterfaceUnion[]> {
    return this.$objectUnionsSync<
      PartialInterfaceUnion,
      PartialInterfaceUnion.$Filter,
      PartialInterfaceUnion.$Identifier
    >(
      [
        {
          $filter: PartialInterfaceUnion.$filter,
          $fromRdf: PartialInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember1.$fromRdfType],
        },
        {
          $filter: PartialInterfaceUnion.$filter,
          $fromRdf: PartialInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async recursiveClassUnion(
    identifier: RecursiveClassUnion.$Identifier,
  ): Promise<Either<Error, RecursiveClassUnion>> {
    return this.recursiveClassUnionSync(identifier);
  }

  recursiveClassUnionSync(
    identifier: RecursiveClassUnion.$Identifier,
  ): Either<Error, RecursiveClassUnion> {
    return this.recursiveClassUnionsSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async recursiveClassUnionIdentifiers(
    query?: $ObjectSet.Query<
      RecursiveClassUnion.$Filter,
      RecursiveClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly RecursiveClassUnion.$Identifier[]>> {
    return this.recursiveClassUnionIdentifiersSync(query);
  }

  recursiveClassUnionIdentifiersSync(
    query?: $ObjectSet.Query<
      RecursiveClassUnion.$Filter,
      RecursiveClassUnion.$Identifier
    >,
  ): Either<Error, readonly RecursiveClassUnion.$Identifier[]> {
    return this.recursiveClassUnionsSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async recursiveClassUnions(
    query?: $ObjectSet.Query<
      RecursiveClassUnion.$Filter,
      RecursiveClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly RecursiveClassUnion[]>> {
    return this.recursiveClassUnionsSync(query);
  }

  async recursiveClassUnionsCount(
    query?: Pick<
      $ObjectSet.Query<
        RecursiveClassUnion.$Filter,
        RecursiveClassUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.recursiveClassUnionsCountSync(query);
  }

  recursiveClassUnionsCountSync(
    query?: Pick<
      $ObjectSet.Query<
        RecursiveClassUnion.$Filter,
        RecursiveClassUnion.$Identifier
      >,
      "filter"
    >,
  ): Either<Error, number> {
    return this.recursiveClassUnionsSync(query).map(
      (objects) => objects.length,
    );
  }

  recursiveClassUnionsSync(
    query?: $ObjectSet.Query<
      RecursiveClassUnion.$Filter,
      RecursiveClassUnion.$Identifier
    >,
  ): Either<Error, readonly RecursiveClassUnion[]> {
    return this.$objectUnionsSync<
      RecursiveClassUnion,
      RecursiveClassUnion.$Filter,
      RecursiveClassUnion.$Identifier
    >(
      [
        {
          $filter: RecursiveClassUnion.$filter,
          $fromRdf: RecursiveClassUnionMember1.$fromRdf,
          $fromRdfTypes: [RecursiveClassUnionMember1.$fromRdfType],
        },
        {
          $filter: RecursiveClassUnion.$filter,
          $fromRdf: RecursiveClassUnionMember2.$fromRdf,
          $fromRdfTypes: [RecursiveClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async object(
    identifier: $Object.$Identifier,
  ): Promise<Either<Error, $Object>> {
    return this.objectSync(identifier);
  }

  objectSync(identifier: $Object.$Identifier): Either<Error, $Object> {
    return this.objectsSync({ identifiers: [identifier] }).map(
      (objects) => objects[0],
    );
  }

  async objectIdentifiers(
    query?: $ObjectSet.Query<$Object.$Filter, $Object.$Identifier>,
  ): Promise<Either<Error, readonly $Object.$Identifier[]>> {
    return this.objectIdentifiersSync(query);
  }

  objectIdentifiersSync(
    query?: $ObjectSet.Query<$Object.$Filter, $Object.$Identifier>,
  ): Either<Error, readonly $Object.$Identifier[]> {
    return this.objectsSync(query).map((objects) =>
      objects.map((object) => object.$identifier),
    );
  }

  async objects(
    query?: $ObjectSet.Query<$Object.$Filter, $Object.$Identifier>,
  ): Promise<Either<Error, readonly $Object[]>> {
    return this.objectsSync(query);
  }

  async objectsCount(
    query?: Pick<
      $ObjectSet.Query<$Object.$Filter, $Object.$Identifier>,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.objectsCountSync(query);
  }

  objectsCountSync(
    query?: Pick<
      $ObjectSet.Query<$Object.$Filter, $Object.$Identifier>,
      "filter"
    >,
  ): Either<Error, number> {
    return this.objectsSync(query).map((objects) => objects.length);
  }

  objectsSync(
    query?: $ObjectSet.Query<$Object.$Filter, $Object.$Identifier>,
  ): Either<Error, readonly $Object[]> {
    return this.$objectUnionsSync<
      $Object,
      $Object.$Filter,
      $Object.$Identifier
    >(
      [
        {
          $filter: $Object.$filter,
          $fromRdf: BlankNodeIdentifierClass.$fromRdf,
          $fromRdfTypes: [BlankNodeIdentifierClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: BlankNodeIdentifierInterface.$fromRdf,
          $fromRdfTypes: [BlankNodeIdentifierInterface.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: BlankNodeOrIriIdentifierClass.$fromRdf,
          $fromRdfTypes: [BlankNodeOrIriIdentifierClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: BlankNodeOrIriIdentifierInterface.$fromRdf,
          $fromRdfTypes: [BlankNodeOrIriIdentifierInterface.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ClassUnionMember1.$fromRdf,
          $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ClassUnionMember2.$fromRdf,
          $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ConcreteChildClass.$fromRdf,
          $fromRdfTypes: [ConcreteChildClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ConcreteParentClassStatic.$fromRdf,
          $fromRdfTypes: [
            ConcreteParentClassStatic.$fromRdfType,
            ConcreteChildClass.$fromRdfType,
          ],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ConcreteChildInterface.$fromRdf,
          $fromRdfTypes: [ConcreteChildInterface.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ConcreteParentInterfaceStatic.$fromRdf,
          $fromRdfTypes: [
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: BaseInterfaceWithoutPropertiesStatic.$fromRdf,
          $fromRdfTypes: [
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: BaseInterfaceWithPropertiesStatic.$fromRdf,
          $fromRdfTypes: [
            BaseInterfaceWithPropertiesStatic.$fromRdfType,
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ConvertibleTypePropertiesClass.$fromRdf,
          $fromRdfTypes: [ConvertibleTypePropertiesClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: DateUnionPropertiesClass.$fromRdf,
          $fromRdfTypes: [DateUnionPropertiesClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: DefaultValuePropertiesClass.$fromRdf,
          $fromRdfTypes: [DefaultValuePropertiesClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: DirectRecursiveClass.$fromRdf,
          $fromRdfTypes: [DirectRecursiveClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ExplicitFromToRdfTypesClass.$fromRdf,
          $fromRdfTypes: [ExplicitFromToRdfTypesClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ExplicitRdfTypeClass.$fromRdf,
          $fromRdfTypes: [ExplicitRdfTypeClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ExternClassPropertyClass.$fromRdf,
          $fromRdfTypes: [ExternClassPropertyClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: FlattenClassUnionMember3.$fromRdf,
          $fromRdfTypes: [FlattenClassUnionMember3.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: HasValuePropertiesClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: IdentifierOverride5Class.$fromRdf,
          $fromRdfTypes: [IdentifierOverride5Class.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: IdentifierOverride4ClassStatic.$fromRdf,
          $fromRdfTypes: [
            IdentifierOverride4ClassStatic.$fromRdfType,
            IdentifierOverride5Class.$fromRdfType,
          ],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: IdentifierOverride3ClassStatic.$fromRdf,
          $fromRdfTypes: [
            IdentifierOverride3ClassStatic.$fromRdfType,
            IdentifierOverride4ClassStatic.$fromRdfType,
            IdentifierOverride5Class.$fromRdfType,
          ],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: InIdentifierClass.$fromRdf,
          $fromRdfTypes: [InIdentifierClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: InPropertiesClass.$fromRdf,
          $fromRdfTypes: [InPropertiesClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: IndirectRecursiveClass.$fromRdf,
          $fromRdfTypes: [IndirectRecursiveClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: IndirectRecursiveHelperClass.$fromRdf,
          $fromRdfTypes: [IndirectRecursiveHelperClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: Interface.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: InterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [InterfaceUnionMember1.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: InterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [InterfaceUnionMember2.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: IriIdentifierClass.$fromRdf,
          $fromRdfTypes: [IriIdentifierClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: IriIdentifierInterface.$fromRdf,
          $fromRdfTypes: [IriIdentifierInterface.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: JsPrimitiveUnionPropertyClass.$fromRdf,
          $fromRdfTypes: [JsPrimitiveUnionPropertyClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LanguageInPropertiesClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdf,
          $fromRdfTypes: [
            LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdfType,
          ],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdf,
          $fromRdfTypes: [
            LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdfType,
          ],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LazilyResolvedClassUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember1.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LazilyResolvedClassUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember2.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LazilyResolvedInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember1.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LazilyResolvedInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember2.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LazilyResolvedIriIdentifierClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LazilyResolvedIriIdentifierInterface.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LazyPropertiesClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: PartialClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: LazyPropertiesInterface.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: PartialInterface.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: ListPropertiesClass.$fromRdf,
          $fromRdfTypes: [ListPropertiesClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: MutablePropertiesClass.$fromRdf,
          $fromRdfTypes: [MutablePropertiesClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: NoRdfTypeClassUnionMember1.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: NoRdfTypeClassUnionMember2.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: NonClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: OrderedPropertiesClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: PartialClassUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember1.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: PartialClassUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember2.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: PartialInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember1.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: PartialInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember2.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: PropertyCardinalitiesClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: PropertyVisibilitiesClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: RecursiveClassUnionMember1.$fromRdf,
          $fromRdfTypes: [RecursiveClassUnionMember1.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: RecursiveClassUnionMember2.$fromRdf,
          $fromRdfTypes: [RecursiveClassUnionMember2.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: Sha256IriIdentifierClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: TermPropertiesClass.$fromRdf,
          $fromRdfTypes: [TermPropertiesClass.$fromRdfType],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: UnionDiscriminantsClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: UuidV4IriIdentifierClass.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: UuidV4IriIdentifierInterface.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: $DefaultPartial.$fromRdf,
          $fromRdfTypes: [],
        },
        {
          $filter: $Object.$filter,
          $fromRdf: $NamedDefaultPartial.$fromRdf,
          $fromRdfTypes: [],
        },
      ],
      query,
    );
  }

  protected $objectsSync<
    ObjectT extends { readonly $identifier: ObjectIdentifierT },
    ObjectFilterT,
    ObjectIdentifierT extends BlankNode | NamedNode,
  >(
    objectType: {
      $filter: (filter: ObjectFilterT, value: ObjectT) => boolean;
      $fromRdf: (
        resource: Resource,
        options: { objectSet: $ObjectSet },
      ) => Either<Error, ObjectT>;
      $fromRdfTypes: readonly NamedNode[];
    },
    query?: $ObjectSet.Query<ObjectFilterT, ObjectIdentifierT>,
  ): Either<Error, readonly ObjectT[]> {
    const limit = query?.limit ?? Number.MAX_SAFE_INTEGER;
    if (limit <= 0) {
      return Either.of([]);
    }

    let offset = query?.offset ?? 0;
    if (offset < 0) {
      offset = 0;
    }

    let resources: { object?: ObjectT; resource: Resource }[];
    let sortResources: boolean;
    if (query?.identifiers) {
      resources = query.identifiers.map((identifier) => ({
        resource: this.resourceSet.resource(identifier),
      }));
      sortResources = false;
    } else if (objectType.$fromRdfTypes.length > 0) {
      const identifierSet = new $IdentifierSet();
      resources = [];
      sortResources = true;
      for (const fromRdfType of objectType.$fromRdfTypes) {
        for (const resource of this.resourceSet.instancesOf(fromRdfType)) {
          if (!identifierSet.has(resource.identifier)) {
            identifierSet.add(resource.identifier);
            resources.push({ resource });
          }
        }
      }
    } else {
      const identifierSet = new $IdentifierSet();
      resources = [];
      sortResources = true;
      for (const quad of this.resourceSet.dataset) {
        switch (quad.subject.termType) {
          case "BlankNode":
          case "NamedNode":
            break;
          default:
            continue;
        }

        if (identifierSet.has(quad.subject)) {
          continue;
        }
        identifierSet.add(quad.subject);
        const resource = this.resourceSet.resource(quad.subject);
        // Eagerly eliminate the majority of resources that won't match the object type
        objectType.$fromRdf(resource, { objectSet: this }).ifRight((object) => {
          resources.push({ object, resource });
        });
      }
    }

    if (sortResources) {
      // Sort resources by identifier so limit and offset are deterministic
      resources.sort((left, right) =>
        left.resource.identifier.value.localeCompare(
          right.resource.identifier.value,
        ),
      );
    }

    let objectI = 0;
    const objects: ObjectT[] = [];
    for (let { object, resource } of resources) {
      if (!object) {
        const objectEither = objectType.$fromRdf(resource, { objectSet: this });
        if (objectEither.isLeft()) {
          return objectEither;
        }
        object = objectEither.unsafeCoerce();
      }

      if (query?.filter && !objectType.$filter(query.filter, object)) {
        continue;
      }

      if (objectI++ >= offset) {
        objects.push(object);
        if (objects.length === limit) {
          return Either.of(objects);
        }
      }
    }
    return Either.of(objects);
  }

  protected $objectUnionsSync<
    ObjectT extends { readonly $identifier: ObjectIdentifierT },
    ObjectFilterT,
    ObjectIdentifierT extends BlankNode | NamedNode,
  >(
    objectTypes: readonly {
      $filter: (filter: ObjectFilterT, value: ObjectT) => boolean;
      $fromRdf: (
        resource: Resource,
        options: { objectSet: $ObjectSet },
      ) => Either<Error, ObjectT>;
      $fromRdfTypes: readonly NamedNode[];
    }[],
    query?: $ObjectSet.Query<ObjectFilterT, ObjectIdentifierT>,
  ): Either<Error, readonly ObjectT[]> {
    const limit = query?.limit ?? Number.MAX_SAFE_INTEGER;
    if (limit <= 0) {
      return Either.of([]);
    }

    let offset = query?.offset ?? 0;
    if (offset < 0) {
      offset = 0;
    }

    let resources: {
      object?: ObjectT;
      objectType?: {
        $filter: (filter: ObjectFilterT, value: ObjectT) => boolean;
        $fromRdf: (
          resource: Resource,
          options: { objectSet: $ObjectSet },
        ) => Either<Error, ObjectT>;
        $fromRdfTypes: readonly NamedNode[];
      };
      resource: Resource;
    }[];
    let sortResources: boolean;
    if (query?.identifiers) {
      resources = query.identifiers.map((identifier) => ({
        resource: this.resourceSet.resource(identifier),
      }));
      sortResources = false;
    } else if (
      objectTypes.every((objectType) => objectType.$fromRdfTypes.length > 0)
    ) {
      const identifierSet = new $IdentifierSet();
      resources = [];
      sortResources = true;
      for (const objectType of objectTypes) {
        for (const fromRdfType of objectType.$fromRdfTypes) {
          for (const resource of this.resourceSet.instancesOf(fromRdfType)) {
            if (!identifierSet.has(resource.identifier)) {
              identifierSet.add(resource.identifier);
              resources.push({ objectType, resource });
            }
          }
        }
      }
    } else {
      const identifierSet = new $IdentifierSet();
      resources = [];
      sortResources = true;
      for (const quad of this.resourceSet.dataset) {
        switch (quad.subject.termType) {
          case "BlankNode":
          case "NamedNode":
            break;
          default:
            continue;
        }

        if (identifierSet.has(quad.subject)) {
          continue;
        }
        identifierSet.add(quad.subject);
        // Eagerly eliminate the majority of resources that won't match the object types
        const resource = this.resourceSet.resource(quad.subject);
        for (const objectType of objectTypes) {
          if (
            objectType
              .$fromRdf(resource, { objectSet: this })
              .ifRight((object) => {
                resources.push({ object, objectType, resource });
              })
              .isRight()
          ) {
            break;
          }
        }
      }
    }

    if (sortResources) {
      // Sort resources by identifier so limit and offset are deterministic
      resources.sort((left, right) =>
        left.resource.identifier.value.localeCompare(
          right.resource.identifier.value,
        ),
      );
    }

    let objectI = 0;
    const objects: ObjectT[] = [];
    for (let { object, objectType, resource } of resources) {
      if (!object) {
        let objectEither: Either<Error, ObjectT>;
        if (objectType) {
          objectEither = objectType.$fromRdf(resource, { objectSet: this });
        } else {
          objectEither = Left(new Error("no object types"));
          for (const tryObjectType of objectTypes) {
            objectEither = tryObjectType.$fromRdf(resource, {
              objectSet: this,
            });
            if (objectEither.isRight()) {
              objectType = tryObjectType;
              break;
            }
          }
        }
        if (objectEither.isLeft()) {
          return objectEither;
        }
        object = objectEither.unsafeCoerce();
      }
      if (!objectType) {
        throw new Error("objectType should be set here");
      }

      if (query?.filter && !objectType.$filter(query.filter, object)) {
        continue;
      }

      if (objectI++ >= offset) {
        objects.push(object);
        if (objects.length === limit) {
          return Either.of(objects);
        }
      }
    }
    return Either.of(objects);
  }
}
export class $SparqlObjectSet implements $ObjectSet {
  protected readonly $countVariable = dataFactory.variable!("count");
  protected readonly $objectVariable = dataFactory.variable!("object");
  protected readonly $sparqlGenerator = new sparqljs.Generator();

  constructor(
    protected readonly $sparqlClient: {
      queryBindings: (
        query: string,
      ) => Promise<readonly Record<string, BlankNode | Literal | NamedNode>[]>;
      queryQuads: (query: string) => Promise<readonly Quad[]>;
    },
  ) {}

  async baseInterfaceWithoutProperties(
    identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier,
  ): Promise<Either<Error, BaseInterfaceWithoutProperties>> {
    return (
      await this.baseInterfaceWithoutPropertieses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async baseInterfaceWithoutPropertiesIdentifiers(
    query?: $SparqlObjectSet.Query<
      BaseInterfaceWithoutPropertiesStatic.$Filter,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >,
  ): Promise<
    Either<Error, readonly BaseInterfaceWithoutPropertiesStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      BaseInterfaceWithoutPropertiesStatic.$Filter,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >(BaseInterfaceWithoutPropertiesStatic, query);
  }

  async baseInterfaceWithoutPropertieses(
    query?: $SparqlObjectSet.Query<
      BaseInterfaceWithoutPropertiesStatic.$Filter,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >,
  ): Promise<Either<Error, readonly BaseInterfaceWithoutProperties[]>> {
    return this.$objects<
      BaseInterfaceWithoutProperties,
      BaseInterfaceWithoutPropertiesStatic.$Filter,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >(BaseInterfaceWithoutPropertiesStatic, query);
  }

  async baseInterfaceWithoutPropertiesesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        BaseInterfaceWithoutPropertiesStatic.$Filter,
        BaseInterfaceWithoutPropertiesStatic.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      BaseInterfaceWithoutPropertiesStatic.$Filter,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >(BaseInterfaceWithoutPropertiesStatic, query);
  }

  async baseInterfaceWithProperties(
    identifier: BaseInterfaceWithPropertiesStatic.$Identifier,
  ): Promise<Either<Error, BaseInterfaceWithProperties>> {
    return (
      await this.baseInterfaceWithPropertieses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async baseInterfaceWithPropertiesIdentifiers(
    query?: $SparqlObjectSet.Query<
      BaseInterfaceWithPropertiesStatic.$Filter,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >,
  ): Promise<
    Either<Error, readonly BaseInterfaceWithPropertiesStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      BaseInterfaceWithPropertiesStatic.$Filter,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >(BaseInterfaceWithPropertiesStatic, query);
  }

  async baseInterfaceWithPropertieses(
    query?: $SparqlObjectSet.Query<
      BaseInterfaceWithPropertiesStatic.$Filter,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >,
  ): Promise<Either<Error, readonly BaseInterfaceWithProperties[]>> {
    return this.$objects<
      BaseInterfaceWithProperties,
      BaseInterfaceWithPropertiesStatic.$Filter,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >(BaseInterfaceWithPropertiesStatic, query);
  }

  async baseInterfaceWithPropertiesesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        BaseInterfaceWithPropertiesStatic.$Filter,
        BaseInterfaceWithPropertiesStatic.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      BaseInterfaceWithPropertiesStatic.$Filter,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >(BaseInterfaceWithPropertiesStatic, query);
  }

  async blankNodeIdentifierClass(
    identifier: BlankNodeIdentifierClass.$Identifier,
  ): Promise<Either<Error, BlankNodeIdentifierClass>> {
    return (
      await this.blankNodeIdentifierClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async blankNodeIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      BlankNodeIdentifierClass.$Filter,
      BlankNodeIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly BlankNodeIdentifierClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      BlankNodeIdentifierClass.$Filter,
      BlankNodeIdentifierClass.$Identifier
    >(BlankNodeIdentifierClass, query);
  }

  async blankNodeIdentifierClasses(
    query?: $SparqlObjectSet.Query<
      BlankNodeIdentifierClass.$Filter,
      BlankNodeIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly BlankNodeIdentifierClass[]>> {
    return this.$objects<
      BlankNodeIdentifierClass,
      BlankNodeIdentifierClass.$Filter,
      BlankNodeIdentifierClass.$Identifier
    >(BlankNodeIdentifierClass, query);
  }

  async blankNodeIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        BlankNodeIdentifierClass.$Filter,
        BlankNodeIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      BlankNodeIdentifierClass.$Filter,
      BlankNodeIdentifierClass.$Identifier
    >(BlankNodeIdentifierClass, query);
  }

  async blankNodeIdentifierInterface(
    identifier: BlankNodeIdentifierInterface.$Identifier,
  ): Promise<Either<Error, BlankNodeIdentifierInterface>> {
    return (
      await this.blankNodeIdentifierInterfaces({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async blankNodeIdentifierInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<
      BlankNodeIdentifierInterface.$Filter,
      BlankNodeIdentifierInterface.$Identifier
    >,
  ): Promise<
    Either<Error, readonly BlankNodeIdentifierInterface.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      BlankNodeIdentifierInterface.$Filter,
      BlankNodeIdentifierInterface.$Identifier
    >(BlankNodeIdentifierInterface, query);
  }

  async blankNodeIdentifierInterfaces(
    query?: $SparqlObjectSet.Query<
      BlankNodeIdentifierInterface.$Filter,
      BlankNodeIdentifierInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly BlankNodeIdentifierInterface[]>> {
    return this.$objects<
      BlankNodeIdentifierInterface,
      BlankNodeIdentifierInterface.$Filter,
      BlankNodeIdentifierInterface.$Identifier
    >(BlankNodeIdentifierInterface, query);
  }

  async blankNodeIdentifierInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        BlankNodeIdentifierInterface.$Filter,
        BlankNodeIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      BlankNodeIdentifierInterface.$Filter,
      BlankNodeIdentifierInterface.$Identifier
    >(BlankNodeIdentifierInterface, query);
  }

  async blankNodeOrIriIdentifierClass(
    identifier: BlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<Either<Error, BlankNodeOrIriIdentifierClass>> {
    return (
      await this.blankNodeOrIriIdentifierClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async blankNodeOrIriIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      BlankNodeOrIriIdentifierClass.$Filter,
      BlankNodeOrIriIdentifierClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly BlankNodeOrIriIdentifierClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      BlankNodeOrIriIdentifierClass.$Filter,
      BlankNodeOrIriIdentifierClass.$Identifier
    >(BlankNodeOrIriIdentifierClass, query);
  }

  async blankNodeOrIriIdentifierClasses(
    query?: $SparqlObjectSet.Query<
      BlankNodeOrIriIdentifierClass.$Filter,
      BlankNodeOrIriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly BlankNodeOrIriIdentifierClass[]>> {
    return this.$objects<
      BlankNodeOrIriIdentifierClass,
      BlankNodeOrIriIdentifierClass.$Filter,
      BlankNodeOrIriIdentifierClass.$Identifier
    >(BlankNodeOrIriIdentifierClass, query);
  }

  async blankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        BlankNodeOrIriIdentifierClass.$Filter,
        BlankNodeOrIriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      BlankNodeOrIriIdentifierClass.$Filter,
      BlankNodeOrIriIdentifierClass.$Identifier
    >(BlankNodeOrIriIdentifierClass, query);
  }

  async blankNodeOrIriIdentifierInterface(
    identifier: BlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<Either<Error, BlankNodeOrIriIdentifierInterface>> {
    return (
      await this.blankNodeOrIriIdentifierInterfaces({
        identifiers: [identifier],
      })
    ).map((objects) => objects[0]);
  }

  async blankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<
      BlankNodeOrIriIdentifierInterface.$Filter,
      BlankNodeOrIriIdentifierInterface.$Identifier
    >,
  ): Promise<
    Either<Error, readonly BlankNodeOrIriIdentifierInterface.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      BlankNodeOrIriIdentifierInterface.$Filter,
      BlankNodeOrIriIdentifierInterface.$Identifier
    >(BlankNodeOrIriIdentifierInterface, query);
  }

  async blankNodeOrIriIdentifierInterfaces(
    query?: $SparqlObjectSet.Query<
      BlankNodeOrIriIdentifierInterface.$Filter,
      BlankNodeOrIriIdentifierInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly BlankNodeOrIriIdentifierInterface[]>> {
    return this.$objects<
      BlankNodeOrIriIdentifierInterface,
      BlankNodeOrIriIdentifierInterface.$Filter,
      BlankNodeOrIriIdentifierInterface.$Identifier
    >(BlankNodeOrIriIdentifierInterface, query);
  }

  async blankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        BlankNodeOrIriIdentifierInterface.$Filter,
        BlankNodeOrIriIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      BlankNodeOrIriIdentifierInterface.$Filter,
      BlankNodeOrIriIdentifierInterface.$Identifier
    >(BlankNodeOrIriIdentifierInterface, query);
  }

  async classUnionMember1(
    identifier: ClassUnionMember1.$Identifier,
  ): Promise<Either<Error, ClassUnionMember1>> {
    return (await this.classUnionMember1s({ identifiers: [identifier] })).map(
      (objects) => objects[0],
    );
  }

  async classUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<
      ClassUnionMember1.$Filter,
      ClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly ClassUnionMember1.$Identifier[]>> {
    return this.$objectIdentifiers<
      ClassUnionMember1.$Filter,
      ClassUnionMember1.$Identifier
    >(ClassUnionMember1, query);
  }

  async classUnionMember1s(
    query?: $SparqlObjectSet.Query<
      ClassUnionMember1.$Filter,
      ClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly ClassUnionMember1[]>> {
    return this.$objects<
      ClassUnionMember1,
      ClassUnionMember1.$Filter,
      ClassUnionMember1.$Identifier
    >(ClassUnionMember1, query);
  }

  async classUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        ClassUnionMember1.$Filter,
        ClassUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      ClassUnionMember1.$Filter,
      ClassUnionMember1.$Identifier
    >(ClassUnionMember1, query);
  }

  async classUnionMember2(
    identifier: ClassUnionMember2.$Identifier,
  ): Promise<Either<Error, ClassUnionMember2>> {
    return (await this.classUnionMember2s({ identifiers: [identifier] })).map(
      (objects) => objects[0],
    );
  }

  async classUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<
      ClassUnionMember2.$Filter,
      ClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly ClassUnionMember2.$Identifier[]>> {
    return this.$objectIdentifiers<
      ClassUnionMember2.$Filter,
      ClassUnionMember2.$Identifier
    >(ClassUnionMember2, query);
  }

  async classUnionMember2s(
    query?: $SparqlObjectSet.Query<
      ClassUnionMember2.$Filter,
      ClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly ClassUnionMember2[]>> {
    return this.$objects<
      ClassUnionMember2,
      ClassUnionMember2.$Filter,
      ClassUnionMember2.$Identifier
    >(ClassUnionMember2, query);
  }

  async classUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        ClassUnionMember2.$Filter,
        ClassUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      ClassUnionMember2.$Filter,
      ClassUnionMember2.$Identifier
    >(ClassUnionMember2, query);
  }

  async concreteChildClass(
    identifier: ConcreteChildClass.$Identifier,
  ): Promise<Either<Error, ConcreteChildClass>> {
    return (await this.concreteChildClasses({ identifiers: [identifier] })).map(
      (objects) => objects[0],
    );
  }

  async concreteChildClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      ConcreteChildClass.$Filter,
      ConcreteChildClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ConcreteChildClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      ConcreteChildClass.$Filter,
      ConcreteChildClass.$Identifier
    >(ConcreteChildClass, query);
  }

  async concreteChildClasses(
    query?: $SparqlObjectSet.Query<
      ConcreteChildClass.$Filter,
      ConcreteChildClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ConcreteChildClass[]>> {
    return this.$objects<
      ConcreteChildClass,
      ConcreteChildClass.$Filter,
      ConcreteChildClass.$Identifier
    >(ConcreteChildClass, query);
  }

  async concreteChildClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        ConcreteChildClass.$Filter,
        ConcreteChildClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      ConcreteChildClass.$Filter,
      ConcreteChildClass.$Identifier
    >(ConcreteChildClass, query);
  }

  async concreteChildInterface(
    identifier: ConcreteChildInterface.$Identifier,
  ): Promise<Either<Error, ConcreteChildInterface>> {
    return (
      await this.concreteChildInterfaces({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async concreteChildInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<
      ConcreteChildInterface.$Filter,
      ConcreteChildInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly ConcreteChildInterface.$Identifier[]>> {
    return this.$objectIdentifiers<
      ConcreteChildInterface.$Filter,
      ConcreteChildInterface.$Identifier
    >(ConcreteChildInterface, query);
  }

  async concreteChildInterfaces(
    query?: $SparqlObjectSet.Query<
      ConcreteChildInterface.$Filter,
      ConcreteChildInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly ConcreteChildInterface[]>> {
    return this.$objects<
      ConcreteChildInterface,
      ConcreteChildInterface.$Filter,
      ConcreteChildInterface.$Identifier
    >(ConcreteChildInterface, query);
  }

  async concreteChildInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        ConcreteChildInterface.$Filter,
        ConcreteChildInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      ConcreteChildInterface.$Filter,
      ConcreteChildInterface.$Identifier
    >(ConcreteChildInterface, query);
  }

  async concreteParentClass(
    identifier: ConcreteParentClassStatic.$Identifier,
  ): Promise<Either<Error, ConcreteParentClass>> {
    return (
      await this.concreteParentClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async concreteParentClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      ConcreteParentClassStatic.$Filter,
      ConcreteParentClassStatic.$Identifier
    >,
  ): Promise<Either<Error, readonly ConcreteParentClassStatic.$Identifier[]>> {
    return this.$objectIdentifiers<
      ConcreteParentClassStatic.$Filter,
      ConcreteParentClassStatic.$Identifier
    >(ConcreteParentClassStatic, query);
  }

  async concreteParentClasses(
    query?: $SparqlObjectSet.Query<
      ConcreteParentClassStatic.$Filter,
      ConcreteParentClassStatic.$Identifier
    >,
  ): Promise<Either<Error, readonly ConcreteParentClass[]>> {
    return this.$objects<
      ConcreteParentClass,
      ConcreteParentClassStatic.$Filter,
      ConcreteParentClassStatic.$Identifier
    >(ConcreteParentClassStatic, query);
  }

  async concreteParentClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        ConcreteParentClassStatic.$Filter,
        ConcreteParentClassStatic.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      ConcreteParentClassStatic.$Filter,
      ConcreteParentClassStatic.$Identifier
    >(ConcreteParentClassStatic, query);
  }

  async concreteParentInterface(
    identifier: ConcreteParentInterfaceStatic.$Identifier,
  ): Promise<Either<Error, ConcreteParentInterface>> {
    return (
      await this.concreteParentInterfaces({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async concreteParentInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<
      ConcreteParentInterfaceStatic.$Filter,
      ConcreteParentInterfaceStatic.$Identifier
    >,
  ): Promise<
    Either<Error, readonly ConcreteParentInterfaceStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      ConcreteParentInterfaceStatic.$Filter,
      ConcreteParentInterfaceStatic.$Identifier
    >(ConcreteParentInterfaceStatic, query);
  }

  async concreteParentInterfaces(
    query?: $SparqlObjectSet.Query<
      ConcreteParentInterfaceStatic.$Filter,
      ConcreteParentInterfaceStatic.$Identifier
    >,
  ): Promise<Either<Error, readonly ConcreteParentInterface[]>> {
    return this.$objects<
      ConcreteParentInterface,
      ConcreteParentInterfaceStatic.$Filter,
      ConcreteParentInterfaceStatic.$Identifier
    >(ConcreteParentInterfaceStatic, query);
  }

  async concreteParentInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        ConcreteParentInterfaceStatic.$Filter,
        ConcreteParentInterfaceStatic.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      ConcreteParentInterfaceStatic.$Filter,
      ConcreteParentInterfaceStatic.$Identifier
    >(ConcreteParentInterfaceStatic, query);
  }

  async convertibleTypePropertiesClass(
    identifier: ConvertibleTypePropertiesClass.$Identifier,
  ): Promise<Either<Error, ConvertibleTypePropertiesClass>> {
    return (
      await this.convertibleTypePropertiesClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async convertibleTypePropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      ConvertibleTypePropertiesClass.$Filter,
      ConvertibleTypePropertiesClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly ConvertibleTypePropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      ConvertibleTypePropertiesClass.$Filter,
      ConvertibleTypePropertiesClass.$Identifier
    >(ConvertibleTypePropertiesClass, query);
  }

  async convertibleTypePropertiesClasses(
    query?: $SparqlObjectSet.Query<
      ConvertibleTypePropertiesClass.$Filter,
      ConvertibleTypePropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ConvertibleTypePropertiesClass[]>> {
    return this.$objects<
      ConvertibleTypePropertiesClass,
      ConvertibleTypePropertiesClass.$Filter,
      ConvertibleTypePropertiesClass.$Identifier
    >(ConvertibleTypePropertiesClass, query);
  }

  async convertibleTypePropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        ConvertibleTypePropertiesClass.$Filter,
        ConvertibleTypePropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      ConvertibleTypePropertiesClass.$Filter,
      ConvertibleTypePropertiesClass.$Identifier
    >(ConvertibleTypePropertiesClass, query);
  }

  async dateUnionPropertiesClass(
    identifier: DateUnionPropertiesClass.$Identifier,
  ): Promise<Either<Error, DateUnionPropertiesClass>> {
    return (
      await this.dateUnionPropertiesClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async dateUnionPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      DateUnionPropertiesClass.$Filter,
      DateUnionPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly DateUnionPropertiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      DateUnionPropertiesClass.$Filter,
      DateUnionPropertiesClass.$Identifier
    >(DateUnionPropertiesClass, query);
  }

  async dateUnionPropertiesClasses(
    query?: $SparqlObjectSet.Query<
      DateUnionPropertiesClass.$Filter,
      DateUnionPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly DateUnionPropertiesClass[]>> {
    return this.$objects<
      DateUnionPropertiesClass,
      DateUnionPropertiesClass.$Filter,
      DateUnionPropertiesClass.$Identifier
    >(DateUnionPropertiesClass, query);
  }

  async dateUnionPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        DateUnionPropertiesClass.$Filter,
        DateUnionPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      DateUnionPropertiesClass.$Filter,
      DateUnionPropertiesClass.$Identifier
    >(DateUnionPropertiesClass, query);
  }

  async defaultValuePropertiesClass(
    identifier: DefaultValuePropertiesClass.$Identifier,
  ): Promise<Either<Error, DefaultValuePropertiesClass>> {
    return (
      await this.defaultValuePropertiesClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async defaultValuePropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      DefaultValuePropertiesClass.$Filter,
      DefaultValuePropertiesClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly DefaultValuePropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      DefaultValuePropertiesClass.$Filter,
      DefaultValuePropertiesClass.$Identifier
    >(DefaultValuePropertiesClass, query);
  }

  async defaultValuePropertiesClasses(
    query?: $SparqlObjectSet.Query<
      DefaultValuePropertiesClass.$Filter,
      DefaultValuePropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly DefaultValuePropertiesClass[]>> {
    return this.$objects<
      DefaultValuePropertiesClass,
      DefaultValuePropertiesClass.$Filter,
      DefaultValuePropertiesClass.$Identifier
    >(DefaultValuePropertiesClass, query);
  }

  async defaultValuePropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        DefaultValuePropertiesClass.$Filter,
        DefaultValuePropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      DefaultValuePropertiesClass.$Filter,
      DefaultValuePropertiesClass.$Identifier
    >(DefaultValuePropertiesClass, query);
  }

  async directRecursiveClass(
    identifier: DirectRecursiveClass.$Identifier,
  ): Promise<Either<Error, DirectRecursiveClass>> {
    return (
      await this.directRecursiveClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async directRecursiveClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      DirectRecursiveClass.$Filter,
      DirectRecursiveClass.$Identifier
    >,
  ): Promise<Either<Error, readonly DirectRecursiveClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      DirectRecursiveClass.$Filter,
      DirectRecursiveClass.$Identifier
    >(DirectRecursiveClass, query);
  }

  async directRecursiveClasses(
    query?: $SparqlObjectSet.Query<
      DirectRecursiveClass.$Filter,
      DirectRecursiveClass.$Identifier
    >,
  ): Promise<Either<Error, readonly DirectRecursiveClass[]>> {
    return this.$objects<
      DirectRecursiveClass,
      DirectRecursiveClass.$Filter,
      DirectRecursiveClass.$Identifier
    >(DirectRecursiveClass, query);
  }

  async directRecursiveClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        DirectRecursiveClass.$Filter,
        DirectRecursiveClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      DirectRecursiveClass.$Filter,
      DirectRecursiveClass.$Identifier
    >(DirectRecursiveClass, query);
  }

  async explicitFromToRdfTypesClass(
    identifier: ExplicitFromToRdfTypesClass.$Identifier,
  ): Promise<Either<Error, ExplicitFromToRdfTypesClass>> {
    return (
      await this.explicitFromToRdfTypesClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async explicitFromToRdfTypesClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      ExplicitFromToRdfTypesClass.$Filter,
      ExplicitFromToRdfTypesClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly ExplicitFromToRdfTypesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      ExplicitFromToRdfTypesClass.$Filter,
      ExplicitFromToRdfTypesClass.$Identifier
    >(ExplicitFromToRdfTypesClass, query);
  }

  async explicitFromToRdfTypesClasses(
    query?: $SparqlObjectSet.Query<
      ExplicitFromToRdfTypesClass.$Filter,
      ExplicitFromToRdfTypesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ExplicitFromToRdfTypesClass[]>> {
    return this.$objects<
      ExplicitFromToRdfTypesClass,
      ExplicitFromToRdfTypesClass.$Filter,
      ExplicitFromToRdfTypesClass.$Identifier
    >(ExplicitFromToRdfTypesClass, query);
  }

  async explicitFromToRdfTypesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        ExplicitFromToRdfTypesClass.$Filter,
        ExplicitFromToRdfTypesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      ExplicitFromToRdfTypesClass.$Filter,
      ExplicitFromToRdfTypesClass.$Identifier
    >(ExplicitFromToRdfTypesClass, query);
  }

  async explicitRdfTypeClass(
    identifier: ExplicitRdfTypeClass.$Identifier,
  ): Promise<Either<Error, ExplicitRdfTypeClass>> {
    return (
      await this.explicitRdfTypeClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async explicitRdfTypeClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      ExplicitRdfTypeClass.$Filter,
      ExplicitRdfTypeClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ExplicitRdfTypeClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      ExplicitRdfTypeClass.$Filter,
      ExplicitRdfTypeClass.$Identifier
    >(ExplicitRdfTypeClass, query);
  }

  async explicitRdfTypeClasses(
    query?: $SparqlObjectSet.Query<
      ExplicitRdfTypeClass.$Filter,
      ExplicitRdfTypeClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ExplicitRdfTypeClass[]>> {
    return this.$objects<
      ExplicitRdfTypeClass,
      ExplicitRdfTypeClass.$Filter,
      ExplicitRdfTypeClass.$Identifier
    >(ExplicitRdfTypeClass, query);
  }

  async explicitRdfTypeClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        ExplicitRdfTypeClass.$Filter,
        ExplicitRdfTypeClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      ExplicitRdfTypeClass.$Filter,
      ExplicitRdfTypeClass.$Identifier
    >(ExplicitRdfTypeClass, query);
  }

  async externClassPropertyClass(
    identifier: ExternClassPropertyClass.$Identifier,
  ): Promise<Either<Error, ExternClassPropertyClass>> {
    return (
      await this.externClassPropertyClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async externClassPropertyClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      ExternClassPropertyClass.$Filter,
      ExternClassPropertyClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ExternClassPropertyClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      ExternClassPropertyClass.$Filter,
      ExternClassPropertyClass.$Identifier
    >(ExternClassPropertyClass, query);
  }

  async externClassPropertyClasses(
    query?: $SparqlObjectSet.Query<
      ExternClassPropertyClass.$Filter,
      ExternClassPropertyClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ExternClassPropertyClass[]>> {
    return this.$objects<
      ExternClassPropertyClass,
      ExternClassPropertyClass.$Filter,
      ExternClassPropertyClass.$Identifier
    >(ExternClassPropertyClass, query);
  }

  async externClassPropertyClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        ExternClassPropertyClass.$Filter,
        ExternClassPropertyClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      ExternClassPropertyClass.$Filter,
      ExternClassPropertyClass.$Identifier
    >(ExternClassPropertyClass, query);
  }

  async flattenClassUnionMember3(
    identifier: FlattenClassUnionMember3.$Identifier,
  ): Promise<Either<Error, FlattenClassUnionMember3>> {
    return (
      await this.flattenClassUnionMember3s({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async flattenClassUnionMember3Identifiers(
    query?: $SparqlObjectSet.Query<
      FlattenClassUnionMember3.$Filter,
      FlattenClassUnionMember3.$Identifier
    >,
  ): Promise<Either<Error, readonly FlattenClassUnionMember3.$Identifier[]>> {
    return this.$objectIdentifiers<
      FlattenClassUnionMember3.$Filter,
      FlattenClassUnionMember3.$Identifier
    >(FlattenClassUnionMember3, query);
  }

  async flattenClassUnionMember3s(
    query?: $SparqlObjectSet.Query<
      FlattenClassUnionMember3.$Filter,
      FlattenClassUnionMember3.$Identifier
    >,
  ): Promise<Either<Error, readonly FlattenClassUnionMember3[]>> {
    return this.$objects<
      FlattenClassUnionMember3,
      FlattenClassUnionMember3.$Filter,
      FlattenClassUnionMember3.$Identifier
    >(FlattenClassUnionMember3, query);
  }

  async flattenClassUnionMember3sCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        FlattenClassUnionMember3.$Filter,
        FlattenClassUnionMember3.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      FlattenClassUnionMember3.$Filter,
      FlattenClassUnionMember3.$Identifier
    >(FlattenClassUnionMember3, query);
  }

  async hasValuePropertiesClass(
    identifier: HasValuePropertiesClass.$Identifier,
  ): Promise<Either<Error, HasValuePropertiesClass>> {
    return (
      await this.hasValuePropertiesClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async hasValuePropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      HasValuePropertiesClass.$Filter,
      HasValuePropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly HasValuePropertiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      HasValuePropertiesClass.$Filter,
      HasValuePropertiesClass.$Identifier
    >(HasValuePropertiesClass, query);
  }

  async hasValuePropertiesClasses(
    query?: $SparqlObjectSet.Query<
      HasValuePropertiesClass.$Filter,
      HasValuePropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly HasValuePropertiesClass[]>> {
    return this.$objects<
      HasValuePropertiesClass,
      HasValuePropertiesClass.$Filter,
      HasValuePropertiesClass.$Identifier
    >(HasValuePropertiesClass, query);
  }

  async hasValuePropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        HasValuePropertiesClass.$Filter,
        HasValuePropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      HasValuePropertiesClass.$Filter,
      HasValuePropertiesClass.$Identifier
    >(HasValuePropertiesClass, query);
  }

  async identifierOverride3Class(
    identifier: IdentifierOverride3ClassStatic.$Identifier,
  ): Promise<Either<Error, IdentifierOverride3Class>> {
    return (
      await this.identifierOverride3Classes({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async identifierOverride3ClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      IdentifierOverride3ClassStatic.$Filter,
      IdentifierOverride3ClassStatic.$Identifier
    >,
  ): Promise<
    Either<Error, readonly IdentifierOverride3ClassStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      IdentifierOverride3ClassStatic.$Filter,
      IdentifierOverride3ClassStatic.$Identifier
    >(IdentifierOverride3ClassStatic, query);
  }

  async identifierOverride3Classes(
    query?: $SparqlObjectSet.Query<
      IdentifierOverride3ClassStatic.$Filter,
      IdentifierOverride3ClassStatic.$Identifier
    >,
  ): Promise<Either<Error, readonly IdentifierOverride3Class[]>> {
    return this.$objects<
      IdentifierOverride3Class,
      IdentifierOverride3ClassStatic.$Filter,
      IdentifierOverride3ClassStatic.$Identifier
    >(IdentifierOverride3ClassStatic, query);
  }

  async identifierOverride3ClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        IdentifierOverride3ClassStatic.$Filter,
        IdentifierOverride3ClassStatic.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      IdentifierOverride3ClassStatic.$Filter,
      IdentifierOverride3ClassStatic.$Identifier
    >(IdentifierOverride3ClassStatic, query);
  }

  async identifierOverride4Class(
    identifier: IdentifierOverride4ClassStatic.$Identifier,
  ): Promise<Either<Error, IdentifierOverride4Class>> {
    return (
      await this.identifierOverride4Classes({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async identifierOverride4ClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      IdentifierOverride4ClassStatic.$Filter,
      IdentifierOverride4ClassStatic.$Identifier
    >,
  ): Promise<
    Either<Error, readonly IdentifierOverride4ClassStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      IdentifierOverride4ClassStatic.$Filter,
      IdentifierOverride4ClassStatic.$Identifier
    >(IdentifierOverride4ClassStatic, query);
  }

  async identifierOverride4Classes(
    query?: $SparqlObjectSet.Query<
      IdentifierOverride4ClassStatic.$Filter,
      IdentifierOverride4ClassStatic.$Identifier
    >,
  ): Promise<Either<Error, readonly IdentifierOverride4Class[]>> {
    return this.$objects<
      IdentifierOverride4Class,
      IdentifierOverride4ClassStatic.$Filter,
      IdentifierOverride4ClassStatic.$Identifier
    >(IdentifierOverride4ClassStatic, query);
  }

  async identifierOverride4ClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        IdentifierOverride4ClassStatic.$Filter,
        IdentifierOverride4ClassStatic.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      IdentifierOverride4ClassStatic.$Filter,
      IdentifierOverride4ClassStatic.$Identifier
    >(IdentifierOverride4ClassStatic, query);
  }

  async identifierOverride5Class(
    identifier: IdentifierOverride5Class.$Identifier,
  ): Promise<Either<Error, IdentifierOverride5Class>> {
    return (
      await this.identifierOverride5Classes({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async identifierOverride5ClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      IdentifierOverride5Class.$Filter,
      IdentifierOverride5Class.$Identifier
    >,
  ): Promise<Either<Error, readonly IdentifierOverride5Class.$Identifier[]>> {
    return this.$objectIdentifiers<
      IdentifierOverride5Class.$Filter,
      IdentifierOverride5Class.$Identifier
    >(IdentifierOverride5Class, query);
  }

  async identifierOverride5Classes(
    query?: $SparqlObjectSet.Query<
      IdentifierOverride5Class.$Filter,
      IdentifierOverride5Class.$Identifier
    >,
  ): Promise<Either<Error, readonly IdentifierOverride5Class[]>> {
    return this.$objects<
      IdentifierOverride5Class,
      IdentifierOverride5Class.$Filter,
      IdentifierOverride5Class.$Identifier
    >(IdentifierOverride5Class, query);
  }

  async identifierOverride5ClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        IdentifierOverride5Class.$Filter,
        IdentifierOverride5Class.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      IdentifierOverride5Class.$Filter,
      IdentifierOverride5Class.$Identifier
    >(IdentifierOverride5Class, query);
  }

  async indirectRecursiveClass(
    identifier: IndirectRecursiveClass.$Identifier,
  ): Promise<Either<Error, IndirectRecursiveClass>> {
    return (
      await this.indirectRecursiveClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async indirectRecursiveClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      IndirectRecursiveClass.$Filter,
      IndirectRecursiveClass.$Identifier
    >,
  ): Promise<Either<Error, readonly IndirectRecursiveClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      IndirectRecursiveClass.$Filter,
      IndirectRecursiveClass.$Identifier
    >(IndirectRecursiveClass, query);
  }

  async indirectRecursiveClasses(
    query?: $SparqlObjectSet.Query<
      IndirectRecursiveClass.$Filter,
      IndirectRecursiveClass.$Identifier
    >,
  ): Promise<Either<Error, readonly IndirectRecursiveClass[]>> {
    return this.$objects<
      IndirectRecursiveClass,
      IndirectRecursiveClass.$Filter,
      IndirectRecursiveClass.$Identifier
    >(IndirectRecursiveClass, query);
  }

  async indirectRecursiveClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        IndirectRecursiveClass.$Filter,
        IndirectRecursiveClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      IndirectRecursiveClass.$Filter,
      IndirectRecursiveClass.$Identifier
    >(IndirectRecursiveClass, query);
  }

  async indirectRecursiveHelperClass(
    identifier: IndirectRecursiveHelperClass.$Identifier,
  ): Promise<Either<Error, IndirectRecursiveHelperClass>> {
    return (
      await this.indirectRecursiveHelperClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async indirectRecursiveHelperClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      IndirectRecursiveHelperClass.$Filter,
      IndirectRecursiveHelperClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly IndirectRecursiveHelperClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      IndirectRecursiveHelperClass.$Filter,
      IndirectRecursiveHelperClass.$Identifier
    >(IndirectRecursiveHelperClass, query);
  }

  async indirectRecursiveHelperClasses(
    query?: $SparqlObjectSet.Query<
      IndirectRecursiveHelperClass.$Filter,
      IndirectRecursiveHelperClass.$Identifier
    >,
  ): Promise<Either<Error, readonly IndirectRecursiveHelperClass[]>> {
    return this.$objects<
      IndirectRecursiveHelperClass,
      IndirectRecursiveHelperClass.$Filter,
      IndirectRecursiveHelperClass.$Identifier
    >(IndirectRecursiveHelperClass, query);
  }

  async indirectRecursiveHelperClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        IndirectRecursiveHelperClass.$Filter,
        IndirectRecursiveHelperClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      IndirectRecursiveHelperClass.$Filter,
      IndirectRecursiveHelperClass.$Identifier
    >(IndirectRecursiveHelperClass, query);
  }

  async inIdentifierClass(
    identifier: InIdentifierClass.$Identifier,
  ): Promise<Either<Error, InIdentifierClass>> {
    return (await this.inIdentifierClasses({ identifiers: [identifier] })).map(
      (objects) => objects[0],
    );
  }

  async inIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      InIdentifierClass.$Filter,
      InIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly InIdentifierClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      InIdentifierClass.$Filter,
      InIdentifierClass.$Identifier
    >(InIdentifierClass, query);
  }

  async inIdentifierClasses(
    query?: $SparqlObjectSet.Query<
      InIdentifierClass.$Filter,
      InIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly InIdentifierClass[]>> {
    return this.$objects<
      InIdentifierClass,
      InIdentifierClass.$Filter,
      InIdentifierClass.$Identifier
    >(InIdentifierClass, query);
  }

  async inIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        InIdentifierClass.$Filter,
        InIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      InIdentifierClass.$Filter,
      InIdentifierClass.$Identifier
    >(InIdentifierClass, query);
  }

  async inPropertiesClass(
    identifier: InPropertiesClass.$Identifier,
  ): Promise<Either<Error, InPropertiesClass>> {
    return (await this.inPropertiesClasses({ identifiers: [identifier] })).map(
      (objects) => objects[0],
    );
  }

  async inPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      InPropertiesClass.$Filter,
      InPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly InPropertiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      InPropertiesClass.$Filter,
      InPropertiesClass.$Identifier
    >(InPropertiesClass, query);
  }

  async inPropertiesClasses(
    query?: $SparqlObjectSet.Query<
      InPropertiesClass.$Filter,
      InPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly InPropertiesClass[]>> {
    return this.$objects<
      InPropertiesClass,
      InPropertiesClass.$Filter,
      InPropertiesClass.$Identifier
    >(InPropertiesClass, query);
  }

  async inPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        InPropertiesClass.$Filter,
        InPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      InPropertiesClass.$Filter,
      InPropertiesClass.$Identifier
    >(InPropertiesClass, query);
  }

  async interface(
    identifier: Interface.$Identifier,
  ): Promise<Either<Error, Interface>> {
    return (await this.interfaces({ identifiers: [identifier] })).map(
      (objects) => objects[0],
    );
  }

  async interfaceIdentifiers(
    query?: $SparqlObjectSet.Query<Interface.$Filter, Interface.$Identifier>,
  ): Promise<Either<Error, readonly Interface.$Identifier[]>> {
    return this.$objectIdentifiers<Interface.$Filter, Interface.$Identifier>(
      Interface,
      query,
    );
  }

  async interfaces(
    query?: $SparqlObjectSet.Query<Interface.$Filter, Interface.$Identifier>,
  ): Promise<Either<Error, readonly Interface[]>> {
    return this.$objects<Interface, Interface.$Filter, Interface.$Identifier>(
      Interface,
      query,
    );
  }

  async interfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<Interface.$Filter, Interface.$Identifier>,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<Interface.$Filter, Interface.$Identifier>(
      Interface,
      query,
    );
  }

  async interfaceUnionMember1(
    identifier: InterfaceUnionMember1.$Identifier,
  ): Promise<Either<Error, InterfaceUnionMember1>> {
    return (
      await this.interfaceUnionMember1s({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async interfaceUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<
      InterfaceUnionMember1.$Filter,
      InterfaceUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly InterfaceUnionMember1.$Identifier[]>> {
    return this.$objectIdentifiers<
      InterfaceUnionMember1.$Filter,
      InterfaceUnionMember1.$Identifier
    >(InterfaceUnionMember1, query);
  }

  async interfaceUnionMember1s(
    query?: $SparqlObjectSet.Query<
      InterfaceUnionMember1.$Filter,
      InterfaceUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly InterfaceUnionMember1[]>> {
    return this.$objects<
      InterfaceUnionMember1,
      InterfaceUnionMember1.$Filter,
      InterfaceUnionMember1.$Identifier
    >(InterfaceUnionMember1, query);
  }

  async interfaceUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        InterfaceUnionMember1.$Filter,
        InterfaceUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      InterfaceUnionMember1.$Filter,
      InterfaceUnionMember1.$Identifier
    >(InterfaceUnionMember1, query);
  }

  async interfaceUnionMember2(
    identifier: InterfaceUnionMember2.$Identifier,
  ): Promise<Either<Error, InterfaceUnionMember2>> {
    return (
      await this.interfaceUnionMember2s({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async interfaceUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<
      InterfaceUnionMember2.$Filter,
      InterfaceUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly InterfaceUnionMember2.$Identifier[]>> {
    return this.$objectIdentifiers<
      InterfaceUnionMember2.$Filter,
      InterfaceUnionMember2.$Identifier
    >(InterfaceUnionMember2, query);
  }

  async interfaceUnionMember2s(
    query?: $SparqlObjectSet.Query<
      InterfaceUnionMember2.$Filter,
      InterfaceUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly InterfaceUnionMember2[]>> {
    return this.$objects<
      InterfaceUnionMember2,
      InterfaceUnionMember2.$Filter,
      InterfaceUnionMember2.$Identifier
    >(InterfaceUnionMember2, query);
  }

  async interfaceUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        InterfaceUnionMember2.$Filter,
        InterfaceUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      InterfaceUnionMember2.$Filter,
      InterfaceUnionMember2.$Identifier
    >(InterfaceUnionMember2, query);
  }

  async iriIdentifierClass(
    identifier: IriIdentifierClass.$Identifier,
  ): Promise<Either<Error, IriIdentifierClass>> {
    return (await this.iriIdentifierClasses({ identifiers: [identifier] })).map(
      (objects) => objects[0],
    );
  }

  async iriIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      IriIdentifierClass.$Filter,
      IriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly IriIdentifierClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      IriIdentifierClass.$Filter,
      IriIdentifierClass.$Identifier
    >(IriIdentifierClass, query);
  }

  async iriIdentifierClasses(
    query?: $SparqlObjectSet.Query<
      IriIdentifierClass.$Filter,
      IriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly IriIdentifierClass[]>> {
    return this.$objects<
      IriIdentifierClass,
      IriIdentifierClass.$Filter,
      IriIdentifierClass.$Identifier
    >(IriIdentifierClass, query);
  }

  async iriIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        IriIdentifierClass.$Filter,
        IriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      IriIdentifierClass.$Filter,
      IriIdentifierClass.$Identifier
    >(IriIdentifierClass, query);
  }

  async iriIdentifierInterface(
    identifier: IriIdentifierInterface.$Identifier,
  ): Promise<Either<Error, IriIdentifierInterface>> {
    return (
      await this.iriIdentifierInterfaces({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async iriIdentifierInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<
      IriIdentifierInterface.$Filter,
      IriIdentifierInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly IriIdentifierInterface.$Identifier[]>> {
    return this.$objectIdentifiers<
      IriIdentifierInterface.$Filter,
      IriIdentifierInterface.$Identifier
    >(IriIdentifierInterface, query);
  }

  async iriIdentifierInterfaces(
    query?: $SparqlObjectSet.Query<
      IriIdentifierInterface.$Filter,
      IriIdentifierInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly IriIdentifierInterface[]>> {
    return this.$objects<
      IriIdentifierInterface,
      IriIdentifierInterface.$Filter,
      IriIdentifierInterface.$Identifier
    >(IriIdentifierInterface, query);
  }

  async iriIdentifierInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        IriIdentifierInterface.$Filter,
        IriIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      IriIdentifierInterface.$Filter,
      IriIdentifierInterface.$Identifier
    >(IriIdentifierInterface, query);
  }

  async jsPrimitiveUnionPropertyClass(
    identifier: JsPrimitiveUnionPropertyClass.$Identifier,
  ): Promise<Either<Error, JsPrimitiveUnionPropertyClass>> {
    return (
      await this.jsPrimitiveUnionPropertyClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async jsPrimitiveUnionPropertyClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      JsPrimitiveUnionPropertyClass.$Filter,
      JsPrimitiveUnionPropertyClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly JsPrimitiveUnionPropertyClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      JsPrimitiveUnionPropertyClass.$Filter,
      JsPrimitiveUnionPropertyClass.$Identifier
    >(JsPrimitiveUnionPropertyClass, query);
  }

  async jsPrimitiveUnionPropertyClasses(
    query?: $SparqlObjectSet.Query<
      JsPrimitiveUnionPropertyClass.$Filter,
      JsPrimitiveUnionPropertyClass.$Identifier
    >,
  ): Promise<Either<Error, readonly JsPrimitiveUnionPropertyClass[]>> {
    return this.$objects<
      JsPrimitiveUnionPropertyClass,
      JsPrimitiveUnionPropertyClass.$Filter,
      JsPrimitiveUnionPropertyClass.$Identifier
    >(JsPrimitiveUnionPropertyClass, query);
  }

  async jsPrimitiveUnionPropertyClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        JsPrimitiveUnionPropertyClass.$Filter,
        JsPrimitiveUnionPropertyClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      JsPrimitiveUnionPropertyClass.$Filter,
      JsPrimitiveUnionPropertyClass.$Identifier
    >(JsPrimitiveUnionPropertyClass, query);
  }

  async languageInPropertiesClass(
    identifier: LanguageInPropertiesClass.$Identifier,
  ): Promise<Either<Error, LanguageInPropertiesClass>> {
    return (
      await this.languageInPropertiesClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async languageInPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      LanguageInPropertiesClass.$Filter,
      LanguageInPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly LanguageInPropertiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      LanguageInPropertiesClass.$Filter,
      LanguageInPropertiesClass.$Identifier
    >(LanguageInPropertiesClass, query);
  }

  async languageInPropertiesClasses(
    query?: $SparqlObjectSet.Query<
      LanguageInPropertiesClass.$Filter,
      LanguageInPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly LanguageInPropertiesClass[]>> {
    return this.$objects<
      LanguageInPropertiesClass,
      LanguageInPropertiesClass.$Filter,
      LanguageInPropertiesClass.$Identifier
    >(LanguageInPropertiesClass, query);
  }

  async languageInPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        LanguageInPropertiesClass.$Filter,
        LanguageInPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      LanguageInPropertiesClass.$Filter,
      LanguageInPropertiesClass.$Identifier
    >(LanguageInPropertiesClass, query);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClass(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<Either<Error, LazilyResolvedBlankNodeOrIriIdentifierClass>> {
    return (
      await this.lazilyResolvedBlankNodeOrIriIdentifierClasses({
        identifiers: [identifier],
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
    >,
  ): Promise<
    Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
    >(LazilyResolvedBlankNodeOrIriIdentifierClass, query);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClasses(
    query?: $SparqlObjectSet.Query<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedBlankNodeOrIriIdentifierClass[]>
  > {
    return this.$objects<
      LazilyResolvedBlankNodeOrIriIdentifierClass,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
    >(LazilyResolvedBlankNodeOrIriIdentifierClass, query);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
    >(LazilyResolvedBlankNodeOrIriIdentifierClass, query);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterface(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<Either<Error, LazilyResolvedBlankNodeOrIriIdentifierInterface>> {
    return (
      await this.lazilyResolvedBlankNodeOrIriIdentifierInterfaces({
        identifiers: [identifier],
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
    >,
  ): Promise<
    Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
    >(LazilyResolvedBlankNodeOrIriIdentifierInterface, query);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterfaces(
    query?: $SparqlObjectSet.Query<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[]>
  > {
    return this.$objects<
      LazilyResolvedBlankNodeOrIriIdentifierInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
    >(LazilyResolvedBlankNodeOrIriIdentifierInterface, query);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
    >(LazilyResolvedBlankNodeOrIriIdentifierInterface, query);
  }

  async lazilyResolvedClassUnionMember1(
    identifier: LazilyResolvedClassUnionMember1.$Identifier,
  ): Promise<Either<Error, LazilyResolvedClassUnionMember1>> {
    return (
      await this.lazilyResolvedClassUnionMember1s({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<
      LazilyResolvedClassUnionMember1.$Filter,
      LazilyResolvedClassUnionMember1.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedClassUnionMember1.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      LazilyResolvedClassUnionMember1.$Filter,
      LazilyResolvedClassUnionMember1.$Identifier
    >(LazilyResolvedClassUnionMember1, query);
  }

  async lazilyResolvedClassUnionMember1s(
    query?: $SparqlObjectSet.Query<
      LazilyResolvedClassUnionMember1.$Filter,
      LazilyResolvedClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedClassUnionMember1[]>> {
    return this.$objects<
      LazilyResolvedClassUnionMember1,
      LazilyResolvedClassUnionMember1.$Filter,
      LazilyResolvedClassUnionMember1.$Identifier
    >(LazilyResolvedClassUnionMember1, query);
  }

  async lazilyResolvedClassUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        LazilyResolvedClassUnionMember1.$Filter,
        LazilyResolvedClassUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      LazilyResolvedClassUnionMember1.$Filter,
      LazilyResolvedClassUnionMember1.$Identifier
    >(LazilyResolvedClassUnionMember1, query);
  }

  async lazilyResolvedClassUnionMember2(
    identifier: LazilyResolvedClassUnionMember2.$Identifier,
  ): Promise<Either<Error, LazilyResolvedClassUnionMember2>> {
    return (
      await this.lazilyResolvedClassUnionMember2s({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<
      LazilyResolvedClassUnionMember2.$Filter,
      LazilyResolvedClassUnionMember2.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedClassUnionMember2.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      LazilyResolvedClassUnionMember2.$Filter,
      LazilyResolvedClassUnionMember2.$Identifier
    >(LazilyResolvedClassUnionMember2, query);
  }

  async lazilyResolvedClassUnionMember2s(
    query?: $SparqlObjectSet.Query<
      LazilyResolvedClassUnionMember2.$Filter,
      LazilyResolvedClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedClassUnionMember2[]>> {
    return this.$objects<
      LazilyResolvedClassUnionMember2,
      LazilyResolvedClassUnionMember2.$Filter,
      LazilyResolvedClassUnionMember2.$Identifier
    >(LazilyResolvedClassUnionMember2, query);
  }

  async lazilyResolvedClassUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        LazilyResolvedClassUnionMember2.$Filter,
        LazilyResolvedClassUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      LazilyResolvedClassUnionMember2.$Filter,
      LazilyResolvedClassUnionMember2.$Identifier
    >(LazilyResolvedClassUnionMember2, query);
  }

  async lazilyResolvedInterfaceUnionMember1(
    identifier: LazilyResolvedInterfaceUnionMember1.$Identifier,
  ): Promise<Either<Error, LazilyResolvedInterfaceUnionMember1>> {
    return (
      await this.lazilyResolvedInterfaceUnionMember1s({
        identifiers: [identifier],
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<
      LazilyResolvedInterfaceUnionMember1.$Filter,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedInterfaceUnionMember1.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      LazilyResolvedInterfaceUnionMember1.$Filter,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >(LazilyResolvedInterfaceUnionMember1, query);
  }

  async lazilyResolvedInterfaceUnionMember1s(
    query?: $SparqlObjectSet.Query<
      LazilyResolvedInterfaceUnionMember1.$Filter,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedInterfaceUnionMember1[]>> {
    return this.$objects<
      LazilyResolvedInterfaceUnionMember1,
      LazilyResolvedInterfaceUnionMember1.$Filter,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >(LazilyResolvedInterfaceUnionMember1, query);
  }

  async lazilyResolvedInterfaceUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        LazilyResolvedInterfaceUnionMember1.$Filter,
        LazilyResolvedInterfaceUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      LazilyResolvedInterfaceUnionMember1.$Filter,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >(LazilyResolvedInterfaceUnionMember1, query);
  }

  async lazilyResolvedInterfaceUnionMember2(
    identifier: LazilyResolvedInterfaceUnionMember2.$Identifier,
  ): Promise<Either<Error, LazilyResolvedInterfaceUnionMember2>> {
    return (
      await this.lazilyResolvedInterfaceUnionMember2s({
        identifiers: [identifier],
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<
      LazilyResolvedInterfaceUnionMember2.$Filter,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedInterfaceUnionMember2.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      LazilyResolvedInterfaceUnionMember2.$Filter,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >(LazilyResolvedInterfaceUnionMember2, query);
  }

  async lazilyResolvedInterfaceUnionMember2s(
    query?: $SparqlObjectSet.Query<
      LazilyResolvedInterfaceUnionMember2.$Filter,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedInterfaceUnionMember2[]>> {
    return this.$objects<
      LazilyResolvedInterfaceUnionMember2,
      LazilyResolvedInterfaceUnionMember2.$Filter,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >(LazilyResolvedInterfaceUnionMember2, query);
  }

  async lazilyResolvedInterfaceUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        LazilyResolvedInterfaceUnionMember2.$Filter,
        LazilyResolvedInterfaceUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      LazilyResolvedInterfaceUnionMember2.$Filter,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >(LazilyResolvedInterfaceUnionMember2, query);
  }

  async lazilyResolvedIriIdentifierClass(
    identifier: LazilyResolvedIriIdentifierClass.$Identifier,
  ): Promise<Either<Error, LazilyResolvedIriIdentifierClass>> {
    return (
      await this.lazilyResolvedIriIdentifierClasses({
        identifiers: [identifier],
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedIriIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      LazilyResolvedIriIdentifierClass.$Filter,
      LazilyResolvedIriIdentifierClass.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedIriIdentifierClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      LazilyResolvedIriIdentifierClass.$Filter,
      LazilyResolvedIriIdentifierClass.$Identifier
    >(LazilyResolvedIriIdentifierClass, query);
  }

  async lazilyResolvedIriIdentifierClasses(
    query?: $SparqlObjectSet.Query<
      LazilyResolvedIriIdentifierClass.$Filter,
      LazilyResolvedIriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedIriIdentifierClass[]>> {
    return this.$objects<
      LazilyResolvedIriIdentifierClass,
      LazilyResolvedIriIdentifierClass.$Filter,
      LazilyResolvedIriIdentifierClass.$Identifier
    >(LazilyResolvedIriIdentifierClass, query);
  }

  async lazilyResolvedIriIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        LazilyResolvedIriIdentifierClass.$Filter,
        LazilyResolvedIriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      LazilyResolvedIriIdentifierClass.$Filter,
      LazilyResolvedIriIdentifierClass.$Identifier
    >(LazilyResolvedIriIdentifierClass, query);
  }

  async lazilyResolvedIriIdentifierInterface(
    identifier: LazilyResolvedIriIdentifierInterface.$Identifier,
  ): Promise<Either<Error, LazilyResolvedIriIdentifierInterface>> {
    return (
      await this.lazilyResolvedIriIdentifierInterfaces({
        identifiers: [identifier],
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedIriIdentifierInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<
      LazilyResolvedIriIdentifierInterface.$Filter,
      LazilyResolvedIriIdentifierInterface.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedIriIdentifierInterface.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      LazilyResolvedIriIdentifierInterface.$Filter,
      LazilyResolvedIriIdentifierInterface.$Identifier
    >(LazilyResolvedIriIdentifierInterface, query);
  }

  async lazilyResolvedIriIdentifierInterfaces(
    query?: $SparqlObjectSet.Query<
      LazilyResolvedIriIdentifierInterface.$Filter,
      LazilyResolvedIriIdentifierInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedIriIdentifierInterface[]>> {
    return this.$objects<
      LazilyResolvedIriIdentifierInterface,
      LazilyResolvedIriIdentifierInterface.$Filter,
      LazilyResolvedIriIdentifierInterface.$Identifier
    >(LazilyResolvedIriIdentifierInterface, query);
  }

  async lazilyResolvedIriIdentifierInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        LazilyResolvedIriIdentifierInterface.$Filter,
        LazilyResolvedIriIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      LazilyResolvedIriIdentifierInterface.$Filter,
      LazilyResolvedIriIdentifierInterface.$Identifier
    >(LazilyResolvedIriIdentifierInterface, query);
  }

  async lazyPropertiesClass(
    identifier: LazyPropertiesClass.$Identifier,
  ): Promise<Either<Error, LazyPropertiesClass>> {
    return (
      await this.lazyPropertiesClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async lazyPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      LazyPropertiesClass.$Filter,
      LazyPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly LazyPropertiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      LazyPropertiesClass.$Filter,
      LazyPropertiesClass.$Identifier
    >(LazyPropertiesClass, query);
  }

  async lazyPropertiesClasses(
    query?: $SparqlObjectSet.Query<
      LazyPropertiesClass.$Filter,
      LazyPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly LazyPropertiesClass[]>> {
    return this.$objects<
      LazyPropertiesClass,
      LazyPropertiesClass.$Filter,
      LazyPropertiesClass.$Identifier
    >(LazyPropertiesClass, query);
  }

  async lazyPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        LazyPropertiesClass.$Filter,
        LazyPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      LazyPropertiesClass.$Filter,
      LazyPropertiesClass.$Identifier
    >(LazyPropertiesClass, query);
  }

  async lazyPropertiesInterface(
    identifier: LazyPropertiesInterface.$Identifier,
  ): Promise<Either<Error, LazyPropertiesInterface>> {
    return (
      await this.lazyPropertiesInterfaces({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async lazyPropertiesInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<
      LazyPropertiesInterface.$Filter,
      LazyPropertiesInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly LazyPropertiesInterface.$Identifier[]>> {
    return this.$objectIdentifiers<
      LazyPropertiesInterface.$Filter,
      LazyPropertiesInterface.$Identifier
    >(LazyPropertiesInterface, query);
  }

  async lazyPropertiesInterfaces(
    query?: $SparqlObjectSet.Query<
      LazyPropertiesInterface.$Filter,
      LazyPropertiesInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly LazyPropertiesInterface[]>> {
    return this.$objects<
      LazyPropertiesInterface,
      LazyPropertiesInterface.$Filter,
      LazyPropertiesInterface.$Identifier
    >(LazyPropertiesInterface, query);
  }

  async lazyPropertiesInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        LazyPropertiesInterface.$Filter,
        LazyPropertiesInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      LazyPropertiesInterface.$Filter,
      LazyPropertiesInterface.$Identifier
    >(LazyPropertiesInterface, query);
  }

  async listPropertiesClass(
    identifier: ListPropertiesClass.$Identifier,
  ): Promise<Either<Error, ListPropertiesClass>> {
    return (
      await this.listPropertiesClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async listPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      ListPropertiesClass.$Filter,
      ListPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ListPropertiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      ListPropertiesClass.$Filter,
      ListPropertiesClass.$Identifier
    >(ListPropertiesClass, query);
  }

  async listPropertiesClasses(
    query?: $SparqlObjectSet.Query<
      ListPropertiesClass.$Filter,
      ListPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly ListPropertiesClass[]>> {
    return this.$objects<
      ListPropertiesClass,
      ListPropertiesClass.$Filter,
      ListPropertiesClass.$Identifier
    >(ListPropertiesClass, query);
  }

  async listPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        ListPropertiesClass.$Filter,
        ListPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      ListPropertiesClass.$Filter,
      ListPropertiesClass.$Identifier
    >(ListPropertiesClass, query);
  }

  async mutablePropertiesClass(
    identifier: MutablePropertiesClass.$Identifier,
  ): Promise<Either<Error, MutablePropertiesClass>> {
    return (
      await this.mutablePropertiesClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async mutablePropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      MutablePropertiesClass.$Filter,
      MutablePropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly MutablePropertiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      MutablePropertiesClass.$Filter,
      MutablePropertiesClass.$Identifier
    >(MutablePropertiesClass, query);
  }

  async mutablePropertiesClasses(
    query?: $SparqlObjectSet.Query<
      MutablePropertiesClass.$Filter,
      MutablePropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly MutablePropertiesClass[]>> {
    return this.$objects<
      MutablePropertiesClass,
      MutablePropertiesClass.$Filter,
      MutablePropertiesClass.$Identifier
    >(MutablePropertiesClass, query);
  }

  async mutablePropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        MutablePropertiesClass.$Filter,
        MutablePropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      MutablePropertiesClass.$Filter,
      MutablePropertiesClass.$Identifier
    >(MutablePropertiesClass, query);
  }

  async nonClass(
    identifier: NonClass.$Identifier,
  ): Promise<Either<Error, NonClass>> {
    return (await this.nonClasses({ identifiers: [identifier] })).map(
      (objects) => objects[0],
    );
  }

  async nonClassIdentifiers(
    query?: $SparqlObjectSet.Query<NonClass.$Filter, NonClass.$Identifier>,
  ): Promise<Either<Error, readonly NonClass.$Identifier[]>> {
    return this.$objectIdentifiers<NonClass.$Filter, NonClass.$Identifier>(
      NonClass,
      query,
    );
  }

  async nonClasses(
    query?: $SparqlObjectSet.Query<NonClass.$Filter, NonClass.$Identifier>,
  ): Promise<Either<Error, readonly NonClass[]>> {
    return this.$objects<NonClass, NonClass.$Filter, NonClass.$Identifier>(
      NonClass,
      query,
    );
  }

  async nonClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<NonClass.$Filter, NonClass.$Identifier>,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<NonClass.$Filter, NonClass.$Identifier>(
      NonClass,
      query,
    );
  }

  async noRdfTypeClassUnionMember1(
    identifier: NoRdfTypeClassUnionMember1.$Identifier,
  ): Promise<Either<Error, NoRdfTypeClassUnionMember1>> {
    return (
      await this.noRdfTypeClassUnionMember1s({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async noRdfTypeClassUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<
      NoRdfTypeClassUnionMember1.$Filter,
      NoRdfTypeClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly NoRdfTypeClassUnionMember1.$Identifier[]>> {
    return this.$objectIdentifiers<
      NoRdfTypeClassUnionMember1.$Filter,
      NoRdfTypeClassUnionMember1.$Identifier
    >(NoRdfTypeClassUnionMember1, query);
  }

  async noRdfTypeClassUnionMember1s(
    query?: $SparqlObjectSet.Query<
      NoRdfTypeClassUnionMember1.$Filter,
      NoRdfTypeClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly NoRdfTypeClassUnionMember1[]>> {
    return this.$objects<
      NoRdfTypeClassUnionMember1,
      NoRdfTypeClassUnionMember1.$Filter,
      NoRdfTypeClassUnionMember1.$Identifier
    >(NoRdfTypeClassUnionMember1, query);
  }

  async noRdfTypeClassUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        NoRdfTypeClassUnionMember1.$Filter,
        NoRdfTypeClassUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      NoRdfTypeClassUnionMember1.$Filter,
      NoRdfTypeClassUnionMember1.$Identifier
    >(NoRdfTypeClassUnionMember1, query);
  }

  async noRdfTypeClassUnionMember2(
    identifier: NoRdfTypeClassUnionMember2.$Identifier,
  ): Promise<Either<Error, NoRdfTypeClassUnionMember2>> {
    return (
      await this.noRdfTypeClassUnionMember2s({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async noRdfTypeClassUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<
      NoRdfTypeClassUnionMember2.$Filter,
      NoRdfTypeClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly NoRdfTypeClassUnionMember2.$Identifier[]>> {
    return this.$objectIdentifiers<
      NoRdfTypeClassUnionMember2.$Filter,
      NoRdfTypeClassUnionMember2.$Identifier
    >(NoRdfTypeClassUnionMember2, query);
  }

  async noRdfTypeClassUnionMember2s(
    query?: $SparqlObjectSet.Query<
      NoRdfTypeClassUnionMember2.$Filter,
      NoRdfTypeClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly NoRdfTypeClassUnionMember2[]>> {
    return this.$objects<
      NoRdfTypeClassUnionMember2,
      NoRdfTypeClassUnionMember2.$Filter,
      NoRdfTypeClassUnionMember2.$Identifier
    >(NoRdfTypeClassUnionMember2, query);
  }

  async noRdfTypeClassUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        NoRdfTypeClassUnionMember2.$Filter,
        NoRdfTypeClassUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      NoRdfTypeClassUnionMember2.$Filter,
      NoRdfTypeClassUnionMember2.$Identifier
    >(NoRdfTypeClassUnionMember2, query);
  }

  async orderedPropertiesClass(
    identifier: OrderedPropertiesClass.$Identifier,
  ): Promise<Either<Error, OrderedPropertiesClass>> {
    return (
      await this.orderedPropertiesClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async orderedPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      OrderedPropertiesClass.$Filter,
      OrderedPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly OrderedPropertiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      OrderedPropertiesClass.$Filter,
      OrderedPropertiesClass.$Identifier
    >(OrderedPropertiesClass, query);
  }

  async orderedPropertiesClasses(
    query?: $SparqlObjectSet.Query<
      OrderedPropertiesClass.$Filter,
      OrderedPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly OrderedPropertiesClass[]>> {
    return this.$objects<
      OrderedPropertiesClass,
      OrderedPropertiesClass.$Filter,
      OrderedPropertiesClass.$Identifier
    >(OrderedPropertiesClass, query);
  }

  async orderedPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        OrderedPropertiesClass.$Filter,
        OrderedPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      OrderedPropertiesClass.$Filter,
      OrderedPropertiesClass.$Identifier
    >(OrderedPropertiesClass, query);
  }

  async partialClass(
    identifier: PartialClass.$Identifier,
  ): Promise<Either<Error, PartialClass>> {
    return (await this.partialClasses({ identifiers: [identifier] })).map(
      (objects) => objects[0],
    );
  }

  async partialClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      PartialClass.$Filter,
      PartialClass.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      PartialClass.$Filter,
      PartialClass.$Identifier
    >(PartialClass, query);
  }

  async partialClasses(
    query?: $SparqlObjectSet.Query<
      PartialClass.$Filter,
      PartialClass.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialClass[]>> {
    return this.$objects<
      PartialClass,
      PartialClass.$Filter,
      PartialClass.$Identifier
    >(PartialClass, query);
  }

  async partialClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<PartialClass.$Filter, PartialClass.$Identifier>,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<PartialClass.$Filter, PartialClass.$Identifier>(
      PartialClass,
      query,
    );
  }

  async partialClassUnionMember1(
    identifier: PartialClassUnionMember1.$Identifier,
  ): Promise<Either<Error, PartialClassUnionMember1>> {
    return (
      await this.partialClassUnionMember1s({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async partialClassUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<
      PartialClassUnionMember1.$Filter,
      PartialClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialClassUnionMember1.$Identifier[]>> {
    return this.$objectIdentifiers<
      PartialClassUnionMember1.$Filter,
      PartialClassUnionMember1.$Identifier
    >(PartialClassUnionMember1, query);
  }

  async partialClassUnionMember1s(
    query?: $SparqlObjectSet.Query<
      PartialClassUnionMember1.$Filter,
      PartialClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialClassUnionMember1[]>> {
    return this.$objects<
      PartialClassUnionMember1,
      PartialClassUnionMember1.$Filter,
      PartialClassUnionMember1.$Identifier
    >(PartialClassUnionMember1, query);
  }

  async partialClassUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        PartialClassUnionMember1.$Filter,
        PartialClassUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      PartialClassUnionMember1.$Filter,
      PartialClassUnionMember1.$Identifier
    >(PartialClassUnionMember1, query);
  }

  async partialClassUnionMember2(
    identifier: PartialClassUnionMember2.$Identifier,
  ): Promise<Either<Error, PartialClassUnionMember2>> {
    return (
      await this.partialClassUnionMember2s({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async partialClassUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<
      PartialClassUnionMember2.$Filter,
      PartialClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialClassUnionMember2.$Identifier[]>> {
    return this.$objectIdentifiers<
      PartialClassUnionMember2.$Filter,
      PartialClassUnionMember2.$Identifier
    >(PartialClassUnionMember2, query);
  }

  async partialClassUnionMember2s(
    query?: $SparqlObjectSet.Query<
      PartialClassUnionMember2.$Filter,
      PartialClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialClassUnionMember2[]>> {
    return this.$objects<
      PartialClassUnionMember2,
      PartialClassUnionMember2.$Filter,
      PartialClassUnionMember2.$Identifier
    >(PartialClassUnionMember2, query);
  }

  async partialClassUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        PartialClassUnionMember2.$Filter,
        PartialClassUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      PartialClassUnionMember2.$Filter,
      PartialClassUnionMember2.$Identifier
    >(PartialClassUnionMember2, query);
  }

  async partialInterface(
    identifier: PartialInterface.$Identifier,
  ): Promise<Either<Error, PartialInterface>> {
    return (await this.partialInterfaces({ identifiers: [identifier] })).map(
      (objects) => objects[0],
    );
  }

  async partialInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<
      PartialInterface.$Filter,
      PartialInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialInterface.$Identifier[]>> {
    return this.$objectIdentifiers<
      PartialInterface.$Filter,
      PartialInterface.$Identifier
    >(PartialInterface, query);
  }

  async partialInterfaces(
    query?: $SparqlObjectSet.Query<
      PartialInterface.$Filter,
      PartialInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialInterface[]>> {
    return this.$objects<
      PartialInterface,
      PartialInterface.$Filter,
      PartialInterface.$Identifier
    >(PartialInterface, query);
  }

  async partialInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        PartialInterface.$Filter,
        PartialInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      PartialInterface.$Filter,
      PartialInterface.$Identifier
    >(PartialInterface, query);
  }

  async partialInterfaceUnionMember1(
    identifier: PartialInterfaceUnionMember1.$Identifier,
  ): Promise<Either<Error, PartialInterfaceUnionMember1>> {
    return (
      await this.partialInterfaceUnionMember1s({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async partialInterfaceUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<
      PartialInterfaceUnionMember1.$Filter,
      PartialInterfaceUnionMember1.$Identifier
    >,
  ): Promise<
    Either<Error, readonly PartialInterfaceUnionMember1.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      PartialInterfaceUnionMember1.$Filter,
      PartialInterfaceUnionMember1.$Identifier
    >(PartialInterfaceUnionMember1, query);
  }

  async partialInterfaceUnionMember1s(
    query?: $SparqlObjectSet.Query<
      PartialInterfaceUnionMember1.$Filter,
      PartialInterfaceUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialInterfaceUnionMember1[]>> {
    return this.$objects<
      PartialInterfaceUnionMember1,
      PartialInterfaceUnionMember1.$Filter,
      PartialInterfaceUnionMember1.$Identifier
    >(PartialInterfaceUnionMember1, query);
  }

  async partialInterfaceUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        PartialInterfaceUnionMember1.$Filter,
        PartialInterfaceUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      PartialInterfaceUnionMember1.$Filter,
      PartialInterfaceUnionMember1.$Identifier
    >(PartialInterfaceUnionMember1, query);
  }

  async partialInterfaceUnionMember2(
    identifier: PartialInterfaceUnionMember2.$Identifier,
  ): Promise<Either<Error, PartialInterfaceUnionMember2>> {
    return (
      await this.partialInterfaceUnionMember2s({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async partialInterfaceUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<
      PartialInterfaceUnionMember2.$Filter,
      PartialInterfaceUnionMember2.$Identifier
    >,
  ): Promise<
    Either<Error, readonly PartialInterfaceUnionMember2.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      PartialInterfaceUnionMember2.$Filter,
      PartialInterfaceUnionMember2.$Identifier
    >(PartialInterfaceUnionMember2, query);
  }

  async partialInterfaceUnionMember2s(
    query?: $SparqlObjectSet.Query<
      PartialInterfaceUnionMember2.$Filter,
      PartialInterfaceUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialInterfaceUnionMember2[]>> {
    return this.$objects<
      PartialInterfaceUnionMember2,
      PartialInterfaceUnionMember2.$Filter,
      PartialInterfaceUnionMember2.$Identifier
    >(PartialInterfaceUnionMember2, query);
  }

  async partialInterfaceUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        PartialInterfaceUnionMember2.$Filter,
        PartialInterfaceUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      PartialInterfaceUnionMember2.$Filter,
      PartialInterfaceUnionMember2.$Identifier
    >(PartialInterfaceUnionMember2, query);
  }

  async propertyCardinalitiesClass(
    identifier: PropertyCardinalitiesClass.$Identifier,
  ): Promise<Either<Error, PropertyCardinalitiesClass>> {
    return (
      await this.propertyCardinalitiesClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async propertyCardinalitiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      PropertyCardinalitiesClass.$Filter,
      PropertyCardinalitiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly PropertyCardinalitiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      PropertyCardinalitiesClass.$Filter,
      PropertyCardinalitiesClass.$Identifier
    >(PropertyCardinalitiesClass, query);
  }

  async propertyCardinalitiesClasses(
    query?: $SparqlObjectSet.Query<
      PropertyCardinalitiesClass.$Filter,
      PropertyCardinalitiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly PropertyCardinalitiesClass[]>> {
    return this.$objects<
      PropertyCardinalitiesClass,
      PropertyCardinalitiesClass.$Filter,
      PropertyCardinalitiesClass.$Identifier
    >(PropertyCardinalitiesClass, query);
  }

  async propertyCardinalitiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        PropertyCardinalitiesClass.$Filter,
        PropertyCardinalitiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      PropertyCardinalitiesClass.$Filter,
      PropertyCardinalitiesClass.$Identifier
    >(PropertyCardinalitiesClass, query);
  }

  async propertyVisibilitiesClass(
    identifier: PropertyVisibilitiesClass.$Identifier,
  ): Promise<Either<Error, PropertyVisibilitiesClass>> {
    return (
      await this.propertyVisibilitiesClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async propertyVisibilitiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      PropertyVisibilitiesClass.$Filter,
      PropertyVisibilitiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly PropertyVisibilitiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      PropertyVisibilitiesClass.$Filter,
      PropertyVisibilitiesClass.$Identifier
    >(PropertyVisibilitiesClass, query);
  }

  async propertyVisibilitiesClasses(
    query?: $SparqlObjectSet.Query<
      PropertyVisibilitiesClass.$Filter,
      PropertyVisibilitiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly PropertyVisibilitiesClass[]>> {
    return this.$objects<
      PropertyVisibilitiesClass,
      PropertyVisibilitiesClass.$Filter,
      PropertyVisibilitiesClass.$Identifier
    >(PropertyVisibilitiesClass, query);
  }

  async propertyVisibilitiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        PropertyVisibilitiesClass.$Filter,
        PropertyVisibilitiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      PropertyVisibilitiesClass.$Filter,
      PropertyVisibilitiesClass.$Identifier
    >(PropertyVisibilitiesClass, query);
  }

  async recursiveClassUnionMember1(
    identifier: RecursiveClassUnionMember1.$Identifier,
  ): Promise<Either<Error, RecursiveClassUnionMember1>> {
    return (
      await this.recursiveClassUnionMember1s({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async recursiveClassUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<
      RecursiveClassUnionMember1.$Filter,
      RecursiveClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly RecursiveClassUnionMember1.$Identifier[]>> {
    return this.$objectIdentifiers<
      RecursiveClassUnionMember1.$Filter,
      RecursiveClassUnionMember1.$Identifier
    >(RecursiveClassUnionMember1, query);
  }

  async recursiveClassUnionMember1s(
    query?: $SparqlObjectSet.Query<
      RecursiveClassUnionMember1.$Filter,
      RecursiveClassUnionMember1.$Identifier
    >,
  ): Promise<Either<Error, readonly RecursiveClassUnionMember1[]>> {
    return this.$objects<
      RecursiveClassUnionMember1,
      RecursiveClassUnionMember1.$Filter,
      RecursiveClassUnionMember1.$Identifier
    >(RecursiveClassUnionMember1, query);
  }

  async recursiveClassUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        RecursiveClassUnionMember1.$Filter,
        RecursiveClassUnionMember1.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      RecursiveClassUnionMember1.$Filter,
      RecursiveClassUnionMember1.$Identifier
    >(RecursiveClassUnionMember1, query);
  }

  async recursiveClassUnionMember2(
    identifier: RecursiveClassUnionMember2.$Identifier,
  ): Promise<Either<Error, RecursiveClassUnionMember2>> {
    return (
      await this.recursiveClassUnionMember2s({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async recursiveClassUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<
      RecursiveClassUnionMember2.$Filter,
      RecursiveClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly RecursiveClassUnionMember2.$Identifier[]>> {
    return this.$objectIdentifiers<
      RecursiveClassUnionMember2.$Filter,
      RecursiveClassUnionMember2.$Identifier
    >(RecursiveClassUnionMember2, query);
  }

  async recursiveClassUnionMember2s(
    query?: $SparqlObjectSet.Query<
      RecursiveClassUnionMember2.$Filter,
      RecursiveClassUnionMember2.$Identifier
    >,
  ): Promise<Either<Error, readonly RecursiveClassUnionMember2[]>> {
    return this.$objects<
      RecursiveClassUnionMember2,
      RecursiveClassUnionMember2.$Filter,
      RecursiveClassUnionMember2.$Identifier
    >(RecursiveClassUnionMember2, query);
  }

  async recursiveClassUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        RecursiveClassUnionMember2.$Filter,
        RecursiveClassUnionMember2.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      RecursiveClassUnionMember2.$Filter,
      RecursiveClassUnionMember2.$Identifier
    >(RecursiveClassUnionMember2, query);
  }

  async sha256IriIdentifierClass(
    identifier: Sha256IriIdentifierClass.$Identifier,
  ): Promise<Either<Error, Sha256IriIdentifierClass>> {
    return (
      await this.sha256IriIdentifierClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async sha256IriIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      Sha256IriIdentifierClass.$Filter,
      Sha256IriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly Sha256IriIdentifierClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      Sha256IriIdentifierClass.$Filter,
      Sha256IriIdentifierClass.$Identifier
    >(Sha256IriIdentifierClass, query);
  }

  async sha256IriIdentifierClasses(
    query?: $SparqlObjectSet.Query<
      Sha256IriIdentifierClass.$Filter,
      Sha256IriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly Sha256IriIdentifierClass[]>> {
    return this.$objects<
      Sha256IriIdentifierClass,
      Sha256IriIdentifierClass.$Filter,
      Sha256IriIdentifierClass.$Identifier
    >(Sha256IriIdentifierClass, query);
  }

  async sha256IriIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        Sha256IriIdentifierClass.$Filter,
        Sha256IriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      Sha256IriIdentifierClass.$Filter,
      Sha256IriIdentifierClass.$Identifier
    >(Sha256IriIdentifierClass, query);
  }

  async termPropertiesClass(
    identifier: TermPropertiesClass.$Identifier,
  ): Promise<Either<Error, TermPropertiesClass>> {
    return (
      await this.termPropertiesClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async termPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      TermPropertiesClass.$Filter,
      TermPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly TermPropertiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      TermPropertiesClass.$Filter,
      TermPropertiesClass.$Identifier
    >(TermPropertiesClass, query);
  }

  async termPropertiesClasses(
    query?: $SparqlObjectSet.Query<
      TermPropertiesClass.$Filter,
      TermPropertiesClass.$Identifier
    >,
  ): Promise<Either<Error, readonly TermPropertiesClass[]>> {
    return this.$objects<
      TermPropertiesClass,
      TermPropertiesClass.$Filter,
      TermPropertiesClass.$Identifier
    >(TermPropertiesClass, query);
  }

  async termPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        TermPropertiesClass.$Filter,
        TermPropertiesClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      TermPropertiesClass.$Filter,
      TermPropertiesClass.$Identifier
    >(TermPropertiesClass, query);
  }

  async unionDiscriminantsClass(
    identifier: UnionDiscriminantsClass.$Identifier,
  ): Promise<Either<Error, UnionDiscriminantsClass>> {
    return (
      await this.unionDiscriminantsClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async unionDiscriminantsClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      UnionDiscriminantsClass.$Filter,
      UnionDiscriminantsClass.$Identifier
    >,
  ): Promise<Either<Error, readonly UnionDiscriminantsClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      UnionDiscriminantsClass.$Filter,
      UnionDiscriminantsClass.$Identifier
    >(UnionDiscriminantsClass, query);
  }

  async unionDiscriminantsClasses(
    query?: $SparqlObjectSet.Query<
      UnionDiscriminantsClass.$Filter,
      UnionDiscriminantsClass.$Identifier
    >,
  ): Promise<Either<Error, readonly UnionDiscriminantsClass[]>> {
    return this.$objects<
      UnionDiscriminantsClass,
      UnionDiscriminantsClass.$Filter,
      UnionDiscriminantsClass.$Identifier
    >(UnionDiscriminantsClass, query);
  }

  async unionDiscriminantsClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        UnionDiscriminantsClass.$Filter,
        UnionDiscriminantsClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      UnionDiscriminantsClass.$Filter,
      UnionDiscriminantsClass.$Identifier
    >(UnionDiscriminantsClass, query);
  }

  async uuidV4IriIdentifierClass(
    identifier: UuidV4IriIdentifierClass.$Identifier,
  ): Promise<Either<Error, UuidV4IriIdentifierClass>> {
    return (
      await this.uuidV4IriIdentifierClasses({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async uuidV4IriIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<
      UuidV4IriIdentifierClass.$Filter,
      UuidV4IriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly UuidV4IriIdentifierClass.$Identifier[]>> {
    return this.$objectIdentifiers<
      UuidV4IriIdentifierClass.$Filter,
      UuidV4IriIdentifierClass.$Identifier
    >(UuidV4IriIdentifierClass, query);
  }

  async uuidV4IriIdentifierClasses(
    query?: $SparqlObjectSet.Query<
      UuidV4IriIdentifierClass.$Filter,
      UuidV4IriIdentifierClass.$Identifier
    >,
  ): Promise<Either<Error, readonly UuidV4IriIdentifierClass[]>> {
    return this.$objects<
      UuidV4IriIdentifierClass,
      UuidV4IriIdentifierClass.$Filter,
      UuidV4IriIdentifierClass.$Identifier
    >(UuidV4IriIdentifierClass, query);
  }

  async uuidV4IriIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        UuidV4IriIdentifierClass.$Filter,
        UuidV4IriIdentifierClass.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      UuidV4IriIdentifierClass.$Filter,
      UuidV4IriIdentifierClass.$Identifier
    >(UuidV4IriIdentifierClass, query);
  }

  async uuidV4IriIdentifierInterface(
    identifier: UuidV4IriIdentifierInterface.$Identifier,
  ): Promise<Either<Error, UuidV4IriIdentifierInterface>> {
    return (
      await this.uuidV4IriIdentifierInterfaces({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async uuidV4IriIdentifierInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<
      UuidV4IriIdentifierInterface.$Filter,
      UuidV4IriIdentifierInterface.$Identifier
    >,
  ): Promise<
    Either<Error, readonly UuidV4IriIdentifierInterface.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      UuidV4IriIdentifierInterface.$Filter,
      UuidV4IriIdentifierInterface.$Identifier
    >(UuidV4IriIdentifierInterface, query);
  }

  async uuidV4IriIdentifierInterfaces(
    query?: $SparqlObjectSet.Query<
      UuidV4IriIdentifierInterface.$Filter,
      UuidV4IriIdentifierInterface.$Identifier
    >,
  ): Promise<Either<Error, readonly UuidV4IriIdentifierInterface[]>> {
    return this.$objects<
      UuidV4IriIdentifierInterface,
      UuidV4IriIdentifierInterface.$Filter,
      UuidV4IriIdentifierInterface.$Identifier
    >(UuidV4IriIdentifierInterface, query);
  }

  async uuidV4IriIdentifierInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        UuidV4IriIdentifierInterface.$Filter,
        UuidV4IriIdentifierInterface.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      UuidV4IriIdentifierInterface.$Filter,
      UuidV4IriIdentifierInterface.$Identifier
    >(UuidV4IriIdentifierInterface, query);
  }

  async classUnion(
    identifier: ClassUnion.$Identifier,
  ): Promise<Either<Error, ClassUnion>> {
    return (await this.classUnions({ identifiers: [identifier] })).map(
      (objects) => objects[0],
    );
  }

  async classUnionIdentifiers(
    query?: $SparqlObjectSet.Query<ClassUnion.$Filter, ClassUnion.$Identifier>,
  ): Promise<Either<Error, readonly ClassUnion.$Identifier[]>> {
    return this.$objectIdentifiers<ClassUnion.$Filter, ClassUnion.$Identifier>(
      ClassUnion,
      query,
    );
  }

  async classUnions(
    query?: $SparqlObjectSet.Query<ClassUnion.$Filter, ClassUnion.$Identifier>,
  ): Promise<Either<Error, readonly ClassUnion[]>> {
    return this.$objects<
      ClassUnion,
      ClassUnion.$Filter,
      ClassUnion.$Identifier
    >(ClassUnion, query);
  }

  async classUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<ClassUnion.$Filter, ClassUnion.$Identifier>,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<ClassUnion.$Filter, ClassUnion.$Identifier>(
      ClassUnion,
      query,
    );
  }

  async flattenClassUnion(
    identifier: FlattenClassUnion.$Identifier,
  ): Promise<Either<Error, FlattenClassUnion>> {
    return (await this.flattenClassUnions({ identifiers: [identifier] })).map(
      (objects) => objects[0],
    );
  }

  async flattenClassUnionIdentifiers(
    query?: $SparqlObjectSet.Query<
      FlattenClassUnion.$Filter,
      FlattenClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly FlattenClassUnion.$Identifier[]>> {
    return this.$objectIdentifiers<
      FlattenClassUnion.$Filter,
      FlattenClassUnion.$Identifier
    >(FlattenClassUnion, query);
  }

  async flattenClassUnions(
    query?: $SparqlObjectSet.Query<
      FlattenClassUnion.$Filter,
      FlattenClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly FlattenClassUnion[]>> {
    return this.$objects<
      FlattenClassUnion,
      FlattenClassUnion.$Filter,
      FlattenClassUnion.$Identifier
    >(FlattenClassUnion, query);
  }

  async flattenClassUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        FlattenClassUnion.$Filter,
        FlattenClassUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      FlattenClassUnion.$Filter,
      FlattenClassUnion.$Identifier
    >(FlattenClassUnion, query);
  }

  async interfaceUnion(
    identifier: InterfaceUnion.$Identifier,
  ): Promise<Either<Error, InterfaceUnion>> {
    return (await this.interfaceUnions({ identifiers: [identifier] })).map(
      (objects) => objects[0],
    );
  }

  async interfaceUnionIdentifiers(
    query?: $SparqlObjectSet.Query<
      InterfaceUnion.$Filter,
      InterfaceUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly InterfaceUnion.$Identifier[]>> {
    return this.$objectIdentifiers<
      InterfaceUnion.$Filter,
      InterfaceUnion.$Identifier
    >(InterfaceUnion, query);
  }

  async interfaceUnions(
    query?: $SparqlObjectSet.Query<
      InterfaceUnion.$Filter,
      InterfaceUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly InterfaceUnion[]>> {
    return this.$objects<
      InterfaceUnion,
      InterfaceUnion.$Filter,
      InterfaceUnion.$Identifier
    >(InterfaceUnion, query);
  }

  async interfaceUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        InterfaceUnion.$Filter,
        InterfaceUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      InterfaceUnion.$Filter,
      InterfaceUnion.$Identifier
    >(InterfaceUnion, query);
  }

  async lazilyResolvedClassUnion(
    identifier: LazilyResolvedClassUnion.$Identifier,
  ): Promise<Either<Error, LazilyResolvedClassUnion>> {
    return (
      await this.lazilyResolvedClassUnions({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionIdentifiers(
    query?: $SparqlObjectSet.Query<
      LazilyResolvedClassUnion.$Filter,
      LazilyResolvedClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedClassUnion.$Identifier[]>> {
    return this.$objectIdentifiers<
      LazilyResolvedClassUnion.$Filter,
      LazilyResolvedClassUnion.$Identifier
    >(LazilyResolvedClassUnion, query);
  }

  async lazilyResolvedClassUnions(
    query?: $SparqlObjectSet.Query<
      LazilyResolvedClassUnion.$Filter,
      LazilyResolvedClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedClassUnion[]>> {
    return this.$objects<
      LazilyResolvedClassUnion,
      LazilyResolvedClassUnion.$Filter,
      LazilyResolvedClassUnion.$Identifier
    >(LazilyResolvedClassUnion, query);
  }

  async lazilyResolvedClassUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        LazilyResolvedClassUnion.$Filter,
        LazilyResolvedClassUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      LazilyResolvedClassUnion.$Filter,
      LazilyResolvedClassUnion.$Identifier
    >(LazilyResolvedClassUnion, query);
  }

  async lazilyResolvedInterfaceUnion(
    identifier: LazilyResolvedInterfaceUnion.$Identifier,
  ): Promise<Either<Error, LazilyResolvedInterfaceUnion>> {
    return (
      await this.lazilyResolvedInterfaceUnions({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionIdentifiers(
    query?: $SparqlObjectSet.Query<
      LazilyResolvedInterfaceUnion.$Filter,
      LazilyResolvedInterfaceUnion.$Identifier
    >,
  ): Promise<
    Either<Error, readonly LazilyResolvedInterfaceUnion.$Identifier[]>
  > {
    return this.$objectIdentifiers<
      LazilyResolvedInterfaceUnion.$Filter,
      LazilyResolvedInterfaceUnion.$Identifier
    >(LazilyResolvedInterfaceUnion, query);
  }

  async lazilyResolvedInterfaceUnions(
    query?: $SparqlObjectSet.Query<
      LazilyResolvedInterfaceUnion.$Filter,
      LazilyResolvedInterfaceUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly LazilyResolvedInterfaceUnion[]>> {
    return this.$objects<
      LazilyResolvedInterfaceUnion,
      LazilyResolvedInterfaceUnion.$Filter,
      LazilyResolvedInterfaceUnion.$Identifier
    >(LazilyResolvedInterfaceUnion, query);
  }

  async lazilyResolvedInterfaceUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        LazilyResolvedInterfaceUnion.$Filter,
        LazilyResolvedInterfaceUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      LazilyResolvedInterfaceUnion.$Filter,
      LazilyResolvedInterfaceUnion.$Identifier
    >(LazilyResolvedInterfaceUnion, query);
  }

  async noRdfTypeClassUnion(
    identifier: NoRdfTypeClassUnion.$Identifier,
  ): Promise<Either<Error, NoRdfTypeClassUnion>> {
    return (await this.noRdfTypeClassUnions({ identifiers: [identifier] })).map(
      (objects) => objects[0],
    );
  }

  async noRdfTypeClassUnionIdentifiers(
    query?: $SparqlObjectSet.Query<
      NoRdfTypeClassUnion.$Filter,
      NoRdfTypeClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly NoRdfTypeClassUnion.$Identifier[]>> {
    return this.$objectIdentifiers<
      NoRdfTypeClassUnion.$Filter,
      NoRdfTypeClassUnion.$Identifier
    >(NoRdfTypeClassUnion, query);
  }

  async noRdfTypeClassUnions(
    query?: $SparqlObjectSet.Query<
      NoRdfTypeClassUnion.$Filter,
      NoRdfTypeClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly NoRdfTypeClassUnion[]>> {
    return this.$objects<
      NoRdfTypeClassUnion,
      NoRdfTypeClassUnion.$Filter,
      NoRdfTypeClassUnion.$Identifier
    >(NoRdfTypeClassUnion, query);
  }

  async noRdfTypeClassUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        NoRdfTypeClassUnion.$Filter,
        NoRdfTypeClassUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      NoRdfTypeClassUnion.$Filter,
      NoRdfTypeClassUnion.$Identifier
    >(NoRdfTypeClassUnion, query);
  }

  async partialClassUnion(
    identifier: PartialClassUnion.$Identifier,
  ): Promise<Either<Error, PartialClassUnion>> {
    return (await this.partialClassUnions({ identifiers: [identifier] })).map(
      (objects) => objects[0],
    );
  }

  async partialClassUnionIdentifiers(
    query?: $SparqlObjectSet.Query<
      PartialClassUnion.$Filter,
      PartialClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialClassUnion.$Identifier[]>> {
    return this.$objectIdentifiers<
      PartialClassUnion.$Filter,
      PartialClassUnion.$Identifier
    >(PartialClassUnion, query);
  }

  async partialClassUnions(
    query?: $SparqlObjectSet.Query<
      PartialClassUnion.$Filter,
      PartialClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialClassUnion[]>> {
    return this.$objects<
      PartialClassUnion,
      PartialClassUnion.$Filter,
      PartialClassUnion.$Identifier
    >(PartialClassUnion, query);
  }

  async partialClassUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        PartialClassUnion.$Filter,
        PartialClassUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      PartialClassUnion.$Filter,
      PartialClassUnion.$Identifier
    >(PartialClassUnion, query);
  }

  async partialInterfaceUnion(
    identifier: PartialInterfaceUnion.$Identifier,
  ): Promise<Either<Error, PartialInterfaceUnion>> {
    return (
      await this.partialInterfaceUnions({ identifiers: [identifier] })
    ).map((objects) => objects[0]);
  }

  async partialInterfaceUnionIdentifiers(
    query?: $SparqlObjectSet.Query<
      PartialInterfaceUnion.$Filter,
      PartialInterfaceUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialInterfaceUnion.$Identifier[]>> {
    return this.$objectIdentifiers<
      PartialInterfaceUnion.$Filter,
      PartialInterfaceUnion.$Identifier
    >(PartialInterfaceUnion, query);
  }

  async partialInterfaceUnions(
    query?: $SparqlObjectSet.Query<
      PartialInterfaceUnion.$Filter,
      PartialInterfaceUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly PartialInterfaceUnion[]>> {
    return this.$objects<
      PartialInterfaceUnion,
      PartialInterfaceUnion.$Filter,
      PartialInterfaceUnion.$Identifier
    >(PartialInterfaceUnion, query);
  }

  async partialInterfaceUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        PartialInterfaceUnion.$Filter,
        PartialInterfaceUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      PartialInterfaceUnion.$Filter,
      PartialInterfaceUnion.$Identifier
    >(PartialInterfaceUnion, query);
  }

  async recursiveClassUnion(
    identifier: RecursiveClassUnion.$Identifier,
  ): Promise<Either<Error, RecursiveClassUnion>> {
    return (await this.recursiveClassUnions({ identifiers: [identifier] })).map(
      (objects) => objects[0],
    );
  }

  async recursiveClassUnionIdentifiers(
    query?: $SparqlObjectSet.Query<
      RecursiveClassUnion.$Filter,
      RecursiveClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly RecursiveClassUnion.$Identifier[]>> {
    return this.$objectIdentifiers<
      RecursiveClassUnion.$Filter,
      RecursiveClassUnion.$Identifier
    >(RecursiveClassUnion, query);
  }

  async recursiveClassUnions(
    query?: $SparqlObjectSet.Query<
      RecursiveClassUnion.$Filter,
      RecursiveClassUnion.$Identifier
    >,
  ): Promise<Either<Error, readonly RecursiveClassUnion[]>> {
    return this.$objects<
      RecursiveClassUnion,
      RecursiveClassUnion.$Filter,
      RecursiveClassUnion.$Identifier
    >(RecursiveClassUnion, query);
  }

  async recursiveClassUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<
        RecursiveClassUnion.$Filter,
        RecursiveClassUnion.$Identifier
      >,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<
      RecursiveClassUnion.$Filter,
      RecursiveClassUnion.$Identifier
    >(RecursiveClassUnion, query);
  }

  async object(
    identifier: $Object.$Identifier,
  ): Promise<Either<Error, $Object>> {
    return (await this.objects({ identifiers: [identifier] })).map(
      (objects) => objects[0],
    );
  }

  async objectIdentifiers(
    query?: $SparqlObjectSet.Query<$Object.$Filter, $Object.$Identifier>,
  ): Promise<Either<Error, readonly $Object.$Identifier[]>> {
    return this.$objectIdentifiers<$Object.$Filter, $Object.$Identifier>(
      $Object,
      query,
    );
  }

  async objects(
    query?: $SparqlObjectSet.Query<$Object.$Filter, $Object.$Identifier>,
  ): Promise<Either<Error, readonly $Object[]>> {
    return this.$objects<$Object, $Object.$Filter, $Object.$Identifier>(
      $Object,
      query,
    );
  }

  async objectsCount(
    query?: Pick<
      $SparqlObjectSet.Query<$Object.$Filter, $Object.$Identifier>,
      "filter"
    >,
  ): Promise<Either<Error, number>> {
    return this.$objectsCount<$Object.$Filter, $Object.$Identifier>(
      $Object,
      query,
    );
  }

  protected $mapBindingsToCount(
    bindings: readonly Record<string, BlankNode | Literal | NamedNode>[],
    variable: string,
  ): Either<Error, number> {
    if (bindings.length === 0) {
      return Left(new Error("empty result rows"));
    }
    if (bindings.length > 1) {
      return Left(new Error("more than one result row"));
    }
    const count = bindings[0][variable];
    if (typeof count === "undefined") {
      return Left(new Error("no 'count' variable in result row"));
    }
    if (count.termType !== "Literal") {
      return Left(new Error("'count' variable is not a Literal"));
    }
    const parsedCount = Number.parseInt(count.value, 10);
    if (Number.isNaN(parsedCount)) {
      return Left(new Error("'count' variable is NaN"));
    }
    return Either.of(parsedCount);
  }

  protected $mapBindingsToIdentifiers(
    bindings: readonly Record<string, BlankNode | Literal | NamedNode>[],
    variable: string,
  ): readonly NamedNode[] {
    const identifiers: NamedNode[] = [];
    for (const bindings_ of bindings) {
      const identifier = bindings_[variable];
      if (
        typeof identifier !== "undefined" &&
        identifier.termType === "NamedNode"
      ) {
        identifiers.push(identifier);
      }
    }
    return identifiers;
  }

  protected async $objectIdentifiers<
    ObjectFilterT,
    ObjectIdentifierT extends BlankNode | NamedNode,
  >(
    objectType: {
      $sparqlWherePatterns: (parameters?: {
        filter?: ObjectFilterT;
        subject?: sparqljs.Triple["subject"];
      }) => readonly sparqljs.Pattern[];
    },
    query?: $SparqlObjectSet.Query<ObjectFilterT, ObjectIdentifierT>,
  ): Promise<Either<Error, readonly ObjectIdentifierT[]>> {
    if (query?.identifiers) {
      return Either.of(query.identifiers);
    }

    const limit = query?.limit ?? Number.MAX_SAFE_INTEGER;
    if (limit <= 0) {
      return Either.of([]);
    }

    let offset = query?.offset ?? 0;
    if (offset < 0) {
      offset = 0;
    }

    const wherePatterns = this.$wherePatterns(objectType, query);
    if (wherePatterns.length === 0) {
      return Left(new Error("no SPARQL WHERE patterns for identifiers"));
    }

    const selectQueryString = this.$sparqlGenerator.stringify({
      distinct: true,
      limit: limit < Number.MAX_SAFE_INTEGER ? limit : undefined,
      offset,
      order: query?.order
        ? query.order(this.$objectVariable).concat()
        : [{ expression: this.$objectVariable }],
      prefixes: {},
      queryType: "SELECT",
      type: "query",
      variables: [this.$objectVariable],
      where: wherePatterns.concat(),
    });

    return EitherAsync(
      async () =>
        this.$mapBindingsToIdentifiers(
          await this.$sparqlClient.queryBindings(selectQueryString),
          this.$objectVariable.value,
        ) as readonly ObjectIdentifierT[],
    );
  }

  protected async $objects<
    ObjectT extends { readonly $identifier: ObjectIdentifierT },
    ObjectFilterT,
    ObjectIdentifierT extends BlankNode | NamedNode,
  >(
    objectType: {
      $fromRdf: (
        resource: Resource,
        options: { objectSet: $ObjectSet },
      ) => Either<Error, ObjectT>;
      $sparqlConstructQueryString: (
        parameters?: {
          filter?: ObjectFilterT;
          subject?: sparqljs.Triple["subject"];
        } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
          sparqljs.GeneratorOptions,
      ) => string;
      $sparqlWherePatterns: (parameters?: {
        filter?: ObjectFilterT;
        subject?: sparqljs.Triple["subject"];
      }) => readonly sparqljs.Pattern[];
    },
    query?: $SparqlObjectSet.Query<ObjectFilterT, ObjectIdentifierT>,
  ): Promise<Either<Error, readonly ObjectT[]>> {
    return EitherAsync(async ({ liftEither }) => {
      const identifiers = await liftEither(
        await this.$objectIdentifiers<ObjectFilterT, ObjectIdentifierT>(
          objectType,
          query,
        ),
      );
      if (identifiers.length === 0) {
        return [];
      }

      const constructQueryString = objectType.$sparqlConstructQueryString({
        subject: this.$objectVariable,
        where: [
          {
            type: "values" as const,
            values: identifiers.map((identifier) => {
              const valuePatternRow: sparqljs.ValuePatternRow = {};
              valuePatternRow["?object"] = identifier as NamedNode;
              return valuePatternRow;
            }),
          },
        ],
      });

      const quads = await this.$sparqlClient.queryQuads(constructQueryString);

      const dataset = $datasetFactory.dataset(quads.concat());
      const objects: ObjectT[] = [];
      for (const identifier of identifiers) {
        objects.push(
          await liftEither(
            objectType.$fromRdf(
              new Resource(dataset, identifier as NamedNode),
              { objectSet: this },
            ),
          ),
        );
      }
      return objects;
    });
  }

  protected async $objectsCount<
    ObjectFilterT,
    ObjectIdentifierT extends BlankNode | NamedNode,
  >(
    objectType: {
      $sparqlWherePatterns: (parameters?: {
        filter?: ObjectFilterT;
        subject?: sparqljs.Triple["subject"];
      }) => readonly sparqljs.Pattern[];
    },
    query?: $SparqlObjectSet.Query<ObjectFilterT, ObjectIdentifierT>,
  ): Promise<Either<Error, number>> {
    const wherePatterns = this.$wherePatterns(objectType, query);
    if (wherePatterns.length === 0) {
      return Left(new Error("no SPARQL WHERE patterns for count"));
    }

    const selectQueryString = this.$sparqlGenerator.stringify({
      prefixes: {},
      queryType: "SELECT",
      type: "query",
      variables: [
        {
          expression: {
            aggregation: "COUNT",
            distinct: true,
            expression: this.$objectVariable,
            type: "aggregate",
          },
          variable: this.$countVariable,
        },
      ],
      where: wherePatterns.concat(),
    });

    return EitherAsync(async ({ liftEither }) =>
      liftEither(
        this.$mapBindingsToCount(
          await this.$sparqlClient.queryBindings(selectQueryString),
          this.$countVariable.value,
        ),
      ),
    );
  }

  protected $wherePatterns<
    ObjectFilterT,
    ObjectIdentifierT extends BlankNode | NamedNode,
  >(
    objectType: {
      $sparqlWherePatterns: (parameters?: {
        filter?: ObjectFilterT;
        subject?: sparqljs.Triple["subject"];
      }) => readonly sparqljs.Pattern[];
    },
    query?: $SparqlObjectSet.Query<ObjectFilterT, ObjectIdentifierT>,
  ): readonly sparqljs.Pattern[] {
    // Patterns should be most to least specific.
    const patterns: sparqljs.Pattern[] = [];

    if (query?.where) {
      patterns.push(...query.where(this.$objectVariable));
    }

    patterns.push(
      ...objectType.$sparqlWherePatterns({
        filter: query?.filter,
        subject: this.$objectVariable,
      }),
    );

    return $normalizeSparqlWherePatterns(patterns);
  }
}

export namespace $SparqlObjectSet {
  export type Query<
    ObjectFilterT,
    ObjectIdentifierT extends BlankNode | NamedNode,
  > = $ObjectSet.Query<ObjectFilterT, ObjectIdentifierT> & {
    readonly order?: (objectVariable: Variable) => readonly sparqljs.Ordering[];
    readonly where?: (objectVariable: Variable) => readonly sparqljs.Pattern[];
  };
}
