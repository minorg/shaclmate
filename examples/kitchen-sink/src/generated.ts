import { StoreFactory as _DatasetFactory } from "n3";

const datasetFactory = new _DatasetFactory();

import type * as rdfjs from "@rdfjs/types";
import { sha256 } from "js-sha256";
import { DataFactory as dataFactory } from "n3";
import * as purify from "purify-ts";
import * as rdfjsResource from "rdfjs-resource";
import * as sparqljs from "sparqljs";
import * as uuid from "uuid";
import { z as zod } from "zod";
import { ExternClass } from "./ExternClass.js";

/**
 * Compare two arrays element-wise with the provided elementEquals function.
 */
function $arrayEquals<T>(
  leftArray: readonly T[],
  rightArray: readonly T[],
  elementEquals: (left: T, right: T) => boolean | $EqualsResult,
): $EqualsResult {
  if (leftArray.length !== rightArray.length) {
    return purify.Left({
      left: leftArray,
      right: rightArray,
      type: "ArrayLength",
    });
  }

  for (
    let leftElementIndex = 0;
    leftElementIndex < leftArray.length;
    leftElementIndex++
  ) {
    const leftElement = leftArray[leftElementIndex];

    const rightUnequals: $EqualsResult.Unequal[] = [];
    for (
      let rightElementIndex = 0;
      rightElementIndex < rightArray.length;
      rightElementIndex++
    ) {
      const rightElement = rightArray[rightElementIndex];

      const leftElementEqualsRightElement =
        $EqualsResult.fromBooleanEqualsResult(
          leftElement,
          rightElement,
          elementEquals(leftElement, rightElement),
        );
      if (leftElementEqualsRightElement.isRight()) {
        break; // left element === right element, break out of the right iteration
      }
      rightUnequals.push(
        leftElementEqualsRightElement.extract() as $EqualsResult.Unequal,
      );
    }

    if (rightUnequals.length === rightArray.length) {
      // All right elements were unequal to the left element
      return purify.Left({
        left: {
          array: leftArray,
          element: leftElement,
          elementIndex: leftElementIndex,
        },
        right: {
          array: rightArray,
          unequals: rightUnequals,
        },
        type: "ArrayElement",
      });
    }
    // Else there was a right element equal to the left element, continue to the next left element
  }

  return $EqualsResult.Equal;
}

function $arrayIntersection<T>(
  left: readonly T[],
  right: readonly T[],
): readonly T[] {
  if (left.length === 0) {
    return right;
  }
  if (right.length === 0) {
    return left;
  }

  const intersection = new Set<T>();
  if (left.length <= right.length) {
    const rightSet = new Set(right);
    for (const leftElement of left) {
      if (rightSet.has(leftElement)) {
        intersection.add(leftElement);
      }
    }
  } else {
    const leftSet = new Set(left);
    for (const rightElement of right) {
      if (leftSet.has(rightElement)) {
        intersection.add(rightElement);
      }
    }
  }
  return [...intersection];
}

interface $BlankNodeFilter {}

namespace $BlankNodeFilter {
  export function $sparqlWherePatterns(
    _filter: $BlankNodeFilter | undefined,
    _value: rdfjs.Variable,
  ) {
    return [];
  }
}

/**
 * Compare two objects with equals(other: T): boolean methods and return an $EqualsResult.
 */
function $booleanEquals<T extends { equals: (other: T) => boolean }>(
  left: T,
  right: T,
): $EqualsResult {
  return $EqualsResult.fromBooleanEqualsResult(left, right, left.equals(right));
}

interface $BooleanFilter {
  readonly value?: boolean;
}

namespace $BooleanFilter {
  export function $sparqlWherePatterns(
    filter: $BooleanFilter | undefined,
    value: rdfjs.Variable,
  ) {
    const patterns: sparqljs.Pattern[] = [];

    if (!filter) {
      return patterns;
    }

    if (typeof filter.value !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "=",
          args: [value, $toLiteral(filter.value)],
        },
      });
    }

    return patterns;
  }
}

type $CollectionFilter<ItemFilterT> = ItemFilterT & {
  readonly $maxCount?: number;
  readonly $minCount?: number;
};
/**
 * Compare two Dates and return an $EqualsResult.
 */
function $dateEquals(left: Date, right: Date): $EqualsResult {
  return $EqualsResult.fromBooleanEqualsResult(
    left,
    right,
    left.getTime() === right.getTime(),
  );
}

interface $DateFilter {
  readonly in?: readonly Date[];
  readonly maxExclusive?: Date;
  readonly maxInclusive?: Date;
  readonly minExclusive?: Date;
  readonly minInclusive?: Date;
}

namespace $DateFilter {
  export function $sparqlWherePatterns(
    filter: $DateFilter | undefined,
    value: rdfjs.Variable,
  ): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];

    if (!filter) {
      return patterns;
    }

    if (typeof filter.in !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "in",
          args: [value, filter.in.map((inValue) => $toLiteral(inValue))],
        },
      });
    }

    if (typeof filter.maxExclusive !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "<",
          args: [value, $toLiteral(filter.maxExclusive)],
        },
      });
    }

    if (typeof filter.maxInclusive !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "<=",
          args: [value, $toLiteral(filter.maxInclusive)],
        },
      });
    }

    if (typeof filter.minExclusive !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: ">",
          args: [value, $toLiteral(filter.minExclusive)],
        },
      });
    }

    if (typeof filter.minInclusive !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: ">=",
          args: [value, $toLiteral(filter.minInclusive)],
        },
      });
    }

    return patterns;
  }
}

function $deduplicateSparqlWherePatterns(
  patterns: readonly sparqljs.Pattern[],
): readonly sparqljs.Pattern[] {
  const deduplicatedPatterns: sparqljs.Pattern[] = [];
  const deduplicatePatternStrings = new Set<string>();
  for (const pattern of patterns) {
    const patternString = JSON.stringify(pattern);
    if (!deduplicatePatternStrings.has(patternString)) {
      deduplicatePatternStrings.add(patternString);
      deduplicatedPatterns.push(pattern);
    }
  }
  return deduplicatedPatterns;
}

export type $EqualsResult = purify.Either<$EqualsResult.Unequal, true>;

export namespace $EqualsResult {
  export const Equal: $EqualsResult = purify.Either.of<Unequal, true>(true);

  export function fromBooleanEqualsResult(
    left: any,
    right: any,
    equalsResult: boolean | $EqualsResult,
  ): $EqualsResult {
    if (typeof equalsResult !== "boolean") {
      return equalsResult;
    }

    if (equalsResult) {
      return Equal;
    }

    return purify.Left({ left, right, type: "BooleanEquals" });
  }

  export type Unequal =
    | {
        readonly left: {
          readonly array: readonly any[];
          readonly element: any;
          readonly elementIndex: number;
        };
        readonly right: {
          readonly array: readonly any[];
          readonly unequals: readonly Unequal[];
        };
        readonly type: "ArrayElement";
      }
    | {
        readonly left: readonly any[];
        readonly right: readonly any[];
        readonly type: "ArrayLength";
      }
    | {
        readonly left: any;
        readonly right: any;
        readonly type: "BooleanEquals";
      }
    | {
        readonly left: any;
        readonly right: any;
        readonly type: "LeftError";
      }
    | {
        readonly right: any;
        readonly type: "LeftNull";
      }
    | {
        readonly left: bigint | boolean | number | string;
        readonly right: bigint | boolean | number | string;
        readonly type: "Primitive";
      }
    | {
        readonly left: any;
        readonly right: any;
        readonly propertyName: string;
        readonly propertyValuesUnequal: Unequal;
        readonly type: "Property";
      }
    | {
        readonly left: any;
        readonly right: any;
        readonly type: "RightError";
      }
    | {
        readonly left: any;
        readonly type: "RightNull";
      };
}

function $filterArray<ItemT, ItemFilterT>(
  filterItem: (itemFilter: ItemFilterT, item: ItemT) => boolean,
) {
  return (
    filter: $CollectionFilter<ItemFilterT>,
    values: readonly ItemT[],
  ): boolean => {
    for (const value of values) {
      if (!filterItem(filter, value)) {
        return false;
      }
    }

    if (
      typeof filter.$maxCount !== "undefined" &&
      values.length > filter.$maxCount
    ) {
      return false;
    }

    if (
      typeof filter.$minCount !== "undefined" &&
      values.length < filter.$minCount
    ) {
      return false;
    }

    return true;
  };
}

function $filterBlankNode(_filter: $BlankNodeFilter, _value: rdfjs.BlankNode) {
  return true;
}

function $filterBoolean(filter: $BooleanFilter, value: boolean) {
  if (typeof filter.value !== "undefined" && value !== filter.value) {
    return false;
  }

  return true;
}

function $filterDate(filter: $DateFilter, value: Date) {
  if (
    typeof filter.in !== "undefined" &&
    !filter.in.some((inValue) => inValue.getTime() === value.getTime())
  ) {
    return false;
  }

  if (
    typeof filter.maxExclusive !== "undefined" &&
    value.getTime() >= filter.maxExclusive.getTime()
  ) {
    return false;
  }

  if (
    typeof filter.maxInclusive !== "undefined" &&
    value.getTime() > filter.maxInclusive.getTime()
  ) {
    return false;
  }

  if (
    typeof filter.minExclusive !== "undefined" &&
    value.getTime() <= filter.minExclusive.getTime()
  ) {
    return false;
  }

  if (
    typeof filter.minInclusive !== "undefined" &&
    value.getTime() < filter.minInclusive.getTime()
  ) {
    return false;
  }

  return true;
}

function $filterIdentifier(
  filter: $IdentifierFilter,
  value: rdfjs.BlankNode | rdfjs.NamedNode,
) {
  if (
    typeof filter.in !== "undefined" &&
    !filter.in.some((inValue) => inValue === value.value)
  ) {
    return false;
  }

  if (typeof filter.type !== "undefined" && value.termType !== filter.type) {
    return false;
  }

  return true;
}

function $filterLiteral(filter: $LiteralFilter, value: rdfjs.Literal): boolean {
  return $filterTerm(
    {
      ...filter,
      in: filter.in
        ? filter.in.map((inLiteral) => ({
            ...inLiteral,
            type: "Literal" as const,
          }))
        : undefined,
    },
    value,
  );
}

function $filterMaybe<ItemT, ItemFilterT>(
  filterItem: (itemFilter: ItemFilterT, item: ItemT) => boolean,
) {
  return (
    filter: $MaybeFilter<ItemFilterT>,
    value: purify.Maybe<ItemT>,
  ): boolean => {
    if (filter !== null) {
      if (value.isNothing()) {
        return false;
      }

      if (!filterItem(filter, value.extract()!)) {
        return false;
      }
    } else {
      if (value.isJust()) {
        return false;
      }
    }

    return true;
  };
}

function $filterNamedNode(filter: $NamedNodeFilter, value: rdfjs.NamedNode) {
  if (
    typeof filter.in !== "undefined" &&
    !filter.in.some((inValue) => inValue === value.value)
  ) {
    return false;
  }

  return true;
}

function $filterNumber(filter: $NumberFilter, value: number) {
  if (
    typeof filter.in !== "undefined" &&
    !filter.in.some((inValue) => inValue === value)
  ) {
    return false;
  }

  if (
    typeof filter.maxExclusive !== "undefined" &&
    value >= filter.maxExclusive
  ) {
    return false;
  }

  if (
    typeof filter.maxInclusive !== "undefined" &&
    value > filter.maxInclusive
  ) {
    return false;
  }

  if (
    typeof filter.minExclusive !== "undefined" &&
    value <= filter.minExclusive
  ) {
    return false;
  }

  if (
    typeof filter.minInclusive !== "undefined" &&
    value < filter.minInclusive
  ) {
    return false;
  }

  return true;
}

function $filterString(filter: $StringFilter, value: string) {
  if (
    typeof filter.in !== "undefined" &&
    !filter.in.some((inValue) => inValue === value)
  ) {
    return false;
  }

  if (
    typeof filter.maxLength !== "undefined" &&
    value.length > filter.maxLength
  ) {
    return false;
  }

  if (
    typeof filter.minLength !== "undefined" &&
    value.length < filter.minLength
  ) {
    return false;
  }

  return true;
}

function $filterTerm(
  filter: $TermFilter,
  value: rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode,
): boolean {
  if (
    typeof filter.datatypeIn !== "undefined" &&
    (value.termType !== "Literal" ||
      !filter.datatypeIn.some(
        (inDatatype) => inDatatype === value.datatype.value,
      ))
  ) {
    return false;
  }

  if (
    typeof filter.in !== "undefined" &&
    !filter.in.some((inTerm) => {
      if (
        typeof inTerm.datatype !== "undefined" &&
        (value.termType !== "Literal" ||
          value.datatype.value !== inTerm.datatype)
      ) {
        return false;
      }

      if (
        typeof inTerm.language !== "undefined" &&
        (value.termType !== "Literal" || value.language !== inTerm.language)
      ) {
        return false;
      }

      if (value.termType !== inTerm.type) {
        return false;
      }

      if (value.value !== inTerm.value) {
        return false;
      }

      return true;
    })
  ) {
    return false;
  }

  if (
    typeof filter.languageIn !== "undefined" &&
    (value.termType !== "Literal" ||
      !filter.languageIn.some((inLanguage) => inLanguage === value.language))
  ) {
    return false;
  }

  if (
    typeof filter.typeIn !== "undefined" &&
    !filter.typeIn.some((inType) => inType === value.termType)
  ) {
    return false;
  }

  return true;
}

function $fromRdfPreferredLanguages({
  focusResource,
  predicate,
  preferredLanguages,
  values,
}: {
  focusResource: rdfjsResource.Resource;
  predicate: rdfjs.NamedNode;
  preferredLanguages?: readonly string[];
  values: rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>;
}): purify.Either<
  Error,
  rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
> {
  if (!preferredLanguages || preferredLanguages.length === 0) {
    return purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(values);
  }

  const literalValuesEither = values.chainMap((value) => value.toLiteral());
  if (literalValuesEither.isLeft()) {
    return literalValuesEither;
  }
  const literalValues = literalValuesEither.unsafeCoerce();

  // Return all literals for the first preferredLanguage, then all literals for the second preferredLanguage, etc.
  // Within a preferredLanguage the literals may be in any order.
  let filteredLiteralValues:
    | rdfjsResource.Resource.Values<rdfjs.Literal>
    | undefined;
  for (const preferredLanguage of preferredLanguages) {
    if (!filteredLiteralValues) {
      filteredLiteralValues = literalValues.filter(
        (value) => value.language === preferredLanguage,
      );
    } else {
      filteredLiteralValues = filteredLiteralValues.concat(
        ...literalValues
          .filter((value) => value.language === preferredLanguage)
          .toArray(),
      );
    }
  }

  return purify.Either.of<
    Error,
    rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
  >(
    filteredLiteralValues!.map(
      (literalValue) =>
        new rdfjsResource.Resource.TermValue({
          focusResource,
          predicate,
          term: literalValue,
        }),
    ),
  );
}

interface $IdentifierFilter {
  readonly in?: readonly string[];
  readonly type?: "BlankNode" | "NamedNode";
}

namespace $IdentifierFilter {
  export function $sparqlWherePatterns(
    filter: $IdentifierFilter | undefined,
    value: rdfjs.Variable,
  ) {
    const patterns: sparqljs.Pattern[] = [];

    if (!filter) {
      return patterns;
    }

    if (typeof filter.in !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "in",
          args: [
            value,
            filter.in.map((inValue) => dataFactory.namedNode(inValue)),
          ],
        },
      });
    }

    if (typeof filter.type !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: filter.type === "BlankNode" ? "isBlank" : "isIRI",
          args: [value],
        },
      });
    }

    return patterns;
  }
}

/**
 * Insert a seed SPARQL where pattern if necessary.
 *
 * A SPARQL WHERE block that solely consists of OPTIONAL blocks won't match anything. OPTIONAL is a left join.
 * In that situation the solution is to insert a VALUES () { () } seed as the first pattern in order to match the entire store.
 */
function $insertSeedSparqlWherePattern(
  patterns: readonly sparqljs.Pattern[],
): readonly sparqljs.Pattern[] {
  if (patterns.every((pattern) => pattern.type === "optional")) {
    return [{ values: [{}], type: "values" }, ...patterns];
  }
  return patterns;
}

function $isReadonlyBooleanArray(x: unknown): x is readonly boolean[] {
  return Array.isArray(x) && x.every((z) => typeof z === "boolean");
}

function $isReadonlyNumberArray(x: unknown): x is readonly number[] {
  return Array.isArray(x) && x.every((z) => typeof z === "number");
}

function $isReadonlyObjectArray(x: unknown): x is readonly object[] {
  return Array.isArray(x) && x.every((z) => typeof z === "object");
}

function $isReadonlyStringArray(x: unknown): x is readonly string[] {
  return Array.isArray(x) && x.every((z) => typeof z === "string");
}

/**
 * Type of lazy properties that return a single required object. This is a class instead of an interface so it can be instanceof'd elsewhere.
 */
export class $LazyObject<
  ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  PartialObjectT extends { $identifier: ObjectIdentifierT },
  ResolvedObjectT extends { $identifier: ObjectIdentifierT },
> {
  readonly partial: PartialObjectT;
  private readonly resolver: (
    identifier: ObjectIdentifierT,
  ) => Promise<purify.Either<Error, ResolvedObjectT>>;

  constructor({
    partial,
    resolver,
  }: {
    partial: PartialObjectT;
    resolver: (
      identifier: ObjectIdentifierT,
    ) => Promise<purify.Either<Error, ResolvedObjectT>>;
  }) {
    this.partial = partial;
    this.resolver = resolver;
  }

  resolve(): Promise<purify.Either<Error, ResolvedObjectT>> {
    return this.resolver(this.partial.$identifier);
  }
}

/**
 * Type of lazy properties that return a single optional object. This is a class instead of an interface so it can be instanceof'd elsewhere.
 */
export class $LazyObjectOption<
  ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  PartialObjectT extends { $identifier: ObjectIdentifierT },
  ResolvedObjectT extends { $identifier: ObjectIdentifierT },
> {
  readonly partial: purify.Maybe<PartialObjectT>;
  private readonly resolver: (
    identifier: ObjectIdentifierT,
  ) => Promise<purify.Either<Error, ResolvedObjectT>>;

  constructor({
    partial,
    resolver,
  }: {
    partial: purify.Maybe<PartialObjectT>;
    resolver: (
      identifier: ObjectIdentifierT,
    ) => Promise<purify.Either<Error, ResolvedObjectT>>;
  }) {
    this.partial = partial;
    this.resolver = resolver;
  }

  async resolve(): Promise<
    purify.Either<Error, purify.Maybe<ResolvedObjectT>>
  > {
    if (this.partial.isNothing()) {
      return purify.Either.of(purify.Maybe.empty());
    }
    return (await this.resolver(this.partial.unsafeCoerce().$identifier)).map(
      purify.Maybe.of,
    );
  }
}

/**
 * Type of lazy properties that return a set of objects. This is a class instead of an interface so it can be instanceof'd elsewhere.
 */
export class $LazyObjectSet<
  ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  PartialObjectT extends { $identifier: ObjectIdentifierT },
  ResolvedObjectT extends { $identifier: ObjectIdentifierT },
> {
  readonly partials: readonly PartialObjectT[];
  private readonly resolver: (
    identifiers: readonly ObjectIdentifierT[],
  ) => Promise<purify.Either<Error, readonly ResolvedObjectT[]>>;

  constructor({
    partials,
    resolver,
  }: {
    partials: readonly PartialObjectT[];
    resolver: (
      identifiers: readonly ObjectIdentifierT[],
    ) => Promise<purify.Either<Error, readonly ResolvedObjectT[]>>;
  }) {
    this.partials = partials;
    this.resolver = resolver;
  }

  get length(): number {
    return this.partials.length;
  }

  async resolve(options?: {
    limit?: number;
    offset?: number;
  }): Promise<purify.Either<Error, readonly ResolvedObjectT[]>> {
    if (this.partials.length === 0) {
      return purify.Either.of([]);
    }

    const limit = options?.limit ?? Number.MAX_SAFE_INTEGER;
    if (limit <= 0) {
      return purify.Either.of([]);
    }

    let offset = options?.offset ?? 0;
    if (offset < 0) {
      offset = 0;
    }

    return await this.resolver(
      this.partials
        .slice(offset, offset + limit)
        .map((partial) => partial.$identifier),
    );
  }
}

interface $LiteralFilter extends Omit<$TermFilter, "in" | "type"> {
  readonly in?: readonly {
    readonly datatype?: string;
    readonly language?: string;
    readonly value: string;
  }[];
}

namespace $LiteralFilter {
  export function $sparqlWherePatterns(
    filter: $LiteralFilter | undefined,
    value: rdfjs.Variable,
  ) {
    return $TermFilter.$sparqlWherePatterns(
      filter
        ? {
            ...filter,
            in: filter.in
              ? filter.in.map((inLiteral) => ({
                  ...inLiteral,
                  type: "Literal" as const,
                }))
              : undefined,
          }
        : undefined,
      value,
    );
  }
}

function $maybeEquals<T>(
  leftMaybe: purify.Maybe<T>,
  rightMaybe: purify.Maybe<T>,
  valueEquals: (left: T, right: T) => boolean | $EqualsResult,
): $EqualsResult {
  if (leftMaybe.isJust()) {
    if (rightMaybe.isJust()) {
      return $EqualsResult.fromBooleanEqualsResult(
        leftMaybe,
        rightMaybe,
        valueEquals(leftMaybe.unsafeCoerce(), rightMaybe.unsafeCoerce()),
      );
    }
    return purify.Left({
      left: leftMaybe.unsafeCoerce(),
      type: "RightNull",
    });
  }

  if (rightMaybe.isJust()) {
    return purify.Left({
      right: rightMaybe.unsafeCoerce(),
      type: "LeftNull",
    });
  }

  return $EqualsResult.Equal;
}

type $MaybeFilter<ItemFilterT> = ItemFilterT | null;
namespace $MaybeFilter {
  export function $sparqlWherePatterns<ItemFilterT>(
    filter: $MaybeFilter<ItemFilterT> | undefined,
    itemSparqlWherePatterns: (
      itemFilter: ItemFilterT | undefined,
    ) => readonly sparqljs.Pattern[],
  ): readonly sparqljs.Pattern[] {
    if (filter === null) {
      return [
        {
          expression: {
            args: itemSparqlWherePatterns(undefined).concat(),
            operator: "notexists",
            type: "operation",
          },
          type: "filter",
        },
      ];
    }

    return [
      { patterns: itemSparqlWherePatterns(filter).concat(), type: "optional" },
    ];
  }
}

interface $NamedNodeFilter {
  readonly in?: readonly string[];
}

namespace $NamedNodeFilter {
  export function $sparqlWherePatterns(
    filter: $NamedNodeFilter | undefined,
    value: rdfjs.Variable,
  ) {
    const patterns: sparqljs.Pattern[] = [];

    if (!filter) {
      return patterns;
    }

    if (typeof filter.in !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "in",
          args: [
            value,
            filter.in.map((inValue) => dataFactory.namedNode(inValue)),
          ],
        },
      });
    }

    return patterns;
  }
}

interface $NumberFilter {
  readonly in?: readonly number[];
  readonly maxExclusive?: number;
  readonly maxInclusive?: number;
  readonly minExclusive?: number;
  readonly minInclusive?: number;
}

namespace $NumberFilter {
  export function $sparqlWherePatterns(
    filter: $NumberFilter | undefined,
    value: rdfjs.Variable,
  ): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];

    if (!filter) {
      return patterns;
    }

    if (typeof filter.in !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "in",
          args: [value, filter.in.map((inValue) => $toLiteral(inValue))],
        },
      });
    }

    if (typeof filter.maxExclusive !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "<",
          args: [value, $toLiteral(filter.maxExclusive)],
        },
      });
    }

    if (typeof filter.maxInclusive !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "<=",
          args: [value, $toLiteral(filter.maxInclusive)],
        },
      });
    }

    if (typeof filter.minExclusive !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: ">",
          args: [value, $toLiteral(filter.minExclusive)],
        },
      });
    }

    if (typeof filter.minInclusive !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: ">=",
          args: [value, $toLiteral(filter.minInclusive)],
        },
      });
    }

    return patterns;
  }
}

function $optimizeSparqlWherePatterns(
  patterns: readonly sparqljs.Pattern[],
): readonly sparqljs.Pattern[] {
  if (patterns.length === 0) {
    return patterns;
  }

  const filterPatterns: sparqljs.Pattern[] = [];
  const valuesPatterns: sparqljs.Pattern[] = [];
  const otherPatterns: sparqljs.Pattern[] = [];

  for (const pattern of patterns) {
    switch (pattern.type) {
      case "bgp": {
        if (pattern.triples.length === 0) {
          continue;
        }
        const lastPattern = otherPatterns.at(-1);
        if (lastPattern && lastPattern.type === "bgp") {
          // Coalesce adjacent BGP patterns
          lastPattern.triples.push(...pattern.triples);
        } else {
          otherPatterns.push(pattern);
        }
        break;
      }
      case "bind":
      case "query":
        otherPatterns.push(pattern);
        break;
      case "filter":
        filterPatterns.push(pattern);
        break;
      case "group":
        // Flatten groups outside unions
        otherPatterns.push(...$optimizeSparqlWherePatterns(pattern.patterns));
        break;
      case "values":
        valuesPatterns.push(pattern);
        break;
      case "graph":
      case "minus":
      case "optional":
      case "service": {
        const optimizedPatterns = $optimizeSparqlWherePatterns(
          pattern.patterns,
        );
        if (optimizedPatterns.length > 0) {
          otherPatterns.push({
            ...pattern,
            patterns: optimizedPatterns.concat(),
          });
        }
        break;
      }
      case "union": {
        const unionPatterns = $deduplicateSparqlWherePatterns(
          pattern.patterns.flatMap((pattern) => {
            switch (pattern.type) {
              case "group":
              // Don't flatten the groups in a union
              case "graph":
              case "minus":
              case "optional":
              case "service": {
                const optimizedPatterns = $optimizeSparqlWherePatterns(
                  pattern.patterns,
                );
                if (optimizedPatterns.length > 0) {
                  return [{ ...pattern, patterns: optimizedPatterns.concat() }];
                }
                return [] as sparqljs.Pattern[];
              }
              default:
                return [pattern];
            }
          }),
        );

        switch (unionPatterns.length) {
          case 0:
            break;
          case 1:
            otherPatterns.push(
              ...$optimizeSparqlWherePatterns([unionPatterns[0]]),
            );
            break;
          default:
            otherPatterns.push({
              ...pattern,
              patterns: unionPatterns.concat(),
            });
            break;
        }
        break;
      }
      default:
        pattern satisfies never;
    }
  }

  return $deduplicateSparqlWherePatterns(
    valuesPatterns.concat(otherPatterns).concat(filterPatterns),
  );
}

namespace $RdfVocabularies {
  export namespace rdf {
    export const first = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
    );
    export const nil = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil",
    );
    export const rest = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
    );
    export const subject = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#subject",
    );
    export const type = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    );
  }

  export namespace rdfs {
    export const subClassOf = dataFactory.namedNode(
      "http://www.w3.org/2000/01/rdf-schema#subClassOf",
    );
  }

  export namespace xsd {
    export const boolean = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#boolean",
    );
    export const date = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#date",
    );
    export const dateTime = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#dateTime",
    );
    export const decimal = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#decimal",
    );
    export const double = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#double",
    );
    export const integer = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#integer",
    );
  }
}

/**
 * A sparqljs.Pattern that's the equivalent of ?subject rdf:type/rdfs:subClassOf* ?rdfType .
 */
function $sparqlInstancesOfPattern({
  rdfType,
  subject,
}: {
  rdfType: rdfjs.NamedNode | rdfjs.Variable;
  subject: sparqljs.Triple["subject"];
}): sparqljs.Pattern {
  return {
    triples: [
      {
        subject,
        predicate: {
          items: [
            $RdfVocabularies.rdf.type,
            {
              items: [$RdfVocabularies.rdfs.subClassOf],
              pathType: "*",
              type: "path",
            },
          ],
          pathType: "/",
          type: "path",
        },
        object: rdfType,
      },
    ],
    type: "bgp",
  };
}

/**
 * Compare two values for strict equality (===), returning an $EqualsResult rather than a boolean.
 */
function $strictEquals<T extends bigint | boolean | number | string>(
  left: T,
  right: T,
): $EqualsResult {
  return $EqualsResult.fromBooleanEqualsResult(left, right, left === right);
}

interface $StringFilter {
  readonly in?: readonly string[];
  readonly maxLength?: number;
  readonly minLength?: number;
}

namespace $StringFilter {
  export function $sparqlWherePatterns(
    filter: $StringFilter | undefined,
    value: rdfjs.Variable,
  ) {
    const patterns: sparqljs.Pattern[] = [];

    if (!filter) {
      return patterns;
    }

    if (typeof filter.in !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "in",
          args: [value, filter.in.map((inValue) => $toLiteral(inValue))],
        },
      });
    }

    if (typeof filter.maxLength !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "<=",
          args: [
            { args: [value], operator: "strlen", type: "operation" },
            $toLiteral(filter.maxLength),
          ],
        },
      });
    }

    if (typeof filter.minLength !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: ">=",
          args: [
            { args: [value], operator: "strlen", type: "operation" },
            $toLiteral(filter.minLength),
          ],
        },
      });
    }

    return patterns;
  }
}

interface $TermFilter {
  readonly datatypeIn?: readonly string[];
  readonly in?: readonly {
    readonly datatype?: string;
    readonly language?: string;
    readonly type: "Literal" | "NamedNode";
    readonly value: string;
  }[];
  readonly languageIn?: readonly string[];
  readonly typeIn?: readonly ("BlankNode" | "Literal" | "NamedNode")[];
}

namespace $TermFilter {
  export function $sparqlWherePatterns(
    filter: $TermFilter | undefined,
    value: rdfjs.Variable,
  ): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];

    if (!filter) {
      return patterns;
    }

    if (typeof filter.datatypeIn !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "in",
          args: [
            { args: [value], operator: "datatype", type: "operation" },
            filter.datatypeIn.map(dataFactory.namedNode),
          ],
        },
      });
    }

    if (typeof filter.in !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "in",
          args: [
            value,
            filter.in.map((inTerm) => {
              if (typeof inTerm.datatype !== "undefined") {
                return dataFactory.literal(
                  inTerm.value,
                  dataFactory.namedNode(inTerm.datatype),
                );
              }
              if (typeof inTerm.language !== "undefined") {
                return dataFactory.literal(inTerm.value, inTerm.language);
              }
              switch (inTerm.type) {
                case "Literal":
                  return dataFactory.literal(inTerm.value);
                case "NamedNode":
                  return dataFactory.namedNode(inTerm.value);
                default:
                  inTerm.type satisfies never;
                  throw new RangeError(inTerm.type);
              }
            }),
          ],
        },
      });
    }

    if (typeof filter.languageIn !== "undefined") {
      patterns.push({
        type: "filter",
        expression: {
          type: "operation",
          operator: "in",
          args: [
            { args: [value], operator: "lang", type: "operation" },
            filter.languageIn.map((value) => dataFactory.literal(value)),
          ],
        },
      });
    }

    if (typeof filter.typeIn !== "undefined") {
      const typeInExpressions = filter.typeIn
        .map((inType) => {
          switch (inType) {
            case "BlankNode":
              return "isBlank";
            case "Literal":
              return "isLiteral";
            case "NamedNode":
              return "isIRI";
            default:
              inType satisfies never;
              throw new RangeError(inType);
          }
        })
        .map((operator) => ({
          type: "operation" as const,
          operator,
          args: [value],
        }));

      switch (typeInExpressions.length) {
        case 0:
          break;
        case 1:
          patterns.push({ type: "filter", expression: typeInExpressions[0] });
          break;
        default:
          patterns.push({
            type: "filter",
            expression: {
              type: "operation",
              operator: "||",
              args: typeInExpressions,
            },
          });
      }
    }

    return patterns;
  }
}

function $toLiteral(
  value: boolean | Date | number | string,
  datatype?: rdfjs.NamedNode,
): rdfjs.Literal {
  switch (typeof value) {
    case "boolean":
      return dataFactory.literal(
        value.toString(),
        $RdfVocabularies.xsd.boolean,
      );
    case "object": {
      if (value instanceof Date) {
        if (datatype) {
          if (datatype.equals($RdfVocabularies.xsd.date)) {
            return dataFactory.literal(
              value.toISOString().replace(/T.*$/, ""),
              datatype,
            );
          } else if (datatype.equals($RdfVocabularies.xsd.dateTime)) {
            return dataFactory.literal(value.toISOString(), datatype);
          } else {
            throw new RangeError(datatype.value);
          }
        }

        return dataFactory.literal(
          value.toISOString(),
          $RdfVocabularies.xsd.dateTime,
        );
      }
      value satisfies never;
      throw new Error("should never happen");
    }
    case "number": {
      if (datatype) {
        return dataFactory.literal(value.toString(10), datatype);
      }

      // Convert the number to a literal following SPARQL rules = tests on the lexical form
      const valueString = value.toString(10);
      if (/^[+-]?[0-9]+$/.test(valueString)) {
        // No decimal point, no exponent: xsd:integer
        return dataFactory.literal(valueString, $RdfVocabularies.xsd.integer);
      }
      if (
        /^[+-]?([0-9]+(\.[0-9]*)?|\.[0-9]+)[eE][+-]?[0-9]+$/.test(valueString)
      ) {
        // Has exponent: xsd:double
        return dataFactory.literal(valueString, $RdfVocabularies.xsd.double);
      }
      // Default: xsd:decimal
      return dataFactory.literal(valueString, $RdfVocabularies.xsd.decimal);
    }
    case "string":
      return dataFactory.literal(value, datatype);
  }
}

type $UnwrapR<T> = T extends purify.Either<any, infer R> ? R : never;
export class $NamedDefaultPartial {
  readonly $identifier: $NamedDefaultPartial.$Identifier;
  readonly $type = "$NamedDefaultPartial";

  constructor(parameters: { readonly $identifier: rdfjs.NamedNode | string }) {
    if (typeof parameters.$identifier === "object") {
      this.$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this.$identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      this.$identifier = parameters.$identifier satisfies never;
    }
  }

  $equals(other: $NamedDefaultPartial): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    return _hasher;
  }

  $toJson(): $NamedDefaultPartial.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
      } satisfies $NamedDefaultPartial.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(this.$identifier, {
      mutateGraph,
    });
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace $NamedDefaultPartial {
  export function $filter(
    filter: $NamedDefaultPartial.$Filter,
    value: $NamedDefaultPartial,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = { readonly $identifier?: $NamedNodeFilter };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, $NamedDefaultPartial> {
    return $propertiesFromJson(json).map(
      (properties) => new $NamedDefaultPartial(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, $NamedDefaultPartial> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return $NamedDefaultPartial
      .$propertiesFromRdf({
        context,
        ignoreRdfType,
        objectSet,
        preferredLanguages,
        resource,
      })
      .map((properties) => new $NamedDefaultPartial(properties));
  }

  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "$NamedDefaultPartial";
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "$NamedDefaultPartial" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "$NamedDefaultPartial",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("$NamedDefaultPartial"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {};

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<zod.ZodError, { $identifier: rdfjs.NamedNode }> {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    return purify.Either.of({ $identifier });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<Error, { $identifier: rdfjs.NamedNode }> {
    if ($parameters.resource.identifier.termType !== "NamedNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedTermValueError({
          actualValue: $parameters.resource.identifier,
          expectedValueType: "(rdfjs.NamedNode)",
          focusResource: $parameters.resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: $NamedDefaultPartial.$Identifier =
      $parameters.resource.identifier;
    return purify.Either.of({ $identifier });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: $NamedDefaultPartial.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        $NamedDefaultPartial.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            $NamedDefaultPartial.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: $NamedDefaultPartial.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      $NamedDefaultPartial.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: $NamedDefaultPartial.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("namedDefaultPartial");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }
}
export class $DefaultPartial {
  readonly $identifier: $DefaultPartial.$Identifier;
  readonly $type = "$DefaultPartial";

  constructor(parameters: {
    readonly $identifier: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this.$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this.$identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      this.$identifier = parameters.$identifier satisfies never;
    }
  }

  $equals(other: $DefaultPartial): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    return _hasher;
  }

  $toJson(): $DefaultPartial.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
      } satisfies $DefaultPartial.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace $DefaultPartial {
  export function $filter(
    filter: $DefaultPartial.$Filter,
    value: $DefaultPartial,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = { readonly $identifier?: $IdentifierFilter };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, $DefaultPartial> {
    return $propertiesFromJson(json).map(
      (properties) => new $DefaultPartial(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, $DefaultPartial> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return $DefaultPartial
      .$propertiesFromRdf({
        context,
        ignoreRdfType,
        objectSet,
        preferredLanguages,
        resource,
      })
      .map((properties) => new $DefaultPartial(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "$DefaultPartial";
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "$DefaultPartial" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "$DefaultPartial",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("$DefaultPartial"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {};

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    return purify.Either.of({ $identifier });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<Error, { $identifier: rdfjs.BlankNode | rdfjs.NamedNode }> {
    const $identifier: $DefaultPartial.$Identifier =
      $parameters.resource.identifier;
    return purify.Either.of({ $identifier });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: $DefaultPartial.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        $DefaultPartial.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            $DefaultPartial.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: $DefaultPartial.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      $DefaultPartial.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: $DefaultPartial.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("defaultPartial");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }
}
/**
 * A node shape that mints its identifier by generating a v4 UUID, if no identifier is supplied.
 */
export interface UuidV4IriIdentifierInterface {
  readonly $identifier: UuidV4IriIdentifierInterface.$Identifier;
  readonly $type: "UuidV4IriIdentifierInterface";
  readonly uuidV4IriProperty: string;
}

export namespace UuidV4IriIdentifierInterface {
  export function $create(parameters: {
    readonly $identifier?: rdfjs.NamedNode | string;
    readonly $identifierPrefix?: string;
    readonly uuidV4IriProperty: string;
  }): Omit<UuidV4IriIdentifierInterface, "$identifierPrefix"> {
    let $identifier: UuidV4IriIdentifierInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.namedNode(
        `${parameters.$identifierPrefix ?? "urn:shaclmate:UuidV4IriIdentifierInterface:"}${uuid.v4()}`,
      );
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "UuidV4IriIdentifierInterface" as const;
    const uuidV4IriProperty = parameters.uuidV4IriProperty;
    return { $identifier, $type, uuidV4IriProperty };
  }

  export function $equals(
    left: UuidV4IriIdentifierInterface,
    right: UuidV4IriIdentifierInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(left.uuidV4IriProperty, right.uuidV4IriProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "uuidV4IriProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  export function $filter(
    filter: UuidV4IriIdentifierInterface.$Filter,
    value: UuidV4IriIdentifierInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.uuidV4IriProperty !== "undefined" &&
      !$filterString(filter.uuidV4IriProperty, value.uuidV4IriProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
    readonly uuidV4IriProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, UuidV4IriIdentifierInterface> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, UuidV4IriIdentifierInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return UuidV4IriIdentifierInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _uuidV4IriIdentifierInterface: UuidV4IriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_uuidV4IriIdentifierInterface.$identifier.value);
    _hasher.update(_uuidV4IriIdentifierInterface.$type);
    UuidV4IriIdentifierInterface.$hashShaclProperties(
      _uuidV4IriIdentifierInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _uuidV4IriIdentifierInterface: UuidV4IriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_uuidV4IriIdentifierInterface.uuidV4IriProperty);
    return _hasher;
  }

  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "UuidV4IriIdentifierInterface";
    readonly uuidV4IriProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "UuidV4IriIdentifierInterface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/uuidV4IriProperty`,
          type: "Control",
        },
      ],
      label: "UuidV4IriIdentifierInterface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("UuidV4IriIdentifierInterface"),
      uuidV4IriProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    uuidV4IriProperty: {
      identifier: dataFactory.namedNode("http://example.com/uuidV4IriProperty"),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.NamedNode;
      $type: "UuidV4IriIdentifierInterface";
      uuidV4IriProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const $type = "UuidV4IriIdentifierInterface" as const;
    const uuidV4IriProperty = $jsonObject["uuidV4IriProperty"];
    return purify.Either.of({ $identifier, $type, uuidV4IriProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.NamedNode;
      $type: "UuidV4IriIdentifierInterface";
      uuidV4IriProperty: string;
    }
  > {
    if ($parameters.resource.identifier.termType !== "NamedNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedTermValueError({
          actualValue: $parameters.resource.identifier,
          expectedValueType: "(rdfjs.NamedNode)",
          focusResource: $parameters.resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: UuidV4IriIdentifierInterface.$Identifier =
      $parameters.resource.identifier;
    const $type = "UuidV4IriIdentifierInterface" as const;
    const _uuidV4IriPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.uuidV4IriProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              UuidV4IriIdentifierInterface.$properties.uuidV4IriProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_uuidV4IriPropertyEither.isLeft()) {
      return _uuidV4IriPropertyEither;
    }

    const uuidV4IriProperty = _uuidV4IriPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, $type, uuidV4IriProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: UuidV4IriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        UuidV4IriIdentifierInterface.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            UuidV4IriIdentifierInterface.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: UuidV4IriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      UuidV4IriIdentifierInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("uuidV4IriIdentifierInterface");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "uuidV4IriIdentifierInterface")}UuidV4IriProperty`,
      ),
      predicate:
        UuidV4IriIdentifierInterface.$properties.uuidV4IriProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: UuidV4IriIdentifierInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("uuidV4IriIdentifierInterface");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "uuidV4IriIdentifierInterface")}UuidV4IriProperty`,
            ),
            predicate:
              UuidV4IriIdentifierInterface.$properties.uuidV4IriProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "uuidV4IriIdentifierInterface")}UuidV4IriProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.uuidV4IriProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "uuidV4IriIdentifierInterface")}UuidV4IriProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _uuidV4IriIdentifierInterface: UuidV4IriIdentifierInterface,
  ): UuidV4IriIdentifierInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": _uuidV4IriIdentifierInterface.$identifier.value,
        $type: _uuidV4IriIdentifierInterface.$type,
        uuidV4IriProperty: _uuidV4IriIdentifierInterface.uuidV4IriProperty,
      } satisfies UuidV4IriIdentifierInterface.$Json),
    );
  }

  export function $toRdf(
    _uuidV4IriIdentifierInterface: UuidV4IriIdentifierInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(
      _uuidV4IriIdentifierInterface.$identifier,
      { mutateGraph },
    );
    resource.add(
      UuidV4IriIdentifierInterface.$properties.uuidV4IriProperty["identifier"],
      ...[_uuidV4IriIdentifierInterface.uuidV4IriProperty],
    );
    return resource;
  }
}
/**
 * A node shape that mints its identifier by generating a v4 UUID, if no identifier is supplied.
 */
export class UuidV4IriIdentifierClass {
  private _$identifier?: UuidV4IriIdentifierClass.$Identifier;
  protected readonly _$identifierPrefix?: string;
  readonly $type = "UuidV4IriIdentifierClass";
  readonly uuidV4IriProperty: string;

  constructor(parameters: {
    readonly $identifier?: rdfjs.NamedNode | string;
    readonly $identifierPrefix?: string;
    readonly uuidV4IriProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this._$identifierPrefix = parameters.$identifierPrefix;
    this.uuidV4IriProperty = parameters.uuidV4IriProperty;
  }

  get $identifier(): UuidV4IriIdentifierClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${uuid.v4()}`,
      );
    }

    if (this._$identifier.termType !== "NamedNode") {
      throw new Error(
        `expected identifier to be NamedNode, not ${this._$identifier.termType}`,
      );
    }

    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  $equals(other: UuidV4IriIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$identifierPrefix, other.$identifierPrefix).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$identifierPrefix",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.uuidV4IriProperty, other.uuidV4IriProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "uuidV4IriProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.uuidV4IriProperty);
    return _hasher;
  }

  $toJson(): UuidV4IriIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
        uuidV4IriProperty: this.uuidV4IriProperty,
      } satisfies UuidV4IriIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      UuidV4IriIdentifierClass.$properties.uuidV4IriProperty["identifier"],
      ...[this.uuidV4IriProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace UuidV4IriIdentifierClass {
  export function $filter(
    filter: UuidV4IriIdentifierClass.$Filter,
    value: UuidV4IriIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.uuidV4IriProperty !== "undefined" &&
      !$filterString(filter.uuidV4IriProperty, value.uuidV4IriProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
    readonly uuidV4IriProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, UuidV4IriIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new UuidV4IriIdentifierClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, UuidV4IriIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return UuidV4IriIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new UuidV4IriIdentifierClass(properties));
  }

  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "UuidV4IriIdentifierClass";
    readonly uuidV4IriProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "UuidV4IriIdentifierClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/uuidV4IriProperty`,
          type: "Control",
        },
      ],
      label: "UuidV4IriIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("UuidV4IriIdentifierClass"),
      uuidV4IriProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    uuidV4IriProperty: {
      identifier: dataFactory.namedNode("http://example.com/uuidV4IriProperty"),
    },
  };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.NamedNode; uuidV4IriProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const uuidV4IriProperty = $jsonObject["uuidV4IriProperty"];
    return purify.Either.of({ $identifier, uuidV4IriProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.NamedNode; uuidV4IriProperty: string }
  > {
    if ($parameters.resource.identifier.termType !== "NamedNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedTermValueError({
          actualValue: $parameters.resource.identifier,
          expectedValueType: "(rdfjs.NamedNode)",
          focusResource: $parameters.resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: UuidV4IriIdentifierClass.$Identifier =
      $parameters.resource.identifier;
    const _uuidV4IriPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.uuidV4IriProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              UuidV4IriIdentifierClass.$properties.uuidV4IriProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_uuidV4IriPropertyEither.isLeft()) {
      return _uuidV4IriPropertyEither;
    }

    const uuidV4IriProperty = _uuidV4IriPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, uuidV4IriProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: UuidV4IriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        UuidV4IriIdentifierClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            UuidV4IriIdentifierClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: UuidV4IriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      UuidV4IriIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("uuidV4IriIdentifierClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "uuidV4IriIdentifierClass")}UuidV4IriProperty`,
      ),
      predicate:
        UuidV4IriIdentifierClass.$properties.uuidV4IriProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: UuidV4IriIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("uuidV4IriIdentifierClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "uuidV4IriIdentifierClass")}UuidV4IriProperty`,
            ),
            predicate:
              UuidV4IriIdentifierClass.$properties.uuidV4IriProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "uuidV4IriIdentifierClass")}UuidV4IriProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.uuidV4IriProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "uuidV4IriIdentifierClass")}UuidV4IriProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
/**
 * Shape with sh:xone (union) properties with different discriminant types (envelope, typeof, property) x cardinality.
 */
export class UnionDiscriminantsClass {
  private _$identifier?: UnionDiscriminantsClass.$Identifier;
  readonly $type = "UnionDiscriminantsClass";
  /**
   * Union with an envelope discriminant (multiple+duplicate typeofs, no inline discriminant property).
   */
  readonly optionalClassOrClassOrStringProperty: purify.Maybe<
    | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
    | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
    | { type: "2-string"; value: string }
  >;
  /**
   * Union that can be discriminated by an inline discriminant property (termType).
   */
  readonly optionalIriOrLiteralProperty: purify.Maybe<
    rdfjs.NamedNode | rdfjs.Literal
  >;
  /**
   * Union that can be discriminated by typeof.
   */
  readonly optionalIriOrStringProperty: purify.Maybe<rdfjs.NamedNode | string>;
  /**
   * Union with an envelope discriminant (multiple typeofs, no inline discriminant property).
   */
  readonly requiredClassOrClassOrStringProperty:
    | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
    | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
    | { type: "2-string"; value: string };
  /**
   * Union that can be discriminated by an inline discriminant property (termType).
   */
  readonly requiredIriOrLiteralProperty: rdfjs.NamedNode | rdfjs.Literal;
  /**
   * Union that can be discriminated by typeof.
   */
  readonly requiredIriOrStringProperty: rdfjs.NamedNode | string;
  /**
   * Union with an envelope discriminant (multiple typeofs, no inline discriminant property).
   */
  readonly setClassOrClassOrStringProperty: readonly (
    | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
    | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
    | { type: "2-string"; value: string }
  )[];
  /**
   * Union that can be discriminated by an inline discriminant property (termType).
   */
  readonly setIriOrLiteralProperty: readonly (
    | rdfjs.NamedNode
    | rdfjs.Literal
  )[];
  /**
   * Union that can be discriminated by typeof.
   */
  readonly setIriOrStringProperty: readonly (rdfjs.NamedNode | string)[];

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly optionalClassOrClassOrStringProperty?:
      | (
          | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
          | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
          | { type: "2-string"; value: string }
        )
      | purify.Maybe<
          | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
          | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
          | { type: "2-string"; value: string }
        >;
    readonly optionalIriOrLiteralProperty?:
      | (rdfjs.NamedNode | rdfjs.Literal)
      | purify.Maybe<rdfjs.NamedNode | rdfjs.Literal>;
    readonly optionalIriOrStringProperty?:
      | rdfjs.NamedNode
      | purify.Maybe<rdfjs.NamedNode | string>
      | string;
    readonly requiredClassOrClassOrStringProperty:
      | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
      | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
      | { type: "2-string"; value: string };
    readonly requiredIriOrLiteralProperty: rdfjs.NamedNode | rdfjs.Literal;
    readonly requiredIriOrStringProperty: rdfjs.NamedNode | string;
    readonly setClassOrClassOrStringProperty?: readonly (
      | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
      | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
      | { type: "2-string"; value: string }
    )[];
    readonly setIriOrLiteralProperty?: readonly (
      | rdfjs.NamedNode
      | rdfjs.Literal
    )[];
    readonly setIriOrStringProperty?: readonly (rdfjs.NamedNode | string)[];
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.optionalClassOrClassOrStringProperty)) {
      this.optionalClassOrClassOrStringProperty =
        parameters.optionalClassOrClassOrStringProperty;
    } else if (
      typeof parameters.optionalClassOrClassOrStringProperty === "object"
    ) {
      this.optionalClassOrClassOrStringProperty = purify.Maybe.of(
        parameters.optionalClassOrClassOrStringProperty,
      );
    } else if (
      typeof parameters.optionalClassOrClassOrStringProperty === "undefined"
    ) {
      this.optionalClassOrClassOrStringProperty = purify.Maybe.empty();
    } else {
      this.optionalClassOrClassOrStringProperty =
        parameters.optionalClassOrClassOrStringProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.optionalIriOrLiteralProperty)) {
      this.optionalIriOrLiteralProperty =
        parameters.optionalIriOrLiteralProperty;
    } else if (typeof parameters.optionalIriOrLiteralProperty === "object") {
      this.optionalIriOrLiteralProperty = purify.Maybe.of(
        parameters.optionalIriOrLiteralProperty,
      );
    } else if (typeof parameters.optionalIriOrLiteralProperty === "undefined") {
      this.optionalIriOrLiteralProperty = purify.Maybe.empty();
    } else {
      this.optionalIriOrLiteralProperty =
        parameters.optionalIriOrLiteralProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.optionalIriOrStringProperty)) {
      this.optionalIriOrStringProperty = parameters.optionalIriOrStringProperty;
    } else if (typeof parameters.optionalIriOrStringProperty === "object") {
      this.optionalIriOrStringProperty = purify.Maybe.of(
        parameters.optionalIriOrStringProperty,
      );
    } else if (typeof parameters.optionalIriOrStringProperty === "string") {
      this.optionalIriOrStringProperty = purify.Maybe.of(
        parameters.optionalIriOrStringProperty,
      );
    } else if (typeof parameters.optionalIriOrStringProperty === "undefined") {
      this.optionalIriOrStringProperty = purify.Maybe.empty();
    } else {
      this.optionalIriOrStringProperty =
        parameters.optionalIriOrStringProperty satisfies never;
    }

    this.requiredClassOrClassOrStringProperty =
      parameters.requiredClassOrClassOrStringProperty;
    this.requiredIriOrLiteralProperty = parameters.requiredIriOrLiteralProperty;
    if (typeof parameters.requiredIriOrStringProperty === "object") {
      this.requiredIriOrStringProperty = parameters.requiredIriOrStringProperty;
    } else if (typeof parameters.requiredIriOrStringProperty === "string") {
      this.requiredIriOrStringProperty = parameters.requiredIriOrStringProperty;
    } else {
      this.requiredIriOrStringProperty =
        parameters.requiredIriOrStringProperty satisfies never;
    }

    if (typeof parameters.setClassOrClassOrStringProperty === "undefined") {
      this.setClassOrClassOrStringProperty = [];
    } else if (typeof parameters.setClassOrClassOrStringProperty === "object") {
      this.setClassOrClassOrStringProperty =
        parameters.setClassOrClassOrStringProperty;
    } else {
      this.setClassOrClassOrStringProperty =
        parameters.setClassOrClassOrStringProperty satisfies never;
    }

    if (typeof parameters.setIriOrLiteralProperty === "undefined") {
      this.setIriOrLiteralProperty = [];
    } else if (typeof parameters.setIriOrLiteralProperty === "object") {
      this.setIriOrLiteralProperty = parameters.setIriOrLiteralProperty;
    } else {
      this.setIriOrLiteralProperty =
        parameters.setIriOrLiteralProperty satisfies never;
    }

    if (typeof parameters.setIriOrStringProperty === "undefined") {
      this.setIriOrStringProperty = [];
    } else if (typeof parameters.setIriOrStringProperty === "object") {
      this.setIriOrStringProperty = parameters.setIriOrStringProperty;
    } else {
      this.setIriOrStringProperty =
        parameters.setIriOrStringProperty satisfies never;
    }
  }

  get $identifier(): UnionDiscriminantsClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: UnionDiscriminantsClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (
              left:
                | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
                | { type: "2-string"; value: string },
              right:
                | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
                | { type: "2-string"; value: string },
            ) => {
              if (
                left.type === "0-ClassUnionMember1" &&
                right.type === "0-ClassUnionMember1"
              ) {
                return ((left, right) => left.$equals(right))(
                  left.value,
                  right.value,
                );
              }
              if (
                left.type === "1-ClassUnionMember2" &&
                right.type === "1-ClassUnionMember2"
              ) {
                return ((left, right) => left.$equals(right))(
                  left.value,
                  right.value,
                );
              }
              if (left.type === "2-string" && right.type === "2-string") {
                return $strictEquals(left.value, right.value);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(
          this.optionalClassOrClassOrStringProperty,
          other.optionalClassOrClassOrStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalClassOrClassOrStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (
              left: rdfjs.NamedNode | rdfjs.Literal,
              right: rdfjs.NamedNode | rdfjs.Literal,
            ) => {
              if (
                left.termType === "NamedNode" &&
                right.termType === "NamedNode"
              ) {
                return $booleanEquals(left, right);
              }
              if (left.termType === "Literal" && right.termType === "Literal") {
                return $booleanEquals(left, right);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(
          this.optionalIriOrLiteralProperty,
          other.optionalIriOrLiteralProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalIriOrLiteralProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (
              left: rdfjs.NamedNode | string,
              right: rdfjs.NamedNode | string,
            ) => {
              if (typeof left === "object" && typeof right === "object") {
                return $booleanEquals(left, right);
              }
              if (typeof left === "string" && typeof right === "string") {
                return $strictEquals(left, right);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(
          this.optionalIriOrStringProperty,
          other.optionalIriOrStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalIriOrStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((
          left:
            | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
            | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
            | { type: "2-string"; value: string },
          right:
            | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
            | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
            | { type: "2-string"; value: string },
        ) => {
          if (
            left.type === "0-ClassUnionMember1" &&
            right.type === "0-ClassUnionMember1"
          ) {
            return ((left, right) => left.$equals(right))(
              left.value,
              right.value,
            );
          }
          if (
            left.type === "1-ClassUnionMember2" &&
            right.type === "1-ClassUnionMember2"
          ) {
            return ((left, right) => left.$equals(right))(
              left.value,
              right.value,
            );
          }
          if (left.type === "2-string" && right.type === "2-string") {
            return $strictEquals(left.value, right.value);
          }

          return purify.Left({
            left,
            right,
            propertyName: "type",
            propertyValuesUnequal: {
              left: typeof left,
              right: typeof right,
              type: "BooleanEquals" as const,
            },
            type: "Property" as const,
          });
        })(
          this.requiredClassOrClassOrStringProperty,
          other.requiredClassOrClassOrStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "requiredClassOrClassOrStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((
          left: rdfjs.NamedNode | rdfjs.Literal,
          right: rdfjs.NamedNode | rdfjs.Literal,
        ) => {
          if (left.termType === "NamedNode" && right.termType === "NamedNode") {
            return $booleanEquals(left, right);
          }
          if (left.termType === "Literal" && right.termType === "Literal") {
            return $booleanEquals(left, right);
          }

          return purify.Left({
            left,
            right,
            propertyName: "type",
            propertyValuesUnequal: {
              left: typeof left,
              right: typeof right,
              type: "BooleanEquals" as const,
            },
            type: "Property" as const,
          });
        })(
          this.requiredIriOrLiteralProperty,
          other.requiredIriOrLiteralProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "requiredIriOrLiteralProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left: rdfjs.NamedNode | string, right: rdfjs.NamedNode | string) => {
          if (typeof left === "object" && typeof right === "object") {
            return $booleanEquals(left, right);
          }
          if (typeof left === "string" && typeof right === "string") {
            return $strictEquals(left, right);
          }

          return purify.Left({
            left,
            right,
            propertyName: "type",
            propertyValuesUnequal: {
              left: typeof left,
              right: typeof right,
              type: "BooleanEquals" as const,
            },
            type: "Property" as const,
          });
        })(
          this.requiredIriOrStringProperty,
          other.requiredIriOrStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "requiredIriOrStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(
            left,
            right,
            (
              left:
                | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
                | { type: "2-string"; value: string },
              right:
                | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
                | { type: "2-string"; value: string },
            ) => {
              if (
                left.type === "0-ClassUnionMember1" &&
                right.type === "0-ClassUnionMember1"
              ) {
                return ((left, right) => left.$equals(right))(
                  left.value,
                  right.value,
                );
              }
              if (
                left.type === "1-ClassUnionMember2" &&
                right.type === "1-ClassUnionMember2"
              ) {
                return ((left, right) => left.$equals(right))(
                  left.value,
                  right.value,
                );
              }
              if (left.type === "2-string" && right.type === "2-string") {
                return $strictEquals(left.value, right.value);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(
          this.setClassOrClassOrStringProperty,
          other.setClassOrClassOrStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "setClassOrClassOrStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(
            left,
            right,
            (
              left: rdfjs.NamedNode | rdfjs.Literal,
              right: rdfjs.NamedNode | rdfjs.Literal,
            ) => {
              if (
                left.termType === "NamedNode" &&
                right.termType === "NamedNode"
              ) {
                return $booleanEquals(left, right);
              }
              if (left.termType === "Literal" && right.termType === "Literal") {
                return $booleanEquals(left, right);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(
          this.setIriOrLiteralProperty,
          other.setIriOrLiteralProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "setIriOrLiteralProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(
            left,
            right,
            (
              left: rdfjs.NamedNode | string,
              right: rdfjs.NamedNode | string,
            ) => {
              if (typeof left === "object" && typeof right === "object") {
                return $booleanEquals(left, right);
              }
              if (typeof left === "string" && typeof right === "string") {
                return $strictEquals(left, right);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(this.setIriOrStringProperty, other.setIriOrStringProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "setIriOrStringProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.optionalClassOrClassOrStringProperty.ifJust((value0) => {
      switch (value0.type) {
        case "0-ClassUnionMember1": {
          value0.value.$hash(_hasher);
          break;
        }
        case "1-ClassUnionMember2": {
          value0.value.$hash(_hasher);
          break;
        }
        case "2-string": {
          _hasher.update(value0.value);
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    this.optionalIriOrLiteralProperty.ifJust((value0) => {
      switch (value0.termType) {
        case "NamedNode": {
          _hasher.update(value0.termType);
          _hasher.update(value0.value);
          break;
        }
        case "Literal": {
          _hasher.update(value0.datatype.value);
          _hasher.update(value0.language);
          _hasher.update(value0.termType);
          _hasher.update(value0.value);
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    this.optionalIriOrStringProperty.ifJust((value0) => {
      switch (typeof value0) {
        case "object": {
          _hasher.update(value0.termType);
          _hasher.update(value0.value);
          break;
        }
        case "string": {
          _hasher.update(value0);
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    switch (this.requiredClassOrClassOrStringProperty.type) {
      case "0-ClassUnionMember1": {
        this.requiredClassOrClassOrStringProperty.value.$hash(_hasher);
        break;
      }
      case "1-ClassUnionMember2": {
        this.requiredClassOrClassOrStringProperty.value.$hash(_hasher);
        break;
      }
      case "2-string": {
        _hasher.update(this.requiredClassOrClassOrStringProperty.value);
        break;
      }
      default:
        this.requiredClassOrClassOrStringProperty satisfies never;
        throw new Error("unrecognized type");
    }

    switch (this.requiredIriOrLiteralProperty.termType) {
      case "NamedNode": {
        _hasher.update(this.requiredIriOrLiteralProperty.termType);
        _hasher.update(this.requiredIriOrLiteralProperty.value);
        break;
      }
      case "Literal": {
        _hasher.update(this.requiredIriOrLiteralProperty.datatype.value);
        _hasher.update(this.requiredIriOrLiteralProperty.language);
        _hasher.update(this.requiredIriOrLiteralProperty.termType);
        _hasher.update(this.requiredIriOrLiteralProperty.value);
        break;
      }
      default:
        this.requiredIriOrLiteralProperty satisfies never;
        throw new Error("unrecognized type");
    }

    switch (typeof this.requiredIriOrStringProperty) {
      case "object": {
        _hasher.update(this.requiredIriOrStringProperty.termType);
        _hasher.update(this.requiredIriOrStringProperty.value);
        break;
      }
      case "string": {
        _hasher.update(this.requiredIriOrStringProperty);
        break;
      }
      default:
        this.requiredIriOrStringProperty satisfies never;
        throw new Error("unrecognized type");
    }

    for (const item0 of this.setClassOrClassOrStringProperty) {
      switch (item0.type) {
        case "0-ClassUnionMember1": {
          item0.value.$hash(_hasher);
          break;
        }
        case "1-ClassUnionMember2": {
          item0.value.$hash(_hasher);
          break;
        }
        case "2-string": {
          _hasher.update(item0.value);
          break;
        }
        default:
          item0 satisfies never;
          throw new Error("unrecognized type");
      }
    }

    for (const item0 of this.setIriOrLiteralProperty) {
      switch (item0.termType) {
        case "NamedNode": {
          _hasher.update(item0.termType);
          _hasher.update(item0.value);
          break;
        }
        case "Literal": {
          _hasher.update(item0.datatype.value);
          _hasher.update(item0.language);
          _hasher.update(item0.termType);
          _hasher.update(item0.value);
          break;
        }
        default:
          item0 satisfies never;
          throw new Error("unrecognized type");
      }
    }

    for (const item0 of this.setIriOrStringProperty) {
      switch (typeof item0) {
        case "object": {
          _hasher.update(item0.termType);
          _hasher.update(item0.value);
          break;
        }
        case "string": {
          _hasher.update(item0);
          break;
        }
        default:
          item0 satisfies never;
          throw new Error("unrecognized type");
      }
    }

    return _hasher;
  }

  $toJson(): UnionDiscriminantsClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        optionalClassOrClassOrStringProperty:
          this.optionalClassOrClassOrStringProperty
            .map((item) =>
              item.type === "2-string"
                ? { type: "2-string" as const, value: item.value }
                : item.type === "1-ClassUnionMember2"
                  ? {
                      type: "1-ClassUnionMember2" as const,
                      value: item.value.$toJson(),
                    }
                  : {
                      type: "0-ClassUnionMember1" as const,
                      value: item.value.$toJson(),
                    },
            )
            .extract(),
        optionalIriOrLiteralProperty: this.optionalIriOrLiteralProperty
          .map((item) =>
            item.termType === "Literal"
              ? {
                  "@language":
                    item.language.length > 0 ? item.language : undefined,
                  termType: "Literal" as const,
                  "@type":
                    item.datatype.value !==
                    "http://www.w3.org/2001/XMLSchema#string"
                      ? item.datatype.value
                      : undefined,
                  "@value": item.value,
                }
              : { "@id": item.value, termType: item.termType as "NamedNode" },
          )
          .extract(),
        optionalIriOrStringProperty: this.optionalIriOrStringProperty
          .map((item) =>
            typeof item === "string" ? item : { "@id": item.value },
          )
          .extract(),
        requiredClassOrClassOrStringProperty:
          this.requiredClassOrClassOrStringProperty.type === "2-string"
            ? {
                type: "2-string" as const,
                value: this.requiredClassOrClassOrStringProperty.value,
              }
            : this.requiredClassOrClassOrStringProperty.type ===
                "1-ClassUnionMember2"
              ? {
                  type: "1-ClassUnionMember2" as const,
                  value:
                    this.requiredClassOrClassOrStringProperty.value.$toJson(),
                }
              : {
                  type: "0-ClassUnionMember1" as const,
                  value:
                    this.requiredClassOrClassOrStringProperty.value.$toJson(),
                },
        requiredIriOrLiteralProperty:
          this.requiredIriOrLiteralProperty.termType === "Literal"
            ? {
                "@language":
                  this.requiredIriOrLiteralProperty.language.length > 0
                    ? this.requiredIriOrLiteralProperty.language
                    : undefined,
                termType: "Literal" as const,
                "@type":
                  this.requiredIriOrLiteralProperty.datatype.value !==
                  "http://www.w3.org/2001/XMLSchema#string"
                    ? this.requiredIriOrLiteralProperty.datatype.value
                    : undefined,
                "@value": this.requiredIriOrLiteralProperty.value,
              }
            : {
                "@id": this.requiredIriOrLiteralProperty.value,
                termType: this.requiredIriOrLiteralProperty
                  .termType as "NamedNode",
              },
        requiredIriOrStringProperty:
          typeof this.requiredIriOrStringProperty === "string"
            ? this.requiredIriOrStringProperty
            : { "@id": this.requiredIriOrStringProperty.value },
        setClassOrClassOrStringProperty:
          this.setClassOrClassOrStringProperty.map((item) =>
            item.type === "2-string"
              ? { type: "2-string" as const, value: item.value }
              : item.type === "1-ClassUnionMember2"
                ? {
                    type: "1-ClassUnionMember2" as const,
                    value: item.value.$toJson(),
                  }
                : {
                    type: "0-ClassUnionMember1" as const,
                    value: item.value.$toJson(),
                  },
          ),
        setIriOrLiteralProperty: this.setIriOrLiteralProperty.map((item) =>
          item.termType === "Literal"
            ? {
                "@language":
                  item.language.length > 0 ? item.language : undefined,
                termType: "Literal" as const,
                "@type":
                  item.datatype.value !==
                  "http://www.w3.org/2001/XMLSchema#string"
                    ? item.datatype.value
                    : undefined,
                "@value": item.value,
              }
            : { "@id": item.value, termType: item.termType as "NamedNode" },
        ),
        setIriOrStringProperty: this.setIriOrStringProperty.map((item) =>
          typeof item === "string" ? item : { "@id": item.value },
        ),
      } satisfies UnionDiscriminantsClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      UnionDiscriminantsClass.$properties.optionalClassOrClassOrStringProperty[
        "identifier"
      ],
      ...this.optionalClassOrClassOrStringProperty.toList().flatMap((value) =>
        value.type === "2-string"
          ? ([value.value] as readonly Parameters<
              rdfjsResource.MutableResource["add"]
            >[1][])
          : ([
              value.value.$toRdf({
                mutateGraph: mutateGraph,
                resourceSet: resourceSet,
              }).identifier,
            ] as readonly Parameters<
              rdfjsResource.MutableResource["add"]
            >[1][]),
      ),
    );
    resource.add(
      UnionDiscriminantsClass.$properties.optionalIriOrLiteralProperty[
        "identifier"
      ],
      ...this.optionalIriOrLiteralProperty
        .toList()
        .flatMap(
          (value) =>
            [value] as readonly Parameters<
              rdfjsResource.MutableResource["add"]
            >[1][],
        ),
    );
    resource.add(
      UnionDiscriminantsClass.$properties.optionalIriOrStringProperty[
        "identifier"
      ],
      ...this.optionalIriOrStringProperty
        .toList()
        .flatMap(
          (value) =>
            [value] as readonly Parameters<
              rdfjsResource.MutableResource["add"]
            >[1][],
        ),
    );
    resource.add(
      UnionDiscriminantsClass.$properties.requiredClassOrClassOrStringProperty[
        "identifier"
      ],
      ...(this.requiredClassOrClassOrStringProperty.type === "2-string"
        ? ([
            this.requiredClassOrClassOrStringProperty.value,
          ] as readonly Parameters<rdfjsResource.MutableResource["add"]>[1][])
        : ([
            this.requiredClassOrClassOrStringProperty.value.$toRdf({
              mutateGraph: mutateGraph,
              resourceSet: resourceSet,
            }).identifier,
          ] as readonly Parameters<rdfjsResource.MutableResource["add"]>[1][])),
    );
    resource.add(
      UnionDiscriminantsClass.$properties.requiredIriOrLiteralProperty[
        "identifier"
      ],
      ...([this.requiredIriOrLiteralProperty] as readonly Parameters<
        rdfjsResource.MutableResource["add"]
      >[1][]),
    );
    resource.add(
      UnionDiscriminantsClass.$properties.requiredIriOrStringProperty[
        "identifier"
      ],
      ...([this.requiredIriOrStringProperty] as readonly Parameters<
        rdfjsResource.MutableResource["add"]
      >[1][]),
    );
    resource.add(
      UnionDiscriminantsClass.$properties.setClassOrClassOrStringProperty[
        "identifier"
      ],
      ...this.setClassOrClassOrStringProperty.flatMap((item) =>
        item.type === "2-string"
          ? ([item.value] as readonly Parameters<
              rdfjsResource.MutableResource["add"]
            >[1][])
          : ([
              item.value.$toRdf({
                mutateGraph: mutateGraph,
                resourceSet: resourceSet,
              }).identifier,
            ] as readonly Parameters<
              rdfjsResource.MutableResource["add"]
            >[1][]),
      ),
    );
    resource.add(
      UnionDiscriminantsClass.$properties.setIriOrLiteralProperty["identifier"],
      ...this.setIriOrLiteralProperty.flatMap(
        (item) =>
          [item] as readonly Parameters<
            rdfjsResource.MutableResource["add"]
          >[1][],
      ),
    );
    resource.add(
      UnionDiscriminantsClass.$properties.setIriOrStringProperty["identifier"],
      ...this.setIriOrStringProperty.flatMap(
        (item) =>
          [item] as readonly Parameters<
            rdfjsResource.MutableResource["add"]
          >[1][],
      ),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace UnionDiscriminantsClass {
  export function $filter(
    filter: UnionDiscriminantsClass.$Filter,
    value: UnionDiscriminantsClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.optionalClassOrClassOrStringProperty !== "undefined" &&
      !$filterMaybe<
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
        | { type: "2-string"; value: string },
        {
          readonly on?: {
            readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
            readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
            readonly "2-string"?: $StringFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
              readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
              readonly "2-string"?: $StringFilter;
            };
          },
          value:
            | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
            | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
            | { type: "2-string"; value: string },
        ) => {
          if (typeof filter.on?.["0-ClassUnionMember1"] !== "undefined") {
            switch (value.type) {
              case "0-ClassUnionMember1":
                if (
                  !ClassUnionMember1.$filter(
                    filter.on["0-ClassUnionMember1"],
                    value.value,
                  )
                ) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["1-ClassUnionMember2"] !== "undefined") {
            switch (value.type) {
              case "1-ClassUnionMember2":
                if (
                  !ClassUnionMember2.$filter(
                    filter.on["1-ClassUnionMember2"],
                    value.value,
                  )
                ) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["2-string"] !== "undefined") {
            switch (value.type) {
              case "2-string":
                if (!$filterString(filter.on["2-string"], value.value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(
        filter.optionalClassOrClassOrStringProperty,
        value.optionalClassOrClassOrStringProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalIriOrLiteralProperty !== "undefined" &&
      !$filterMaybe<
        rdfjs.NamedNode | rdfjs.Literal,
        {
          readonly on?: {
            readonly NamedNode?: $NamedNodeFilter;
            readonly Literal?: $LiteralFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly NamedNode?: $NamedNodeFilter;
              readonly Literal?: $LiteralFilter;
            };
          },
          value: rdfjs.NamedNode | rdfjs.Literal,
        ) => {
          if (typeof filter.on?.["NamedNode"] !== "undefined") {
            switch (value.termType) {
              case "NamedNode":
                if (!$filterNamedNode(filter.on["NamedNode"], value)) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["Literal"] !== "undefined") {
            switch (value.termType) {
              case "Literal":
                if (!$filterLiteral(filter.on["Literal"], value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.optionalIriOrLiteralProperty, value.optionalIriOrLiteralProperty)
    ) {
      return false;
    }

    if (
      typeof filter.optionalIriOrStringProperty !== "undefined" &&
      !$filterMaybe<
        rdfjs.NamedNode | string,
        {
          readonly on?: {
            readonly object?: $NamedNodeFilter;
            readonly string?: $StringFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly object?: $NamedNodeFilter;
              readonly string?: $StringFilter;
            };
          },
          value: rdfjs.NamedNode | string,
        ) => {
          if (typeof filter.on?.["object"] !== "undefined") {
            switch (typeof value) {
              case "object":
                if (!$filterNamedNode(filter.on["object"], value)) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["string"] !== "undefined") {
            switch (typeof value) {
              case "string":
                if (!$filterString(filter.on["string"], value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.optionalIriOrStringProperty, value.optionalIriOrStringProperty)
    ) {
      return false;
    }

    if (
      typeof filter.requiredClassOrClassOrStringProperty !== "undefined" &&
      !((
        filter: {
          readonly on?: {
            readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
            readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
            readonly "2-string"?: $StringFilter;
          };
        },
        value:
          | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
          | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
          | { type: "2-string"; value: string },
      ) => {
        if (typeof filter.on?.["0-ClassUnionMember1"] !== "undefined") {
          switch (value.type) {
            case "0-ClassUnionMember1":
              if (
                !ClassUnionMember1.$filter(
                  filter.on["0-ClassUnionMember1"],
                  value.value,
                )
              ) {
                return false;
              }
              break;
          }
        }

        if (typeof filter.on?.["1-ClassUnionMember2"] !== "undefined") {
          switch (value.type) {
            case "1-ClassUnionMember2":
              if (
                !ClassUnionMember2.$filter(
                  filter.on["1-ClassUnionMember2"],
                  value.value,
                )
              ) {
                return false;
              }
              break;
          }
        }

        if (typeof filter.on?.["2-string"] !== "undefined") {
          switch (value.type) {
            case "2-string":
              if (!$filterString(filter.on["2-string"], value.value)) {
                return false;
              }
              break;
          }
        }

        return true;
      })(
        filter.requiredClassOrClassOrStringProperty,
        value.requiredClassOrClassOrStringProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.requiredIriOrLiteralProperty !== "undefined" &&
      !((
        filter: {
          readonly on?: {
            readonly NamedNode?: $NamedNodeFilter;
            readonly Literal?: $LiteralFilter;
          };
        },
        value: rdfjs.NamedNode | rdfjs.Literal,
      ) => {
        if (typeof filter.on?.["NamedNode"] !== "undefined") {
          switch (value.termType) {
            case "NamedNode":
              if (!$filterNamedNode(filter.on["NamedNode"], value)) {
                return false;
              }
              break;
          }
        }

        if (typeof filter.on?.["Literal"] !== "undefined") {
          switch (value.termType) {
            case "Literal":
              if (!$filterLiteral(filter.on["Literal"], value)) {
                return false;
              }
              break;
          }
        }

        return true;
      })(
        filter.requiredIriOrLiteralProperty,
        value.requiredIriOrLiteralProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.requiredIriOrStringProperty !== "undefined" &&
      !((
        filter: {
          readonly on?: {
            readonly object?: $NamedNodeFilter;
            readonly string?: $StringFilter;
          };
        },
        value: rdfjs.NamedNode | string,
      ) => {
        if (typeof filter.on?.["object"] !== "undefined") {
          switch (typeof value) {
            case "object":
              if (!$filterNamedNode(filter.on["object"], value)) {
                return false;
              }
              break;
          }
        }

        if (typeof filter.on?.["string"] !== "undefined") {
          switch (typeof value) {
            case "string":
              if (!$filterString(filter.on["string"], value)) {
                return false;
              }
              break;
          }
        }

        return true;
      })(filter.requiredIriOrStringProperty, value.requiredIriOrStringProperty)
    ) {
      return false;
    }

    if (
      typeof filter.setClassOrClassOrStringProperty !== "undefined" &&
      !$filterArray<
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
        | { type: "2-string"; value: string },
        {
          readonly on?: {
            readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
            readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
            readonly "2-string"?: $StringFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
              readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
              readonly "2-string"?: $StringFilter;
            };
          },
          value:
            | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
            | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
            | { type: "2-string"; value: string },
        ) => {
          if (typeof filter.on?.["0-ClassUnionMember1"] !== "undefined") {
            switch (value.type) {
              case "0-ClassUnionMember1":
                if (
                  !ClassUnionMember1.$filter(
                    filter.on["0-ClassUnionMember1"],
                    value.value,
                  )
                ) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["1-ClassUnionMember2"] !== "undefined") {
            switch (value.type) {
              case "1-ClassUnionMember2":
                if (
                  !ClassUnionMember2.$filter(
                    filter.on["1-ClassUnionMember2"],
                    value.value,
                  )
                ) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["2-string"] !== "undefined") {
            switch (value.type) {
              case "2-string":
                if (!$filterString(filter.on["2-string"], value.value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(
        filter.setClassOrClassOrStringProperty,
        value.setClassOrClassOrStringProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.setIriOrLiteralProperty !== "undefined" &&
      !$filterArray<
        rdfjs.NamedNode | rdfjs.Literal,
        {
          readonly on?: {
            readonly NamedNode?: $NamedNodeFilter;
            readonly Literal?: $LiteralFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly NamedNode?: $NamedNodeFilter;
              readonly Literal?: $LiteralFilter;
            };
          },
          value: rdfjs.NamedNode | rdfjs.Literal,
        ) => {
          if (typeof filter.on?.["NamedNode"] !== "undefined") {
            switch (value.termType) {
              case "NamedNode":
                if (!$filterNamedNode(filter.on["NamedNode"], value)) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["Literal"] !== "undefined") {
            switch (value.termType) {
              case "Literal":
                if (!$filterLiteral(filter.on["Literal"], value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.setIriOrLiteralProperty, value.setIriOrLiteralProperty)
    ) {
      return false;
    }

    if (
      typeof filter.setIriOrStringProperty !== "undefined" &&
      !$filterArray<
        rdfjs.NamedNode | string,
        {
          readonly on?: {
            readonly object?: $NamedNodeFilter;
            readonly string?: $StringFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly object?: $NamedNodeFilter;
              readonly string?: $StringFilter;
            };
          },
          value: rdfjs.NamedNode | string,
        ) => {
          if (typeof filter.on?.["object"] !== "undefined") {
            switch (typeof value) {
              case "object":
                if (!$filterNamedNode(filter.on["object"], value)) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["string"] !== "undefined") {
            switch (typeof value) {
              case "string":
                if (!$filterString(filter.on["string"], value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.setIriOrStringProperty, value.setIriOrStringProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly optionalClassOrClassOrStringProperty?: $MaybeFilter<{
      readonly on?: {
        readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
        readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
        readonly "2-string"?: $StringFilter;
      };
    }>;
    readonly optionalIriOrLiteralProperty?: $MaybeFilter<{
      readonly on?: {
        readonly NamedNode?: $NamedNodeFilter;
        readonly Literal?: $LiteralFilter;
      };
    }>;
    readonly optionalIriOrStringProperty?: $MaybeFilter<{
      readonly on?: {
        readonly object?: $NamedNodeFilter;
        readonly string?: $StringFilter;
      };
    }>;
    readonly requiredClassOrClassOrStringProperty?: {
      readonly on?: {
        readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
        readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
        readonly "2-string"?: $StringFilter;
      };
    };
    readonly requiredIriOrLiteralProperty?: {
      readonly on?: {
        readonly NamedNode?: $NamedNodeFilter;
        readonly Literal?: $LiteralFilter;
      };
    };
    readonly requiredIriOrStringProperty?: {
      readonly on?: {
        readonly object?: $NamedNodeFilter;
        readonly string?: $StringFilter;
      };
    };
    readonly setClassOrClassOrStringProperty?: $CollectionFilter<{
      readonly on?: {
        readonly "0-ClassUnionMember1"?: ClassUnionMember1.$Filter;
        readonly "1-ClassUnionMember2"?: ClassUnionMember2.$Filter;
        readonly "2-string"?: $StringFilter;
      };
    }>;
    readonly setIriOrLiteralProperty?: $CollectionFilter<{
      readonly on?: {
        readonly NamedNode?: $NamedNodeFilter;
        readonly Literal?: $LiteralFilter;
      };
    }>;
    readonly setIriOrStringProperty?: $CollectionFilter<{
      readonly on?: {
        readonly object?: $NamedNodeFilter;
        readonly string?: $StringFilter;
      };
    }>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, UnionDiscriminantsClass> {
    return $propertiesFromJson(json).map(
      (properties) => new UnionDiscriminantsClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, UnionDiscriminantsClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return UnionDiscriminantsClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new UnionDiscriminantsClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "UnionDiscriminantsClass";
    readonly optionalClassOrClassOrStringProperty?:
      | { type: "0-ClassUnionMember1"; value: ClassUnionMember1.$Json }
      | { type: "1-ClassUnionMember2"; value: ClassUnionMember2.$Json }
      | { type: "2-string"; value: string };
    readonly optionalIriOrLiteralProperty?:
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly termType: "Literal";
          readonly "@type"?: string;
          readonly "@value": string;
        };
    readonly optionalIriOrStringProperty?: { readonly "@id": string } | string;
    readonly requiredClassOrClassOrStringProperty:
      | { type: "0-ClassUnionMember1"; value: ClassUnionMember1.$Json }
      | { type: "1-ClassUnionMember2"; value: ClassUnionMember2.$Json }
      | { type: "2-string"; value: string };
    readonly requiredIriOrLiteralProperty:
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly termType: "Literal";
          readonly "@type"?: string;
          readonly "@value": string;
        };
    readonly requiredIriOrStringProperty: { readonly "@id": string } | string;
    readonly setClassOrClassOrStringProperty?: readonly (
      | { type: "0-ClassUnionMember1"; value: ClassUnionMember1.$Json }
      | { type: "1-ClassUnionMember2"; value: ClassUnionMember2.$Json }
      | { type: "2-string"; value: string }
    )[];
    readonly setIriOrLiteralProperty?: readonly (
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly termType: "Literal";
          readonly "@type"?: string;
          readonly "@value": string;
        }
    )[];
    readonly setIriOrStringProperty?: readonly (
      | { readonly "@id": string }
      | string
    )[];
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "UnionDiscriminantsClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/optionalClassOrClassOrStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/optionalIriOrLiteralProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/optionalIriOrStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/requiredClassOrClassOrStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/requiredIriOrLiteralProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/requiredIriOrStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/setClassOrClassOrStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/setIriOrLiteralProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/setIriOrStringProperty`,
          type: "Control",
        },
      ],
      label: "UnionDiscriminantsClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("UnionDiscriminantsClass"),
      optionalClassOrClassOrStringProperty: zod
        .discriminatedUnion("type", [
          zod.object({
            type: zod.literal("0-ClassUnionMember1"),
            value: ClassUnionMember1.$jsonZodSchema(),
          }),
          zod.object({
            type: zod.literal("1-ClassUnionMember2"),
            value: ClassUnionMember2.$jsonZodSchema(),
          }),
          zod.object({ type: zod.literal("2-string"), value: zod.string() }),
        ])
        .optional()
        .describe(
          "Union with an envelope discriminant (multiple+duplicate typeofs, no inline discriminant property).",
        ),
      optionalIriOrLiteralProperty: zod
        .discriminatedUnion("termType", [
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("NamedNode"),
          }),
          zod.object({
            "@language": zod.string().optional(),
            termType: zod.literal("Literal"),
            "@type": zod.string().optional(),
            "@value": zod.string(),
          }),
        ])
        .optional()
        .describe(
          "Union that can be discriminated by an inline discriminant property (termType).",
        ),
      optionalIriOrStringProperty: zod
        .union([zod.object({ "@id": zod.string().min(1) }), zod.string()])
        .optional()
        .describe("Union that can be discriminated by typeof."),
      requiredClassOrClassOrStringProperty: zod
        .discriminatedUnion("type", [
          zod.object({
            type: zod.literal("0-ClassUnionMember1"),
            value: ClassUnionMember1.$jsonZodSchema(),
          }),
          zod.object({
            type: zod.literal("1-ClassUnionMember2"),
            value: ClassUnionMember2.$jsonZodSchema(),
          }),
          zod.object({ type: zod.literal("2-string"), value: zod.string() }),
        ])
        .describe(
          "Union with an envelope discriminant (multiple typeofs, no inline discriminant property).",
        ),
      requiredIriOrLiteralProperty: zod
        .discriminatedUnion("termType", [
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("NamedNode"),
          }),
          zod.object({
            "@language": zod.string().optional(),
            termType: zod.literal("Literal"),
            "@type": zod.string().optional(),
            "@value": zod.string(),
          }),
        ])
        .describe(
          "Union that can be discriminated by an inline discriminant property (termType).",
        ),
      requiredIriOrStringProperty: zod
        .union([zod.object({ "@id": zod.string().min(1) }), zod.string()])
        .describe("Union that can be discriminated by typeof."),
      setClassOrClassOrStringProperty: zod
        .discriminatedUnion("type", [
          zod.object({
            type: zod.literal("0-ClassUnionMember1"),
            value: ClassUnionMember1.$jsonZodSchema(),
          }),
          zod.object({
            type: zod.literal("1-ClassUnionMember2"),
            value: ClassUnionMember2.$jsonZodSchema(),
          }),
          zod.object({ type: zod.literal("2-string"), value: zod.string() }),
        ])
        .array()
        .default(() => [])
        .describe(
          "Union with an envelope discriminant (multiple typeofs, no inline discriminant property).",
        ),
      setIriOrLiteralProperty: zod
        .discriminatedUnion("termType", [
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("NamedNode"),
          }),
          zod.object({
            "@language": zod.string().optional(),
            termType: zod.literal("Literal"),
            "@type": zod.string().optional(),
            "@value": zod.string(),
          }),
        ])
        .array()
        .default(() => [])
        .describe(
          "Union that can be discriminated by an inline discriminant property (termType).",
        ),
      setIriOrStringProperty: zod
        .union([zod.object({ "@id": zod.string().min(1) }), zod.string()])
        .array()
        .default(() => [])
        .describe("Union that can be discriminated by typeof."),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    optionalClassOrClassOrStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalClassOrClassOrStringProperty",
      ),
    },
    optionalIriOrLiteralProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalIriOrLiteralProperty",
      ),
    },
    optionalIriOrStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalIriOrStringProperty",
      ),
    },
    requiredClassOrClassOrStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/requiredClassOrClassOrStringProperty",
      ),
    },
    requiredIriOrLiteralProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/requiredIriOrLiteralProperty",
      ),
    },
    requiredIriOrStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/requiredIriOrStringProperty",
      ),
    },
    setClassOrClassOrStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/setClassOrClassOrStringProperty",
      ),
    },
    setIriOrLiteralProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/setIriOrLiteralProperty",
      ),
    },
    setIriOrStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/setIriOrStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      optionalClassOrClassOrStringProperty: purify.Maybe<
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
        | { type: "2-string"; value: string }
      >;
      optionalIriOrLiteralProperty: purify.Maybe<
        rdfjs.NamedNode | rdfjs.Literal
      >;
      optionalIriOrStringProperty: purify.Maybe<rdfjs.NamedNode | string>;
      requiredClassOrClassOrStringProperty:
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
        | { type: "2-string"; value: string };
      requiredIriOrLiteralProperty: rdfjs.NamedNode | rdfjs.Literal;
      requiredIriOrStringProperty: rdfjs.NamedNode | string;
      setClassOrClassOrStringProperty: readonly (
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
        | { type: "2-string"; value: string }
      )[];
      setIriOrLiteralProperty: readonly (rdfjs.NamedNode | rdfjs.Literal)[];
      setIriOrStringProperty: readonly (rdfjs.NamedNode | string)[];
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const optionalClassOrClassOrStringProperty = purify.Maybe.fromNullable(
      $jsonObject["optionalClassOrClassOrStringProperty"],
    ).map((item) =>
      item.type === "2-string"
        ? { type: "2-string" as const, value: item.value }
        : item.type === "1-ClassUnionMember2"
          ? {
              type: "1-ClassUnionMember2" as const,
              value: ClassUnionMember2.$fromJson(item.value).unsafeCoerce(),
            }
          : {
              type: "0-ClassUnionMember1" as const,
              value: ClassUnionMember1.$fromJson(item.value).unsafeCoerce(),
            },
    );
    const optionalIriOrLiteralProperty = purify.Maybe.fromNullable(
      $jsonObject["optionalIriOrLiteralProperty"],
    ).map((item) =>
      item.termType === "Literal"
        ? dataFactory.literal(
            item["@value"],
            typeof item["@language"] !== "undefined"
              ? item["@language"]
              : typeof item["@type"] !== "undefined"
                ? dataFactory.namedNode(item["@type"])
                : undefined,
          )
        : dataFactory.namedNode(item["@id"]),
    );
    const optionalIriOrStringProperty = purify.Maybe.fromNullable(
      $jsonObject["optionalIriOrStringProperty"],
    ).map((item) =>
      typeof item === "string" ? item : dataFactory.namedNode(item["@id"]),
    );
    const requiredClassOrClassOrStringProperty =
      $jsonObject["requiredClassOrClassOrStringProperty"].type === "2-string"
        ? {
            type: "2-string" as const,
            value: $jsonObject["requiredClassOrClassOrStringProperty"].value,
          }
        : $jsonObject["requiredClassOrClassOrStringProperty"].type ===
            "1-ClassUnionMember2"
          ? {
              type: "1-ClassUnionMember2" as const,
              value: ClassUnionMember2.$fromJson(
                $jsonObject["requiredClassOrClassOrStringProperty"].value,
              ).unsafeCoerce(),
            }
          : {
              type: "0-ClassUnionMember1" as const,
              value: ClassUnionMember1.$fromJson(
                $jsonObject["requiredClassOrClassOrStringProperty"].value,
              ).unsafeCoerce(),
            };
    const requiredIriOrLiteralProperty =
      $jsonObject["requiredIriOrLiteralProperty"].termType === "Literal"
        ? dataFactory.literal(
            $jsonObject["requiredIriOrLiteralProperty"]["@value"],
            typeof $jsonObject["requiredIriOrLiteralProperty"]["@language"] !==
              "undefined"
              ? $jsonObject["requiredIriOrLiteralProperty"]["@language"]
              : typeof $jsonObject["requiredIriOrLiteralProperty"]["@type"] !==
                  "undefined"
                ? dataFactory.namedNode(
                    $jsonObject["requiredIriOrLiteralProperty"]["@type"],
                  )
                : undefined,
          )
        : dataFactory.namedNode(
            $jsonObject["requiredIriOrLiteralProperty"]["@id"],
          );
    const requiredIriOrStringProperty =
      typeof $jsonObject["requiredIriOrStringProperty"] === "string"
        ? $jsonObject["requiredIriOrStringProperty"]
        : dataFactory.namedNode(
            $jsonObject["requiredIriOrStringProperty"]["@id"],
          );
    const setClassOrClassOrStringProperty = $jsonObject[
      "setClassOrClassOrStringProperty"
    ].map((item) =>
      item.type === "2-string"
        ? { type: "2-string" as const, value: item.value }
        : item.type === "1-ClassUnionMember2"
          ? {
              type: "1-ClassUnionMember2" as const,
              value: ClassUnionMember2.$fromJson(item.value).unsafeCoerce(),
            }
          : {
              type: "0-ClassUnionMember1" as const,
              value: ClassUnionMember1.$fromJson(item.value).unsafeCoerce(),
            },
    );
    const setIriOrLiteralProperty = $jsonObject["setIriOrLiteralProperty"].map(
      (item) =>
        item.termType === "Literal"
          ? dataFactory.literal(
              item["@value"],
              typeof item["@language"] !== "undefined"
                ? item["@language"]
                : typeof item["@type"] !== "undefined"
                  ? dataFactory.namedNode(item["@type"])
                  : undefined,
            )
          : dataFactory.namedNode(item["@id"]),
    );
    const setIriOrStringProperty = $jsonObject["setIriOrStringProperty"].map(
      (item) =>
        typeof item === "string" ? item : dataFactory.namedNode(item["@id"]),
    );
    return purify.Either.of({
      $identifier,
      optionalClassOrClassOrStringProperty,
      optionalIriOrLiteralProperty,
      optionalIriOrStringProperty,
      requiredClassOrClassOrStringProperty,
      requiredIriOrLiteralProperty,
      requiredIriOrStringProperty,
      setClassOrClassOrStringProperty,
      setIriOrLiteralProperty,
      setIriOrStringProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      optionalClassOrClassOrStringProperty: purify.Maybe<
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
        | { type: "2-string"; value: string }
      >;
      optionalIriOrLiteralProperty: purify.Maybe<
        rdfjs.NamedNode | rdfjs.Literal
      >;
      optionalIriOrStringProperty: purify.Maybe<rdfjs.NamedNode | string>;
      requiredClassOrClassOrStringProperty:
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
        | { type: "2-string"; value: string };
      requiredIriOrLiteralProperty: rdfjs.NamedNode | rdfjs.Literal;
      requiredIriOrStringProperty: rdfjs.NamedNode | string;
      setClassOrClassOrStringProperty: readonly (
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
        | { type: "2-string"; value: string }
      )[];
      setIriOrLiteralProperty: readonly (rdfjs.NamedNode | rdfjs.Literal)[];
      setIriOrStringProperty: readonly (rdfjs.NamedNode | string)[];
    }
  > {
    const $identifier: UnionDiscriminantsClass.$Identifier =
      $parameters.resource.identifier;
    const _optionalClassOrClassOrStringPropertyEither: purify.Either<
      Error,
      purify.Maybe<
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
        | { type: "2-string"; value: string }
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.optionalClassOrClassOrStringProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) => {
          const valueAsValues = purify.Either.of(value.toValues());
          return (
            valueAsValues
              .chain((values) =>
                values.chainMap((value) =>
                  value.toResource().chain((resource) =>
                    ClassUnionMember1.$fromRdf(resource, {
                      context: $parameters.context,
                      objectSet: $parameters.objectSet,
                      preferredLanguages: $parameters.preferredLanguages,
                    }),
                  ),
                ),
              )
              .map((values) =>
                values.map(
                  (value) =>
                    ({ type: "0-ClassUnionMember1" as const, value }) as
                      | {
                          type: "0-ClassUnionMember1";
                          value: ClassUnionMember1;
                        }
                      | {
                          type: "1-ClassUnionMember2";
                          value: ClassUnionMember2;
                        }
                      | { type: "2-string"; value: string },
                ),
              ) as purify.Either<
              Error,
              rdfjsResource.Resource.Values<
                | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
                | { type: "2-string"; value: string }
              >
            >
          )
            .altLazy(
              () =>
                valueAsValues
                  .chain((values) =>
                    values.chainMap((value) =>
                      value.toResource().chain((resource) =>
                        ClassUnionMember2.$fromRdf(resource, {
                          context: $parameters.context,
                          objectSet: $parameters.objectSet,
                          preferredLanguages: $parameters.preferredLanguages,
                        }),
                      ),
                    ),
                  )
                  .map((values) =>
                    values.map(
                      (value) =>
                        ({ type: "1-ClassUnionMember2" as const, value }) as
                          | {
                              type: "0-ClassUnionMember1";
                              value: ClassUnionMember1;
                            }
                          | {
                              type: "1-ClassUnionMember2";
                              value: ClassUnionMember2;
                            }
                          | { type: "2-string"; value: string },
                    ),
                  ) as purify.Either<
                  Error,
                  rdfjsResource.Resource.Values<
                    | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                    | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
                    | { type: "2-string"; value: string }
                  >
                >,
            )
            .altLazy(
              () =>
                valueAsValues
                  .chain((values) =>
                    $fromRdfPreferredLanguages({
                      focusResource: $parameters.resource,
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .optionalClassOrClassOrStringProperty["identifier"],
                      preferredLanguages: $parameters.preferredLanguages,
                      values,
                    }),
                  )
                  .chain((values) =>
                    values.chainMap((value) => value.toString()),
                  )
                  .map((values) =>
                    values.map(
                      (value) =>
                        ({ type: "2-string" as const, value }) as
                          | {
                              type: "0-ClassUnionMember1";
                              value: ClassUnionMember1;
                            }
                          | {
                              type: "1-ClassUnionMember2";
                              value: ClassUnionMember2;
                            }
                          | { type: "2-string"; value: string },
                    ),
                  ) as purify.Either<
                  Error,
                  rdfjsResource.Resource.Values<
                    | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                    | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
                    | { type: "2-string"; value: string }
                  >
                >,
            )
            .chain((values) => values.head());
        }),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<
                | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
                | { type: "2-string"; value: string }
              >
            >({
              focusResource: $parameters.resource,
              predicate:
                UnionDiscriminantsClass.$properties
                  .optionalClassOrClassOrStringProperty["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_optionalClassOrClassOrStringPropertyEither.isLeft()) {
      return _optionalClassOrClassOrStringPropertyEither;
    }

    const optionalClassOrClassOrStringProperty =
      _optionalClassOrClassOrStringPropertyEither.unsafeCoerce();
    const _optionalIriOrLiteralPropertyEither: purify.Either<
      Error,
      purify.Maybe<rdfjs.NamedNode | rdfjs.Literal>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.optionalIriOrLiteralProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) => {
          const valueAsValues = purify.Either.of(value.toValues());
          return (
            valueAsValues.chain((values) =>
              values.chainMap((value) => value.toIri()),
            ) as purify.Either<
              Error,
              rdfjsResource.Resource.Values<rdfjs.NamedNode | rdfjs.Literal>
            >
          )
            .altLazy(
              () =>
                valueAsValues
                  .chain((values) =>
                    $fromRdfPreferredLanguages({
                      focusResource: $parameters.resource,
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .optionalIriOrLiteralProperty["identifier"],
                      preferredLanguages: $parameters.preferredLanguages,
                      values,
                    }),
                  )
                  .chain((values) =>
                    values.chainMap((value) => value.toLiteral()),
                  ) as purify.Either<
                  Error,
                  rdfjsResource.Resource.Values<rdfjs.NamedNode | rdfjs.Literal>
                >,
            )
            .chain((values) => values.head());
        }),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<rdfjs.NamedNode | rdfjs.Literal>
            >({
              focusResource: $parameters.resource,
              predicate:
                UnionDiscriminantsClass.$properties
                  .optionalIriOrLiteralProperty["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_optionalIriOrLiteralPropertyEither.isLeft()) {
      return _optionalIriOrLiteralPropertyEither;
    }

    const optionalIriOrLiteralProperty =
      _optionalIriOrLiteralPropertyEither.unsafeCoerce();
    const _optionalIriOrStringPropertyEither: purify.Either<
      Error,
      purify.Maybe<rdfjs.NamedNode | string>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.optionalIriOrStringProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) => {
          const valueAsValues = purify.Either.of(value.toValues());
          return (
            valueAsValues.chain((values) =>
              values.chainMap((value) => value.toIri()),
            ) as purify.Either<
              Error,
              rdfjsResource.Resource.Values<rdfjs.NamedNode | string>
            >
          )
            .altLazy(
              () =>
                valueAsValues
                  .chain((values) =>
                    $fromRdfPreferredLanguages({
                      focusResource: $parameters.resource,
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .optionalIriOrStringProperty["identifier"],
                      preferredLanguages: $parameters.preferredLanguages,
                      values,
                    }),
                  )
                  .chain((values) =>
                    values.chainMap((value) => value.toString()),
                  ) as purify.Either<
                  Error,
                  rdfjsResource.Resource.Values<rdfjs.NamedNode | string>
                >,
            )
            .chain((values) => values.head());
        }),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<rdfjs.NamedNode | string>
            >({
              focusResource: $parameters.resource,
              predicate:
                UnionDiscriminantsClass.$properties.optionalIriOrStringProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_optionalIriOrStringPropertyEither.isLeft()) {
      return _optionalIriOrStringPropertyEither;
    }

    const optionalIriOrStringProperty =
      _optionalIriOrStringPropertyEither.unsafeCoerce();
    const _requiredClassOrClassOrStringPropertyEither: purify.Either<
      Error,
      | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
      | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
      | { type: "2-string"; value: string }
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.requiredClassOrClassOrStringProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) => {
          const valueAsValues = purify.Either.of(value.toValues());
          return (
            valueAsValues
              .chain((values) =>
                values.chainMap((value) =>
                  value.toResource().chain((resource) =>
                    ClassUnionMember1.$fromRdf(resource, {
                      context: $parameters.context,
                      objectSet: $parameters.objectSet,
                      preferredLanguages: $parameters.preferredLanguages,
                    }),
                  ),
                ),
              )
              .map((values) =>
                values.map(
                  (value) =>
                    ({ type: "0-ClassUnionMember1" as const, value }) as
                      | {
                          type: "0-ClassUnionMember1";
                          value: ClassUnionMember1;
                        }
                      | {
                          type: "1-ClassUnionMember2";
                          value: ClassUnionMember2;
                        }
                      | { type: "2-string"; value: string },
                ),
              ) as purify.Either<
              Error,
              rdfjsResource.Resource.Values<
                | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
                | { type: "2-string"; value: string }
              >
            >
          )
            .altLazy(
              () =>
                valueAsValues
                  .chain((values) =>
                    values.chainMap((value) =>
                      value.toResource().chain((resource) =>
                        ClassUnionMember2.$fromRdf(resource, {
                          context: $parameters.context,
                          objectSet: $parameters.objectSet,
                          preferredLanguages: $parameters.preferredLanguages,
                        }),
                      ),
                    ),
                  )
                  .map((values) =>
                    values.map(
                      (value) =>
                        ({ type: "1-ClassUnionMember2" as const, value }) as
                          | {
                              type: "0-ClassUnionMember1";
                              value: ClassUnionMember1;
                            }
                          | {
                              type: "1-ClassUnionMember2";
                              value: ClassUnionMember2;
                            }
                          | { type: "2-string"; value: string },
                    ),
                  ) as purify.Either<
                  Error,
                  rdfjsResource.Resource.Values<
                    | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                    | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
                    | { type: "2-string"; value: string }
                  >
                >,
            )
            .altLazy(
              () =>
                valueAsValues
                  .chain((values) =>
                    $fromRdfPreferredLanguages({
                      focusResource: $parameters.resource,
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .requiredClassOrClassOrStringProperty["identifier"],
                      preferredLanguages: $parameters.preferredLanguages,
                      values,
                    }),
                  )
                  .chain((values) =>
                    values.chainMap((value) => value.toString()),
                  )
                  .map((values) =>
                    values.map(
                      (value) =>
                        ({ type: "2-string" as const, value }) as
                          | {
                              type: "0-ClassUnionMember1";
                              value: ClassUnionMember1;
                            }
                          | {
                              type: "1-ClassUnionMember2";
                              value: ClassUnionMember2;
                            }
                          | { type: "2-string"; value: string },
                    ),
                  ) as purify.Either<
                  Error,
                  rdfjsResource.Resource.Values<
                    | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                    | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
                    | { type: "2-string"; value: string }
                  >
                >,
            )
            .chain((values) => values.head());
        }),
      )
      .chain((values) => values.head());
    if (_requiredClassOrClassOrStringPropertyEither.isLeft()) {
      return _requiredClassOrClassOrStringPropertyEither;
    }

    const requiredClassOrClassOrStringProperty =
      _requiredClassOrClassOrStringPropertyEither.unsafeCoerce();
    const _requiredIriOrLiteralPropertyEither: purify.Either<
      Error,
      rdfjs.NamedNode | rdfjs.Literal
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.requiredIriOrLiteralProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) => {
          const valueAsValues = purify.Either.of(value.toValues());
          return (
            valueAsValues.chain((values) =>
              values.chainMap((value) => value.toIri()),
            ) as purify.Either<
              Error,
              rdfjsResource.Resource.Values<rdfjs.NamedNode | rdfjs.Literal>
            >
          )
            .altLazy(
              () =>
                valueAsValues
                  .chain((values) =>
                    $fromRdfPreferredLanguages({
                      focusResource: $parameters.resource,
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .requiredIriOrLiteralProperty["identifier"],
                      preferredLanguages: $parameters.preferredLanguages,
                      values,
                    }),
                  )
                  .chain((values) =>
                    values.chainMap((value) => value.toLiteral()),
                  ) as purify.Either<
                  Error,
                  rdfjsResource.Resource.Values<rdfjs.NamedNode | rdfjs.Literal>
                >,
            )
            .chain((values) => values.head());
        }),
      )
      .chain((values) => values.head());
    if (_requiredIriOrLiteralPropertyEither.isLeft()) {
      return _requiredIriOrLiteralPropertyEither;
    }

    const requiredIriOrLiteralProperty =
      _requiredIriOrLiteralPropertyEither.unsafeCoerce();
    const _requiredIriOrStringPropertyEither: purify.Either<
      Error,
      rdfjs.NamedNode | string
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.requiredIriOrStringProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) => {
          const valueAsValues = purify.Either.of(value.toValues());
          return (
            valueAsValues.chain((values) =>
              values.chainMap((value) => value.toIri()),
            ) as purify.Either<
              Error,
              rdfjsResource.Resource.Values<rdfjs.NamedNode | string>
            >
          )
            .altLazy(
              () =>
                valueAsValues
                  .chain((values) =>
                    $fromRdfPreferredLanguages({
                      focusResource: $parameters.resource,
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .requiredIriOrStringProperty["identifier"],
                      preferredLanguages: $parameters.preferredLanguages,
                      values,
                    }),
                  )
                  .chain((values) =>
                    values.chainMap((value) => value.toString()),
                  ) as purify.Either<
                  Error,
                  rdfjsResource.Resource.Values<rdfjs.NamedNode | string>
                >,
            )
            .chain((values) => values.head());
        }),
      )
      .chain((values) => values.head());
    if (_requiredIriOrStringPropertyEither.isLeft()) {
      return _requiredIriOrStringPropertyEither;
    }

    const requiredIriOrStringProperty =
      _requiredIriOrStringPropertyEither.unsafeCoerce();
    const _setClassOrClassOrStringPropertyEither: purify.Either<
      Error,
      readonly (
        | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
        | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
        | { type: "2-string"; value: string }
      )[]
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.setClassOrClassOrStringProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) => {
          const valueAsValues = purify.Either.of(value.toValues());
          return (
            valueAsValues
              .chain((values) =>
                values.chainMap((value) =>
                  value.toResource().chain((resource) =>
                    ClassUnionMember1.$fromRdf(resource, {
                      context: $parameters.context,
                      objectSet: $parameters.objectSet,
                      preferredLanguages: $parameters.preferredLanguages,
                    }),
                  ),
                ),
              )
              .map((values) =>
                values.map(
                  (value) =>
                    ({ type: "0-ClassUnionMember1" as const, value }) as
                      | {
                          type: "0-ClassUnionMember1";
                          value: ClassUnionMember1;
                        }
                      | {
                          type: "1-ClassUnionMember2";
                          value: ClassUnionMember2;
                        }
                      | { type: "2-string"; value: string },
                ),
              ) as purify.Either<
              Error,
              rdfjsResource.Resource.Values<
                | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
                | { type: "2-string"; value: string }
              >
            >
          )
            .altLazy(
              () =>
                valueAsValues
                  .chain((values) =>
                    values.chainMap((value) =>
                      value.toResource().chain((resource) =>
                        ClassUnionMember2.$fromRdf(resource, {
                          context: $parameters.context,
                          objectSet: $parameters.objectSet,
                          preferredLanguages: $parameters.preferredLanguages,
                        }),
                      ),
                    ),
                  )
                  .map((values) =>
                    values.map(
                      (value) =>
                        ({ type: "1-ClassUnionMember2" as const, value }) as
                          | {
                              type: "0-ClassUnionMember1";
                              value: ClassUnionMember1;
                            }
                          | {
                              type: "1-ClassUnionMember2";
                              value: ClassUnionMember2;
                            }
                          | { type: "2-string"; value: string },
                    ),
                  ) as purify.Either<
                  Error,
                  rdfjsResource.Resource.Values<
                    | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                    | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
                    | { type: "2-string"; value: string }
                  >
                >,
            )
            .altLazy(
              () =>
                valueAsValues
                  .chain((values) =>
                    $fromRdfPreferredLanguages({
                      focusResource: $parameters.resource,
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .setClassOrClassOrStringProperty["identifier"],
                      preferredLanguages: $parameters.preferredLanguages,
                      values,
                    }),
                  )
                  .chain((values) =>
                    values.chainMap((value) => value.toString()),
                  )
                  .map((values) =>
                    values.map(
                      (value) =>
                        ({ type: "2-string" as const, value }) as
                          | {
                              type: "0-ClassUnionMember1";
                              value: ClassUnionMember1;
                            }
                          | {
                              type: "1-ClassUnionMember2";
                              value: ClassUnionMember2;
                            }
                          | { type: "2-string"; value: string },
                    ),
                  ) as purify.Either<
                  Error,
                  rdfjsResource.Resource.Values<
                    | { type: "0-ClassUnionMember1"; value: ClassUnionMember1 }
                    | { type: "1-ClassUnionMember2"; value: ClassUnionMember2 }
                    | { type: "2-string"; value: string }
                  >
                >,
            )
            .chain((values) => values.head());
        }),
      )
      .map((values) => values.toArray())
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          focusResource: $parameters.resource,
          predicate:
            UnionDiscriminantsClass.$properties.setClassOrClassOrStringProperty[
              "identifier"
            ],
          value: valuesArray,
        }),
      )
      .chain((values) => values.head());
    if (_setClassOrClassOrStringPropertyEither.isLeft()) {
      return _setClassOrClassOrStringPropertyEither;
    }

    const setClassOrClassOrStringProperty =
      _setClassOrClassOrStringPropertyEither.unsafeCoerce();
    const _setIriOrLiteralPropertyEither: purify.Either<
      Error,
      readonly (rdfjs.NamedNode | rdfjs.Literal)[]
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.setIriOrLiteralProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) => {
          const valueAsValues = purify.Either.of(value.toValues());
          return (
            valueAsValues.chain((values) =>
              values.chainMap((value) => value.toIri()),
            ) as purify.Either<
              Error,
              rdfjsResource.Resource.Values<rdfjs.NamedNode | rdfjs.Literal>
            >
          )
            .altLazy(
              () =>
                valueAsValues
                  .chain((values) =>
                    $fromRdfPreferredLanguages({
                      focusResource: $parameters.resource,
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .setIriOrLiteralProperty["identifier"],
                      preferredLanguages: $parameters.preferredLanguages,
                      values,
                    }),
                  )
                  .chain((values) =>
                    values.chainMap((value) => value.toLiteral()),
                  ) as purify.Either<
                  Error,
                  rdfjsResource.Resource.Values<rdfjs.NamedNode | rdfjs.Literal>
                >,
            )
            .chain((values) => values.head());
        }),
      )
      .map((values) => values.toArray())
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          focusResource: $parameters.resource,
          predicate:
            UnionDiscriminantsClass.$properties.setIriOrLiteralProperty[
              "identifier"
            ],
          value: valuesArray,
        }),
      )
      .chain((values) => values.head());
    if (_setIriOrLiteralPropertyEither.isLeft()) {
      return _setIriOrLiteralPropertyEither;
    }

    const setIriOrLiteralProperty =
      _setIriOrLiteralPropertyEither.unsafeCoerce();
    const _setIriOrStringPropertyEither: purify.Either<
      Error,
      readonly (rdfjs.NamedNode | string)[]
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.setIriOrStringProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) => {
          const valueAsValues = purify.Either.of(value.toValues());
          return (
            valueAsValues.chain((values) =>
              values.chainMap((value) => value.toIri()),
            ) as purify.Either<
              Error,
              rdfjsResource.Resource.Values<rdfjs.NamedNode | string>
            >
          )
            .altLazy(
              () =>
                valueAsValues
                  .chain((values) =>
                    $fromRdfPreferredLanguages({
                      focusResource: $parameters.resource,
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .setIriOrStringProperty["identifier"],
                      preferredLanguages: $parameters.preferredLanguages,
                      values,
                    }),
                  )
                  .chain((values) =>
                    values.chainMap((value) => value.toString()),
                  ) as purify.Either<
                  Error,
                  rdfjsResource.Resource.Values<rdfjs.NamedNode | string>
                >,
            )
            .chain((values) => values.head());
        }),
      )
      .map((values) => values.toArray())
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          focusResource: $parameters.resource,
          predicate:
            UnionDiscriminantsClass.$properties.setIriOrStringProperty[
              "identifier"
            ],
          value: valuesArray,
        }),
      )
      .chain((values) => values.head());
    if (_setIriOrStringPropertyEither.isLeft()) {
      return _setIriOrStringPropertyEither;
    }

    const setIriOrStringProperty = _setIriOrStringPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      optionalClassOrClassOrStringProperty,
      optionalIriOrLiteralProperty,
      optionalIriOrStringProperty,
      requiredClassOrClassOrStringProperty,
      requiredIriOrLiteralProperty,
      requiredIriOrStringProperty,
      setClassOrClassOrStringProperty,
      setIriOrLiteralProperty,
      setIriOrStringProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: UnionDiscriminantsClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        UnionDiscriminantsClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            UnionDiscriminantsClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: UnionDiscriminantsClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      UnionDiscriminantsClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("unionDiscriminantsClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
      ),
      predicate:
        UnionDiscriminantsClass.$properties
          .optionalClassOrClassOrStringProperty["identifier"],
      subject,
    });
    triples.push(
      ...ClassUnionMember1.$sparqlConstructTriples({
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
      }),
    );
    triples.push(
      ...ClassUnionMember2.$sparqlConstructTriples({
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrLiteralProperty`,
      ),
      predicate:
        UnionDiscriminantsClass.$properties.optionalIriOrLiteralProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrStringProperty`,
      ),
      predicate:
        UnionDiscriminantsClass.$properties.optionalIriOrStringProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
      ),
      predicate:
        UnionDiscriminantsClass.$properties
          .requiredClassOrClassOrStringProperty["identifier"],
      subject,
    });
    triples.push(
      ...ClassUnionMember1.$sparqlConstructTriples({
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
      }),
    );
    triples.push(
      ...ClassUnionMember2.$sparqlConstructTriples({
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrLiteralProperty`,
      ),
      predicate:
        UnionDiscriminantsClass.$properties.requiredIriOrLiteralProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrStringProperty`,
      ),
      predicate:
        UnionDiscriminantsClass.$properties.requiredIriOrStringProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
      ),
      predicate:
        UnionDiscriminantsClass.$properties.setClassOrClassOrStringProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...ClassUnionMember1.$sparqlConstructTriples({
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
      }),
    );
    triples.push(
      ...ClassUnionMember2.$sparqlConstructTriples({
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrLiteralProperty`,
      ),
      predicate:
        UnionDiscriminantsClass.$properties.setIriOrLiteralProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrStringProperty`,
      ),
      predicate:
        UnionDiscriminantsClass.$properties.setIriOrStringProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: UnionDiscriminantsClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("unionDiscriminantsClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalClassOrClassOrStringProperty,
          (itemFilter) => [
            {
              patterns: [
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
                          ),
                          predicate:
                            UnionDiscriminantsClass.$properties
                              .optionalClassOrClassOrStringProperty[
                              "identifier"
                            ],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: ClassUnionMember1.$sparqlWherePatterns({
                        filter: itemFilter?.on?.["0-ClassUnionMember1"],
                        preferredLanguages: parameters?.preferredLanguages,
                        subject: dataFactory.variable!(
                          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
                        ),
                        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
                      }).concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
                          ),
                          predicate:
                            UnionDiscriminantsClass.$properties
                              .optionalClassOrClassOrStringProperty[
                              "identifier"
                            ],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: ClassUnionMember2.$sparqlWherePatterns({
                        filter: itemFilter?.on?.["1-ClassUnionMember2"],
                        preferredLanguages: parameters?.preferredLanguages,
                        subject: dataFactory.variable!(
                          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
                        ),
                        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
                      }).concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
                          ),
                          predicate:
                            UnionDiscriminantsClass.$properties
                              .optionalClassOrClassOrStringProperty[
                              "identifier"
                            ],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: [parameters?.preferredLanguages ?? []]
                        .filter((languages) => languages.length > 0)
                        .map((languages) =>
                          languages.map((language) => ({
                            type: "operation" as const,
                            operator: "=",
                            args: [
                              {
                                type: "operation" as const,
                                operator: "lang",
                                args: [
                                  dataFactory.variable!(
                                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
                                  ),
                                ],
                              },
                              dataFactory.literal(language),
                            ],
                          })),
                        )
                        .map((langEqualsExpressions) => ({
                          type: "filter" as const,
                          expression: langEqualsExpressions.reduce(
                            (reducedExpression, langEqualsExpression) => {
                              if (reducedExpression === null) {
                                return langEqualsExpression;
                              }
                              return {
                                type: "operation" as const,
                                operator: "||",
                                args: [reducedExpression, langEqualsExpression],
                              };
                            },
                            null as sparqljs.Expression | null,
                          ) as sparqljs.Expression,
                        }))
                        .concat(),
                      type: "group",
                    },
                    {
                      patterns: $StringFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["2-string"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalClassOrClassOrStringProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
              ],
              type: "union",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalIriOrLiteralProperty,
          (itemFilter) => [
            {
              patterns: [
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrLiteralProperty`,
                          ),
                          predicate:
                            UnionDiscriminantsClass.$properties
                              .optionalIriOrLiteralProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: $NamedNodeFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["NamedNode"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrLiteralProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrLiteralProperty`,
                          ),
                          predicate:
                            UnionDiscriminantsClass.$properties
                              .optionalIriOrLiteralProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: [parameters?.preferredLanguages ?? []]
                        .filter((languages) => languages.length > 0)
                        .map((languages) =>
                          languages.map((language) => ({
                            type: "operation" as const,
                            operator: "=",
                            args: [
                              {
                                type: "operation" as const,
                                operator: "lang",
                                args: [
                                  dataFactory.variable!(
                                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrLiteralProperty`,
                                  ),
                                ],
                              },
                              dataFactory.literal(language),
                            ],
                          })),
                        )
                        .map((langEqualsExpressions) => ({
                          type: "filter" as const,
                          expression: langEqualsExpressions.reduce(
                            (reducedExpression, langEqualsExpression) => {
                              if (reducedExpression === null) {
                                return langEqualsExpression;
                              }
                              return {
                                type: "operation" as const,
                                operator: "||",
                                args: [reducedExpression, langEqualsExpression],
                              };
                            },
                            null as sparqljs.Expression | null,
                          ) as sparqljs.Expression,
                        }))
                        .concat(),
                      type: "group",
                    },
                    {
                      patterns: $LiteralFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["Literal"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrLiteralProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
              ],
              type: "union",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalIriOrStringProperty,
          (itemFilter) => [
            {
              patterns: [
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrStringProperty`,
                          ),
                          predicate:
                            UnionDiscriminantsClass.$properties
                              .optionalIriOrStringProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: $NamedNodeFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["object"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrStringProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrStringProperty`,
                          ),
                          predicate:
                            UnionDiscriminantsClass.$properties
                              .optionalIriOrStringProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: [parameters?.preferredLanguages ?? []]
                        .filter((languages) => languages.length > 0)
                        .map((languages) =>
                          languages.map((language) => ({
                            type: "operation" as const,
                            operator: "=",
                            args: [
                              {
                                type: "operation" as const,
                                operator: "lang",
                                args: [
                                  dataFactory.variable!(
                                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrStringProperty`,
                                  ),
                                ],
                              },
                              dataFactory.literal(language),
                            ],
                          })),
                        )
                        .map((langEqualsExpressions) => ({
                          type: "filter" as const,
                          expression: langEqualsExpressions.reduce(
                            (reducedExpression, langEqualsExpression) => {
                              if (reducedExpression === null) {
                                return langEqualsExpression;
                              }
                              return {
                                type: "operation" as const,
                                operator: "||",
                                args: [reducedExpression, langEqualsExpression],
                              };
                            },
                            null as sparqljs.Expression | null,
                          ) as sparqljs.Expression,
                        }))
                        .concat(),
                      type: "group",
                    },
                    {
                      patterns: $StringFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["string"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}OptionalIriOrStringProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
              ],
              type: "union",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: [
        {
          patterns: [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
                  ),
                  predicate:
                    UnionDiscriminantsClass.$properties
                      .requiredClassOrClassOrStringProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: ClassUnionMember1.$sparqlWherePatterns({
                filter:
                  parameters?.filter?.requiredClassOrClassOrStringProperty
                    ?.on?.["0-ClassUnionMember1"],
                preferredLanguages: parameters?.preferredLanguages,
                subject: dataFactory.variable!(
                  `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
                ),
                variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
              }).concat(),
              type: "group",
            },
          ],
          type: "group",
        },
        {
          patterns: [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
                  ),
                  predicate:
                    UnionDiscriminantsClass.$properties
                      .requiredClassOrClassOrStringProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: ClassUnionMember2.$sparqlWherePatterns({
                filter:
                  parameters?.filter?.requiredClassOrClassOrStringProperty
                    ?.on?.["1-ClassUnionMember2"],
                preferredLanguages: parameters?.preferredLanguages,
                subject: dataFactory.variable!(
                  `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
                ),
                variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
              }).concat(),
              type: "group",
            },
          ],
          type: "group",
        },
        {
          patterns: [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
                  ),
                  predicate:
                    UnionDiscriminantsClass.$properties
                      .requiredClassOrClassOrStringProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [parameters?.preferredLanguages ?? []]
                .filter((languages) => languages.length > 0)
                .map((languages) =>
                  languages.map((language) => ({
                    type: "operation" as const,
                    operator: "=",
                    args: [
                      {
                        type: "operation" as const,
                        operator: "lang",
                        args: [
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
                          ),
                        ],
                      },
                      dataFactory.literal(language),
                    ],
                  })),
                )
                .map((langEqualsExpressions) => ({
                  type: "filter" as const,
                  expression: langEqualsExpressions.reduce(
                    (reducedExpression, langEqualsExpression) => {
                      if (reducedExpression === null) {
                        return langEqualsExpression;
                      }
                      return {
                        type: "operation" as const,
                        operator: "||",
                        args: [reducedExpression, langEqualsExpression],
                      };
                    },
                    null as sparqljs.Expression | null,
                  ) as sparqljs.Expression,
                }))
                .concat(),
              type: "group",
            },
            {
              patterns: $StringFilter
                .$sparqlWherePatterns(
                  parameters?.filter?.requiredClassOrClassOrStringProperty
                    ?.on?.["2-string"],
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredClassOrClassOrStringProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
          type: "group",
        },
      ],
      type: "union",
    });
    patterns.push({
      patterns: [
        {
          patterns: [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrLiteralProperty`,
                  ),
                  predicate:
                    UnionDiscriminantsClass.$properties
                      .requiredIriOrLiteralProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $NamedNodeFilter
                .$sparqlWherePatterns(
                  parameters?.filter?.requiredIriOrLiteralProperty?.on?.[
                    "NamedNode"
                  ],
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrLiteralProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
          type: "group",
        },
        {
          patterns: [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrLiteralProperty`,
                  ),
                  predicate:
                    UnionDiscriminantsClass.$properties
                      .requiredIriOrLiteralProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [parameters?.preferredLanguages ?? []]
                .filter((languages) => languages.length > 0)
                .map((languages) =>
                  languages.map((language) => ({
                    type: "operation" as const,
                    operator: "=",
                    args: [
                      {
                        type: "operation" as const,
                        operator: "lang",
                        args: [
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrLiteralProperty`,
                          ),
                        ],
                      },
                      dataFactory.literal(language),
                    ],
                  })),
                )
                .map((langEqualsExpressions) => ({
                  type: "filter" as const,
                  expression: langEqualsExpressions.reduce(
                    (reducedExpression, langEqualsExpression) => {
                      if (reducedExpression === null) {
                        return langEqualsExpression;
                      }
                      return {
                        type: "operation" as const,
                        operator: "||",
                        args: [reducedExpression, langEqualsExpression],
                      };
                    },
                    null as sparqljs.Expression | null,
                  ) as sparqljs.Expression,
                }))
                .concat(),
              type: "group",
            },
            {
              patterns: $LiteralFilter
                .$sparqlWherePatterns(
                  parameters?.filter?.requiredIriOrLiteralProperty?.on?.[
                    "Literal"
                  ],
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrLiteralProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
          type: "group",
        },
      ],
      type: "union",
    });
    patterns.push({
      patterns: [
        {
          patterns: [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrStringProperty`,
                  ),
                  predicate:
                    UnionDiscriminantsClass.$properties
                      .requiredIriOrStringProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $NamedNodeFilter
                .$sparqlWherePatterns(
                  parameters?.filter?.requiredIriOrStringProperty?.on?.[
                    "object"
                  ],
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrStringProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
          type: "group",
        },
        {
          patterns: [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrStringProperty`,
                  ),
                  predicate:
                    UnionDiscriminantsClass.$properties
                      .requiredIriOrStringProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [parameters?.preferredLanguages ?? []]
                .filter((languages) => languages.length > 0)
                .map((languages) =>
                  languages.map((language) => ({
                    type: "operation" as const,
                    operator: "=",
                    args: [
                      {
                        type: "operation" as const,
                        operator: "lang",
                        args: [
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrStringProperty`,
                          ),
                        ],
                      },
                      dataFactory.literal(language),
                    ],
                  })),
                )
                .map((langEqualsExpressions) => ({
                  type: "filter" as const,
                  expression: langEqualsExpressions.reduce(
                    (reducedExpression, langEqualsExpression) => {
                      if (reducedExpression === null) {
                        return langEqualsExpression;
                      }
                      return {
                        type: "operation" as const,
                        operator: "||",
                        args: [reducedExpression, langEqualsExpression],
                      };
                    },
                    null as sparqljs.Expression | null,
                  ) as sparqljs.Expression,
                }))
                .concat(),
              type: "group",
            },
            {
              patterns: $StringFilter
                .$sparqlWherePatterns(
                  parameters?.filter?.requiredIriOrStringProperty?.on?.[
                    "string"
                  ],
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}RequiredIriOrStringProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
          type: "group",
        },
      ],
      type: "union",
    });
    patterns.push({
      patterns: [
        {
          patterns: [
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
                      ),
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .setClassOrClassOrStringProperty["identifier"],
                      subject: subject,
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: ClassUnionMember1.$sparqlWherePatterns({
                    filter:
                      parameters?.filter?.setClassOrClassOrStringProperty?.on?.[
                        "0-ClassUnionMember1"
                      ],
                    preferredLanguages: parameters?.preferredLanguages,
                    subject: dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
                    ),
                    variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
                  }).concat(),
                  type: "group",
                },
              ],
              type: "group",
            },
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
                      ),
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .setClassOrClassOrStringProperty["identifier"],
                      subject: subject,
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: ClassUnionMember2.$sparqlWherePatterns({
                    filter:
                      parameters?.filter?.setClassOrClassOrStringProperty?.on?.[
                        "1-ClassUnionMember2"
                      ],
                    preferredLanguages: parameters?.preferredLanguages,
                    subject: dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
                    ),
                    variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
                  }).concat(),
                  type: "group",
                },
              ],
              type: "group",
            },
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
                      ),
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .setClassOrClassOrStringProperty["identifier"],
                      subject: subject,
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: [parameters?.preferredLanguages ?? []]
                    .filter((languages) => languages.length > 0)
                    .map((languages) =>
                      languages.map((language) => ({
                        type: "operation" as const,
                        operator: "=",
                        args: [
                          {
                            type: "operation" as const,
                            operator: "lang",
                            args: [
                              dataFactory.variable!(
                                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
                              ),
                            ],
                          },
                          dataFactory.literal(language),
                        ],
                      })),
                    )
                    .map((langEqualsExpressions) => ({
                      type: "filter" as const,
                      expression: langEqualsExpressions.reduce(
                        (reducedExpression, langEqualsExpression) => {
                          if (reducedExpression === null) {
                            return langEqualsExpression;
                          }
                          return {
                            type: "operation" as const,
                            operator: "||",
                            args: [reducedExpression, langEqualsExpression],
                          };
                        },
                        null as sparqljs.Expression | null,
                      ) as sparqljs.Expression,
                    }))
                    .concat(),
                  type: "group",
                },
                {
                  patterns: $StringFilter
                    .$sparqlWherePatterns(
                      parameters?.filter?.setClassOrClassOrStringProperty?.on?.[
                        "2-string"
                      ],
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetClassOrClassOrStringProperty`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
              ],
              type: "group",
            },
          ],
          type: "union",
        },
      ],
      type: "optional",
    });
    patterns.push({
      patterns: [
        {
          patterns: [
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrLiteralProperty`,
                      ),
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .setIriOrLiteralProperty["identifier"],
                      subject: subject,
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: $NamedNodeFilter
                    .$sparqlWherePatterns(
                      parameters?.filter?.setIriOrLiteralProperty?.on?.[
                        "NamedNode"
                      ],
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrLiteralProperty`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
              ],
              type: "group",
            },
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrLiteralProperty`,
                      ),
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .setIriOrLiteralProperty["identifier"],
                      subject: subject,
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: [parameters?.preferredLanguages ?? []]
                    .filter((languages) => languages.length > 0)
                    .map((languages) =>
                      languages.map((language) => ({
                        type: "operation" as const,
                        operator: "=",
                        args: [
                          {
                            type: "operation" as const,
                            operator: "lang",
                            args: [
                              dataFactory.variable!(
                                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrLiteralProperty`,
                              ),
                            ],
                          },
                          dataFactory.literal(language),
                        ],
                      })),
                    )
                    .map((langEqualsExpressions) => ({
                      type: "filter" as const,
                      expression: langEqualsExpressions.reduce(
                        (reducedExpression, langEqualsExpression) => {
                          if (reducedExpression === null) {
                            return langEqualsExpression;
                          }
                          return {
                            type: "operation" as const,
                            operator: "||",
                            args: [reducedExpression, langEqualsExpression],
                          };
                        },
                        null as sparqljs.Expression | null,
                      ) as sparqljs.Expression,
                    }))
                    .concat(),
                  type: "group",
                },
                {
                  patterns: $LiteralFilter
                    .$sparqlWherePatterns(
                      parameters?.filter?.setIriOrLiteralProperty?.on?.[
                        "Literal"
                      ],
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrLiteralProperty`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
              ],
              type: "group",
            },
          ],
          type: "union",
        },
      ],
      type: "optional",
    });
    patterns.push({
      patterns: [
        {
          patterns: [
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrStringProperty`,
                      ),
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .setIriOrStringProperty["identifier"],
                      subject: subject,
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: $NamedNodeFilter
                    .$sparqlWherePatterns(
                      parameters?.filter?.setIriOrStringProperty?.on?.[
                        "object"
                      ],
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrStringProperty`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
              ],
              type: "group",
            },
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrStringProperty`,
                      ),
                      predicate:
                        UnionDiscriminantsClass.$properties
                          .setIriOrStringProperty["identifier"],
                      subject: subject,
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: [parameters?.preferredLanguages ?? []]
                    .filter((languages) => languages.length > 0)
                    .map((languages) =>
                      languages.map((language) => ({
                        type: "operation" as const,
                        operator: "=",
                        args: [
                          {
                            type: "operation" as const,
                            operator: "lang",
                            args: [
                              dataFactory.variable!(
                                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrStringProperty`,
                              ),
                            ],
                          },
                          dataFactory.literal(language),
                        ],
                      })),
                    )
                    .map((langEqualsExpressions) => ({
                      type: "filter" as const,
                      expression: langEqualsExpressions.reduce(
                        (reducedExpression, langEqualsExpression) => {
                          if (reducedExpression === null) {
                            return langEqualsExpression;
                          }
                          return {
                            type: "operation" as const,
                            operator: "||",
                            args: [reducedExpression, langEqualsExpression],
                          };
                        },
                        null as sparqljs.Expression | null,
                      ) as sparqljs.Expression,
                    }))
                    .concat(),
                  type: "group",
                },
                {
                  patterns: $StringFilter
                    .$sparqlWherePatterns(
                      parameters?.filter?.setIriOrStringProperty?.on?.[
                        "string"
                      ],
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unionDiscriminantsClass")}SetIriOrStringProperty`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
              ],
              type: "group",
            },
          ],
          type: "union",
        },
      ],
      type: "optional",
    });
    return patterns;
  }
}
/**
 * Shape with properties that are not nested objects
 */
export class TermPropertiesClass {
  private _$identifier?: TermPropertiesClass.$Identifier;
  readonly $type = "TermPropertiesClass";
  readonly blankNodeTermProperty: purify.Maybe<rdfjs.BlankNode>;
  readonly booleanTermProperty: purify.Maybe<boolean>;
  readonly dateTermProperty: purify.Maybe<Date>;
  readonly dateTimeTermProperty: purify.Maybe<Date>;
  readonly iriTermProperty: purify.Maybe<rdfjs.NamedNode>;
  readonly literalTermProperty: purify.Maybe<rdfjs.Literal>;
  readonly numberTermProperty: purify.Maybe<number>;
  readonly stringTermProperty: purify.Maybe<string>;
  readonly termProperty: purify.Maybe<
    rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
  >;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly blankNodeTermProperty?:
      | rdfjs.BlankNode
      | purify.Maybe<rdfjs.BlankNode>;
    readonly booleanTermProperty?: boolean | purify.Maybe<boolean>;
    readonly dateTermProperty?: Date | purify.Maybe<Date>;
    readonly dateTimeTermProperty?: Date | purify.Maybe<Date>;
    readonly iriTermProperty?:
      | rdfjs.NamedNode
      | purify.Maybe<rdfjs.NamedNode>
      | string;
    readonly literalTermProperty?:
      | rdfjs.Literal
      | Date
      | boolean
      | number
      | purify.Maybe<rdfjs.Literal>
      | string;
    readonly numberTermProperty?: number | purify.Maybe<number>;
    readonly stringTermProperty?: purify.Maybe<string> | string;
    readonly termProperty?:
      | (rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode)
      | Date
      | boolean
      | number
      | purify.Maybe<rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode>
      | string;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.blankNodeTermProperty)) {
      this.blankNodeTermProperty = parameters?.blankNodeTermProperty;
    } else if (typeof parameters?.blankNodeTermProperty === "object") {
      this.blankNodeTermProperty = purify.Maybe.of(
        parameters?.blankNodeTermProperty,
      );
    } else if (typeof parameters?.blankNodeTermProperty === "undefined") {
      this.blankNodeTermProperty = purify.Maybe.empty();
    } else {
      this.blankNodeTermProperty =
        parameters?.blankNodeTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.booleanTermProperty)) {
      this.booleanTermProperty = parameters?.booleanTermProperty;
    } else if (typeof parameters?.booleanTermProperty === "boolean") {
      this.booleanTermProperty = purify.Maybe.of(
        parameters?.booleanTermProperty,
      );
    } else if (typeof parameters?.booleanTermProperty === "undefined") {
      this.booleanTermProperty = purify.Maybe.empty();
    } else {
      this.booleanTermProperty =
        parameters?.booleanTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.dateTermProperty)) {
      this.dateTermProperty = parameters?.dateTermProperty;
    } else if (
      typeof parameters?.dateTermProperty === "object" &&
      parameters?.dateTermProperty instanceof Date
    ) {
      this.dateTermProperty = purify.Maybe.of(parameters?.dateTermProperty);
    } else if (typeof parameters?.dateTermProperty === "undefined") {
      this.dateTermProperty = purify.Maybe.empty();
    } else {
      this.dateTermProperty = parameters?.dateTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.dateTimeTermProperty)) {
      this.dateTimeTermProperty = parameters?.dateTimeTermProperty;
    } else if (
      typeof parameters?.dateTimeTermProperty === "object" &&
      parameters?.dateTimeTermProperty instanceof Date
    ) {
      this.dateTimeTermProperty = purify.Maybe.of(
        parameters?.dateTimeTermProperty,
      );
    } else if (typeof parameters?.dateTimeTermProperty === "undefined") {
      this.dateTimeTermProperty = purify.Maybe.empty();
    } else {
      this.dateTimeTermProperty =
        parameters?.dateTimeTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.iriTermProperty)) {
      this.iriTermProperty = parameters?.iriTermProperty;
    } else if (typeof parameters?.iriTermProperty === "object") {
      this.iriTermProperty = purify.Maybe.of(parameters?.iriTermProperty);
    } else if (typeof parameters?.iriTermProperty === "string") {
      this.iriTermProperty = purify.Maybe.of(
        dataFactory.namedNode(parameters?.iriTermProperty),
      );
    } else if (typeof parameters?.iriTermProperty === "undefined") {
      this.iriTermProperty = purify.Maybe.empty();
    } else {
      this.iriTermProperty = parameters?.iriTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.literalTermProperty)) {
      this.literalTermProperty = parameters?.literalTermProperty;
    } else if (typeof parameters?.literalTermProperty === "boolean") {
      this.literalTermProperty = purify.Maybe.of(
        $toLiteral(parameters?.literalTermProperty),
      );
    } else if (
      typeof parameters?.literalTermProperty === "object" &&
      parameters?.literalTermProperty instanceof Date
    ) {
      this.literalTermProperty = purify.Maybe.of(
        $toLiteral(parameters?.literalTermProperty),
      );
    } else if (typeof parameters?.literalTermProperty === "number") {
      this.literalTermProperty = purify.Maybe.of(
        $toLiteral(parameters?.literalTermProperty),
      );
    } else if (typeof parameters?.literalTermProperty === "string") {
      this.literalTermProperty = purify.Maybe.of(
        $toLiteral(parameters?.literalTermProperty),
      );
    } else if (typeof parameters?.literalTermProperty === "object") {
      this.literalTermProperty = purify.Maybe.of(
        parameters?.literalTermProperty,
      );
    } else if (typeof parameters?.literalTermProperty === "undefined") {
      this.literalTermProperty = purify.Maybe.empty();
    } else {
      this.literalTermProperty =
        parameters?.literalTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.numberTermProperty)) {
      this.numberTermProperty = parameters?.numberTermProperty;
    } else if (typeof parameters?.numberTermProperty === "number") {
      this.numberTermProperty = purify.Maybe.of(parameters?.numberTermProperty);
    } else if (typeof parameters?.numberTermProperty === "undefined") {
      this.numberTermProperty = purify.Maybe.empty();
    } else {
      this.numberTermProperty = parameters?.numberTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.stringTermProperty)) {
      this.stringTermProperty = parameters?.stringTermProperty;
    } else if (typeof parameters?.stringTermProperty === "string") {
      this.stringTermProperty = purify.Maybe.of(parameters?.stringTermProperty);
    } else if (typeof parameters?.stringTermProperty === "undefined") {
      this.stringTermProperty = purify.Maybe.empty();
    } else {
      this.stringTermProperty = parameters?.stringTermProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.termProperty)) {
      this.termProperty = parameters?.termProperty;
    } else if (typeof parameters?.termProperty === "boolean") {
      this.termProperty = purify.Maybe.of($toLiteral(parameters?.termProperty));
    } else if (
      typeof parameters?.termProperty === "object" &&
      parameters?.termProperty instanceof Date
    ) {
      this.termProperty = purify.Maybe.of($toLiteral(parameters?.termProperty));
    } else if (typeof parameters?.termProperty === "number") {
      this.termProperty = purify.Maybe.of($toLiteral(parameters?.termProperty));
    } else if (typeof parameters?.termProperty === "string") {
      this.termProperty = purify.Maybe.of($toLiteral(parameters?.termProperty));
    } else if (typeof parameters?.termProperty === "object") {
      this.termProperty = purify.Maybe.of(parameters?.termProperty);
    } else if (typeof parameters?.termProperty === "undefined") {
      this.termProperty = purify.Maybe.empty();
    } else {
      this.termProperty = parameters?.termProperty satisfies never;
    }
  }

  get $identifier(): TermPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: TermPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.blankNodeTermProperty,
          other.blankNodeTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "blankNodeTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.booleanTermProperty,
          other.booleanTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "booleanTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.dateTermProperty,
          other.dateTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "dateTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.dateTimeTermProperty,
          other.dateTimeTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "dateTimeTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.iriTermProperty,
          other.iriTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "iriTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.literalTermProperty,
          other.literalTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "literalTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.numberTermProperty,
          other.numberTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "numberTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.stringTermProperty,
          other.stringTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "stringTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.termProperty,
          other.termProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "termProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.blankNodeTermProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    this.booleanTermProperty.ifJust((value0) => {
      _hasher.update(value0.toString());
    });
    this.dateTermProperty.ifJust((value0) => {
      _hasher.update(value0.toISOString());
    });
    this.dateTimeTermProperty.ifJust((value0) => {
      _hasher.update(value0.toISOString());
    });
    this.iriTermProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    this.literalTermProperty.ifJust((value0) => {
      _hasher.update(value0.datatype.value);
      _hasher.update(value0.language);
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    this.numberTermProperty.ifJust((value0) => {
      _hasher.update(value0.toString());
    });
    this.stringTermProperty.ifJust((value0) => {
      _hasher.update(value0);
    });
    this.termProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    return _hasher;
  }

  $toJson(): TermPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        blankNodeTermProperty: this.blankNodeTermProperty
          .map((item) => ({ "@id": `_:${item.value}` }))
          .extract(),
        booleanTermProperty: this.booleanTermProperty
          .map((item) => item)
          .extract(),
        dateTermProperty: this.dateTermProperty
          .map((item) => item.toISOString().replace(/T.*$/, ""))
          .extract(),
        dateTimeTermProperty: this.dateTimeTermProperty
          .map((item) => item.toISOString())
          .extract(),
        iriTermProperty: this.iriTermProperty
          .map((item) => ({ "@id": item.value }))
          .extract(),
        literalTermProperty: this.literalTermProperty
          .map((item) => ({
            "@language": item.language.length > 0 ? item.language : undefined,
            "@type":
              item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? item.datatype.value
                : undefined,
            "@value": item.value,
          }))
          .extract(),
        numberTermProperty: this.numberTermProperty
          .map((item) => item)
          .extract(),
        stringTermProperty: this.stringTermProperty
          .map((item) => item)
          .extract(),
        termProperty: this.termProperty
          .map((item) =>
            item.termType === "NamedNode"
              ? { "@id": item.value, termType: "NamedNode" as const }
              : item.termType === "Literal"
                ? {
                    "@language":
                      item.language.length > 0 ? item.language : undefined,
                    "@type":
                      item.datatype.value !==
                      "http://www.w3.org/2001/XMLSchema#string"
                        ? item.datatype.value
                        : undefined,
                    "@value": item.value,
                    termType: "Literal" as const,
                  }
                : { "@id": `_:${item.value}`, termType: "BlankNode" as const },
          )
          .extract(),
      } satisfies TermPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      TermPropertiesClass.$properties.blankNodeTermProperty["identifier"],
      ...this.blankNodeTermProperty.toList(),
    );
    resource.add(
      TermPropertiesClass.$properties.booleanTermProperty["identifier"],
      ...this.booleanTermProperty.toList(),
    );
    resource.add(
      TermPropertiesClass.$properties.dateTermProperty["identifier"],
      ...this.dateTermProperty
        .toList()
        .flatMap((value) => [
          dataFactory.literal(
            value.toISOString().replace(/T.*$/, ""),
            $RdfVocabularies.xsd.date,
          ),
        ]),
    );
    resource.add(
      TermPropertiesClass.$properties.dateTimeTermProperty["identifier"],
      ...this.dateTimeTermProperty
        .toList()
        .flatMap((value) => [
          dataFactory.literal(
            value.toISOString(),
            $RdfVocabularies.xsd.dateTime,
          ),
        ]),
    );
    resource.add(
      TermPropertiesClass.$properties.iriTermProperty["identifier"],
      ...this.iriTermProperty.toList(),
    );
    resource.add(
      TermPropertiesClass.$properties.literalTermProperty["identifier"],
      ...this.literalTermProperty.toList(),
    );
    resource.add(
      TermPropertiesClass.$properties.numberTermProperty["identifier"],
      ...this.numberTermProperty
        .toList()
        .flatMap((value) => [
          dataFactory.literal(value.toString(10), $RdfVocabularies.xsd.decimal),
        ]),
    );
    resource.add(
      TermPropertiesClass.$properties.stringTermProperty["identifier"],
      ...this.stringTermProperty.toList(),
    );
    resource.add(
      TermPropertiesClass.$properties.termProperty["identifier"],
      ...this.termProperty.toList(),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace TermPropertiesClass {
  export function $filter(
    filter: TermPropertiesClass.$Filter,
    value: TermPropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.blankNodeTermProperty !== "undefined" &&
      !$filterMaybe<rdfjs.BlankNode, $BlankNodeFilter>($filterBlankNode)(
        filter.blankNodeTermProperty,
        value.blankNodeTermProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.booleanTermProperty !== "undefined" &&
      !$filterMaybe<boolean, $BooleanFilter>($filterBoolean)(
        filter.booleanTermProperty,
        value.booleanTermProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.dateTermProperty !== "undefined" &&
      !$filterMaybe<Date, $DateFilter>($filterDate)(
        filter.dateTermProperty,
        value.dateTermProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.dateTimeTermProperty !== "undefined" &&
      !$filterMaybe<Date, $DateFilter>($filterDate)(
        filter.dateTimeTermProperty,
        value.dateTimeTermProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.iriTermProperty !== "undefined" &&
      !$filterMaybe<rdfjs.NamedNode, $NamedNodeFilter>($filterNamedNode)(
        filter.iriTermProperty,
        value.iriTermProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.literalTermProperty !== "undefined" &&
      !$filterMaybe<rdfjs.Literal, $LiteralFilter>($filterLiteral)(
        filter.literalTermProperty,
        value.literalTermProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.numberTermProperty !== "undefined" &&
      !$filterMaybe<number, $NumberFilter>($filterNumber)(
        filter.numberTermProperty,
        value.numberTermProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.stringTermProperty !== "undefined" &&
      !$filterMaybe<string, $StringFilter>($filterString)(
        filter.stringTermProperty,
        value.stringTermProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.termProperty !== "undefined" &&
      !$filterMaybe<
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode,
        $TermFilter
      >($filterTerm)(filter.termProperty, value.termProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly blankNodeTermProperty?: $MaybeFilter<$BlankNodeFilter>;
    readonly booleanTermProperty?: $MaybeFilter<$BooleanFilter>;
    readonly dateTermProperty?: $MaybeFilter<$DateFilter>;
    readonly dateTimeTermProperty?: $MaybeFilter<$DateFilter>;
    readonly iriTermProperty?: $MaybeFilter<$NamedNodeFilter>;
    readonly literalTermProperty?: $MaybeFilter<$LiteralFilter>;
    readonly numberTermProperty?: $MaybeFilter<$NumberFilter>;
    readonly stringTermProperty?: $MaybeFilter<$StringFilter>;
    readonly termProperty?: $MaybeFilter<$TermFilter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, TermPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new TermPropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, TermPropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return TermPropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new TermPropertiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "TermPropertiesClass";
    readonly blankNodeTermProperty?: { readonly "@id": string };
    readonly booleanTermProperty?: boolean;
    readonly dateTermProperty?: string;
    readonly dateTimeTermProperty?: string;
    readonly iriTermProperty?: { readonly "@id": string };
    readonly literalTermProperty?: {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    };
    readonly numberTermProperty?: number;
    readonly stringTermProperty?: string;
    readonly termProperty?:
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly "@type"?: string;
          readonly "@value": string;
          readonly termType: "Literal";
        };
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "TermPropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/blankNodeTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/booleanTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateTimeTermProperty`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/iriTermProperty`, type: "Control" },
        {
          scope: `${scopePrefix}/properties/literalTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/numberTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/stringTermProperty`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/termProperty`, type: "Control" },
      ],
      label: "TermPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("TermPropertiesClass"),
      blankNodeTermProperty: zod
        .object({ "@id": zod.string().min(1) })
        .optional(),
      booleanTermProperty: zod.boolean().optional(),
      dateTermProperty: zod.iso.date().optional(),
      dateTimeTermProperty: zod.iso.datetime().optional(),
      iriTermProperty: zod.object({ "@id": zod.string().min(1) }).optional(),
      literalTermProperty: zod
        .object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
        })
        .optional(),
      numberTermProperty: zod.number().optional(),
      stringTermProperty: zod.string().optional(),
      termProperty: zod
        .discriminatedUnion("termType", [
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("BlankNode"),
          }),
          zod.object({
            "@language": zod.string().optional(),
            "@type": zod.string().optional(),
            "@value": zod.string(),
            termType: zod.literal("Literal"),
          }),
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("NamedNode"),
          }),
        ])
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    blankNodeTermProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/blankNodeTermProperty",
      ),
    },
    booleanTermProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/booleanTermProperty",
      ),
    },
    dateTermProperty: {
      identifier: dataFactory.namedNode("http://example.com/dateTermProperty"),
    },
    dateTimeTermProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/dateTimeTermProperty",
      ),
    },
    iriTermProperty: {
      identifier: dataFactory.namedNode("http://example.com/iriTermProperty"),
    },
    literalTermProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/literalTermProperty",
      ),
    },
    numberTermProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/numberTermProperty",
      ),
    },
    stringTermProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/stringTermProperty",
      ),
    },
    termProperty: {
      identifier: dataFactory.namedNode("http://example.com/termProperty"),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      blankNodeTermProperty: purify.Maybe<rdfjs.BlankNode>;
      booleanTermProperty: purify.Maybe<boolean>;
      dateTermProperty: purify.Maybe<Date>;
      dateTimeTermProperty: purify.Maybe<Date>;
      iriTermProperty: purify.Maybe<rdfjs.NamedNode>;
      literalTermProperty: purify.Maybe<rdfjs.Literal>;
      numberTermProperty: purify.Maybe<number>;
      stringTermProperty: purify.Maybe<string>;
      termProperty: purify.Maybe<
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
      >;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const blankNodeTermProperty = purify.Maybe.fromNullable(
      $jsonObject["blankNodeTermProperty"],
    ).map((item) => dataFactory.blankNode(item["@id"].substring(2)));
    const booleanTermProperty = purify.Maybe.fromNullable(
      $jsonObject["booleanTermProperty"],
    );
    const dateTermProperty = purify.Maybe.fromNullable(
      $jsonObject["dateTermProperty"],
    ).map((item) => new Date(item));
    const dateTimeTermProperty = purify.Maybe.fromNullable(
      $jsonObject["dateTimeTermProperty"],
    ).map((item) => new Date(item));
    const iriTermProperty = purify.Maybe.fromNullable(
      $jsonObject["iriTermProperty"],
    ).map((item) => dataFactory.namedNode(item["@id"]));
    const literalTermProperty = purify.Maybe.fromNullable(
      $jsonObject["literalTermProperty"],
    ).map((item) =>
      dataFactory.literal(
        item["@value"],
        typeof item["@language"] !== "undefined"
          ? item["@language"]
          : typeof item["@type"] !== "undefined"
            ? dataFactory.namedNode(item["@type"])
            : undefined,
      ),
    );
    const numberTermProperty = purify.Maybe.fromNullable(
      $jsonObject["numberTermProperty"],
    );
    const stringTermProperty = purify.Maybe.fromNullable(
      $jsonObject["stringTermProperty"],
    );
    const termProperty = purify.Maybe.fromNullable(
      $jsonObject["termProperty"],
    ).map((item) =>
      item.termType === "NamedNode"
        ? dataFactory.namedNode(item["@id"])
        : item.termType === "Literal"
          ? dataFactory.literal(
              item["@value"],
              typeof item["@language"] !== "undefined"
                ? item["@language"]
                : typeof item["@type"] !== "undefined"
                  ? dataFactory.namedNode(item["@type"])
                  : undefined,
            )
          : dataFactory.blankNode(item["@id"].substring(2)),
    );
    return purify.Either.of({
      $identifier,
      blankNodeTermProperty,
      booleanTermProperty,
      dateTermProperty,
      dateTimeTermProperty,
      iriTermProperty,
      literalTermProperty,
      numberTermProperty,
      stringTermProperty,
      termProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      blankNodeTermProperty: purify.Maybe<rdfjs.BlankNode>;
      booleanTermProperty: purify.Maybe<boolean>;
      dateTermProperty: purify.Maybe<Date>;
      dateTimeTermProperty: purify.Maybe<Date>;
      iriTermProperty: purify.Maybe<rdfjs.NamedNode>;
      literalTermProperty: purify.Maybe<rdfjs.Literal>;
      numberTermProperty: purify.Maybe<number>;
      stringTermProperty: purify.Maybe<string>;
      termProperty: purify.Maybe<
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
      >;
    }
  > {
    const $identifier: TermPropertiesClass.$Identifier =
      $parameters.resource.identifier;
    const _blankNodeTermPropertyEither: purify.Either<
      Error,
      purify.Maybe<rdfjs.BlankNode>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.blankNodeTermProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) => values.chainMap((value) => value.toBlankNode()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<rdfjs.BlankNode>
            >({
              focusResource: $parameters.resource,
              predicate:
                TermPropertiesClass.$properties.blankNodeTermProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_blankNodeTermPropertyEither.isLeft()) {
      return _blankNodeTermPropertyEither;
    }

    const blankNodeTermProperty = _blankNodeTermPropertyEither.unsafeCoerce();
    const _booleanTermPropertyEither: purify.Either<
      Error,
      purify.Maybe<boolean>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.booleanTermProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) => values.chainMap((value) => value.toBoolean()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<boolean>>({
              focusResource: $parameters.resource,
              predicate:
                TermPropertiesClass.$properties.booleanTermProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_booleanTermPropertyEither.isLeft()) {
      return _booleanTermPropertyEither;
    }

    const booleanTermProperty = _booleanTermPropertyEither.unsafeCoerce();
    const _dateTermPropertyEither: purify.Either<
      Error,
      purify.Maybe<Date>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values($properties.dateTermProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => values.chainMap((value) => value.toDate()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<Date>>({
              focusResource: $parameters.resource,
              predicate:
                TermPropertiesClass.$properties.dateTermProperty["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_dateTermPropertyEither.isLeft()) {
      return _dateTermPropertyEither;
    }

    const dateTermProperty = _dateTermPropertyEither.unsafeCoerce();
    const _dateTimeTermPropertyEither: purify.Either<
      Error,
      purify.Maybe<Date>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.dateTimeTermProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) => values.chainMap((value) => value.toDate()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<Date>>({
              focusResource: $parameters.resource,
              predicate:
                TermPropertiesClass.$properties.dateTimeTermProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_dateTimeTermPropertyEither.isLeft()) {
      return _dateTimeTermPropertyEither;
    }

    const dateTimeTermProperty = _dateTimeTermPropertyEither.unsafeCoerce();
    const _iriTermPropertyEither: purify.Either<
      Error,
      purify.Maybe<rdfjs.NamedNode>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values($properties.iriTermProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => values.chainMap((value) => value.toIri()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<rdfjs.NamedNode>
            >({
              focusResource: $parameters.resource,
              predicate:
                TermPropertiesClass.$properties.iriTermProperty["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_iriTermPropertyEither.isLeft()) {
      return _iriTermPropertyEither;
    }

    const iriTermProperty = _iriTermPropertyEither.unsafeCoerce();
    const _literalTermPropertyEither: purify.Either<
      Error,
      purify.Maybe<rdfjs.Literal>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.literalTermProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        $fromRdfPreferredLanguages({
          focusResource: $parameters.resource,
          predicate:
            TermPropertiesClass.$properties.literalTermProperty["identifier"],
          preferredLanguages: $parameters.preferredLanguages,
          values,
        }),
      )
      .chain((values) => values.chainMap((value) => value.toLiteral()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<rdfjs.Literal>
            >({
              focusResource: $parameters.resource,
              predicate:
                TermPropertiesClass.$properties.literalTermProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_literalTermPropertyEither.isLeft()) {
      return _literalTermPropertyEither;
    }

    const literalTermProperty = _literalTermPropertyEither.unsafeCoerce();
    const _numberTermPropertyEither: purify.Either<
      Error,
      purify.Maybe<number>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.numberTermProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) => values.chainMap((value) => value.toNumber()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<number>>({
              focusResource: $parameters.resource,
              predicate:
                TermPropertiesClass.$properties.numberTermProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_numberTermPropertyEither.isLeft()) {
      return _numberTermPropertyEither;
    }

    const numberTermProperty = _numberTermPropertyEither.unsafeCoerce();
    const _stringTermPropertyEither: purify.Either<
      Error,
      purify.Maybe<string>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.stringTermProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        $fromRdfPreferredLanguages({
          focusResource: $parameters.resource,
          predicate:
            TermPropertiesClass.$properties.stringTermProperty["identifier"],
          preferredLanguages: $parameters.preferredLanguages,
          values,
        }),
      )
      .chain((values) => values.chainMap((value) => value.toString()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<string>>({
              focusResource: $parameters.resource,
              predicate:
                TermPropertiesClass.$properties.stringTermProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_stringTermPropertyEither.isLeft()) {
      return _stringTermPropertyEither;
    }

    const stringTermProperty = _stringTermPropertyEither.unsafeCoerce();
    const _termPropertyEither: purify.Either<
      Error,
      purify.Maybe<rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values($properties.termProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) =>
        values.chainMap((value) =>
          purify.Either.of<
            Error,
            rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
          >(value.toTerm()),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode>
            >({
              focusResource: $parameters.resource,
              predicate:
                TermPropertiesClass.$properties.termProperty["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_termPropertyEither.isLeft()) {
      return _termPropertyEither;
    }

    const termProperty = _termPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      blankNodeTermProperty,
      booleanTermProperty,
      dateTermProperty,
      dateTimeTermProperty,
      iriTermProperty,
      literalTermProperty,
      numberTermProperty,
      stringTermProperty,
      termProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: TermPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        TermPropertiesClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            TermPropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: TermPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      TermPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("termPropertiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}BlankNodeTermProperty`,
      ),
      predicate:
        TermPropertiesClass.$properties.blankNodeTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}BooleanTermProperty`,
      ),
      predicate:
        TermPropertiesClass.$properties.booleanTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}DateTermProperty`,
      ),
      predicate: TermPropertiesClass.$properties.dateTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}DateTimeTermProperty`,
      ),
      predicate:
        TermPropertiesClass.$properties.dateTimeTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}IriTermProperty`,
      ),
      predicate: TermPropertiesClass.$properties.iriTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}LiteralTermProperty`,
      ),
      predicate:
        TermPropertiesClass.$properties.literalTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}NumberTermProperty`,
      ),
      predicate:
        TermPropertiesClass.$properties.numberTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}StringTermProperty`,
      ),
      predicate:
        TermPropertiesClass.$properties.stringTermProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}TermProperty`,
      ),
      predicate: TermPropertiesClass.$properties.termProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: TermPropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("termPropertiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.blankNodeTermProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}BlankNodeTermProperty`,
                  ),
                  predicate:
                    TermPropertiesClass.$properties.blankNodeTermProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $BlankNodeFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}BlankNodeTermProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.booleanTermProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}BooleanTermProperty`,
                  ),
                  predicate:
                    TermPropertiesClass.$properties.booleanTermProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $BooleanFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}BooleanTermProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.dateTermProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}DateTermProperty`,
                  ),
                  predicate:
                    TermPropertiesClass.$properties.dateTermProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $DateFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}DateTermProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.dateTimeTermProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}DateTimeTermProperty`,
                  ),
                  predicate:
                    TermPropertiesClass.$properties.dateTimeTermProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $DateFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}DateTimeTermProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.iriTermProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}IriTermProperty`,
                  ),
                  predicate:
                    TermPropertiesClass.$properties.iriTermProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $NamedNodeFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}IriTermProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.literalTermProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}LiteralTermProperty`,
                  ),
                  predicate:
                    TermPropertiesClass.$properties.literalTermProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [parameters?.preferredLanguages ?? []]
                .filter((languages) => languages.length > 0)
                .map((languages) =>
                  languages.map((language) => ({
                    type: "operation" as const,
                    operator: "=",
                    args: [
                      {
                        type: "operation" as const,
                        operator: "lang",
                        args: [
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}LiteralTermProperty`,
                          ),
                        ],
                      },
                      dataFactory.literal(language),
                    ],
                  })),
                )
                .map((langEqualsExpressions) => ({
                  type: "filter" as const,
                  expression: langEqualsExpressions.reduce(
                    (reducedExpression, langEqualsExpression) => {
                      if (reducedExpression === null) {
                        return langEqualsExpression;
                      }
                      return {
                        type: "operation" as const,
                        operator: "||",
                        args: [reducedExpression, langEqualsExpression],
                      };
                    },
                    null as sparqljs.Expression | null,
                  ) as sparqljs.Expression,
                }))
                .concat(),
              type: "group",
            },
            {
              patterns: $LiteralFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}LiteralTermProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.numberTermProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}NumberTermProperty`,
                  ),
                  predicate:
                    TermPropertiesClass.$properties.numberTermProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $NumberFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}NumberTermProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.stringTermProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}StringTermProperty`,
                  ),
                  predicate:
                    TermPropertiesClass.$properties.stringTermProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [parameters?.preferredLanguages ?? []]
                .filter((languages) => languages.length > 0)
                .map((languages) =>
                  languages.map((language) => ({
                    type: "operation" as const,
                    operator: "=",
                    args: [
                      {
                        type: "operation" as const,
                        operator: "lang",
                        args: [
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}StringTermProperty`,
                          ),
                        ],
                      },
                      dataFactory.literal(language),
                    ],
                  })),
                )
                .map((langEqualsExpressions) => ({
                  type: "filter" as const,
                  expression: langEqualsExpressions.reduce(
                    (reducedExpression, langEqualsExpression) => {
                      if (reducedExpression === null) {
                        return langEqualsExpression;
                      }
                      return {
                        type: "operation" as const,
                        operator: "||",
                        args: [reducedExpression, langEqualsExpression],
                      };
                    },
                    null as sparqljs.Expression | null,
                  ) as sparqljs.Expression,
                }))
                .concat(),
              type: "group",
            },
            {
              patterns: $StringFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}StringTermProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.termProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}TermProperty`,
                  ),
                  predicate:
                    TermPropertiesClass.$properties.termProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $TermFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "termPropertiesClass")}TermProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    return patterns;
  }
}
/**
 * A node shape that mints its identifier by hashing (other) contents, if no identifier is supplied.
 */
export class Sha256IriIdentifierClass {
  private _$identifier?: Sha256IriIdentifierClass.$Identifier;
  protected readonly _$identifierPrefix?: string;
  readonly $type = "Sha256IriIdentifierClass";
  readonly sha256IriProperty: string;

  constructor(parameters: {
    readonly $identifier?: rdfjs.NamedNode | string;
    readonly $identifierPrefix?: string;
    readonly sha256IriProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this._$identifierPrefix = parameters.$identifierPrefix;
    this.sha256IriProperty = parameters.sha256IriProperty;
  }

  get $identifier(): Sha256IriIdentifierClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }

    if (this._$identifier.termType !== "NamedNode") {
      throw new Error(
        `expected identifier to be NamedNode, not ${this._$identifier.termType}`,
      );
    }

    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  $equals(other: Sha256IriIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$identifierPrefix, other.$identifierPrefix).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$identifierPrefix",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.sha256IriProperty, other.sha256IriProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "sha256IriProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.sha256IriProperty);
    return _hasher;
  }

  $toJson(): Sha256IriIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
        sha256IriProperty: this.sha256IriProperty,
      } satisfies Sha256IriIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      Sha256IriIdentifierClass.$properties.sha256IriProperty["identifier"],
      ...[this.sha256IriProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace Sha256IriIdentifierClass {
  export function $filter(
    filter: Sha256IriIdentifierClass.$Filter,
    value: Sha256IriIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.sha256IriProperty !== "undefined" &&
      !$filterString(filter.sha256IriProperty, value.sha256IriProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
    readonly sha256IriProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Sha256IriIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new Sha256IriIdentifierClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, Sha256IriIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return Sha256IriIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new Sha256IriIdentifierClass(properties));
  }

  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "Sha256IriIdentifierClass";
    readonly sha256IriProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "Sha256IriIdentifierClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/sha256IriProperty`,
          type: "Control",
        },
      ],
      label: "Sha256IriIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("Sha256IriIdentifierClass"),
      sha256IriProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    sha256IriProperty: {
      identifier: dataFactory.namedNode("http://example.com/sha256IriProperty"),
    },
  };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.NamedNode; sha256IriProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const sha256IriProperty = $jsonObject["sha256IriProperty"];
    return purify.Either.of({ $identifier, sha256IriProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.NamedNode; sha256IriProperty: string }
  > {
    if ($parameters.resource.identifier.termType !== "NamedNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedTermValueError({
          actualValue: $parameters.resource.identifier,
          expectedValueType: "(rdfjs.NamedNode)",
          focusResource: $parameters.resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: Sha256IriIdentifierClass.$Identifier =
      $parameters.resource.identifier;
    const _sha256IriPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.sha256IriProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              Sha256IriIdentifierClass.$properties.sha256IriProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_sha256IriPropertyEither.isLeft()) {
      return _sha256IriPropertyEither;
    }

    const sha256IriProperty = _sha256IriPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, sha256IriProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: Sha256IriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Sha256IriIdentifierClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            Sha256IriIdentifierClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: Sha256IriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Sha256IriIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("sha256IriIdentifierClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "sha256IriIdentifierClass")}Sha256IriProperty`,
      ),
      predicate:
        Sha256IriIdentifierClass.$properties.sha256IriProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: Sha256IriIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("sha256IriIdentifierClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "sha256IriIdentifierClass")}Sha256IriProperty`,
            ),
            predicate:
              Sha256IriIdentifierClass.$properties.sha256IriProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "sha256IriIdentifierClass")}Sha256IriProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.sha256IriProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "sha256IriIdentifierClass")}Sha256IriProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
export class RecursiveClassUnionMember2 {
  private _$identifier?: RecursiveClassUnionMember2.$Identifier;
  readonly $type = "RecursiveClassUnionMember2";
  readonly recursiveClassUnionMember2Property: purify.Maybe<RecursiveClassUnion>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly recursiveClassUnionMember2Property?:
      | RecursiveClassUnion
      | purify.Maybe<RecursiveClassUnion>;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.recursiveClassUnionMember2Property)) {
      this.recursiveClassUnionMember2Property =
        parameters?.recursiveClassUnionMember2Property;
    } else if (
      typeof parameters?.recursiveClassUnionMember2Property === "object"
    ) {
      this.recursiveClassUnionMember2Property = purify.Maybe.of(
        parameters?.recursiveClassUnionMember2Property,
      );
    } else if (
      typeof parameters?.recursiveClassUnionMember2Property === "undefined"
    ) {
      this.recursiveClassUnionMember2Property = purify.Maybe.empty();
    } else {
      this.recursiveClassUnionMember2Property =
        parameters?.recursiveClassUnionMember2Property satisfies never;
    }
  }

  get $identifier(): RecursiveClassUnionMember2.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: RecursiveClassUnionMember2): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, RecursiveClassUnion.$equals))(
          this.recursiveClassUnionMember2Property,
          other.recursiveClassUnionMember2Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "recursiveClassUnionMember2Property",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.recursiveClassUnionMember2Property.ifJust((value0) => {
      value0.$hash(_hasher);
    });
    return _hasher;
  }

  $toJson(): RecursiveClassUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        recursiveClassUnionMember2Property:
          this.recursiveClassUnionMember2Property
            .map((item) => item.$toJson())
            .extract(),
      } satisfies RecursiveClassUnionMember2.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      RecursiveClassUnionMember2.$properties.recursiveClassUnionMember2Property[
        "identifier"
      ],
      ...this.recursiveClassUnionMember2Property
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace RecursiveClassUnionMember2 {
  export function $filter(
    filter: RecursiveClassUnionMember2.$Filter,
    value: RecursiveClassUnionMember2,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.recursiveClassUnionMember2Property !== "undefined" &&
      !$filterMaybe<RecursiveClassUnion, RecursiveClassUnion.$Filter>(
        RecursiveClassUnion.$filter,
      )(
        filter.recursiveClassUnionMember2Property,
        value.recursiveClassUnionMember2Property,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly recursiveClassUnionMember2Property?: $MaybeFilter<RecursiveClassUnion.$Filter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, RecursiveClassUnionMember2> {
    return $propertiesFromJson(json).map(
      (properties) => new RecursiveClassUnionMember2(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, RecursiveClassUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return RecursiveClassUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new RecursiveClassUnionMember2(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "RecursiveClassUnionMember2";
    readonly recursiveClassUnionMember2Property?:
      | RecursiveClassUnionMember1.$Json
      | RecursiveClassUnionMember2.$Json;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "RecursiveClassUnionMember2" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/recursiveClassUnionMember2Property`,
          type: "Control",
        },
      ],
      label: "RecursiveClassUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("RecursiveClassUnionMember2"),
      recursiveClassUnionMember2Property: zod
        .lazy(
          (): zod.ZodType<RecursiveClassUnion.$Json> =>
            RecursiveClassUnion.$jsonZodSchema(),
        )
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    recursiveClassUnionMember2Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/recursiveClassUnionMember2Property",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      recursiveClassUnionMember2Property: purify.Maybe<RecursiveClassUnion>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const recursiveClassUnionMember2Property = purify.Maybe.fromNullable(
      $jsonObject["recursiveClassUnionMember2Property"],
    ).map((item) => RecursiveClassUnion.$fromJson(item).unsafeCoerce());
    return purify.Either.of({
      $identifier,
      recursiveClassUnionMember2Property,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      recursiveClassUnionMember2Property: purify.Maybe<RecursiveClassUnion>;
    }
  > {
    const $identifier: RecursiveClassUnionMember2.$Identifier =
      $parameters.resource.identifier;
    const _recursiveClassUnionMember2PropertyEither: purify.Either<
      Error,
      purify.Maybe<RecursiveClassUnion>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.recursiveClassUnionMember2Property["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            RecursiveClassUnion.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: false,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<RecursiveClassUnion>
            >({
              focusResource: $parameters.resource,
              predicate:
                RecursiveClassUnionMember2.$properties
                  .recursiveClassUnionMember2Property["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_recursiveClassUnionMember2PropertyEither.isLeft()) {
      return _recursiveClassUnionMember2PropertyEither;
    }

    const recursiveClassUnionMember2Property =
      _recursiveClassUnionMember2PropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      recursiveClassUnionMember2Property,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: RecursiveClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        RecursiveClassUnionMember2.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            RecursiveClassUnionMember2.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: RecursiveClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      RecursiveClassUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: RecursiveClassUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("recursiveClassUnionMember2");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }
}
export class RecursiveClassUnionMember1 {
  private _$identifier?: RecursiveClassUnionMember1.$Identifier;
  readonly $type = "RecursiveClassUnionMember1";
  readonly recursiveClassUnionMember1Property: purify.Maybe<RecursiveClassUnion>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly recursiveClassUnionMember1Property?:
      | RecursiveClassUnion
      | purify.Maybe<RecursiveClassUnion>;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.recursiveClassUnionMember1Property)) {
      this.recursiveClassUnionMember1Property =
        parameters?.recursiveClassUnionMember1Property;
    } else if (
      typeof parameters?.recursiveClassUnionMember1Property === "object"
    ) {
      this.recursiveClassUnionMember1Property = purify.Maybe.of(
        parameters?.recursiveClassUnionMember1Property,
      );
    } else if (
      typeof parameters?.recursiveClassUnionMember1Property === "undefined"
    ) {
      this.recursiveClassUnionMember1Property = purify.Maybe.empty();
    } else {
      this.recursiveClassUnionMember1Property =
        parameters?.recursiveClassUnionMember1Property satisfies never;
    }
  }

  get $identifier(): RecursiveClassUnionMember1.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: RecursiveClassUnionMember1): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, RecursiveClassUnion.$equals))(
          this.recursiveClassUnionMember1Property,
          other.recursiveClassUnionMember1Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "recursiveClassUnionMember1Property",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.recursiveClassUnionMember1Property.ifJust((value0) => {
      value0.$hash(_hasher);
    });
    return _hasher;
  }

  $toJson(): RecursiveClassUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        recursiveClassUnionMember1Property:
          this.recursiveClassUnionMember1Property
            .map((item) => item.$toJson())
            .extract(),
      } satisfies RecursiveClassUnionMember1.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      RecursiveClassUnionMember1.$properties.recursiveClassUnionMember1Property[
        "identifier"
      ],
      ...this.recursiveClassUnionMember1Property
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace RecursiveClassUnionMember1 {
  export function $filter(
    filter: RecursiveClassUnionMember1.$Filter,
    value: RecursiveClassUnionMember1,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.recursiveClassUnionMember1Property !== "undefined" &&
      !$filterMaybe<RecursiveClassUnion, RecursiveClassUnion.$Filter>(
        RecursiveClassUnion.$filter,
      )(
        filter.recursiveClassUnionMember1Property,
        value.recursiveClassUnionMember1Property,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly recursiveClassUnionMember1Property?: $MaybeFilter<RecursiveClassUnion.$Filter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, RecursiveClassUnionMember1> {
    return $propertiesFromJson(json).map(
      (properties) => new RecursiveClassUnionMember1(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, RecursiveClassUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return RecursiveClassUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new RecursiveClassUnionMember1(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "RecursiveClassUnionMember1";
    readonly recursiveClassUnionMember1Property?:
      | RecursiveClassUnionMember1.$Json
      | RecursiveClassUnionMember2.$Json;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "RecursiveClassUnionMember1" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/recursiveClassUnionMember1Property`,
          type: "Control",
        },
      ],
      label: "RecursiveClassUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("RecursiveClassUnionMember1"),
      recursiveClassUnionMember1Property: zod
        .lazy(
          (): zod.ZodType<RecursiveClassUnion.$Json> =>
            RecursiveClassUnion.$jsonZodSchema(),
        )
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    recursiveClassUnionMember1Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/recursiveClassUnionMember1Property",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      recursiveClassUnionMember1Property: purify.Maybe<RecursiveClassUnion>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const recursiveClassUnionMember1Property = purify.Maybe.fromNullable(
      $jsonObject["recursiveClassUnionMember1Property"],
    ).map((item) => RecursiveClassUnion.$fromJson(item).unsafeCoerce());
    return purify.Either.of({
      $identifier,
      recursiveClassUnionMember1Property,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      recursiveClassUnionMember1Property: purify.Maybe<RecursiveClassUnion>;
    }
  > {
    const $identifier: RecursiveClassUnionMember1.$Identifier =
      $parameters.resource.identifier;
    const _recursiveClassUnionMember1PropertyEither: purify.Either<
      Error,
      purify.Maybe<RecursiveClassUnion>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.recursiveClassUnionMember1Property["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            RecursiveClassUnion.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: false,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<RecursiveClassUnion>
            >({
              focusResource: $parameters.resource,
              predicate:
                RecursiveClassUnionMember1.$properties
                  .recursiveClassUnionMember1Property["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_recursiveClassUnionMember1PropertyEither.isLeft()) {
      return _recursiveClassUnionMember1PropertyEither;
    }

    const recursiveClassUnionMember1Property =
      _recursiveClassUnionMember1PropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      recursiveClassUnionMember1Property,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: RecursiveClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        RecursiveClassUnionMember1.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            RecursiveClassUnionMember1.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: RecursiveClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      RecursiveClassUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: RecursiveClassUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("recursiveClassUnionMember1");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }
}
/**
 * Shape with properties that have visibility modifiers (private, protected, public)
 */
export class PropertyVisibilitiesClass {
  private _$identifier?: PropertyVisibilitiesClass.$Identifier;
  readonly $type = "PropertyVisibilitiesClass";
  private readonly privateProperty: string;
  protected readonly protectedProperty: string;
  readonly publicProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly privateProperty: string;
    readonly protectedProperty: string;
    readonly publicProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.privateProperty = parameters.privateProperty;
    this.protectedProperty = parameters.protectedProperty;
    this.publicProperty = parameters.publicProperty;
  }

  get $identifier(): PropertyVisibilitiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: PropertyVisibilitiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.privateProperty, other.privateProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "privateProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.protectedProperty, other.protectedProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "protectedProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.publicProperty, other.publicProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "publicProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.privateProperty);
    _hasher.update(this.protectedProperty);
    _hasher.update(this.publicProperty);
    return _hasher;
  }

  $toJson(): PropertyVisibilitiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        privateProperty: this.privateProperty,
        protectedProperty: this.protectedProperty,
        publicProperty: this.publicProperty,
      } satisfies PropertyVisibilitiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      PropertyVisibilitiesClass.$properties.privateProperty["identifier"],
      ...[this.privateProperty],
    );
    resource.add(
      PropertyVisibilitiesClass.$properties.protectedProperty["identifier"],
      ...[this.protectedProperty],
    );
    resource.add(
      PropertyVisibilitiesClass.$properties.publicProperty["identifier"],
      ...[this.publicProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PropertyVisibilitiesClass {
  export function $filter(
    filter: PropertyVisibilitiesClass.$Filter,
    value: PropertyVisibilitiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.publicProperty !== "undefined" &&
      !$filterString(filter.publicProperty, value.publicProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly publicProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PropertyVisibilitiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new PropertyVisibilitiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PropertyVisibilitiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PropertyVisibilitiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new PropertyVisibilitiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PropertyVisibilitiesClass";
    readonly privateProperty: string;
    readonly protectedProperty: string;
    readonly publicProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PropertyVisibilitiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/privateProperty`, type: "Control" },
        {
          scope: `${scopePrefix}/properties/protectedProperty`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/publicProperty`, type: "Control" },
      ],
      label: "PropertyVisibilitiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PropertyVisibilitiesClass"),
      privateProperty: zod.string(),
      protectedProperty: zod.string(),
      publicProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    privateProperty: {
      identifier: dataFactory.namedNode("http://example.com/privateProperty"),
    },
    protectedProperty: {
      identifier: dataFactory.namedNode("http://example.com/protectedProperty"),
    },
    publicProperty: {
      identifier: dataFactory.namedNode("http://example.com/publicProperty"),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      privateProperty: string;
      protectedProperty: string;
      publicProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const privateProperty = $jsonObject["privateProperty"];
    const protectedProperty = $jsonObject["protectedProperty"];
    const publicProperty = $jsonObject["publicProperty"];
    return purify.Either.of({
      $identifier,
      privateProperty,
      protectedProperty,
      publicProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      privateProperty: string;
      protectedProperty: string;
      publicProperty: string;
    }
  > {
    const $identifier: PropertyVisibilitiesClass.$Identifier =
      $parameters.resource.identifier;
    const _privatePropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values($properties.privateProperty["identifier"], {
          unique: true,
        }),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              PropertyVisibilitiesClass.$properties.privateProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_privatePropertyEither.isLeft()) {
      return _privatePropertyEither;
    }

    const privateProperty = _privatePropertyEither.unsafeCoerce();
    const _protectedPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.protectedProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              PropertyVisibilitiesClass.$properties.protectedProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_protectedPropertyEither.isLeft()) {
      return _protectedPropertyEither;
    }

    const protectedProperty = _protectedPropertyEither.unsafeCoerce();
    const _publicPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values($properties.publicProperty["identifier"], {
          unique: true,
        }),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              PropertyVisibilitiesClass.$properties.publicProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_publicPropertyEither.isLeft()) {
      return _publicPropertyEither;
    }

    const publicProperty = _publicPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      privateProperty,
      protectedProperty,
      publicProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PropertyVisibilitiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PropertyVisibilitiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            PropertyVisibilitiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PropertyVisibilitiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PropertyVisibilitiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("propertyVisibilitiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyVisibilitiesClass")}PrivateProperty`,
      ),
      predicate:
        PropertyVisibilitiesClass.$properties.privateProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyVisibilitiesClass")}ProtectedProperty`,
      ),
      predicate:
        PropertyVisibilitiesClass.$properties.protectedProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyVisibilitiesClass")}PublicProperty`,
      ),
      predicate:
        PropertyVisibilitiesClass.$properties.publicProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PropertyVisibilitiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("propertyVisibilitiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      triples: [
        {
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyVisibilitiesClass")}PrivateProperty`,
          ),
          predicate:
            PropertyVisibilitiesClass.$properties.privateProperty["identifier"],
          subject: subject,
        },
      ],
      type: "bgp",
    });
    patterns.push({
      triples: [
        {
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyVisibilitiesClass")}ProtectedProperty`,
          ),
          predicate:
            PropertyVisibilitiesClass.$properties.protectedProperty[
              "identifier"
            ],
          subject: subject,
        },
      ],
      type: "bgp",
    });
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyVisibilitiesClass")}PublicProperty`,
            ),
            predicate:
              PropertyVisibilitiesClass.$properties.publicProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyVisibilitiesClass")}PublicProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.publicProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyVisibilitiesClass")}PublicProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
/**
 * Shape that has properties with different cardinalities
 */
export class PropertyCardinalitiesClass {
  private _$identifier?: PropertyCardinalitiesClass.$Identifier;
  readonly $type = "PropertyCardinalitiesClass";
  /**
   * Set: minCount implicitly=0, no maxCount
   */
  readonly emptyStringSetProperty: readonly string[];
  /**
   * Set: minCount=1, no maxCount
   */
  readonly nonEmptyStringSetProperty: purify.NonEmptyList<string>;
  /**
   * Option: maxCount=1, minCount=0
   */
  readonly optionalStringProperty: purify.Maybe<string>;
  /**
   * Required: maxCount=minCount=1
   */
  readonly requiredStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly emptyStringSetProperty?: readonly string[];
    readonly nonEmptyStringSetProperty: purify.NonEmptyList<string>;
    readonly optionalStringProperty?: purify.Maybe<string> | string;
    readonly requiredStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    if (typeof parameters.emptyStringSetProperty === "undefined") {
      this.emptyStringSetProperty = [];
    } else if (typeof parameters.emptyStringSetProperty === "object") {
      this.emptyStringSetProperty = parameters.emptyStringSetProperty;
    } else {
      this.emptyStringSetProperty =
        parameters.emptyStringSetProperty satisfies never;
    }

    this.nonEmptyStringSetProperty = parameters.nonEmptyStringSetProperty;
    if (purify.Maybe.isMaybe(parameters.optionalStringProperty)) {
      this.optionalStringProperty = parameters.optionalStringProperty;
    } else if (typeof parameters.optionalStringProperty === "string") {
      this.optionalStringProperty = purify.Maybe.of(
        parameters.optionalStringProperty,
      );
    } else if (typeof parameters.optionalStringProperty === "undefined") {
      this.optionalStringProperty = purify.Maybe.empty();
    } else {
      this.optionalStringProperty =
        parameters.optionalStringProperty satisfies never;
    }

    this.requiredStringProperty = parameters.requiredStringProperty;
  }

  get $identifier(): PropertyCardinalitiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: PropertyCardinalitiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $strictEquals))(
          this.emptyStringSetProperty,
          other.emptyStringSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "emptyStringSetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $strictEquals))(
          this.nonEmptyStringSetProperty,
          other.nonEmptyStringSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "nonEmptyStringSetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.optionalStringProperty,
          other.optionalStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.requiredStringProperty,
          other.requiredStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "requiredStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    for (const item0 of this.emptyStringSetProperty) {
      _hasher.update(item0);
    }

    for (const item0 of this.nonEmptyStringSetProperty) {
      _hasher.update(item0);
    }

    this.optionalStringProperty.ifJust((value0) => {
      _hasher.update(value0);
    });
    _hasher.update(this.requiredStringProperty);
    return _hasher;
  }

  $toJson(): PropertyCardinalitiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        emptyStringSetProperty: this.emptyStringSetProperty.map((item) => item),
        nonEmptyStringSetProperty: this.nonEmptyStringSetProperty.map(
          (item) => item,
        ),
        optionalStringProperty: this.optionalStringProperty
          .map((item) => item)
          .extract(),
        requiredStringProperty: this.requiredStringProperty,
      } satisfies PropertyCardinalitiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      PropertyCardinalitiesClass.$properties.emptyStringSetProperty[
        "identifier"
      ],
      ...this.emptyStringSetProperty.flatMap((item) => [item]),
    );
    resource.add(
      PropertyCardinalitiesClass.$properties.nonEmptyStringSetProperty[
        "identifier"
      ],
      ...this.nonEmptyStringSetProperty.flatMap((item) => [item]),
    );
    resource.add(
      PropertyCardinalitiesClass.$properties.optionalStringProperty[
        "identifier"
      ],
      ...this.optionalStringProperty.toList(),
    );
    resource.add(
      PropertyCardinalitiesClass.$properties.requiredStringProperty[
        "identifier"
      ],
      ...[this.requiredStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PropertyCardinalitiesClass {
  export function $filter(
    filter: PropertyCardinalitiesClass.$Filter,
    value: PropertyCardinalitiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.emptyStringSetProperty !== "undefined" &&
      !$filterArray<string, $StringFilter>($filterString)(
        filter.emptyStringSetProperty,
        value.emptyStringSetProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.nonEmptyStringSetProperty !== "undefined" &&
      !$filterArray<string, $StringFilter>($filterString)(
        filter.nonEmptyStringSetProperty,
        value.nonEmptyStringSetProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalStringProperty !== "undefined" &&
      !$filterMaybe<string, $StringFilter>($filterString)(
        filter.optionalStringProperty,
        value.optionalStringProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.requiredStringProperty !== "undefined" &&
      !$filterString(
        filter.requiredStringProperty,
        value.requiredStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly emptyStringSetProperty?: $CollectionFilter<$StringFilter>;
    readonly nonEmptyStringSetProperty?: $CollectionFilter<$StringFilter>;
    readonly optionalStringProperty?: $MaybeFilter<$StringFilter>;
    readonly requiredStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PropertyCardinalitiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new PropertyCardinalitiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PropertyCardinalitiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PropertyCardinalitiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new PropertyCardinalitiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PropertyCardinalitiesClass";
    readonly emptyStringSetProperty?: readonly string[];
    readonly nonEmptyStringSetProperty: readonly string[];
    readonly optionalStringProperty?: string;
    readonly requiredStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PropertyCardinalitiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/emptyStringSetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/nonEmptyStringSetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/optionalStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/requiredStringProperty`,
          type: "Control",
        },
      ],
      label: "PropertyCardinalitiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PropertyCardinalitiesClass"),
      emptyStringSetProperty: zod
        .string()
        .array()
        .default(() => [])
        .describe("Set: minCount implicitly=0, no maxCount"),
      nonEmptyStringSetProperty: zod
        .string()
        .array()
        .nonempty()
        .min(1)
        .describe("Set: minCount=1, no maxCount"),
      optionalStringProperty: zod
        .string()
        .optional()
        .describe("Option: maxCount=1, minCount=0"),
      requiredStringProperty: zod
        .string()
        .describe("Required: maxCount=minCount=1"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    emptyStringSetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/emptyStringSetProperty",
      ),
    },
    nonEmptyStringSetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/nonEmptyStringSetProperty",
      ),
    },
    optionalStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalStringProperty",
      ),
    },
    requiredStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/requiredStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      emptyStringSetProperty: readonly string[];
      nonEmptyStringSetProperty: purify.NonEmptyList<string>;
      optionalStringProperty: purify.Maybe<string>;
      requiredStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const emptyStringSetProperty = $jsonObject["emptyStringSetProperty"];
    const nonEmptyStringSetProperty = purify.NonEmptyList.fromArray(
      $jsonObject["nonEmptyStringSetProperty"],
    ).unsafeCoerce();
    const optionalStringProperty = purify.Maybe.fromNullable(
      $jsonObject["optionalStringProperty"],
    );
    const requiredStringProperty = $jsonObject["requiredStringProperty"];
    return purify.Either.of({
      $identifier,
      emptyStringSetProperty,
      nonEmptyStringSetProperty,
      optionalStringProperty,
      requiredStringProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      emptyStringSetProperty: readonly string[];
      nonEmptyStringSetProperty: purify.NonEmptyList<string>;
      optionalStringProperty: purify.Maybe<string>;
      requiredStringProperty: string;
    }
  > {
    const $identifier: PropertyCardinalitiesClass.$Identifier =
      $parameters.resource.identifier;
    const _emptyStringSetPropertyEither: purify.Either<
      Error,
      readonly string[]
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.emptyStringSetProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        $fromRdfPreferredLanguages({
          focusResource: $parameters.resource,
          predicate:
            PropertyCardinalitiesClass.$properties.emptyStringSetProperty[
              "identifier"
            ],
          preferredLanguages: $parameters.preferredLanguages,
          values,
        }),
      )
      .chain((values) => values.chainMap((value) => value.toString()))
      .map((values) => values.toArray())
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          focusResource: $parameters.resource,
          predicate:
            PropertyCardinalitiesClass.$properties.emptyStringSetProperty[
              "identifier"
            ],
          value: valuesArray,
        }),
      )
      .chain((values) => values.head());
    if (_emptyStringSetPropertyEither.isLeft()) {
      return _emptyStringSetPropertyEither;
    }

    const emptyStringSetProperty = _emptyStringSetPropertyEither.unsafeCoerce();
    const _nonEmptyStringSetPropertyEither: purify.Either<
      Error,
      purify.NonEmptyList<string>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.nonEmptyStringSetProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        $fromRdfPreferredLanguages({
          focusResource: $parameters.resource,
          predicate:
            PropertyCardinalitiesClass.$properties.nonEmptyStringSetProperty[
              "identifier"
            ],
          preferredLanguages: $parameters.preferredLanguages,
          values,
        }),
      )
      .chain((values) => values.chainMap((value) => value.toString()))
      .chain((values) =>
        purify.NonEmptyList.fromArray(values.toArray()).toEither(
          new Error(
            `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} is an empty set`,
          ),
        ),
      )
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          focusResource: $parameters.resource,
          predicate:
            PropertyCardinalitiesClass.$properties.nonEmptyStringSetProperty[
              "identifier"
            ],
          value: valuesArray,
        }),
      )
      .chain((values) => values.head());
    if (_nonEmptyStringSetPropertyEither.isLeft()) {
      return _nonEmptyStringSetPropertyEither;
    }

    const nonEmptyStringSetProperty =
      _nonEmptyStringSetPropertyEither.unsafeCoerce();
    const _optionalStringPropertyEither: purify.Either<
      Error,
      purify.Maybe<string>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.optionalStringProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        $fromRdfPreferredLanguages({
          focusResource: $parameters.resource,
          predicate:
            PropertyCardinalitiesClass.$properties.optionalStringProperty[
              "identifier"
            ],
          preferredLanguages: $parameters.preferredLanguages,
          values,
        }),
      )
      .chain((values) => values.chainMap((value) => value.toString()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<string>>({
              focusResource: $parameters.resource,
              predicate:
                PropertyCardinalitiesClass.$properties.optionalStringProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_optionalStringPropertyEither.isLeft()) {
      return _optionalStringPropertyEither;
    }

    const optionalStringProperty = _optionalStringPropertyEither.unsafeCoerce();
    const _requiredStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.requiredStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              PropertyCardinalitiesClass.$properties.requiredStringProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_requiredStringPropertyEither.isLeft()) {
      return _requiredStringPropertyEither;
    }

    const requiredStringProperty = _requiredStringPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      emptyStringSetProperty,
      nonEmptyStringSetProperty,
      optionalStringProperty,
      requiredStringProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PropertyCardinalitiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PropertyCardinalitiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            PropertyCardinalitiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PropertyCardinalitiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PropertyCardinalitiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("propertyCardinalitiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}EmptyStringSetProperty`,
      ),
      predicate:
        PropertyCardinalitiesClass.$properties.emptyStringSetProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}NonEmptyStringSetProperty`,
      ),
      predicate:
        PropertyCardinalitiesClass.$properties.nonEmptyStringSetProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}OptionalStringProperty`,
      ),
      predicate:
        PropertyCardinalitiesClass.$properties.optionalStringProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}RequiredStringProperty`,
      ),
      predicate:
        PropertyCardinalitiesClass.$properties.requiredStringProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PropertyCardinalitiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("propertyCardinalitiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}EmptyStringSetProperty`,
              ),
              predicate:
                PropertyCardinalitiesClass.$properties.emptyStringSetProperty[
                  "identifier"
                ],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: [parameters?.preferredLanguages ?? []]
            .filter((languages) => languages.length > 0)
            .map((languages) =>
              languages.map((language) => ({
                type: "operation" as const,
                operator: "=",
                args: [
                  {
                    type: "operation" as const,
                    operator: "lang",
                    args: [
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}EmptyStringSetProperty`,
                      ),
                    ],
                  },
                  dataFactory.literal(language),
                ],
              })),
            )
            .map((langEqualsExpressions) => ({
              type: "filter" as const,
              expression: langEqualsExpressions.reduce(
                (reducedExpression, langEqualsExpression) => {
                  if (reducedExpression === null) {
                    return langEqualsExpression;
                  }
                  return {
                    type: "operation" as const,
                    operator: "||",
                    args: [reducedExpression, langEqualsExpression],
                  };
                },
                null as sparqljs.Expression | null,
              ) as sparqljs.Expression,
            }))
            .concat(),
          type: "group",
        },
        {
          patterns: $StringFilter
            .$sparqlWherePatterns(
              parameters?.filter?.emptyStringSetProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}EmptyStringSetProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}NonEmptyStringSetProperty`,
            ),
            predicate:
              PropertyCardinalitiesClass.$properties.nonEmptyStringSetProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}NonEmptyStringSetProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.nonEmptyStringSetProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}NonEmptyStringSetProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalStringProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}OptionalStringProperty`,
                  ),
                  predicate:
                    PropertyCardinalitiesClass.$properties
                      .optionalStringProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [parameters?.preferredLanguages ?? []]
                .filter((languages) => languages.length > 0)
                .map((languages) =>
                  languages.map((language) => ({
                    type: "operation" as const,
                    operator: "=",
                    args: [
                      {
                        type: "operation" as const,
                        operator: "lang",
                        args: [
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}OptionalStringProperty`,
                          ),
                        ],
                      },
                      dataFactory.literal(language),
                    ],
                  })),
                )
                .map((langEqualsExpressions) => ({
                  type: "filter" as const,
                  expression: langEqualsExpressions.reduce(
                    (reducedExpression, langEqualsExpression) => {
                      if (reducedExpression === null) {
                        return langEqualsExpression;
                      }
                      return {
                        type: "operation" as const,
                        operator: "||",
                        args: [reducedExpression, langEqualsExpression],
                      };
                    },
                    null as sparqljs.Expression | null,
                  ) as sparqljs.Expression,
                }))
                .concat(),
              type: "group",
            },
            {
              patterns: $StringFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}OptionalStringProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}RequiredStringProperty`,
            ),
            predicate:
              PropertyCardinalitiesClass.$properties.requiredStringProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}RequiredStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.requiredStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "propertyCardinalitiesClass")}RequiredStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
export interface PartialInterfaceUnionMember2 {
  readonly $identifier: PartialInterfaceUnionMember2.$Identifier;
  readonly $type: "PartialInterfaceUnionMember2";
  readonly lazilyResolvedStringProperty: string;
}

export namespace PartialInterfaceUnionMember2 {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): PartialInterfaceUnionMember2 {
    let $identifier: PartialInterfaceUnionMember2.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "PartialInterfaceUnionMember2" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: PartialInterfaceUnionMember2,
    right: PartialInterfaceUnionMember2,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export function $filter(
    filter: PartialInterfaceUnionMember2.$Filter,
    value: PartialInterfaceUnionMember2,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialInterfaceUnionMember2> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialInterfaceUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PartialInterfaceUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/PartialInterfaceUnionMember2",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _partialInterfaceUnionMember2: PartialInterfaceUnionMember2,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_partialInterfaceUnionMember2.$identifier.value);
    _hasher.update(_partialInterfaceUnionMember2.$type);
    PartialInterfaceUnionMember2.$hashShaclProperties(
      _partialInterfaceUnionMember2,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _partialInterfaceUnionMember2: PartialInterfaceUnionMember2,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_partialInterfaceUnionMember2.lazilyResolvedStringProperty);
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialInterfaceUnionMember2";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialInterfaceUnionMember2" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialInterfaceUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PartialInterfaceUnionMember2"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "PartialInterfaceUnionMember2";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "PartialInterfaceUnionMember2" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "PartialInterfaceUnionMember2";
      lazilyResolvedStringProperty: string;
    }
  > {
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/PartialInterfaceUnionMember2":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              PartialInterfaceUnionMember2.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/PartialInterfaceUnionMember2)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: PartialInterfaceUnionMember2.$Identifier =
      $parameters.resource.identifier;
    const $type = "PartialInterfaceUnionMember2" as const;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              PartialInterfaceUnionMember2.$properties
                .lazilyResolvedStringProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialInterfaceUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialInterfaceUnionMember2.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            PartialInterfaceUnionMember2.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialInterfaceUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialInterfaceUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("partialInterfaceUnionMember2");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember2")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember2")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember2")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember2")}LazilyResolvedStringProperty`,
      ),
      predicate:
        PartialInterfaceUnionMember2.$properties.lazilyResolvedStringProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialInterfaceUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("partialInterfaceUnionMember2");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember2")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: PartialInterfaceUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember2")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember2")}LazilyResolvedStringProperty`,
            ),
            predicate:
              PartialInterfaceUnionMember2.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember2")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember2")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _partialInterfaceUnionMember2: PartialInterfaceUnionMember2,
  ): PartialInterfaceUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _partialInterfaceUnionMember2.$identifier.termType === "BlankNode"
            ? `_:${_partialInterfaceUnionMember2.$identifier.value}`
            : _partialInterfaceUnionMember2.$identifier.value,
        $type: _partialInterfaceUnionMember2.$type,
        lazilyResolvedStringProperty:
          _partialInterfaceUnionMember2.lazilyResolvedStringProperty,
      } satisfies PartialInterfaceUnionMember2.$Json),
    );
  }

  export function $toRdf(
    _partialInterfaceUnionMember2: PartialInterfaceUnionMember2,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _partialInterfaceUnionMember2.$identifier,
      { mutateGraph },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/PartialInterfaceUnionMember2",
        ),
      );
    }

    resource.add(
      PartialInterfaceUnionMember2.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[_partialInterfaceUnionMember2.lazilyResolvedStringProperty],
    );
    return resource;
  }
}
export interface PartialInterfaceUnionMember1 {
  readonly $identifier: PartialInterfaceUnionMember1.$Identifier;
  readonly $type: "PartialInterfaceUnionMember1";
  readonly lazilyResolvedStringProperty: string;
}

export namespace PartialInterfaceUnionMember1 {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): PartialInterfaceUnionMember1 {
    let $identifier: PartialInterfaceUnionMember1.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "PartialInterfaceUnionMember1" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: PartialInterfaceUnionMember1,
    right: PartialInterfaceUnionMember1,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export function $filter(
    filter: PartialInterfaceUnionMember1.$Filter,
    value: PartialInterfaceUnionMember1,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialInterfaceUnionMember1> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialInterfaceUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PartialInterfaceUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/PartialInterfaceUnionMember1",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _partialInterfaceUnionMember1: PartialInterfaceUnionMember1,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_partialInterfaceUnionMember1.$identifier.value);
    _hasher.update(_partialInterfaceUnionMember1.$type);
    PartialInterfaceUnionMember1.$hashShaclProperties(
      _partialInterfaceUnionMember1,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _partialInterfaceUnionMember1: PartialInterfaceUnionMember1,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_partialInterfaceUnionMember1.lazilyResolvedStringProperty);
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialInterfaceUnionMember1";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialInterfaceUnionMember1" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialInterfaceUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PartialInterfaceUnionMember1"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "PartialInterfaceUnionMember1";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "PartialInterfaceUnionMember1" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "PartialInterfaceUnionMember1";
      lazilyResolvedStringProperty: string;
    }
  > {
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/PartialInterfaceUnionMember1":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              PartialInterfaceUnionMember1.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/PartialInterfaceUnionMember1)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: PartialInterfaceUnionMember1.$Identifier =
      $parameters.resource.identifier;
    const $type = "PartialInterfaceUnionMember1" as const;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              PartialInterfaceUnionMember1.$properties
                .lazilyResolvedStringProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialInterfaceUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialInterfaceUnionMember1.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            PartialInterfaceUnionMember1.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialInterfaceUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialInterfaceUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("partialInterfaceUnionMember1");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember1")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember1")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember1")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember1")}LazilyResolvedStringProperty`,
      ),
      predicate:
        PartialInterfaceUnionMember1.$properties.lazilyResolvedStringProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialInterfaceUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("partialInterfaceUnionMember1");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember1")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: PartialInterfaceUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember1")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember1")}LazilyResolvedStringProperty`,
            ),
            predicate:
              PartialInterfaceUnionMember1.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember1")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterfaceUnionMember1")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _partialInterfaceUnionMember1: PartialInterfaceUnionMember1,
  ): PartialInterfaceUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _partialInterfaceUnionMember1.$identifier.termType === "BlankNode"
            ? `_:${_partialInterfaceUnionMember1.$identifier.value}`
            : _partialInterfaceUnionMember1.$identifier.value,
        $type: _partialInterfaceUnionMember1.$type,
        lazilyResolvedStringProperty:
          _partialInterfaceUnionMember1.lazilyResolvedStringProperty,
      } satisfies PartialInterfaceUnionMember1.$Json),
    );
  }

  export function $toRdf(
    _partialInterfaceUnionMember1: PartialInterfaceUnionMember1,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _partialInterfaceUnionMember1.$identifier,
      { mutateGraph },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/PartialInterfaceUnionMember1",
        ),
      );
    }

    resource.add(
      PartialInterfaceUnionMember1.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[_partialInterfaceUnionMember1.lazilyResolvedStringProperty],
    );
    return resource;
  }
}
export class PartialClassUnionMember2 {
  private _$identifier?: PartialClassUnionMember2.$Identifier;
  readonly $type = "PartialClassUnionMember2";
  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): PartialClassUnionMember2.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: PartialClassUnionMember2): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): PartialClassUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies PartialClassUnionMember2.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/PartialClassUnionMember2",
        ),
      );
    }

    resource.add(
      PartialClassUnionMember2.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[this.lazilyResolvedStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PartialClassUnionMember2 {
  export function $filter(
    filter: PartialClassUnionMember2.$Filter,
    value: PartialClassUnionMember2,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialClassUnionMember2> {
    return $propertiesFromJson(json).map(
      (properties) => new PartialClassUnionMember2(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialClassUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PartialClassUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new PartialClassUnionMember2(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/PartialClassUnionMember2",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialClassUnionMember2";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialClassUnionMember2" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialClassUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PartialClassUnionMember2"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/PartialClassUnionMember2":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              PartialClassUnionMember2.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/PartialClassUnionMember2)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: PartialClassUnionMember2.$Identifier =
      $parameters.resource.identifier;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              PartialClassUnionMember2.$properties.lazilyResolvedStringProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialClassUnionMember2.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            PartialClassUnionMember2.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialClassUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClassUnionMember2");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember2")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember2")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember2")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember2")}LazilyResolvedStringProperty`,
      ),
      predicate:
        PartialClassUnionMember2.$properties.lazilyResolvedStringProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialClassUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClassUnionMember2");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember2")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: PartialClassUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember2")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember2")}LazilyResolvedStringProperty`,
            ),
            predicate:
              PartialClassUnionMember2.$properties.lazilyResolvedStringProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember2")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember2")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
export class PartialClassUnionMember1 {
  private _$identifier?: PartialClassUnionMember1.$Identifier;
  readonly $type = "PartialClassUnionMember1";
  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): PartialClassUnionMember1.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: PartialClassUnionMember1): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): PartialClassUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies PartialClassUnionMember1.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/PartialClassUnionMember1",
        ),
      );
    }

    resource.add(
      PartialClassUnionMember1.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[this.lazilyResolvedStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PartialClassUnionMember1 {
  export function $filter(
    filter: PartialClassUnionMember1.$Filter,
    value: PartialClassUnionMember1,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialClassUnionMember1> {
    return $propertiesFromJson(json).map(
      (properties) => new PartialClassUnionMember1(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialClassUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PartialClassUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new PartialClassUnionMember1(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/PartialClassUnionMember1",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialClassUnionMember1";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialClassUnionMember1" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialClassUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PartialClassUnionMember1"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/PartialClassUnionMember1":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              PartialClassUnionMember1.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/PartialClassUnionMember1)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: PartialClassUnionMember1.$Identifier =
      $parameters.resource.identifier;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              PartialClassUnionMember1.$properties.lazilyResolvedStringProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialClassUnionMember1.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            PartialClassUnionMember1.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialClassUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClassUnionMember1");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember1")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember1")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember1")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember1")}LazilyResolvedStringProperty`,
      ),
      predicate:
        PartialClassUnionMember1.$properties.lazilyResolvedStringProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialClassUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClassUnionMember1");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember1")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: PartialClassUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember1")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember1")}LazilyResolvedStringProperty`,
            ),
            predicate:
              PartialClassUnionMember1.$properties.lazilyResolvedStringProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember1")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClassUnionMember1")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
/**
 * Shape whose sh:properties have sh:order's. The compiler should order them C, A, B based on sh:order instead of on the declaration or lexicographic orders.
 */
export class OrderedPropertiesClass {
  private _$identifier?: OrderedPropertiesClass.$Identifier;
  readonly $type = "OrderedPropertiesClass";
  readonly orderedPropertyC: string;
  readonly orderedPropertyB: string;
  readonly orderedPropertyA: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly orderedPropertyC: string;
    readonly orderedPropertyB: string;
    readonly orderedPropertyA: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.orderedPropertyC = parameters.orderedPropertyC;
    this.orderedPropertyB = parameters.orderedPropertyB;
    this.orderedPropertyA = parameters.orderedPropertyA;
  }

  get $identifier(): OrderedPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: OrderedPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.orderedPropertyC, other.orderedPropertyC).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "orderedPropertyC",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.orderedPropertyB, other.orderedPropertyB).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "orderedPropertyB",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.orderedPropertyA, other.orderedPropertyA).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "orderedPropertyA",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.orderedPropertyC);
    _hasher.update(this.orderedPropertyB);
    _hasher.update(this.orderedPropertyA);
    return _hasher;
  }

  $toJson(): OrderedPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        orderedPropertyC: this.orderedPropertyC,
        orderedPropertyB: this.orderedPropertyB,
        orderedPropertyA: this.orderedPropertyA,
      } satisfies OrderedPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      OrderedPropertiesClass.$properties.orderedPropertyC["identifier"],
      ...[this.orderedPropertyC],
    );
    resource.add(
      OrderedPropertiesClass.$properties.orderedPropertyB["identifier"],
      ...[this.orderedPropertyB],
    );
    resource.add(
      OrderedPropertiesClass.$properties.orderedPropertyA["identifier"],
      ...[this.orderedPropertyA],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace OrderedPropertiesClass {
  export function $filter(
    filter: OrderedPropertiesClass.$Filter,
    value: OrderedPropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.orderedPropertyC !== "undefined" &&
      !$filterString(filter.orderedPropertyC, value.orderedPropertyC)
    ) {
      return false;
    }

    if (
      typeof filter.orderedPropertyB !== "undefined" &&
      !$filterString(filter.orderedPropertyB, value.orderedPropertyB)
    ) {
      return false;
    }

    if (
      typeof filter.orderedPropertyA !== "undefined" &&
      !$filterString(filter.orderedPropertyA, value.orderedPropertyA)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly orderedPropertyC?: $StringFilter;
    readonly orderedPropertyB?: $StringFilter;
    readonly orderedPropertyA?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, OrderedPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new OrderedPropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, OrderedPropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return OrderedPropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new OrderedPropertiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "OrderedPropertiesClass";
    readonly orderedPropertyC: string;
    readonly orderedPropertyB: string;
    readonly orderedPropertyA: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "OrderedPropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/orderedPropertyC`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/orderedPropertyB`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/orderedPropertyA`,
          type: "Control",
        },
      ],
      label: "OrderedPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("OrderedPropertiesClass"),
      orderedPropertyC: zod.string(),
      orderedPropertyB: zod.string(),
      orderedPropertyA: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    orderedPropertyC: {
      identifier: dataFactory.namedNode("http://example.com/orderedPropertyC"),
    },
    orderedPropertyB: {
      identifier: dataFactory.namedNode("http://example.com/orderedPropertyB"),
    },
    orderedPropertyA: {
      identifier: dataFactory.namedNode("http://example.com/orderedPropertyA"),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      orderedPropertyC: string;
      orderedPropertyB: string;
      orderedPropertyA: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const orderedPropertyC = $jsonObject["orderedPropertyC"];
    const orderedPropertyB = $jsonObject["orderedPropertyB"];
    const orderedPropertyA = $jsonObject["orderedPropertyA"];
    return purify.Either.of({
      $identifier,
      orderedPropertyC,
      orderedPropertyB,
      orderedPropertyA,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      orderedPropertyC: string;
      orderedPropertyB: string;
      orderedPropertyA: string;
    }
  > {
    const $identifier: OrderedPropertiesClass.$Identifier =
      $parameters.resource.identifier;
    const _orderedPropertyCEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.orderedPropertyC["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              OrderedPropertiesClass.$properties.orderedPropertyC["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_orderedPropertyCEither.isLeft()) {
      return _orderedPropertyCEither;
    }

    const orderedPropertyC = _orderedPropertyCEither.unsafeCoerce();
    const _orderedPropertyBEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.orderedPropertyB["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              OrderedPropertiesClass.$properties.orderedPropertyB["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_orderedPropertyBEither.isLeft()) {
      return _orderedPropertyBEither;
    }

    const orderedPropertyB = _orderedPropertyBEither.unsafeCoerce();
    const _orderedPropertyAEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.orderedPropertyA["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              OrderedPropertiesClass.$properties.orderedPropertyA["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_orderedPropertyAEither.isLeft()) {
      return _orderedPropertyAEither;
    }

    const orderedPropertyA = _orderedPropertyAEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      orderedPropertyC,
      orderedPropertyB,
      orderedPropertyA,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: OrderedPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        OrderedPropertiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            OrderedPropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: OrderedPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      OrderedPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("orderedPropertiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyC`,
      ),
      predicate:
        OrderedPropertiesClass.$properties.orderedPropertyC["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyB`,
      ),
      predicate:
        OrderedPropertiesClass.$properties.orderedPropertyB["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyA`,
      ),
      predicate:
        OrderedPropertiesClass.$properties.orderedPropertyA["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: OrderedPropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("orderedPropertiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyC`,
            ),
            predicate:
              OrderedPropertiesClass.$properties.orderedPropertyC["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyC`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.orderedPropertyC,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyC`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyB`,
            ),
            predicate:
              OrderedPropertiesClass.$properties.orderedPropertyB["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyB`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.orderedPropertyB,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyB`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyA`,
            ),
            predicate:
              OrderedPropertiesClass.$properties.orderedPropertyA["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyA`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.orderedPropertyA,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "orderedPropertiesClass")}OrderedPropertyA`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
/**
 * Node shape that isn't an rdfs:Class.
 */
export class NonClass {
  private _$identifier?: NonClass.$Identifier;
  readonly $type = "NonClass";
  readonly nonClassProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly nonClassProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.nonClassProperty = parameters.nonClassProperty;
  }

  get $identifier(): NonClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: NonClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.nonClassProperty, other.nonClassProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "nonClassProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.nonClassProperty);
    return _hasher;
  }

  $toJson(): NonClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        nonClassProperty: this.nonClassProperty,
      } satisfies NonClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      NonClass.$properties.nonClassProperty["identifier"],
      ...[this.nonClassProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace NonClass {
  export function $filter(filter: NonClass.$Filter, value: NonClass): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.nonClassProperty !== "undefined" &&
      !$filterString(filter.nonClassProperty, value.nonClassProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly nonClassProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, NonClass> {
    return $propertiesFromJson(json).map(
      (properties) => new NonClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, NonClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return NonClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new NonClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "NonClass";
    readonly nonClassProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "NonClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/nonClassProperty`,
          type: "Control",
        },
      ],
      label: "NonClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("NonClass"),
      nonClassProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    nonClassProperty: {
      identifier: dataFactory.namedNode("http://example.com/nonClassProperty"),
    },
  };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode; nonClassProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const nonClassProperty = $jsonObject["nonClassProperty"];
    return purify.Either.of({ $identifier, nonClassProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode; nonClassProperty: string }
  > {
    const $identifier: NonClass.$Identifier = $parameters.resource.identifier;
    const _nonClassPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.nonClassProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate: NonClass.$properties.nonClassProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_nonClassPropertyEither.isLeft()) {
      return _nonClassPropertyEither;
    }

    const nonClassProperty = _nonClassPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, nonClassProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: NonClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        NonClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            NonClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: NonClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      NonClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("nonClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "nonClass")}NonClassProperty`,
      ),
      predicate: NonClass.$properties.nonClassProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: NonClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("nonClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "nonClass")}NonClassProperty`,
            ),
            predicate: NonClass.$properties.nonClassProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "nonClass")}NonClassProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.nonClassProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "nonClass")}NonClassProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
export class NoRdfTypeClassUnionMember2 {
  private _$identifier?: NoRdfTypeClassUnionMember2.$Identifier;
  readonly $type = "NoRdfTypeClassUnionMember2";
  readonly noRdfTypeClassUnionMember2Property: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly noRdfTypeClassUnionMember2Property: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.noRdfTypeClassUnionMember2Property =
      parameters.noRdfTypeClassUnionMember2Property;
  }

  get $identifier(): NoRdfTypeClassUnionMember2.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: NoRdfTypeClassUnionMember2): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.noRdfTypeClassUnionMember2Property,
          other.noRdfTypeClassUnionMember2Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "noRdfTypeClassUnionMember2Property",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.noRdfTypeClassUnionMember2Property);
    return _hasher;
  }

  $toJson(): NoRdfTypeClassUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        noRdfTypeClassUnionMember2Property:
          this.noRdfTypeClassUnionMember2Property,
      } satisfies NoRdfTypeClassUnionMember2.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      NoRdfTypeClassUnionMember2.$properties.noRdfTypeClassUnionMember2Property[
        "identifier"
      ],
      ...[this.noRdfTypeClassUnionMember2Property],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace NoRdfTypeClassUnionMember2 {
  export function $filter(
    filter: NoRdfTypeClassUnionMember2.$Filter,
    value: NoRdfTypeClassUnionMember2,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.noRdfTypeClassUnionMember2Property !== "undefined" &&
      !$filterString(
        filter.noRdfTypeClassUnionMember2Property,
        value.noRdfTypeClassUnionMember2Property,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly noRdfTypeClassUnionMember2Property?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, NoRdfTypeClassUnionMember2> {
    return $propertiesFromJson(json).map(
      (properties) => new NoRdfTypeClassUnionMember2(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, NoRdfTypeClassUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return NoRdfTypeClassUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new NoRdfTypeClassUnionMember2(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "NoRdfTypeClassUnionMember2";
    readonly noRdfTypeClassUnionMember2Property: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "NoRdfTypeClassUnionMember2" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/noRdfTypeClassUnionMember2Property`,
          type: "Control",
        },
      ],
      label: "NoRdfTypeClassUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("NoRdfTypeClassUnionMember2"),
      noRdfTypeClassUnionMember2Property: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    noRdfTypeClassUnionMember2Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/noRdfTypeClassUnionMember2Property",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      noRdfTypeClassUnionMember2Property: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const noRdfTypeClassUnionMember2Property =
      $jsonObject["noRdfTypeClassUnionMember2Property"];
    return purify.Either.of({
      $identifier,
      noRdfTypeClassUnionMember2Property,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      noRdfTypeClassUnionMember2Property: string;
    }
  > {
    const $identifier: NoRdfTypeClassUnionMember2.$Identifier =
      $parameters.resource.identifier;
    const _noRdfTypeClassUnionMember2PropertyEither: purify.Either<
      Error,
      string
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.noRdfTypeClassUnionMember2Property["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        $fromRdfPreferredLanguages({
          focusResource: $parameters.resource,
          predicate:
            NoRdfTypeClassUnionMember2.$properties
              .noRdfTypeClassUnionMember2Property["identifier"],
          preferredLanguages: $parameters.preferredLanguages,
          values,
        }),
      )
      .chain((values) => values.chainMap((value) => value.toString()))
      .chain((values) => values.head());
    if (_noRdfTypeClassUnionMember2PropertyEither.isLeft()) {
      return _noRdfTypeClassUnionMember2PropertyEither;
    }

    const noRdfTypeClassUnionMember2Property =
      _noRdfTypeClassUnionMember2PropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      noRdfTypeClassUnionMember2Property,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: NoRdfTypeClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        NoRdfTypeClassUnionMember2.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            NoRdfTypeClassUnionMember2.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: NoRdfTypeClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      NoRdfTypeClassUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("noRdfTypeClassUnionMember2");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "noRdfTypeClassUnionMember2")}NoRdfTypeClassUnionMember2Property`,
      ),
      predicate:
        NoRdfTypeClassUnionMember2.$properties
          .noRdfTypeClassUnionMember2Property["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: NoRdfTypeClassUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("noRdfTypeClassUnionMember2");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "noRdfTypeClassUnionMember2")}NoRdfTypeClassUnionMember2Property`,
            ),
            predicate:
              NoRdfTypeClassUnionMember2.$properties
                .noRdfTypeClassUnionMember2Property["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "noRdfTypeClassUnionMember2")}NoRdfTypeClassUnionMember2Property`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.noRdfTypeClassUnionMember2Property,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "noRdfTypeClassUnionMember2")}NoRdfTypeClassUnionMember2Property`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
export class NoRdfTypeClassUnionMember1 {
  private _$identifier?: NoRdfTypeClassUnionMember1.$Identifier;
  readonly $type = "NoRdfTypeClassUnionMember1";
  readonly noRdfTypeClassUnionMember1Property: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly noRdfTypeClassUnionMember1Property: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.noRdfTypeClassUnionMember1Property =
      parameters.noRdfTypeClassUnionMember1Property;
  }

  get $identifier(): NoRdfTypeClassUnionMember1.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: NoRdfTypeClassUnionMember1): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.noRdfTypeClassUnionMember1Property,
          other.noRdfTypeClassUnionMember1Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "noRdfTypeClassUnionMember1Property",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.noRdfTypeClassUnionMember1Property);
    return _hasher;
  }

  $toJson(): NoRdfTypeClassUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        noRdfTypeClassUnionMember1Property:
          this.noRdfTypeClassUnionMember1Property,
      } satisfies NoRdfTypeClassUnionMember1.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      NoRdfTypeClassUnionMember1.$properties.noRdfTypeClassUnionMember1Property[
        "identifier"
      ],
      ...[this.noRdfTypeClassUnionMember1Property],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace NoRdfTypeClassUnionMember1 {
  export function $filter(
    filter: NoRdfTypeClassUnionMember1.$Filter,
    value: NoRdfTypeClassUnionMember1,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.noRdfTypeClassUnionMember1Property !== "undefined" &&
      !$filterString(
        filter.noRdfTypeClassUnionMember1Property,
        value.noRdfTypeClassUnionMember1Property,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly noRdfTypeClassUnionMember1Property?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, NoRdfTypeClassUnionMember1> {
    return $propertiesFromJson(json).map(
      (properties) => new NoRdfTypeClassUnionMember1(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, NoRdfTypeClassUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return NoRdfTypeClassUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new NoRdfTypeClassUnionMember1(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "NoRdfTypeClassUnionMember1";
    readonly noRdfTypeClassUnionMember1Property: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "NoRdfTypeClassUnionMember1" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/noRdfTypeClassUnionMember1Property`,
          type: "Control",
        },
      ],
      label: "NoRdfTypeClassUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("NoRdfTypeClassUnionMember1"),
      noRdfTypeClassUnionMember1Property: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    noRdfTypeClassUnionMember1Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/noRdfTypeClassUnionMember1Property",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      noRdfTypeClassUnionMember1Property: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const noRdfTypeClassUnionMember1Property =
      $jsonObject["noRdfTypeClassUnionMember1Property"];
    return purify.Either.of({
      $identifier,
      noRdfTypeClassUnionMember1Property,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      noRdfTypeClassUnionMember1Property: string;
    }
  > {
    const $identifier: NoRdfTypeClassUnionMember1.$Identifier =
      $parameters.resource.identifier;
    const _noRdfTypeClassUnionMember1PropertyEither: purify.Either<
      Error,
      string
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.noRdfTypeClassUnionMember1Property["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        $fromRdfPreferredLanguages({
          focusResource: $parameters.resource,
          predicate:
            NoRdfTypeClassUnionMember1.$properties
              .noRdfTypeClassUnionMember1Property["identifier"],
          preferredLanguages: $parameters.preferredLanguages,
          values,
        }),
      )
      .chain((values) => values.chainMap((value) => value.toString()))
      .chain((values) => values.head());
    if (_noRdfTypeClassUnionMember1PropertyEither.isLeft()) {
      return _noRdfTypeClassUnionMember1PropertyEither;
    }

    const noRdfTypeClassUnionMember1Property =
      _noRdfTypeClassUnionMember1PropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      noRdfTypeClassUnionMember1Property,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: NoRdfTypeClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        NoRdfTypeClassUnionMember1.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            NoRdfTypeClassUnionMember1.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: NoRdfTypeClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      NoRdfTypeClassUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("noRdfTypeClassUnionMember1");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "noRdfTypeClassUnionMember1")}NoRdfTypeClassUnionMember1Property`,
      ),
      predicate:
        NoRdfTypeClassUnionMember1.$properties
          .noRdfTypeClassUnionMember1Property["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: NoRdfTypeClassUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("noRdfTypeClassUnionMember1");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "noRdfTypeClassUnionMember1")}NoRdfTypeClassUnionMember1Property`,
            ),
            predicate:
              NoRdfTypeClassUnionMember1.$properties
                .noRdfTypeClassUnionMember1Property["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "noRdfTypeClassUnionMember1")}NoRdfTypeClassUnionMember1Property`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.noRdfTypeClassUnionMember1Property,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "noRdfTypeClassUnionMember1")}NoRdfTypeClassUnionMember1Property`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
/**
 * Shape with shaclmate:mutable properties.
 */
export class MutablePropertiesClass {
  private _$identifier?: MutablePropertiesClass.$Identifier;
  protected readonly _$identifierPrefix?: string;
  readonly $type = "MutablePropertiesClass";
  /**
   * List-valued property that can't be reassigned but whose value can be mutated
   */
  readonly mutableListProperty: purify.Maybe<string[]>;
  /**
   * Set-valued property that can't be reassigned but whose value can be mutated
   */
  mutableSetProperty: string[];
  /**
   * String-valued property that can be re-assigned
   */
  mutableStringProperty: purify.Maybe<string>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly $identifierPrefix?: string;
    readonly mutableListProperty?: purify.Maybe<string[]> | readonly string[];
    readonly mutableSetProperty?: readonly string[];
    readonly mutableStringProperty?: purify.Maybe<string> | string;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    this._$identifierPrefix = parameters?.$identifierPrefix;
    if (purify.Maybe.isMaybe(parameters?.mutableListProperty)) {
      this.mutableListProperty = parameters?.mutableListProperty;
    } else if (typeof parameters?.mutableListProperty === "undefined") {
      this.mutableListProperty = purify.Maybe.of([]);
    } else if (typeof parameters?.mutableListProperty === "object") {
      this.mutableListProperty = purify.Maybe.of(
        parameters?.mutableListProperty.concat(),
      );
    } else {
      this.mutableListProperty =
        parameters?.mutableListProperty satisfies never;
    }

    if (typeof parameters?.mutableSetProperty === "undefined") {
      this.mutableSetProperty = [];
    } else if (typeof parameters?.mutableSetProperty === "object") {
      this.mutableSetProperty = parameters?.mutableSetProperty.concat();
    } else {
      this.mutableSetProperty = parameters?.mutableSetProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.mutableStringProperty)) {
      this.mutableStringProperty = parameters?.mutableStringProperty;
    } else if (typeof parameters?.mutableStringProperty === "string") {
      this.mutableStringProperty = purify.Maybe.of(
        parameters?.mutableStringProperty,
      );
    } else if (typeof parameters?.mutableStringProperty === "undefined") {
      this.mutableStringProperty = purify.Maybe.empty();
    } else {
      this.mutableStringProperty =
        parameters?.mutableStringProperty satisfies never;
    }
  }

  get $identifier(): MutablePropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      return dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }

    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  $equals(other: MutablePropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$identifierPrefix, other.$identifierPrefix).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$identifierPrefix",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) =>
            $arrayEquals(left, right, $strictEquals),
          ))(this.mutableListProperty, other.mutableListProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "mutableListProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $strictEquals))(
          this.mutableSetProperty,
          other.mutableSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "mutableSetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.mutableStringProperty,
          other.mutableStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "mutableStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.mutableListProperty.ifJust((value0) => {
      for (const item1 of value0) {
        _hasher.update(item1);
      }
    });
    for (const item0 of this.mutableSetProperty) {
      _hasher.update(item0);
    }

    this.mutableStringProperty.ifJust((value0) => {
      _hasher.update(value0);
    });
    return _hasher;
  }

  $toJson(): MutablePropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        mutableListProperty: this.mutableListProperty
          .map((item) => item.map((item) => item))
          .extract(),
        mutableSetProperty: this.mutableSetProperty.map((item) => item),
        mutableStringProperty: this.mutableStringProperty
          .map((item) => item)
          .extract(),
      } satisfies MutablePropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      MutablePropertiesClass.$properties.mutableListProperty["identifier"],
      ...this.mutableListProperty.toList().flatMap((value) => [
        value.length > 0
          ? value.reduce(
              (
                { currentSubListResource, listResource },
                item,
                itemIndex,
                list,
              ) => {
                if (itemIndex === 0) {
                  currentSubListResource = listResource;
                } else {
                  const newSubListResource = resourceSet.mutableResource(
                    dataFactory.blankNode(),
                    { mutateGraph },
                  );
                  currentSubListResource!.add(
                    $RdfVocabularies.rdf.rest,
                    newSubListResource.identifier,
                  );
                  currentSubListResource = newSubListResource;
                }

                currentSubListResource.add(
                  $RdfVocabularies.rdf.first,
                  ...[item],
                );

                if (itemIndex + 1 === list.length) {
                  currentSubListResource.add(
                    $RdfVocabularies.rdf.rest,
                    $RdfVocabularies.rdf.nil,
                  );
                }

                return { currentSubListResource, listResource };
              },
              {
                currentSubListResource: null,
                listResource: resourceSet.mutableResource(
                  dataFactory.blankNode(),
                  { mutateGraph },
                ),
              } as {
                currentSubListResource: rdfjsResource.MutableResource | null;
                listResource: rdfjsResource.MutableResource;
              },
            ).listResource.identifier
          : $RdfVocabularies.rdf.nil,
      ]),
    );
    resource.add(
      MutablePropertiesClass.$properties.mutableSetProperty["identifier"],
      ...this.mutableSetProperty.flatMap((item) => [item]),
    );
    resource.add(
      MutablePropertiesClass.$properties.mutableStringProperty["identifier"],
      ...this.mutableStringProperty.toList(),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace MutablePropertiesClass {
  export function $filter(
    filter: MutablePropertiesClass.$Filter,
    value: MutablePropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.mutableListProperty !== "undefined" &&
      !$filterMaybe<string[], $CollectionFilter<$StringFilter>>(
        $filterArray<string, $StringFilter>($filterString),
      )(filter.mutableListProperty, value.mutableListProperty)
    ) {
      return false;
    }

    if (
      typeof filter.mutableSetProperty !== "undefined" &&
      !$filterArray<string, $StringFilter>($filterString)(
        filter.mutableSetProperty,
        value.mutableSetProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.mutableStringProperty !== "undefined" &&
      !$filterMaybe<string, $StringFilter>($filterString)(
        filter.mutableStringProperty,
        value.mutableStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly mutableListProperty?: $MaybeFilter<
      $CollectionFilter<$StringFilter>
    >;
    readonly mutableSetProperty?: $CollectionFilter<$StringFilter>;
    readonly mutableStringProperty?: $MaybeFilter<$StringFilter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, MutablePropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new MutablePropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, MutablePropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return MutablePropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new MutablePropertiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "MutablePropertiesClass";
    readonly mutableListProperty?: readonly string[];
    readonly mutableSetProperty?: readonly string[];
    readonly mutableStringProperty?: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "MutablePropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/mutableListProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/mutableSetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/mutableStringProperty`,
          type: "Control",
        },
      ],
      label: "MutablePropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("MutablePropertiesClass"),
      mutableListProperty: zod
        .string()
        .array()
        .default(() => [])
        .optional()
        .describe(
          "List-valued property that can't be reassigned but whose value can be mutated",
        ),
      mutableSetProperty: zod
        .string()
        .array()
        .default(() => [])
        .describe(
          "Set-valued property that can't be reassigned but whose value can be mutated",
        ),
      mutableStringProperty: zod
        .string()
        .optional()
        .describe("String-valued property that can be re-assigned"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    mutableListProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/mutableListProperty",
      ),
    },
    mutableSetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/mutableSetProperty",
      ),
    },
    mutableStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/mutableStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      mutableListProperty: purify.Maybe<string[]>;
      mutableSetProperty: string[];
      mutableStringProperty: purify.Maybe<string>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const mutableListProperty = purify.Maybe.fromNullable(
      $jsonObject["mutableListProperty"],
    );
    const mutableSetProperty = $jsonObject["mutableSetProperty"];
    const mutableStringProperty = purify.Maybe.fromNullable(
      $jsonObject["mutableStringProperty"],
    );
    return purify.Either.of({
      $identifier,
      mutableListProperty,
      mutableSetProperty,
      mutableStringProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      mutableListProperty: purify.Maybe<string[]>;
      mutableSetProperty: string[];
      mutableStringProperty: purify.Maybe<string>;
    }
  > {
    const $identifier: MutablePropertiesClass.$Identifier =
      $parameters.resource.identifier;
    const _mutableListPropertyEither: purify.Either<
      Error,
      purify.Maybe<string[]>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.mutableListProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) => values.chainMap((value) => value.toList()))
      .chain((valueLists) =>
        valueLists.chainMap((valueList) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            rdfjsResource.Resource.Values.fromArray({
              focusResource: $parameters.resource,
              predicate:
                MutablePropertiesClass.$properties.mutableListProperty[
                  "identifier"
                ],
              values: valueList,
            }),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  MutablePropertiesClass.$properties.mutableListProperty[
                    "identifier"
                  ],
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString())),
        ),
      )
      .map((valueLists) =>
        valueLists.map((valueList) => valueList.toArray().concat()),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<string[]>>({
              focusResource: $parameters.resource,
              predicate:
                MutablePropertiesClass.$properties.mutableListProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_mutableListPropertyEither.isLeft()) {
      return _mutableListPropertyEither;
    }

    const mutableListProperty = _mutableListPropertyEither.unsafeCoerce();
    const _mutableSetPropertyEither: purify.Either<Error, string[]> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.mutableSetProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              MutablePropertiesClass.$properties.mutableSetProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .map((values) => values.toArray().concat())
        .map((valuesArray) =>
          rdfjsResource.Resource.Values.fromValue({
            focusResource: $parameters.resource,
            predicate:
              MutablePropertiesClass.$properties.mutableSetProperty[
                "identifier"
              ],
            value: valuesArray,
          }),
        )
        .chain((values) => values.head());
    if (_mutableSetPropertyEither.isLeft()) {
      return _mutableSetPropertyEither;
    }

    const mutableSetProperty = _mutableSetPropertyEither.unsafeCoerce();
    const _mutableStringPropertyEither: purify.Either<
      Error,
      purify.Maybe<string>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.mutableStringProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        $fromRdfPreferredLanguages({
          focusResource: $parameters.resource,
          predicate:
            MutablePropertiesClass.$properties.mutableStringProperty[
              "identifier"
            ],
          preferredLanguages: $parameters.preferredLanguages,
          values,
        }),
      )
      .chain((values) => values.chainMap((value) => value.toString()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<string>>({
              focusResource: $parameters.resource,
              predicate:
                MutablePropertiesClass.$properties.mutableStringProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_mutableStringPropertyEither.isLeft()) {
      return _mutableStringPropertyEither;
    }

    const mutableStringProperty = _mutableStringPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      mutableListProperty,
      mutableSetProperty,
      mutableStringProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: MutablePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        MutablePropertiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            MutablePropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: MutablePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      MutablePropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("mutablePropertiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`,
      ),
      predicate:
        MutablePropertiesClass.$properties.mutableListProperty["identifier"],
      subject,
    });
    triples.push({
      subject: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`,
      ),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}Item0`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`,
      ),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}Rest0`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}ItemN`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}RestNBasic`,
      ),
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableSetProperty`,
      ),
      predicate:
        MutablePropertiesClass.$properties.mutableSetProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableStringProperty`,
      ),
      predicate:
        MutablePropertiesClass.$properties.mutableStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: MutablePropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("mutablePropertiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.mutableListProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`,
                  ),
                  predicate:
                    MutablePropertiesClass.$properties.mutableListProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}Item0`,
                      ),
                      predicate: $RdfVocabularies.rdf.first,
                      subject: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`,
                      ),
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: [parameters?.preferredLanguages ?? []]
                    .filter((languages) => languages.length > 0)
                    .map((languages) =>
                      languages.map((language) => ({
                        type: "operation" as const,
                        operator: "=",
                        args: [
                          {
                            type: "operation" as const,
                            operator: "lang",
                            args: [
                              dataFactory.variable!(
                                `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}Item0`,
                              ),
                            ],
                          },
                          dataFactory.literal(language),
                        ],
                      })),
                    )
                    .map((langEqualsExpressions) => ({
                      type: "filter" as const,
                      expression: langEqualsExpressions.reduce(
                        (reducedExpression, langEqualsExpression) => {
                          if (reducedExpression === null) {
                            return langEqualsExpression;
                          }
                          return {
                            type: "operation" as const,
                            operator: "||",
                            args: [reducedExpression, langEqualsExpression],
                          };
                        },
                        null as sparqljs.Expression | null,
                      ) as sparqljs.Expression,
                    }))
                    .concat(),
                  type: "group",
                },
                {
                  patterns: $StringFilter
                    .$sparqlWherePatterns(
                      itemFilter,
                      dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}Item0`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}Rest0`,
                      ),
                      predicate: $RdfVocabularies.rdf.rest,
                      subject: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`,
                      ),
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}RestN`,
                          ),
                          predicate: {
                            type: "path",
                            pathType: "*",
                            items: [$RdfVocabularies.rdf.rest],
                          },
                          subject: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}ItemN`,
                          ),
                          predicate: $RdfVocabularies.rdf.first,
                          subject: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}RestN`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: [parameters?.preferredLanguages ?? []]
                        .filter((languages) => languages.length > 0)
                        .map((languages) =>
                          languages.map((language) => ({
                            type: "operation" as const,
                            operator: "=",
                            args: [
                              {
                                type: "operation" as const,
                                operator: "lang",
                                args: [
                                  dataFactory.variable!(
                                    `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}ItemN`,
                                  ),
                                ],
                              },
                              dataFactory.literal(language),
                            ],
                          })),
                        )
                        .map((langEqualsExpressions) => ({
                          type: "filter" as const,
                          expression: langEqualsExpressions.reduce(
                            (reducedExpression, langEqualsExpression) => {
                              if (reducedExpression === null) {
                                return langEqualsExpression;
                              }
                              return {
                                type: "operation" as const,
                                operator: "||",
                                args: [reducedExpression, langEqualsExpression],
                              };
                            },
                            null as sparqljs.Expression | null,
                          ) as sparqljs.Expression,
                        }))
                        .concat(),
                      type: "group",
                    },
                    {
                      patterns: $StringFilter
                        .$sparqlWherePatterns(
                          itemFilter,
                          dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}ItemN`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}RestNBasic`,
                          ),
                          predicate: $RdfVocabularies.rdf.rest,
                          subject: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableListProperty`}RestN`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                  ],
                  type: "optional",
                },
              ],
              type: "optional",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableSetProperty`,
              ),
              predicate:
                MutablePropertiesClass.$properties.mutableSetProperty[
                  "identifier"
                ],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: [parameters?.preferredLanguages ?? []]
            .filter((languages) => languages.length > 0)
            .map((languages) =>
              languages.map((language) => ({
                type: "operation" as const,
                operator: "=",
                args: [
                  {
                    type: "operation" as const,
                    operator: "lang",
                    args: [
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableSetProperty`,
                      ),
                    ],
                  },
                  dataFactory.literal(language),
                ],
              })),
            )
            .map((langEqualsExpressions) => ({
              type: "filter" as const,
              expression: langEqualsExpressions.reduce(
                (reducedExpression, langEqualsExpression) => {
                  if (reducedExpression === null) {
                    return langEqualsExpression;
                  }
                  return {
                    type: "operation" as const,
                    operator: "||",
                    args: [reducedExpression, langEqualsExpression],
                  };
                },
                null as sparqljs.Expression | null,
              ) as sparqljs.Expression,
            }))
            .concat(),
          type: "group",
        },
        {
          patterns: $StringFilter
            .$sparqlWherePatterns(
              parameters?.filter?.mutableSetProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableSetProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.mutableStringProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableStringProperty`,
                  ),
                  predicate:
                    MutablePropertiesClass.$properties.mutableStringProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [parameters?.preferredLanguages ?? []]
                .filter((languages) => languages.length > 0)
                .map((languages) =>
                  languages.map((language) => ({
                    type: "operation" as const,
                    operator: "=",
                    args: [
                      {
                        type: "operation" as const,
                        operator: "lang",
                        args: [
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableStringProperty`,
                          ),
                        ],
                      },
                      dataFactory.literal(language),
                    ],
                  })),
                )
                .map((langEqualsExpressions) => ({
                  type: "filter" as const,
                  expression: langEqualsExpressions.reduce(
                    (reducedExpression, langEqualsExpression) => {
                      if (reducedExpression === null) {
                        return langEqualsExpression;
                      }
                      return {
                        type: "operation" as const,
                        operator: "||",
                        args: [reducedExpression, langEqualsExpression],
                      };
                    },
                    null as sparqljs.Expression | null,
                  ) as sparqljs.Expression,
                }))
                .concat(),
              type: "group",
            },
            {
              patterns: $StringFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "mutablePropertiesClass")}MutableStringProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    return patterns;
  }
}
/**
 * Shape that uses the list shapes in properties.
 */
export class ListPropertiesClass {
  private _$identifier?: ListPropertiesClass.$Identifier;
  readonly $type = "ListPropertiesClass";
  readonly iriListProperty: purify.Maybe<readonly rdfjs.NamedNode[]>;
  readonly objectListProperty: purify.Maybe<readonly NonClass[]>;
  readonly stringListProperty: purify.Maybe<readonly string[]>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly iriListProperty?:
      | purify.Maybe<readonly rdfjs.NamedNode[]>
      | readonly rdfjs.NamedNode[]
      | readonly string[];
    readonly objectListProperty?:
      | purify.Maybe<readonly NonClass[]>
      | readonly NonClass[];
    readonly stringListProperty?:
      | purify.Maybe<readonly string[]>
      | readonly string[];
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.iriListProperty)) {
      this.iriListProperty = parameters?.iriListProperty;
    } else if (typeof parameters?.iriListProperty === "undefined") {
      this.iriListProperty = purify.Maybe.of([]);
    } else if ($isReadonlyObjectArray(parameters?.iriListProperty)) {
      this.iriListProperty = purify.Maybe.of(parameters?.iriListProperty);
    } else if ($isReadonlyStringArray(parameters?.iriListProperty)) {
      this.iriListProperty = purify.Maybe.of(
        parameters?.iriListProperty.map((item) => dataFactory.namedNode(item)),
      );
    } else {
      this.iriListProperty = parameters?.iriListProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.objectListProperty)) {
      this.objectListProperty = parameters?.objectListProperty;
    } else if (typeof parameters?.objectListProperty === "undefined") {
      this.objectListProperty = purify.Maybe.of([]);
    } else if (typeof parameters?.objectListProperty === "object") {
      this.objectListProperty = purify.Maybe.of(parameters?.objectListProperty);
    } else {
      this.objectListProperty = parameters?.objectListProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.stringListProperty)) {
      this.stringListProperty = parameters?.stringListProperty;
    } else if (typeof parameters?.stringListProperty === "undefined") {
      this.stringListProperty = purify.Maybe.of([]);
    } else if (typeof parameters?.stringListProperty === "object") {
      this.stringListProperty = purify.Maybe.of(parameters?.stringListProperty);
    } else {
      this.stringListProperty = parameters?.stringListProperty satisfies never;
    }
  }

  get $identifier(): ListPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: ListPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) =>
            $arrayEquals(left, right, $booleanEquals),
          ))(this.iriListProperty, other.iriListProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "iriListProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) =>
            $arrayEquals(left, right, (left, right) => left.$equals(right)),
          ))(this.objectListProperty, other.objectListProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "objectListProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) =>
            $arrayEquals(left, right, $strictEquals),
          ))(this.stringListProperty, other.stringListProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "stringListProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.iriListProperty.ifJust((value0) => {
      for (const item1 of value0) {
        _hasher.update(item1.termType);
        _hasher.update(item1.value);
      }
    });
    this.objectListProperty.ifJust((value0) => {
      for (const item1 of value0) {
        item1.$hash(_hasher);
      }
    });
    this.stringListProperty.ifJust((value0) => {
      for (const item1 of value0) {
        _hasher.update(item1);
      }
    });
    return _hasher;
  }

  $toJson(): ListPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        iriListProperty: this.iriListProperty
          .map((item) => item.map((item) => ({ "@id": item.value })))
          .extract(),
        objectListProperty: this.objectListProperty
          .map((item) => item.map((item) => item.$toJson()))
          .extract(),
        stringListProperty: this.stringListProperty
          .map((item) => item.map((item) => item))
          .extract(),
      } satisfies ListPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      ListPropertiesClass.$properties.iriListProperty["identifier"],
      ...this.iriListProperty.toList().flatMap((value) => [
        value.length > 0
          ? value.reduce(
              (
                { currentSubListResource, listResource },
                item,
                itemIndex,
                list,
              ) => {
                if (itemIndex === 0) {
                  currentSubListResource = listResource;
                } else {
                  const newSubListResource = resourceSet.mutableResource(
                    dataFactory.blankNode(),
                    { mutateGraph },
                  );
                  currentSubListResource!.add(
                    $RdfVocabularies.rdf.rest,
                    newSubListResource.identifier,
                  );
                  currentSubListResource = newSubListResource;
                }

                currentSubListResource.add(
                  $RdfVocabularies.rdf.first,
                  ...[item],
                );

                if (itemIndex + 1 === list.length) {
                  currentSubListResource.add(
                    $RdfVocabularies.rdf.rest,
                    $RdfVocabularies.rdf.nil,
                  );
                }

                return { currentSubListResource, listResource };
              },
              {
                currentSubListResource: null,
                listResource: resourceSet.mutableResource(
                  dataFactory.blankNode(),
                  { mutateGraph },
                ),
              } as {
                currentSubListResource: rdfjsResource.MutableResource | null;
                listResource: rdfjsResource.MutableResource;
              },
            ).listResource.identifier
          : $RdfVocabularies.rdf.nil,
      ]),
    );
    resource.add(
      ListPropertiesClass.$properties.objectListProperty["identifier"],
      ...this.objectListProperty.toList().flatMap((value) => [
        value.length > 0
          ? value.reduce(
              (
                { currentSubListResource, listResource },
                item,
                itemIndex,
                list,
              ) => {
                if (itemIndex === 0) {
                  currentSubListResource = listResource;
                } else {
                  const newSubListResource = resourceSet.mutableResource(
                    dataFactory.blankNode(),
                    { mutateGraph },
                  );
                  currentSubListResource!.add(
                    $RdfVocabularies.rdf.rest,
                    newSubListResource.identifier,
                  );
                  currentSubListResource = newSubListResource;
                }

                currentSubListResource.add(
                  $RdfVocabularies.rdf.first,
                  ...[
                    item.$toRdf({
                      mutateGraph: mutateGraph,
                      resourceSet: resourceSet,
                    }).identifier,
                  ],
                );

                if (itemIndex + 1 === list.length) {
                  currentSubListResource.add(
                    $RdfVocabularies.rdf.rest,
                    $RdfVocabularies.rdf.nil,
                  );
                }

                return { currentSubListResource, listResource };
              },
              {
                currentSubListResource: null,
                listResource: resourceSet.mutableResource(
                  dataFactory.blankNode(),
                  { mutateGraph },
                ),
              } as {
                currentSubListResource: rdfjsResource.MutableResource | null;
                listResource: rdfjsResource.MutableResource;
              },
            ).listResource.identifier
          : $RdfVocabularies.rdf.nil,
      ]),
    );
    resource.add(
      ListPropertiesClass.$properties.stringListProperty["identifier"],
      ...this.stringListProperty.toList().flatMap((value) => [
        value.length > 0
          ? value.reduce(
              (
                { currentSubListResource, listResource },
                item,
                itemIndex,
                list,
              ) => {
                if (itemIndex === 0) {
                  currentSubListResource = listResource;
                } else {
                  const newSubListResource = resourceSet.mutableResource(
                    dataFactory.blankNode(),
                    { mutateGraph },
                  );
                  currentSubListResource!.add(
                    $RdfVocabularies.rdf.rest,
                    newSubListResource.identifier,
                  );
                  currentSubListResource = newSubListResource;
                }

                currentSubListResource.add(
                  $RdfVocabularies.rdf.first,
                  ...[item],
                );

                if (itemIndex + 1 === list.length) {
                  currentSubListResource.add(
                    $RdfVocabularies.rdf.rest,
                    $RdfVocabularies.rdf.nil,
                  );
                }

                return { currentSubListResource, listResource };
              },
              {
                currentSubListResource: null,
                listResource: resourceSet.mutableResource(
                  dataFactory.blankNode(),
                  { mutateGraph },
                ),
              } as {
                currentSubListResource: rdfjsResource.MutableResource | null;
                listResource: rdfjsResource.MutableResource;
              },
            ).listResource.identifier
          : $RdfVocabularies.rdf.nil,
      ]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ListPropertiesClass {
  export function $filter(
    filter: ListPropertiesClass.$Filter,
    value: ListPropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.iriListProperty !== "undefined" &&
      !$filterMaybe<
        readonly rdfjs.NamedNode[],
        $CollectionFilter<$NamedNodeFilter>
      >($filterArray<rdfjs.NamedNode, $NamedNodeFilter>($filterNamedNode))(
        filter.iriListProperty,
        value.iriListProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.objectListProperty !== "undefined" &&
      !$filterMaybe<readonly NonClass[], $CollectionFilter<NonClass.$Filter>>(
        $filterArray<NonClass, NonClass.$Filter>(NonClass.$filter),
      )(filter.objectListProperty, value.objectListProperty)
    ) {
      return false;
    }

    if (
      typeof filter.stringListProperty !== "undefined" &&
      !$filterMaybe<readonly string[], $CollectionFilter<$StringFilter>>(
        $filterArray<string, $StringFilter>($filterString),
      )(filter.stringListProperty, value.stringListProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly iriListProperty?: $MaybeFilter<
      $CollectionFilter<$NamedNodeFilter>
    >;
    readonly objectListProperty?: $MaybeFilter<
      $CollectionFilter<NonClass.$Filter>
    >;
    readonly stringListProperty?: $MaybeFilter<
      $CollectionFilter<$StringFilter>
    >;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ListPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ListPropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ListPropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ListPropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ListPropertiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ListPropertiesClass";
    readonly iriListProperty?: readonly { readonly "@id": string }[];
    readonly objectListProperty?: readonly NonClass.$Json[];
    readonly stringListProperty?: readonly string[];
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ListPropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/iriListProperty`, type: "Control" },
        NonClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/objectListProperty`,
        }),
        {
          scope: `${scopePrefix}/properties/stringListProperty`,
          type: "Control",
        },
      ],
      label: "ListPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("ListPropertiesClass"),
      iriListProperty: zod
        .object({ "@id": zod.string().min(1) })
        .array()
        .default(() => [])
        .optional(),
      objectListProperty: NonClass.$jsonZodSchema()
        .array()
        .default(() => [])
        .optional(),
      stringListProperty: zod
        .string()
        .array()
        .default(() => [])
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    iriListProperty: {
      identifier: dataFactory.namedNode("http://example.com/iriListProperty"),
    },
    objectListProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/objectListProperty",
      ),
    },
    stringListProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/stringListProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      iriListProperty: purify.Maybe<readonly rdfjs.NamedNode[]>;
      objectListProperty: purify.Maybe<readonly NonClass[]>;
      stringListProperty: purify.Maybe<readonly string[]>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const iriListProperty = purify.Maybe.fromNullable(
      $jsonObject["iriListProperty"],
    ).map((item) => item.map((item) => dataFactory.namedNode(item["@id"])));
    const objectListProperty = purify.Maybe.fromNullable(
      $jsonObject["objectListProperty"],
    ).map((item) =>
      item.map((item) => NonClass.$fromJson(item).unsafeCoerce()),
    );
    const stringListProperty = purify.Maybe.fromNullable(
      $jsonObject["stringListProperty"],
    );
    return purify.Either.of({
      $identifier,
      iriListProperty,
      objectListProperty,
      stringListProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      iriListProperty: purify.Maybe<readonly rdfjs.NamedNode[]>;
      objectListProperty: purify.Maybe<readonly NonClass[]>;
      stringListProperty: purify.Maybe<readonly string[]>;
    }
  > {
    const $identifier: ListPropertiesClass.$Identifier =
      $parameters.resource.identifier;
    const _iriListPropertyEither: purify.Either<
      Error,
      purify.Maybe<readonly rdfjs.NamedNode[]>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values($properties.iriListProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) => values.chainMap((value) => value.toList()))
      .chain((valueLists) =>
        valueLists.chainMap((valueList) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            rdfjsResource.Resource.Values.fromArray({
              focusResource: $parameters.resource,
              predicate:
                ListPropertiesClass.$properties.iriListProperty["identifier"],
              values: valueList,
            }),
          ).chain((values) => values.chainMap((value) => value.toIri())),
        ),
      )
      .map((valueLists) => valueLists.map((valueList) => valueList.toArray()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<readonly rdfjs.NamedNode[]>
            >({
              focusResource: $parameters.resource,
              predicate:
                ListPropertiesClass.$properties.iriListProperty["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_iriListPropertyEither.isLeft()) {
      return _iriListPropertyEither;
    }

    const iriListProperty = _iriListPropertyEither.unsafeCoerce();
    const _objectListPropertyEither: purify.Either<
      Error,
      purify.Maybe<readonly NonClass[]>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.objectListProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) => values.chainMap((value) => value.toList()))
      .chain((valueLists) =>
        valueLists.chainMap((valueList) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            rdfjsResource.Resource.Values.fromArray({
              focusResource: $parameters.resource,
              predicate:
                ListPropertiesClass.$properties.objectListProperty[
                  "identifier"
                ],
              values: valueList,
            }),
          ).chain((values) =>
            values.chainMap((value) =>
              value.toResource().chain((resource) =>
                NonClass.$fromRdf(resource, {
                  context: $parameters.context,
                  ignoreRdfType: true,
                  objectSet: $parameters.objectSet,
                  preferredLanguages: $parameters.preferredLanguages,
                }),
              ),
            ),
          ),
        ),
      )
      .map((valueLists) => valueLists.map((valueList) => valueList.toArray()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<readonly NonClass[]>
            >({
              focusResource: $parameters.resource,
              predicate:
                ListPropertiesClass.$properties.objectListProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_objectListPropertyEither.isLeft()) {
      return _objectListPropertyEither;
    }

    const objectListProperty = _objectListPropertyEither.unsafeCoerce();
    const _stringListPropertyEither: purify.Either<
      Error,
      purify.Maybe<readonly string[]>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.stringListProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) => values.chainMap((value) => value.toList()))
      .chain((valueLists) =>
        valueLists.chainMap((valueList) =>
          purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(
            rdfjsResource.Resource.Values.fromArray({
              focusResource: $parameters.resource,
              predicate:
                ListPropertiesClass.$properties.stringListProperty[
                  "identifier"
                ],
              values: valueList,
            }),
          )
            .chain((values) =>
              $fromRdfPreferredLanguages({
                focusResource: $parameters.resource,
                predicate:
                  ListPropertiesClass.$properties.stringListProperty[
                    "identifier"
                  ],
                preferredLanguages: $parameters.preferredLanguages,
                values,
              }),
            )
            .chain((values) => values.chainMap((value) => value.toString())),
        ),
      )
      .map((valueLists) => valueLists.map((valueList) => valueList.toArray()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<readonly string[]>
            >({
              focusResource: $parameters.resource,
              predicate:
                ListPropertiesClass.$properties.stringListProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_stringListPropertyEither.isLeft()) {
      return _stringListPropertyEither;
    }

    const stringListProperty = _stringListPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      iriListProperty,
      objectListProperty,
      stringListProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ListPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ListPropertiesClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ListPropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ListPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ListPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("listPropertiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`,
      ),
      predicate: ListPropertiesClass.$properties.iriListProperty["identifier"],
      subject,
    });
    triples.push({
      subject: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`,
      ),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}Item0`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`,
      ),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}Rest0`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}ItemN`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}RestNBasic`,
      ),
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`,
      ),
      predicate:
        ListPropertiesClass.$properties.objectListProperty["identifier"],
      subject,
    });
    triples.push({
      subject: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`,
      ),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}Item0`,
      ),
    });
    triples.push(
      ...NonClass.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}Item0`,
        ),
        variablePrefix: `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}Item0`,
      }),
    );
    triples.push({
      subject: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`,
      ),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}Rest0`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}ItemN`,
      ),
    });
    triples.push(
      ...NonClass.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}ItemN`,
        ),
        variablePrefix: `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}ItemN`,
      }),
    );
    triples.push({
      subject: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}RestNBasic`,
      ),
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`,
      ),
      predicate:
        ListPropertiesClass.$properties.stringListProperty["identifier"],
      subject,
    });
    triples.push({
      subject: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`,
      ),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}Item0`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`,
      ),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}Rest0`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.first,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}ItemN`,
      ),
    });
    triples.push({
      subject: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}RestN`,
      ),
      predicate: $RdfVocabularies.rdf.rest,
      object: dataFactory.variable!(
        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}RestNBasic`,
      ),
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ListPropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("listPropertiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.iriListProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`,
                  ),
                  predicate:
                    ListPropertiesClass.$properties.iriListProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}Item0`,
                      ),
                      predicate: $RdfVocabularies.rdf.first,
                      subject: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`,
                      ),
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: $NamedNodeFilter
                    .$sparqlWherePatterns(
                      itemFilter,
                      dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}Item0`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}Rest0`,
                      ),
                      predicate: $RdfVocabularies.rdf.rest,
                      subject: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`,
                      ),
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}RestN`,
                          ),
                          predicate: {
                            type: "path",
                            pathType: "*",
                            items: [$RdfVocabularies.rdf.rest],
                          },
                          subject: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}ItemN`,
                          ),
                          predicate: $RdfVocabularies.rdf.first,
                          subject: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}RestN`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: $NamedNodeFilter
                        .$sparqlWherePatterns(
                          itemFilter,
                          dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}ItemN`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}RestNBasic`,
                          ),
                          predicate: $RdfVocabularies.rdf.rest,
                          subject: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}IriListProperty`}RestN`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                  ],
                  type: "optional",
                },
              ],
              type: "optional",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.objectListProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`,
                  ),
                  predicate:
                    ListPropertiesClass.$properties.objectListProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}Item0`,
                      ),
                      predicate: $RdfVocabularies.rdf.first,
                      subject: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`,
                      ),
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: NonClass.$sparqlWherePatterns({
                    filter: itemFilter,
                    ignoreRdfType: true,
                    preferredLanguages: parameters?.preferredLanguages,
                    subject: dataFactory.variable!(
                      `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}Item0`,
                    ),
                    variablePrefix: `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}Item0`,
                  }).concat(),
                  type: "group",
                },
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}Rest0`,
                      ),
                      predicate: $RdfVocabularies.rdf.rest,
                      subject: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`,
                      ),
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}RestN`,
                          ),
                          predicate: {
                            type: "path",
                            pathType: "*",
                            items: [$RdfVocabularies.rdf.rest],
                          },
                          subject: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}ItemN`,
                          ),
                          predicate: $RdfVocabularies.rdf.first,
                          subject: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}RestN`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: NonClass.$sparqlWherePatterns({
                        filter: itemFilter,
                        ignoreRdfType: true,
                        preferredLanguages: parameters?.preferredLanguages,
                        subject: dataFactory.variable!(
                          `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}ItemN`,
                        ),
                        variablePrefix: `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}ItemN`,
                      }).concat(),
                      type: "group",
                    },
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}RestNBasic`,
                          ),
                          predicate: $RdfVocabularies.rdf.rest,
                          subject: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}ObjectListProperty`}RestN`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                  ],
                  type: "optional",
                },
              ],
              type: "optional",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.stringListProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`,
                  ),
                  predicate:
                    ListPropertiesClass.$properties.stringListProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}Item0`,
                      ),
                      predicate: $RdfVocabularies.rdf.first,
                      subject: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`,
                      ),
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: [parameters?.preferredLanguages ?? []]
                    .filter((languages) => languages.length > 0)
                    .map((languages) =>
                      languages.map((language) => ({
                        type: "operation" as const,
                        operator: "=",
                        args: [
                          {
                            type: "operation" as const,
                            operator: "lang",
                            args: [
                              dataFactory.variable!(
                                `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}Item0`,
                              ),
                            ],
                          },
                          dataFactory.literal(language),
                        ],
                      })),
                    )
                    .map((langEqualsExpressions) => ({
                      type: "filter" as const,
                      expression: langEqualsExpressions.reduce(
                        (reducedExpression, langEqualsExpression) => {
                          if (reducedExpression === null) {
                            return langEqualsExpression;
                          }
                          return {
                            type: "operation" as const,
                            operator: "||",
                            args: [reducedExpression, langEqualsExpression],
                          };
                        },
                        null as sparqljs.Expression | null,
                      ) as sparqljs.Expression,
                    }))
                    .concat(),
                  type: "group",
                },
                {
                  patterns: $StringFilter
                    .$sparqlWherePatterns(
                      itemFilter,
                      dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}Item0`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}Rest0`,
                      ),
                      predicate: $RdfVocabularies.rdf.rest,
                      subject: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`,
                      ),
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}RestN`,
                          ),
                          predicate: {
                            type: "path",
                            pathType: "*",
                            items: [$RdfVocabularies.rdf.rest],
                          },
                          subject: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}ItemN`,
                          ),
                          predicate: $RdfVocabularies.rdf.first,
                          subject: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}RestN`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: [parameters?.preferredLanguages ?? []]
                        .filter((languages) => languages.length > 0)
                        .map((languages) =>
                          languages.map((language) => ({
                            type: "operation" as const,
                            operator: "=",
                            args: [
                              {
                                type: "operation" as const,
                                operator: "lang",
                                args: [
                                  dataFactory.variable!(
                                    `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}ItemN`,
                                  ),
                                ],
                              },
                              dataFactory.literal(language),
                            ],
                          })),
                        )
                        .map((langEqualsExpressions) => ({
                          type: "filter" as const,
                          expression: langEqualsExpressions.reduce(
                            (reducedExpression, langEqualsExpression) => {
                              if (reducedExpression === null) {
                                return langEqualsExpression;
                              }
                              return {
                                type: "operation" as const,
                                operator: "||",
                                args: [reducedExpression, langEqualsExpression],
                              };
                            },
                            null as sparqljs.Expression | null,
                          ) as sparqljs.Expression,
                        }))
                        .concat(),
                      type: "group",
                    },
                    {
                      patterns: $StringFilter
                        .$sparqlWherePatterns(
                          itemFilter,
                          dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}ItemN`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}RestNBasic`,
                          ),
                          predicate: $RdfVocabularies.rdf.rest,
                          subject: dataFactory.variable!(
                            `${`${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "listPropertiesClass")}StringListProperty`}RestN`,
                          ),
                        },
                      ],
                      type: "bgp",
                    },
                  ],
                  type: "optional",
                },
              ],
              type: "optional",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    return patterns;
  }
}
/**
 * Node shape used as a partial by LazyPropertiesInterface
 */
export interface PartialInterface {
  readonly $identifier: PartialInterface.$Identifier;
  readonly $type: "PartialInterface";
  readonly lazilyResolvedStringProperty: string;
}

export namespace PartialInterface {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): PartialInterface {
    let $identifier: PartialInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "PartialInterface" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: PartialInterface,
    right: PartialInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export function $filter(
    filter: PartialInterface.$Filter,
    value: PartialInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialInterface> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PartialInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_partialInterface: PartialInterface, _hasher: HasherT): HasherT {
    _hasher.update(_partialInterface.$identifier.value);
    _hasher.update(_partialInterface.$type);
    PartialInterface.$hashShaclProperties(_partialInterface, _hasher);
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_partialInterface: PartialInterface, _hasher: HasherT): HasherT {
    _hasher.update(_partialInterface.lazilyResolvedStringProperty);
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialInterface";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialInterface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialInterface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PartialInterface"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "PartialInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "PartialInterface" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "PartialInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $identifier: PartialInterface.$Identifier =
      $parameters.resource.identifier;
    const $type = "PartialInterface" as const;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              PartialInterface.$properties.lazilyResolvedStringProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialInterface.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            PartialInterface.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialInterface");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterface")}LazilyResolvedStringProperty`,
      ),
      predicate:
        PartialInterface.$properties.lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialInterface");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterface")}LazilyResolvedStringProperty`,
            ),
            predicate:
              PartialInterface.$properties.lazilyResolvedStringProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterface")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialInterface")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _partialInterface: PartialInterface,
  ): PartialInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _partialInterface.$identifier.termType === "BlankNode"
            ? `_:${_partialInterface.$identifier.value}`
            : _partialInterface.$identifier.value,
        $type: _partialInterface.$type,
        lazilyResolvedStringProperty:
          _partialInterface.lazilyResolvedStringProperty,
      } satisfies PartialInterface.$Json),
    );
  }

  export function $toRdf(
    _partialInterface: PartialInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _partialInterface.$identifier,
      { mutateGraph },
    );
    resource.add(
      PartialInterface.$properties.lazilyResolvedStringProperty["identifier"],
      ...[_partialInterface.lazilyResolvedStringProperty],
    );
    return resource;
  }
}
/**
 * Node shape that has lazy properties.
 */
export interface LazyPropertiesInterface {
  readonly $identifier: LazyPropertiesInterface.$Identifier;
  readonly $type: "LazyPropertiesInterface";
  readonly optionalLazyToResolvedInterfaceProperty: $LazyObjectOption<
    LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriIdentifierInterface
  >;
  readonly optionalLazyToResolvedInterfaceUnionProperty: $LazyObjectOption<
    LazilyResolvedInterfaceUnion.$Identifier,
    $DefaultPartial,
    LazilyResolvedInterfaceUnion
  >;
  readonly optionalLazyToResolvedIriIdentifierInterfaceProperty: $LazyObjectOption<
    LazilyResolvedIriIdentifierInterface.$Identifier,
    $NamedDefaultPartial,
    LazilyResolvedIriIdentifierInterface
  >;
  readonly optionalPartialInterfaceToResolvedInterfaceProperty: $LazyObjectOption<
    LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
    PartialInterface,
    LazilyResolvedBlankNodeOrIriIdentifierInterface
  >;
  readonly optionalPartialInterfaceToResolvedInterfaceUnionProperty: $LazyObjectOption<
    LazilyResolvedInterfaceUnion.$Identifier,
    PartialInterface,
    LazilyResolvedInterfaceUnion
  >;
  readonly optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty: $LazyObjectOption<
    LazilyResolvedInterfaceUnion.$Identifier,
    PartialInterfaceUnion,
    LazilyResolvedInterfaceUnion
  >;
  readonly requiredLazyToResolvedInterfaceProperty: $LazyObject<
    LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriIdentifierInterface
  >;
  readonly requiredPartialInterfaceToResolvedInterfaceProperty: $LazyObject<
    LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
    PartialInterface,
    LazilyResolvedBlankNodeOrIriIdentifierInterface
  >;
  readonly setLazyToResolvedInterfaceProperty: $LazyObjectSet<
    LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriIdentifierInterface
  >;
  readonly setPartialInterfaceToResolvedInterfaceProperty: $LazyObjectSet<
    LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
    PartialInterface,
    LazilyResolvedBlankNodeOrIriIdentifierInterface
  >;
}

export namespace LazyPropertiesInterface {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly optionalLazyToResolvedInterfaceProperty?:
      | $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >
      | LazilyResolvedBlankNodeOrIriIdentifierInterface
      | purify.Maybe<LazilyResolvedBlankNodeOrIriIdentifierInterface>;
    readonly optionalLazyToResolvedInterfaceUnionProperty?:
      | $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          $DefaultPartial,
          LazilyResolvedInterfaceUnion
        >
      | LazilyResolvedInterfaceUnion
      | purify.Maybe<LazilyResolvedInterfaceUnion>;
    readonly optionalLazyToResolvedIriIdentifierInterfaceProperty?:
      | $LazyObjectOption<
          LazilyResolvedIriIdentifierInterface.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierInterface
        >
      | LazilyResolvedIriIdentifierInterface
      | purify.Maybe<LazilyResolvedIriIdentifierInterface>;
    readonly optionalPartialInterfaceToResolvedInterfaceProperty?:
      | $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >
      | LazilyResolvedBlankNodeOrIriIdentifierInterface
      | purify.Maybe<LazilyResolvedBlankNodeOrIriIdentifierInterface>;
    readonly optionalPartialInterfaceToResolvedInterfaceUnionProperty?:
      | $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterface,
          LazilyResolvedInterfaceUnion
        >
      | LazilyResolvedInterfaceUnion
      | purify.Maybe<LazilyResolvedInterfaceUnion>;
    readonly optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty?:
      | $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterfaceUnion,
          LazilyResolvedInterfaceUnion
        >
      | LazilyResolvedInterfaceUnion
      | purify.Maybe<LazilyResolvedInterfaceUnion>;
    readonly requiredLazyToResolvedInterfaceProperty:
      | $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >
      | LazilyResolvedBlankNodeOrIriIdentifierInterface;
    readonly requiredPartialInterfaceToResolvedInterfaceProperty:
      | $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >
      | LazilyResolvedBlankNodeOrIriIdentifierInterface;
    readonly setLazyToResolvedInterfaceProperty?:
      | $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >
      | readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[];
    readonly setPartialInterfaceToResolvedInterfaceProperty?:
      | $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >
      | readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[];
  }): LazyPropertiesInterface {
    let $identifier: LazyPropertiesInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "LazyPropertiesInterface" as const;
    let optionalLazyToResolvedInterfaceProperty: $LazyObjectOption<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >;
    if (
      typeof parameters.optionalLazyToResolvedInterfaceProperty === "object" &&
      parameters.optionalLazyToResolvedInterfaceProperty instanceof
        $LazyObjectOption
    ) {
      optionalLazyToResolvedInterfaceProperty =
        parameters.optionalLazyToResolvedInterfaceProperty;
    } else if (
      purify.Maybe.isMaybe(parameters.optionalLazyToResolvedInterfaceProperty)
    ) {
      optionalLazyToResolvedInterfaceProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partial: parameters.optionalLazyToResolvedInterfaceProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          purify.Either.of(
            (
              parameters.optionalLazyToResolvedInterfaceProperty as purify.Maybe<LazilyResolvedBlankNodeOrIriIdentifierInterface>
            ).unsafeCoerce(),
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedInterfaceProperty === "object"
    ) {
      optionalLazyToResolvedInterfaceProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partial: purify.Maybe.of(
          new $DefaultPartial(
            parameters.optionalLazyToResolvedInterfaceProperty,
          ),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.optionalLazyToResolvedInterfaceProperty as LazilyResolvedBlankNodeOrIriIdentifierInterface,
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedInterfaceProperty === "undefined"
    ) {
      optionalLazyToResolvedInterfaceProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partial: purify.Maybe.empty(),
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      optionalLazyToResolvedInterfaceProperty =
        parameters.optionalLazyToResolvedInterfaceProperty satisfies never;
    }

    let optionalLazyToResolvedInterfaceUnionProperty: $LazyObjectOption<
      LazilyResolvedInterfaceUnion.$Identifier,
      $DefaultPartial,
      LazilyResolvedInterfaceUnion
    >;
    if (
      typeof parameters.optionalLazyToResolvedInterfaceUnionProperty ===
        "object" &&
      parameters.optionalLazyToResolvedInterfaceUnionProperty instanceof
        $LazyObjectOption
    ) {
      optionalLazyToResolvedInterfaceUnionProperty =
        parameters.optionalLazyToResolvedInterfaceUnionProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalLazyToResolvedInterfaceUnionProperty,
      )
    ) {
      optionalLazyToResolvedInterfaceUnionProperty = new $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >({
        partial: parameters.optionalLazyToResolvedInterfaceUnionProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          purify.Either.of(
            (
              parameters.optionalLazyToResolvedInterfaceUnionProperty as purify.Maybe<LazilyResolvedInterfaceUnion>
            ).unsafeCoerce(),
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedInterfaceUnionProperty ===
      "object"
    ) {
      optionalLazyToResolvedInterfaceUnionProperty = new $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >({
        partial: purify.Maybe.of(
          new $DefaultPartial(
            parameters.optionalLazyToResolvedInterfaceUnionProperty,
          ),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.optionalLazyToResolvedInterfaceUnionProperty as LazilyResolvedInterfaceUnion,
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedInterfaceUnionProperty ===
      "undefined"
    ) {
      optionalLazyToResolvedInterfaceUnionProperty = new $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >({
        partial: purify.Maybe.empty(),
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      optionalLazyToResolvedInterfaceUnionProperty =
        parameters.optionalLazyToResolvedInterfaceUnionProperty satisfies never;
    }

    let optionalLazyToResolvedIriIdentifierInterfaceProperty: $LazyObjectOption<
      LazilyResolvedIriIdentifierInterface.$Identifier,
      $NamedDefaultPartial,
      LazilyResolvedIriIdentifierInterface
    >;
    if (
      typeof parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty ===
        "object" &&
      parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty instanceof
        $LazyObjectOption
    ) {
      optionalLazyToResolvedIriIdentifierInterfaceProperty =
        parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty,
      )
    ) {
      optionalLazyToResolvedIriIdentifierInterfaceProperty =
        new $LazyObjectOption<
          LazilyResolvedIriIdentifierInterface.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierInterface
        >({
          partial:
            parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty.map(
              (object) => new $NamedDefaultPartial(object),
            ),
          resolver: async () =>
            purify.Either.of(
              (
                parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty as purify.Maybe<LazilyResolvedIriIdentifierInterface>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty ===
      "object"
    ) {
      optionalLazyToResolvedIriIdentifierInterfaceProperty =
        new $LazyObjectOption<
          LazilyResolvedIriIdentifierInterface.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierInterface
        >({
          partial: purify.Maybe.of(
            new $NamedDefaultPartial(
              parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty,
            ),
          ),
          resolver: async () =>
            purify.Either.of(
              parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty as LazilyResolvedIriIdentifierInterface,
            ),
        });
    } else if (
      typeof parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty ===
      "undefined"
    ) {
      optionalLazyToResolvedIriIdentifierInterfaceProperty =
        new $LazyObjectOption<
          LazilyResolvedIriIdentifierInterface.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierInterface
        >({
          partial: purify.Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      optionalLazyToResolvedIriIdentifierInterfaceProperty =
        parameters.optionalLazyToResolvedIriIdentifierInterfaceProperty satisfies never;
    }

    let optionalPartialInterfaceToResolvedInterfaceProperty: $LazyObjectOption<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      PartialInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >;
    if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceProperty ===
        "object" &&
      parameters.optionalPartialInterfaceToResolvedInterfaceProperty instanceof
        $LazyObjectOption
    ) {
      optionalPartialInterfaceToResolvedInterfaceProperty =
        parameters.optionalPartialInterfaceToResolvedInterfaceProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalPartialInterfaceToResolvedInterfaceProperty,
      )
    ) {
      optionalPartialInterfaceToResolvedInterfaceProperty =
        new $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >({
          partial:
            parameters.optionalPartialInterfaceToResolvedInterfaceProperty.map(
              (object) => PartialInterface.$create(object),
            ),
          resolver: async () =>
            purify.Either.of(
              (
                parameters.optionalPartialInterfaceToResolvedInterfaceProperty as purify.Maybe<LazilyResolvedBlankNodeOrIriIdentifierInterface>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceProperty ===
      "object"
    ) {
      optionalPartialInterfaceToResolvedInterfaceProperty =
        new $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >({
          partial: purify.Maybe.of(
            PartialInterface.$create(
              parameters.optionalPartialInterfaceToResolvedInterfaceProperty,
            ),
          ),
          resolver: async () =>
            purify.Either.of(
              parameters.optionalPartialInterfaceToResolvedInterfaceProperty as LazilyResolvedBlankNodeOrIriIdentifierInterface,
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceProperty ===
      "undefined"
    ) {
      optionalPartialInterfaceToResolvedInterfaceProperty =
        new $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >({
          partial: purify.Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      optionalPartialInterfaceToResolvedInterfaceProperty =
        parameters.optionalPartialInterfaceToResolvedInterfaceProperty satisfies never;
    }

    let optionalPartialInterfaceToResolvedInterfaceUnionProperty: $LazyObjectOption<
      LazilyResolvedInterfaceUnion.$Identifier,
      PartialInterface,
      LazilyResolvedInterfaceUnion
    >;
    if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty ===
        "object" &&
      parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty instanceof
        $LazyObjectOption
    ) {
      optionalPartialInterfaceToResolvedInterfaceUnionProperty =
        parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
      )
    ) {
      optionalPartialInterfaceToResolvedInterfaceUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterface,
          LazilyResolvedInterfaceUnion
        >({
          partial:
            parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty.map(
              (object) => PartialInterface.$create(object),
            ),
          resolver: async () =>
            purify.Either.of(
              (
                parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty as purify.Maybe<LazilyResolvedInterfaceUnion>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty ===
      "object"
    ) {
      optionalPartialInterfaceToResolvedInterfaceUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterface,
          LazilyResolvedInterfaceUnion
        >({
          partial: purify.Maybe.of(
            PartialInterface.$create(
              parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
            ),
          ),
          resolver: async () =>
            purify.Either.of(
              parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty as LazilyResolvedInterfaceUnion,
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty ===
      "undefined"
    ) {
      optionalPartialInterfaceToResolvedInterfaceUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterface,
          LazilyResolvedInterfaceUnion
        >({
          partial: purify.Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      optionalPartialInterfaceToResolvedInterfaceUnionProperty =
        parameters.optionalPartialInterfaceToResolvedInterfaceUnionProperty satisfies never;
    }

    let optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty: $LazyObjectOption<
      LazilyResolvedInterfaceUnion.$Identifier,
      PartialInterfaceUnion,
      LazilyResolvedInterfaceUnion
    >;
    if (
      typeof parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty ===
        "object" &&
      parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty instanceof
        $LazyObjectOption
    ) {
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
        parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
      )
    ) {
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterfaceUnion,
          LazilyResolvedInterfaceUnion
        >({
          partial:
            parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty.map(
              (object) => {
                switch (object.$type) {
                  case "LazilyResolvedInterfaceUnionMember1":
                    return PartialInterfaceUnionMember1.$create(object);
                  case "LazilyResolvedInterfaceUnionMember2":
                    return PartialInterfaceUnionMember2.$create(object);
                  default:
                    object satisfies never;
                    throw new Error("unrecognized type");
                }
              },
            ),
          resolver: async () =>
            purify.Either.of(
              (
                parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty as purify.Maybe<LazilyResolvedInterfaceUnion>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty ===
      "object"
    ) {
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterfaceUnion,
          LazilyResolvedInterfaceUnion
        >({
          partial: purify.Maybe.of(
            parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
          ).map((object) => {
            switch (object.$type) {
              case "LazilyResolvedInterfaceUnionMember1":
                return PartialInterfaceUnionMember1.$create(object);
              case "LazilyResolvedInterfaceUnionMember2":
                return PartialInterfaceUnionMember2.$create(object);
              default:
                object satisfies never;
                throw new Error("unrecognized type");
            }
          }),
          resolver: async () =>
            purify.Either.of(
              parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty as LazilyResolvedInterfaceUnion,
            ),
        });
    } else if (
      typeof parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty ===
      "undefined"
    ) {
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterfaceUnion,
          LazilyResolvedInterfaceUnion
        >({
          partial: purify.Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
        parameters.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty satisfies never;
    }

    let requiredLazyToResolvedInterfaceProperty: $LazyObject<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >;
    if (
      typeof parameters.requiredLazyToResolvedInterfaceProperty === "object" &&
      parameters.requiredLazyToResolvedInterfaceProperty instanceof $LazyObject
    ) {
      requiredLazyToResolvedInterfaceProperty =
        parameters.requiredLazyToResolvedInterfaceProperty;
    } else if (
      typeof parameters.requiredLazyToResolvedInterfaceProperty === "object"
    ) {
      requiredLazyToResolvedInterfaceProperty = new $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partial: new $DefaultPartial(
          parameters.requiredLazyToResolvedInterfaceProperty,
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.requiredLazyToResolvedInterfaceProperty as LazilyResolvedBlankNodeOrIriIdentifierInterface,
          ),
      });
    } else {
      requiredLazyToResolvedInterfaceProperty =
        parameters.requiredLazyToResolvedInterfaceProperty satisfies never;
    }

    let requiredPartialInterfaceToResolvedInterfaceProperty: $LazyObject<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      PartialInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >;
    if (
      typeof parameters.requiredPartialInterfaceToResolvedInterfaceProperty ===
        "object" &&
      parameters.requiredPartialInterfaceToResolvedInterfaceProperty instanceof
        $LazyObject
    ) {
      requiredPartialInterfaceToResolvedInterfaceProperty =
        parameters.requiredPartialInterfaceToResolvedInterfaceProperty;
    } else if (
      typeof parameters.requiredPartialInterfaceToResolvedInterfaceProperty ===
      "object"
    ) {
      requiredPartialInterfaceToResolvedInterfaceProperty = new $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partial: PartialInterface.$create(
          parameters.requiredPartialInterfaceToResolvedInterfaceProperty,
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.requiredPartialInterfaceToResolvedInterfaceProperty as LazilyResolvedBlankNodeOrIriIdentifierInterface,
          ),
      });
    } else {
      requiredPartialInterfaceToResolvedInterfaceProperty =
        parameters.requiredPartialInterfaceToResolvedInterfaceProperty satisfies never;
    }

    let setLazyToResolvedInterfaceProperty: $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >;
    if (
      typeof parameters.setLazyToResolvedInterfaceProperty === "object" &&
      parameters.setLazyToResolvedInterfaceProperty instanceof $LazyObjectSet
    ) {
      setLazyToResolvedInterfaceProperty =
        parameters.setLazyToResolvedInterfaceProperty;
    } else if (
      typeof parameters.setLazyToResolvedInterfaceProperty === "object"
    ) {
      setLazyToResolvedInterfaceProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partials: parameters.setLazyToResolvedInterfaceProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.setLazyToResolvedInterfaceProperty as readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[],
          ),
      });
    } else if (
      typeof parameters.setLazyToResolvedInterfaceProperty === "undefined"
    ) {
      setLazyToResolvedInterfaceProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partials: [],
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      setLazyToResolvedInterfaceProperty =
        parameters.setLazyToResolvedInterfaceProperty satisfies never;
    }

    let setPartialInterfaceToResolvedInterfaceProperty: $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      PartialInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >;
    if (
      typeof parameters.setPartialInterfaceToResolvedInterfaceProperty ===
        "object" &&
      parameters.setPartialInterfaceToResolvedInterfaceProperty instanceof
        $LazyObjectSet
    ) {
      setPartialInterfaceToResolvedInterfaceProperty =
        parameters.setPartialInterfaceToResolvedInterfaceProperty;
    } else if (
      typeof parameters.setPartialInterfaceToResolvedInterfaceProperty ===
      "object"
    ) {
      setPartialInterfaceToResolvedInterfaceProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partials: parameters.setPartialInterfaceToResolvedInterfaceProperty.map(
          (object) => PartialInterface.$create(object),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.setPartialInterfaceToResolvedInterfaceProperty as readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[],
          ),
      });
    } else if (
      typeof parameters.setPartialInterfaceToResolvedInterfaceProperty ===
      "undefined"
    ) {
      setPartialInterfaceToResolvedInterfaceProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partials: [],
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      setPartialInterfaceToResolvedInterfaceProperty =
        parameters.setPartialInterfaceToResolvedInterfaceProperty satisfies never;
    }

    return {
      $identifier,
      $type,
      optionalLazyToResolvedInterfaceProperty,
      optionalLazyToResolvedInterfaceUnionProperty,
      optionalLazyToResolvedIriIdentifierInterfaceProperty,
      optionalPartialInterfaceToResolvedInterfaceProperty,
      optionalPartialInterfaceToResolvedInterfaceUnionProperty,
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
      requiredLazyToResolvedInterfaceProperty,
      requiredPartialInterfaceToResolvedInterfaceProperty,
      setLazyToResolvedInterfaceProperty,
      setPartialInterfaceToResolvedInterfaceProperty,
    };
  }

  export function $equals(
    left: LazyPropertiesInterface,
    right: LazyPropertiesInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          left.optionalLazyToResolvedInterfaceProperty,
          right.optionalLazyToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "optionalLazyToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          left.optionalLazyToResolvedInterfaceUnionProperty,
          right.optionalLazyToResolvedInterfaceUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "optionalLazyToResolvedInterfaceUnionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          left.optionalLazyToResolvedIriIdentifierInterfaceProperty,
          right.optionalLazyToResolvedIriIdentifierInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "optionalLazyToResolvedIriIdentifierInterfaceProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, PartialInterface.$equals))(
            left.partial,
            right.partial,
          ))(
          left.optionalPartialInterfaceToResolvedInterfaceProperty,
          right.optionalPartialInterfaceToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "optionalPartialInterfaceToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, PartialInterface.$equals))(
            left.partial,
            right.partial,
          ))(
          left.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
          right.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName:
            "optionalPartialInterfaceToResolvedInterfaceUnionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, PartialInterfaceUnion.$equals))(
            left.partial,
            right.partial,
          ))(
          left.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
          right.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName:
            "optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) => left.$equals(right))(left.partial, right.partial))(
          left.requiredLazyToResolvedInterfaceProperty,
          right.requiredLazyToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "requiredLazyToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          PartialInterface.$equals(left.partial, right.partial))(
          left.requiredPartialInterfaceToResolvedInterfaceProperty,
          right.requiredPartialInterfaceToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "requiredPartialInterfaceToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $arrayEquals(left, right, (left, right) => left.$equals(right)))(
            left.partials,
            right.partials,
          ))(
          left.setLazyToResolvedInterfaceProperty,
          right.setLazyToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "setLazyToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $arrayEquals(left, right, PartialInterface.$equals))(
            left.partials,
            right.partials,
          ))(
          left.setPartialInterfaceToResolvedInterfaceProperty,
          right.setPartialInterfaceToResolvedInterfaceProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "setPartialInterfaceToResolvedInterfaceProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export function $filter(
    filter: LazyPropertiesInterface.$Filter,
    value: LazyPropertiesInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.optionalLazyToResolvedInterfaceProperty !== "undefined" &&
      !((
        filter: $MaybeFilter<$DefaultPartial.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >,
      ) =>
        $filterMaybe<$DefaultPartial, $DefaultPartial.$Filter>(
          $DefaultPartial.$filter,
        )(filter, value.partial))(
        filter.optionalLazyToResolvedInterfaceProperty,
        value.optionalLazyToResolvedInterfaceProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalLazyToResolvedInterfaceUnionProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<$DefaultPartial.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          $DefaultPartial,
          LazilyResolvedInterfaceUnion
        >,
      ) =>
        $filterMaybe<$DefaultPartial, $DefaultPartial.$Filter>(
          $DefaultPartial.$filter,
        )(filter, value.partial))(
        filter.optionalLazyToResolvedInterfaceUnionProperty,
        value.optionalLazyToResolvedInterfaceUnionProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalLazyToResolvedIriIdentifierInterfaceProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<$NamedDefaultPartial.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedIriIdentifierInterface.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierInterface
        >,
      ) =>
        $filterMaybe<$NamedDefaultPartial, $NamedDefaultPartial.$Filter>(
          $NamedDefaultPartial.$filter,
        )(filter, value.partial))(
        filter.optionalLazyToResolvedIriIdentifierInterfaceProperty,
        value.optionalLazyToResolvedIriIdentifierInterfaceProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalPartialInterfaceToResolvedInterfaceProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<PartialInterface.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >,
      ) =>
        $filterMaybe<PartialInterface, PartialInterface.$Filter>(
          PartialInterface.$filter,
        )(filter, value.partial))(
        filter.optionalPartialInterfaceToResolvedInterfaceProperty,
        value.optionalPartialInterfaceToResolvedInterfaceProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalPartialInterfaceToResolvedInterfaceUnionProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<PartialInterface.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterface,
          LazilyResolvedInterfaceUnion
        >,
      ) =>
        $filterMaybe<PartialInterface, PartialInterface.$Filter>(
          PartialInterface.$filter,
        )(filter, value.partial))(
        filter.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
        value.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<PartialInterfaceUnion.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedInterfaceUnion.$Identifier,
          PartialInterfaceUnion,
          LazilyResolvedInterfaceUnion
        >,
      ) =>
        $filterMaybe<PartialInterfaceUnion, PartialInterfaceUnion.$Filter>(
          PartialInterfaceUnion.$filter,
        )(filter, value.partial))(
        filter.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
        value.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.requiredLazyToResolvedInterfaceProperty !== "undefined" &&
      !((
        filter: $DefaultPartial.$Filter,
        value: $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >,
      ) => $DefaultPartial.$filter(filter, value.partial))(
        filter.requiredLazyToResolvedInterfaceProperty,
        value.requiredLazyToResolvedInterfaceProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.requiredPartialInterfaceToResolvedInterfaceProperty !==
        "undefined" &&
      !((
        filter: PartialInterface.$Filter,
        value: $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >,
      ) => PartialInterface.$filter(filter, value.partial))(
        filter.requiredPartialInterfaceToResolvedInterfaceProperty,
        value.requiredPartialInterfaceToResolvedInterfaceProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.setLazyToResolvedInterfaceProperty !== "undefined" &&
      !((
        filter: $CollectionFilter<$DefaultPartial.$Filter>,
        value: $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >,
      ) =>
        $filterArray<$DefaultPartial, $DefaultPartial.$Filter>(
          $DefaultPartial.$filter,
        )(filter, value.partials))(
        filter.setLazyToResolvedInterfaceProperty,
        value.setLazyToResolvedInterfaceProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.setPartialInterfaceToResolvedInterfaceProperty !==
        "undefined" &&
      !((
        filter: $CollectionFilter<PartialInterface.$Filter>,
        value: $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
          PartialInterface,
          LazilyResolvedBlankNodeOrIriIdentifierInterface
        >,
      ) =>
        $filterArray<PartialInterface, PartialInterface.$Filter>(
          PartialInterface.$filter,
        )(filter, value.partials))(
        filter.setPartialInterfaceToResolvedInterfaceProperty,
        value.setPartialInterfaceToResolvedInterfaceProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly optionalLazyToResolvedInterfaceProperty?: $MaybeFilter<$DefaultPartial.$Filter>;
    readonly optionalLazyToResolvedInterfaceUnionProperty?: $MaybeFilter<$DefaultPartial.$Filter>;
    readonly optionalLazyToResolvedIriIdentifierInterfaceProperty?: $MaybeFilter<$NamedDefaultPartial.$Filter>;
    readonly optionalPartialInterfaceToResolvedInterfaceProperty?: $MaybeFilter<PartialInterface.$Filter>;
    readonly optionalPartialInterfaceToResolvedInterfaceUnionProperty?: $MaybeFilter<PartialInterface.$Filter>;
    readonly optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty?: $MaybeFilter<PartialInterfaceUnion.$Filter>;
    readonly requiredLazyToResolvedInterfaceProperty?: $DefaultPartial.$Filter;
    readonly requiredPartialInterfaceToResolvedInterfaceProperty?: PartialInterface.$Filter;
    readonly setLazyToResolvedInterfaceProperty?: $CollectionFilter<$DefaultPartial.$Filter>;
    readonly setPartialInterfaceToResolvedInterfaceProperty?: $CollectionFilter<PartialInterface.$Filter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazyPropertiesInterface> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazyPropertiesInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazyPropertiesInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazyPropertiesInterface: LazyPropertiesInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_lazyPropertiesInterface.$identifier.value);
    _hasher.update(_lazyPropertiesInterface.$type);
    LazyPropertiesInterface.$hashShaclProperties(
      _lazyPropertiesInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazyPropertiesInterface: LazyPropertiesInterface,
    _hasher: HasherT,
  ): HasherT {
    _lazyPropertiesInterface.optionalLazyToResolvedInterfaceProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    _lazyPropertiesInterface.optionalLazyToResolvedInterfaceUnionProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    _lazyPropertiesInterface.optionalLazyToResolvedIriIdentifierInterfaceProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    _lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceProperty.partial.ifJust(
      (value1) => {
        PartialInterface.$hash(value1, _hasher);
      },
    );
    _lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceUnionProperty.partial.ifJust(
      (value1) => {
        PartialInterface.$hash(value1, _hasher);
      },
    );
    _lazyPropertiesInterface.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty.partial.ifJust(
      (value1) => {
        PartialInterfaceUnion.$hash(value1, _hasher);
      },
    );
    _lazyPropertiesInterface.requiredLazyToResolvedInterfaceProperty.partial.$hash(
      _hasher,
    );
    PartialInterface.$hash(
      _lazyPropertiesInterface
        .requiredPartialInterfaceToResolvedInterfaceProperty.partial,
      _hasher,
    );
    for (const item1 of _lazyPropertiesInterface
      .setLazyToResolvedInterfaceProperty.partials) {
      item1.$hash(_hasher);
    }

    for (const item1 of _lazyPropertiesInterface
      .setPartialInterfaceToResolvedInterfaceProperty.partials) {
      PartialInterface.$hash(item1, _hasher);
    }

    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazyPropertiesInterface";
    readonly optionalLazyToResolvedInterfaceProperty?: $DefaultPartial.$Json;
    readonly optionalLazyToResolvedInterfaceUnionProperty?: $DefaultPartial.$Json;
    readonly optionalLazyToResolvedIriIdentifierInterfaceProperty?: $NamedDefaultPartial.$Json;
    readonly optionalPartialInterfaceToResolvedInterfaceProperty?: PartialInterface.$Json;
    readonly optionalPartialInterfaceToResolvedInterfaceUnionProperty?: PartialInterface.$Json;
    readonly optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty?:
      | PartialInterfaceUnionMember1.$Json
      | PartialInterfaceUnionMember2.$Json;
    readonly requiredLazyToResolvedInterfaceProperty: $DefaultPartial.$Json;
    readonly requiredPartialInterfaceToResolvedInterfaceProperty: PartialInterface.$Json;
    readonly setLazyToResolvedInterfaceProperty?: readonly $DefaultPartial.$Json[];
    readonly setPartialInterfaceToResolvedInterfaceProperty?: readonly PartialInterface.$Json[];
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazyPropertiesInterface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedInterfaceProperty`,
        }),
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedInterfaceUnionProperty`,
        }),
        $NamedDefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedIriIdentifierInterfaceProperty`,
        }),
        PartialInterface.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalPartialInterfaceToResolvedInterfaceProperty`,
        }),
        PartialInterface.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalPartialInterfaceToResolvedInterfaceUnionProperty`,
        }),
        {
          scope: `${scopePrefix}/properties/optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
          type: "Control",
        },
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/requiredLazyToResolvedInterfaceProperty`,
        }),
        PartialInterface.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/requiredPartialInterfaceToResolvedInterfaceProperty`,
        }),
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/setLazyToResolvedInterfaceProperty`,
        }),
        PartialInterface.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/setPartialInterfaceToResolvedInterfaceProperty`,
        }),
      ],
      label: "LazyPropertiesInterface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazyPropertiesInterface"),
      optionalLazyToResolvedInterfaceProperty: $DefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalLazyToResolvedInterfaceUnionProperty: $DefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalLazyToResolvedIriIdentifierInterfaceProperty: $NamedDefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalPartialInterfaceToResolvedInterfaceProperty:
        PartialInterface.$jsonZodSchema().optional(),
      optionalPartialInterfaceToResolvedInterfaceUnionProperty:
        PartialInterface.$jsonZodSchema().optional(),
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty:
        PartialInterfaceUnion.$jsonZodSchema().optional(),
      requiredLazyToResolvedInterfaceProperty: $DefaultPartial.$jsonZodSchema(),
      requiredPartialInterfaceToResolvedInterfaceProperty:
        PartialInterface.$jsonZodSchema(),
      setLazyToResolvedInterfaceProperty: $DefaultPartial
        .$jsonZodSchema()
        .array()
        .default(() => []),
      setPartialInterfaceToResolvedInterfaceProperty:
        PartialInterface.$jsonZodSchema()
          .array()
          .default(() => []),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    optionalLazyToResolvedInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalLazyToResolvedInterfaceProperty",
      ),
    },
    optionalLazyToResolvedInterfaceUnionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalLazyToResolvedInterfaceUnionProperty",
      ),
    },
    optionalLazyToResolvedIriIdentifierInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalLazyToResolvedIriIdentifierInterfaceProperty",
      ),
    },
    optionalPartialInterfaceToResolvedInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalPartialInterfaceToResolvedInterfaceProperty",
      ),
    },
    optionalPartialInterfaceToResolvedInterfaceUnionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalPartialInterfaceToResolvedInterfaceUnionProperty",
      ),
    },
    optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty",
      ),
    },
    requiredLazyToResolvedInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/requiredLazyToResolvedInterfaceProperty",
      ),
    },
    requiredPartialInterfaceToResolvedInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/requiredPartialInterfaceToResolvedInterfaceProperty",
      ),
    },
    setLazyToResolvedInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/setLazyToResolvedInterfaceProperty",
      ),
    },
    setPartialInterfaceToResolvedInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/setPartialInterfaceToResolvedInterfaceProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazyPropertiesInterface";
      optionalLazyToResolvedInterfaceProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      optionalLazyToResolvedInterfaceUnionProperty: $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >;
      optionalLazyToResolvedIriIdentifierInterfaceProperty: $LazyObjectOption<
        LazilyResolvedIriIdentifierInterface.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriIdentifierInterface
      >;
      optionalPartialInterfaceToResolvedInterfaceProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      optionalPartialInterfaceToResolvedInterfaceUnionProperty: $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterface,
        LazilyResolvedInterfaceUnion
      >;
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty: $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterfaceUnion,
        LazilyResolvedInterfaceUnion
      >;
      requiredLazyToResolvedInterfaceProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      requiredPartialInterfaceToResolvedInterfaceProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      setLazyToResolvedInterfaceProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      setPartialInterfaceToResolvedInterfaceProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "LazyPropertiesInterface" as const;
    const optionalLazyToResolvedInterfaceProperty = new $LazyObjectOption<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >({
      partial: purify.Maybe.fromNullable(
        $jsonObject["optionalLazyToResolvedInterfaceProperty"],
      ).map((item) => $DefaultPartial.$fromJson(item).unsafeCoerce()),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const optionalLazyToResolvedInterfaceUnionProperty = new $LazyObjectOption<
      LazilyResolvedInterfaceUnion.$Identifier,
      $DefaultPartial,
      LazilyResolvedInterfaceUnion
    >({
      partial: purify.Maybe.fromNullable(
        $jsonObject["optionalLazyToResolvedInterfaceUnionProperty"],
      ).map((item) => $DefaultPartial.$fromJson(item).unsafeCoerce()),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const optionalLazyToResolvedIriIdentifierInterfaceProperty =
      new $LazyObjectOption<
        LazilyResolvedIriIdentifierInterface.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriIdentifierInterface
      >({
        partial: purify.Maybe.fromNullable(
          $jsonObject["optionalLazyToResolvedIriIdentifierInterfaceProperty"],
        ).map((item) => $NamedDefaultPartial.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            purify.Left(
              new Error(
                `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const optionalPartialInterfaceToResolvedInterfaceProperty =
      new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >({
        partial: purify.Maybe.fromNullable(
          $jsonObject["optionalPartialInterfaceToResolvedInterfaceProperty"],
        ).map((item) => PartialInterface.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            purify.Left(
              new Error(
                `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const optionalPartialInterfaceToResolvedInterfaceUnionProperty =
      new $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterface,
        LazilyResolvedInterfaceUnion
      >({
        partial: purify.Maybe.fromNullable(
          $jsonObject[
            "optionalPartialInterfaceToResolvedInterfaceUnionProperty"
          ],
        ).map((item) => PartialInterface.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            purify.Left(
              new Error(
                `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
      new $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterfaceUnion,
        LazilyResolvedInterfaceUnion
      >({
        partial: purify.Maybe.fromNullable(
          $jsonObject[
            "optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty"
          ],
        ).map((item) => PartialInterfaceUnion.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            purify.Left(
              new Error(
                `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const requiredLazyToResolvedInterfaceProperty = new $LazyObject<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >({
      partial: $DefaultPartial
        .$fromJson($jsonObject["requiredLazyToResolvedInterfaceProperty"])
        .unsafeCoerce(),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const requiredPartialInterfaceToResolvedInterfaceProperty = new $LazyObject<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      PartialInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >({
      partial: PartialInterface.$fromJson(
        $jsonObject["requiredPartialInterfaceToResolvedInterfaceProperty"],
      ).unsafeCoerce(),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const setLazyToResolvedInterfaceProperty = new $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >({
      partials: $jsonObject["setLazyToResolvedInterfaceProperty"].map((item) =>
        $DefaultPartial.$fromJson(item).unsafeCoerce(),
      ),
      resolver: () =>
        Promise.resolve(
          purify.Left(
            new Error("unable to resolve identifiers deserialized from JSON"),
          ),
        ),
    });
    const setPartialInterfaceToResolvedInterfaceProperty = new $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
      PartialInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface
    >({
      partials: $jsonObject[
        "setPartialInterfaceToResolvedInterfaceProperty"
      ].map((item) => PartialInterface.$fromJson(item).unsafeCoerce()),
      resolver: () =>
        Promise.resolve(
          purify.Left(
            new Error("unable to resolve identifiers deserialized from JSON"),
          ),
        ),
    });
    return purify.Either.of({
      $identifier,
      $type,
      optionalLazyToResolvedInterfaceProperty,
      optionalLazyToResolvedInterfaceUnionProperty,
      optionalLazyToResolvedIriIdentifierInterfaceProperty,
      optionalPartialInterfaceToResolvedInterfaceProperty,
      optionalPartialInterfaceToResolvedInterfaceUnionProperty,
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
      requiredLazyToResolvedInterfaceProperty,
      requiredPartialInterfaceToResolvedInterfaceProperty,
      setLazyToResolvedInterfaceProperty,
      setPartialInterfaceToResolvedInterfaceProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazyPropertiesInterface";
      optionalLazyToResolvedInterfaceProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      optionalLazyToResolvedInterfaceUnionProperty: $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >;
      optionalLazyToResolvedIriIdentifierInterfaceProperty: $LazyObjectOption<
        LazilyResolvedIriIdentifierInterface.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriIdentifierInterface
      >;
      optionalPartialInterfaceToResolvedInterfaceProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      optionalPartialInterfaceToResolvedInterfaceUnionProperty: $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterface,
        LazilyResolvedInterfaceUnion
      >;
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty: $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterfaceUnion,
        LazilyResolvedInterfaceUnion
      >;
      requiredLazyToResolvedInterfaceProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      requiredPartialInterfaceToResolvedInterfaceProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      setLazyToResolvedInterfaceProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
      setPartialInterfaceToResolvedInterfaceProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >;
    }
  > {
    const $identifier: LazyPropertiesInterface.$Identifier =
      $parameters.resource.identifier;
    const $type = "LazyPropertiesInterface" as const;
    const _optionalLazyToResolvedInterfacePropertyEither: purify.Either<
      Error,
      $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.optionalLazyToResolvedInterfaceProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            $DefaultPartial.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<$DefaultPartial>
            >({
              focusResource: $parameters.resource,
              predicate:
                LazyPropertiesInterface.$properties
                  .optionalLazyToResolvedInterfaceProperty["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyObjectOption<
              LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
              $DefaultPartial,
              LazilyResolvedBlankNodeOrIriIdentifierInterface
            >({
              partial,
              resolver: (identifier) =>
                $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierInterface(
                  identifier,
                ),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_optionalLazyToResolvedInterfacePropertyEither.isLeft()) {
      return _optionalLazyToResolvedInterfacePropertyEither;
    }

    const optionalLazyToResolvedInterfaceProperty =
      _optionalLazyToResolvedInterfacePropertyEither.unsafeCoerce();
    const _optionalLazyToResolvedInterfaceUnionPropertyEither: purify.Either<
      Error,
      $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedInterfaceUnion
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.optionalLazyToResolvedInterfaceUnionProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            $DefaultPartial.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<$DefaultPartial>
            >({
              focusResource: $parameters.resource,
              predicate:
                LazyPropertiesInterface.$properties
                  .optionalLazyToResolvedInterfaceUnionProperty["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyObjectOption<
              LazilyResolvedInterfaceUnion.$Identifier,
              $DefaultPartial,
              LazilyResolvedInterfaceUnion
            >({
              partial,
              resolver: (identifier) =>
                $parameters.objectSet.lazilyResolvedInterfaceUnion(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_optionalLazyToResolvedInterfaceUnionPropertyEither.isLeft()) {
      return _optionalLazyToResolvedInterfaceUnionPropertyEither;
    }

    const optionalLazyToResolvedInterfaceUnionProperty =
      _optionalLazyToResolvedInterfaceUnionPropertyEither.unsafeCoerce();
    const _optionalLazyToResolvedIriIdentifierInterfacePropertyEither: purify.Either<
      Error,
      $LazyObjectOption<
        LazilyResolvedIriIdentifierInterface.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriIdentifierInterface
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.optionalLazyToResolvedIriIdentifierInterfaceProperty[
          "identifier"
        ],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            $NamedDefaultPartial.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<$NamedDefaultPartial>
            >({
              focusResource: $parameters.resource,
              predicate:
                LazyPropertiesInterface.$properties
                  .optionalLazyToResolvedIriIdentifierInterfaceProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyObjectOption<
              LazilyResolvedIriIdentifierInterface.$Identifier,
              $NamedDefaultPartial,
              LazilyResolvedIriIdentifierInterface
            >({
              partial,
              resolver: (identifier) =>
                $parameters.objectSet.lazilyResolvedIriIdentifierInterface(
                  identifier,
                ),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_optionalLazyToResolvedIriIdentifierInterfacePropertyEither.isLeft()) {
      return _optionalLazyToResolvedIriIdentifierInterfacePropertyEither;
    }

    const optionalLazyToResolvedIriIdentifierInterfaceProperty =
      _optionalLazyToResolvedIriIdentifierInterfacePropertyEither.unsafeCoerce();
    const _optionalPartialInterfaceToResolvedInterfacePropertyEither: purify.Either<
      Error,
      $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.optionalPartialInterfaceToResolvedInterfaceProperty[
          "identifier"
        ],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            PartialInterface.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<PartialInterface>
            >({
              focusResource: $parameters.resource,
              predicate:
                LazyPropertiesInterface.$properties
                  .optionalPartialInterfaceToResolvedInterfaceProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyObjectOption<
              LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
              PartialInterface,
              LazilyResolvedBlankNodeOrIriIdentifierInterface
            >({
              partial,
              resolver: (identifier) =>
                $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierInterface(
                  identifier,
                ),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_optionalPartialInterfaceToResolvedInterfacePropertyEither.isLeft()) {
      return _optionalPartialInterfaceToResolvedInterfacePropertyEither;
    }

    const optionalPartialInterfaceToResolvedInterfaceProperty =
      _optionalPartialInterfaceToResolvedInterfacePropertyEither.unsafeCoerce();
    const _optionalPartialInterfaceToResolvedInterfaceUnionPropertyEither: purify.Either<
      Error,
      $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterface,
        LazilyResolvedInterfaceUnion
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.optionalPartialInterfaceToResolvedInterfaceUnionProperty[
          "identifier"
        ],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            PartialInterface.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<PartialInterface>
            >({
              focusResource: $parameters.resource,
              predicate:
                LazyPropertiesInterface.$properties
                  .optionalPartialInterfaceToResolvedInterfaceUnionProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyObjectOption<
              LazilyResolvedInterfaceUnion.$Identifier,
              PartialInterface,
              LazilyResolvedInterfaceUnion
            >({
              partial,
              resolver: (identifier) =>
                $parameters.objectSet.lazilyResolvedInterfaceUnion(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (
      _optionalPartialInterfaceToResolvedInterfaceUnionPropertyEither.isLeft()
    ) {
      return _optionalPartialInterfaceToResolvedInterfaceUnionPropertyEither;
    }

    const optionalPartialInterfaceToResolvedInterfaceUnionProperty =
      _optionalPartialInterfaceToResolvedInterfaceUnionPropertyEither.unsafeCoerce();
    const _optionalPartialInterfaceUnionToResolvedInterfaceUnionPropertyEither: purify.Either<
      Error,
      $LazyObjectOption<
        LazilyResolvedInterfaceUnion.$Identifier,
        PartialInterfaceUnion,
        LazilyResolvedInterfaceUnion
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties
          .optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty[
          "identifier"
        ],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            PartialInterfaceUnion.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: false,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<PartialInterfaceUnion>
            >({
              focusResource: $parameters.resource,
              predicate:
                LazyPropertiesInterface.$properties
                  .optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyObjectOption<
              LazilyResolvedInterfaceUnion.$Identifier,
              PartialInterfaceUnion,
              LazilyResolvedInterfaceUnion
            >({
              partial,
              resolver: (identifier) =>
                $parameters.objectSet.lazilyResolvedInterfaceUnion(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (
      _optionalPartialInterfaceUnionToResolvedInterfaceUnionPropertyEither.isLeft()
    ) {
      return _optionalPartialInterfaceUnionToResolvedInterfaceUnionPropertyEither;
    }

    const optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty =
      _optionalPartialInterfaceUnionToResolvedInterfaceUnionPropertyEither.unsafeCoerce();
    const _requiredLazyToResolvedInterfacePropertyEither: purify.Either<
      Error,
      $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.requiredLazyToResolvedInterfaceProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            $DefaultPartial.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyObject<
              LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
              $DefaultPartial,
              LazilyResolvedBlankNodeOrIriIdentifierInterface
            >({
              partial,
              resolver: (identifier) =>
                $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierInterface(
                  identifier,
                ),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_requiredLazyToResolvedInterfacePropertyEither.isLeft()) {
      return _requiredLazyToResolvedInterfacePropertyEither;
    }

    const requiredLazyToResolvedInterfaceProperty =
      _requiredLazyToResolvedInterfacePropertyEither.unsafeCoerce();
    const _requiredPartialInterfaceToResolvedInterfacePropertyEither: purify.Either<
      Error,
      $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.requiredPartialInterfaceToResolvedInterfaceProperty[
          "identifier"
        ],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            PartialInterface.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyObject<
              LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
              PartialInterface,
              LazilyResolvedBlankNodeOrIriIdentifierInterface
            >({
              partial,
              resolver: (identifier) =>
                $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierInterface(
                  identifier,
                ),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_requiredPartialInterfaceToResolvedInterfacePropertyEither.isLeft()) {
      return _requiredPartialInterfaceToResolvedInterfacePropertyEither;
    }

    const requiredPartialInterfaceToResolvedInterfaceProperty =
      _requiredPartialInterfaceToResolvedInterfacePropertyEither.unsafeCoerce();
    const _setLazyToResolvedInterfacePropertyEither: purify.Either<
      Error,
      $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.setLazyToResolvedInterfaceProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            $DefaultPartial.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) => values.toArray())
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          focusResource: $parameters.resource,
          predicate:
            LazyPropertiesInterface.$properties
              .setLazyToResolvedInterfaceProperty["identifier"],
          value: valuesArray,
        }),
      )
      .map((values) =>
        values.map(
          (partials) =>
            new $LazyObjectSet<
              LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
              $DefaultPartial,
              LazilyResolvedBlankNodeOrIriIdentifierInterface
            >({
              partials,
              resolver: (identifiers) =>
                $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierInterfaces(
                  { where: { identifiers, type: "identifiers" } },
                ),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_setLazyToResolvedInterfacePropertyEither.isLeft()) {
      return _setLazyToResolvedInterfacePropertyEither;
    }

    const setLazyToResolvedInterfaceProperty =
      _setLazyToResolvedInterfacePropertyEither.unsafeCoerce();
    const _setPartialInterfaceToResolvedInterfacePropertyEither: purify.Either<
      Error,
      $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
        PartialInterface,
        LazilyResolvedBlankNodeOrIriIdentifierInterface
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.setPartialInterfaceToResolvedInterfaceProperty[
          "identifier"
        ],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            PartialInterface.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) => values.toArray())
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          focusResource: $parameters.resource,
          predicate:
            LazyPropertiesInterface.$properties
              .setPartialInterfaceToResolvedInterfaceProperty["identifier"],
          value: valuesArray,
        }),
      )
      .map((values) =>
        values.map(
          (partials) =>
            new $LazyObjectSet<
              LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
              PartialInterface,
              LazilyResolvedBlankNodeOrIriIdentifierInterface
            >({
              partials,
              resolver: (identifiers) =>
                $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierInterfaces(
                  { where: { identifiers, type: "identifiers" } },
                ),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_setPartialInterfaceToResolvedInterfacePropertyEither.isLeft()) {
      return _setPartialInterfaceToResolvedInterfacePropertyEither;
    }

    const setPartialInterfaceToResolvedInterfaceProperty =
      _setPartialInterfaceToResolvedInterfacePropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      $type,
      optionalLazyToResolvedInterfaceProperty,
      optionalLazyToResolvedInterfaceUnionProperty,
      optionalLazyToResolvedIriIdentifierInterfaceProperty,
      optionalPartialInterfaceToResolvedInterfaceProperty,
      optionalPartialInterfaceToResolvedInterfaceUnionProperty,
      optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
      requiredLazyToResolvedInterfaceProperty,
      requiredPartialInterfaceToResolvedInterfaceProperty,
      setLazyToResolvedInterfaceProperty,
      setPartialInterfaceToResolvedInterfaceProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazyPropertiesInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazyPropertiesInterface.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazyPropertiesInterface.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazyPropertiesInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazyPropertiesInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("lazyPropertiesInterface");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .optionalLazyToResolvedInterfaceProperty["identifier"],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceUnionProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .optionalLazyToResolvedInterfaceUnionProperty["identifier"],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceUnionProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceUnionProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedIriIdentifierInterfaceProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .optionalLazyToResolvedIriIdentifierInterfaceProperty["identifier"],
      subject,
    });
    triples.push(
      ...$NamedDefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedIriIdentifierInterfaceProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedIriIdentifierInterfaceProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .optionalPartialInterfaceToResolvedInterfaceProperty["identifier"],
      subject,
    });
    triples.push(
      ...PartialInterface.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .optionalPartialInterfaceToResolvedInterfaceUnionProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...PartialInterface.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...PartialInterfaceUnion.$sparqlConstructTriples({
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredLazyToResolvedInterfaceProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .requiredLazyToResolvedInterfaceProperty["identifier"],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredLazyToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredLazyToResolvedInterfaceProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredPartialInterfaceToResolvedInterfaceProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .requiredPartialInterfaceToResolvedInterfaceProperty["identifier"],
      subject,
    });
    triples.push(
      ...PartialInterface.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredPartialInterfaceToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredPartialInterfaceToResolvedInterfaceProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetLazyToResolvedInterfaceProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties.setLazyToResolvedInterfaceProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetLazyToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetLazyToResolvedInterfaceProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetPartialInterfaceToResolvedInterfaceProperty`,
      ),
      predicate:
        LazyPropertiesInterface.$properties
          .setPartialInterfaceToResolvedInterfaceProperty["identifier"],
      subject,
    });
    triples.push(
      ...PartialInterface.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetPartialInterfaceToResolvedInterfaceProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetPartialInterfaceToResolvedInterfaceProperty`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazyPropertiesInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("lazyPropertiesInterface");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalLazyToResolvedInterfaceProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceProperty`,
                  ),
                  predicate:
                    LazyPropertiesInterface.$properties
                      .optionalLazyToResolvedInterfaceProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $DefaultPartial
                .$sparqlWherePatterns({
                  filter: itemFilter,
                  ignoreRdfType: true,
                  preferredLanguages: parameters?.preferredLanguages,
                  subject: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceProperty`,
                  ),
                  variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceProperty`,
                })
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalLazyToResolvedInterfaceUnionProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceUnionProperty`,
                  ),
                  predicate:
                    LazyPropertiesInterface.$properties
                      .optionalLazyToResolvedInterfaceUnionProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $DefaultPartial
                .$sparqlWherePatterns({
                  filter: itemFilter,
                  ignoreRdfType: true,
                  preferredLanguages: parameters?.preferredLanguages,
                  subject: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceUnionProperty`,
                  ),
                  variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedInterfaceUnionProperty`,
                })
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter
            ?.optionalLazyToResolvedIriIdentifierInterfaceProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedIriIdentifierInterfaceProperty`,
                  ),
                  predicate:
                    LazyPropertiesInterface.$properties
                      .optionalLazyToResolvedIriIdentifierInterfaceProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $NamedDefaultPartial
                .$sparqlWherePatterns({
                  filter: itemFilter,
                  ignoreRdfType: true,
                  preferredLanguages: parameters?.preferredLanguages,
                  subject: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedIriIdentifierInterfaceProperty`,
                  ),
                  variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalLazyToResolvedIriIdentifierInterfaceProperty`,
                })
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter
            ?.optionalPartialInterfaceToResolvedInterfaceProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceProperty`,
                  ),
                  predicate:
                    LazyPropertiesInterface.$properties
                      .optionalPartialInterfaceToResolvedInterfaceProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: PartialInterface.$sparqlWherePatterns({
                filter: itemFilter,
                ignoreRdfType: true,
                preferredLanguages: parameters?.preferredLanguages,
                subject: dataFactory.variable!(
                  `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceProperty`,
                ),
                variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceProperty`,
              }).concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter
            ?.optionalPartialInterfaceToResolvedInterfaceUnionProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
                  ),
                  predicate:
                    LazyPropertiesInterface.$properties
                      .optionalPartialInterfaceToResolvedInterfaceUnionProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: PartialInterface.$sparqlWherePatterns({
                filter: itemFilter,
                ignoreRdfType: true,
                preferredLanguages: parameters?.preferredLanguages,
                subject: dataFactory.variable!(
                  `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
                ),
                variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceToResolvedInterfaceUnionProperty`,
              }).concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter
            ?.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
                  ),
                  predicate:
                    LazyPropertiesInterface.$properties
                      .optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: PartialInterfaceUnion.$sparqlWherePatterns({
                filter: itemFilter,
                preferredLanguages: parameters?.preferredLanguages,
                subject: dataFactory.variable!(
                  `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
                ),
                variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}OptionalPartialInterfaceUnionToResolvedInterfaceUnionProperty`,
              }).concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredLazyToResolvedInterfaceProperty`,
            ),
            predicate:
              LazyPropertiesInterface.$properties
                .requiredLazyToResolvedInterfaceProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: $DefaultPartial
          .$sparqlWherePatterns({
            filter: parameters?.filter?.requiredLazyToResolvedInterfaceProperty,
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredLazyToResolvedInterfaceProperty`,
            ),
            variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredLazyToResolvedInterfaceProperty`,
          })
          .concat(),
        type: "group",
      },
    );
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredPartialInterfaceToResolvedInterfaceProperty`,
            ),
            predicate:
              LazyPropertiesInterface.$properties
                .requiredPartialInterfaceToResolvedInterfaceProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: PartialInterface.$sparqlWherePatterns({
          filter:
            parameters?.filter
              ?.requiredPartialInterfaceToResolvedInterfaceProperty,
          ignoreRdfType: true,
          preferredLanguages: parameters?.preferredLanguages,
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredPartialInterfaceToResolvedInterfaceProperty`,
          ),
          variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}RequiredPartialInterfaceToResolvedInterfaceProperty`,
        }).concat(),
        type: "group",
      },
    );
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetLazyToResolvedInterfaceProperty`,
              ),
              predicate:
                LazyPropertiesInterface.$properties
                  .setLazyToResolvedInterfaceProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: $DefaultPartial
            .$sparqlWherePatterns({
              filter: parameters?.filter?.setLazyToResolvedInterfaceProperty,
              ignoreRdfType: true,
              preferredLanguages: parameters?.preferredLanguages,
              subject: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetLazyToResolvedInterfaceProperty`,
              ),
              variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetLazyToResolvedInterfaceProperty`,
            })
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetPartialInterfaceToResolvedInterfaceProperty`,
              ),
              predicate:
                LazyPropertiesInterface.$properties
                  .setPartialInterfaceToResolvedInterfaceProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: PartialInterface.$sparqlWherePatterns({
            filter:
              parameters?.filter
                ?.setPartialInterfaceToResolvedInterfaceProperty,
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetPartialInterfaceToResolvedInterfaceProperty`,
            ),
            variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesInterface")}SetPartialInterfaceToResolvedInterfaceProperty`,
          }).concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    return patterns;
  }

  export function $toJson(
    _lazyPropertiesInterface: LazyPropertiesInterface,
  ): LazyPropertiesInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _lazyPropertiesInterface.$identifier.termType === "BlankNode"
            ? `_:${_lazyPropertiesInterface.$identifier.value}`
            : _lazyPropertiesInterface.$identifier.value,
        $type: _lazyPropertiesInterface.$type,
        optionalLazyToResolvedInterfaceProperty:
          _lazyPropertiesInterface.optionalLazyToResolvedInterfaceProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalLazyToResolvedInterfaceUnionProperty:
          _lazyPropertiesInterface.optionalLazyToResolvedInterfaceUnionProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalLazyToResolvedIriIdentifierInterfaceProperty:
          _lazyPropertiesInterface.optionalLazyToResolvedIriIdentifierInterfaceProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalPartialInterfaceToResolvedInterfaceProperty:
          _lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceProperty.partial
            .map((item) => PartialInterface.$toJson(item))
            .extract(),
        optionalPartialInterfaceToResolvedInterfaceUnionProperty:
          _lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceUnionProperty.partial
            .map((item) => PartialInterface.$toJson(item))
            .extract(),
        optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty:
          _lazyPropertiesInterface.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty.partial
            .map((item) => PartialInterfaceUnion.$toJson(item))
            .extract(),
        requiredLazyToResolvedInterfaceProperty:
          _lazyPropertiesInterface.requiredLazyToResolvedInterfaceProperty.partial.$toJson(),
        requiredPartialInterfaceToResolvedInterfaceProperty:
          PartialInterface.$toJson(
            _lazyPropertiesInterface
              .requiredPartialInterfaceToResolvedInterfaceProperty.partial,
          ),
        setLazyToResolvedInterfaceProperty:
          _lazyPropertiesInterface.setLazyToResolvedInterfaceProperty.partials.map(
            (item) => item.$toJson(),
          ),
        setPartialInterfaceToResolvedInterfaceProperty:
          _lazyPropertiesInterface.setPartialInterfaceToResolvedInterfaceProperty.partials.map(
            (item) => PartialInterface.$toJson(item),
          ),
      } satisfies LazyPropertiesInterface.$Json),
    );
  }

  export function $toRdf(
    _lazyPropertiesInterface: LazyPropertiesInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _lazyPropertiesInterface.$identifier,
      { mutateGraph },
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .optionalLazyToResolvedInterfaceProperty["identifier"],
      ..._lazyPropertiesInterface.optionalLazyToResolvedInterfaceProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .optionalLazyToResolvedInterfaceUnionProperty["identifier"],
      ..._lazyPropertiesInterface.optionalLazyToResolvedInterfaceUnionProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .optionalLazyToResolvedIriIdentifierInterfaceProperty["identifier"],
      ..._lazyPropertiesInterface.optionalLazyToResolvedIriIdentifierInterfaceProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .optionalPartialInterfaceToResolvedInterfaceProperty["identifier"],
      ..._lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceProperty.partial
        .toList()
        .flatMap((value) => [
          PartialInterface.$toRdf(value, {
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          }).identifier,
        ]),
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .optionalPartialInterfaceToResolvedInterfaceUnionProperty["identifier"],
      ..._lazyPropertiesInterface.optionalPartialInterfaceToResolvedInterfaceUnionProperty.partial
        .toList()
        .flatMap((value) => [
          PartialInterface.$toRdf(value, {
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          }).identifier,
        ]),
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty[
        "identifier"
      ],
      ..._lazyPropertiesInterface.optionalPartialInterfaceUnionToResolvedInterfaceUnionProperty.partial
        .toList()
        .flatMap((value) => [
          PartialInterfaceUnion.$toRdf(value, {
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          }).identifier,
        ]),
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .requiredLazyToResolvedInterfaceProperty["identifier"],
      ...[
        _lazyPropertiesInterface.requiredLazyToResolvedInterfaceProperty.partial.$toRdf(
          { mutateGraph: mutateGraph, resourceSet: resourceSet },
        ).identifier,
      ],
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .requiredPartialInterfaceToResolvedInterfaceProperty["identifier"],
      ...[
        PartialInterface.$toRdf(
          _lazyPropertiesInterface
            .requiredPartialInterfaceToResolvedInterfaceProperty.partial,
          { mutateGraph: mutateGraph, resourceSet: resourceSet },
        ).identifier,
      ],
    );
    resource.add(
      LazyPropertiesInterface.$properties.setLazyToResolvedInterfaceProperty[
        "identifier"
      ],
      ..._lazyPropertiesInterface.setLazyToResolvedInterfaceProperty.partials.flatMap(
        (item) => [
          item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ],
      ),
    );
    resource.add(
      LazyPropertiesInterface.$properties
        .setPartialInterfaceToResolvedInterfaceProperty["identifier"],
      ..._lazyPropertiesInterface.setPartialInterfaceToResolvedInterfaceProperty.partials.flatMap(
        (item) => [
          PartialInterface.$toRdf(item, {
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          }).identifier,
        ],
      ),
    );
    return resource;
  }
}
/**
 * Node shape used as a partial by LazyPropertiesClass
 */
export class PartialClass {
  private _$identifier?: PartialClass.$Identifier;
  readonly $type = "PartialClass";
  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): PartialClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: PartialClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): PartialClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies PartialClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      PartialClass.$properties.lazilyResolvedStringProperty["identifier"],
      ...[this.lazilyResolvedStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PartialClass {
  export function $filter(
    filter: PartialClass.$Filter,
    value: PartialClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialClass> {
    return $propertiesFromJson(json).map(
      (properties) => new PartialClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return PartialClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new PartialClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "PartialClass";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "PartialClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "PartialClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("PartialClass"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    const $identifier: PartialClass.$Identifier =
      $parameters.resource.identifier;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              PartialClass.$properties.lazilyResolvedStringProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            PartialClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClass")}LazilyResolvedStringProperty`,
      ),
      predicate:
        PartialClass.$properties.lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("partialClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClass")}LazilyResolvedStringProperty`,
            ),
            predicate:
              PartialClass.$properties.lazilyResolvedStringProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClass")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "partialClass")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
/**
 * Node shape that has lazy properties.
 */
export class LazyPropertiesClass {
  private _$identifier?: LazyPropertiesClass.$Identifier;
  readonly $type = "LazyPropertiesClass";
  readonly optionalLazyToResolvedClassProperty: $LazyObjectOption<
    LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriIdentifierClass
  >;
  readonly optionalLazyToResolvedClassUnionProperty: $LazyObjectOption<
    LazilyResolvedClassUnion.$Identifier,
    $DefaultPartial,
    LazilyResolvedClassUnion
  >;
  readonly optionalLazyToResolvedIriIdentifierClassProperty: $LazyObjectOption<
    LazilyResolvedIriIdentifierClass.$Identifier,
    $NamedDefaultPartial,
    LazilyResolvedIriIdentifierClass
  >;
  readonly optionalPartialClassToResolvedClassProperty: $LazyObjectOption<
    LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
    PartialClass,
    LazilyResolvedBlankNodeOrIriIdentifierClass
  >;
  readonly optionalPartialClassToResolvedClassUnionProperty: $LazyObjectOption<
    LazilyResolvedClassUnion.$Identifier,
    PartialClass,
    LazilyResolvedClassUnion
  >;
  readonly optionalPartialClassUnionToResolvedClassUnionProperty: $LazyObjectOption<
    LazilyResolvedClassUnion.$Identifier,
    PartialClassUnion,
    LazilyResolvedClassUnion
  >;
  readonly requiredLazyToResolvedClassProperty: $LazyObject<
    LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriIdentifierClass
  >;
  readonly requiredPartialClassToResolvedClassProperty: $LazyObject<
    LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
    PartialClass,
    LazilyResolvedBlankNodeOrIriIdentifierClass
  >;
  readonly setLazyToResolvedClassProperty: $LazyObjectSet<
    LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
    $DefaultPartial,
    LazilyResolvedBlankNodeOrIriIdentifierClass
  >;
  readonly setPartialClassToResolvedClassProperty: $LazyObjectSet<
    LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
    PartialClass,
    LazilyResolvedBlankNodeOrIriIdentifierClass
  >;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly optionalLazyToResolvedClassProperty?:
      | $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >
      | LazilyResolvedBlankNodeOrIriIdentifierClass
      | purify.Maybe<LazilyResolvedBlankNodeOrIriIdentifierClass>;
    readonly optionalLazyToResolvedClassUnionProperty?:
      | $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          $DefaultPartial,
          LazilyResolvedClassUnion
        >
      | LazilyResolvedClassUnion
      | purify.Maybe<LazilyResolvedClassUnion>;
    readonly optionalLazyToResolvedIriIdentifierClassProperty?:
      | $LazyObjectOption<
          LazilyResolvedIriIdentifierClass.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierClass
        >
      | LazilyResolvedIriIdentifierClass
      | purify.Maybe<LazilyResolvedIriIdentifierClass>;
    readonly optionalPartialClassToResolvedClassProperty?:
      | $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >
      | LazilyResolvedBlankNodeOrIriIdentifierClass
      | purify.Maybe<LazilyResolvedBlankNodeOrIriIdentifierClass>;
    readonly optionalPartialClassToResolvedClassUnionProperty?:
      | $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClass,
          LazilyResolvedClassUnion
        >
      | LazilyResolvedClassUnion
      | purify.Maybe<LazilyResolvedClassUnion>;
    readonly optionalPartialClassUnionToResolvedClassUnionProperty?:
      | $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClassUnion,
          LazilyResolvedClassUnion
        >
      | LazilyResolvedClassUnion
      | purify.Maybe<LazilyResolvedClassUnion>;
    readonly requiredLazyToResolvedClassProperty:
      | $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >
      | LazilyResolvedBlankNodeOrIriIdentifierClass;
    readonly requiredPartialClassToResolvedClassProperty:
      | $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >
      | LazilyResolvedBlankNodeOrIriIdentifierClass;
    readonly setLazyToResolvedClassProperty?:
      | $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >
      | readonly LazilyResolvedBlankNodeOrIriIdentifierClass[];
    readonly setPartialClassToResolvedClassProperty?:
      | $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >
      | readonly LazilyResolvedBlankNodeOrIriIdentifierClass[];
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    if (
      typeof parameters.optionalLazyToResolvedClassProperty === "object" &&
      parameters.optionalLazyToResolvedClassProperty instanceof
        $LazyObjectOption
    ) {
      this.optionalLazyToResolvedClassProperty =
        parameters.optionalLazyToResolvedClassProperty;
    } else if (
      purify.Maybe.isMaybe(parameters.optionalLazyToResolvedClassProperty)
    ) {
      this.optionalLazyToResolvedClassProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: parameters.optionalLazyToResolvedClassProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          purify.Either.of(
            (
              parameters.optionalLazyToResolvedClassProperty as purify.Maybe<LazilyResolvedBlankNodeOrIriIdentifierClass>
            ).unsafeCoerce(),
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedClassProperty === "object"
    ) {
      this.optionalLazyToResolvedClassProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: purify.Maybe.of(
          new $DefaultPartial(parameters.optionalLazyToResolvedClassProperty),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.optionalLazyToResolvedClassProperty as LazilyResolvedBlankNodeOrIriIdentifierClass,
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedClassProperty === "undefined"
    ) {
      this.optionalLazyToResolvedClassProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: purify.Maybe.empty(),
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      this.optionalLazyToResolvedClassProperty =
        parameters.optionalLazyToResolvedClassProperty satisfies never;
    }

    if (
      typeof parameters.optionalLazyToResolvedClassUnionProperty === "object" &&
      parameters.optionalLazyToResolvedClassUnionProperty instanceof
        $LazyObjectOption
    ) {
      this.optionalLazyToResolvedClassUnionProperty =
        parameters.optionalLazyToResolvedClassUnionProperty;
    } else if (
      purify.Maybe.isMaybe(parameters.optionalLazyToResolvedClassUnionProperty)
    ) {
      this.optionalLazyToResolvedClassUnionProperty = new $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >({
        partial: parameters.optionalLazyToResolvedClassUnionProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          purify.Either.of(
            (
              parameters.optionalLazyToResolvedClassUnionProperty as purify.Maybe<LazilyResolvedClassUnion>
            ).unsafeCoerce(),
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedClassUnionProperty === "object"
    ) {
      this.optionalLazyToResolvedClassUnionProperty = new $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >({
        partial: purify.Maybe.of(
          new $DefaultPartial(
            parameters.optionalLazyToResolvedClassUnionProperty,
          ),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.optionalLazyToResolvedClassUnionProperty as LazilyResolvedClassUnion,
          ),
      });
    } else if (
      typeof parameters.optionalLazyToResolvedClassUnionProperty === "undefined"
    ) {
      this.optionalLazyToResolvedClassUnionProperty = new $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >({
        partial: purify.Maybe.empty(),
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      this.optionalLazyToResolvedClassUnionProperty =
        parameters.optionalLazyToResolvedClassUnionProperty satisfies never;
    }

    if (
      typeof parameters.optionalLazyToResolvedIriIdentifierClassProperty ===
        "object" &&
      parameters.optionalLazyToResolvedIriIdentifierClassProperty instanceof
        $LazyObjectOption
    ) {
      this.optionalLazyToResolvedIriIdentifierClassProperty =
        parameters.optionalLazyToResolvedIriIdentifierClassProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalLazyToResolvedIriIdentifierClassProperty,
      )
    ) {
      this.optionalLazyToResolvedIriIdentifierClassProperty =
        new $LazyObjectOption<
          LazilyResolvedIriIdentifierClass.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierClass
        >({
          partial:
            parameters.optionalLazyToResolvedIriIdentifierClassProperty.map(
              (object) => new $NamedDefaultPartial(object),
            ),
          resolver: async () =>
            purify.Either.of(
              (
                parameters.optionalLazyToResolvedIriIdentifierClassProperty as purify.Maybe<LazilyResolvedIriIdentifierClass>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalLazyToResolvedIriIdentifierClassProperty ===
      "object"
    ) {
      this.optionalLazyToResolvedIriIdentifierClassProperty =
        new $LazyObjectOption<
          LazilyResolvedIriIdentifierClass.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierClass
        >({
          partial: purify.Maybe.of(
            new $NamedDefaultPartial(
              parameters.optionalLazyToResolvedIriIdentifierClassProperty,
            ),
          ),
          resolver: async () =>
            purify.Either.of(
              parameters.optionalLazyToResolvedIriIdentifierClassProperty as LazilyResolvedIriIdentifierClass,
            ),
        });
    } else if (
      typeof parameters.optionalLazyToResolvedIriIdentifierClassProperty ===
      "undefined"
    ) {
      this.optionalLazyToResolvedIriIdentifierClassProperty =
        new $LazyObjectOption<
          LazilyResolvedIriIdentifierClass.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierClass
        >({
          partial: purify.Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      this.optionalLazyToResolvedIriIdentifierClassProperty =
        parameters.optionalLazyToResolvedIriIdentifierClassProperty satisfies never;
    }

    if (
      typeof parameters.optionalPartialClassToResolvedClassProperty ===
        "object" &&
      parameters.optionalPartialClassToResolvedClassProperty instanceof
        $LazyObjectOption
    ) {
      this.optionalPartialClassToResolvedClassProperty =
        parameters.optionalPartialClassToResolvedClassProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalPartialClassToResolvedClassProperty,
      )
    ) {
      this.optionalPartialClassToResolvedClassProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: parameters.optionalPartialClassToResolvedClassProperty.map(
          (object) => new PartialClass(object),
        ),
        resolver: async () =>
          purify.Either.of(
            (
              parameters.optionalPartialClassToResolvedClassProperty as purify.Maybe<LazilyResolvedBlankNodeOrIriIdentifierClass>
            ).unsafeCoerce(),
          ),
      });
    } else if (
      typeof parameters.optionalPartialClassToResolvedClassProperty === "object"
    ) {
      this.optionalPartialClassToResolvedClassProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: purify.Maybe.of(
          new PartialClass(
            parameters.optionalPartialClassToResolvedClassProperty,
          ),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.optionalPartialClassToResolvedClassProperty as LazilyResolvedBlankNodeOrIriIdentifierClass,
          ),
      });
    } else if (
      typeof parameters.optionalPartialClassToResolvedClassProperty ===
      "undefined"
    ) {
      this.optionalPartialClassToResolvedClassProperty = new $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: purify.Maybe.empty(),
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      this.optionalPartialClassToResolvedClassProperty =
        parameters.optionalPartialClassToResolvedClassProperty satisfies never;
    }

    if (
      typeof parameters.optionalPartialClassToResolvedClassUnionProperty ===
        "object" &&
      parameters.optionalPartialClassToResolvedClassUnionProperty instanceof
        $LazyObjectOption
    ) {
      this.optionalPartialClassToResolvedClassUnionProperty =
        parameters.optionalPartialClassToResolvedClassUnionProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalPartialClassToResolvedClassUnionProperty,
      )
    ) {
      this.optionalPartialClassToResolvedClassUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClass,
          LazilyResolvedClassUnion
        >({
          partial:
            parameters.optionalPartialClassToResolvedClassUnionProperty.map(
              (object) => new PartialClass(object),
            ),
          resolver: async () =>
            purify.Either.of(
              (
                parameters.optionalPartialClassToResolvedClassUnionProperty as purify.Maybe<LazilyResolvedClassUnion>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalPartialClassToResolvedClassUnionProperty ===
      "object"
    ) {
      this.optionalPartialClassToResolvedClassUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClass,
          LazilyResolvedClassUnion
        >({
          partial: purify.Maybe.of(
            new PartialClass(
              parameters.optionalPartialClassToResolvedClassUnionProperty,
            ),
          ),
          resolver: async () =>
            purify.Either.of(
              parameters.optionalPartialClassToResolvedClassUnionProperty as LazilyResolvedClassUnion,
            ),
        });
    } else if (
      typeof parameters.optionalPartialClassToResolvedClassUnionProperty ===
      "undefined"
    ) {
      this.optionalPartialClassToResolvedClassUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClass,
          LazilyResolvedClassUnion
        >({
          partial: purify.Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      this.optionalPartialClassToResolvedClassUnionProperty =
        parameters.optionalPartialClassToResolvedClassUnionProperty satisfies never;
    }

    if (
      typeof parameters.optionalPartialClassUnionToResolvedClassUnionProperty ===
        "object" &&
      parameters.optionalPartialClassUnionToResolvedClassUnionProperty instanceof
        $LazyObjectOption
    ) {
      this.optionalPartialClassUnionToResolvedClassUnionProperty =
        parameters.optionalPartialClassUnionToResolvedClassUnionProperty;
    } else if (
      purify.Maybe.isMaybe(
        parameters.optionalPartialClassUnionToResolvedClassUnionProperty,
      )
    ) {
      this.optionalPartialClassUnionToResolvedClassUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClassUnion,
          LazilyResolvedClassUnion
        >({
          partial:
            parameters.optionalPartialClassUnionToResolvedClassUnionProperty.map(
              (object) => {
                switch (object.$type) {
                  case "LazilyResolvedClassUnionMember1":
                    return new PartialClassUnionMember1(object);
                  case "LazilyResolvedClassUnionMember2":
                    return new PartialClassUnionMember2(object);
                  default:
                    object satisfies never;
                    throw new Error("unrecognized type");
                }
              },
            ),
          resolver: async () =>
            purify.Either.of(
              (
                parameters.optionalPartialClassUnionToResolvedClassUnionProperty as purify.Maybe<LazilyResolvedClassUnion>
              ).unsafeCoerce(),
            ),
        });
    } else if (
      typeof parameters.optionalPartialClassUnionToResolvedClassUnionProperty ===
      "object"
    ) {
      this.optionalPartialClassUnionToResolvedClassUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClassUnion,
          LazilyResolvedClassUnion
        >({
          partial: purify.Maybe.of(
            parameters.optionalPartialClassUnionToResolvedClassUnionProperty,
          ).map((object) => {
            switch (object.$type) {
              case "LazilyResolvedClassUnionMember1":
                return new PartialClassUnionMember1(object);
              case "LazilyResolvedClassUnionMember2":
                return new PartialClassUnionMember2(object);
              default:
                object satisfies never;
                throw new Error("unrecognized type");
            }
          }),
          resolver: async () =>
            purify.Either.of(
              parameters.optionalPartialClassUnionToResolvedClassUnionProperty as LazilyResolvedClassUnion,
            ),
        });
    } else if (
      typeof parameters.optionalPartialClassUnionToResolvedClassUnionProperty ===
      "undefined"
    ) {
      this.optionalPartialClassUnionToResolvedClassUnionProperty =
        new $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClassUnion,
          LazilyResolvedClassUnion
        >({
          partial: purify.Maybe.empty(),
          resolver: async () => {
            throw new Error("should never be called");
          },
        });
    } else {
      this.optionalPartialClassUnionToResolvedClassUnionProperty =
        parameters.optionalPartialClassUnionToResolvedClassUnionProperty satisfies never;
    }

    if (
      typeof parameters.requiredLazyToResolvedClassProperty === "object" &&
      parameters.requiredLazyToResolvedClassProperty instanceof $LazyObject
    ) {
      this.requiredLazyToResolvedClassProperty =
        parameters.requiredLazyToResolvedClassProperty;
    } else if (
      typeof parameters.requiredLazyToResolvedClassProperty === "object"
    ) {
      this.requiredLazyToResolvedClassProperty = new $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: new $DefaultPartial(
          parameters.requiredLazyToResolvedClassProperty,
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.requiredLazyToResolvedClassProperty as LazilyResolvedBlankNodeOrIriIdentifierClass,
          ),
      });
    } else {
      this.requiredLazyToResolvedClassProperty =
        parameters.requiredLazyToResolvedClassProperty satisfies never;
    }

    if (
      typeof parameters.requiredPartialClassToResolvedClassProperty ===
        "object" &&
      parameters.requiredPartialClassToResolvedClassProperty instanceof
        $LazyObject
    ) {
      this.requiredPartialClassToResolvedClassProperty =
        parameters.requiredPartialClassToResolvedClassProperty;
    } else if (
      typeof parameters.requiredPartialClassToResolvedClassProperty === "object"
    ) {
      this.requiredPartialClassToResolvedClassProperty = new $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partial: new PartialClass(
          parameters.requiredPartialClassToResolvedClassProperty,
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.requiredPartialClassToResolvedClassProperty as LazilyResolvedBlankNodeOrIriIdentifierClass,
          ),
      });
    } else {
      this.requiredPartialClassToResolvedClassProperty =
        parameters.requiredPartialClassToResolvedClassProperty satisfies never;
    }

    if (
      typeof parameters.setLazyToResolvedClassProperty === "object" &&
      parameters.setLazyToResolvedClassProperty instanceof $LazyObjectSet
    ) {
      this.setLazyToResolvedClassProperty =
        parameters.setLazyToResolvedClassProperty;
    } else if (typeof parameters.setLazyToResolvedClassProperty === "object") {
      this.setLazyToResolvedClassProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partials: parameters.setLazyToResolvedClassProperty.map(
          (object) => new $DefaultPartial(object),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.setLazyToResolvedClassProperty as readonly LazilyResolvedBlankNodeOrIriIdentifierClass[],
          ),
      });
    } else if (
      typeof parameters.setLazyToResolvedClassProperty === "undefined"
    ) {
      this.setLazyToResolvedClassProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partials: [],
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      this.setLazyToResolvedClassProperty =
        parameters.setLazyToResolvedClassProperty satisfies never;
    }

    if (
      typeof parameters.setPartialClassToResolvedClassProperty === "object" &&
      parameters.setPartialClassToResolvedClassProperty instanceof
        $LazyObjectSet
    ) {
      this.setPartialClassToResolvedClassProperty =
        parameters.setPartialClassToResolvedClassProperty;
    } else if (
      typeof parameters.setPartialClassToResolvedClassProperty === "object"
    ) {
      this.setPartialClassToResolvedClassProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partials: parameters.setPartialClassToResolvedClassProperty.map(
          (object) => new PartialClass(object),
        ),
        resolver: async () =>
          purify.Either.of(
            parameters.setPartialClassToResolvedClassProperty as readonly LazilyResolvedBlankNodeOrIriIdentifierClass[],
          ),
      });
    } else if (
      typeof parameters.setPartialClassToResolvedClassProperty === "undefined"
    ) {
      this.setPartialClassToResolvedClassProperty = new $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >({
        partials: [],
        resolver: async () => {
          throw new Error("should never be called");
        },
      });
    } else {
      this.setPartialClassToResolvedClassProperty =
        parameters.setPartialClassToResolvedClassProperty satisfies never;
    }
  }

  get $identifier(): LazyPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: LazyPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          this.optionalLazyToResolvedClassProperty,
          other.optionalLazyToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalLazyToResolvedClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          this.optionalLazyToResolvedClassUnionProperty,
          other.optionalLazyToResolvedClassUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalLazyToResolvedClassUnionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          this.optionalLazyToResolvedIriIdentifierClassProperty,
          other.optionalLazyToResolvedIriIdentifierClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalLazyToResolvedIriIdentifierClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          this.optionalPartialClassToResolvedClassProperty,
          other.optionalPartialClassToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalPartialClassToResolvedClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, (left, right) => left.$equals(right)))(
            left.partial,
            right.partial,
          ))(
          this.optionalPartialClassToResolvedClassUnionProperty,
          other.optionalPartialClassToResolvedClassUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalPartialClassToResolvedClassUnionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $maybeEquals(left, right, PartialClassUnion.$equals))(
            left.partial,
            right.partial,
          ))(
          this.optionalPartialClassUnionToResolvedClassUnionProperty,
          other.optionalPartialClassUnionToResolvedClassUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "optionalPartialClassUnionToResolvedClassUnionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) => left.$equals(right))(left.partial, right.partial))(
          this.requiredLazyToResolvedClassProperty,
          other.requiredLazyToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "requiredLazyToResolvedClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) => left.$equals(right))(left.partial, right.partial))(
          this.requiredPartialClassToResolvedClassProperty,
          other.requiredPartialClassToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "requiredPartialClassToResolvedClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $arrayEquals(left, right, (left, right) => left.$equals(right)))(
            left.partials,
            right.partials,
          ))(
          this.setLazyToResolvedClassProperty,
          other.setLazyToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "setLazyToResolvedClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          ((left, right) =>
            $arrayEquals(left, right, (left, right) => left.$equals(right)))(
            left.partials,
            right.partials,
          ))(
          this.setPartialClassToResolvedClassProperty,
          other.setPartialClassToResolvedClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "setPartialClassToResolvedClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.optionalLazyToResolvedClassProperty.partial.ifJust((value1) => {
      value1.$hash(_hasher);
    });
    this.optionalLazyToResolvedClassUnionProperty.partial.ifJust((value1) => {
      value1.$hash(_hasher);
    });
    this.optionalLazyToResolvedIriIdentifierClassProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    this.optionalPartialClassToResolvedClassProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    this.optionalPartialClassToResolvedClassUnionProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    this.optionalPartialClassUnionToResolvedClassUnionProperty.partial.ifJust(
      (value1) => {
        value1.$hash(_hasher);
      },
    );
    this.requiredLazyToResolvedClassProperty.partial.$hash(_hasher);
    this.requiredPartialClassToResolvedClassProperty.partial.$hash(_hasher);
    for (const item1 of this.setLazyToResolvedClassProperty.partials) {
      item1.$hash(_hasher);
    }

    for (const item1 of this.setPartialClassToResolvedClassProperty.partials) {
      item1.$hash(_hasher);
    }

    return _hasher;
  }

  $toJson(): LazyPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        optionalLazyToResolvedClassProperty:
          this.optionalLazyToResolvedClassProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalLazyToResolvedClassUnionProperty:
          this.optionalLazyToResolvedClassUnionProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalLazyToResolvedIriIdentifierClassProperty:
          this.optionalLazyToResolvedIriIdentifierClassProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalPartialClassToResolvedClassProperty:
          this.optionalPartialClassToResolvedClassProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalPartialClassToResolvedClassUnionProperty:
          this.optionalPartialClassToResolvedClassUnionProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        optionalPartialClassUnionToResolvedClassUnionProperty:
          this.optionalPartialClassUnionToResolvedClassUnionProperty.partial
            .map((item) => item.$toJson())
            .extract(),
        requiredLazyToResolvedClassProperty:
          this.requiredLazyToResolvedClassProperty.partial.$toJson(),
        requiredPartialClassToResolvedClassProperty:
          this.requiredPartialClassToResolvedClassProperty.partial.$toJson(),
        setLazyToResolvedClassProperty:
          this.setLazyToResolvedClassProperty.partials.map((item) =>
            item.$toJson(),
          ),
        setPartialClassToResolvedClassProperty:
          this.setPartialClassToResolvedClassProperty.partials.map((item) =>
            item.$toJson(),
          ),
      } satisfies LazyPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      LazyPropertiesClass.$properties.optionalLazyToResolvedClassProperty[
        "identifier"
      ],
      ...this.optionalLazyToResolvedClassProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesClass.$properties.optionalLazyToResolvedClassUnionProperty[
        "identifier"
      ],
      ...this.optionalLazyToResolvedClassUnionProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesClass.$properties
        .optionalLazyToResolvedIriIdentifierClassProperty["identifier"],
      ...this.optionalLazyToResolvedIriIdentifierClassProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesClass.$properties
        .optionalPartialClassToResolvedClassProperty["identifier"],
      ...this.optionalPartialClassToResolvedClassProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesClass.$properties
        .optionalPartialClassToResolvedClassUnionProperty["identifier"],
      ...this.optionalPartialClassToResolvedClassUnionProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesClass.$properties
        .optionalPartialClassUnionToResolvedClassUnionProperty["identifier"],
      ...this.optionalPartialClassUnionToResolvedClassUnionProperty.partial
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    resource.add(
      LazyPropertiesClass.$properties.requiredLazyToResolvedClassProperty[
        "identifier"
      ],
      ...[
        this.requiredLazyToResolvedClassProperty.partial.$toRdf({
          mutateGraph: mutateGraph,
          resourceSet: resourceSet,
        }).identifier,
      ],
    );
    resource.add(
      LazyPropertiesClass.$properties
        .requiredPartialClassToResolvedClassProperty["identifier"],
      ...[
        this.requiredPartialClassToResolvedClassProperty.partial.$toRdf({
          mutateGraph: mutateGraph,
          resourceSet: resourceSet,
        }).identifier,
      ],
    );
    resource.add(
      LazyPropertiesClass.$properties.setLazyToResolvedClassProperty[
        "identifier"
      ],
      ...this.setLazyToResolvedClassProperty.partials.flatMap((item) => [
        item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
          .identifier,
      ]),
    );
    resource.add(
      LazyPropertiesClass.$properties.setPartialClassToResolvedClassProperty[
        "identifier"
      ],
      ...this.setPartialClassToResolvedClassProperty.partials.flatMap(
        (item) => [
          item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ],
      ),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LazyPropertiesClass {
  export function $filter(
    filter: LazyPropertiesClass.$Filter,
    value: LazyPropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.optionalLazyToResolvedClassProperty !== "undefined" &&
      !((
        filter: $MaybeFilter<$DefaultPartial.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >,
      ) =>
        $filterMaybe<$DefaultPartial, $DefaultPartial.$Filter>(
          $DefaultPartial.$filter,
        )(filter, value.partial))(
        filter.optionalLazyToResolvedClassProperty,
        value.optionalLazyToResolvedClassProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalLazyToResolvedClassUnionProperty !== "undefined" &&
      !((
        filter: $MaybeFilter<$DefaultPartial.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          $DefaultPartial,
          LazilyResolvedClassUnion
        >,
      ) =>
        $filterMaybe<$DefaultPartial, $DefaultPartial.$Filter>(
          $DefaultPartial.$filter,
        )(filter, value.partial))(
        filter.optionalLazyToResolvedClassUnionProperty,
        value.optionalLazyToResolvedClassUnionProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalLazyToResolvedIriIdentifierClassProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<$NamedDefaultPartial.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedIriIdentifierClass.$Identifier,
          $NamedDefaultPartial,
          LazilyResolvedIriIdentifierClass
        >,
      ) =>
        $filterMaybe<$NamedDefaultPartial, $NamedDefaultPartial.$Filter>(
          $NamedDefaultPartial.$filter,
        )(filter, value.partial))(
        filter.optionalLazyToResolvedIriIdentifierClassProperty,
        value.optionalLazyToResolvedIriIdentifierClassProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalPartialClassToResolvedClassProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<PartialClass.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >,
      ) =>
        $filterMaybe<PartialClass, PartialClass.$Filter>(PartialClass.$filter)(
          filter,
          value.partial,
        ))(
        filter.optionalPartialClassToResolvedClassProperty,
        value.optionalPartialClassToResolvedClassProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalPartialClassToResolvedClassUnionProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<PartialClass.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClass,
          LazilyResolvedClassUnion
        >,
      ) =>
        $filterMaybe<PartialClass, PartialClass.$Filter>(PartialClass.$filter)(
          filter,
          value.partial,
        ))(
        filter.optionalPartialClassToResolvedClassUnionProperty,
        value.optionalPartialClassToResolvedClassUnionProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.optionalPartialClassUnionToResolvedClassUnionProperty !==
        "undefined" &&
      !((
        filter: $MaybeFilter<PartialClassUnion.$Filter>,
        value: $LazyObjectOption<
          LazilyResolvedClassUnion.$Identifier,
          PartialClassUnion,
          LazilyResolvedClassUnion
        >,
      ) =>
        $filterMaybe<PartialClassUnion, PartialClassUnion.$Filter>(
          PartialClassUnion.$filter,
        )(filter, value.partial))(
        filter.optionalPartialClassUnionToResolvedClassUnionProperty,
        value.optionalPartialClassUnionToResolvedClassUnionProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.requiredLazyToResolvedClassProperty !== "undefined" &&
      !((
        filter: $DefaultPartial.$Filter,
        value: $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >,
      ) => $DefaultPartial.$filter(filter, value.partial))(
        filter.requiredLazyToResolvedClassProperty,
        value.requiredLazyToResolvedClassProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.requiredPartialClassToResolvedClassProperty !==
        "undefined" &&
      !((
        filter: PartialClass.$Filter,
        value: $LazyObject<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >,
      ) => PartialClass.$filter(filter, value.partial))(
        filter.requiredPartialClassToResolvedClassProperty,
        value.requiredPartialClassToResolvedClassProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.setLazyToResolvedClassProperty !== "undefined" &&
      !((
        filter: $CollectionFilter<$DefaultPartial.$Filter>,
        value: $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          $DefaultPartial,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >,
      ) =>
        $filterArray<$DefaultPartial, $DefaultPartial.$Filter>(
          $DefaultPartial.$filter,
        )(filter, value.partials))(
        filter.setLazyToResolvedClassProperty,
        value.setLazyToResolvedClassProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.setPartialClassToResolvedClassProperty !== "undefined" &&
      !((
        filter: $CollectionFilter<PartialClass.$Filter>,
        value: $LazyObjectSet<
          LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
          PartialClass,
          LazilyResolvedBlankNodeOrIriIdentifierClass
        >,
      ) =>
        $filterArray<PartialClass, PartialClass.$Filter>(PartialClass.$filter)(
          filter,
          value.partials,
        ))(
        filter.setPartialClassToResolvedClassProperty,
        value.setPartialClassToResolvedClassProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly optionalLazyToResolvedClassProperty?: $MaybeFilter<$DefaultPartial.$Filter>;
    readonly optionalLazyToResolvedClassUnionProperty?: $MaybeFilter<$DefaultPartial.$Filter>;
    readonly optionalLazyToResolvedIriIdentifierClassProperty?: $MaybeFilter<$NamedDefaultPartial.$Filter>;
    readonly optionalPartialClassToResolvedClassProperty?: $MaybeFilter<PartialClass.$Filter>;
    readonly optionalPartialClassToResolvedClassUnionProperty?: $MaybeFilter<PartialClass.$Filter>;
    readonly optionalPartialClassUnionToResolvedClassUnionProperty?: $MaybeFilter<PartialClassUnion.$Filter>;
    readonly requiredLazyToResolvedClassProperty?: $DefaultPartial.$Filter;
    readonly requiredPartialClassToResolvedClassProperty?: PartialClass.$Filter;
    readonly setLazyToResolvedClassProperty?: $CollectionFilter<$DefaultPartial.$Filter>;
    readonly setPartialClassToResolvedClassProperty?: $CollectionFilter<PartialClass.$Filter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazyPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new LazyPropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazyPropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazyPropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new LazyPropertiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazyPropertiesClass";
    readonly optionalLazyToResolvedClassProperty?: $DefaultPartial.$Json;
    readonly optionalLazyToResolvedClassUnionProperty?: $DefaultPartial.$Json;
    readonly optionalLazyToResolvedIriIdentifierClassProperty?: $NamedDefaultPartial.$Json;
    readonly optionalPartialClassToResolvedClassProperty?: PartialClass.$Json;
    readonly optionalPartialClassToResolvedClassUnionProperty?: PartialClass.$Json;
    readonly optionalPartialClassUnionToResolvedClassUnionProperty?:
      | PartialClassUnionMember1.$Json
      | PartialClassUnionMember2.$Json;
    readonly requiredLazyToResolvedClassProperty: $DefaultPartial.$Json;
    readonly requiredPartialClassToResolvedClassProperty: PartialClass.$Json;
    readonly setLazyToResolvedClassProperty?: readonly $DefaultPartial.$Json[];
    readonly setPartialClassToResolvedClassProperty?: readonly PartialClass.$Json[];
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazyPropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedClassProperty`,
        }),
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedClassUnionProperty`,
        }),
        $NamedDefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalLazyToResolvedIriIdentifierClassProperty`,
        }),
        PartialClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalPartialClassToResolvedClassProperty`,
        }),
        PartialClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/optionalPartialClassToResolvedClassUnionProperty`,
        }),
        {
          scope: `${scopePrefix}/properties/optionalPartialClassUnionToResolvedClassUnionProperty`,
          type: "Control",
        },
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/requiredLazyToResolvedClassProperty`,
        }),
        PartialClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/requiredPartialClassToResolvedClassProperty`,
        }),
        $DefaultPartial.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/setLazyToResolvedClassProperty`,
        }),
        PartialClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/setPartialClassToResolvedClassProperty`,
        }),
      ],
      label: "LazyPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazyPropertiesClass"),
      optionalLazyToResolvedClassProperty: $DefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalLazyToResolvedClassUnionProperty: $DefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalLazyToResolvedIriIdentifierClassProperty: $NamedDefaultPartial
        .$jsonZodSchema()
        .optional(),
      optionalPartialClassToResolvedClassProperty:
        PartialClass.$jsonZodSchema().optional(),
      optionalPartialClassToResolvedClassUnionProperty:
        PartialClass.$jsonZodSchema().optional(),
      optionalPartialClassUnionToResolvedClassUnionProperty:
        PartialClassUnion.$jsonZodSchema().optional(),
      requiredLazyToResolvedClassProperty: $DefaultPartial.$jsonZodSchema(),
      requiredPartialClassToResolvedClassProperty:
        PartialClass.$jsonZodSchema(),
      setLazyToResolvedClassProperty: $DefaultPartial
        .$jsonZodSchema()
        .array()
        .default(() => []),
      setPartialClassToResolvedClassProperty: PartialClass.$jsonZodSchema()
        .array()
        .default(() => []),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    optionalLazyToResolvedClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalLazyToResolvedClassProperty",
      ),
    },
    optionalLazyToResolvedClassUnionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalLazyToResolvedClassUnionProperty",
      ),
    },
    optionalLazyToResolvedIriIdentifierClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalLazyToResolvedIriIdentifierClassProperty",
      ),
    },
    optionalPartialClassToResolvedClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalPartialClassToResolvedClassProperty",
      ),
    },
    optionalPartialClassToResolvedClassUnionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalPartialClassToResolvedClassUnionProperty",
      ),
    },
    optionalPartialClassUnionToResolvedClassUnionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/optionalPartialClassUnionToResolvedClassUnionProperty",
      ),
    },
    requiredLazyToResolvedClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/requiredLazyToResolvedClassProperty",
      ),
    },
    requiredPartialClassToResolvedClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/requiredPartialClassToResolvedClassProperty",
      ),
    },
    setLazyToResolvedClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/setLazyToResolvedClassProperty",
      ),
    },
    setPartialClassToResolvedClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/setPartialClassToResolvedClassProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      optionalLazyToResolvedClassProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      optionalLazyToResolvedClassUnionProperty: $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >;
      optionalLazyToResolvedIriIdentifierClassProperty: $LazyObjectOption<
        LazilyResolvedIriIdentifierClass.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriIdentifierClass
      >;
      optionalPartialClassToResolvedClassProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      optionalPartialClassToResolvedClassUnionProperty: $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        PartialClass,
        LazilyResolvedClassUnion
      >;
      optionalPartialClassUnionToResolvedClassUnionProperty: $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        PartialClassUnion,
        LazilyResolvedClassUnion
      >;
      requiredLazyToResolvedClassProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      requiredPartialClassToResolvedClassProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      setLazyToResolvedClassProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      setPartialClassToResolvedClassProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const optionalLazyToResolvedClassProperty = new $LazyObjectOption<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierClass
    >({
      partial: purify.Maybe.fromNullable(
        $jsonObject["optionalLazyToResolvedClassProperty"],
      ).map((item) => $DefaultPartial.$fromJson(item).unsafeCoerce()),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const optionalLazyToResolvedClassUnionProperty = new $LazyObjectOption<
      LazilyResolvedClassUnion.$Identifier,
      $DefaultPartial,
      LazilyResolvedClassUnion
    >({
      partial: purify.Maybe.fromNullable(
        $jsonObject["optionalLazyToResolvedClassUnionProperty"],
      ).map((item) => $DefaultPartial.$fromJson(item).unsafeCoerce()),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const optionalLazyToResolvedIriIdentifierClassProperty =
      new $LazyObjectOption<
        LazilyResolvedIriIdentifierClass.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriIdentifierClass
      >({
        partial: purify.Maybe.fromNullable(
          $jsonObject["optionalLazyToResolvedIriIdentifierClassProperty"],
        ).map((item) => $NamedDefaultPartial.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            purify.Left(
              new Error(
                `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const optionalPartialClassToResolvedClassProperty = new $LazyObjectOption<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
      PartialClass,
      LazilyResolvedBlankNodeOrIriIdentifierClass
    >({
      partial: purify.Maybe.fromNullable(
        $jsonObject["optionalPartialClassToResolvedClassProperty"],
      ).map((item) => PartialClass.$fromJson(item).unsafeCoerce()),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const optionalPartialClassToResolvedClassUnionProperty =
      new $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        PartialClass,
        LazilyResolvedClassUnion
      >({
        partial: purify.Maybe.fromNullable(
          $jsonObject["optionalPartialClassToResolvedClassUnionProperty"],
        ).map((item) => PartialClass.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            purify.Left(
              new Error(
                `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const optionalPartialClassUnionToResolvedClassUnionProperty =
      new $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        PartialClassUnion,
        LazilyResolvedClassUnion
      >({
        partial: purify.Maybe.fromNullable(
          $jsonObject["optionalPartialClassUnionToResolvedClassUnionProperty"],
        ).map((item) => PartialClassUnion.$fromJson(item).unsafeCoerce()),
        resolver: (identifier) =>
          Promise.resolve(
            purify.Left(
              new Error(
                `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
              ),
            ),
          ),
      });
    const requiredLazyToResolvedClassProperty = new $LazyObject<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierClass
    >({
      partial: $DefaultPartial
        .$fromJson($jsonObject["requiredLazyToResolvedClassProperty"])
        .unsafeCoerce(),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const requiredPartialClassToResolvedClassProperty = new $LazyObject<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
      PartialClass,
      LazilyResolvedBlankNodeOrIriIdentifierClass
    >({
      partial: PartialClass.$fromJson(
        $jsonObject["requiredPartialClassToResolvedClassProperty"],
      ).unsafeCoerce(),
      resolver: (identifier) =>
        Promise.resolve(
          purify.Left(
            new Error(
              `unable to resolve identifier ${rdfjsResource.Resource.Identifier.toString(identifier)} deserialized from JSON`,
            ),
          ),
        ),
    });
    const setLazyToResolvedClassProperty = new $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
      $DefaultPartial,
      LazilyResolvedBlankNodeOrIriIdentifierClass
    >({
      partials: $jsonObject["setLazyToResolvedClassProperty"].map((item) =>
        $DefaultPartial.$fromJson(item).unsafeCoerce(),
      ),
      resolver: () =>
        Promise.resolve(
          purify.Left(
            new Error("unable to resolve identifiers deserialized from JSON"),
          ),
        ),
    });
    const setPartialClassToResolvedClassProperty = new $LazyObjectSet<
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
      PartialClass,
      LazilyResolvedBlankNodeOrIriIdentifierClass
    >({
      partials: $jsonObject["setPartialClassToResolvedClassProperty"].map(
        (item) => PartialClass.$fromJson(item).unsafeCoerce(),
      ),
      resolver: () =>
        Promise.resolve(
          purify.Left(
            new Error("unable to resolve identifiers deserialized from JSON"),
          ),
        ),
    });
    return purify.Either.of({
      $identifier,
      optionalLazyToResolvedClassProperty,
      optionalLazyToResolvedClassUnionProperty,
      optionalLazyToResolvedIriIdentifierClassProperty,
      optionalPartialClassToResolvedClassProperty,
      optionalPartialClassToResolvedClassUnionProperty,
      optionalPartialClassUnionToResolvedClassUnionProperty,
      requiredLazyToResolvedClassProperty,
      requiredPartialClassToResolvedClassProperty,
      setLazyToResolvedClassProperty,
      setPartialClassToResolvedClassProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      optionalLazyToResolvedClassProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      optionalLazyToResolvedClassUnionProperty: $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >;
      optionalLazyToResolvedIriIdentifierClassProperty: $LazyObjectOption<
        LazilyResolvedIriIdentifierClass.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriIdentifierClass
      >;
      optionalPartialClassToResolvedClassProperty: $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      optionalPartialClassToResolvedClassUnionProperty: $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        PartialClass,
        LazilyResolvedClassUnion
      >;
      optionalPartialClassUnionToResolvedClassUnionProperty: $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        PartialClassUnion,
        LazilyResolvedClassUnion
      >;
      requiredLazyToResolvedClassProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      requiredPartialClassToResolvedClassProperty: $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      setLazyToResolvedClassProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
      setPartialClassToResolvedClassProperty: $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >;
    }
  > {
    const $identifier: LazyPropertiesClass.$Identifier =
      $parameters.resource.identifier;
    const _optionalLazyToResolvedClassPropertyEither: purify.Either<
      Error,
      $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.optionalLazyToResolvedClassProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            $DefaultPartial.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<$DefaultPartial>
            >({
              focusResource: $parameters.resource,
              predicate:
                LazyPropertiesClass.$properties
                  .optionalLazyToResolvedClassProperty["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyObjectOption<
              LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
              $DefaultPartial,
              LazilyResolvedBlankNodeOrIriIdentifierClass
            >({
              partial,
              resolver: (identifier) =>
                $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierClass(
                  identifier,
                ),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_optionalLazyToResolvedClassPropertyEither.isLeft()) {
      return _optionalLazyToResolvedClassPropertyEither;
    }

    const optionalLazyToResolvedClassProperty =
      _optionalLazyToResolvedClassPropertyEither.unsafeCoerce();
    const _optionalLazyToResolvedClassUnionPropertyEither: purify.Either<
      Error,
      $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        $DefaultPartial,
        LazilyResolvedClassUnion
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.optionalLazyToResolvedClassUnionProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            $DefaultPartial.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<$DefaultPartial>
            >({
              focusResource: $parameters.resource,
              predicate:
                LazyPropertiesClass.$properties
                  .optionalLazyToResolvedClassUnionProperty["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyObjectOption<
              LazilyResolvedClassUnion.$Identifier,
              $DefaultPartial,
              LazilyResolvedClassUnion
            >({
              partial,
              resolver: (identifier) =>
                $parameters.objectSet.lazilyResolvedClassUnion(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_optionalLazyToResolvedClassUnionPropertyEither.isLeft()) {
      return _optionalLazyToResolvedClassUnionPropertyEither;
    }

    const optionalLazyToResolvedClassUnionProperty =
      _optionalLazyToResolvedClassUnionPropertyEither.unsafeCoerce();
    const _optionalLazyToResolvedIriIdentifierClassPropertyEither: purify.Either<
      Error,
      $LazyObjectOption<
        LazilyResolvedIriIdentifierClass.$Identifier,
        $NamedDefaultPartial,
        LazilyResolvedIriIdentifierClass
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.optionalLazyToResolvedIriIdentifierClassProperty[
          "identifier"
        ],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            $NamedDefaultPartial.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<$NamedDefaultPartial>
            >({
              focusResource: $parameters.resource,
              predicate:
                LazyPropertiesClass.$properties
                  .optionalLazyToResolvedIriIdentifierClassProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyObjectOption<
              LazilyResolvedIriIdentifierClass.$Identifier,
              $NamedDefaultPartial,
              LazilyResolvedIriIdentifierClass
            >({
              partial,
              resolver: (identifier) =>
                $parameters.objectSet.lazilyResolvedIriIdentifierClass(
                  identifier,
                ),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_optionalLazyToResolvedIriIdentifierClassPropertyEither.isLeft()) {
      return _optionalLazyToResolvedIriIdentifierClassPropertyEither;
    }

    const optionalLazyToResolvedIriIdentifierClassProperty =
      _optionalLazyToResolvedIriIdentifierClassPropertyEither.unsafeCoerce();
    const _optionalPartialClassToResolvedClassPropertyEither: purify.Either<
      Error,
      $LazyObjectOption<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.optionalPartialClassToResolvedClassProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            PartialClass.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<PartialClass>>(
              {
                focusResource: $parameters.resource,
                predicate:
                  LazyPropertiesClass.$properties
                    .optionalPartialClassToResolvedClassProperty["identifier"],
                value: purify.Maybe.empty(),
              },
            ),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyObjectOption<
              LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
              PartialClass,
              LazilyResolvedBlankNodeOrIriIdentifierClass
            >({
              partial,
              resolver: (identifier) =>
                $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierClass(
                  identifier,
                ),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_optionalPartialClassToResolvedClassPropertyEither.isLeft()) {
      return _optionalPartialClassToResolvedClassPropertyEither;
    }

    const optionalPartialClassToResolvedClassProperty =
      _optionalPartialClassToResolvedClassPropertyEither.unsafeCoerce();
    const _optionalPartialClassToResolvedClassUnionPropertyEither: purify.Either<
      Error,
      $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        PartialClass,
        LazilyResolvedClassUnion
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.optionalPartialClassToResolvedClassUnionProperty[
          "identifier"
        ],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            PartialClass.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<PartialClass>>(
              {
                focusResource: $parameters.resource,
                predicate:
                  LazyPropertiesClass.$properties
                    .optionalPartialClassToResolvedClassUnionProperty[
                    "identifier"
                  ],
                value: purify.Maybe.empty(),
              },
            ),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyObjectOption<
              LazilyResolvedClassUnion.$Identifier,
              PartialClass,
              LazilyResolvedClassUnion
            >({
              partial,
              resolver: (identifier) =>
                $parameters.objectSet.lazilyResolvedClassUnion(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_optionalPartialClassToResolvedClassUnionPropertyEither.isLeft()) {
      return _optionalPartialClassToResolvedClassUnionPropertyEither;
    }

    const optionalPartialClassToResolvedClassUnionProperty =
      _optionalPartialClassToResolvedClassUnionPropertyEither.unsafeCoerce();
    const _optionalPartialClassUnionToResolvedClassUnionPropertyEither: purify.Either<
      Error,
      $LazyObjectOption<
        LazilyResolvedClassUnion.$Identifier,
        PartialClassUnion,
        LazilyResolvedClassUnion
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.optionalPartialClassUnionToResolvedClassUnionProperty[
          "identifier"
        ],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            PartialClassUnion.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: false,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<PartialClassUnion>
            >({
              focusResource: $parameters.resource,
              predicate:
                LazyPropertiesClass.$properties
                  .optionalPartialClassUnionToResolvedClassUnionProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyObjectOption<
              LazilyResolvedClassUnion.$Identifier,
              PartialClassUnion,
              LazilyResolvedClassUnion
            >({
              partial,
              resolver: (identifier) =>
                $parameters.objectSet.lazilyResolvedClassUnion(identifier),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_optionalPartialClassUnionToResolvedClassUnionPropertyEither.isLeft()) {
      return _optionalPartialClassUnionToResolvedClassUnionPropertyEither;
    }

    const optionalPartialClassUnionToResolvedClassUnionProperty =
      _optionalPartialClassUnionToResolvedClassUnionPropertyEither.unsafeCoerce();
    const _requiredLazyToResolvedClassPropertyEither: purify.Either<
      Error,
      $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.requiredLazyToResolvedClassProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            $DefaultPartial.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyObject<
              LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
              $DefaultPartial,
              LazilyResolvedBlankNodeOrIriIdentifierClass
            >({
              partial,
              resolver: (identifier) =>
                $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierClass(
                  identifier,
                ),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_requiredLazyToResolvedClassPropertyEither.isLeft()) {
      return _requiredLazyToResolvedClassPropertyEither;
    }

    const requiredLazyToResolvedClassProperty =
      _requiredLazyToResolvedClassPropertyEither.unsafeCoerce();
    const _requiredPartialClassToResolvedClassPropertyEither: purify.Either<
      Error,
      $LazyObject<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.requiredPartialClassToResolvedClassProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            PartialClass.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.map(
          (partial) =>
            new $LazyObject<
              LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
              PartialClass,
              LazilyResolvedBlankNodeOrIriIdentifierClass
            >({
              partial,
              resolver: (identifier) =>
                $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierClass(
                  identifier,
                ),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_requiredPartialClassToResolvedClassPropertyEither.isLeft()) {
      return _requiredPartialClassToResolvedClassPropertyEither;
    }

    const requiredPartialClassToResolvedClassProperty =
      _requiredPartialClassToResolvedClassPropertyEither.unsafeCoerce();
    const _setLazyToResolvedClassPropertyEither: purify.Either<
      Error,
      $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        $DefaultPartial,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.setLazyToResolvedClassProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            $DefaultPartial.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) => values.toArray())
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          focusResource: $parameters.resource,
          predicate:
            LazyPropertiesClass.$properties.setLazyToResolvedClassProperty[
              "identifier"
            ],
          value: valuesArray,
        }),
      )
      .map((values) =>
        values.map(
          (partials) =>
            new $LazyObjectSet<
              LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
              $DefaultPartial,
              LazilyResolvedBlankNodeOrIriIdentifierClass
            >({
              partials,
              resolver: (identifiers) =>
                $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierClasses(
                  { where: { identifiers, type: "identifiers" } },
                ),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_setLazyToResolvedClassPropertyEither.isLeft()) {
      return _setLazyToResolvedClassPropertyEither;
    }

    const setLazyToResolvedClassProperty =
      _setLazyToResolvedClassPropertyEither.unsafeCoerce();
    const _setPartialClassToResolvedClassPropertyEither: purify.Either<
      Error,
      $LazyObjectSet<
        LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
        PartialClass,
        LazilyResolvedBlankNodeOrIriIdentifierClass
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.setPartialClassToResolvedClassProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            PartialClass.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) => values.toArray())
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          focusResource: $parameters.resource,
          predicate:
            LazyPropertiesClass.$properties
              .setPartialClassToResolvedClassProperty["identifier"],
          value: valuesArray,
        }),
      )
      .map((values) =>
        values.map(
          (partials) =>
            new $LazyObjectSet<
              LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
              PartialClass,
              LazilyResolvedBlankNodeOrIriIdentifierClass
            >({
              partials,
              resolver: (identifiers) =>
                $parameters.objectSet.lazilyResolvedBlankNodeOrIriIdentifierClasses(
                  { where: { identifiers, type: "identifiers" } },
                ),
            }),
        ),
      )
      .chain((values) => values.head());
    if (_setPartialClassToResolvedClassPropertyEither.isLeft()) {
      return _setPartialClassToResolvedClassPropertyEither;
    }

    const setPartialClassToResolvedClassProperty =
      _setPartialClassToResolvedClassPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      optionalLazyToResolvedClassProperty,
      optionalLazyToResolvedClassUnionProperty,
      optionalLazyToResolvedIriIdentifierClassProperty,
      optionalPartialClassToResolvedClassProperty,
      optionalPartialClassToResolvedClassUnionProperty,
      optionalPartialClassUnionToResolvedClassUnionProperty,
      requiredLazyToResolvedClassProperty,
      requiredPartialClassToResolvedClassProperty,
      setLazyToResolvedClassProperty,
      setPartialClassToResolvedClassProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazyPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazyPropertiesClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazyPropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazyPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazyPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("lazyPropertiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties.optionalLazyToResolvedClassProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassUnionProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties
          .optionalLazyToResolvedClassUnionProperty["identifier"],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassUnionProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassUnionProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedIriIdentifierClassProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties
          .optionalLazyToResolvedIriIdentifierClassProperty["identifier"],
      subject,
    });
    triples.push(
      ...$NamedDefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedIriIdentifierClassProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedIriIdentifierClassProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties
          .optionalPartialClassToResolvedClassProperty["identifier"],
      subject,
    });
    triples.push(
      ...PartialClass.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassUnionProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties
          .optionalPartialClassToResolvedClassUnionProperty["identifier"],
      subject,
    });
    triples.push(
      ...PartialClass.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassUnionProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassUnionProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassUnionToResolvedClassUnionProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties
          .optionalPartialClassUnionToResolvedClassUnionProperty["identifier"],
      subject,
    });
    triples.push(
      ...PartialClassUnion.$sparqlConstructTriples({
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassUnionToResolvedClassUnionProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassUnionToResolvedClassUnionProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredLazyToResolvedClassProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties.requiredLazyToResolvedClassProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredLazyToResolvedClassProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredLazyToResolvedClassProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredPartialClassToResolvedClassProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties
          .requiredPartialClassToResolvedClassProperty["identifier"],
      subject,
    });
    triples.push(
      ...PartialClass.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredPartialClassToResolvedClassProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredPartialClassToResolvedClassProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetLazyToResolvedClassProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties.setLazyToResolvedClassProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...$DefaultPartial.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetLazyToResolvedClassProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetLazyToResolvedClassProperty`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetPartialClassToResolvedClassProperty`,
      ),
      predicate:
        LazyPropertiesClass.$properties.setPartialClassToResolvedClassProperty[
          "identifier"
        ],
      subject,
    });
    triples.push(
      ...PartialClass.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetPartialClassToResolvedClassProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetPartialClassToResolvedClassProperty`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazyPropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("lazyPropertiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalLazyToResolvedClassProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassProperty`,
                  ),
                  predicate:
                    LazyPropertiesClass.$properties
                      .optionalLazyToResolvedClassProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $DefaultPartial
                .$sparqlWherePatterns({
                  filter: itemFilter,
                  ignoreRdfType: true,
                  preferredLanguages: parameters?.preferredLanguages,
                  subject: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassProperty`,
                  ),
                  variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassProperty`,
                })
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalLazyToResolvedClassUnionProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassUnionProperty`,
                  ),
                  predicate:
                    LazyPropertiesClass.$properties
                      .optionalLazyToResolvedClassUnionProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $DefaultPartial
                .$sparqlWherePatterns({
                  filter: itemFilter,
                  ignoreRdfType: true,
                  preferredLanguages: parameters?.preferredLanguages,
                  subject: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassUnionProperty`,
                  ),
                  variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedClassUnionProperty`,
                })
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalLazyToResolvedIriIdentifierClassProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedIriIdentifierClassProperty`,
                  ),
                  predicate:
                    LazyPropertiesClass.$properties
                      .optionalLazyToResolvedIriIdentifierClassProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $NamedDefaultPartial
                .$sparqlWherePatterns({
                  filter: itemFilter,
                  ignoreRdfType: true,
                  preferredLanguages: parameters?.preferredLanguages,
                  subject: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedIriIdentifierClassProperty`,
                  ),
                  variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalLazyToResolvedIriIdentifierClassProperty`,
                })
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalPartialClassToResolvedClassProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassProperty`,
                  ),
                  predicate:
                    LazyPropertiesClass.$properties
                      .optionalPartialClassToResolvedClassProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: PartialClass.$sparqlWherePatterns({
                filter: itemFilter,
                ignoreRdfType: true,
                preferredLanguages: parameters?.preferredLanguages,
                subject: dataFactory.variable!(
                  `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassProperty`,
                ),
                variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassProperty`,
              }).concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.optionalPartialClassToResolvedClassUnionProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassUnionProperty`,
                  ),
                  predicate:
                    LazyPropertiesClass.$properties
                      .optionalPartialClassToResolvedClassUnionProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: PartialClass.$sparqlWherePatterns({
                filter: itemFilter,
                ignoreRdfType: true,
                preferredLanguages: parameters?.preferredLanguages,
                subject: dataFactory.variable!(
                  `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassUnionProperty`,
                ),
                variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassToResolvedClassUnionProperty`,
              }).concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter
            ?.optionalPartialClassUnionToResolvedClassUnionProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassUnionToResolvedClassUnionProperty`,
                  ),
                  predicate:
                    LazyPropertiesClass.$properties
                      .optionalPartialClassUnionToResolvedClassUnionProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: PartialClassUnion.$sparqlWherePatterns({
                filter: itemFilter,
                preferredLanguages: parameters?.preferredLanguages,
                subject: dataFactory.variable!(
                  `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassUnionToResolvedClassUnionProperty`,
                ),
                variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}OptionalPartialClassUnionToResolvedClassUnionProperty`,
              }).concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredLazyToResolvedClassProperty`,
            ),
            predicate:
              LazyPropertiesClass.$properties
                .requiredLazyToResolvedClassProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: $DefaultPartial
          .$sparqlWherePatterns({
            filter: parameters?.filter?.requiredLazyToResolvedClassProperty,
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredLazyToResolvedClassProperty`,
            ),
            variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredLazyToResolvedClassProperty`,
          })
          .concat(),
        type: "group",
      },
    );
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredPartialClassToResolvedClassProperty`,
            ),
            predicate:
              LazyPropertiesClass.$properties
                .requiredPartialClassToResolvedClassProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: PartialClass.$sparqlWherePatterns({
          filter:
            parameters?.filter?.requiredPartialClassToResolvedClassProperty,
          ignoreRdfType: true,
          preferredLanguages: parameters?.preferredLanguages,
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredPartialClassToResolvedClassProperty`,
          ),
          variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}RequiredPartialClassToResolvedClassProperty`,
        }).concat(),
        type: "group",
      },
    );
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetLazyToResolvedClassProperty`,
              ),
              predicate:
                LazyPropertiesClass.$properties.setLazyToResolvedClassProperty[
                  "identifier"
                ],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: $DefaultPartial
            .$sparqlWherePatterns({
              filter: parameters?.filter?.setLazyToResolvedClassProperty,
              ignoreRdfType: true,
              preferredLanguages: parameters?.preferredLanguages,
              subject: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetLazyToResolvedClassProperty`,
              ),
              variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetLazyToResolvedClassProperty`,
            })
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetPartialClassToResolvedClassProperty`,
              ),
              predicate:
                LazyPropertiesClass.$properties
                  .setPartialClassToResolvedClassProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: PartialClass.$sparqlWherePatterns({
            filter: parameters?.filter?.setPartialClassToResolvedClassProperty,
            ignoreRdfType: true,
            preferredLanguages: parameters?.preferredLanguages,
            subject: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetPartialClassToResolvedClassProperty`,
            ),
            variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazyPropertiesClass")}SetPartialClassToResolvedClassProperty`,
          }).concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    return patterns;
  }
}
/**
 * Node shape resolved by LazyPropertiesInterface
 */
export interface LazilyResolvedIriIdentifierInterface {
  readonly $identifier: LazilyResolvedIriIdentifierInterface.$Identifier;
  readonly $type: "LazilyResolvedIriIdentifierInterface";
  readonly lazilyResolvedStringProperty: string;
}

export namespace LazilyResolvedIriIdentifierInterface {
  export function $create(parameters: {
    readonly $identifier: rdfjs.NamedNode | string;
    readonly lazilyResolvedStringProperty: string;
  }): LazilyResolvedIriIdentifierInterface {
    let $identifier: LazilyResolvedIriIdentifierInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "LazilyResolvedIriIdentifierInterface" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: LazilyResolvedIriIdentifierInterface,
    right: LazilyResolvedIriIdentifierInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export function $filter(
    filter: LazilyResolvedIriIdentifierInterface.$Filter,
    value: LazilyResolvedIriIdentifierInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedIriIdentifierInterface> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedIriIdentifierInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedIriIdentifierInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedIriIdentifierInterface: LazilyResolvedIriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_lazilyResolvedIriIdentifierInterface.$identifier.value);
    _hasher.update(_lazilyResolvedIriIdentifierInterface.$type);
    LazilyResolvedIriIdentifierInterface.$hashShaclProperties(
      _lazilyResolvedIriIdentifierInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedIriIdentifierInterface: LazilyResolvedIriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _lazilyResolvedIriIdentifierInterface.lazilyResolvedStringProperty,
    );
    return _hasher;
  }

  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedIriIdentifierInterface";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedIriIdentifierInterface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedIriIdentifierInterface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedIriIdentifierInterface"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.NamedNode;
      $type: "LazilyResolvedIriIdentifierInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const $type = "LazilyResolvedIriIdentifierInterface" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.NamedNode;
      $type: "LazilyResolvedIriIdentifierInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    if ($parameters.resource.identifier.termType !== "NamedNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedTermValueError({
          actualValue: $parameters.resource.identifier,
          expectedValueType: "(rdfjs.NamedNode)",
          focusResource: $parameters.resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: LazilyResolvedIriIdentifierInterface.$Identifier =
      $parameters.resource.identifier;
    const $type = "LazilyResolvedIriIdentifierInterface" as const;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              LazilyResolvedIriIdentifierInterface.$properties
                .lazilyResolvedStringProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedIriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedIriIdentifierInterface.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazilyResolvedIriIdentifierInterface.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedIriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedIriIdentifierInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedIriIdentifierInterface");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedIriIdentifierInterface")}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedIriIdentifierInterface.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedIriIdentifierInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedIriIdentifierInterface");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedIriIdentifierInterface")}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedIriIdentifierInterface.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedIriIdentifierInterface")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedIriIdentifierInterface")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _lazilyResolvedIriIdentifierInterface: LazilyResolvedIriIdentifierInterface,
  ): LazilyResolvedIriIdentifierInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": _lazilyResolvedIriIdentifierInterface.$identifier.value,
        $type: _lazilyResolvedIriIdentifierInterface.$type,
        lazilyResolvedStringProperty:
          _lazilyResolvedIriIdentifierInterface.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedIriIdentifierInterface.$Json),
    );
  }

  export function $toRdf(
    _lazilyResolvedIriIdentifierInterface: LazilyResolvedIriIdentifierInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(
      _lazilyResolvedIriIdentifierInterface.$identifier,
      { mutateGraph },
    );
    resource.add(
      LazilyResolvedIriIdentifierInterface.$properties
        .lazilyResolvedStringProperty["identifier"],
      ...[_lazilyResolvedIriIdentifierInterface.lazilyResolvedStringProperty],
    );
    return resource;
  }
}
/**
 * Node shape resolved by LazyPropertiesClass
 */
export class LazilyResolvedIriIdentifierClass {
  readonly $identifier: LazilyResolvedIriIdentifierClass.$Identifier;
  readonly $type = "LazilyResolvedIriIdentifierClass";
  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier: rdfjs.NamedNode | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this.$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this.$identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      this.$identifier = parameters.$identifier satisfies never;
    }

    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  $equals(other: LazilyResolvedIriIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): LazilyResolvedIriIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedIriIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      LazilyResolvedIriIdentifierClass.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[this.lazilyResolvedStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LazilyResolvedIriIdentifierClass {
  export function $filter(
    filter: LazilyResolvedIriIdentifierClass.$Filter,
    value: LazilyResolvedIriIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedIriIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new LazilyResolvedIriIdentifierClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedIriIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedIriIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new LazilyResolvedIriIdentifierClass(properties));
  }

  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedIriIdentifierClass";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedIriIdentifierClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedIriIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedIriIdentifierClass"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.NamedNode; lazilyResolvedStringProperty: string }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.NamedNode; lazilyResolvedStringProperty: string }
  > {
    if ($parameters.resource.identifier.termType !== "NamedNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedTermValueError({
          actualValue: $parameters.resource.identifier,
          expectedValueType: "(rdfjs.NamedNode)",
          focusResource: $parameters.resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: LazilyResolvedIriIdentifierClass.$Identifier =
      $parameters.resource.identifier;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              LazilyResolvedIriIdentifierClass.$properties
                .lazilyResolvedStringProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedIriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedIriIdentifierClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazilyResolvedIriIdentifierClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedIriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedIriIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedIriIdentifierClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedIriIdentifierClass")}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedIriIdentifierClass.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedIriIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedIriIdentifierClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedIriIdentifierClass")}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedIriIdentifierClass.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedIriIdentifierClass")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedIriIdentifierClass")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
export interface LazilyResolvedInterfaceUnionMember2 {
  readonly $identifier: LazilyResolvedInterfaceUnionMember2.$Identifier;
  readonly $type: "LazilyResolvedInterfaceUnionMember2";
  readonly lazilyResolvedStringProperty: string;
}

export namespace LazilyResolvedInterfaceUnionMember2 {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): LazilyResolvedInterfaceUnionMember2 {
    let $identifier: LazilyResolvedInterfaceUnionMember2.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "LazilyResolvedInterfaceUnionMember2" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: LazilyResolvedInterfaceUnionMember2,
    right: LazilyResolvedInterfaceUnionMember2,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export function $filter(
    filter: LazilyResolvedInterfaceUnionMember2.$Filter,
    value: LazilyResolvedInterfaceUnionMember2,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedInterfaceUnionMember2> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedInterfaceUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedInterfaceUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedInterfaceUnionMember2",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedInterfaceUnionMember2: LazilyResolvedInterfaceUnionMember2,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_lazilyResolvedInterfaceUnionMember2.$identifier.value);
    _hasher.update(_lazilyResolvedInterfaceUnionMember2.$type);
    LazilyResolvedInterfaceUnionMember2.$hashShaclProperties(
      _lazilyResolvedInterfaceUnionMember2,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedInterfaceUnionMember2: LazilyResolvedInterfaceUnionMember2,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _lazilyResolvedInterfaceUnionMember2.lazilyResolvedStringProperty,
    );
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedInterfaceUnionMember2";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedInterfaceUnionMember2" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedInterfaceUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedInterfaceUnionMember2"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazilyResolvedInterfaceUnionMember2";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "LazilyResolvedInterfaceUnionMember2" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazilyResolvedInterfaceUnionMember2";
      lazilyResolvedStringProperty: string;
    }
  > {
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/LazilyResolvedInterfaceUnionMember2":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              LazilyResolvedInterfaceUnionMember2.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedInterfaceUnionMember2)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: LazilyResolvedInterfaceUnionMember2.$Identifier =
      $parameters.resource.identifier;
    const $type = "LazilyResolvedInterfaceUnionMember2" as const;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              LazilyResolvedInterfaceUnionMember2.$properties
                .lazilyResolvedStringProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedInterfaceUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedInterfaceUnionMember2.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazilyResolvedInterfaceUnionMember2.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedInterfaceUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedInterfaceUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedInterfaceUnionMember2");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember2")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember2")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember2")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember2")}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedInterfaceUnionMember2.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedInterfaceUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedInterfaceUnionMember2");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember2")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedInterfaceUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember2")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember2")}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedInterfaceUnionMember2.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember2")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember2")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _lazilyResolvedInterfaceUnionMember2: LazilyResolvedInterfaceUnionMember2,
  ): LazilyResolvedInterfaceUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _lazilyResolvedInterfaceUnionMember2.$identifier.termType ===
          "BlankNode"
            ? `_:${_lazilyResolvedInterfaceUnionMember2.$identifier.value}`
            : _lazilyResolvedInterfaceUnionMember2.$identifier.value,
        $type: _lazilyResolvedInterfaceUnionMember2.$type,
        lazilyResolvedStringProperty:
          _lazilyResolvedInterfaceUnionMember2.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedInterfaceUnionMember2.$Json),
    );
  }

  export function $toRdf(
    _lazilyResolvedInterfaceUnionMember2: LazilyResolvedInterfaceUnionMember2,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _lazilyResolvedInterfaceUnionMember2.$identifier,
      { mutateGraph },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/LazilyResolvedInterfaceUnionMember2",
        ),
      );
    }

    resource.add(
      LazilyResolvedInterfaceUnionMember2.$properties
        .lazilyResolvedStringProperty["identifier"],
      ...[_lazilyResolvedInterfaceUnionMember2.lazilyResolvedStringProperty],
    );
    return resource;
  }
}
export interface LazilyResolvedInterfaceUnionMember1 {
  readonly $identifier: LazilyResolvedInterfaceUnionMember1.$Identifier;
  readonly $type: "LazilyResolvedInterfaceUnionMember1";
  readonly lazilyResolvedStringProperty: string;
}

export namespace LazilyResolvedInterfaceUnionMember1 {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): LazilyResolvedInterfaceUnionMember1 {
    let $identifier: LazilyResolvedInterfaceUnionMember1.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "LazilyResolvedInterfaceUnionMember1" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: LazilyResolvedInterfaceUnionMember1,
    right: LazilyResolvedInterfaceUnionMember1,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export function $filter(
    filter: LazilyResolvedInterfaceUnionMember1.$Filter,
    value: LazilyResolvedInterfaceUnionMember1,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedInterfaceUnionMember1> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedInterfaceUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedInterfaceUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedInterfaceUnionMember1",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedInterfaceUnionMember1: LazilyResolvedInterfaceUnionMember1,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_lazilyResolvedInterfaceUnionMember1.$identifier.value);
    _hasher.update(_lazilyResolvedInterfaceUnionMember1.$type);
    LazilyResolvedInterfaceUnionMember1.$hashShaclProperties(
      _lazilyResolvedInterfaceUnionMember1,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedInterfaceUnionMember1: LazilyResolvedInterfaceUnionMember1,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _lazilyResolvedInterfaceUnionMember1.lazilyResolvedStringProperty,
    );
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedInterfaceUnionMember1";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedInterfaceUnionMember1" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedInterfaceUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedInterfaceUnionMember1"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazilyResolvedInterfaceUnionMember1";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "LazilyResolvedInterfaceUnionMember1" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazilyResolvedInterfaceUnionMember1";
      lazilyResolvedStringProperty: string;
    }
  > {
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/LazilyResolvedInterfaceUnionMember1":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              LazilyResolvedInterfaceUnionMember1.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedInterfaceUnionMember1)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: LazilyResolvedInterfaceUnionMember1.$Identifier =
      $parameters.resource.identifier;
    const $type = "LazilyResolvedInterfaceUnionMember1" as const;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              LazilyResolvedInterfaceUnionMember1.$properties
                .lazilyResolvedStringProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedInterfaceUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedInterfaceUnionMember1.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazilyResolvedInterfaceUnionMember1.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedInterfaceUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedInterfaceUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedInterfaceUnionMember1");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember1")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember1")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember1")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember1")}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedInterfaceUnionMember1.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedInterfaceUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedInterfaceUnionMember1");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember1")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedInterfaceUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember1")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember1")}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedInterfaceUnionMember1.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember1")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedInterfaceUnionMember1")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _lazilyResolvedInterfaceUnionMember1: LazilyResolvedInterfaceUnionMember1,
  ): LazilyResolvedInterfaceUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _lazilyResolvedInterfaceUnionMember1.$identifier.termType ===
          "BlankNode"
            ? `_:${_lazilyResolvedInterfaceUnionMember1.$identifier.value}`
            : _lazilyResolvedInterfaceUnionMember1.$identifier.value,
        $type: _lazilyResolvedInterfaceUnionMember1.$type,
        lazilyResolvedStringProperty:
          _lazilyResolvedInterfaceUnionMember1.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedInterfaceUnionMember1.$Json),
    );
  }

  export function $toRdf(
    _lazilyResolvedInterfaceUnionMember1: LazilyResolvedInterfaceUnionMember1,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _lazilyResolvedInterfaceUnionMember1.$identifier,
      { mutateGraph },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/LazilyResolvedInterfaceUnionMember1",
        ),
      );
    }

    resource.add(
      LazilyResolvedInterfaceUnionMember1.$properties
        .lazilyResolvedStringProperty["identifier"],
      ...[_lazilyResolvedInterfaceUnionMember1.lazilyResolvedStringProperty],
    );
    return resource;
  }
}
export class LazilyResolvedClassUnionMember2 {
  private _$identifier?: LazilyResolvedClassUnionMember2.$Identifier;
  readonly $type = "LazilyResolvedClassUnionMember2";
  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): LazilyResolvedClassUnionMember2.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: LazilyResolvedClassUnionMember2): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): LazilyResolvedClassUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedClassUnionMember2.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/LazilyResolvedClassUnionMember2",
        ),
      );
    }

    resource.add(
      LazilyResolvedClassUnionMember2.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[this.lazilyResolvedStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LazilyResolvedClassUnionMember2 {
  export function $filter(
    filter: LazilyResolvedClassUnionMember2.$Filter,
    value: LazilyResolvedClassUnionMember2,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedClassUnionMember2> {
    return $propertiesFromJson(json).map(
      (properties) => new LazilyResolvedClassUnionMember2(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedClassUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedClassUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new LazilyResolvedClassUnionMember2(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedClassUnionMember2",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedClassUnionMember2";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedClassUnionMember2" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedClassUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedClassUnionMember2"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/LazilyResolvedClassUnionMember2":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              LazilyResolvedClassUnionMember2.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedClassUnionMember2)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: LazilyResolvedClassUnionMember2.$Identifier =
      $parameters.resource.identifier;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              LazilyResolvedClassUnionMember2.$properties
                .lazilyResolvedStringProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedClassUnionMember2.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazilyResolvedClassUnionMember2.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedClassUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedClassUnionMember2");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember2")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember2")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember2")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember2")}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedClassUnionMember2.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedClassUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedClassUnionMember2");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember2")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedClassUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember2")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember2")}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedClassUnionMember2.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember2")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember2")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
export class LazilyResolvedClassUnionMember1 {
  private _$identifier?: LazilyResolvedClassUnionMember1.$Identifier;
  readonly $type = "LazilyResolvedClassUnionMember1";
  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): LazilyResolvedClassUnionMember1.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: LazilyResolvedClassUnionMember1): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): LazilyResolvedClassUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedClassUnionMember1.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/LazilyResolvedClassUnionMember1",
        ),
      );
    }

    resource.add(
      LazilyResolvedClassUnionMember1.$properties.lazilyResolvedStringProperty[
        "identifier"
      ],
      ...[this.lazilyResolvedStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LazilyResolvedClassUnionMember1 {
  export function $filter(
    filter: LazilyResolvedClassUnionMember1.$Filter,
    value: LazilyResolvedClassUnionMember1,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedClassUnionMember1> {
    return $propertiesFromJson(json).map(
      (properties) => new LazilyResolvedClassUnionMember1(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedClassUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedClassUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new LazilyResolvedClassUnionMember1(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedClassUnionMember1",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedClassUnionMember1";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedClassUnionMember1" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedClassUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedClassUnionMember1"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/LazilyResolvedClassUnionMember1":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              LazilyResolvedClassUnionMember1.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedClassUnionMember1)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: LazilyResolvedClassUnionMember1.$Identifier =
      $parameters.resource.identifier;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              LazilyResolvedClassUnionMember1.$properties
                .lazilyResolvedStringProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedClassUnionMember1.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazilyResolvedClassUnionMember1.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedClassUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedClassUnionMember1");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember1")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember1")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember1")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember1")}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedClassUnionMember1.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedClassUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedClassUnionMember1");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember1")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedClassUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember1")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember1")}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedClassUnionMember1.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember1")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedClassUnionMember1")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
/**
 * Node shape resolved by LazyPropertiesInterface
 */
export interface LazilyResolvedBlankNodeOrIriIdentifierInterface {
  readonly $identifier: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier;
  readonly $type: "LazilyResolvedBlankNodeOrIriIdentifierInterface";
  readonly lazilyResolvedStringProperty: string;
}

export namespace LazilyResolvedBlankNodeOrIriIdentifierInterface {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }): LazilyResolvedBlankNodeOrIriIdentifierInterface {
    let $identifier: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "LazilyResolvedBlankNodeOrIriIdentifierInterface" as const;
    const lazilyResolvedStringProperty =
      parameters.lazilyResolvedStringProperty;
    return { $identifier, $type, lazilyResolvedStringProperty };
  }

  export function $equals(
    left: LazilyResolvedBlankNodeOrIriIdentifierInterface,
    right: LazilyResolvedBlankNodeOrIriIdentifierInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.lazilyResolvedStringProperty,
          right.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export function $filter(
    filter: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter,
    value: LazilyResolvedBlankNodeOrIriIdentifierInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<
    zod.ZodError,
    LazilyResolvedBlankNodeOrIriIdentifierInterface
  > {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedBlankNodeOrIriIdentifierInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedBlankNodeOrIriIdentifierInterface",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedBlankNodeOrIriIdentifierInterface: LazilyResolvedBlankNodeOrIriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _lazilyResolvedBlankNodeOrIriIdentifierInterface.$identifier.value,
    );
    _hasher.update(_lazilyResolvedBlankNodeOrIriIdentifierInterface.$type);
    LazilyResolvedBlankNodeOrIriIdentifierInterface.$hashShaclProperties(
      _lazilyResolvedBlankNodeOrIriIdentifierInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedBlankNodeOrIriIdentifierInterface: LazilyResolvedBlankNodeOrIriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _lazilyResolvedBlankNodeOrIriIdentifierInterface.lazilyResolvedStringProperty,
    );
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedBlankNodeOrIriIdentifierInterface";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: {
                const: "LazilyResolvedBlankNodeOrIriIdentifierInterface",
              },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedBlankNodeOrIriIdentifierInterface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedBlankNodeOrIriIdentifierInterface"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazilyResolvedBlankNodeOrIriIdentifierInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "LazilyResolvedBlankNodeOrIriIdentifierInterface" as const;
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "LazilyResolvedBlankNodeOrIriIdentifierInterface";
      lazilyResolvedStringProperty: string;
    }
  > {
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/LazilyResolvedBlankNodeOrIriIdentifierInterface":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedBlankNodeOrIriIdentifierInterface)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier =
      $parameters.resource.identifier;
    const $type = "LazilyResolvedBlankNodeOrIriIdentifierInterface" as const;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              LazilyResolvedBlankNodeOrIriIdentifierInterface.$properties
                .lazilyResolvedStringProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      $type,
      lazilyResolvedStringProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$sparqlConstructTriples(
          { ignoreRdfType, subject },
        ),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazilyResolvedBlankNodeOrIriIdentifierInterface.$sparqlWherePatterns(
              { filter, ignoreRdfType, preferredLanguages, subject },
            ),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$sparqlConstructQuery(
        parameters,
      ),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedBlankNodeOrIriIdentifierInterface");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierInterface")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierInterface")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierInterface")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierInterface")}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedBlankNodeOrIriIdentifierInterface.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedBlankNodeOrIriIdentifierInterface");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierInterface")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierInterface")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierInterface")}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedBlankNodeOrIriIdentifierInterface.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierInterface")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierInterface")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _lazilyResolvedBlankNodeOrIriIdentifierInterface: LazilyResolvedBlankNodeOrIriIdentifierInterface,
  ): LazilyResolvedBlankNodeOrIriIdentifierInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _lazilyResolvedBlankNodeOrIriIdentifierInterface.$identifier
            .termType === "BlankNode"
            ? `_:${_lazilyResolvedBlankNodeOrIriIdentifierInterface.$identifier.value}`
            : _lazilyResolvedBlankNodeOrIriIdentifierInterface.$identifier
                .value,
        $type: _lazilyResolvedBlankNodeOrIriIdentifierInterface.$type,
        lazilyResolvedStringProperty:
          _lazilyResolvedBlankNodeOrIriIdentifierInterface.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedBlankNodeOrIriIdentifierInterface.$Json),
    );
  }

  export function $toRdf(
    _lazilyResolvedBlankNodeOrIriIdentifierInterface: LazilyResolvedBlankNodeOrIriIdentifierInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _lazilyResolvedBlankNodeOrIriIdentifierInterface.$identifier,
      { mutateGraph },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/LazilyResolvedBlankNodeOrIriIdentifierInterface",
        ),
      );
    }

    resource.add(
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$properties
        .lazilyResolvedStringProperty["identifier"],
      ...[
        _lazilyResolvedBlankNodeOrIriIdentifierInterface.lazilyResolvedStringProperty,
      ],
    );
    return resource;
  }
}
/**
 * Node shape resolved by LazyPropertiesClass
 */
export class LazilyResolvedBlankNodeOrIriIdentifierClass {
  private _$identifier?: LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier;
  readonly $type = "LazilyResolvedBlankNodeOrIriIdentifierClass";
  readonly lazilyResolvedStringProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly lazilyResolvedStringProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.lazilyResolvedStringProperty = parameters.lazilyResolvedStringProperty;
  }

  get $identifier(): LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: LazilyResolvedBlankNodeOrIriIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.lazilyResolvedStringProperty,
          other.lazilyResolvedStringProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "lazilyResolvedStringProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.lazilyResolvedStringProperty);
    return _hasher;
  }

  $toJson(): LazilyResolvedBlankNodeOrIriIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        lazilyResolvedStringProperty: this.lazilyResolvedStringProperty,
      } satisfies LazilyResolvedBlankNodeOrIriIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/LazilyResolvedBlankNodeOrIriIdentifierClass",
        ),
      );
    }

    resource.add(
      LazilyResolvedBlankNodeOrIriIdentifierClass.$properties
        .lazilyResolvedStringProperty["identifier"],
      ...[this.lazilyResolvedStringProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LazilyResolvedBlankNodeOrIriIdentifierClass {
  export function $filter(
    filter: LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter,
    value: LazilyResolvedBlankNodeOrIriIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.lazilyResolvedStringProperty !== "undefined" &&
      !$filterString(
        filter.lazilyResolvedStringProperty,
        value.lazilyResolvedStringProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly lazilyResolvedStringProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedBlankNodeOrIriIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) =>
        new LazilyResolvedBlankNodeOrIriIdentifierClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LazilyResolvedBlankNodeOrIriIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map(
      (properties) =>
        new LazilyResolvedBlankNodeOrIriIdentifierClass(properties),
    );
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/LazilyResolvedBlankNodeOrIriIdentifierClass",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LazilyResolvedBlankNodeOrIriIdentifierClass";
    readonly lazilyResolvedStringProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LazilyResolvedBlankNodeOrIriIdentifierClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/lazilyResolvedStringProperty`,
          type: "Control",
        },
      ],
      label: "LazilyResolvedBlankNodeOrIriIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LazilyResolvedBlankNodeOrIriIdentifierClass"),
      lazilyResolvedStringProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const lazilyResolvedStringProperty =
      $jsonObject["lazilyResolvedStringProperty"];
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      lazilyResolvedStringProperty: string;
    }
  > {
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/LazilyResolvedBlankNodeOrIriIdentifierClass":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/LazilyResolvedBlankNodeOrIriIdentifierClass)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier =
      $parameters.resource.identifier;
    const _lazilyResolvedStringPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.lazilyResolvedStringProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              LazilyResolvedBlankNodeOrIriIdentifierClass.$properties
                .lazilyResolvedStringProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_lazilyResolvedStringPropertyEither.isLeft()) {
      return _lazilyResolvedStringPropertyEither;
    }

    const lazilyResolvedStringProperty =
      _lazilyResolvedStringPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, lazilyResolvedStringProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedBlankNodeOrIriIdentifierClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazilyResolvedBlankNodeOrIriIdentifierClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedBlankNodeOrIriIdentifierClass.$sparqlConstructQuery(
        parameters,
      ),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedBlankNodeOrIriIdentifierClass");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierClass")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierClass")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierClass")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierClass")}LazilyResolvedStringProperty`,
      ),
      predicate:
        LazilyResolvedBlankNodeOrIriIdentifierClass.$properties
          .lazilyResolvedStringProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedBlankNodeOrIriIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("lazilyResolvedBlankNodeOrIriIdentifierClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierClass")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierClass")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierClass")}LazilyResolvedStringProperty`,
            ),
            predicate:
              LazilyResolvedBlankNodeOrIriIdentifierClass.$properties
                .lazilyResolvedStringProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierClass")}LazilyResolvedStringProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.lazilyResolvedStringProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "lazilyResolvedBlankNodeOrIriIdentifierClass")}LazilyResolvedStringProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
/**
 * Shape that uses the StringList in a property.
 */
export class LanguageInPropertiesClass {
  private _$identifier?: LanguageInPropertiesClass.$Identifier;
  readonly $type = "LanguageInPropertiesClass";
  /**
   * literal property for testing languageIn
   */
  readonly languageInLiteralProperty: purify.NonEmptyList<rdfjs.Literal>;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly languageInLiteralProperty: purify.NonEmptyList<rdfjs.Literal>;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.languageInLiteralProperty = parameters.languageInLiteralProperty;
  }

  get $identifier(): LanguageInPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: LanguageInPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.languageInLiteralProperty,
          other.languageInLiteralProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "languageInLiteralProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    for (const item0 of this.languageInLiteralProperty) {
      _hasher.update(item0.datatype.value);
      _hasher.update(item0.language);
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }

    return _hasher;
  }

  $toJson(): LanguageInPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        languageInLiteralProperty: this.languageInLiteralProperty.map(
          (item) => ({
            "@language": item.language.length > 0 ? item.language : undefined,
            "@type":
              item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? item.datatype.value
                : undefined,
            "@value": item.value,
          }),
        ),
      } satisfies LanguageInPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      LanguageInPropertiesClass.$properties.languageInLiteralProperty[
        "identifier"
      ],
      ...this.languageInLiteralProperty.flatMap((item) => [item]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace LanguageInPropertiesClass {
  export function $filter(
    filter: LanguageInPropertiesClass.$Filter,
    value: LanguageInPropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.languageInLiteralProperty !== "undefined" &&
      !$filterArray<rdfjs.Literal, $LiteralFilter>($filterLiteral)(
        filter.languageInLiteralProperty,
        value.languageInLiteralProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly languageInLiteralProperty?: $CollectionFilter<$LiteralFilter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LanguageInPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new LanguageInPropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LanguageInPropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return LanguageInPropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new LanguageInPropertiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "LanguageInPropertiesClass";
    readonly languageInLiteralProperty: readonly {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    }[];
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LanguageInPropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/languageInLiteralProperty`,
          type: "Control",
        },
      ],
      label: "LanguageInPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("LanguageInPropertiesClass"),
      languageInLiteralProperty: zod
        .object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
        })
        .array()
        .nonempty()
        .min(1)
        .describe("literal property for testing languageIn"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    languageInLiteralProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/languageInLiteralProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      languageInLiteralProperty: purify.NonEmptyList<rdfjs.Literal>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const languageInLiteralProperty = purify.NonEmptyList.fromArray(
      $jsonObject["languageInLiteralProperty"],
    )
      .unsafeCoerce()
      .map((item) =>
        dataFactory.literal(
          item["@value"],
          typeof item["@language"] !== "undefined"
            ? item["@language"]
            : typeof item["@type"] !== "undefined"
              ? dataFactory.namedNode(item["@type"])
              : undefined,
        ),
      );
    return purify.Either.of({ $identifier, languageInLiteralProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      languageInLiteralProperty: purify.NonEmptyList<rdfjs.Literal>;
    }
  > {
    const $identifier: LanguageInPropertiesClass.$Identifier =
      $parameters.resource.identifier;
    const _languageInLiteralPropertyEither: purify.Either<
      Error,
      purify.NonEmptyList<rdfjs.Literal>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.languageInLiteralProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toLiteral().chain((literalValue) => {
            switch (literalValue.language) {
              case "en":
              case "fr":
                return purify.Either.of(value);
              default:
                return purify.Left(
                  new rdfjsResource.Resource.MistypedTermValueError({
                    actualValue: literalValue,
                    expectedValueType: "(rdfjs.Literal)",
                    focusResource: $parameters.resource,
                    predicate:
                      LanguageInPropertiesClass.$properties
                        .languageInLiteralProperty["identifier"],
                  }),
                );
            }
          }),
        ),
      )
      .chain((values) =>
        $fromRdfPreferredLanguages({
          focusResource: $parameters.resource,
          predicate:
            LanguageInPropertiesClass.$properties.languageInLiteralProperty[
              "identifier"
            ],
          preferredLanguages: $parameters.preferredLanguages,
          values,
        }),
      )
      .chain((values) => values.chainMap((value) => value.toLiteral()))
      .chain((values) =>
        purify.NonEmptyList.fromArray(values.toArray()).toEither(
          new Error(
            `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} is an empty set`,
          ),
        ),
      )
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          focusResource: $parameters.resource,
          predicate:
            LanguageInPropertiesClass.$properties.languageInLiteralProperty[
              "identifier"
            ],
          value: valuesArray,
        }),
      )
      .chain((values) => values.head());
    if (_languageInLiteralPropertyEither.isLeft()) {
      return _languageInLiteralPropertyEither;
    }

    const languageInLiteralProperty =
      _languageInLiteralPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, languageInLiteralProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LanguageInPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LanguageInPropertiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LanguageInPropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LanguageInPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LanguageInPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("languageInPropertiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "languageInPropertiesClass")}LanguageInLiteralProperty`,
      ),
      predicate:
        LanguageInPropertiesClass.$properties.languageInLiteralProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LanguageInPropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("languageInPropertiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "languageInPropertiesClass")}LanguageInLiteralProperty`,
            ),
            predicate:
              LanguageInPropertiesClass.$properties.languageInLiteralProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [
          [
            ...$arrayIntersection(
              ["en", "fr"],
              parameters?.preferredLanguages ?? [],
            ),
          ],
        ]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "languageInPropertiesClass")}LanguageInLiteralProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $LiteralFilter
          .$sparqlWherePatterns(
            parameters?.filter?.languageInLiteralProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "languageInPropertiesClass")}LanguageInLiteralProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
/**
 * Shape with sh:xone (union) properties with JavaScript primitive types (e.g., boolean, number, et al.). Unions of these are common in actual models.
 */
export class JsPrimitiveUnionPropertyClass {
  private _$identifier?: JsPrimitiveUnionPropertyClass.$Identifier;
  readonly $type = "JsPrimitiveUnionPropertyClass";
  readonly jsPrimitiveUnionProperty: readonly (boolean | number | string)[];

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly jsPrimitiveUnionProperty?: readonly (boolean | number | string)[];
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (typeof parameters?.jsPrimitiveUnionProperty === "undefined") {
      this.jsPrimitiveUnionProperty = [];
    } else if (typeof parameters?.jsPrimitiveUnionProperty === "object") {
      this.jsPrimitiveUnionProperty = parameters?.jsPrimitiveUnionProperty;
    } else {
      this.jsPrimitiveUnionProperty =
        parameters?.jsPrimitiveUnionProperty satisfies never;
    }
  }

  get $identifier(): JsPrimitiveUnionPropertyClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: JsPrimitiveUnionPropertyClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(
            left,
            right,
            (
              left: boolean | number | string,
              right: boolean | number | string,
            ) => {
              if (typeof left === "boolean" && typeof right === "boolean") {
                return $strictEquals(left, right);
              }
              if (typeof left === "number" && typeof right === "number") {
                return $strictEquals(left, right);
              }
              if (typeof left === "string" && typeof right === "string") {
                return $strictEquals(left, right);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(
          this.jsPrimitiveUnionProperty,
          other.jsPrimitiveUnionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "jsPrimitiveUnionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    for (const item0 of this.jsPrimitiveUnionProperty) {
      switch (typeof item0) {
        case "boolean": {
          _hasher.update(item0.toString());
          break;
        }
        case "number": {
          _hasher.update(item0.toString());
          break;
        }
        case "string": {
          _hasher.update(item0);
          break;
        }
        default:
          item0 satisfies never;
          throw new Error("unrecognized type");
      }
    }

    return _hasher;
  }

  $toJson(): JsPrimitiveUnionPropertyClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        jsPrimitiveUnionProperty: this.jsPrimitiveUnionProperty.map(
          (item) => item,
        ),
      } satisfies JsPrimitiveUnionPropertyClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      JsPrimitiveUnionPropertyClass.$properties.jsPrimitiveUnionProperty[
        "identifier"
      ],
      ...this.jsPrimitiveUnionProperty.flatMap((item) =>
        typeof item === "string"
          ? ([item] as readonly Parameters<
              rdfjsResource.MutableResource["add"]
            >[1][])
          : typeof item === "number"
            ? ([
                dataFactory.literal(
                  item.toString(10),
                  $RdfVocabularies.xsd.decimal,
                ),
              ] as readonly Parameters<
                rdfjsResource.MutableResource["add"]
              >[1][])
            : ([item] as readonly Parameters<
                rdfjsResource.MutableResource["add"]
              >[1][]),
      ),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace JsPrimitiveUnionPropertyClass {
  export function $filter(
    filter: JsPrimitiveUnionPropertyClass.$Filter,
    value: JsPrimitiveUnionPropertyClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.jsPrimitiveUnionProperty !== "undefined" &&
      !$filterArray<
        boolean | number | string,
        {
          readonly on?: {
            readonly boolean?: $BooleanFilter;
            readonly number?: $NumberFilter;
            readonly string?: $StringFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly boolean?: $BooleanFilter;
              readonly number?: $NumberFilter;
              readonly string?: $StringFilter;
            };
          },
          value: boolean | number | string,
        ) => {
          if (typeof filter.on?.["boolean"] !== "undefined") {
            switch (typeof value) {
              case "boolean":
                if (!$filterBoolean(filter.on["boolean"], value)) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["number"] !== "undefined") {
            switch (typeof value) {
              case "number":
                if (!$filterNumber(filter.on["number"], value)) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["string"] !== "undefined") {
            switch (typeof value) {
              case "string":
                if (!$filterString(filter.on["string"], value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.jsPrimitiveUnionProperty, value.jsPrimitiveUnionProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly jsPrimitiveUnionProperty?: $CollectionFilter<{
      readonly on?: {
        readonly boolean?: $BooleanFilter;
        readonly number?: $NumberFilter;
        readonly string?: $StringFilter;
      };
    }>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, JsPrimitiveUnionPropertyClass> {
    return $propertiesFromJson(json).map(
      (properties) => new JsPrimitiveUnionPropertyClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, JsPrimitiveUnionPropertyClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return JsPrimitiveUnionPropertyClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new JsPrimitiveUnionPropertyClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "JsPrimitiveUnionPropertyClass";
    readonly jsPrimitiveUnionProperty?: readonly (boolean | number | string)[];
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "JsPrimitiveUnionPropertyClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/jsPrimitiveUnionProperty`,
          type: "Control",
        },
      ],
      label: "JsPrimitiveUnionPropertyClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("JsPrimitiveUnionPropertyClass"),
      jsPrimitiveUnionProperty: zod
        .union([zod.boolean(), zod.number(), zod.string()])
        .array()
        .default(() => []),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    jsPrimitiveUnionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/jsPrimitiveUnionProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      jsPrimitiveUnionProperty: readonly (boolean | number | string)[];
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const jsPrimitiveUnionProperty = $jsonObject["jsPrimitiveUnionProperty"];
    return purify.Either.of({ $identifier, jsPrimitiveUnionProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      jsPrimitiveUnionProperty: readonly (boolean | number | string)[];
    }
  > {
    const $identifier: JsPrimitiveUnionPropertyClass.$Identifier =
      $parameters.resource.identifier;
    const _jsPrimitiveUnionPropertyEither: purify.Either<
      Error,
      readonly (boolean | number | string)[]
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.jsPrimitiveUnionProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) => {
          const valueAsValues = purify.Either.of(value.toValues());
          return (
            valueAsValues.chain((values) =>
              values.chainMap((value) => value.toBoolean()),
            ) as purify.Either<
              Error,
              rdfjsResource.Resource.Values<boolean | number | string>
            >
          )
            .altLazy(
              () =>
                valueAsValues.chain((values) =>
                  values.chainMap((value) => value.toNumber()),
                ) as purify.Either<
                  Error,
                  rdfjsResource.Resource.Values<boolean | number | string>
                >,
            )
            .altLazy(
              () =>
                valueAsValues
                  .chain((values) =>
                    $fromRdfPreferredLanguages({
                      focusResource: $parameters.resource,
                      predicate:
                        JsPrimitiveUnionPropertyClass.$properties
                          .jsPrimitiveUnionProperty["identifier"],
                      preferredLanguages: $parameters.preferredLanguages,
                      values,
                    }),
                  )
                  .chain((values) =>
                    values.chainMap((value) => value.toString()),
                  ) as purify.Either<
                  Error,
                  rdfjsResource.Resource.Values<boolean | number | string>
                >,
            )
            .chain((values) => values.head());
        }),
      )
      .map((values) => values.toArray())
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          focusResource: $parameters.resource,
          predicate:
            JsPrimitiveUnionPropertyClass.$properties.jsPrimitiveUnionProperty[
              "identifier"
            ],
          value: valuesArray,
        }),
      )
      .chain((values) => values.head());
    if (_jsPrimitiveUnionPropertyEither.isLeft()) {
      return _jsPrimitiveUnionPropertyEither;
    }

    const jsPrimitiveUnionProperty =
      _jsPrimitiveUnionPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, jsPrimitiveUnionProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: JsPrimitiveUnionPropertyClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        JsPrimitiveUnionPropertyClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            JsPrimitiveUnionPropertyClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: JsPrimitiveUnionPropertyClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      JsPrimitiveUnionPropertyClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("jsPrimitiveUnionPropertyClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "jsPrimitiveUnionPropertyClass")}JsPrimitiveUnionProperty`,
      ),
      predicate:
        JsPrimitiveUnionPropertyClass.$properties.jsPrimitiveUnionProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: JsPrimitiveUnionPropertyClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("jsPrimitiveUnionPropertyClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: [
        {
          patterns: [
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "jsPrimitiveUnionPropertyClass")}JsPrimitiveUnionProperty`,
                      ),
                      predicate:
                        JsPrimitiveUnionPropertyClass.$properties
                          .jsPrimitiveUnionProperty["identifier"],
                      subject: subject,
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: $BooleanFilter
                    .$sparqlWherePatterns(
                      parameters?.filter?.jsPrimitiveUnionProperty?.on?.[
                        "boolean"
                      ],
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "jsPrimitiveUnionPropertyClass")}JsPrimitiveUnionProperty`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
              ],
              type: "group",
            },
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "jsPrimitiveUnionPropertyClass")}JsPrimitiveUnionProperty`,
                      ),
                      predicate:
                        JsPrimitiveUnionPropertyClass.$properties
                          .jsPrimitiveUnionProperty["identifier"],
                      subject: subject,
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: $NumberFilter
                    .$sparqlWherePatterns(
                      parameters?.filter?.jsPrimitiveUnionProperty?.on?.[
                        "number"
                      ],
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "jsPrimitiveUnionPropertyClass")}JsPrimitiveUnionProperty`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
              ],
              type: "group",
            },
            {
              patterns: [
                {
                  triples: [
                    {
                      object: dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "jsPrimitiveUnionPropertyClass")}JsPrimitiveUnionProperty`,
                      ),
                      predicate:
                        JsPrimitiveUnionPropertyClass.$properties
                          .jsPrimitiveUnionProperty["identifier"],
                      subject: subject,
                    },
                  ],
                  type: "bgp",
                },
                {
                  patterns: [parameters?.preferredLanguages ?? []]
                    .filter((languages) => languages.length > 0)
                    .map((languages) =>
                      languages.map((language) => ({
                        type: "operation" as const,
                        operator: "=",
                        args: [
                          {
                            type: "operation" as const,
                            operator: "lang",
                            args: [
                              dataFactory.variable!(
                                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "jsPrimitiveUnionPropertyClass")}JsPrimitiveUnionProperty`,
                              ),
                            ],
                          },
                          dataFactory.literal(language),
                        ],
                      })),
                    )
                    .map((langEqualsExpressions) => ({
                      type: "filter" as const,
                      expression: langEqualsExpressions.reduce(
                        (reducedExpression, langEqualsExpression) => {
                          if (reducedExpression === null) {
                            return langEqualsExpression;
                          }
                          return {
                            type: "operation" as const,
                            operator: "||",
                            args: [reducedExpression, langEqualsExpression],
                          };
                        },
                        null as sparqljs.Expression | null,
                      ) as sparqljs.Expression,
                    }))
                    .concat(),
                  type: "group",
                },
                {
                  patterns: $StringFilter
                    .$sparqlWherePatterns(
                      parameters?.filter?.jsPrimitiveUnionProperty?.on?.[
                        "string"
                      ],
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "jsPrimitiveUnionPropertyClass")}JsPrimitiveUnionProperty`,
                      ),
                    )
                    .concat(),
                  type: "group",
                },
              ],
              type: "group",
            },
          ],
          type: "union",
        },
      ],
      type: "optional",
    });
    return patterns;
  }
}
/**
 * A node shape that only allows IRI identifiers.
 */
export interface IriIdentifierInterface {
  readonly $identifier: IriIdentifierInterface.$Identifier;
  readonly $type: "IriIdentifierInterface";
}

export namespace IriIdentifierInterface {
  export function $create(parameters: {
    readonly $identifier: rdfjs.NamedNode | string;
  }): IriIdentifierInterface {
    let $identifier: IriIdentifierInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "IriIdentifierInterface" as const;
    return { $identifier, $type };
  }

  export function $equals(
    left: IriIdentifierInterface,
    right: IriIdentifierInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  export function $filter(
    filter: IriIdentifierInterface.$Filter,
    value: IriIdentifierInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = { readonly $identifier?: $NamedNodeFilter };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, IriIdentifierInterface> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, IriIdentifierInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return IriIdentifierInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _iriIdentifierInterface: IriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_iriIdentifierInterface.$identifier.value);
    _hasher.update(_iriIdentifierInterface.$type);
    IriIdentifierInterface.$hashShaclProperties(
      _iriIdentifierInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _iriIdentifierInterface: IriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    return _hasher;
  }

  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "IriIdentifierInterface";
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "IriIdentifierInterface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "IriIdentifierInterface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("IriIdentifierInterface"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {};

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.NamedNode; $type: "IriIdentifierInterface" }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const $type = "IriIdentifierInterface" as const;
    return purify.Either.of({ $identifier, $type });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.NamedNode; $type: "IriIdentifierInterface" }
  > {
    if ($parameters.resource.identifier.termType !== "NamedNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedTermValueError({
          actualValue: $parameters.resource.identifier,
          expectedValueType: "(rdfjs.NamedNode)",
          focusResource: $parameters.resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: IriIdentifierInterface.$Identifier =
      $parameters.resource.identifier;
    const $type = "IriIdentifierInterface" as const;
    return purify.Either.of({ $identifier, $type });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IriIdentifierInterface.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            IriIdentifierInterface.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IriIdentifierInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IriIdentifierInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("iriIdentifierInterface");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }

  export function $toJson(
    _iriIdentifierInterface: IriIdentifierInterface,
  ): IriIdentifierInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": _iriIdentifierInterface.$identifier.value,
        $type: _iriIdentifierInterface.$type,
      } satisfies IriIdentifierInterface.$Json),
    );
  }

  export function $toRdf(
    _iriIdentifierInterface: IriIdentifierInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(
      _iriIdentifierInterface.$identifier,
      { mutateGraph },
    );
    return resource;
  }
}
/**
 * A node shape that only allows IRI identifiers.
 */
export class IriIdentifierClass {
  readonly $identifier: IriIdentifierClass.$Identifier;
  readonly $type = "IriIdentifierClass";

  constructor(parameters: { readonly $identifier: rdfjs.NamedNode | string }) {
    if (typeof parameters.$identifier === "object") {
      this.$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this.$identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      this.$identifier = parameters.$identifier satisfies never;
    }
  }

  $equals(other: IriIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    return _hasher;
  }

  $toJson(): IriIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
      } satisfies IriIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(this.$identifier, {
      mutateGraph,
    });
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IriIdentifierClass {
  export function $filter(
    filter: IriIdentifierClass.$Filter,
    value: IriIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = { readonly $identifier?: $NamedNodeFilter };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, IriIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new IriIdentifierClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, IriIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return IriIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new IriIdentifierClass(properties));
  }

  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "IriIdentifierClass";
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "IriIdentifierClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "IriIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("IriIdentifierClass"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {};

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<zod.ZodError, { $identifier: rdfjs.NamedNode }> {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    return purify.Either.of({ $identifier });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<Error, { $identifier: rdfjs.NamedNode }> {
    if ($parameters.resource.identifier.termType !== "NamedNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedTermValueError({
          actualValue: $parameters.resource.identifier,
          expectedValueType: "(rdfjs.NamedNode)",
          focusResource: $parameters.resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: IriIdentifierClass.$Identifier =
      $parameters.resource.identifier;
    return purify.Either.of({ $identifier });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IriIdentifierClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            IriIdentifierClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IriIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IriIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("iriIdentifierClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }
}
export interface InterfaceUnionMemberCommonParent {
  readonly $identifier: InterfaceUnionMemberCommonParentStatic.$Identifier;
  readonly $type: "InterfaceUnionMember1" | "InterfaceUnionMember2";
  readonly interfaceUnionMemberCommonParentProperty: string;
}

export namespace InterfaceUnionMemberCommonParentStatic {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly interfaceUnionMemberCommonParentProperty: string;
  }): Omit<InterfaceUnionMemberCommonParent, "$type"> {
    let $identifier: InterfaceUnionMemberCommonParentStatic.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const interfaceUnionMemberCommonParentProperty =
      parameters.interfaceUnionMemberCommonParentProperty;
    return { $identifier, interfaceUnionMemberCommonParentProperty };
  }

  export function $equals(
    left: InterfaceUnionMemberCommonParent,
    right: InterfaceUnionMemberCommonParent,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.interfaceUnionMemberCommonParentProperty,
          right.interfaceUnionMemberCommonParentProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "interfaceUnionMemberCommonParentProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export function $filter(
    filter: InterfaceUnionMemberCommonParentStatic.$Filter,
    value: InterfaceUnionMemberCommonParent,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.interfaceUnionMemberCommonParentProperty !== "undefined" &&
      !$filterString(
        filter.interfaceUnionMemberCommonParentProperty,
        value.interfaceUnionMemberCommonParentProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly interfaceUnionMemberCommonParentProperty?: $StringFilter;
  };

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _interfaceUnionMemberCommonParent: InterfaceUnionMemberCommonParent,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_interfaceUnionMemberCommonParent.$identifier.value);
    _hasher.update(_interfaceUnionMemberCommonParent.$type);
    InterfaceUnionMemberCommonParentStatic.$hashShaclProperties(
      _interfaceUnionMemberCommonParent,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _interfaceUnionMemberCommonParent: InterfaceUnionMemberCommonParent,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _interfaceUnionMemberCommonParent.interfaceUnionMemberCommonParentProperty,
    );
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "InterfaceUnionMember1" | "InterfaceUnionMember2";
    readonly interfaceUnionMemberCommonParentProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "InterfaceUnionMemberCommonParent" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/interfaceUnionMemberCommonParentProperty`,
          type: "Control",
        },
      ],
      label: "InterfaceUnionMemberCommonParent",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.enum(["InterfaceUnionMember1", "InterfaceUnionMember2"]),
      interfaceUnionMemberCommonParentProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    interfaceUnionMemberCommonParentProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/interfaceUnionMemberCommonParentProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      interfaceUnionMemberCommonParentProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const interfaceUnionMemberCommonParentProperty =
      $jsonObject["interfaceUnionMemberCommonParentProperty"];
    return purify.Either.of({
      $identifier,
      interfaceUnionMemberCommonParentProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      interfaceUnionMemberCommonParentProperty: string;
    }
  > {
    const $identifier: InterfaceUnionMemberCommonParentStatic.$Identifier =
      $parameters.resource.identifier;
    const _interfaceUnionMemberCommonParentPropertyEither: purify.Either<
      Error,
      string
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.interfaceUnionMemberCommonParentProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        $fromRdfPreferredLanguages({
          focusResource: $parameters.resource,
          predicate:
            InterfaceUnionMemberCommonParentStatic.$properties
              .interfaceUnionMemberCommonParentProperty["identifier"],
          preferredLanguages: $parameters.preferredLanguages,
          values,
        }),
      )
      .chain((values) => values.chainMap((value) => value.toString()))
      .chain((values) => values.head());
    if (_interfaceUnionMemberCommonParentPropertyEither.isLeft()) {
      return _interfaceUnionMemberCommonParentPropertyEither;
    }

    const interfaceUnionMemberCommonParentProperty =
      _interfaceUnionMemberCommonParentPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      interfaceUnionMemberCommonParentProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: InterfaceUnionMemberCommonParentStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InterfaceUnionMemberCommonParentStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            InterfaceUnionMemberCommonParentStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: InterfaceUnionMemberCommonParentStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InterfaceUnionMemberCommonParentStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("interfaceUnionMemberCommonParent");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMemberCommonParent")}InterfaceUnionMemberCommonParentProperty`,
      ),
      predicate:
        InterfaceUnionMemberCommonParentStatic.$properties
          .interfaceUnionMemberCommonParentProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: InterfaceUnionMemberCommonParentStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("interfaceUnionMemberCommonParent");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMemberCommonParent")}InterfaceUnionMemberCommonParentProperty`,
            ),
            predicate:
              InterfaceUnionMemberCommonParentStatic.$properties
                .interfaceUnionMemberCommonParentProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMemberCommonParent")}InterfaceUnionMemberCommonParentProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.interfaceUnionMemberCommonParentProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMemberCommonParent")}InterfaceUnionMemberCommonParentProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _interfaceUnionMemberCommonParent: InterfaceUnionMemberCommonParent,
  ): InterfaceUnionMemberCommonParentStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _interfaceUnionMemberCommonParent.$identifier.termType === "BlankNode"
            ? `_:${_interfaceUnionMemberCommonParent.$identifier.value}`
            : _interfaceUnionMemberCommonParent.$identifier.value,
        $type: _interfaceUnionMemberCommonParent.$type,
        interfaceUnionMemberCommonParentProperty:
          _interfaceUnionMemberCommonParent.interfaceUnionMemberCommonParentProperty,
      } satisfies InterfaceUnionMemberCommonParentStatic.$Json),
    );
  }

  export function $toRdf(
    _interfaceUnionMemberCommonParent: InterfaceUnionMemberCommonParent,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _interfaceUnionMemberCommonParent.$identifier,
      { mutateGraph },
    );
    resource.add(
      InterfaceUnionMemberCommonParentStatic.$properties
        .interfaceUnionMemberCommonParentProperty["identifier"],
      ...[
        _interfaceUnionMemberCommonParent.interfaceUnionMemberCommonParentProperty,
      ],
    );
    return resource;
  }
}
export interface InterfaceUnionMember2
  extends InterfaceUnionMemberCommonParent {
  readonly $identifier: InterfaceUnionMember2.$Identifier;
  readonly $type: "InterfaceUnionMember2";
  readonly interfaceUnionMember2Property: string;
}

export namespace InterfaceUnionMember2 {
  export function $create(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly interfaceUnionMember2Property: string;
    } & Parameters<typeof InterfaceUnionMemberCommonParentStatic.$create>[0],
  ): InterfaceUnionMember2 {
    let $identifier: InterfaceUnionMember2.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "InterfaceUnionMember2" as const;
    const interfaceUnionMember2Property =
      parameters.interfaceUnionMember2Property;
    return {
      ...InterfaceUnionMemberCommonParentStatic.$create(parameters),
      $identifier,
      $type,
      interfaceUnionMember2Property,
    };
  }

  export function $equals(
    left: InterfaceUnionMember2,
    right: InterfaceUnionMember2,
  ): $EqualsResult {
    return InterfaceUnionMemberCommonParentStatic.$equals(left, right).chain(
      () =>
        $strictEquals(
          left.interfaceUnionMember2Property,
          right.interfaceUnionMember2Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "interfaceUnionMember2Property",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
    );
  }

  export function $filter(
    filter: InterfaceUnionMember2.$Filter,
    value: InterfaceUnionMember2,
  ): boolean {
    if (!InterfaceUnionMemberCommonParentStatic.$filter(filter, value)) {
      return false;
    }

    if (
      typeof filter.interfaceUnionMember2Property !== "undefined" &&
      !$filterString(
        filter.interfaceUnionMember2Property,
        value.interfaceUnionMember2Property,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly interfaceUnionMember2Property?: $StringFilter;
  } & InterfaceUnionMemberCommonParentStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, InterfaceUnionMember2> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, InterfaceUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return InterfaceUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/InterfaceUnionMember2",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_interfaceUnionMember2: InterfaceUnionMember2, _hasher: HasherT): HasherT {
    InterfaceUnionMember2.$hashShaclProperties(_interfaceUnionMember2, _hasher);
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_interfaceUnionMember2: InterfaceUnionMember2, _hasher: HasherT): HasherT {
    InterfaceUnionMemberCommonParentStatic.$hashShaclProperties(
      _interfaceUnionMember2,
      _hasher,
    );
    _hasher.update(_interfaceUnionMember2.interfaceUnionMember2Property);
    return _hasher;
  }

  export type $Identifier = InterfaceUnionMemberCommonParentStatic.$Identifier;
  export const $Identifier = InterfaceUnionMemberCommonParentStatic.$Identifier;
  export type $Json = {
    readonly interfaceUnionMember2Property: string;
  } & InterfaceUnionMemberCommonParentStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InterfaceUnionMemberCommonParentStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/interfaceUnionMember2Property`,
          type: "Control",
        },
      ],
      label: "InterfaceUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return InterfaceUnionMemberCommonParentStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("InterfaceUnionMember2"),
        interfaceUnionMember2Property: zod.string(),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    ...InterfaceUnionMemberCommonParentStatic.$properties,
    interfaceUnionMember2Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/interfaceUnionMember2Property",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "InterfaceUnionMember2";
      interfaceUnionMember2Property: string;
    } & $UnwrapR<
      ReturnType<
        typeof InterfaceUnionMemberCommonParentStatic.$propertiesFromJson
      >
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      InterfaceUnionMemberCommonParentStatic.$propertiesFromJson($jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "InterfaceUnionMember2" as const;
    const interfaceUnionMember2Property =
      $jsonObject["interfaceUnionMember2Property"];
    return purify.Either.of({
      ...$super0,
      $identifier,
      $type,
      interfaceUnionMember2Property,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "InterfaceUnionMember2";
      interfaceUnionMember2Property: string;
    } & $UnwrapR<
      ReturnType<
        typeof InterfaceUnionMemberCommonParentStatic.$propertiesFromRdf
      >
    >
  > {
    const $super0Either =
      InterfaceUnionMemberCommonParentStatic.$propertiesFromRdf({
        ...$parameters,
        ignoreRdfType: true,
      });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/InterfaceUnionMember2":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              InterfaceUnionMember2.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/InterfaceUnionMember2)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: InterfaceUnionMember2.$Identifier =
      $parameters.resource.identifier;
    const $type = "InterfaceUnionMember2" as const;
    const _interfaceUnionMember2PropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.interfaceUnionMember2Property["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              InterfaceUnionMember2.$properties.interfaceUnionMember2Property[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_interfaceUnionMember2PropertyEither.isLeft()) {
      return _interfaceUnionMember2PropertyEither;
    }

    const interfaceUnionMember2Property =
      _interfaceUnionMember2PropertyEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      $type,
      interfaceUnionMember2Property,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: InterfaceUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InterfaceUnionMember2.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            InterfaceUnionMember2.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: InterfaceUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InterfaceUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("interfaceUnionMember2");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...InterfaceUnionMemberCommonParentStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "interfaceUnionMember2"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember2")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember2")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember2")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember2")}InterfaceUnionMember2Property`,
      ),
      predicate:
        InterfaceUnionMember2.$properties.interfaceUnionMember2Property[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: InterfaceUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("interfaceUnionMember2");
    patterns.push(
      ...InterfaceUnionMemberCommonParentStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "interfaceUnionMember2"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember2")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: InterfaceUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember2")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember2")}InterfaceUnionMember2Property`,
            ),
            predicate:
              InterfaceUnionMember2.$properties.interfaceUnionMember2Property[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember2")}InterfaceUnionMember2Property`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.interfaceUnionMember2Property,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember2")}InterfaceUnionMember2Property`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _interfaceUnionMember2: InterfaceUnionMember2,
  ): InterfaceUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        ...InterfaceUnionMemberCommonParentStatic.$toJson(
          _interfaceUnionMember2,
        ),
        interfaceUnionMember2Property:
          _interfaceUnionMember2.interfaceUnionMember2Property,
      } satisfies InterfaceUnionMember2.$Json),
    );
  }

  export function $toRdf(
    _interfaceUnionMember2: InterfaceUnionMember2,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = InterfaceUnionMemberCommonParentStatic.$toRdf(
      _interfaceUnionMember2,
      { ignoreRdfType: true, mutateGraph, resourceSet },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/InterfaceUnionMember2",
        ),
      );
    }

    resource.add(
      InterfaceUnionMember2.$properties.interfaceUnionMember2Property[
        "identifier"
      ],
      ...[_interfaceUnionMember2.interfaceUnionMember2Property],
    );
    return resource;
  }

  export function isInterfaceUnionMember2(
    object: InterfaceUnionMemberCommonParent,
  ): object is InterfaceUnionMember2 {
    switch (object.$type) {
      case "InterfaceUnionMember2":
        return true;
      default:
        return false;
    }
  }
}
export interface InterfaceUnionMember1
  extends InterfaceUnionMemberCommonParent {
  readonly $identifier: InterfaceUnionMember1.$Identifier;
  readonly $type: "InterfaceUnionMember1";
  readonly interfaceUnionMember1Property: string;
}

export namespace InterfaceUnionMember1 {
  export function $create(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly interfaceUnionMember1Property: string;
    } & Parameters<typeof InterfaceUnionMemberCommonParentStatic.$create>[0],
  ): InterfaceUnionMember1 {
    let $identifier: InterfaceUnionMember1.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "InterfaceUnionMember1" as const;
    const interfaceUnionMember1Property =
      parameters.interfaceUnionMember1Property;
    return {
      ...InterfaceUnionMemberCommonParentStatic.$create(parameters),
      $identifier,
      $type,
      interfaceUnionMember1Property,
    };
  }

  export function $equals(
    left: InterfaceUnionMember1,
    right: InterfaceUnionMember1,
  ): $EqualsResult {
    return InterfaceUnionMemberCommonParentStatic.$equals(left, right).chain(
      () =>
        $strictEquals(
          left.interfaceUnionMember1Property,
          right.interfaceUnionMember1Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "interfaceUnionMember1Property",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
    );
  }

  export function $filter(
    filter: InterfaceUnionMember1.$Filter,
    value: InterfaceUnionMember1,
  ): boolean {
    if (!InterfaceUnionMemberCommonParentStatic.$filter(filter, value)) {
      return false;
    }

    if (
      typeof filter.interfaceUnionMember1Property !== "undefined" &&
      !$filterString(
        filter.interfaceUnionMember1Property,
        value.interfaceUnionMember1Property,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly interfaceUnionMember1Property?: $StringFilter;
  } & InterfaceUnionMemberCommonParentStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, InterfaceUnionMember1> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, InterfaceUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return InterfaceUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/InterfaceUnionMember1",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_interfaceUnionMember1: InterfaceUnionMember1, _hasher: HasherT): HasherT {
    InterfaceUnionMember1.$hashShaclProperties(_interfaceUnionMember1, _hasher);
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_interfaceUnionMember1: InterfaceUnionMember1, _hasher: HasherT): HasherT {
    InterfaceUnionMemberCommonParentStatic.$hashShaclProperties(
      _interfaceUnionMember1,
      _hasher,
    );
    _hasher.update(_interfaceUnionMember1.interfaceUnionMember1Property);
    return _hasher;
  }

  export type $Identifier = InterfaceUnionMemberCommonParentStatic.$Identifier;
  export const $Identifier = InterfaceUnionMemberCommonParentStatic.$Identifier;
  export type $Json = {
    readonly interfaceUnionMember1Property: string;
  } & InterfaceUnionMemberCommonParentStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InterfaceUnionMemberCommonParentStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/interfaceUnionMember1Property`,
          type: "Control",
        },
      ],
      label: "InterfaceUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return InterfaceUnionMemberCommonParentStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("InterfaceUnionMember1"),
        interfaceUnionMember1Property: zod.string(),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    ...InterfaceUnionMemberCommonParentStatic.$properties,
    interfaceUnionMember1Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/interfaceUnionMember1Property",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "InterfaceUnionMember1";
      interfaceUnionMember1Property: string;
    } & $UnwrapR<
      ReturnType<
        typeof InterfaceUnionMemberCommonParentStatic.$propertiesFromJson
      >
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      InterfaceUnionMemberCommonParentStatic.$propertiesFromJson($jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "InterfaceUnionMember1" as const;
    const interfaceUnionMember1Property =
      $jsonObject["interfaceUnionMember1Property"];
    return purify.Either.of({
      ...$super0,
      $identifier,
      $type,
      interfaceUnionMember1Property,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "InterfaceUnionMember1";
      interfaceUnionMember1Property: string;
    } & $UnwrapR<
      ReturnType<
        typeof InterfaceUnionMemberCommonParentStatic.$propertiesFromRdf
      >
    >
  > {
    const $super0Either =
      InterfaceUnionMemberCommonParentStatic.$propertiesFromRdf({
        ...$parameters,
        ignoreRdfType: true,
      });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/InterfaceUnionMember1":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              InterfaceUnionMember1.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/InterfaceUnionMember1)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: InterfaceUnionMember1.$Identifier =
      $parameters.resource.identifier;
    const $type = "InterfaceUnionMember1" as const;
    const _interfaceUnionMember1PropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.interfaceUnionMember1Property["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              InterfaceUnionMember1.$properties.interfaceUnionMember1Property[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_interfaceUnionMember1PropertyEither.isLeft()) {
      return _interfaceUnionMember1PropertyEither;
    }

    const interfaceUnionMember1Property =
      _interfaceUnionMember1PropertyEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      $type,
      interfaceUnionMember1Property,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: InterfaceUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InterfaceUnionMember1.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            InterfaceUnionMember1.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: InterfaceUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InterfaceUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("interfaceUnionMember1");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...InterfaceUnionMemberCommonParentStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "interfaceUnionMember1"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember1")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember1")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember1")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember1")}InterfaceUnionMember1Property`,
      ),
      predicate:
        InterfaceUnionMember1.$properties.interfaceUnionMember1Property[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: InterfaceUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("interfaceUnionMember1");
    patterns.push(
      ...InterfaceUnionMemberCommonParentStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "interfaceUnionMember1"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember1")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: InterfaceUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember1")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember1")}InterfaceUnionMember1Property`,
            ),
            predicate:
              InterfaceUnionMember1.$properties.interfaceUnionMember1Property[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember1")}InterfaceUnionMember1Property`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.interfaceUnionMember1Property,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interfaceUnionMember1")}InterfaceUnionMember1Property`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _interfaceUnionMember1: InterfaceUnionMember1,
  ): InterfaceUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        ...InterfaceUnionMemberCommonParentStatic.$toJson(
          _interfaceUnionMember1,
        ),
        interfaceUnionMember1Property:
          _interfaceUnionMember1.interfaceUnionMember1Property,
      } satisfies InterfaceUnionMember1.$Json),
    );
  }

  export function $toRdf(
    _interfaceUnionMember1: InterfaceUnionMember1,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = InterfaceUnionMemberCommonParentStatic.$toRdf(
      _interfaceUnionMember1,
      { ignoreRdfType: true, mutateGraph, resourceSet },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/InterfaceUnionMember1",
        ),
      );
    }

    resource.add(
      InterfaceUnionMember1.$properties.interfaceUnionMember1Property[
        "identifier"
      ],
      ...[_interfaceUnionMember1.interfaceUnionMember1Property],
    );
    return resource;
  }

  export function isInterfaceUnionMember1(
    object: InterfaceUnionMemberCommonParent,
  ): object is InterfaceUnionMember1 {
    switch (object.$type) {
      case "InterfaceUnionMember1":
        return true;
      default:
        return false;
    }
  }
}
/**
 * A node shape that's generated as a TypeScript interface instead of a class.
 */
export interface Interface {
  readonly $identifier: Interface.$Identifier;
  readonly $type: "Interface";
  readonly interfaceProperty: string;
}

export namespace Interface {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly interfaceProperty: string;
  }): Interface {
    let $identifier: Interface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "Interface" as const;
    const interfaceProperty = parameters.interfaceProperty;
    return { $identifier, $type, interfaceProperty };
  }

  export function $equals(left: Interface, right: Interface): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(left.interfaceProperty, right.interfaceProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "interfaceProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  export function $filter(
    filter: Interface.$Filter,
    value: Interface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.interfaceProperty !== "undefined" &&
      !$filterString(filter.interfaceProperty, value.interfaceProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly interfaceProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Interface> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, Interface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return Interface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_interface: Interface, _hasher: HasherT): HasherT {
    _hasher.update(_interface.$identifier.value);
    _hasher.update(_interface.$type);
    Interface.$hashShaclProperties(_interface, _hasher);
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_interface: Interface, _hasher: HasherT): HasherT {
    _hasher.update(_interface.interfaceProperty);
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "Interface";
    readonly interfaceProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "Interface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/interfaceProperty`,
          type: "Control",
        },
      ],
      label: "Interface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("Interface"),
      interfaceProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    interfaceProperty: {
      identifier: dataFactory.namedNode("http://example.com/interfaceProperty"),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "Interface";
      interfaceProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "Interface" as const;
    const interfaceProperty = $jsonObject["interfaceProperty"];
    return purify.Either.of({ $identifier, $type, interfaceProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "Interface";
      interfaceProperty: string;
    }
  > {
    const $identifier: Interface.$Identifier = $parameters.resource.identifier;
    const $type = "Interface" as const;
    const _interfacePropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.interfaceProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate: Interface.$properties.interfaceProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_interfacePropertyEither.isLeft()) {
      return _interfacePropertyEither;
    }

    const interfaceProperty = _interfacePropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, $type, interfaceProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: Interface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Interface.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            Interface.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: Interface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Interface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("interface");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interface")}InterfaceProperty`,
      ),
      predicate: Interface.$properties.interfaceProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: Interface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("interface");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interface")}InterfaceProperty`,
            ),
            predicate: Interface.$properties.interfaceProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interface")}InterfaceProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.interfaceProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "interface")}InterfaceProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(_interface: Interface): Interface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _interface.$identifier.termType === "BlankNode"
            ? `_:${_interface.$identifier.value}`
            : _interface.$identifier.value,
        $type: _interface.$type,
        interfaceProperty: _interface.interfaceProperty,
      } satisfies Interface.$Json),
    );
  }

  export function $toRdf(
    _interface: Interface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(_interface.$identifier, {
      mutateGraph,
    });
    resource.add(
      Interface.$properties.interfaceProperty["identifier"],
      ...[_interface.interfaceProperty],
    );
    return resource;
  }
}
export class IndirectRecursiveHelperClass {
  private _$identifier?: IndirectRecursiveHelperClass.$Identifier;
  readonly $type = "IndirectRecursiveHelperClass";
  readonly indirectRecursiveProperty: purify.Maybe<IndirectRecursiveClass>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly indirectRecursiveProperty?:
      | IndirectRecursiveClass
      | purify.Maybe<IndirectRecursiveClass>;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.indirectRecursiveProperty)) {
      this.indirectRecursiveProperty = parameters?.indirectRecursiveProperty;
    } else if (
      typeof parameters?.indirectRecursiveProperty === "object" &&
      parameters?.indirectRecursiveProperty instanceof IndirectRecursiveClass
    ) {
      this.indirectRecursiveProperty = purify.Maybe.of(
        parameters?.indirectRecursiveProperty,
      );
    } else if (typeof parameters?.indirectRecursiveProperty === "undefined") {
      this.indirectRecursiveProperty = purify.Maybe.empty();
    } else {
      this.indirectRecursiveProperty =
        parameters?.indirectRecursiveProperty satisfies never;
    }
  }

  get $identifier(): IndirectRecursiveHelperClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: IndirectRecursiveHelperClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.indirectRecursiveProperty,
          other.indirectRecursiveProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "indirectRecursiveProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.indirectRecursiveProperty.ifJust((value0) => {
      value0.$hash(_hasher);
    });
    return _hasher;
  }

  $toJson(): IndirectRecursiveHelperClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        indirectRecursiveProperty: this.indirectRecursiveProperty
          .map((item) => item.$toJson())
          .extract(),
      } satisfies IndirectRecursiveHelperClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      IndirectRecursiveHelperClass.$properties.indirectRecursiveProperty[
        "identifier"
      ],
      ...this.indirectRecursiveProperty
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IndirectRecursiveHelperClass {
  export function $filter(
    filter: IndirectRecursiveHelperClass.$Filter,
    value: IndirectRecursiveHelperClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.indirectRecursiveProperty !== "undefined" &&
      !$filterMaybe<IndirectRecursiveClass, IndirectRecursiveClass.$Filter>(
        IndirectRecursiveClass.$filter,
      )(filter.indirectRecursiveProperty, value.indirectRecursiveProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly indirectRecursiveProperty?: $MaybeFilter<IndirectRecursiveClass.$Filter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, IndirectRecursiveHelperClass> {
    return $propertiesFromJson(json).map(
      (properties) => new IndirectRecursiveHelperClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, IndirectRecursiveHelperClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return IndirectRecursiveHelperClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new IndirectRecursiveHelperClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "IndirectRecursiveHelperClass";
    readonly indirectRecursiveProperty?: IndirectRecursiveClass.$Json;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "IndirectRecursiveHelperClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        IndirectRecursiveClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/indirectRecursiveProperty`,
        }),
      ],
      label: "IndirectRecursiveHelperClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("IndirectRecursiveHelperClass"),
      indirectRecursiveProperty: zod
        .lazy(
          (): zod.ZodType<IndirectRecursiveClass.$Json> =>
            IndirectRecursiveClass.$jsonZodSchema(),
        )
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    indirectRecursiveProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/indirectRecursiveProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      indirectRecursiveProperty: purify.Maybe<IndirectRecursiveClass>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const indirectRecursiveProperty = purify.Maybe.fromNullable(
      $jsonObject["indirectRecursiveProperty"],
    ).map((item) => IndirectRecursiveClass.$fromJson(item).unsafeCoerce());
    return purify.Either.of({ $identifier, indirectRecursiveProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      indirectRecursiveProperty: purify.Maybe<IndirectRecursiveClass>;
    }
  > {
    const $identifier: IndirectRecursiveHelperClass.$Identifier =
      $parameters.resource.identifier;
    const _indirectRecursivePropertyEither: purify.Either<
      Error,
      purify.Maybe<IndirectRecursiveClass>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.indirectRecursiveProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            IndirectRecursiveClass.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<IndirectRecursiveClass>
            >({
              focusResource: $parameters.resource,
              predicate:
                IndirectRecursiveHelperClass.$properties
                  .indirectRecursiveProperty["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_indirectRecursivePropertyEither.isLeft()) {
      return _indirectRecursivePropertyEither;
    }

    const indirectRecursiveProperty =
      _indirectRecursivePropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, indirectRecursiveProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IndirectRecursiveHelperClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IndirectRecursiveHelperClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            IndirectRecursiveHelperClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IndirectRecursiveHelperClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IndirectRecursiveHelperClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IndirectRecursiveHelperClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("indirectRecursiveHelperClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }
}
export class IndirectRecursiveClass {
  private _$identifier?: IndirectRecursiveClass.$Identifier;
  readonly $type = "IndirectRecursiveClass";
  readonly indirectRecursiveHelperProperty: purify.Maybe<IndirectRecursiveHelperClass>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly indirectRecursiveHelperProperty?:
      | IndirectRecursiveHelperClass
      | purify.Maybe<IndirectRecursiveHelperClass>;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.indirectRecursiveHelperProperty)) {
      this.indirectRecursiveHelperProperty =
        parameters?.indirectRecursiveHelperProperty;
    } else if (
      typeof parameters?.indirectRecursiveHelperProperty === "object" &&
      parameters?.indirectRecursiveHelperProperty instanceof
        IndirectRecursiveHelperClass
    ) {
      this.indirectRecursiveHelperProperty = purify.Maybe.of(
        parameters?.indirectRecursiveHelperProperty,
      );
    } else if (
      typeof parameters?.indirectRecursiveHelperProperty === "undefined"
    ) {
      this.indirectRecursiveHelperProperty = purify.Maybe.empty();
    } else {
      this.indirectRecursiveHelperProperty =
        parameters?.indirectRecursiveHelperProperty satisfies never;
    }
  }

  get $identifier(): IndirectRecursiveClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: IndirectRecursiveClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.indirectRecursiveHelperProperty,
          other.indirectRecursiveHelperProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "indirectRecursiveHelperProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.indirectRecursiveHelperProperty.ifJust((value0) => {
      value0.$hash(_hasher);
    });
    return _hasher;
  }

  $toJson(): IndirectRecursiveClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        indirectRecursiveHelperProperty: this.indirectRecursiveHelperProperty
          .map((item) => item.$toJson())
          .extract(),
      } satisfies IndirectRecursiveClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      IndirectRecursiveClass.$properties.indirectRecursiveHelperProperty[
        "identifier"
      ],
      ...this.indirectRecursiveHelperProperty
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IndirectRecursiveClass {
  export function $filter(
    filter: IndirectRecursiveClass.$Filter,
    value: IndirectRecursiveClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.indirectRecursiveHelperProperty !== "undefined" &&
      !$filterMaybe<
        IndirectRecursiveHelperClass,
        IndirectRecursiveHelperClass.$Filter
      >(IndirectRecursiveHelperClass.$filter)(
        filter.indirectRecursiveHelperProperty,
        value.indirectRecursiveHelperProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly indirectRecursiveHelperProperty?: $MaybeFilter<IndirectRecursiveHelperClass.$Filter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, IndirectRecursiveClass> {
    return $propertiesFromJson(json).map(
      (properties) => new IndirectRecursiveClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, IndirectRecursiveClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return IndirectRecursiveClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new IndirectRecursiveClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "IndirectRecursiveClass";
    readonly indirectRecursiveHelperProperty?: IndirectRecursiveHelperClass.$Json;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "IndirectRecursiveClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        IndirectRecursiveHelperClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/indirectRecursiveHelperProperty`,
        }),
      ],
      label: "IndirectRecursiveClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("IndirectRecursiveClass"),
      indirectRecursiveHelperProperty: zod
        .lazy(
          (): zod.ZodType<IndirectRecursiveHelperClass.$Json> =>
            IndirectRecursiveHelperClass.$jsonZodSchema(),
        )
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    indirectRecursiveHelperProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/indirectRecursiveHelperProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      indirectRecursiveHelperProperty: purify.Maybe<IndirectRecursiveHelperClass>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const indirectRecursiveHelperProperty = purify.Maybe.fromNullable(
      $jsonObject["indirectRecursiveHelperProperty"],
    ).map((item) =>
      IndirectRecursiveHelperClass.$fromJson(item).unsafeCoerce(),
    );
    return purify.Either.of({ $identifier, indirectRecursiveHelperProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      indirectRecursiveHelperProperty: purify.Maybe<IndirectRecursiveHelperClass>;
    }
  > {
    const $identifier: IndirectRecursiveClass.$Identifier =
      $parameters.resource.identifier;
    const _indirectRecursiveHelperPropertyEither: purify.Either<
      Error,
      purify.Maybe<IndirectRecursiveHelperClass>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.indirectRecursiveHelperProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            IndirectRecursiveHelperClass.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<IndirectRecursiveHelperClass>
            >({
              focusResource: $parameters.resource,
              predicate:
                IndirectRecursiveClass.$properties
                  .indirectRecursiveHelperProperty["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_indirectRecursiveHelperPropertyEither.isLeft()) {
      return _indirectRecursiveHelperPropertyEither;
    }

    const indirectRecursiveHelperProperty =
      _indirectRecursiveHelperPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, indirectRecursiveHelperProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IndirectRecursiveClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IndirectRecursiveClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            IndirectRecursiveClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IndirectRecursiveClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IndirectRecursiveClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IndirectRecursiveClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("indirectRecursiveClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }
}
/**
 * Shape with sh:in properties.
 */
export class InPropertiesClass {
  private _$identifier?: InPropertiesClass.$Identifier;
  readonly $type = "InPropertiesClass";
  readonly inBooleansProperty: purify.Maybe<true>;
  readonly inDateTimesProperty: purify.Maybe<Date>;
  readonly inIrisProperty: purify.Maybe<
    rdfjs.NamedNode<
      | "http://example.com/InPropertiesIri1"
      | "http://example.com/InPropertiesIri2"
    >
  >;
  readonly inNumbersProperty: purify.Maybe<1 | 2>;
  readonly inStringsProperty: purify.Maybe<"text" | "html">;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly inBooleansProperty?: purify.Maybe<true> | true;
    readonly inDateTimesProperty?: Date | purify.Maybe<Date>;
    readonly inIrisProperty?:
      | "http://example.com/InPropertiesIri1"
      | "http://example.com/InPropertiesIri2"
      | purify.Maybe<
          rdfjs.NamedNode<
            | "http://example.com/InPropertiesIri1"
            | "http://example.com/InPropertiesIri2"
          >
        >
      | rdfjs.NamedNode<
          | "http://example.com/InPropertiesIri1"
          | "http://example.com/InPropertiesIri2"
        >;
    readonly inNumbersProperty?: 1 | 2 | purify.Maybe<1 | 2>;
    readonly inStringsProperty?:
      | "text"
      | "html"
      | purify.Maybe<"text" | "html">;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.inBooleansProperty)) {
      this.inBooleansProperty = parameters?.inBooleansProperty;
    } else if (typeof parameters?.inBooleansProperty === "boolean") {
      this.inBooleansProperty = purify.Maybe.of(parameters?.inBooleansProperty);
    } else if (typeof parameters?.inBooleansProperty === "undefined") {
      this.inBooleansProperty = purify.Maybe.empty();
    } else {
      this.inBooleansProperty = parameters?.inBooleansProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.inDateTimesProperty)) {
      this.inDateTimesProperty = parameters?.inDateTimesProperty;
    } else if (
      typeof parameters?.inDateTimesProperty === "object" &&
      parameters?.inDateTimesProperty instanceof Date
    ) {
      this.inDateTimesProperty = purify.Maybe.of(
        parameters?.inDateTimesProperty,
      );
    } else if (typeof parameters?.inDateTimesProperty === "undefined") {
      this.inDateTimesProperty = purify.Maybe.empty();
    } else {
      this.inDateTimesProperty =
        parameters?.inDateTimesProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.inIrisProperty)) {
      this.inIrisProperty = parameters?.inIrisProperty;
    } else if (typeof parameters?.inIrisProperty === "object") {
      this.inIrisProperty = purify.Maybe.of(parameters?.inIrisProperty);
    } else if (typeof parameters?.inIrisProperty === "string") {
      this.inIrisProperty = purify.Maybe.of(
        dataFactory.namedNode(parameters?.inIrisProperty),
      );
    } else if (typeof parameters?.inIrisProperty === "undefined") {
      this.inIrisProperty = purify.Maybe.empty();
    } else {
      this.inIrisProperty = parameters?.inIrisProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.inNumbersProperty)) {
      this.inNumbersProperty = parameters?.inNumbersProperty;
    } else if (typeof parameters?.inNumbersProperty === "number") {
      this.inNumbersProperty = purify.Maybe.of(parameters?.inNumbersProperty);
    } else if (typeof parameters?.inNumbersProperty === "undefined") {
      this.inNumbersProperty = purify.Maybe.empty();
    } else {
      this.inNumbersProperty = parameters?.inNumbersProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.inStringsProperty)) {
      this.inStringsProperty = parameters?.inStringsProperty;
    } else if (typeof parameters?.inStringsProperty === "string") {
      this.inStringsProperty = purify.Maybe.of(parameters?.inStringsProperty);
    } else if (typeof parameters?.inStringsProperty === "undefined") {
      this.inStringsProperty = purify.Maybe.empty();
    } else {
      this.inStringsProperty = parameters?.inStringsProperty satisfies never;
    }
  }

  get $identifier(): InPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: InPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.inBooleansProperty,
          other.inBooleansProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inBooleansProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.inDateTimesProperty,
          other.inDateTimesProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inDateTimesProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.inIrisProperty,
          other.inIrisProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inIrisProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.inNumbersProperty,
          other.inNumbersProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inNumbersProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.inStringsProperty,
          other.inStringsProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inStringsProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.inBooleansProperty.ifJust((value0) => {
      _hasher.update(value0.toString());
    });
    this.inDateTimesProperty.ifJust((value0) => {
      _hasher.update(value0.toISOString());
    });
    this.inIrisProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    this.inNumbersProperty.ifJust((value0) => {
      _hasher.update(value0.toString());
    });
    this.inStringsProperty.ifJust((value0) => {
      _hasher.update(value0);
    });
    return _hasher;
  }

  $toJson(): InPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        inBooleansProperty: this.inBooleansProperty
          .map((item) => item)
          .extract(),
        inDateTimesProperty: this.inDateTimesProperty
          .map((item) => item.toISOString())
          .extract(),
        inIrisProperty: this.inIrisProperty
          .map((item) => ({ "@id": item.value }))
          .extract(),
        inNumbersProperty: this.inNumbersProperty.map((item) => item).extract(),
        inStringsProperty: this.inStringsProperty.map((item) => item).extract(),
      } satisfies InPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      InPropertiesClass.$properties.inBooleansProperty["identifier"],
      ...this.inBooleansProperty.toList(),
    );
    resource.add(
      InPropertiesClass.$properties.inDateTimesProperty["identifier"],
      ...this.inDateTimesProperty
        .toList()
        .flatMap((value) => [
          dataFactory.literal(
            value.toISOString(),
            $RdfVocabularies.xsd.dateTime,
          ),
        ]),
    );
    resource.add(
      InPropertiesClass.$properties.inIrisProperty["identifier"],
      ...this.inIrisProperty.toList(),
    );
    resource.add(
      InPropertiesClass.$properties.inNumbersProperty["identifier"],
      ...this.inNumbersProperty
        .toList()
        .flatMap((value) => [
          dataFactory.literal(value.toString(10), $RdfVocabularies.xsd.integer),
        ]),
    );
    resource.add(
      InPropertiesClass.$properties.inStringsProperty["identifier"],
      ...this.inStringsProperty.toList(),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace InPropertiesClass {
  export function $filter(
    filter: InPropertiesClass.$Filter,
    value: InPropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.inBooleansProperty !== "undefined" &&
      !$filterMaybe<true, $BooleanFilter>($filterBoolean)(
        filter.inBooleansProperty,
        value.inBooleansProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.inDateTimesProperty !== "undefined" &&
      !$filterMaybe<Date, $DateFilter>($filterDate)(
        filter.inDateTimesProperty,
        value.inDateTimesProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.inIrisProperty !== "undefined" &&
      !$filterMaybe<
        rdfjs.NamedNode<
          | "http://example.com/InPropertiesIri1"
          | "http://example.com/InPropertiesIri2"
        >,
        $NamedNodeFilter
      >($filterNamedNode)(filter.inIrisProperty, value.inIrisProperty)
    ) {
      return false;
    }

    if (
      typeof filter.inNumbersProperty !== "undefined" &&
      !$filterMaybe<1 | 2, $NumberFilter>($filterNumber)(
        filter.inNumbersProperty,
        value.inNumbersProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.inStringsProperty !== "undefined" &&
      !$filterMaybe<"text" | "html", $StringFilter>($filterString)(
        filter.inStringsProperty,
        value.inStringsProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly inBooleansProperty?: $MaybeFilter<$BooleanFilter>;
    readonly inDateTimesProperty?: $MaybeFilter<$DateFilter>;
    readonly inIrisProperty?: $MaybeFilter<$NamedNodeFilter>;
    readonly inNumbersProperty?: $MaybeFilter<$NumberFilter>;
    readonly inStringsProperty?: $MaybeFilter<$StringFilter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, InPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new InPropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, InPropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return InPropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new InPropertiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "InPropertiesClass";
    readonly inBooleansProperty?: true;
    readonly inDateTimesProperty?: string;
    readonly inIrisProperty?: {
      readonly "@id":
        | "http://example.com/InPropertiesIri1"
        | "http://example.com/InPropertiesIri2";
    };
    readonly inNumbersProperty?: 1 | 2;
    readonly inStringsProperty?: "text" | "html";
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "InPropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/inBooleansProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/inDateTimesProperty`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/inIrisProperty`, type: "Control" },
        {
          scope: `${scopePrefix}/properties/inNumbersProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/inStringsProperty`,
          type: "Control",
        },
      ],
      label: "InPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("InPropertiesClass"),
      inBooleansProperty: zod.literal(true).optional(),
      inDateTimesProperty: zod.iso.datetime().optional(),
      inIrisProperty: zod
        .object({
          "@id": zod.enum([
            "http://example.com/InPropertiesIri1",
            "http://example.com/InPropertiesIri2",
          ]),
        })
        .optional(),
      inNumbersProperty: zod.union([zod.literal(1), zod.literal(2)]).optional(),
      inStringsProperty: zod.enum(["text", "html"]).optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    inBooleansProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/inBooleansProperty",
      ),
    },
    inDateTimesProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/inDateTimesProperty",
      ),
    },
    inIrisProperty: {
      identifier: dataFactory.namedNode("http://example.com/inIrisProperty"),
    },
    inNumbersProperty: {
      identifier: dataFactory.namedNode("http://example.com/inNumbersProperty"),
    },
    inStringsProperty: {
      identifier: dataFactory.namedNode("http://example.com/inStringsProperty"),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      inBooleansProperty: purify.Maybe<true>;
      inDateTimesProperty: purify.Maybe<Date>;
      inIrisProperty: purify.Maybe<
        rdfjs.NamedNode<
          | "http://example.com/InPropertiesIri1"
          | "http://example.com/InPropertiesIri2"
        >
      >;
      inNumbersProperty: purify.Maybe<1 | 2>;
      inStringsProperty: purify.Maybe<"text" | "html">;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const inBooleansProperty = purify.Maybe.fromNullable(
      $jsonObject["inBooleansProperty"],
    );
    const inDateTimesProperty = purify.Maybe.fromNullable(
      $jsonObject["inDateTimesProperty"],
    ).map((item) => new Date(item));
    const inIrisProperty = purify.Maybe.fromNullable(
      $jsonObject["inIrisProperty"],
    ).map((item) => dataFactory.namedNode(item["@id"]));
    const inNumbersProperty = purify.Maybe.fromNullable(
      $jsonObject["inNumbersProperty"],
    );
    const inStringsProperty = purify.Maybe.fromNullable(
      $jsonObject["inStringsProperty"],
    );
    return purify.Either.of({
      $identifier,
      inBooleansProperty,
      inDateTimesProperty,
      inIrisProperty,
      inNumbersProperty,
      inStringsProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      inBooleansProperty: purify.Maybe<true>;
      inDateTimesProperty: purify.Maybe<Date>;
      inIrisProperty: purify.Maybe<
        rdfjs.NamedNode<
          | "http://example.com/InPropertiesIri1"
          | "http://example.com/InPropertiesIri2"
        >
      >;
      inNumbersProperty: purify.Maybe<1 | 2>;
      inStringsProperty: purify.Maybe<"text" | "html">;
    }
  > {
    const $identifier: InPropertiesClass.$Identifier =
      $parameters.resource.identifier;
    const _inBooleansPropertyEither: purify.Either<
      Error,
      purify.Maybe<true>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.inBooleansProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toBoolean().chain((primitiveValue) =>
            primitiveValue === true
              ? purify.Either.of<Error, true>(primitiveValue)
              : purify.Left<Error, true>(
                  new rdfjsResource.Resource.MistypedTermValueError({
                    actualValue: value.toTerm(),
                    expectedValueType: "true",
                    focusResource: $parameters.resource,
                    predicate:
                      InPropertiesClass.$properties.inBooleansProperty[
                        "identifier"
                      ],
                  }),
                ),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<true>>({
              focusResource: $parameters.resource,
              predicate:
                InPropertiesClass.$properties.inBooleansProperty["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_inBooleansPropertyEither.isLeft()) {
      return _inBooleansPropertyEither;
    }

    const inBooleansProperty = _inBooleansPropertyEither.unsafeCoerce();
    const _inDateTimesPropertyEither: purify.Either<
      Error,
      purify.Maybe<Date>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.inDateTimesProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toDate().chain((primitiveValue) => {
            if (primitiveValue.getTime() === 1523268000000) {
              return purify.Either.of<Error, Date>(primitiveValue);
            }
            return purify.Left<Error, Date>(
              new rdfjsResource.Resource.MistypedTermValueError({
                actualValue: value.toTerm(),
                expectedValueType: "Date",
                focusResource: $parameters.resource,
                predicate:
                  InPropertiesClass.$properties.inDateTimesProperty[
                    "identifier"
                  ],
              }),
            );
          }),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<Date>>({
              focusResource: $parameters.resource,
              predicate:
                InPropertiesClass.$properties.inDateTimesProperty["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_inDateTimesPropertyEither.isLeft()) {
      return _inDateTimesPropertyEither;
    }

    const inDateTimesProperty = _inDateTimesPropertyEither.unsafeCoerce();
    const _inIrisPropertyEither: purify.Either<
      Error,
      purify.Maybe<
        rdfjs.NamedNode<
          | "http://example.com/InPropertiesIri1"
          | "http://example.com/InPropertiesIri2"
        >
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values($properties.inIrisProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toIri().chain((iri) => {
            switch (iri.value) {
              case "http://example.com/InPropertiesIri1":
                return purify.Either.of<
                  Error,
                  rdfjs.NamedNode<
                    | "http://example.com/InPropertiesIri1"
                    | "http://example.com/InPropertiesIri2"
                  >
                >(
                  iri as rdfjs.NamedNode<"http://example.com/InPropertiesIri1">,
                );
              case "http://example.com/InPropertiesIri2":
                return purify.Either.of<
                  Error,
                  rdfjs.NamedNode<
                    | "http://example.com/InPropertiesIri1"
                    | "http://example.com/InPropertiesIri2"
                  >
                >(
                  iri as rdfjs.NamedNode<"http://example.com/InPropertiesIri2">,
                );
              default:
                return purify.Left<
                  Error,
                  rdfjs.NamedNode<
                    | "http://example.com/InPropertiesIri1"
                    | "http://example.com/InPropertiesIri2"
                  >
                >(
                  new rdfjsResource.Resource.MistypedTermValueError({
                    actualValue: iri,
                    expectedValueType:
                      'rdfjs.NamedNode<"http://example.com/InPropertiesIri1" | "http://example.com/InPropertiesIri2">',
                    focusResource: $parameters.resource,
                    predicate:
                      InPropertiesClass.$properties.inIrisProperty[
                        "identifier"
                      ],
                  }),
                );
            }
          }),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<
                rdfjs.NamedNode<
                  | "http://example.com/InPropertiesIri1"
                  | "http://example.com/InPropertiesIri2"
                >
              >
            >({
              focusResource: $parameters.resource,
              predicate:
                InPropertiesClass.$properties.inIrisProperty["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_inIrisPropertyEither.isLeft()) {
      return _inIrisPropertyEither;
    }

    const inIrisProperty = _inIrisPropertyEither.unsafeCoerce();
    const _inNumbersPropertyEither: purify.Either<
      Error,
      purify.Maybe<1 | 2>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values($properties.inNumbersProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toNumber().chain((primitiveValue) => {
            switch (primitiveValue) {
              case 1:
              case 2:
                return purify.Either.of<Error, 1 | 2>(primitiveValue);
              default:
                return purify.Left<Error, 1 | 2>(
                  new rdfjsResource.Resource.MistypedTermValueError({
                    actualValue: value.toTerm(),
                    expectedValueType: "1 | 2",
                    focusResource: $parameters.resource,
                    predicate:
                      InPropertiesClass.$properties.inNumbersProperty[
                        "identifier"
                      ],
                  }),
                );
            }
          }),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<1 | 2>>({
              focusResource: $parameters.resource,
              predicate:
                InPropertiesClass.$properties.inNumbersProperty["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_inNumbersPropertyEither.isLeft()) {
      return _inNumbersPropertyEither;
    }

    const inNumbersProperty = _inNumbersPropertyEither.unsafeCoerce();
    const _inStringsPropertyEither: purify.Either<
      Error,
      purify.Maybe<"text" | "html">
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values($properties.inStringsProperty["identifier"], {
        unique: true,
      }),
    )
      .chain((values) =>
        $fromRdfPreferredLanguages({
          focusResource: $parameters.resource,
          predicate:
            InPropertiesClass.$properties.inStringsProperty["identifier"],
          preferredLanguages: $parameters.preferredLanguages,
          values,
        }),
      )
      .chain((values) =>
        values.chainMap((value) =>
          value.toString().chain((string_) => {
            switch (string_) {
              case "text":
              case "html":
                return purify.Either.of<Error, "text" | "html">(string_);
              default:
                return purify.Left<Error, "text" | "html">(
                  new rdfjsResource.Resource.MistypedTermValueError({
                    actualValue: value.toTerm(),
                    expectedValueType: '"text" | "html"',
                    focusResource: $parameters.resource,
                    predicate:
                      InPropertiesClass.$properties.inStringsProperty[
                        "identifier"
                      ],
                  }),
                );
            }
          }),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<"text" | "html">
            >({
              focusResource: $parameters.resource,
              predicate:
                InPropertiesClass.$properties.inStringsProperty["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_inStringsPropertyEither.isLeft()) {
      return _inStringsPropertyEither;
    }

    const inStringsProperty = _inStringsPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      inBooleansProperty,
      inDateTimesProperty,
      inIrisProperty,
      inNumbersProperty,
      inStringsProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: InPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InPropertiesClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            InPropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: InPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("inPropertiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InBooleansProperty`,
      ),
      predicate: InPropertiesClass.$properties.inBooleansProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InDateTimesProperty`,
      ),
      predicate:
        InPropertiesClass.$properties.inDateTimesProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InIrisProperty`,
      ),
      predicate: InPropertiesClass.$properties.inIrisProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InNumbersProperty`,
      ),
      predicate: InPropertiesClass.$properties.inNumbersProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InStringsProperty`,
      ),
      predicate: InPropertiesClass.$properties.inStringsProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: InPropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("inPropertiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.inBooleansProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InBooleansProperty`,
                  ),
                  predicate:
                    InPropertiesClass.$properties.inBooleansProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $BooleanFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InBooleansProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.inDateTimesProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InDateTimesProperty`,
                  ),
                  predicate:
                    InPropertiesClass.$properties.inDateTimesProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $DateFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InDateTimesProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.inIrisProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InIrisProperty`,
                  ),
                  predicate:
                    InPropertiesClass.$properties.inIrisProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $NamedNodeFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InIrisProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.inNumbersProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InNumbersProperty`,
                  ),
                  predicate:
                    InPropertiesClass.$properties.inNumbersProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $NumberFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InNumbersProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.inStringsProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InStringsProperty`,
                  ),
                  predicate:
                    InPropertiesClass.$properties.inStringsProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [parameters?.preferredLanguages ?? []]
                .filter((languages) => languages.length > 0)
                .map((languages) =>
                  languages.map((language) => ({
                    type: "operation" as const,
                    operator: "=",
                    args: [
                      {
                        type: "operation" as const,
                        operator: "lang",
                        args: [
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InStringsProperty`,
                          ),
                        ],
                      },
                      dataFactory.literal(language),
                    ],
                  })),
                )
                .map((langEqualsExpressions) => ({
                  type: "filter" as const,
                  expression: langEqualsExpressions.reduce(
                    (reducedExpression, langEqualsExpression) => {
                      if (reducedExpression === null) {
                        return langEqualsExpression;
                      }
                      return {
                        type: "operation" as const,
                        operator: "||",
                        args: [reducedExpression, langEqualsExpression],
                      };
                    },
                    null as sparqljs.Expression | null,
                  ) as sparqljs.Expression,
                }))
                .concat(),
              type: "group",
            },
            {
              patterns: $StringFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inPropertiesClass")}InStringsProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    return patterns;
  }
}
/**
 * Shape with sh:in constraining its identifier.
 */
export class InIdentifierClass {
  readonly $identifier: InIdentifierClass.$Identifier;
  readonly $type = "InIdentifierClass";
  readonly inIdentifierProperty: purify.Maybe<string>;

  constructor(parameters: {
    readonly $identifier:
      | "http://example.com/InIdentifierInstance1"
      | "http://example.com/InIdentifierInstance2"
      | rdfjs.NamedNode<
          | "http://example.com/InIdentifierInstance1"
          | "http://example.com/InIdentifierInstance2"
        >;
    readonly inIdentifierProperty?: purify.Maybe<string> | string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this.$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this.$identifier = dataFactory.namedNode(parameters.$identifier);
    } else {
      this.$identifier = parameters.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.inIdentifierProperty)) {
      this.inIdentifierProperty = parameters.inIdentifierProperty;
    } else if (typeof parameters.inIdentifierProperty === "string") {
      this.inIdentifierProperty = purify.Maybe.of(
        parameters.inIdentifierProperty,
      );
    } else if (typeof parameters.inIdentifierProperty === "undefined") {
      this.inIdentifierProperty = purify.Maybe.empty();
    } else {
      this.inIdentifierProperty =
        parameters.inIdentifierProperty satisfies never;
    }
  }

  $equals(other: InIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.inIdentifierProperty,
          other.inIdentifierProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inIdentifierProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.inIdentifierProperty.ifJust((value0) => {
      _hasher.update(value0);
    });
    return _hasher;
  }

  $toJson(): InIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": this.$identifier.value,
        $type: this.$type,
        inIdentifierProperty: this.inIdentifierProperty
          .map((item) => item)
          .extract(),
      } satisfies InIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableNamedResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      InIdentifierClass.$properties.inIdentifierProperty["identifier"],
      ...this.inIdentifierProperty.toList(),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace InIdentifierClass {
  export function $filter(
    filter: InIdentifierClass.$Filter,
    value: InIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterNamedNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.inIdentifierProperty !== "undefined" &&
      !$filterMaybe<string, $StringFilter>($filterString)(
        filter.inIdentifierProperty,
        value.inIdentifierProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $NamedNodeFilter;
    readonly inIdentifierProperty?: $MaybeFilter<$StringFilter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, InIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new InIdentifierClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, InIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return InIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new InIdentifierClass(properties));
  }

  export type $Identifier = rdfjs.NamedNode<
    | "http://example.com/InIdentifierInstance1"
    | "http://example.com/InIdentifierInstance2"
  >;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<
      Error,
      rdfjs.NamedNode<
        | "http://example.com/InIdentifierInstance1"
        | "http://example.com/InIdentifierInstance2"
      >
    > {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      )
        .chain((identifier) =>
          identifier.termType === "NamedNode"
            ? purify.Either.of(identifier)
            : purify.Left(new Error("expected identifier to be NamedNode")),
        )
        .chain((identifier) => {
          switch (identifier.value) {
            case "http://example.com/InIdentifierInstance1":
              return purify.Either.of(
                identifier as rdfjs.NamedNode<"http://example.com/InIdentifierInstance1">,
              );
            case "http://example.com/InIdentifierInstance2":
              return purify.Either.of(
                identifier as rdfjs.NamedNode<"http://example.com/InIdentifierInstance2">,
              );
            default:
              return purify.Left(
                new Error(
                  "expected NamedNode identifier to be one of http://example.com/InIdentifierInstance1 http://example.com/InIdentifierInstance2",
                ),
              );
          }
        }) as purify.Either<
        Error,
        rdfjs.NamedNode<
          | "http://example.com/InIdentifierInstance1"
          | "http://example.com/InIdentifierInstance2"
        >
      >;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "InIdentifierClass";
    readonly inIdentifierProperty?: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "InIdentifierClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/inIdentifierProperty`,
          type: "Control",
        },
      ],
      label: "InIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.enum([
        "http://example.com/InIdentifierInstance1",
        "http://example.com/InIdentifierInstance2",
      ]),
      $type: zod.literal("InIdentifierClass"),
      inIdentifierProperty: zod.string().optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    inIdentifierProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/inIdentifierProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.NamedNode<
        | "http://example.com/InIdentifierInstance1"
        | "http://example.com/InIdentifierInstance2"
      >;
      inIdentifierProperty: purify.Maybe<string>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    const inIdentifierProperty = purify.Maybe.fromNullable(
      $jsonObject["inIdentifierProperty"],
    );
    return purify.Either.of({ $identifier, inIdentifierProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.NamedNode<
        | "http://example.com/InIdentifierInstance1"
        | "http://example.com/InIdentifierInstance2"
      >;
      inIdentifierProperty: purify.Maybe<string>;
    }
  > {
    let $identifier: InIdentifierClass.$Identifier;
    switch ($parameters.resource.identifier.value) {
      case "http://example.com/InIdentifierInstance1":
        $identifier = dataFactory.namedNode(
          "http://example.com/InIdentifierInstance1",
        );
        break;
      case "http://example.com/InIdentifierInstance2":
        $identifier = dataFactory.namedNode(
          "http://example.com/InIdentifierInstance2",
        );
        break;
      default:
        return purify.Left(
          new rdfjsResource.Resource.MistypedTermValueError({
            actualValue: $parameters.resource.identifier,
            expectedValueType:
              'rdfjs.NamedNode<"http://example.com/InIdentifierInstance1" | "http://example.com/InIdentifierInstance2">',
            focusResource: $parameters.resource,
            predicate: $RdfVocabularies.rdf.subject,
          }),
        );
    }

    const _inIdentifierPropertyEither: purify.Either<
      Error,
      purify.Maybe<string>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.inIdentifierProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        $fromRdfPreferredLanguages({
          focusResource: $parameters.resource,
          predicate:
            InIdentifierClass.$properties.inIdentifierProperty["identifier"],
          preferredLanguages: $parameters.preferredLanguages,
          values,
        }),
      )
      .chain((values) => values.chainMap((value) => value.toString()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<string>>({
              focusResource: $parameters.resource,
              predicate:
                InIdentifierClass.$properties.inIdentifierProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_inIdentifierPropertyEither.isLeft()) {
      return _inIdentifierPropertyEither;
    }

    const inIdentifierProperty = _inIdentifierPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, inIdentifierProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: InIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InIdentifierClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            InIdentifierClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: InIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("inIdentifierClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inIdentifierClass")}InIdentifierProperty`,
      ),
      predicate:
        InIdentifierClass.$properties.inIdentifierProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: InIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("inIdentifierClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.inIdentifierProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inIdentifierClass")}InIdentifierProperty`,
                  ),
                  predicate:
                    InIdentifierClass.$properties.inIdentifierProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [parameters?.preferredLanguages ?? []]
                .filter((languages) => languages.length > 0)
                .map((languages) =>
                  languages.map((language) => ({
                    type: "operation" as const,
                    operator: "=",
                    args: [
                      {
                        type: "operation" as const,
                        operator: "lang",
                        args: [
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inIdentifierClass")}InIdentifierProperty`,
                          ),
                        ],
                      },
                      dataFactory.literal(language),
                    ],
                  })),
                )
                .map((langEqualsExpressions) => ({
                  type: "filter" as const,
                  expression: langEqualsExpressions.reduce(
                    (reducedExpression, langEqualsExpression) => {
                      if (reducedExpression === null) {
                        return langEqualsExpression;
                      }
                      return {
                        type: "operation" as const,
                        operator: "||",
                        args: [reducedExpression, langEqualsExpression],
                      };
                    },
                    null as sparqljs.Expression | null,
                  ) as sparqljs.Expression,
                }))
                .concat(),
              type: "group",
            },
            {
              patterns: $StringFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "inIdentifierClass")}InIdentifierProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    return patterns;
  }
}
/**
 * Node shape for testing identifier type overriding: blank node or IRI identifier, abstract
 */
export abstract class IdentifierOverride1Class {
  protected _$identifier?: IdentifierOverride1ClassStatic.$Identifier;
  abstract readonly $type:
    | "IdentifierOverride3Class"
    | "IdentifierOverride4Class"
    | "IdentifierOverride5Class";
  readonly identifierOverrideProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly identifierOverrideProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.identifierOverrideProperty = parameters.identifierOverrideProperty;
  }

  get $identifier(): IdentifierOverride1ClassStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: IdentifierOverride1Class): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.identifierOverrideProperty,
          other.identifierOverrideProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "identifierOverrideProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.identifierOverrideProperty);
    return _hasher;
  }

  $toJson(): IdentifierOverride1ClassStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        identifierOverrideProperty: this.identifierOverrideProperty,
      } satisfies IdentifierOverride1ClassStatic.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      IdentifierOverride1ClassStatic.$properties.identifierOverrideProperty[
        "identifier"
      ],
      ...[this.identifierOverrideProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IdentifierOverride1ClassStatic {
  export function $filter(
    filter: IdentifierOverride1ClassStatic.$Filter,
    value: IdentifierOverride1Class,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.identifierOverrideProperty !== "undefined" &&
      !$filterString(
        filter.identifierOverrideProperty,
        value.identifierOverrideProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly identifierOverrideProperty?: $StringFilter;
  };
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type:
      | "IdentifierOverride3Class"
      | "IdentifierOverride4Class"
      | "IdentifierOverride5Class";
    readonly identifierOverrideProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "IdentifierOverride1Class" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/identifierOverrideProperty`,
          type: "Control",
        },
      ],
      label: "IdentifierOverride1Class",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.enum([
        "IdentifierOverride3Class",
        "IdentifierOverride4Class",
        "IdentifierOverride5Class",
      ]),
      identifierOverrideProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    identifierOverrideProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/identifierOverrideProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      identifierOverrideProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const identifierOverrideProperty =
      $jsonObject["identifierOverrideProperty"];
    return purify.Either.of({ $identifier, identifierOverrideProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      identifierOverrideProperty: string;
    }
  > {
    const $identifier: IdentifierOverride1ClassStatic.$Identifier =
      $parameters.resource.identifier;
    const _identifierOverridePropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.identifierOverrideProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              IdentifierOverride1ClassStatic.$properties
                .identifierOverrideProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_identifierOverridePropertyEither.isLeft()) {
      return _identifierOverridePropertyEither;
    }

    const identifierOverrideProperty =
      _identifierOverridePropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, identifierOverrideProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IdentifierOverride1ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IdentifierOverride1ClassStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            IdentifierOverride1ClassStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IdentifierOverride1ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IdentifierOverride1ClassStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride1Class");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride1Class")}IdentifierOverrideProperty`,
      ),
      predicate:
        IdentifierOverride1ClassStatic.$properties.identifierOverrideProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IdentifierOverride1ClassStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride1Class");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride1Class")}IdentifierOverrideProperty`,
            ),
            predicate:
              IdentifierOverride1ClassStatic.$properties
                .identifierOverrideProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride1Class")}IdentifierOverrideProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.identifierOverrideProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride1Class")}IdentifierOverrideProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
/**
 * Node shape for testing identifier type overriding: blank node or IRI identifier, abstract
 */
export abstract class IdentifierOverride2Class extends IdentifierOverride1Class {
  abstract override readonly $type:
    | "IdentifierOverride3Class"
    | "IdentifierOverride4Class"
    | "IdentifierOverride5Class";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: ConstructorParameters<typeof IdentifierOverride1Class>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): IdentifierOverride2ClassStatic.$Identifier {
    const identifier = super.$identifier;
    if (identifier.termType !== "NamedNode") {
      throw new Error(
        `expected identifier to be NamedNode, not ${identifier.termType}`,
      );
    }

    return identifier;
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IdentifierOverride2ClassStatic {
  export function $filter(
    filter: IdentifierOverride2ClassStatic.$Filter,
    value: IdentifierOverride2Class,
  ): boolean {
    if (!IdentifierOverride1ClassStatic.$filter(filter, value)) {
      return false;
    }

    return true;
  }

  export type $Filter = IdentifierOverride1ClassStatic.$Filter;
  export type $Identifier = rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.NamedNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ).chain((identifier) =>
        identifier.termType === "NamedNode"
          ? purify.Either.of(identifier)
          : purify.Left(new Error("expected identifier to be NamedNode")),
      ) as purify.Either<Error, rdfjs.NamedNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = IdentifierOverride1ClassStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [IdentifierOverride1ClassStatic.$jsonUiSchema({ scopePrefix })],
      label: "IdentifierOverride2Class",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IdentifierOverride1ClassStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "IdentifierOverride3Class",
          "IdentifierOverride4Class",
          "IdentifierOverride5Class",
        ]),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = { ...IdentifierOverride1ClassStatic.$properties };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride1ClassStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      IdentifierOverride1ClassStatic.$propertiesFromJson($jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride1ClassStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = IdentifierOverride1ClassStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if ($parameters.resource.identifier.termType !== "NamedNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedTermValueError({
          actualValue: $parameters.resource.identifier,
          expectedValueType: "(rdfjs.NamedNode)",
          focusResource: $parameters.resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: IdentifierOverride2ClassStatic.$Identifier =
      $parameters.resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IdentifierOverride2ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IdentifierOverride2ClassStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            IdentifierOverride2ClassStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IdentifierOverride2ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IdentifierOverride2ClassStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride2Class");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...IdentifierOverride1ClassStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride2Class"),
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IdentifierOverride2ClassStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride2Class");
    patterns.push(
      ...IdentifierOverride1ClassStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride2Class"),
      }),
    );
    return patterns;
  }

  export function isIdentifierOverride2Class(
    object: IdentifierOverride1Class,
  ): object is IdentifierOverride2Class {
    switch (object.$type) {
      case "IdentifierOverride3Class":
      case "IdentifierOverride4Class":
      case "IdentifierOverride5Class":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape for testing identifier type overriding: IRI identifier, concrete
 */
export class IdentifierOverride3Class extends IdentifierOverride2Class {
  override readonly $type:
    | "IdentifierOverride3Class"
    | "IdentifierOverride4Class"
    | "IdentifierOverride5Class" = "IdentifierOverride3Class";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof IdentifierOverride2Class>[0],
  ) {
    super(parameters);
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/IdentifierOverride3Class",
        ),
      );
    }

    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IdentifierOverride3ClassStatic {
  export function $filter(
    filter: IdentifierOverride3ClassStatic.$Filter,
    value: IdentifierOverride3Class,
  ): boolean {
    if (!IdentifierOverride2ClassStatic.$filter(filter, value)) {
      return false;
    }

    return true;
  }

  export type $Filter = IdentifierOverride2ClassStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, IdentifierOverride3Class> {
    return $propertiesFromJson(json).map(
      (properties) => new IdentifierOverride3Class(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, IdentifierOverride3Class> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return IdentifierOverride3ClassStatic.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new IdentifierOverride3Class(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/IdentifierOverride3Class",
  );
  export type $Identifier = IdentifierOverride2ClassStatic.$Identifier;
  export const $Identifier = IdentifierOverride2ClassStatic.$Identifier;
  export type $Json = IdentifierOverride2ClassStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [IdentifierOverride2ClassStatic.$jsonUiSchema({ scopePrefix })],
      label: "IdentifierOverride3Class",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IdentifierOverride2ClassStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "IdentifierOverride3Class",
          "IdentifierOverride4Class",
          "IdentifierOverride5Class",
        ]),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = { ...IdentifierOverride2ClassStatic.$properties };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride2ClassStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      IdentifierOverride2ClassStatic.$propertiesFromJson($jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride2ClassStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = IdentifierOverride2ClassStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/IdentifierOverride3Class":
            case "http://example.com/IdentifierOverride4Class":
            case "http://example.com/IdentifierOverride5Class":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              IdentifierOverride3ClassStatic.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/IdentifierOverride3Class)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    if ($parameters.resource.identifier.termType !== "NamedNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedTermValueError({
          actualValue: $parameters.resource.identifier,
          expectedValueType: "(rdfjs.NamedNode)",
          focusResource: $parameters.resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: IdentifierOverride3ClassStatic.$Identifier =
      $parameters.resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IdentifierOverride3ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IdentifierOverride3ClassStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            IdentifierOverride3ClassStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IdentifierOverride3ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IdentifierOverride3ClassStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride3Class");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...IdentifierOverride2ClassStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride3Class"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride3Class")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride3Class")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride3Class")}RdfClass`,
          ),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IdentifierOverride3ClassStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride3Class");
    patterns.push(
      ...IdentifierOverride2ClassStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride3Class"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride3Class")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        {
          type: "values" as const,
          values: [
            IdentifierOverride3ClassStatic.$fromRdfType,
            IdentifierOverride4ClassStatic.$fromRdfType,
            IdentifierOverride5Class.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[
              `?${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride3Class")}FromRdfType`
            ] = identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride3Class")}FromRdfType`,
          ),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride3Class")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    return patterns;
  }

  export function isIdentifierOverride3Class(
    object: IdentifierOverride1Class,
  ): object is IdentifierOverride3Class {
    switch (object.$type) {
      case "IdentifierOverride4Class":
      case "IdentifierOverride5Class":
      case "IdentifierOverride3Class":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape for testing identifier type overriding: IRI identifier, concrete, UUIDv4 minting
 */
export class IdentifierOverride4Class extends IdentifierOverride3Class {
  protected readonly _$identifierPrefix?: string;
  override readonly $type:
    | "IdentifierOverride4Class"
    | "IdentifierOverride5Class" = "IdentifierOverride4Class";

  constructor(
    parameters: {
      readonly $identifier?: rdfjs.NamedNode | string;
      readonly $identifierPrefix?: string;
    } & ConstructorParameters<typeof IdentifierOverride3Class>[0],
  ) {
    super(parameters);
    this._$identifierPrefix = parameters.$identifierPrefix;
  }

  override get $identifier(): IdentifierOverride4ClassStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${uuid.v4()}`,
      );
    }

    if (this._$identifier.termType !== "NamedNode") {
      throw new Error(
        `expected identifier to be NamedNode, not ${this._$identifier.termType}`,
      );
    }

    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/IdentifierOverride4Class",
        ),
      );
    }

    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IdentifierOverride4ClassStatic {
  export function $filter(
    filter: IdentifierOverride4ClassStatic.$Filter,
    value: IdentifierOverride4Class,
  ): boolean {
    if (!IdentifierOverride3ClassStatic.$filter(filter, value)) {
      return false;
    }

    return true;
  }

  export type $Filter = IdentifierOverride3ClassStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, IdentifierOverride4Class> {
    return $propertiesFromJson(json).map(
      (properties) => new IdentifierOverride4Class(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, IdentifierOverride4Class> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return IdentifierOverride4ClassStatic.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new IdentifierOverride4Class(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/IdentifierOverride4Class",
  );
  export type $Identifier = IdentifierOverride3ClassStatic.$Identifier;
  export const $Identifier = IdentifierOverride3ClassStatic.$Identifier;
  export type $Json = IdentifierOverride3ClassStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [IdentifierOverride3ClassStatic.$jsonUiSchema({ scopePrefix })],
      label: "IdentifierOverride4Class",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IdentifierOverride3ClassStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "IdentifierOverride4Class",
          "IdentifierOverride5Class",
        ]),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = { ...IdentifierOverride3ClassStatic.$properties };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride3ClassStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      IdentifierOverride3ClassStatic.$propertiesFromJson($jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride3ClassStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = IdentifierOverride3ClassStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/IdentifierOverride4Class":
            case "http://example.com/IdentifierOverride5Class":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              IdentifierOverride4ClassStatic.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/IdentifierOverride4Class)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    if ($parameters.resource.identifier.termType !== "NamedNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedTermValueError({
          actualValue: $parameters.resource.identifier,
          expectedValueType: "(rdfjs.NamedNode)",
          focusResource: $parameters.resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: IdentifierOverride4ClassStatic.$Identifier =
      $parameters.resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IdentifierOverride4ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IdentifierOverride4ClassStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            IdentifierOverride4ClassStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IdentifierOverride4ClassStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IdentifierOverride4ClassStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride4Class");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...IdentifierOverride3ClassStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride4Class"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride4Class")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride4Class")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride4Class")}RdfClass`,
          ),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IdentifierOverride4ClassStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride4Class");
    patterns.push(
      ...IdentifierOverride3ClassStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride4Class"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride4Class")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        {
          type: "values" as const,
          values: [
            IdentifierOverride4ClassStatic.$fromRdfType,
            IdentifierOverride5Class.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[
              `?${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride4Class")}FromRdfType`
            ] = identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride4Class")}FromRdfType`,
          ),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride4Class")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    return patterns;
  }

  export function isIdentifierOverride4Class(
    object: IdentifierOverride1Class,
  ): object is IdentifierOverride4Class {
    switch (object.$type) {
      case "IdentifierOverride5Class":
      case "IdentifierOverride4Class":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape for testing identifier type overriding: IRI identifier, concrete, SHA-256 minting
 */
export class IdentifierOverride5Class extends IdentifierOverride4Class {
  override readonly $type = "IdentifierOverride5Class";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: rdfjs.NamedNode | string;
      readonly $identifierPrefix?: string;
    } & ConstructorParameters<typeof IdentifierOverride4Class>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): IdentifierOverride5Class.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }

    if (this._$identifier.termType !== "NamedNode") {
      throw new Error(
        `expected identifier to be NamedNode, not ${this._$identifier.termType}`,
      );
    }

    return this._$identifier;
  }

  protected override get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/IdentifierOverride5Class",
        ),
      );
    }

    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IdentifierOverride5Class {
  export function $filter(
    filter: IdentifierOverride5Class.$Filter,
    value: IdentifierOverride5Class,
  ): boolean {
    if (!IdentifierOverride4ClassStatic.$filter(filter, value)) {
      return false;
    }

    return true;
  }

  export type $Filter = IdentifierOverride4ClassStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, IdentifierOverride5Class> {
    return $propertiesFromJson(json).map(
      (properties) => new IdentifierOverride5Class(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, IdentifierOverride5Class> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return IdentifierOverride5Class.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new IdentifierOverride5Class(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/IdentifierOverride5Class",
  );
  export type $Identifier = IdentifierOverride4ClassStatic.$Identifier;
  export const $Identifier = IdentifierOverride4ClassStatic.$Identifier;
  export type $Json = IdentifierOverride4ClassStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [IdentifierOverride4ClassStatic.$jsonUiSchema({ scopePrefix })],
      label: "IdentifierOverride5Class",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IdentifierOverride4ClassStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("IdentifierOverride5Class"),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = { ...IdentifierOverride4ClassStatic.$properties };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride4ClassStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      IdentifierOverride4ClassStatic.$propertiesFromJson($jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = dataFactory.namedNode($jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IdentifierOverride4ClassStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = IdentifierOverride4ClassStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/IdentifierOverride5Class":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              IdentifierOverride5Class.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/IdentifierOverride5Class)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    if ($parameters.resource.identifier.termType !== "NamedNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedTermValueError({
          actualValue: $parameters.resource.identifier,
          expectedValueType: "(rdfjs.NamedNode)",
          focusResource: $parameters.resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: IdentifierOverride5Class.$Identifier =
      $parameters.resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: IdentifierOverride5Class.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IdentifierOverride5Class.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            IdentifierOverride5Class.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: IdentifierOverride5Class.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IdentifierOverride5Class.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride5Class");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...IdentifierOverride4ClassStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride5Class"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride5Class")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride5Class")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride5Class")}RdfClass`,
          ),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: IdentifierOverride5Class.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("identifierOverride5Class");
    patterns.push(
      ...IdentifierOverride4ClassStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "identifierOverride5Class"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride5Class")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: IdentifierOverride5Class.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "identifierOverride5Class")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    return patterns;
  }

  export function isIdentifierOverride5Class(
    object: IdentifierOverride1Class,
  ): object is IdentifierOverride5Class {
    switch (object.$type) {
      case "IdentifierOverride5Class":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Shape with sh:hasValue properties.
 */
export class HasValuePropertiesClass {
  private _$identifier?: HasValuePropertiesClass.$Identifier;
  readonly $type = "HasValuePropertiesClass";
  readonly hasIriValueProperty: rdfjs.NamedNode;
  readonly hasLiteralValueProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly hasIriValueProperty: rdfjs.NamedNode | string;
    readonly hasLiteralValueProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    if (typeof parameters.hasIriValueProperty === "object") {
      this.hasIriValueProperty = parameters.hasIriValueProperty;
    } else if (typeof parameters.hasIriValueProperty === "string") {
      this.hasIriValueProperty = dataFactory.namedNode(
        parameters.hasIriValueProperty,
      );
    } else {
      this.hasIriValueProperty = parameters.hasIriValueProperty satisfies never;
    }

    this.hasLiteralValueProperty = parameters.hasLiteralValueProperty;
  }

  get $identifier(): HasValuePropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: HasValuePropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $booleanEquals(
          this.hasIriValueProperty,
          other.hasIriValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "hasIriValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.hasLiteralValueProperty,
          other.hasLiteralValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "hasLiteralValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.hasIriValueProperty.termType);
    _hasher.update(this.hasIriValueProperty.value);
    _hasher.update(this.hasLiteralValueProperty);
    return _hasher;
  }

  $toJson(): HasValuePropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        hasIriValueProperty: { "@id": this.hasIriValueProperty.value },
        hasLiteralValueProperty: this.hasLiteralValueProperty,
      } satisfies HasValuePropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      HasValuePropertiesClass.$properties.hasIriValueProperty["identifier"],
      ...[this.hasIriValueProperty],
    );
    resource.add(
      HasValuePropertiesClass.$properties.hasLiteralValueProperty["identifier"],
      ...[this.hasLiteralValueProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace HasValuePropertiesClass {
  export function $filter(
    filter: HasValuePropertiesClass.$Filter,
    value: HasValuePropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.hasIriValueProperty !== "undefined" &&
      !$filterNamedNode(filter.hasIriValueProperty, value.hasIriValueProperty)
    ) {
      return false;
    }

    if (
      typeof filter.hasLiteralValueProperty !== "undefined" &&
      !$filterString(
        filter.hasLiteralValueProperty,
        value.hasLiteralValueProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly hasIriValueProperty?: $NamedNodeFilter;
    readonly hasLiteralValueProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, HasValuePropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new HasValuePropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, HasValuePropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return HasValuePropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new HasValuePropertiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "HasValuePropertiesClass";
    readonly hasIriValueProperty: { readonly "@id": string };
    readonly hasLiteralValueProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "HasValuePropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/hasIriValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/hasLiteralValueProperty`,
          type: "Control",
        },
      ],
      label: "HasValuePropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("HasValuePropertiesClass"),
      hasIriValueProperty: zod.object({ "@id": zod.string().min(1) }),
      hasLiteralValueProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    hasIriValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/hasIriValueProperty",
      ),
    },
    hasLiteralValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/hasLiteralValueProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      hasIriValueProperty: rdfjs.NamedNode;
      hasLiteralValueProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const hasIriValueProperty = dataFactory.namedNode(
      $jsonObject["hasIriValueProperty"]["@id"],
    );
    const hasLiteralValueProperty = $jsonObject["hasLiteralValueProperty"];
    return purify.Either.of({
      $identifier,
      hasIriValueProperty,
      hasLiteralValueProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      hasIriValueProperty: rdfjs.NamedNode;
      hasLiteralValueProperty: string;
    }
  > {
    const $identifier: HasValuePropertiesClass.$Identifier =
      $parameters.resource.identifier;
    const _hasIriValuePropertyEither: purify.Either<Error, rdfjs.NamedNode> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.hasIriValueProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          for (const hasValue of [
            dataFactory.namedNode(
              "http://example.com/HasValuePropertiesClassIri1",
            ),
          ]) {
            const findResult = values.find((value) =>
              value.toTerm().equals(hasValue),
            );
            if (findResult.isLeft()) {
              return findResult;
            }
          }
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(values);
        })
        .chain((values) => values.chainMap((value) => value.toIri()))
        .chain((values) => values.head());
    if (_hasIriValuePropertyEither.isLeft()) {
      return _hasIriValuePropertyEither;
    }

    const hasIriValueProperty = _hasIriValuePropertyEither.unsafeCoerce();
    const _hasLiteralValuePropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.hasLiteralValueProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => {
          for (const hasValue of [dataFactory.literal("test")]) {
            const findResult = values.find((value) =>
              value.toTerm().equals(hasValue),
            );
            if (findResult.isLeft()) {
              return findResult;
            }
          }
          return purify.Either.of<
            Error,
            rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
          >(values);
        })
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              HasValuePropertiesClass.$properties.hasLiteralValueProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_hasLiteralValuePropertyEither.isLeft()) {
      return _hasLiteralValuePropertyEither;
    }

    const hasLiteralValueProperty =
      _hasLiteralValuePropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      hasIriValueProperty,
      hasLiteralValueProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: HasValuePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        HasValuePropertiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            HasValuePropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: HasValuePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      HasValuePropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("hasValuePropertiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "hasValuePropertiesClass")}HasIriValueProperty`,
      ),
      predicate:
        HasValuePropertiesClass.$properties.hasIriValueProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "hasValuePropertiesClass")}HasLiteralValueProperty`,
      ),
      predicate:
        HasValuePropertiesClass.$properties.hasLiteralValueProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: HasValuePropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("hasValuePropertiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "hasValuePropertiesClass")}HasIriValueProperty`,
            ),
            predicate:
              HasValuePropertiesClass.$properties.hasIriValueProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(
            parameters?.filter?.hasIriValueProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "hasValuePropertiesClass")}HasIriValueProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "hasValuePropertiesClass")}HasLiteralValueProperty`,
            ),
            predicate:
              HasValuePropertiesClass.$properties.hasLiteralValueProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "hasValuePropertiesClass")}HasLiteralValueProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.hasLiteralValueProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "hasValuePropertiesClass")}HasLiteralValueProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
export class FlattenClassUnionMember3 {
  private _$identifier?: FlattenClassUnionMember3.$Identifier;
  readonly $type = "FlattenClassUnionMember3";
  readonly flattenClassUnionMember3Property: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly flattenClassUnionMember3Property: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.flattenClassUnionMember3Property =
      parameters.flattenClassUnionMember3Property;
  }

  get $identifier(): FlattenClassUnionMember3.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: FlattenClassUnionMember3): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.flattenClassUnionMember3Property,
          other.flattenClassUnionMember3Property,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "flattenClassUnionMember3Property",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.flattenClassUnionMember3Property);
    return _hasher;
  }

  $toJson(): FlattenClassUnionMember3.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        flattenClassUnionMember3Property: this.flattenClassUnionMember3Property,
      } satisfies FlattenClassUnionMember3.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/FlattenClassUnionMember3",
        ),
      );
    }

    resource.add(
      FlattenClassUnionMember3.$properties.flattenClassUnionMember3Property[
        "identifier"
      ],
      ...[this.flattenClassUnionMember3Property],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace FlattenClassUnionMember3 {
  export function $filter(
    filter: FlattenClassUnionMember3.$Filter,
    value: FlattenClassUnionMember3,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.flattenClassUnionMember3Property !== "undefined" &&
      !$filterString(
        filter.flattenClassUnionMember3Property,
        value.flattenClassUnionMember3Property,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly flattenClassUnionMember3Property?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, FlattenClassUnionMember3> {
    return $propertiesFromJson(json).map(
      (properties) => new FlattenClassUnionMember3(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, FlattenClassUnionMember3> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return FlattenClassUnionMember3.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new FlattenClassUnionMember3(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/FlattenClassUnionMember3",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "FlattenClassUnionMember3";
    readonly flattenClassUnionMember3Property: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "FlattenClassUnionMember3" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/flattenClassUnionMember3Property`,
          type: "Control",
        },
      ],
      label: "FlattenClassUnionMember3",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("FlattenClassUnionMember3"),
      flattenClassUnionMember3Property: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    flattenClassUnionMember3Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/flattenClassUnionMember3Property",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      flattenClassUnionMember3Property: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const flattenClassUnionMember3Property =
      $jsonObject["flattenClassUnionMember3Property"];
    return purify.Either.of({ $identifier, flattenClassUnionMember3Property });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      flattenClassUnionMember3Property: string;
    }
  > {
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/FlattenClassUnionMember3":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              FlattenClassUnionMember3.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/FlattenClassUnionMember3)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: FlattenClassUnionMember3.$Identifier =
      $parameters.resource.identifier;
    const _flattenClassUnionMember3PropertyEither: purify.Either<
      Error,
      string
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.flattenClassUnionMember3Property["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        $fromRdfPreferredLanguages({
          focusResource: $parameters.resource,
          predicate:
            FlattenClassUnionMember3.$properties
              .flattenClassUnionMember3Property["identifier"],
          preferredLanguages: $parameters.preferredLanguages,
          values,
        }),
      )
      .chain((values) => values.chainMap((value) => value.toString()))
      .chain((values) => values.head());
    if (_flattenClassUnionMember3PropertyEither.isLeft()) {
      return _flattenClassUnionMember3PropertyEither;
    }

    const flattenClassUnionMember3Property =
      _flattenClassUnionMember3PropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, flattenClassUnionMember3Property });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: FlattenClassUnionMember3.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        FlattenClassUnionMember3.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            FlattenClassUnionMember3.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: FlattenClassUnionMember3.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      FlattenClassUnionMember3.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("flattenClassUnionMember3");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "flattenClassUnionMember3")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "flattenClassUnionMember3")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "flattenClassUnionMember3")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "flattenClassUnionMember3")}FlattenClassUnionMember3Property`,
      ),
      predicate:
        FlattenClassUnionMember3.$properties.flattenClassUnionMember3Property[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: FlattenClassUnionMember3.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("flattenClassUnionMember3");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "flattenClassUnionMember3")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: FlattenClassUnionMember3.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "flattenClassUnionMember3")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "flattenClassUnionMember3")}FlattenClassUnionMember3Property`,
            ),
            predicate:
              FlattenClassUnionMember3.$properties
                .flattenClassUnionMember3Property["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "flattenClassUnionMember3")}FlattenClassUnionMember3Property`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.flattenClassUnionMember3Property,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "flattenClassUnionMember3")}FlattenClassUnionMember3Property`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
/**
 * Node shape that references the ExternClass in a property.
 */
export class ExternClassPropertyClass {
  private _$identifier?: ExternClassPropertyClass.$Identifier;
  readonly $type = "ExternClassPropertyClass";
  readonly externClassProperty: purify.Maybe<ExternClass>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly externClassProperty?: ExternClass | purify.Maybe<ExternClass>;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.externClassProperty)) {
      this.externClassProperty = parameters?.externClassProperty;
    } else if (
      typeof parameters?.externClassProperty === "object" &&
      parameters?.externClassProperty instanceof ExternClass
    ) {
      this.externClassProperty = purify.Maybe.of(
        parameters?.externClassProperty,
      );
    } else if (typeof parameters?.externClassProperty === "undefined") {
      this.externClassProperty = purify.Maybe.empty();
    } else {
      this.externClassProperty =
        parameters?.externClassProperty satisfies never;
    }
  }

  get $identifier(): ExternClassPropertyClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: ExternClassPropertyClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.externClassProperty,
          other.externClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "externClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.externClassProperty.ifJust((value0) => {
      value0.$hash(_hasher);
    });
    return _hasher;
  }

  $toJson(): ExternClassPropertyClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        externClassProperty: this.externClassProperty
          .map((item) => item.$toJson())
          .extract(),
      } satisfies ExternClassPropertyClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      ExternClassPropertyClass.$properties.externClassProperty["identifier"],
      ...this.externClassProperty
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ExternClassPropertyClass {
  export function $filter(
    filter: ExternClassPropertyClass.$Filter,
    value: ExternClassPropertyClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.externClassProperty !== "undefined" &&
      !$filterMaybe<ExternClass, ExternClass.$Filter>(ExternClass.$filter)(
        filter.externClassProperty,
        value.externClassProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly externClassProperty?: $MaybeFilter<ExternClass.$Filter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ExternClassPropertyClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ExternClassPropertyClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ExternClassPropertyClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ExternClassPropertyClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ExternClassPropertyClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ExternClassPropertyClass";
    readonly externClassProperty?: ExternClass.$Json;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ExternClassPropertyClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        ExternClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/externClassProperty`,
        }),
      ],
      label: "ExternClassPropertyClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("ExternClassPropertyClass"),
      externClassProperty: ExternClass.$jsonZodSchema().optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    externClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/externClassProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      externClassProperty: purify.Maybe<ExternClass>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const externClassProperty = purify.Maybe.fromNullable(
      $jsonObject["externClassProperty"],
    ).map((item) => ExternClass.$fromJson(item).unsafeCoerce());
    return purify.Either.of({ $identifier, externClassProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      externClassProperty: purify.Maybe<ExternClass>;
    }
  > {
    const $identifier: ExternClassPropertyClass.$Identifier =
      $parameters.resource.identifier;
    const _externClassPropertyEither: purify.Either<
      Error,
      purify.Maybe<ExternClass>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.externClassProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            ExternClass.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<purify.Maybe<ExternClass>>({
              focusResource: $parameters.resource,
              predicate:
                ExternClassPropertyClass.$properties.externClassProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_externClassPropertyEither.isLeft()) {
      return _externClassPropertyEither;
    }

    const externClassProperty = _externClassPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, externClassProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ExternClassPropertyClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ExternClassPropertyClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ExternClassPropertyClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ExternClassPropertyClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ExternClassPropertyClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("externClassPropertyClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "externClassPropertyClass")}ExternClassProperty`,
      ),
      predicate:
        ExternClassPropertyClass.$properties.externClassProperty["identifier"],
      subject,
    });
    triples.push(
      ...ExternClass.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "externClassPropertyClass")}ExternClassProperty`,
        ),
        variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "externClassPropertyClass")}ExternClassProperty`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ExternClassPropertyClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("externClassPropertyClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.externClassProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "externClassPropertyClass")}ExternClassProperty`,
                  ),
                  predicate:
                    ExternClassPropertyClass.$properties.externClassProperty[
                      "identifier"
                    ],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: ExternClass.$sparqlWherePatterns({
                filter: itemFilter,
                ignoreRdfType: true,
                preferredLanguages: parameters?.preferredLanguages,
                subject: dataFactory.variable!(
                  `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "externClassPropertyClass")}ExternClassProperty`,
                ),
                variablePrefix: `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "externClassPropertyClass")}ExternClassProperty`,
              }).concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    return patterns;
  }
}
/**
 * Shape with custom rdf:type's.
 *
 * The shaclmate:rdfType is expected on deserialization and added on serialization.
 */
export class ExplicitRdfTypeClass {
  private _$identifier?: ExplicitRdfTypeClass.$Identifier;
  readonly $type = "ExplicitRdfTypeClass";
  readonly explicitRdfTypeProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly explicitRdfTypeProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.explicitRdfTypeProperty = parameters.explicitRdfTypeProperty;
  }

  get $identifier(): ExplicitRdfTypeClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: ExplicitRdfTypeClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.explicitRdfTypeProperty,
          other.explicitRdfTypeProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "explicitRdfTypeProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.explicitRdfTypeProperty);
    return _hasher;
  }

  $toJson(): ExplicitRdfTypeClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        explicitRdfTypeProperty: this.explicitRdfTypeProperty,
      } satisfies ExplicitRdfTypeClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode("http://example.com/RdfType"),
      );
    }

    resource.add(
      ExplicitRdfTypeClass.$properties.explicitRdfTypeProperty["identifier"],
      ...[this.explicitRdfTypeProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ExplicitRdfTypeClass {
  export function $filter(
    filter: ExplicitRdfTypeClass.$Filter,
    value: ExplicitRdfTypeClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.explicitRdfTypeProperty !== "undefined" &&
      !$filterString(
        filter.explicitRdfTypeProperty,
        value.explicitRdfTypeProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly explicitRdfTypeProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ExplicitRdfTypeClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ExplicitRdfTypeClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ExplicitRdfTypeClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ExplicitRdfTypeClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ExplicitRdfTypeClass(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/RdfType",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ExplicitRdfTypeClass";
    readonly explicitRdfTypeProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ExplicitRdfTypeClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/explicitRdfTypeProperty`,
          type: "Control",
        },
      ],
      label: "ExplicitRdfTypeClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("ExplicitRdfTypeClass"),
      explicitRdfTypeProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    explicitRdfTypeProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/explicitRdfTypeProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      explicitRdfTypeProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const explicitRdfTypeProperty = $jsonObject["explicitRdfTypeProperty"];
    return purify.Either.of({ $identifier, explicitRdfTypeProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      explicitRdfTypeProperty: string;
    }
  > {
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/RdfType":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(ExplicitRdfTypeClass.$fromRdfType)
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/RdfType)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: ExplicitRdfTypeClass.$Identifier =
      $parameters.resource.identifier;
    const _explicitRdfTypePropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.explicitRdfTypeProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              ExplicitRdfTypeClass.$properties.explicitRdfTypeProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_explicitRdfTypePropertyEither.isLeft()) {
      return _explicitRdfTypePropertyEither;
    }

    const explicitRdfTypeProperty =
      _explicitRdfTypePropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, explicitRdfTypeProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ExplicitRdfTypeClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ExplicitRdfTypeClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ExplicitRdfTypeClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ExplicitRdfTypeClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ExplicitRdfTypeClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("explicitRdfTypeClass");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitRdfTypeClass")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitRdfTypeClass")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitRdfTypeClass")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitRdfTypeClass")}ExplicitRdfTypeProperty`,
      ),
      predicate:
        ExplicitRdfTypeClass.$properties.explicitRdfTypeProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ExplicitRdfTypeClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("explicitRdfTypeClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitRdfTypeClass")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ExplicitRdfTypeClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitRdfTypeClass")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitRdfTypeClass")}ExplicitRdfTypeProperty`,
            ),
            predicate:
              ExplicitRdfTypeClass.$properties.explicitRdfTypeProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitRdfTypeClass")}ExplicitRdfTypeProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.explicitRdfTypeProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitRdfTypeClass")}ExplicitRdfTypeProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
/**
 * Shape with custom rdf:type's.
 *
 * The shaclmate:fromRdfType is expected on deserialization.
 * shaclmate:toRdfType's are added an serialization.
 */
export class ExplicitFromToRdfTypesClass {
  private _$identifier?: ExplicitFromToRdfTypesClass.$Identifier;
  readonly $type = "ExplicitFromToRdfTypesClass";
  readonly explicitFromToRdfTypesProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly explicitFromToRdfTypesProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.explicitFromToRdfTypesProperty =
      parameters.explicitFromToRdfTypesProperty;
  }

  get $identifier(): ExplicitFromToRdfTypesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: ExplicitFromToRdfTypesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.explicitFromToRdfTypesProperty,
          other.explicitFromToRdfTypesProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "explicitFromToRdfTypesProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.explicitFromToRdfTypesProperty);
    return _hasher;
  }

  $toJson(): ExplicitFromToRdfTypesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        explicitFromToRdfTypesProperty: this.explicitFromToRdfTypesProperty,
      } satisfies ExplicitFromToRdfTypesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode("http://example.com/ToRdfType"),
      );
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode("http://example.com/FromRdfType"),
      );
    }

    resource.add(
      ExplicitFromToRdfTypesClass.$properties.explicitFromToRdfTypesProperty[
        "identifier"
      ],
      ...[this.explicitFromToRdfTypesProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ExplicitFromToRdfTypesClass {
  export function $filter(
    filter: ExplicitFromToRdfTypesClass.$Filter,
    value: ExplicitFromToRdfTypesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.explicitFromToRdfTypesProperty !== "undefined" &&
      !$filterString(
        filter.explicitFromToRdfTypesProperty,
        value.explicitFromToRdfTypesProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly explicitFromToRdfTypesProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ExplicitFromToRdfTypesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ExplicitFromToRdfTypesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ExplicitFromToRdfTypesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ExplicitFromToRdfTypesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ExplicitFromToRdfTypesClass(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/FromRdfType",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ExplicitFromToRdfTypesClass";
    readonly explicitFromToRdfTypesProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ExplicitFromToRdfTypesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/explicitFromToRdfTypesProperty`,
          type: "Control",
        },
      ],
      label: "ExplicitFromToRdfTypesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("ExplicitFromToRdfTypesClass"),
      explicitFromToRdfTypesProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    explicitFromToRdfTypesProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/explicitFromToRdfTypesProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      explicitFromToRdfTypesProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const explicitFromToRdfTypesProperty =
      $jsonObject["explicitFromToRdfTypesProperty"];
    return purify.Either.of({ $identifier, explicitFromToRdfTypesProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      explicitFromToRdfTypesProperty: string;
    }
  > {
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/FromRdfType":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              ExplicitFromToRdfTypesClass.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/FromRdfType)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: ExplicitFromToRdfTypesClass.$Identifier =
      $parameters.resource.identifier;
    const _explicitFromToRdfTypesPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.explicitFromToRdfTypesProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              ExplicitFromToRdfTypesClass.$properties
                .explicitFromToRdfTypesProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_explicitFromToRdfTypesPropertyEither.isLeft()) {
      return _explicitFromToRdfTypesPropertyEither;
    }

    const explicitFromToRdfTypesProperty =
      _explicitFromToRdfTypesPropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, explicitFromToRdfTypesProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ExplicitFromToRdfTypesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ExplicitFromToRdfTypesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ExplicitFromToRdfTypesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ExplicitFromToRdfTypesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ExplicitFromToRdfTypesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("explicitFromToRdfTypesClass");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitFromToRdfTypesClass")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitFromToRdfTypesClass")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitFromToRdfTypesClass")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitFromToRdfTypesClass")}ExplicitFromToRdfTypesProperty`,
      ),
      predicate:
        ExplicitFromToRdfTypesClass.$properties.explicitFromToRdfTypesProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ExplicitFromToRdfTypesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("explicitFromToRdfTypesClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitFromToRdfTypesClass")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ExplicitFromToRdfTypesClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitFromToRdfTypesClass")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitFromToRdfTypesClass")}ExplicitFromToRdfTypesProperty`,
            ),
            predicate:
              ExplicitFromToRdfTypesClass.$properties
                .explicitFromToRdfTypesProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitFromToRdfTypesClass")}ExplicitFromToRdfTypesProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.explicitFromToRdfTypesProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "explicitFromToRdfTypesClass")}ExplicitFromToRdfTypesProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
export class DirectRecursiveClass {
  private _$identifier?: DirectRecursiveClass.$Identifier;
  readonly $type = "DirectRecursiveClass";
  readonly directRecursiveProperty: purify.Maybe<DirectRecursiveClass>;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly directRecursiveProperty?:
      | DirectRecursiveClass
      | purify.Maybe<DirectRecursiveClass>;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.directRecursiveProperty)) {
      this.directRecursiveProperty = parameters?.directRecursiveProperty;
    } else if (
      typeof parameters?.directRecursiveProperty === "object" &&
      parameters?.directRecursiveProperty instanceof DirectRecursiveClass
    ) {
      this.directRecursiveProperty = purify.Maybe.of(
        parameters?.directRecursiveProperty,
      );
    } else if (typeof parameters?.directRecursiveProperty === "undefined") {
      this.directRecursiveProperty = purify.Maybe.empty();
    } else {
      this.directRecursiveProperty =
        parameters?.directRecursiveProperty satisfies never;
    }
  }

  get $identifier(): DirectRecursiveClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: DirectRecursiveClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.directRecursiveProperty,
          other.directRecursiveProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "directRecursiveProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.directRecursiveProperty.ifJust((value0) => {
      value0.$hash(_hasher);
    });
    return _hasher;
  }

  $toJson(): DirectRecursiveClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        directRecursiveProperty: this.directRecursiveProperty
          .map((item) => item.$toJson())
          .extract(),
      } satisfies DirectRecursiveClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      DirectRecursiveClass.$properties.directRecursiveProperty["identifier"],
      ...this.directRecursiveProperty
        .toList()
        .flatMap((value) => [
          value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
            .identifier,
        ]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace DirectRecursiveClass {
  export function $filter(
    filter: DirectRecursiveClass.$Filter,
    value: DirectRecursiveClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.directRecursiveProperty !== "undefined" &&
      !$filterMaybe<DirectRecursiveClass, DirectRecursiveClass.$Filter>(
        DirectRecursiveClass.$filter,
      )(filter.directRecursiveProperty, value.directRecursiveProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly directRecursiveProperty?: $MaybeFilter<DirectRecursiveClass.$Filter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, DirectRecursiveClass> {
    return $propertiesFromJson(json).map(
      (properties) => new DirectRecursiveClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, DirectRecursiveClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return DirectRecursiveClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new DirectRecursiveClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "DirectRecursiveClass";
    readonly directRecursiveProperty?: DirectRecursiveClass.$Json;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "DirectRecursiveClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        DirectRecursiveClass.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/directRecursiveProperty`,
        }),
      ],
      label: "DirectRecursiveClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("DirectRecursiveClass"),
      directRecursiveProperty: zod
        .lazy(
          (): zod.ZodType<DirectRecursiveClass.$Json> =>
            DirectRecursiveClass.$jsonZodSchema(),
        )
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    directRecursiveProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/directRecursiveProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      directRecursiveProperty: purify.Maybe<DirectRecursiveClass>;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const directRecursiveProperty = purify.Maybe.fromNullable(
      $jsonObject["directRecursiveProperty"],
    ).map((item) => DirectRecursiveClass.$fromJson(item).unsafeCoerce());
    return purify.Either.of({ $identifier, directRecursiveProperty });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      directRecursiveProperty: purify.Maybe<DirectRecursiveClass>;
    }
  > {
    const $identifier: DirectRecursiveClass.$Identifier =
      $parameters.resource.identifier;
    const _directRecursivePropertyEither: purify.Either<
      Error,
      purify.Maybe<DirectRecursiveClass>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.directRecursiveProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          value.toResource().chain((resource) =>
            DirectRecursiveClass.$fromRdf(resource, {
              context: $parameters.context,
              ignoreRdfType: true,
              objectSet: $parameters.objectSet,
              preferredLanguages: $parameters.preferredLanguages,
            }),
          ),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<DirectRecursiveClass>
            >({
              focusResource: $parameters.resource,
              predicate:
                DirectRecursiveClass.$properties.directRecursiveProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_directRecursivePropertyEither.isLeft()) {
      return _directRecursivePropertyEither;
    }

    const directRecursiveProperty =
      _directRecursivePropertyEither.unsafeCoerce();
    return purify.Either.of({ $identifier, directRecursiveProperty });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: DirectRecursiveClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        DirectRecursiveClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            DirectRecursiveClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: DirectRecursiveClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      DirectRecursiveClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: DirectRecursiveClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("directRecursiveClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }
}
/**
 * Shape with sh:defaultValue properties.
 */
export class DefaultValuePropertiesClass {
  private _$identifier?: DefaultValuePropertiesClass.$Identifier;
  protected readonly _$identifierPrefix?: string;
  readonly $type = "DefaultValuePropertiesClass";
  readonly dateDefaultValueProperty: Date;
  readonly dateTimeDefaultValueProperty: Date;
  readonly falseBooleanDefaultValueProperty: boolean;
  readonly numberDefaultValueProperty: number;
  readonly stringDefaultValueProperty: string;
  readonly trueBooleanDefaultValueProperty: boolean;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly $identifierPrefix?: string;
    readonly dateDefaultValueProperty?: Date;
    readonly dateTimeDefaultValueProperty?: Date;
    readonly falseBooleanDefaultValueProperty?: boolean;
    readonly numberDefaultValueProperty?: number;
    readonly stringDefaultValueProperty?: string;
    readonly trueBooleanDefaultValueProperty?: boolean;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    this._$identifierPrefix = parameters?.$identifierPrefix;
    if (
      typeof parameters?.dateDefaultValueProperty === "object" &&
      parameters?.dateDefaultValueProperty instanceof Date
    ) {
      this.dateDefaultValueProperty = parameters?.dateDefaultValueProperty;
    } else if (typeof parameters?.dateDefaultValueProperty === "undefined") {
      this.dateDefaultValueProperty = new Date("2018-04-09T00:00:00.000Z");
    } else {
      this.dateDefaultValueProperty =
        parameters?.dateDefaultValueProperty satisfies never;
    }

    if (
      typeof parameters?.dateTimeDefaultValueProperty === "object" &&
      parameters?.dateTimeDefaultValueProperty instanceof Date
    ) {
      this.dateTimeDefaultValueProperty =
        parameters?.dateTimeDefaultValueProperty;
    } else if (
      typeof parameters?.dateTimeDefaultValueProperty === "undefined"
    ) {
      this.dateTimeDefaultValueProperty = new Date("2018-04-09T10:00:00.000Z");
    } else {
      this.dateTimeDefaultValueProperty =
        parameters?.dateTimeDefaultValueProperty satisfies never;
    }

    if (typeof parameters?.falseBooleanDefaultValueProperty === "boolean") {
      this.falseBooleanDefaultValueProperty =
        parameters?.falseBooleanDefaultValueProperty;
    } else if (
      typeof parameters?.falseBooleanDefaultValueProperty === "undefined"
    ) {
      this.falseBooleanDefaultValueProperty = false;
    } else {
      this.falseBooleanDefaultValueProperty =
        parameters?.falseBooleanDefaultValueProperty satisfies never;
    }

    if (typeof parameters?.numberDefaultValueProperty === "number") {
      this.numberDefaultValueProperty = parameters?.numberDefaultValueProperty;
    } else if (typeof parameters?.numberDefaultValueProperty === "undefined") {
      this.numberDefaultValueProperty = 0;
    } else {
      this.numberDefaultValueProperty =
        parameters?.numberDefaultValueProperty satisfies never;
    }

    if (typeof parameters?.stringDefaultValueProperty === "string") {
      this.stringDefaultValueProperty = parameters?.stringDefaultValueProperty;
    } else if (typeof parameters?.stringDefaultValueProperty === "undefined") {
      this.stringDefaultValueProperty = "";
    } else {
      this.stringDefaultValueProperty =
        parameters?.stringDefaultValueProperty satisfies never;
    }

    if (typeof parameters?.trueBooleanDefaultValueProperty === "boolean") {
      this.trueBooleanDefaultValueProperty =
        parameters?.trueBooleanDefaultValueProperty;
    } else if (
      typeof parameters?.trueBooleanDefaultValueProperty === "undefined"
    ) {
      this.trueBooleanDefaultValueProperty = true;
    } else {
      this.trueBooleanDefaultValueProperty =
        parameters?.trueBooleanDefaultValueProperty satisfies never;
    }
  }

  get $identifier(): DefaultValuePropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }

    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  $equals(other: DefaultValuePropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$identifierPrefix, other.$identifierPrefix).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$identifierPrefix",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $dateEquals(
          this.dateDefaultValueProperty,
          other.dateDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "dateDefaultValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $dateEquals(
          this.dateTimeDefaultValueProperty,
          other.dateTimeDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "dateTimeDefaultValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.falseBooleanDefaultValueProperty,
          other.falseBooleanDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "falseBooleanDefaultValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.numberDefaultValueProperty,
          other.numberDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "numberDefaultValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.stringDefaultValueProperty,
          other.stringDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "stringDefaultValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $strictEquals(
          this.trueBooleanDefaultValueProperty,
          other.trueBooleanDefaultValueProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "trueBooleanDefaultValueProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.dateDefaultValueProperty.toISOString());
    _hasher.update(this.dateTimeDefaultValueProperty.toISOString());
    _hasher.update(this.falseBooleanDefaultValueProperty.toString());
    _hasher.update(this.numberDefaultValueProperty.toString());
    _hasher.update(this.stringDefaultValueProperty);
    _hasher.update(this.trueBooleanDefaultValueProperty.toString());
    return _hasher;
  }

  $toJson(): DefaultValuePropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        dateDefaultValueProperty: this.dateDefaultValueProperty
          .toISOString()
          .replace(/T.*$/, ""),
        dateTimeDefaultValueProperty:
          this.dateTimeDefaultValueProperty.toISOString(),
        falseBooleanDefaultValueProperty: this.falseBooleanDefaultValueProperty,
        numberDefaultValueProperty: this.numberDefaultValueProperty,
        stringDefaultValueProperty: this.stringDefaultValueProperty,
        trueBooleanDefaultValueProperty: this.trueBooleanDefaultValueProperty,
      } satisfies DefaultValuePropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      DefaultValuePropertiesClass.$properties.dateDefaultValueProperty[
        "identifier"
      ],
      ...(this.dateDefaultValueProperty.getTime() !== 1523232000000
        ? [
            dataFactory.literal(
              this.dateDefaultValueProperty.toISOString().replace(/T.*$/, ""),
              $RdfVocabularies.xsd.date,
            ),
          ]
        : []),
    );
    resource.add(
      DefaultValuePropertiesClass.$properties.dateTimeDefaultValueProperty[
        "identifier"
      ],
      ...(this.dateTimeDefaultValueProperty.getTime() !== 1523268000000
        ? [
            dataFactory.literal(
              this.dateTimeDefaultValueProperty.toISOString(),
              $RdfVocabularies.xsd.dateTime,
            ),
          ]
        : []),
    );
    resource.add(
      DefaultValuePropertiesClass.$properties.falseBooleanDefaultValueProperty[
        "identifier"
      ],
      ...(this.falseBooleanDefaultValueProperty ? [true] : []),
    );
    resource.add(
      DefaultValuePropertiesClass.$properties.numberDefaultValueProperty[
        "identifier"
      ],
      ...(this.numberDefaultValueProperty !== 0
        ? [
            dataFactory.literal(
              this.numberDefaultValueProperty.toString(10),
              $RdfVocabularies.xsd.integer,
            ),
          ]
        : []),
    );
    resource.add(
      DefaultValuePropertiesClass.$properties.stringDefaultValueProperty[
        "identifier"
      ],
      ...(this.stringDefaultValueProperty !== ""
        ? [this.stringDefaultValueProperty]
        : []),
    );
    resource.add(
      DefaultValuePropertiesClass.$properties.trueBooleanDefaultValueProperty[
        "identifier"
      ],
      ...(!this.trueBooleanDefaultValueProperty ? [false] : []),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace DefaultValuePropertiesClass {
  export function $filter(
    filter: DefaultValuePropertiesClass.$Filter,
    value: DefaultValuePropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.dateDefaultValueProperty !== "undefined" &&
      !$filterDate(
        filter.dateDefaultValueProperty,
        value.dateDefaultValueProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.dateTimeDefaultValueProperty !== "undefined" &&
      !$filterDate(
        filter.dateTimeDefaultValueProperty,
        value.dateTimeDefaultValueProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.falseBooleanDefaultValueProperty !== "undefined" &&
      !$filterBoolean(
        filter.falseBooleanDefaultValueProperty,
        value.falseBooleanDefaultValueProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.numberDefaultValueProperty !== "undefined" &&
      !$filterNumber(
        filter.numberDefaultValueProperty,
        value.numberDefaultValueProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.stringDefaultValueProperty !== "undefined" &&
      !$filterString(
        filter.stringDefaultValueProperty,
        value.stringDefaultValueProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.trueBooleanDefaultValueProperty !== "undefined" &&
      !$filterBoolean(
        filter.trueBooleanDefaultValueProperty,
        value.trueBooleanDefaultValueProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly dateDefaultValueProperty?: $DateFilter;
    readonly dateTimeDefaultValueProperty?: $DateFilter;
    readonly falseBooleanDefaultValueProperty?: $BooleanFilter;
    readonly numberDefaultValueProperty?: $NumberFilter;
    readonly stringDefaultValueProperty?: $StringFilter;
    readonly trueBooleanDefaultValueProperty?: $BooleanFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, DefaultValuePropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new DefaultValuePropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, DefaultValuePropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return DefaultValuePropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new DefaultValuePropertiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "DefaultValuePropertiesClass";
    readonly dateDefaultValueProperty: string;
    readonly dateTimeDefaultValueProperty: string;
    readonly falseBooleanDefaultValueProperty: boolean;
    readonly numberDefaultValueProperty: number;
    readonly stringDefaultValueProperty: string;
    readonly trueBooleanDefaultValueProperty: boolean;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "DefaultValuePropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateDefaultValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateTimeDefaultValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/falseBooleanDefaultValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/numberDefaultValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/stringDefaultValueProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/trueBooleanDefaultValueProperty`,
          type: "Control",
        },
      ],
      label: "DefaultValuePropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("DefaultValuePropertiesClass"),
      dateDefaultValueProperty: zod.iso.date(),
      dateTimeDefaultValueProperty: zod.iso.datetime(),
      falseBooleanDefaultValueProperty: zod.boolean(),
      numberDefaultValueProperty: zod.number(),
      stringDefaultValueProperty: zod.string(),
      trueBooleanDefaultValueProperty: zod.boolean(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    dateDefaultValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/dateDefaultValueProperty",
      ),
    },
    dateTimeDefaultValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/dateTimeDefaultValueProperty",
      ),
    },
    falseBooleanDefaultValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/falseBooleanDefaultValueProperty",
      ),
    },
    numberDefaultValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/numberDefaultValueProperty",
      ),
    },
    stringDefaultValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/stringDefaultValueProperty",
      ),
    },
    trueBooleanDefaultValueProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/trueBooleanDefaultValueProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      dateDefaultValueProperty: Date;
      dateTimeDefaultValueProperty: Date;
      falseBooleanDefaultValueProperty: boolean;
      numberDefaultValueProperty: number;
      stringDefaultValueProperty: string;
      trueBooleanDefaultValueProperty: boolean;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const dateDefaultValueProperty = new Date(
      $jsonObject["dateDefaultValueProperty"],
    );
    const dateTimeDefaultValueProperty = new Date(
      $jsonObject["dateTimeDefaultValueProperty"],
    );
    const falseBooleanDefaultValueProperty =
      $jsonObject["falseBooleanDefaultValueProperty"];
    const numberDefaultValueProperty =
      $jsonObject["numberDefaultValueProperty"];
    const stringDefaultValueProperty =
      $jsonObject["stringDefaultValueProperty"];
    const trueBooleanDefaultValueProperty =
      $jsonObject["trueBooleanDefaultValueProperty"];
    return purify.Either.of({
      $identifier,
      dateDefaultValueProperty,
      dateTimeDefaultValueProperty,
      falseBooleanDefaultValueProperty,
      numberDefaultValueProperty,
      stringDefaultValueProperty,
      trueBooleanDefaultValueProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      dateDefaultValueProperty: Date;
      dateTimeDefaultValueProperty: Date;
      falseBooleanDefaultValueProperty: boolean;
      numberDefaultValueProperty: number;
      stringDefaultValueProperty: string;
      trueBooleanDefaultValueProperty: boolean;
    }
  > {
    const $identifier: DefaultValuePropertiesClass.$Identifier =
      $parameters.resource.identifier;
    const _dateDefaultValuePropertyEither: purify.Either<Error, Date> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.dateDefaultValueProperty["identifier"],
          { unique: true },
        ),
      )
        .map((values) =>
          values.length > 0
            ? values
            : new rdfjsResource.Resource.TermValue({
                focusResource: $parameters.resource,
                predicate:
                  DefaultValuePropertiesClass.$properties
                    .dateDefaultValueProperty["identifier"],
                term: dataFactory.literal(
                  "2018-04-09",
                  $RdfVocabularies.xsd.date,
                ),
              }).toValues(),
        )
        .chain((values) => values.chainMap((value) => value.toDate()))
        .chain((values) => values.head());
    if (_dateDefaultValuePropertyEither.isLeft()) {
      return _dateDefaultValuePropertyEither;
    }

    const dateDefaultValueProperty =
      _dateDefaultValuePropertyEither.unsafeCoerce();
    const _dateTimeDefaultValuePropertyEither: purify.Either<Error, Date> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.dateTimeDefaultValueProperty["identifier"],
          { unique: true },
        ),
      )
        .map((values) =>
          values.length > 0
            ? values
            : new rdfjsResource.Resource.TermValue({
                focusResource: $parameters.resource,
                predicate:
                  DefaultValuePropertiesClass.$properties
                    .dateTimeDefaultValueProperty["identifier"],
                term: dataFactory.literal(
                  "2018-04-09T10:00:00Z",
                  $RdfVocabularies.xsd.dateTime,
                ),
              }).toValues(),
        )
        .chain((values) => values.chainMap((value) => value.toDate()))
        .chain((values) => values.head());
    if (_dateTimeDefaultValuePropertyEither.isLeft()) {
      return _dateTimeDefaultValuePropertyEither;
    }

    const dateTimeDefaultValueProperty =
      _dateTimeDefaultValuePropertyEither.unsafeCoerce();
    const _falseBooleanDefaultValuePropertyEither: purify.Either<
      Error,
      boolean
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.falseBooleanDefaultValueProperty["identifier"],
        { unique: true },
      ),
    )
      .map((values) =>
        values.length > 0
          ? values
          : new rdfjsResource.Resource.TermValue({
              focusResource: $parameters.resource,
              predicate:
                DefaultValuePropertiesClass.$properties
                  .falseBooleanDefaultValueProperty["identifier"],
              term: dataFactory.literal("false", $RdfVocabularies.xsd.boolean),
            }).toValues(),
      )
      .chain((values) => values.chainMap((value) => value.toBoolean()))
      .chain((values) => values.head());
    if (_falseBooleanDefaultValuePropertyEither.isLeft()) {
      return _falseBooleanDefaultValuePropertyEither;
    }

    const falseBooleanDefaultValueProperty =
      _falseBooleanDefaultValuePropertyEither.unsafeCoerce();
    const _numberDefaultValuePropertyEither: purify.Either<Error, number> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.numberDefaultValueProperty["identifier"],
          { unique: true },
        ),
      )
        .map((values) =>
          values.length > 0
            ? values
            : new rdfjsResource.Resource.TermValue({
                focusResource: $parameters.resource,
                predicate:
                  DefaultValuePropertiesClass.$properties
                    .numberDefaultValueProperty["identifier"],
                term: dataFactory.literal("0", $RdfVocabularies.xsd.integer),
              }).toValues(),
        )
        .chain((values) => values.chainMap((value) => value.toNumber()))
        .chain((values) => values.head());
    if (_numberDefaultValuePropertyEither.isLeft()) {
      return _numberDefaultValuePropertyEither;
    }

    const numberDefaultValueProperty =
      _numberDefaultValuePropertyEither.unsafeCoerce();
    const _stringDefaultValuePropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.stringDefaultValueProperty["identifier"],
          { unique: true },
        ),
      )
        .map((values) =>
          values.length > 0
            ? values
            : new rdfjsResource.Resource.TermValue({
                focusResource: $parameters.resource,
                predicate:
                  DefaultValuePropertiesClass.$properties
                    .stringDefaultValueProperty["identifier"],
                term: dataFactory.literal(""),
              }).toValues(),
        )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              DefaultValuePropertiesClass.$properties
                .stringDefaultValueProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_stringDefaultValuePropertyEither.isLeft()) {
      return _stringDefaultValuePropertyEither;
    }

    const stringDefaultValueProperty =
      _stringDefaultValuePropertyEither.unsafeCoerce();
    const _trueBooleanDefaultValuePropertyEither: purify.Either<
      Error,
      boolean
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.trueBooleanDefaultValueProperty["identifier"],
        { unique: true },
      ),
    )
      .map((values) =>
        values.length > 0
          ? values
          : new rdfjsResource.Resource.TermValue({
              focusResource: $parameters.resource,
              predicate:
                DefaultValuePropertiesClass.$properties
                  .trueBooleanDefaultValueProperty["identifier"],
              term: dataFactory.literal("true", $RdfVocabularies.xsd.boolean),
            }).toValues(),
      )
      .chain((values) => values.chainMap((value) => value.toBoolean()))
      .chain((values) => values.head());
    if (_trueBooleanDefaultValuePropertyEither.isLeft()) {
      return _trueBooleanDefaultValuePropertyEither;
    }

    const trueBooleanDefaultValueProperty =
      _trueBooleanDefaultValuePropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      dateDefaultValueProperty,
      dateTimeDefaultValueProperty,
      falseBooleanDefaultValueProperty,
      numberDefaultValueProperty,
      stringDefaultValueProperty,
      trueBooleanDefaultValueProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: DefaultValuePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        DefaultValuePropertiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            DefaultValuePropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: DefaultValuePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      DefaultValuePropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("defaultValuePropertiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}DateDefaultValueProperty`,
      ),
      predicate:
        DefaultValuePropertiesClass.$properties.dateDefaultValueProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}DateTimeDefaultValueProperty`,
      ),
      predicate:
        DefaultValuePropertiesClass.$properties.dateTimeDefaultValueProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}FalseBooleanDefaultValueProperty`,
      ),
      predicate:
        DefaultValuePropertiesClass.$properties
          .falseBooleanDefaultValueProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}NumberDefaultValueProperty`,
      ),
      predicate:
        DefaultValuePropertiesClass.$properties.numberDefaultValueProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}StringDefaultValueProperty`,
      ),
      predicate:
        DefaultValuePropertiesClass.$properties.stringDefaultValueProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}TrueBooleanDefaultValueProperty`,
      ),
      predicate:
        DefaultValuePropertiesClass.$properties.trueBooleanDefaultValueProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: DefaultValuePropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("defaultValuePropertiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}DateDefaultValueProperty`,
              ),
              predicate:
                DefaultValuePropertiesClass.$properties
                  .dateDefaultValueProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: $DateFilter
            .$sparqlWherePatterns(
              parameters?.filter?.dateDefaultValueProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}DateDefaultValueProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}DateTimeDefaultValueProperty`,
              ),
              predicate:
                DefaultValuePropertiesClass.$properties
                  .dateTimeDefaultValueProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: $DateFilter
            .$sparqlWherePatterns(
              parameters?.filter?.dateTimeDefaultValueProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}DateTimeDefaultValueProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}FalseBooleanDefaultValueProperty`,
              ),
              predicate:
                DefaultValuePropertiesClass.$properties
                  .falseBooleanDefaultValueProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: $BooleanFilter
            .$sparqlWherePatterns(
              parameters?.filter?.falseBooleanDefaultValueProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}FalseBooleanDefaultValueProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}NumberDefaultValueProperty`,
              ),
              predicate:
                DefaultValuePropertiesClass.$properties
                  .numberDefaultValueProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: $NumberFilter
            .$sparqlWherePatterns(
              parameters?.filter?.numberDefaultValueProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}NumberDefaultValueProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}StringDefaultValueProperty`,
              ),
              predicate:
                DefaultValuePropertiesClass.$properties
                  .stringDefaultValueProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: [parameters?.preferredLanguages ?? []]
            .filter((languages) => languages.length > 0)
            .map((languages) =>
              languages.map((language) => ({
                type: "operation" as const,
                operator: "=",
                args: [
                  {
                    type: "operation" as const,
                    operator: "lang",
                    args: [
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}StringDefaultValueProperty`,
                      ),
                    ],
                  },
                  dataFactory.literal(language),
                ],
              })),
            )
            .map((langEqualsExpressions) => ({
              type: "filter" as const,
              expression: langEqualsExpressions.reduce(
                (reducedExpression, langEqualsExpression) => {
                  if (reducedExpression === null) {
                    return langEqualsExpression;
                  }
                  return {
                    type: "operation" as const,
                    operator: "||",
                    args: [reducedExpression, langEqualsExpression],
                  };
                },
                null as sparqljs.Expression | null,
              ) as sparqljs.Expression,
            }))
            .concat(),
          type: "group",
        },
        {
          patterns: $StringFilter
            .$sparqlWherePatterns(
              parameters?.filter?.stringDefaultValueProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}StringDefaultValueProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}TrueBooleanDefaultValueProperty`,
              ),
              predicate:
                DefaultValuePropertiesClass.$properties
                  .trueBooleanDefaultValueProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: $BooleanFilter
            .$sparqlWherePatterns(
              parameters?.filter?.trueBooleanDefaultValueProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "defaultValuePropertiesClass")}TrueBooleanDefaultValueProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    return patterns;
  }
}
/**
 * Shape with sh:xone (union) properties related to dates and date-times. Unions of these and strings are common in actual models.
 */
export class DateUnionPropertiesClass {
  private _$identifier?: DateUnionPropertiesClass.$Identifier;
  readonly $type = "DateUnionPropertiesClass";
  readonly dateOrDateTimeProperty: purify.Maybe<
    { type: "date"; value: Date } | { type: "dateTime"; value: Date }
  >;
  readonly dateOrStringProperty: purify.Maybe<
    { type: "date"; value: Date } | { type: "string"; value: string }
  >;
  readonly dateTimeOrDateProperty: purify.Maybe<
    { type: "dateTime"; value: Date } | { type: "date"; value: Date }
  >;
  readonly stringOrDateProperty: purify.Maybe<
    { type: "string"; value: string } | { type: "date"; value: Date }
  >;

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly dateOrDateTimeProperty?:
      | ({ type: "date"; value: Date } | { type: "dateTime"; value: Date })
      | purify.Maybe<
          { type: "date"; value: Date } | { type: "dateTime"; value: Date }
        >;
    readonly dateOrStringProperty?:
      | ({ type: "date"; value: Date } | { type: "string"; value: string })
      | purify.Maybe<
          { type: "date"; value: Date } | { type: "string"; value: string }
        >;
    readonly dateTimeOrDateProperty?:
      | ({ type: "dateTime"; value: Date } | { type: "date"; value: Date })
      | purify.Maybe<
          { type: "dateTime"; value: Date } | { type: "date"; value: Date }
        >;
    readonly stringOrDateProperty?:
      | ({ type: "string"; value: string } | { type: "date"; value: Date })
      | purify.Maybe<
          { type: "string"; value: string } | { type: "date"; value: Date }
        >;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.dateOrDateTimeProperty)) {
      this.dateOrDateTimeProperty = parameters?.dateOrDateTimeProperty;
    } else if (typeof parameters?.dateOrDateTimeProperty === "object") {
      this.dateOrDateTimeProperty = purify.Maybe.of(
        parameters?.dateOrDateTimeProperty,
      );
    } else if (typeof parameters?.dateOrDateTimeProperty === "undefined") {
      this.dateOrDateTimeProperty = purify.Maybe.empty();
    } else {
      this.dateOrDateTimeProperty =
        parameters?.dateOrDateTimeProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.dateOrStringProperty)) {
      this.dateOrStringProperty = parameters?.dateOrStringProperty;
    } else if (typeof parameters?.dateOrStringProperty === "object") {
      this.dateOrStringProperty = purify.Maybe.of(
        parameters?.dateOrStringProperty,
      );
    } else if (typeof parameters?.dateOrStringProperty === "undefined") {
      this.dateOrStringProperty = purify.Maybe.empty();
    } else {
      this.dateOrStringProperty =
        parameters?.dateOrStringProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.dateTimeOrDateProperty)) {
      this.dateTimeOrDateProperty = parameters?.dateTimeOrDateProperty;
    } else if (typeof parameters?.dateTimeOrDateProperty === "object") {
      this.dateTimeOrDateProperty = purify.Maybe.of(
        parameters?.dateTimeOrDateProperty,
      );
    } else if (typeof parameters?.dateTimeOrDateProperty === "undefined") {
      this.dateTimeOrDateProperty = purify.Maybe.empty();
    } else {
      this.dateTimeOrDateProperty =
        parameters?.dateTimeOrDateProperty satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters?.stringOrDateProperty)) {
      this.stringOrDateProperty = parameters?.stringOrDateProperty;
    } else if (typeof parameters?.stringOrDateProperty === "object") {
      this.stringOrDateProperty = purify.Maybe.of(
        parameters?.stringOrDateProperty,
      );
    } else if (typeof parameters?.stringOrDateProperty === "undefined") {
      this.stringOrDateProperty = purify.Maybe.empty();
    } else {
      this.stringOrDateProperty =
        parameters?.stringOrDateProperty satisfies never;
    }
  }

  get $identifier(): DateUnionPropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: DateUnionPropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (
              left:
                | { type: "date"; value: Date }
                | { type: "dateTime"; value: Date },
              right:
                | { type: "date"; value: Date }
                | { type: "dateTime"; value: Date },
            ) => {
              if (left.type === "date" && right.type === "date") {
                return $dateEquals(left.value, right.value);
              }
              if (left.type === "dateTime" && right.type === "dateTime") {
                return $dateEquals(left.value, right.value);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(this.dateOrDateTimeProperty, other.dateOrDateTimeProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "dateOrDateTimeProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (
              left:
                | { type: "date"; value: Date }
                | { type: "string"; value: string },
              right:
                | { type: "date"; value: Date }
                | { type: "string"; value: string },
            ) => {
              if (left.type === "date" && right.type === "date") {
                return $dateEquals(left.value, right.value);
              }
              if (left.type === "string" && right.type === "string") {
                return $strictEquals(left.value, right.value);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(this.dateOrStringProperty, other.dateOrStringProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "dateOrStringProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (
              left:
                | { type: "dateTime"; value: Date }
                | { type: "date"; value: Date },
              right:
                | { type: "dateTime"; value: Date }
                | { type: "date"; value: Date },
            ) => {
              if (left.type === "dateTime" && right.type === "dateTime") {
                return $dateEquals(left.value, right.value);
              }
              if (left.type === "date" && right.type === "date") {
                return $dateEquals(left.value, right.value);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(this.dateTimeOrDateProperty, other.dateTimeOrDateProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "dateTimeOrDateProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (
              left:
                | { type: "string"; value: string }
                | { type: "date"; value: Date },
              right:
                | { type: "string"; value: string }
                | { type: "date"; value: Date },
            ) => {
              if (left.type === "string" && right.type === "string") {
                return $strictEquals(left.value, right.value);
              }
              if (left.type === "date" && right.type === "date") {
                return $dateEquals(left.value, right.value);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(this.stringOrDateProperty, other.stringOrDateProperty).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "stringOrDateProperty",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.dateOrDateTimeProperty.ifJust((value0) => {
      switch (value0.type) {
        case "date": {
          _hasher.update(value0.value.toISOString());
          break;
        }
        case "dateTime": {
          _hasher.update(value0.value.toISOString());
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    this.dateOrStringProperty.ifJust((value0) => {
      switch (value0.type) {
        case "date": {
          _hasher.update(value0.value.toISOString());
          break;
        }
        case "string": {
          _hasher.update(value0.value);
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    this.dateTimeOrDateProperty.ifJust((value0) => {
      switch (value0.type) {
        case "dateTime": {
          _hasher.update(value0.value.toISOString());
          break;
        }
        case "date": {
          _hasher.update(value0.value.toISOString());
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    this.stringOrDateProperty.ifJust((value0) => {
      switch (value0.type) {
        case "string": {
          _hasher.update(value0.value);
          break;
        }
        case "date": {
          _hasher.update(value0.value.toISOString());
          break;
        }
        default:
          value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    return _hasher;
  }

  $toJson(): DateUnionPropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        dateOrDateTimeProperty: this.dateOrDateTimeProperty
          .map((item) =>
            item.type === "dateTime"
              ? { type: "dateTime" as const, value: item.value.toISOString() }
              : {
                  type: "date" as const,
                  value: item.value.toISOString().replace(/T.*$/, ""),
                },
          )
          .extract(),
        dateOrStringProperty: this.dateOrStringProperty
          .map((item) =>
            item.type === "string"
              ? { type: "string" as const, value: item.value }
              : {
                  type: "date" as const,
                  value: item.value.toISOString().replace(/T.*$/, ""),
                },
          )
          .extract(),
        dateTimeOrDateProperty: this.dateTimeOrDateProperty
          .map((item) =>
            item.type === "date"
              ? {
                  type: "date" as const,
                  value: item.value.toISOString().replace(/T.*$/, ""),
                }
              : { type: "dateTime" as const, value: item.value.toISOString() },
          )
          .extract(),
        stringOrDateProperty: this.stringOrDateProperty
          .map((item) =>
            item.type === "date"
              ? {
                  type: "date" as const,
                  value: item.value.toISOString().replace(/T.*$/, ""),
                }
              : { type: "string" as const, value: item.value },
          )
          .extract(),
      } satisfies DateUnionPropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      DateUnionPropertiesClass.$properties.dateOrDateTimeProperty["identifier"],
      ...this.dateOrDateTimeProperty
        .toList()
        .flatMap((value) =>
          value.type === "dateTime"
            ? ([
                dataFactory.literal(
                  value.value.toISOString(),
                  $RdfVocabularies.xsd.dateTime,
                ),
              ] as readonly Parameters<
                rdfjsResource.MutableResource["add"]
              >[1][])
            : ([
                dataFactory.literal(
                  value.value.toISOString().replace(/T.*$/, ""),
                  $RdfVocabularies.xsd.date,
                ),
              ] as readonly Parameters<
                rdfjsResource.MutableResource["add"]
              >[1][]),
        ),
    );
    resource.add(
      DateUnionPropertiesClass.$properties.dateOrStringProperty["identifier"],
      ...this.dateOrStringProperty
        .toList()
        .flatMap((value) =>
          value.type === "string"
            ? ([value.value] as readonly Parameters<
                rdfjsResource.MutableResource["add"]
              >[1][])
            : ([
                dataFactory.literal(
                  value.value.toISOString().replace(/T.*$/, ""),
                  $RdfVocabularies.xsd.date,
                ),
              ] as readonly Parameters<
                rdfjsResource.MutableResource["add"]
              >[1][]),
        ),
    );
    resource.add(
      DateUnionPropertiesClass.$properties.dateTimeOrDateProperty["identifier"],
      ...this.dateTimeOrDateProperty
        .toList()
        .flatMap((value) =>
          value.type === "date"
            ? ([
                dataFactory.literal(
                  value.value.toISOString().replace(/T.*$/, ""),
                  $RdfVocabularies.xsd.date,
                ),
              ] as readonly Parameters<
                rdfjsResource.MutableResource["add"]
              >[1][])
            : ([
                dataFactory.literal(
                  value.value.toISOString(),
                  $RdfVocabularies.xsd.dateTime,
                ),
              ] as readonly Parameters<
                rdfjsResource.MutableResource["add"]
              >[1][]),
        ),
    );
    resource.add(
      DateUnionPropertiesClass.$properties.stringOrDateProperty["identifier"],
      ...this.stringOrDateProperty
        .toList()
        .flatMap((value) =>
          value.type === "date"
            ? ([
                dataFactory.literal(
                  value.value.toISOString().replace(/T.*$/, ""),
                  $RdfVocabularies.xsd.date,
                ),
              ] as readonly Parameters<
                rdfjsResource.MutableResource["add"]
              >[1][])
            : ([value.value] as readonly Parameters<
                rdfjsResource.MutableResource["add"]
              >[1][]),
        ),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace DateUnionPropertiesClass {
  export function $filter(
    filter: DateUnionPropertiesClass.$Filter,
    value: DateUnionPropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.dateOrDateTimeProperty !== "undefined" &&
      !$filterMaybe<
        { type: "date"; value: Date } | { type: "dateTime"; value: Date },
        {
          readonly on?: {
            readonly date?: $DateFilter;
            readonly dateTime?: $DateFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly date?: $DateFilter;
              readonly dateTime?: $DateFilter;
            };
          },
          value:
            | { type: "date"; value: Date }
            | { type: "dateTime"; value: Date },
        ) => {
          if (typeof filter.on?.["date"] !== "undefined") {
            switch (value.type) {
              case "date":
                if (!$filterDate(filter.on["date"], value.value)) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["dateTime"] !== "undefined") {
            switch (value.type) {
              case "dateTime":
                if (!$filterDate(filter.on["dateTime"], value.value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.dateOrDateTimeProperty, value.dateOrDateTimeProperty)
    ) {
      return false;
    }

    if (
      typeof filter.dateOrStringProperty !== "undefined" &&
      !$filterMaybe<
        { type: "date"; value: Date } | { type: "string"; value: string },
        {
          readonly on?: {
            readonly date?: $DateFilter;
            readonly string?: $StringFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly date?: $DateFilter;
              readonly string?: $StringFilter;
            };
          },
          value:
            | { type: "date"; value: Date }
            | { type: "string"; value: string },
        ) => {
          if (typeof filter.on?.["date"] !== "undefined") {
            switch (value.type) {
              case "date":
                if (!$filterDate(filter.on["date"], value.value)) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["string"] !== "undefined") {
            switch (value.type) {
              case "string":
                if (!$filterString(filter.on["string"], value.value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.dateOrStringProperty, value.dateOrStringProperty)
    ) {
      return false;
    }

    if (
      typeof filter.dateTimeOrDateProperty !== "undefined" &&
      !$filterMaybe<
        { type: "dateTime"; value: Date } | { type: "date"; value: Date },
        {
          readonly on?: {
            readonly dateTime?: $DateFilter;
            readonly date?: $DateFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly dateTime?: $DateFilter;
              readonly date?: $DateFilter;
            };
          },
          value:
            | { type: "dateTime"; value: Date }
            | { type: "date"; value: Date },
        ) => {
          if (typeof filter.on?.["dateTime"] !== "undefined") {
            switch (value.type) {
              case "dateTime":
                if (!$filterDate(filter.on["dateTime"], value.value)) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["date"] !== "undefined") {
            switch (value.type) {
              case "date":
                if (!$filterDate(filter.on["date"], value.value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.dateTimeOrDateProperty, value.dateTimeOrDateProperty)
    ) {
      return false;
    }

    if (
      typeof filter.stringOrDateProperty !== "undefined" &&
      !$filterMaybe<
        { type: "string"; value: string } | { type: "date"; value: Date },
        {
          readonly on?: {
            readonly string?: $StringFilter;
            readonly date?: $DateFilter;
          };
        }
      >(
        (
          filter: {
            readonly on?: {
              readonly string?: $StringFilter;
              readonly date?: $DateFilter;
            };
          },
          value:
            | { type: "string"; value: string }
            | { type: "date"; value: Date },
        ) => {
          if (typeof filter.on?.["string"] !== "undefined") {
            switch (value.type) {
              case "string":
                if (!$filterString(filter.on["string"], value.value)) {
                  return false;
                }
                break;
            }
          }

          if (typeof filter.on?.["date"] !== "undefined") {
            switch (value.type) {
              case "date":
                if (!$filterDate(filter.on["date"], value.value)) {
                  return false;
                }
                break;
            }
          }

          return true;
        },
      )(filter.stringOrDateProperty, value.stringOrDateProperty)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly dateOrDateTimeProperty?: $MaybeFilter<{
      readonly on?: {
        readonly date?: $DateFilter;
        readonly dateTime?: $DateFilter;
      };
    }>;
    readonly dateOrStringProperty?: $MaybeFilter<{
      readonly on?: {
        readonly date?: $DateFilter;
        readonly string?: $StringFilter;
      };
    }>;
    readonly dateTimeOrDateProperty?: $MaybeFilter<{
      readonly on?: {
        readonly dateTime?: $DateFilter;
        readonly date?: $DateFilter;
      };
    }>;
    readonly stringOrDateProperty?: $MaybeFilter<{
      readonly on?: {
        readonly string?: $StringFilter;
        readonly date?: $DateFilter;
      };
    }>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, DateUnionPropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new DateUnionPropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, DateUnionPropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return DateUnionPropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new DateUnionPropertiesClass(properties));
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "DateUnionPropertiesClass";
    readonly dateOrDateTimeProperty?:
      | { type: "date"; value: string }
      | { type: "dateTime"; value: string };
    readonly dateOrStringProperty?:
      | { type: "date"; value: string }
      | { type: "string"; value: string };
    readonly dateTimeOrDateProperty?:
      | { type: "dateTime"; value: string }
      | { type: "date"; value: string };
    readonly stringOrDateProperty?:
      | { type: "string"; value: string }
      | { type: "date"; value: string };
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "DateUnionPropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateOrDateTimeProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateOrStringProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/dateTimeOrDateProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/stringOrDateProperty`,
          type: "Control",
        },
      ],
      label: "DateUnionPropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("DateUnionPropertiesClass"),
      dateOrDateTimeProperty: zod
        .discriminatedUnion("type", [
          zod.object({ type: zod.literal("date"), value: zod.iso.date() }),
          zod.object({
            type: zod.literal("dateTime"),
            value: zod.iso.datetime(),
          }),
        ])
        .optional(),
      dateOrStringProperty: zod
        .discriminatedUnion("type", [
          zod.object({ type: zod.literal("date"), value: zod.iso.date() }),
          zod.object({ type: zod.literal("string"), value: zod.string() }),
        ])
        .optional(),
      dateTimeOrDateProperty: zod
        .discriminatedUnion("type", [
          zod.object({
            type: zod.literal("dateTime"),
            value: zod.iso.datetime(),
          }),
          zod.object({ type: zod.literal("date"), value: zod.iso.date() }),
        ])
        .optional(),
      stringOrDateProperty: zod
        .discriminatedUnion("type", [
          zod.object({ type: zod.literal("string"), value: zod.string() }),
          zod.object({ type: zod.literal("date"), value: zod.iso.date() }),
        ])
        .optional(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    dateOrDateTimeProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/dateOrDateTimeProperty",
      ),
    },
    dateOrStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/dateOrStringProperty",
      ),
    },
    dateTimeOrDateProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/dateTimeOrDateProperty",
      ),
    },
    stringOrDateProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/stringOrDateProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      dateOrDateTimeProperty: purify.Maybe<
        { type: "date"; value: Date } | { type: "dateTime"; value: Date }
      >;
      dateOrStringProperty: purify.Maybe<
        { type: "date"; value: Date } | { type: "string"; value: string }
      >;
      dateTimeOrDateProperty: purify.Maybe<
        { type: "dateTime"; value: Date } | { type: "date"; value: Date }
      >;
      stringOrDateProperty: purify.Maybe<
        { type: "string"; value: string } | { type: "date"; value: Date }
      >;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const dateOrDateTimeProperty = purify.Maybe.fromNullable(
      $jsonObject["dateOrDateTimeProperty"],
    ).map((item) =>
      item.type === "dateTime"
        ? { type: "dateTime" as const, value: new Date(item.value) }
        : { type: "date" as const, value: new Date(item.value) },
    );
    const dateOrStringProperty = purify.Maybe.fromNullable(
      $jsonObject["dateOrStringProperty"],
    ).map((item) =>
      item.type === "string"
        ? { type: "string" as const, value: item.value }
        : { type: "date" as const, value: new Date(item.value) },
    );
    const dateTimeOrDateProperty = purify.Maybe.fromNullable(
      $jsonObject["dateTimeOrDateProperty"],
    ).map((item) =>
      item.type === "date"
        ? { type: "date" as const, value: new Date(item.value) }
        : { type: "dateTime" as const, value: new Date(item.value) },
    );
    const stringOrDateProperty = purify.Maybe.fromNullable(
      $jsonObject["stringOrDateProperty"],
    ).map((item) =>
      item.type === "date"
        ? { type: "date" as const, value: new Date(item.value) }
        : { type: "string" as const, value: item.value },
    );
    return purify.Either.of({
      $identifier,
      dateOrDateTimeProperty,
      dateOrStringProperty,
      dateTimeOrDateProperty,
      stringOrDateProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      dateOrDateTimeProperty: purify.Maybe<
        { type: "date"; value: Date } | { type: "dateTime"; value: Date }
      >;
      dateOrStringProperty: purify.Maybe<
        { type: "date"; value: Date } | { type: "string"; value: string }
      >;
      dateTimeOrDateProperty: purify.Maybe<
        { type: "dateTime"; value: Date } | { type: "date"; value: Date }
      >;
      stringOrDateProperty: purify.Maybe<
        { type: "string"; value: string } | { type: "date"; value: Date }
      >;
    }
  > {
    const $identifier: DateUnionPropertiesClass.$Identifier =
      $parameters.resource.identifier;
    const _dateOrDateTimePropertyEither: purify.Either<
      Error,
      purify.Maybe<
        { type: "date"; value: Date } | { type: "dateTime"; value: Date }
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.dateOrDateTimeProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) => {
          const valueAsValues = purify.Either.of(value.toValues());
          return (
            valueAsValues
              .chain((values) => values.chainMap((value) => value.toDate()))
              .map((values) =>
                values.map(
                  (value) =>
                    ({ type: "date" as const, value }) as
                      | { type: "date"; value: Date }
                      | { type: "dateTime"; value: Date },
                ),
              ) as purify.Either<
              Error,
              rdfjsResource.Resource.Values<
                | { type: "date"; value: Date }
                | { type: "dateTime"; value: Date }
              >
            >
          )
            .altLazy(
              () =>
                valueAsValues
                  .chain((values) => values.chainMap((value) => value.toDate()))
                  .map((values) =>
                    values.map(
                      (value) =>
                        ({ type: "dateTime" as const, value }) as
                          | { type: "date"; value: Date }
                          | { type: "dateTime"; value: Date },
                    ),
                  ) as purify.Either<
                  Error,
                  rdfjsResource.Resource.Values<
                    | { type: "date"; value: Date }
                    | { type: "dateTime"; value: Date }
                  >
                >,
            )
            .chain((values) => values.head());
        }),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<
                | { type: "date"; value: Date }
                | { type: "dateTime"; value: Date }
              >
            >({
              focusResource: $parameters.resource,
              predicate:
                DateUnionPropertiesClass.$properties.dateOrDateTimeProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_dateOrDateTimePropertyEither.isLeft()) {
      return _dateOrDateTimePropertyEither;
    }

    const dateOrDateTimeProperty = _dateOrDateTimePropertyEither.unsafeCoerce();
    const _dateOrStringPropertyEither: purify.Either<
      Error,
      purify.Maybe<
        { type: "date"; value: Date } | { type: "string"; value: string }
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.dateOrStringProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) => {
          const valueAsValues = purify.Either.of(value.toValues());
          return (
            valueAsValues
              .chain((values) => values.chainMap((value) => value.toDate()))
              .map((values) =>
                values.map(
                  (value) =>
                    ({ type: "date" as const, value }) as
                      | { type: "date"; value: Date }
                      | { type: "string"; value: string },
                ),
              ) as purify.Either<
              Error,
              rdfjsResource.Resource.Values<
                | { type: "date"; value: Date }
                | { type: "string"; value: string }
              >
            >
          )
            .altLazy(
              () =>
                valueAsValues
                  .chain((values) =>
                    $fromRdfPreferredLanguages({
                      focusResource: $parameters.resource,
                      predicate:
                        DateUnionPropertiesClass.$properties
                          .dateOrStringProperty["identifier"],
                      preferredLanguages: $parameters.preferredLanguages,
                      values,
                    }),
                  )
                  .chain((values) =>
                    values.chainMap((value) => value.toString()),
                  )
                  .map((values) =>
                    values.map(
                      (value) =>
                        ({ type: "string" as const, value }) as
                          | { type: "date"; value: Date }
                          | { type: "string"; value: string },
                    ),
                  ) as purify.Either<
                  Error,
                  rdfjsResource.Resource.Values<
                    | { type: "date"; value: Date }
                    | { type: "string"; value: string }
                  >
                >,
            )
            .chain((values) => values.head());
        }),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<
                | { type: "date"; value: Date }
                | { type: "string"; value: string }
              >
            >({
              focusResource: $parameters.resource,
              predicate:
                DateUnionPropertiesClass.$properties.dateOrStringProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_dateOrStringPropertyEither.isLeft()) {
      return _dateOrStringPropertyEither;
    }

    const dateOrStringProperty = _dateOrStringPropertyEither.unsafeCoerce();
    const _dateTimeOrDatePropertyEither: purify.Either<
      Error,
      purify.Maybe<
        { type: "dateTime"; value: Date } | { type: "date"; value: Date }
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.dateTimeOrDateProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) => {
          const valueAsValues = purify.Either.of(value.toValues());
          return (
            valueAsValues
              .chain((values) => values.chainMap((value) => value.toDate()))
              .map((values) =>
                values.map(
                  (value) =>
                    ({ type: "dateTime" as const, value }) as
                      | { type: "dateTime"; value: Date }
                      | { type: "date"; value: Date },
                ),
              ) as purify.Either<
              Error,
              rdfjsResource.Resource.Values<
                | { type: "dateTime"; value: Date }
                | { type: "date"; value: Date }
              >
            >
          )
            .altLazy(
              () =>
                valueAsValues
                  .chain((values) => values.chainMap((value) => value.toDate()))
                  .map((values) =>
                    values.map(
                      (value) =>
                        ({ type: "date" as const, value }) as
                          | { type: "dateTime"; value: Date }
                          | { type: "date"; value: Date },
                    ),
                  ) as purify.Either<
                  Error,
                  rdfjsResource.Resource.Values<
                    | { type: "dateTime"; value: Date }
                    | { type: "date"; value: Date }
                  >
                >,
            )
            .chain((values) => values.head());
        }),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<
                | { type: "dateTime"; value: Date }
                | { type: "date"; value: Date }
              >
            >({
              focusResource: $parameters.resource,
              predicate:
                DateUnionPropertiesClass.$properties.dateTimeOrDateProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_dateTimeOrDatePropertyEither.isLeft()) {
      return _dateTimeOrDatePropertyEither;
    }

    const dateTimeOrDateProperty = _dateTimeOrDatePropertyEither.unsafeCoerce();
    const _stringOrDatePropertyEither: purify.Either<
      Error,
      purify.Maybe<
        { type: "string"; value: string } | { type: "date"; value: Date }
      >
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.stringOrDateProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) => {
          const valueAsValues = purify.Either.of(value.toValues());
          return (
            valueAsValues
              .chain((values) =>
                $fromRdfPreferredLanguages({
                  focusResource: $parameters.resource,
                  predicate:
                    DateUnionPropertiesClass.$properties.stringOrDateProperty[
                      "identifier"
                    ],
                  preferredLanguages: $parameters.preferredLanguages,
                  values,
                }),
              )
              .chain((values) => values.chainMap((value) => value.toString()))
              .map((values) =>
                values.map(
                  (value) =>
                    ({ type: "string" as const, value }) as
                      | { type: "string"; value: string }
                      | { type: "date"; value: Date },
                ),
              ) as purify.Either<
              Error,
              rdfjsResource.Resource.Values<
                | { type: "string"; value: string }
                | { type: "date"; value: Date }
              >
            >
          )
            .altLazy(
              () =>
                valueAsValues
                  .chain((values) => values.chainMap((value) => value.toDate()))
                  .map((values) =>
                    values.map(
                      (value) =>
                        ({ type: "date" as const, value }) as
                          | { type: "string"; value: string }
                          | { type: "date"; value: Date },
                    ),
                  ) as purify.Either<
                  Error,
                  rdfjsResource.Resource.Values<
                    | { type: "string"; value: string }
                    | { type: "date"; value: Date }
                  >
                >,
            )
            .chain((values) => values.head());
        }),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<
                | { type: "string"; value: string }
                | { type: "date"; value: Date }
              >
            >({
              focusResource: $parameters.resource,
              predicate:
                DateUnionPropertiesClass.$properties.stringOrDateProperty[
                  "identifier"
                ],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_stringOrDatePropertyEither.isLeft()) {
      return _stringOrDatePropertyEither;
    }

    const stringOrDateProperty = _stringOrDatePropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      dateOrDateTimeProperty,
      dateOrStringProperty,
      dateTimeOrDateProperty,
      stringOrDateProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: DateUnionPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        DateUnionPropertiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            DateUnionPropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: DateUnionPropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      DateUnionPropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("dateUnionPropertiesClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrDateTimeProperty`,
      ),
      predicate:
        DateUnionPropertiesClass.$properties.dateOrDateTimeProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrStringProperty`,
      ),
      predicate:
        DateUnionPropertiesClass.$properties.dateOrStringProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateTimeOrDateProperty`,
      ),
      predicate:
        DateUnionPropertiesClass.$properties.dateTimeOrDateProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}StringOrDateProperty`,
      ),
      predicate:
        DateUnionPropertiesClass.$properties.stringOrDateProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: DateUnionPropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("dateUnionPropertiesClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.dateOrDateTimeProperty,
          (itemFilter) => [
            {
              patterns: [
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrDateTimeProperty`,
                          ),
                          predicate:
                            DateUnionPropertiesClass.$properties
                              .dateOrDateTimeProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: $DateFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["date"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrDateTimeProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrDateTimeProperty`,
                          ),
                          predicate:
                            DateUnionPropertiesClass.$properties
                              .dateOrDateTimeProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: $DateFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["dateTime"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrDateTimeProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
              ],
              type: "union",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.dateOrStringProperty,
          (itemFilter) => [
            {
              patterns: [
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrStringProperty`,
                          ),
                          predicate:
                            DateUnionPropertiesClass.$properties
                              .dateOrStringProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: $DateFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["date"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrStringProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrStringProperty`,
                          ),
                          predicate:
                            DateUnionPropertiesClass.$properties
                              .dateOrStringProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: [parameters?.preferredLanguages ?? []]
                        .filter((languages) => languages.length > 0)
                        .map((languages) =>
                          languages.map((language) => ({
                            type: "operation" as const,
                            operator: "=",
                            args: [
                              {
                                type: "operation" as const,
                                operator: "lang",
                                args: [
                                  dataFactory.variable!(
                                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrStringProperty`,
                                  ),
                                ],
                              },
                              dataFactory.literal(language),
                            ],
                          })),
                        )
                        .map((langEqualsExpressions) => ({
                          type: "filter" as const,
                          expression: langEqualsExpressions.reduce(
                            (reducedExpression, langEqualsExpression) => {
                              if (reducedExpression === null) {
                                return langEqualsExpression;
                              }
                              return {
                                type: "operation" as const,
                                operator: "||",
                                args: [reducedExpression, langEqualsExpression],
                              };
                            },
                            null as sparqljs.Expression | null,
                          ) as sparqljs.Expression,
                        }))
                        .concat(),
                      type: "group",
                    },
                    {
                      patterns: $StringFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["string"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateOrStringProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
              ],
              type: "union",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.dateTimeOrDateProperty,
          (itemFilter) => [
            {
              patterns: [
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateTimeOrDateProperty`,
                          ),
                          predicate:
                            DateUnionPropertiesClass.$properties
                              .dateTimeOrDateProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: $DateFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["dateTime"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateTimeOrDateProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateTimeOrDateProperty`,
                          ),
                          predicate:
                            DateUnionPropertiesClass.$properties
                              .dateTimeOrDateProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: $DateFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["date"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}DateTimeOrDateProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
              ],
              type: "union",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.stringOrDateProperty,
          (itemFilter) => [
            {
              patterns: [
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}StringOrDateProperty`,
                          ),
                          predicate:
                            DateUnionPropertiesClass.$properties
                              .stringOrDateProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: [parameters?.preferredLanguages ?? []]
                        .filter((languages) => languages.length > 0)
                        .map((languages) =>
                          languages.map((language) => ({
                            type: "operation" as const,
                            operator: "=",
                            args: [
                              {
                                type: "operation" as const,
                                operator: "lang",
                                args: [
                                  dataFactory.variable!(
                                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}StringOrDateProperty`,
                                  ),
                                ],
                              },
                              dataFactory.literal(language),
                            ],
                          })),
                        )
                        .map((langEqualsExpressions) => ({
                          type: "filter" as const,
                          expression: langEqualsExpressions.reduce(
                            (reducedExpression, langEqualsExpression) => {
                              if (reducedExpression === null) {
                                return langEqualsExpression;
                              }
                              return {
                                type: "operation" as const,
                                operator: "||",
                                args: [reducedExpression, langEqualsExpression],
                              };
                            },
                            null as sparqljs.Expression | null,
                          ) as sparqljs.Expression,
                        }))
                        .concat(),
                      type: "group",
                    },
                    {
                      patterns: $StringFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["string"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}StringOrDateProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
                {
                  patterns: [
                    {
                      triples: [
                        {
                          object: dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}StringOrDateProperty`,
                          ),
                          predicate:
                            DateUnionPropertiesClass.$properties
                              .stringOrDateProperty["identifier"],
                          subject: subject,
                        },
                      ],
                      type: "bgp",
                    },
                    {
                      patterns: $DateFilter
                        .$sparqlWherePatterns(
                          itemFilter?.on?.["date"],
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dateUnionPropertiesClass")}StringOrDateProperty`,
                          ),
                        )
                        .concat(),
                      type: "group",
                    },
                  ],
                  type: "group",
                },
              ],
              type: "union",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    return patterns;
  }
}
/**
 * Node shape with properties whose types are convertible from other types on construction e.g., string to IRI.
 */
export class ConvertibleTypePropertiesClass {
  private _$identifier?: ConvertibleTypePropertiesClass.$Identifier;
  readonly $type = "ConvertibleTypePropertiesClass";
  readonly convertibleIriNonEmptySetProperty: purify.NonEmptyList<rdfjs.NamedNode>;
  readonly convertibleIriOptionProperty: purify.Maybe<rdfjs.NamedNode>;
  readonly convertibleIriProperty: rdfjs.NamedNode;
  readonly convertibleIriSetProperty: readonly rdfjs.NamedNode[];
  readonly convertibleLiteralNonEmptySetProperty: purify.NonEmptyList<rdfjs.Literal>;
  readonly convertibleLiteralOptionProperty: purify.Maybe<rdfjs.Literal>;
  readonly convertibleLiteralProperty: rdfjs.Literal;
  readonly convertibleLiteralSetProperty: readonly rdfjs.Literal[];
  readonly convertibleTermNonEmptySetProperty: purify.NonEmptyList<
    rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
  >;
  readonly convertibleTermOptionProperty: purify.Maybe<
    rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
  >;
  readonly convertibleTermProperty:
    | rdfjs.BlankNode
    | rdfjs.Literal
    | rdfjs.NamedNode;
  readonly convertibleTermSetProperty: readonly (
    | rdfjs.BlankNode
    | rdfjs.Literal
    | rdfjs.NamedNode
  )[];

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly convertibleIriNonEmptySetProperty: purify.NonEmptyList<rdfjs.NamedNode>;
    readonly convertibleIriOptionProperty?:
      | rdfjs.NamedNode
      | purify.Maybe<rdfjs.NamedNode>
      | string;
    readonly convertibleIriProperty: rdfjs.NamedNode | string;
    readonly convertibleIriSetProperty?:
      | readonly rdfjs.NamedNode[]
      | readonly string[];
    readonly convertibleLiteralNonEmptySetProperty: purify.NonEmptyList<rdfjs.Literal>;
    readonly convertibleLiteralOptionProperty?:
      | rdfjs.Literal
      | Date
      | boolean
      | number
      | purify.Maybe<rdfjs.Literal>
      | string;
    readonly convertibleLiteralProperty:
      | rdfjs.Literal
      | Date
      | boolean
      | number
      | string;
    readonly convertibleLiteralSetProperty?:
      | readonly rdfjs.Literal[]
      | readonly boolean[]
      | readonly number[]
      | readonly string[];
    readonly convertibleTermNonEmptySetProperty: purify.NonEmptyList<
      rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
    >;
    readonly convertibleTermOptionProperty?:
      | (rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode)
      | Date
      | boolean
      | number
      | purify.Maybe<rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode>
      | string;
    readonly convertibleTermProperty:
      | (rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode)
      | Date
      | boolean
      | number
      | string;
    readonly convertibleTermSetProperty?:
      | readonly (rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode)[]
      | readonly boolean[]
      | readonly number[]
      | readonly string[];
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.convertibleIriNonEmptySetProperty =
      parameters.convertibleIriNonEmptySetProperty;
    if (purify.Maybe.isMaybe(parameters.convertibleIriOptionProperty)) {
      this.convertibleIriOptionProperty =
        parameters.convertibleIriOptionProperty;
    } else if (typeof parameters.convertibleIriOptionProperty === "object") {
      this.convertibleIriOptionProperty = purify.Maybe.of(
        parameters.convertibleIriOptionProperty,
      );
    } else if (typeof parameters.convertibleIriOptionProperty === "string") {
      this.convertibleIriOptionProperty = purify.Maybe.of(
        dataFactory.namedNode(parameters.convertibleIriOptionProperty),
      );
    } else if (typeof parameters.convertibleIriOptionProperty === "undefined") {
      this.convertibleIriOptionProperty = purify.Maybe.empty();
    } else {
      this.convertibleIriOptionProperty =
        parameters.convertibleIriOptionProperty satisfies never;
    }

    if (typeof parameters.convertibleIriProperty === "object") {
      this.convertibleIriProperty = parameters.convertibleIriProperty;
    } else if (typeof parameters.convertibleIriProperty === "string") {
      this.convertibleIriProperty = dataFactory.namedNode(
        parameters.convertibleIriProperty,
      );
    } else {
      this.convertibleIriProperty =
        parameters.convertibleIriProperty satisfies never;
    }

    if (typeof parameters.convertibleIriSetProperty === "undefined") {
      this.convertibleIriSetProperty = [];
    } else if ($isReadonlyObjectArray(parameters.convertibleIriSetProperty)) {
      this.convertibleIriSetProperty = parameters.convertibleIriSetProperty;
    } else if ($isReadonlyStringArray(parameters.convertibleIriSetProperty)) {
      this.convertibleIriSetProperty = parameters.convertibleIriSetProperty.map(
        (item) => dataFactory.namedNode(item),
      );
    } else {
      this.convertibleIriSetProperty =
        parameters.convertibleIriSetProperty satisfies never;
    }

    this.convertibleLiteralNonEmptySetProperty =
      parameters.convertibleLiteralNonEmptySetProperty;
    if (purify.Maybe.isMaybe(parameters.convertibleLiteralOptionProperty)) {
      this.convertibleLiteralOptionProperty =
        parameters.convertibleLiteralOptionProperty;
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "boolean"
    ) {
      this.convertibleLiteralOptionProperty = purify.Maybe.of(
        $toLiteral(parameters.convertibleLiteralOptionProperty),
      );
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "object" &&
      parameters.convertibleLiteralOptionProperty instanceof Date
    ) {
      this.convertibleLiteralOptionProperty = purify.Maybe.of(
        $toLiteral(parameters.convertibleLiteralOptionProperty),
      );
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "number"
    ) {
      this.convertibleLiteralOptionProperty = purify.Maybe.of(
        $toLiteral(parameters.convertibleLiteralOptionProperty),
      );
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "string"
    ) {
      this.convertibleLiteralOptionProperty = purify.Maybe.of(
        $toLiteral(parameters.convertibleLiteralOptionProperty),
      );
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "object"
    ) {
      this.convertibleLiteralOptionProperty = purify.Maybe.of(
        parameters.convertibleLiteralOptionProperty,
      );
    } else if (
      typeof parameters.convertibleLiteralOptionProperty === "undefined"
    ) {
      this.convertibleLiteralOptionProperty = purify.Maybe.empty();
    } else {
      this.convertibleLiteralOptionProperty =
        parameters.convertibleLiteralOptionProperty satisfies never;
    }

    if (typeof parameters.convertibleLiteralProperty === "boolean") {
      this.convertibleLiteralProperty = $toLiteral(
        parameters.convertibleLiteralProperty,
      );
    } else if (
      typeof parameters.convertibleLiteralProperty === "object" &&
      parameters.convertibleLiteralProperty instanceof Date
    ) {
      this.convertibleLiteralProperty = $toLiteral(
        parameters.convertibleLiteralProperty,
      );
    } else if (typeof parameters.convertibleLiteralProperty === "number") {
      this.convertibleLiteralProperty = $toLiteral(
        parameters.convertibleLiteralProperty,
      );
    } else if (typeof parameters.convertibleLiteralProperty === "string") {
      this.convertibleLiteralProperty = $toLiteral(
        parameters.convertibleLiteralProperty,
      );
    } else if (typeof parameters.convertibleLiteralProperty === "object") {
      this.convertibleLiteralProperty = parameters.convertibleLiteralProperty;
    } else {
      this.convertibleLiteralProperty =
        parameters.convertibleLiteralProperty satisfies never;
    }

    if (typeof parameters.convertibleLiteralSetProperty === "undefined") {
      this.convertibleLiteralSetProperty = [];
    } else if (
      $isReadonlyObjectArray(parameters.convertibleLiteralSetProperty)
    ) {
      this.convertibleLiteralSetProperty =
        parameters.convertibleLiteralSetProperty;
    } else if (
      $isReadonlyBooleanArray(parameters.convertibleLiteralSetProperty)
    ) {
      this.convertibleLiteralSetProperty =
        parameters.convertibleLiteralSetProperty.map((item) =>
          $toLiteral(item),
        );
    } else if (
      $isReadonlyNumberArray(parameters.convertibleLiteralSetProperty)
    ) {
      this.convertibleLiteralSetProperty =
        parameters.convertibleLiteralSetProperty.map((item) =>
          $toLiteral(item),
        );
    } else if (
      $isReadonlyStringArray(parameters.convertibleLiteralSetProperty)
    ) {
      this.convertibleLiteralSetProperty =
        parameters.convertibleLiteralSetProperty.map((item) =>
          $toLiteral(item),
        );
    } else {
      this.convertibleLiteralSetProperty =
        parameters.convertibleLiteralSetProperty satisfies never;
    }

    this.convertibleTermNonEmptySetProperty =
      parameters.convertibleTermNonEmptySetProperty;
    if (purify.Maybe.isMaybe(parameters.convertibleTermOptionProperty)) {
      this.convertibleTermOptionProperty =
        parameters.convertibleTermOptionProperty;
    } else if (typeof parameters.convertibleTermOptionProperty === "boolean") {
      this.convertibleTermOptionProperty = purify.Maybe.of(
        $toLiteral(parameters.convertibleTermOptionProperty),
      );
    } else if (
      typeof parameters.convertibleTermOptionProperty === "object" &&
      parameters.convertibleTermOptionProperty instanceof Date
    ) {
      this.convertibleTermOptionProperty = purify.Maybe.of(
        $toLiteral(parameters.convertibleTermOptionProperty),
      );
    } else if (typeof parameters.convertibleTermOptionProperty === "number") {
      this.convertibleTermOptionProperty = purify.Maybe.of(
        $toLiteral(parameters.convertibleTermOptionProperty),
      );
    } else if (typeof parameters.convertibleTermOptionProperty === "string") {
      this.convertibleTermOptionProperty = purify.Maybe.of(
        $toLiteral(parameters.convertibleTermOptionProperty),
      );
    } else if (typeof parameters.convertibleTermOptionProperty === "object") {
      this.convertibleTermOptionProperty = purify.Maybe.of(
        parameters.convertibleTermOptionProperty,
      );
    } else if (
      typeof parameters.convertibleTermOptionProperty === "undefined"
    ) {
      this.convertibleTermOptionProperty = purify.Maybe.empty();
    } else {
      this.convertibleTermOptionProperty =
        parameters.convertibleTermOptionProperty satisfies never;
    }

    if (typeof parameters.convertibleTermProperty === "boolean") {
      this.convertibleTermProperty = $toLiteral(
        parameters.convertibleTermProperty,
      );
    } else if (
      typeof parameters.convertibleTermProperty === "object" &&
      parameters.convertibleTermProperty instanceof Date
    ) {
      this.convertibleTermProperty = $toLiteral(
        parameters.convertibleTermProperty,
      );
    } else if (typeof parameters.convertibleTermProperty === "number") {
      this.convertibleTermProperty = $toLiteral(
        parameters.convertibleTermProperty,
      );
    } else if (typeof parameters.convertibleTermProperty === "string") {
      this.convertibleTermProperty = $toLiteral(
        parameters.convertibleTermProperty,
      );
    } else if (typeof parameters.convertibleTermProperty === "object") {
      this.convertibleTermProperty = parameters.convertibleTermProperty;
    } else {
      this.convertibleTermProperty =
        parameters.convertibleTermProperty satisfies never;
    }

    if (typeof parameters.convertibleTermSetProperty === "undefined") {
      this.convertibleTermSetProperty = [];
    } else if ($isReadonlyObjectArray(parameters.convertibleTermSetProperty)) {
      this.convertibleTermSetProperty = parameters.convertibleTermSetProperty;
    } else if ($isReadonlyBooleanArray(parameters.convertibleTermSetProperty)) {
      this.convertibleTermSetProperty =
        parameters.convertibleTermSetProperty.map((item) => $toLiteral(item));
    } else if ($isReadonlyNumberArray(parameters.convertibleTermSetProperty)) {
      this.convertibleTermSetProperty =
        parameters.convertibleTermSetProperty.map((item) => $toLiteral(item));
    } else if ($isReadonlyStringArray(parameters.convertibleTermSetProperty)) {
      this.convertibleTermSetProperty =
        parameters.convertibleTermSetProperty.map((item) => $toLiteral(item));
    } else {
      this.convertibleTermSetProperty =
        parameters.convertibleTermSetProperty satisfies never;
    }
  }

  get $identifier(): ConvertibleTypePropertiesClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: ConvertibleTypePropertiesClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleIriNonEmptySetProperty,
          other.convertibleIriNonEmptySetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleIriNonEmptySetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.convertibleIriOptionProperty,
          other.convertibleIriOptionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleIriOptionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $booleanEquals(
          this.convertibleIriProperty,
          other.convertibleIriProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleIriProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleIriSetProperty,
          other.convertibleIriSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleIriSetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleLiteralNonEmptySetProperty,
          other.convertibleLiteralNonEmptySetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleLiteralNonEmptySetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.convertibleLiteralOptionProperty,
          other.convertibleLiteralOptionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleLiteralOptionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $booleanEquals(
          this.convertibleLiteralProperty,
          other.convertibleLiteralProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleLiteralProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleLiteralSetProperty,
          other.convertibleLiteralSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleLiteralSetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleTermNonEmptySetProperty,
          other.convertibleTermNonEmptySetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleTermNonEmptySetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.convertibleTermOptionProperty,
          other.convertibleTermOptionProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleTermOptionProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        $booleanEquals(
          this.convertibleTermProperty,
          other.convertibleTermProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleTermProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.convertibleTermSetProperty,
          other.convertibleTermSetProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "convertibleTermSetProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    for (const item0 of this.convertibleIriNonEmptySetProperty) {
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }

    this.convertibleIriOptionProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    _hasher.update(this.convertibleIriProperty.termType);
    _hasher.update(this.convertibleIriProperty.value);
    for (const item0 of this.convertibleIriSetProperty) {
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }

    for (const item0 of this.convertibleLiteralNonEmptySetProperty) {
      _hasher.update(item0.datatype.value);
      _hasher.update(item0.language);
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }

    this.convertibleLiteralOptionProperty.ifJust((value0) => {
      _hasher.update(value0.datatype.value);
      _hasher.update(value0.language);
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    _hasher.update(this.convertibleLiteralProperty.datatype.value);
    _hasher.update(this.convertibleLiteralProperty.language);
    _hasher.update(this.convertibleLiteralProperty.termType);
    _hasher.update(this.convertibleLiteralProperty.value);
    for (const item0 of this.convertibleLiteralSetProperty) {
      _hasher.update(item0.datatype.value);
      _hasher.update(item0.language);
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }

    for (const item0 of this.convertibleTermNonEmptySetProperty) {
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }

    this.convertibleTermOptionProperty.ifJust((value0) => {
      _hasher.update(value0.termType);
      _hasher.update(value0.value);
    });
    _hasher.update(this.convertibleTermProperty.termType);
    _hasher.update(this.convertibleTermProperty.value);
    for (const item0 of this.convertibleTermSetProperty) {
      _hasher.update(item0.termType);
      _hasher.update(item0.value);
    }

    return _hasher;
  }

  $toJson(): ConvertibleTypePropertiesClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        convertibleIriNonEmptySetProperty:
          this.convertibleIriNonEmptySetProperty.map((item) => ({
            "@id": item.value,
          })),
        convertibleIriOptionProperty: this.convertibleIriOptionProperty
          .map((item) => ({ "@id": item.value }))
          .extract(),
        convertibleIriProperty: { "@id": this.convertibleIriProperty.value },
        convertibleIriSetProperty: this.convertibleIriSetProperty.map(
          (item) => ({ "@id": item.value }),
        ),
        convertibleLiteralNonEmptySetProperty:
          this.convertibleLiteralNonEmptySetProperty.map((item) => ({
            "@language": item.language.length > 0 ? item.language : undefined,
            "@type":
              item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? item.datatype.value
                : undefined,
            "@value": item.value,
          })),
        convertibleLiteralOptionProperty: this.convertibleLiteralOptionProperty
          .map((item) => ({
            "@language": item.language.length > 0 ? item.language : undefined,
            "@type":
              item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? item.datatype.value
                : undefined,
            "@value": item.value,
          }))
          .extract(),
        convertibleLiteralProperty: {
          "@language":
            this.convertibleLiteralProperty.language.length > 0
              ? this.convertibleLiteralProperty.language
              : undefined,
          "@type":
            this.convertibleLiteralProperty.datatype.value !==
            "http://www.w3.org/2001/XMLSchema#string"
              ? this.convertibleLiteralProperty.datatype.value
              : undefined,
          "@value": this.convertibleLiteralProperty.value,
        },
        convertibleLiteralSetProperty: this.convertibleLiteralSetProperty.map(
          (item) => ({
            "@language": item.language.length > 0 ? item.language : undefined,
            "@type":
              item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? item.datatype.value
                : undefined,
            "@value": item.value,
          }),
        ),
        convertibleTermNonEmptySetProperty:
          this.convertibleTermNonEmptySetProperty.map((item) =>
            item.termType === "NamedNode"
              ? { "@id": item.value, termType: "NamedNode" as const }
              : item.termType === "Literal"
                ? {
                    "@language":
                      item.language.length > 0 ? item.language : undefined,
                    "@type":
                      item.datatype.value !==
                      "http://www.w3.org/2001/XMLSchema#string"
                        ? item.datatype.value
                        : undefined,
                    "@value": item.value,
                    termType: "Literal" as const,
                  }
                : { "@id": `_:${item.value}`, termType: "BlankNode" as const },
          ),
        convertibleTermOptionProperty: this.convertibleTermOptionProperty
          .map((item) =>
            item.termType === "NamedNode"
              ? { "@id": item.value, termType: "NamedNode" as const }
              : item.termType === "Literal"
                ? {
                    "@language":
                      item.language.length > 0 ? item.language : undefined,
                    "@type":
                      item.datatype.value !==
                      "http://www.w3.org/2001/XMLSchema#string"
                        ? item.datatype.value
                        : undefined,
                    "@value": item.value,
                    termType: "Literal" as const,
                  }
                : { "@id": `_:${item.value}`, termType: "BlankNode" as const },
          )
          .extract(),
        convertibleTermProperty:
          this.convertibleTermProperty.termType === "NamedNode"
            ? {
                "@id": this.convertibleTermProperty.value,
                termType: "NamedNode" as const,
              }
            : this.convertibleTermProperty.termType === "Literal"
              ? {
                  "@language":
                    this.convertibleTermProperty.language.length > 0
                      ? this.convertibleTermProperty.language
                      : undefined,
                  "@type":
                    this.convertibleTermProperty.datatype.value !==
                    "http://www.w3.org/2001/XMLSchema#string"
                      ? this.convertibleTermProperty.datatype.value
                      : undefined,
                  "@value": this.convertibleTermProperty.value,
                  termType: "Literal" as const,
                }
              : {
                  "@id": `_:${this.convertibleTermProperty.value}`,
                  termType: "BlankNode" as const,
                },
        convertibleTermSetProperty: this.convertibleTermSetProperty.map(
          (item) =>
            item.termType === "NamedNode"
              ? { "@id": item.value, termType: "NamedNode" as const }
              : item.termType === "Literal"
                ? {
                    "@language":
                      item.language.length > 0 ? item.language : undefined,
                    "@type":
                      item.datatype.value !==
                      "http://www.w3.org/2001/XMLSchema#string"
                        ? item.datatype.value
                        : undefined,
                    "@value": item.value,
                    termType: "Literal" as const,
                  }
                : { "@id": `_:${item.value}`, termType: "BlankNode" as const },
        ),
      } satisfies ConvertibleTypePropertiesClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/ConvertibleTypePropertiesClass",
        ),
      );
    }

    resource.add(
      ConvertibleTypePropertiesClass.$properties
        .convertibleIriNonEmptySetProperty["identifier"],
      ...this.convertibleIriNonEmptySetProperty.flatMap((item) => [item]),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleIriOptionProperty[
        "identifier"
      ],
      ...this.convertibleIriOptionProperty.toList(),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleIriProperty[
        "identifier"
      ],
      ...[this.convertibleIriProperty],
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleIriSetProperty[
        "identifier"
      ],
      ...this.convertibleIriSetProperty.flatMap((item) => [item]),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties
        .convertibleLiteralNonEmptySetProperty["identifier"],
      ...this.convertibleLiteralNonEmptySetProperty.flatMap((item) => [item]),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties
        .convertibleLiteralOptionProperty["identifier"],
      ...this.convertibleLiteralOptionProperty.toList(),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleLiteralProperty[
        "identifier"
      ],
      ...[this.convertibleLiteralProperty],
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleLiteralSetProperty[
        "identifier"
      ],
      ...this.convertibleLiteralSetProperty.flatMap((item) => [item]),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties
        .convertibleTermNonEmptySetProperty["identifier"],
      ...this.convertibleTermNonEmptySetProperty.flatMap((item) => [item]),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleTermOptionProperty[
        "identifier"
      ],
      ...this.convertibleTermOptionProperty.toList(),
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleTermProperty[
        "identifier"
      ],
      ...[this.convertibleTermProperty],
    );
    resource.add(
      ConvertibleTypePropertiesClass.$properties.convertibleTermSetProperty[
        "identifier"
      ],
      ...this.convertibleTermSetProperty.flatMap((item) => [item]),
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ConvertibleTypePropertiesClass {
  export function $filter(
    filter: ConvertibleTypePropertiesClass.$Filter,
    value: ConvertibleTypePropertiesClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.convertibleIriNonEmptySetProperty !== "undefined" &&
      !$filterArray<rdfjs.NamedNode, $NamedNodeFilter>($filterNamedNode)(
        filter.convertibleIriNonEmptySetProperty,
        value.convertibleIriNonEmptySetProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleIriOptionProperty !== "undefined" &&
      !$filterMaybe<rdfjs.NamedNode, $NamedNodeFilter>($filterNamedNode)(
        filter.convertibleIriOptionProperty,
        value.convertibleIriOptionProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleIriProperty !== "undefined" &&
      !$filterNamedNode(
        filter.convertibleIriProperty,
        value.convertibleIriProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleIriSetProperty !== "undefined" &&
      !$filterArray<rdfjs.NamedNode, $NamedNodeFilter>($filterNamedNode)(
        filter.convertibleIriSetProperty,
        value.convertibleIriSetProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleLiteralNonEmptySetProperty !== "undefined" &&
      !$filterArray<rdfjs.Literal, $LiteralFilter>($filterLiteral)(
        filter.convertibleLiteralNonEmptySetProperty,
        value.convertibleLiteralNonEmptySetProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleLiteralOptionProperty !== "undefined" &&
      !$filterMaybe<rdfjs.Literal, $LiteralFilter>($filterLiteral)(
        filter.convertibleLiteralOptionProperty,
        value.convertibleLiteralOptionProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleLiteralProperty !== "undefined" &&
      !$filterLiteral(
        filter.convertibleLiteralProperty,
        value.convertibleLiteralProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleLiteralSetProperty !== "undefined" &&
      !$filterArray<rdfjs.Literal, $LiteralFilter>($filterLiteral)(
        filter.convertibleLiteralSetProperty,
        value.convertibleLiteralSetProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleTermNonEmptySetProperty !== "undefined" &&
      !$filterArray<
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode,
        $TermFilter
      >($filterTerm)(
        filter.convertibleTermNonEmptySetProperty,
        value.convertibleTermNonEmptySetProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleTermOptionProperty !== "undefined" &&
      !$filterMaybe<
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode,
        $TermFilter
      >($filterTerm)(
        filter.convertibleTermOptionProperty,
        value.convertibleTermOptionProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleTermProperty !== "undefined" &&
      !$filterTerm(
        filter.convertibleTermProperty,
        value.convertibleTermProperty,
      )
    ) {
      return false;
    }

    if (
      typeof filter.convertibleTermSetProperty !== "undefined" &&
      !$filterArray<
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode,
        $TermFilter
      >($filterTerm)(
        filter.convertibleTermSetProperty,
        value.convertibleTermSetProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly convertibleIriNonEmptySetProperty?: $CollectionFilter<$NamedNodeFilter>;
    readonly convertibleIriOptionProperty?: $MaybeFilter<$NamedNodeFilter>;
    readonly convertibleIriProperty?: $NamedNodeFilter;
    readonly convertibleIriSetProperty?: $CollectionFilter<$NamedNodeFilter>;
    readonly convertibleLiteralNonEmptySetProperty?: $CollectionFilter<$LiteralFilter>;
    readonly convertibleLiteralOptionProperty?: $MaybeFilter<$LiteralFilter>;
    readonly convertibleLiteralProperty?: $LiteralFilter;
    readonly convertibleLiteralSetProperty?: $CollectionFilter<$LiteralFilter>;
    readonly convertibleTermNonEmptySetProperty?: $CollectionFilter<$TermFilter>;
    readonly convertibleTermOptionProperty?: $MaybeFilter<$TermFilter>;
    readonly convertibleTermProperty?: $TermFilter;
    readonly convertibleTermSetProperty?: $CollectionFilter<$TermFilter>;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ConvertibleTypePropertiesClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ConvertibleTypePropertiesClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ConvertibleTypePropertiesClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ConvertibleTypePropertiesClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ConvertibleTypePropertiesClass(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ConvertibleTypePropertiesClass",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ConvertibleTypePropertiesClass";
    readonly convertibleIriNonEmptySetProperty: readonly {
      readonly "@id": string;
    }[];
    readonly convertibleIriOptionProperty?: { readonly "@id": string };
    readonly convertibleIriProperty: { readonly "@id": string };
    readonly convertibleIriSetProperty?: readonly { readonly "@id": string }[];
    readonly convertibleLiteralNonEmptySetProperty: readonly {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    }[];
    readonly convertibleLiteralOptionProperty?: {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    };
    readonly convertibleLiteralProperty: {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    };
    readonly convertibleLiteralSetProperty?: readonly {
      readonly "@language"?: string;
      readonly "@type"?: string;
      readonly "@value": string;
    }[];
    readonly convertibleTermNonEmptySetProperty: readonly (
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly "@type"?: string;
          readonly "@value": string;
          readonly termType: "Literal";
        }
    )[];
    readonly convertibleTermOptionProperty?:
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly "@type"?: string;
          readonly "@value": string;
          readonly termType: "Literal";
        };
    readonly convertibleTermProperty:
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly "@type"?: string;
          readonly "@value": string;
          readonly termType: "Literal";
        };
    readonly convertibleTermSetProperty?: readonly (
      | { readonly "@id": string; readonly termType: "BlankNode" | "NamedNode" }
      | {
          readonly "@language"?: string;
          readonly "@type"?: string;
          readonly "@value": string;
          readonly termType: "Literal";
        }
    )[];
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ConvertibleTypePropertiesClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleIriNonEmptySetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleIriOptionProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleIriProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleIriSetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleLiteralNonEmptySetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleLiteralOptionProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleLiteralProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleLiteralSetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleTermNonEmptySetProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleTermOptionProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleTermProperty`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/convertibleTermSetProperty`,
          type: "Control",
        },
      ],
      label: "ConvertibleTypePropertiesClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("ConvertibleTypePropertiesClass"),
      convertibleIriNonEmptySetProperty: zod
        .object({ "@id": zod.string().min(1) })
        .array()
        .nonempty()
        .min(1),
      convertibleIriOptionProperty: zod
        .object({ "@id": zod.string().min(1) })
        .optional(),
      convertibleIriProperty: zod.object({ "@id": zod.string().min(1) }),
      convertibleIriSetProperty: zod
        .object({ "@id": zod.string().min(1) })
        .array()
        .default(() => []),
      convertibleLiteralNonEmptySetProperty: zod
        .object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
        })
        .array()
        .nonempty()
        .min(1),
      convertibleLiteralOptionProperty: zod
        .object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
        })
        .optional(),
      convertibleLiteralProperty: zod.object({
        "@language": zod.string().optional(),
        "@type": zod.string().optional(),
        "@value": zod.string(),
      }),
      convertibleLiteralSetProperty: zod
        .object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
        })
        .array()
        .default(() => []),
      convertibleTermNonEmptySetProperty: zod
        .discriminatedUnion("termType", [
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("BlankNode"),
          }),
          zod.object({
            "@language": zod.string().optional(),
            "@type": zod.string().optional(),
            "@value": zod.string(),
            termType: zod.literal("Literal"),
          }),
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("NamedNode"),
          }),
        ])
        .array()
        .nonempty()
        .min(1),
      convertibleTermOptionProperty: zod
        .discriminatedUnion("termType", [
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("BlankNode"),
          }),
          zod.object({
            "@language": zod.string().optional(),
            "@type": zod.string().optional(),
            "@value": zod.string(),
            termType: zod.literal("Literal"),
          }),
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("NamedNode"),
          }),
        ])
        .optional(),
      convertibleTermProperty: zod.discriminatedUnion("termType", [
        zod.object({
          "@id": zod.string().min(1),
          termType: zod.literal("BlankNode"),
        }),
        zod.object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
          termType: zod.literal("Literal"),
        }),
        zod.object({
          "@id": zod.string().min(1),
          termType: zod.literal("NamedNode"),
        }),
      ]),
      convertibleTermSetProperty: zod
        .discriminatedUnion("termType", [
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("BlankNode"),
          }),
          zod.object({
            "@language": zod.string().optional(),
            "@type": zod.string().optional(),
            "@value": zod.string(),
            termType: zod.literal("Literal"),
          }),
          zod.object({
            "@id": zod.string().min(1),
            termType: zod.literal("NamedNode"),
          }),
        ])
        .array()
        .default(() => []),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    convertibleIriNonEmptySetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleIriNonEmptySetProperty",
      ),
    },
    convertibleIriOptionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleIriOptionProperty",
      ),
    },
    convertibleIriProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleIriProperty",
      ),
    },
    convertibleIriSetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleIriSetProperty",
      ),
    },
    convertibleLiteralNonEmptySetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleLiteralNonEmptySetProperty",
      ),
    },
    convertibleLiteralOptionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleLiteralOptionProperty",
      ),
    },
    convertibleLiteralProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleLiteralProperty",
      ),
    },
    convertibleLiteralSetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleLiteralSetProperty",
      ),
    },
    convertibleTermNonEmptySetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleTermNonEmptySetProperty",
      ),
    },
    convertibleTermOptionProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleTermOptionProperty",
      ),
    },
    convertibleTermProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleTermProperty",
      ),
    },
    convertibleTermSetProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/convertibleTermSetProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      convertibleIriNonEmptySetProperty: purify.NonEmptyList<rdfjs.NamedNode>;
      convertibleIriOptionProperty: purify.Maybe<rdfjs.NamedNode>;
      convertibleIriProperty: rdfjs.NamedNode;
      convertibleIriSetProperty: readonly rdfjs.NamedNode[];
      convertibleLiteralNonEmptySetProperty: purify.NonEmptyList<rdfjs.Literal>;
      convertibleLiteralOptionProperty: purify.Maybe<rdfjs.Literal>;
      convertibleLiteralProperty: rdfjs.Literal;
      convertibleLiteralSetProperty: readonly rdfjs.Literal[];
      convertibleTermNonEmptySetProperty: purify.NonEmptyList<
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
      >;
      convertibleTermOptionProperty: purify.Maybe<
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
      >;
      convertibleTermProperty:
        | rdfjs.BlankNode
        | rdfjs.Literal
        | rdfjs.NamedNode;
      convertibleTermSetProperty: readonly (
        | rdfjs.BlankNode
        | rdfjs.Literal
        | rdfjs.NamedNode
      )[];
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const convertibleIriNonEmptySetProperty = purify.NonEmptyList.fromArray(
      $jsonObject["convertibleIriNonEmptySetProperty"],
    )
      .unsafeCoerce()
      .map((item) => dataFactory.namedNode(item["@id"]));
    const convertibleIriOptionProperty = purify.Maybe.fromNullable(
      $jsonObject["convertibleIriOptionProperty"],
    ).map((item) => dataFactory.namedNode(item["@id"]));
    const convertibleIriProperty = dataFactory.namedNode(
      $jsonObject["convertibleIriProperty"]["@id"],
    );
    const convertibleIriSetProperty = $jsonObject[
      "convertibleIriSetProperty"
    ].map((item) => dataFactory.namedNode(item["@id"]));
    const convertibleLiteralNonEmptySetProperty = purify.NonEmptyList.fromArray(
      $jsonObject["convertibleLiteralNonEmptySetProperty"],
    )
      .unsafeCoerce()
      .map((item) =>
        dataFactory.literal(
          item["@value"],
          typeof item["@language"] !== "undefined"
            ? item["@language"]
            : typeof item["@type"] !== "undefined"
              ? dataFactory.namedNode(item["@type"])
              : undefined,
        ),
      );
    const convertibleLiteralOptionProperty = purify.Maybe.fromNullable(
      $jsonObject["convertibleLiteralOptionProperty"],
    ).map((item) =>
      dataFactory.literal(
        item["@value"],
        typeof item["@language"] !== "undefined"
          ? item["@language"]
          : typeof item["@type"] !== "undefined"
            ? dataFactory.namedNode(item["@type"])
            : undefined,
      ),
    );
    const convertibleLiteralProperty = dataFactory.literal(
      $jsonObject["convertibleLiteralProperty"]["@value"],
      typeof $jsonObject["convertibleLiteralProperty"]["@language"] !==
        "undefined"
        ? $jsonObject["convertibleLiteralProperty"]["@language"]
        : typeof $jsonObject["convertibleLiteralProperty"]["@type"] !==
            "undefined"
          ? dataFactory.namedNode(
              $jsonObject["convertibleLiteralProperty"]["@type"],
            )
          : undefined,
    );
    const convertibleLiteralSetProperty = $jsonObject[
      "convertibleLiteralSetProperty"
    ].map((item) =>
      dataFactory.literal(
        item["@value"],
        typeof item["@language"] !== "undefined"
          ? item["@language"]
          : typeof item["@type"] !== "undefined"
            ? dataFactory.namedNode(item["@type"])
            : undefined,
      ),
    );
    const convertibleTermNonEmptySetProperty = purify.NonEmptyList.fromArray(
      $jsonObject["convertibleTermNonEmptySetProperty"],
    )
      .unsafeCoerce()
      .map((item) =>
        item.termType === "NamedNode"
          ? dataFactory.namedNode(item["@id"])
          : item.termType === "Literal"
            ? dataFactory.literal(
                item["@value"],
                typeof item["@language"] !== "undefined"
                  ? item["@language"]
                  : typeof item["@type"] !== "undefined"
                    ? dataFactory.namedNode(item["@type"])
                    : undefined,
              )
            : dataFactory.blankNode(item["@id"].substring(2)),
      );
    const convertibleTermOptionProperty = purify.Maybe.fromNullable(
      $jsonObject["convertibleTermOptionProperty"],
    ).map((item) =>
      item.termType === "NamedNode"
        ? dataFactory.namedNode(item["@id"])
        : item.termType === "Literal"
          ? dataFactory.literal(
              item["@value"],
              typeof item["@language"] !== "undefined"
                ? item["@language"]
                : typeof item["@type"] !== "undefined"
                  ? dataFactory.namedNode(item["@type"])
                  : undefined,
            )
          : dataFactory.blankNode(item["@id"].substring(2)),
    );
    const convertibleTermProperty =
      $jsonObject["convertibleTermProperty"].termType === "NamedNode"
        ? dataFactory.namedNode($jsonObject["convertibleTermProperty"]["@id"])
        : $jsonObject["convertibleTermProperty"].termType === "Literal"
          ? dataFactory.literal(
              $jsonObject["convertibleTermProperty"]["@value"],
              typeof $jsonObject["convertibleTermProperty"]["@language"] !==
                "undefined"
                ? $jsonObject["convertibleTermProperty"]["@language"]
                : typeof $jsonObject["convertibleTermProperty"]["@type"] !==
                    "undefined"
                  ? dataFactory.namedNode(
                      $jsonObject["convertibleTermProperty"]["@type"],
                    )
                  : undefined,
            )
          : dataFactory.blankNode(
              $jsonObject["convertibleTermProperty"]["@id"].substring(2),
            );
    const convertibleTermSetProperty = $jsonObject[
      "convertibleTermSetProperty"
    ].map((item) =>
      item.termType === "NamedNode"
        ? dataFactory.namedNode(item["@id"])
        : item.termType === "Literal"
          ? dataFactory.literal(
              item["@value"],
              typeof item["@language"] !== "undefined"
                ? item["@language"]
                : typeof item["@type"] !== "undefined"
                  ? dataFactory.namedNode(item["@type"])
                  : undefined,
            )
          : dataFactory.blankNode(item["@id"].substring(2)),
    );
    return purify.Either.of({
      $identifier,
      convertibleIriNonEmptySetProperty,
      convertibleIriOptionProperty,
      convertibleIriProperty,
      convertibleIriSetProperty,
      convertibleLiteralNonEmptySetProperty,
      convertibleLiteralOptionProperty,
      convertibleLiteralProperty,
      convertibleLiteralSetProperty,
      convertibleTermNonEmptySetProperty,
      convertibleTermOptionProperty,
      convertibleTermProperty,
      convertibleTermSetProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      convertibleIriNonEmptySetProperty: purify.NonEmptyList<rdfjs.NamedNode>;
      convertibleIriOptionProperty: purify.Maybe<rdfjs.NamedNode>;
      convertibleIriProperty: rdfjs.NamedNode;
      convertibleIriSetProperty: readonly rdfjs.NamedNode[];
      convertibleLiteralNonEmptySetProperty: purify.NonEmptyList<rdfjs.Literal>;
      convertibleLiteralOptionProperty: purify.Maybe<rdfjs.Literal>;
      convertibleLiteralProperty: rdfjs.Literal;
      convertibleLiteralSetProperty: readonly rdfjs.Literal[];
      convertibleTermNonEmptySetProperty: purify.NonEmptyList<
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
      >;
      convertibleTermOptionProperty: purify.Maybe<
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
      >;
      convertibleTermProperty:
        | rdfjs.BlankNode
        | rdfjs.Literal
        | rdfjs.NamedNode;
      convertibleTermSetProperty: readonly (
        | rdfjs.BlankNode
        | rdfjs.Literal
        | rdfjs.NamedNode
      )[];
    }
  > {
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/ConvertibleTypePropertiesClass":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              ConvertibleTypePropertiesClass.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ConvertibleTypePropertiesClass)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: ConvertibleTypePropertiesClass.$Identifier =
      $parameters.resource.identifier;
    const _convertibleIriNonEmptySetPropertyEither: purify.Either<
      Error,
      purify.NonEmptyList<rdfjs.NamedNode>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.convertibleIriNonEmptySetProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) => values.chainMap((value) => value.toIri()))
      .chain((values) =>
        purify.NonEmptyList.fromArray(values.toArray()).toEither(
          new Error(
            `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} is an empty set`,
          ),
        ),
      )
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          focusResource: $parameters.resource,
          predicate:
            ConvertibleTypePropertiesClass.$properties
              .convertibleIriNonEmptySetProperty["identifier"],
          value: valuesArray,
        }),
      )
      .chain((values) => values.head());
    if (_convertibleIriNonEmptySetPropertyEither.isLeft()) {
      return _convertibleIriNonEmptySetPropertyEither;
    }

    const convertibleIriNonEmptySetProperty =
      _convertibleIriNonEmptySetPropertyEither.unsafeCoerce();
    const _convertibleIriOptionPropertyEither: purify.Either<
      Error,
      purify.Maybe<rdfjs.NamedNode>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.convertibleIriOptionProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) => values.chainMap((value) => value.toIri()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<rdfjs.NamedNode>
            >({
              focusResource: $parameters.resource,
              predicate:
                ConvertibleTypePropertiesClass.$properties
                  .convertibleIriOptionProperty["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_convertibleIriOptionPropertyEither.isLeft()) {
      return _convertibleIriOptionPropertyEither;
    }

    const convertibleIriOptionProperty =
      _convertibleIriOptionPropertyEither.unsafeCoerce();
    const _convertibleIriPropertyEither: purify.Either<Error, rdfjs.NamedNode> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.convertibleIriProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) => values.chainMap((value) => value.toIri()))
        .chain((values) => values.head());
    if (_convertibleIriPropertyEither.isLeft()) {
      return _convertibleIriPropertyEither;
    }

    const convertibleIriProperty = _convertibleIriPropertyEither.unsafeCoerce();
    const _convertibleIriSetPropertyEither: purify.Either<
      Error,
      readonly rdfjs.NamedNode[]
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.convertibleIriSetProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) => values.chainMap((value) => value.toIri()))
      .map((values) => values.toArray())
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          focusResource: $parameters.resource,
          predicate:
            ConvertibleTypePropertiesClass.$properties
              .convertibleIriSetProperty["identifier"],
          value: valuesArray,
        }),
      )
      .chain((values) => values.head());
    if (_convertibleIriSetPropertyEither.isLeft()) {
      return _convertibleIriSetPropertyEither;
    }

    const convertibleIriSetProperty =
      _convertibleIriSetPropertyEither.unsafeCoerce();
    const _convertibleLiteralNonEmptySetPropertyEither: purify.Either<
      Error,
      purify.NonEmptyList<rdfjs.Literal>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.convertibleLiteralNonEmptySetProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        $fromRdfPreferredLanguages({
          focusResource: $parameters.resource,
          predicate:
            ConvertibleTypePropertiesClass.$properties
              .convertibleLiteralNonEmptySetProperty["identifier"],
          preferredLanguages: $parameters.preferredLanguages,
          values,
        }),
      )
      .chain((values) => values.chainMap((value) => value.toLiteral()))
      .chain((values) =>
        purify.NonEmptyList.fromArray(values.toArray()).toEither(
          new Error(
            `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} is an empty set`,
          ),
        ),
      )
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          focusResource: $parameters.resource,
          predicate:
            ConvertibleTypePropertiesClass.$properties
              .convertibleLiteralNonEmptySetProperty["identifier"],
          value: valuesArray,
        }),
      )
      .chain((values) => values.head());
    if (_convertibleLiteralNonEmptySetPropertyEither.isLeft()) {
      return _convertibleLiteralNonEmptySetPropertyEither;
    }

    const convertibleLiteralNonEmptySetProperty =
      _convertibleLiteralNonEmptySetPropertyEither.unsafeCoerce();
    const _convertibleLiteralOptionPropertyEither: purify.Either<
      Error,
      purify.Maybe<rdfjs.Literal>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.convertibleLiteralOptionProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        $fromRdfPreferredLanguages({
          focusResource: $parameters.resource,
          predicate:
            ConvertibleTypePropertiesClass.$properties
              .convertibleLiteralOptionProperty["identifier"],
          preferredLanguages: $parameters.preferredLanguages,
          values,
        }),
      )
      .chain((values) => values.chainMap((value) => value.toLiteral()))
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<rdfjs.Literal>
            >({
              focusResource: $parameters.resource,
              predicate:
                ConvertibleTypePropertiesClass.$properties
                  .convertibleLiteralOptionProperty["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_convertibleLiteralOptionPropertyEither.isLeft()) {
      return _convertibleLiteralOptionPropertyEither;
    }

    const convertibleLiteralOptionProperty =
      _convertibleLiteralOptionPropertyEither.unsafeCoerce();
    const _convertibleLiteralPropertyEither: purify.Either<
      Error,
      rdfjs.Literal
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.convertibleLiteralProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        $fromRdfPreferredLanguages({
          focusResource: $parameters.resource,
          predicate:
            ConvertibleTypePropertiesClass.$properties
              .convertibleLiteralProperty["identifier"],
          preferredLanguages: $parameters.preferredLanguages,
          values,
        }),
      )
      .chain((values) => values.chainMap((value) => value.toLiteral()))
      .chain((values) => values.head());
    if (_convertibleLiteralPropertyEither.isLeft()) {
      return _convertibleLiteralPropertyEither;
    }

    const convertibleLiteralProperty =
      _convertibleLiteralPropertyEither.unsafeCoerce();
    const _convertibleLiteralSetPropertyEither: purify.Either<
      Error,
      readonly rdfjs.Literal[]
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.convertibleLiteralSetProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        $fromRdfPreferredLanguages({
          focusResource: $parameters.resource,
          predicate:
            ConvertibleTypePropertiesClass.$properties
              .convertibleLiteralSetProperty["identifier"],
          preferredLanguages: $parameters.preferredLanguages,
          values,
        }),
      )
      .chain((values) => values.chainMap((value) => value.toLiteral()))
      .map((values) => values.toArray())
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          focusResource: $parameters.resource,
          predicate:
            ConvertibleTypePropertiesClass.$properties
              .convertibleLiteralSetProperty["identifier"],
          value: valuesArray,
        }),
      )
      .chain((values) => values.head());
    if (_convertibleLiteralSetPropertyEither.isLeft()) {
      return _convertibleLiteralSetPropertyEither;
    }

    const convertibleLiteralSetProperty =
      _convertibleLiteralSetPropertyEither.unsafeCoerce();
    const _convertibleTermNonEmptySetPropertyEither: purify.Either<
      Error,
      purify.NonEmptyList<rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.convertibleTermNonEmptySetProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          purify.Either.of<
            Error,
            rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
          >(value.toTerm()),
        ),
      )
      .chain((values) =>
        purify.NonEmptyList.fromArray(values.toArray()).toEither(
          new Error(
            `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} is an empty set`,
          ),
        ),
      )
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          focusResource: $parameters.resource,
          predicate:
            ConvertibleTypePropertiesClass.$properties
              .convertibleTermNonEmptySetProperty["identifier"],
          value: valuesArray,
        }),
      )
      .chain((values) => values.head());
    if (_convertibleTermNonEmptySetPropertyEither.isLeft()) {
      return _convertibleTermNonEmptySetPropertyEither;
    }

    const convertibleTermNonEmptySetProperty =
      _convertibleTermNonEmptySetPropertyEither.unsafeCoerce();
    const _convertibleTermOptionPropertyEither: purify.Either<
      Error,
      purify.Maybe<rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode>
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.convertibleTermOptionProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          purify.Either.of<
            Error,
            rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
          >(value.toTerm()),
        ),
      )
      .map((values) =>
        values.length > 0
          ? values.map((value) => purify.Maybe.of(value))
          : rdfjsResource.Resource.Values.fromValue<
              purify.Maybe<rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode>
            >({
              focusResource: $parameters.resource,
              predicate:
                ConvertibleTypePropertiesClass.$properties
                  .convertibleTermOptionProperty["identifier"],
              value: purify.Maybe.empty(),
            }),
      )
      .chain((values) => values.head());
    if (_convertibleTermOptionPropertyEither.isLeft()) {
      return _convertibleTermOptionPropertyEither;
    }

    const convertibleTermOptionProperty =
      _convertibleTermOptionPropertyEither.unsafeCoerce();
    const _convertibleTermPropertyEither: purify.Either<
      Error,
      rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.convertibleTermProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          purify.Either.of<
            Error,
            rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
          >(value.toTerm()),
        ),
      )
      .chain((values) => values.head());
    if (_convertibleTermPropertyEither.isLeft()) {
      return _convertibleTermPropertyEither;
    }

    const convertibleTermProperty =
      _convertibleTermPropertyEither.unsafeCoerce();
    const _convertibleTermSetPropertyEither: purify.Either<
      Error,
      readonly (rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode)[]
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.convertibleTermSetProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        values.chainMap((value) =>
          purify.Either.of<
            Error,
            rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
          >(value.toTerm()),
        ),
      )
      .map((values) => values.toArray())
      .map((valuesArray) =>
        rdfjsResource.Resource.Values.fromValue({
          focusResource: $parameters.resource,
          predicate:
            ConvertibleTypePropertiesClass.$properties
              .convertibleTermSetProperty["identifier"],
          value: valuesArray,
        }),
      )
      .chain((values) => values.head());
    if (_convertibleTermSetPropertyEither.isLeft()) {
      return _convertibleTermSetPropertyEither;
    }

    const convertibleTermSetProperty =
      _convertibleTermSetPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      convertibleIriNonEmptySetProperty,
      convertibleIriOptionProperty,
      convertibleIriProperty,
      convertibleIriSetProperty,
      convertibleLiteralNonEmptySetProperty,
      convertibleLiteralOptionProperty,
      convertibleLiteralProperty,
      convertibleLiteralSetProperty,
      convertibleTermNonEmptySetProperty,
      convertibleTermOptionProperty,
      convertibleTermProperty,
      convertibleTermSetProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ConvertibleTypePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConvertibleTypePropertiesClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ConvertibleTypePropertiesClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ConvertibleTypePropertiesClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConvertibleTypePropertiesClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("convertibleTypePropertiesClass");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriNonEmptySetProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties
          .convertibleIriNonEmptySetProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriOptionProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties.convertibleIriOptionProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties.convertibleIriProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriSetProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties.convertibleIriSetProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralNonEmptySetProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties
          .convertibleLiteralNonEmptySetProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralOptionProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties
          .convertibleLiteralOptionProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties.convertibleLiteralProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralSetProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties
          .convertibleLiteralSetProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermNonEmptySetProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties
          .convertibleTermNonEmptySetProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermOptionProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties
          .convertibleTermOptionProperty["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties.convertibleTermProperty[
          "identifier"
        ],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermSetProperty`,
      ),
      predicate:
        ConvertibleTypePropertiesClass.$properties.convertibleTermSetProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ConvertibleTypePropertiesClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("convertibleTypePropertiesClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ConvertibleTypePropertiesClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriNonEmptySetProperty`,
            ),
            predicate:
              ConvertibleTypePropertiesClass.$properties
                .convertibleIriNonEmptySetProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(
            parameters?.filter?.convertibleIriNonEmptySetProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriNonEmptySetProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.convertibleIriOptionProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriOptionProperty`,
                  ),
                  predicate:
                    ConvertibleTypePropertiesClass.$properties
                      .convertibleIriOptionProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $NamedNodeFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriOptionProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriProperty`,
            ),
            predicate:
              ConvertibleTypePropertiesClass.$properties.convertibleIriProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: $NamedNodeFilter
          .$sparqlWherePatterns(
            parameters?.filter?.convertibleIriProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriSetProperty`,
              ),
              predicate:
                ConvertibleTypePropertiesClass.$properties
                  .convertibleIriSetProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: $NamedNodeFilter
            .$sparqlWherePatterns(
              parameters?.filter?.convertibleIriSetProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleIriSetProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralNonEmptySetProperty`,
            ),
            predicate:
              ConvertibleTypePropertiesClass.$properties
                .convertibleLiteralNonEmptySetProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralNonEmptySetProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $LiteralFilter
          .$sparqlWherePatterns(
            parameters?.filter?.convertibleLiteralNonEmptySetProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralNonEmptySetProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.convertibleLiteralOptionProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralOptionProperty`,
                  ),
                  predicate:
                    ConvertibleTypePropertiesClass.$properties
                      .convertibleLiteralOptionProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: [parameters?.preferredLanguages ?? []]
                .filter((languages) => languages.length > 0)
                .map((languages) =>
                  languages.map((language) => ({
                    type: "operation" as const,
                    operator: "=",
                    args: [
                      {
                        type: "operation" as const,
                        operator: "lang",
                        args: [
                          dataFactory.variable!(
                            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralOptionProperty`,
                          ),
                        ],
                      },
                      dataFactory.literal(language),
                    ],
                  })),
                )
                .map((langEqualsExpressions) => ({
                  type: "filter" as const,
                  expression: langEqualsExpressions.reduce(
                    (reducedExpression, langEqualsExpression) => {
                      if (reducedExpression === null) {
                        return langEqualsExpression;
                      }
                      return {
                        type: "operation" as const,
                        operator: "||",
                        args: [reducedExpression, langEqualsExpression],
                      };
                    },
                    null as sparqljs.Expression | null,
                  ) as sparqljs.Expression,
                }))
                .concat(),
              type: "group",
            },
            {
              patterns: $LiteralFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralOptionProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralProperty`,
            ),
            predicate:
              ConvertibleTypePropertiesClass.$properties
                .convertibleLiteralProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $LiteralFilter
          .$sparqlWherePatterns(
            parameters?.filter?.convertibleLiteralProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralSetProperty`,
              ),
              predicate:
                ConvertibleTypePropertiesClass.$properties
                  .convertibleLiteralSetProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: [parameters?.preferredLanguages ?? []]
            .filter((languages) => languages.length > 0)
            .map((languages) =>
              languages.map((language) => ({
                type: "operation" as const,
                operator: "=",
                args: [
                  {
                    type: "operation" as const,
                    operator: "lang",
                    args: [
                      dataFactory.variable!(
                        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralSetProperty`,
                      ),
                    ],
                  },
                  dataFactory.literal(language),
                ],
              })),
            )
            .map((langEqualsExpressions) => ({
              type: "filter" as const,
              expression: langEqualsExpressions.reduce(
                (reducedExpression, langEqualsExpression) => {
                  if (reducedExpression === null) {
                    return langEqualsExpression;
                  }
                  return {
                    type: "operation" as const,
                    operator: "||",
                    args: [reducedExpression, langEqualsExpression],
                  };
                },
                null as sparqljs.Expression | null,
              ) as sparqljs.Expression,
            }))
            .concat(),
          type: "group",
        },
        {
          patterns: $LiteralFilter
            .$sparqlWherePatterns(
              parameters?.filter?.convertibleLiteralSetProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleLiteralSetProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermNonEmptySetProperty`,
            ),
            predicate:
              ConvertibleTypePropertiesClass.$properties
                .convertibleTermNonEmptySetProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: $TermFilter
          .$sparqlWherePatterns(
            parameters?.filter?.convertibleTermNonEmptySetProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermNonEmptySetProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    patterns.push({
      patterns: $MaybeFilter
        .$sparqlWherePatterns(
          parameters?.filter?.convertibleTermOptionProperty,
          (itemFilter) => [
            {
              triples: [
                {
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermOptionProperty`,
                  ),
                  predicate:
                    ConvertibleTypePropertiesClass.$properties
                      .convertibleTermOptionProperty["identifier"],
                  subject: subject,
                },
              ],
              type: "bgp",
            },
            {
              patterns: $TermFilter
                .$sparqlWherePatterns(
                  itemFilter,
                  dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermOptionProperty`,
                  ),
                )
                .concat(),
              type: "group",
            },
          ],
        )
        .concat(),
      type: "group",
    });
    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermProperty`,
            ),
            predicate:
              ConvertibleTypePropertiesClass.$properties
                .convertibleTermProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: $TermFilter
          .$sparqlWherePatterns(
            parameters?.filter?.convertibleTermProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    patterns.push({
      patterns: [
        {
          triples: [
            {
              object: dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermSetProperty`,
              ),
              predicate:
                ConvertibleTypePropertiesClass.$properties
                  .convertibleTermSetProperty["identifier"],
              subject: subject,
            },
          ],
          type: "bgp",
        },
        {
          patterns: $TermFilter
            .$sparqlWherePatterns(
              parameters?.filter?.convertibleTermSetProperty,
              dataFactory.variable!(
                `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "convertibleTypePropertiesClass")}ConvertibleTermSetProperty`,
              ),
            )
            .concat(),
          type: "group",
        },
      ],
      type: "optional",
    });
    return patterns;
  }
}
/**
 * Base interface for other node shapes.
 */
export interface BaseInterfaceWithProperties {
  readonly $identifier: BaseInterfaceWithPropertiesStatic.$Identifier;
  readonly $type:
    | "BaseInterfaceWithProperties"
    | "BaseInterfaceWithoutProperties"
    | "ConcreteChildInterface"
    | "ConcreteParentInterface";
  readonly baseInterfaceWithPropertiesProperty: string;
}

export namespace BaseInterfaceWithPropertiesStatic {
  export function $create(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly baseInterfaceWithPropertiesProperty: string;
  }): BaseInterfaceWithProperties {
    let $identifier: BaseInterfaceWithPropertiesStatic.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "BaseInterfaceWithProperties" as const;
    const baseInterfaceWithPropertiesProperty =
      parameters.baseInterfaceWithPropertiesProperty;
    return { $identifier, $type, baseInterfaceWithPropertiesProperty };
  }

  export function $equals(
    left: BaseInterfaceWithProperties,
    right: BaseInterfaceWithProperties,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          left.baseInterfaceWithPropertiesProperty,
          right.baseInterfaceWithPropertiesProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "baseInterfaceWithPropertiesProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  export function $filter(
    filter: BaseInterfaceWithPropertiesStatic.$Filter,
    value: BaseInterfaceWithProperties,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.baseInterfaceWithPropertiesProperty !== "undefined" &&
      !$filterString(
        filter.baseInterfaceWithPropertiesProperty,
        value.baseInterfaceWithPropertiesProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly baseInterfaceWithPropertiesProperty?: $StringFilter;
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, BaseInterfaceWithProperties> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, BaseInterfaceWithProperties> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return BaseInterfaceWithPropertiesStatic.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/BaseInterfaceWithProperties",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _baseInterfaceWithProperties: BaseInterfaceWithProperties,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_baseInterfaceWithProperties.$identifier.value);
    _hasher.update(_baseInterfaceWithProperties.$type);
    BaseInterfaceWithPropertiesStatic.$hashShaclProperties(
      _baseInterfaceWithProperties,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _baseInterfaceWithProperties: BaseInterfaceWithProperties,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(
      _baseInterfaceWithProperties.baseInterfaceWithPropertiesProperty,
    );
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type:
      | "BaseInterfaceWithProperties"
      | "BaseInterfaceWithoutProperties"
      | "ConcreteChildInterface"
      | "ConcreteParentInterface";
    readonly baseInterfaceWithPropertiesProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "BaseInterfaceWithProperties" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/baseInterfaceWithPropertiesProperty`,
          type: "Control",
        },
      ],
      label: "BaseInterfaceWithProperties",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.enum([
        "BaseInterfaceWithProperties",
        "BaseInterfaceWithoutProperties",
        "ConcreteChildInterface",
        "ConcreteParentInterface",
      ]),
      baseInterfaceWithPropertiesProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    baseInterfaceWithPropertiesProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/baseInterfaceWithPropertiesProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type:
        | "BaseInterfaceWithProperties"
        | "BaseInterfaceWithoutProperties"
        | "ConcreteChildInterface"
        | "ConcreteParentInterface";
      baseInterfaceWithPropertiesProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "BaseInterfaceWithProperties" as const;
    const baseInterfaceWithPropertiesProperty =
      $jsonObject["baseInterfaceWithPropertiesProperty"];
    return purify.Either.of({
      $identifier,
      $type,
      baseInterfaceWithPropertiesProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type:
        | "BaseInterfaceWithProperties"
        | "BaseInterfaceWithoutProperties"
        | "ConcreteChildInterface"
        | "ConcreteParentInterface";
      baseInterfaceWithPropertiesProperty: string;
    }
  > {
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/BaseInterfaceWithProperties":
            case "http://example.com/BaseInterfaceWithoutProperties":
            case "http://example.com/ConcreteParentInterface":
            case "http://example.com/ConcreteChildInterface":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              BaseInterfaceWithPropertiesStatic.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/BaseInterfaceWithProperties)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: BaseInterfaceWithPropertiesStatic.$Identifier =
      $parameters.resource.identifier;
    const $type = "BaseInterfaceWithProperties" as const;
    const _baseInterfaceWithPropertiesPropertyEither: purify.Either<
      Error,
      string
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.baseInterfaceWithPropertiesProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        $fromRdfPreferredLanguages({
          focusResource: $parameters.resource,
          predicate:
            BaseInterfaceWithPropertiesStatic.$properties
              .baseInterfaceWithPropertiesProperty["identifier"],
          preferredLanguages: $parameters.preferredLanguages,
          values,
        }),
      )
      .chain((values) => values.chainMap((value) => value.toString()))
      .chain((values) => values.head());
    if (_baseInterfaceWithPropertiesPropertyEither.isLeft()) {
      return _baseInterfaceWithPropertiesPropertyEither;
    }

    const baseInterfaceWithPropertiesProperty =
      _baseInterfaceWithPropertiesPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      $type,
      baseInterfaceWithPropertiesProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: BaseInterfaceWithPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BaseInterfaceWithPropertiesStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            BaseInterfaceWithPropertiesStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: BaseInterfaceWithPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BaseInterfaceWithPropertiesStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("baseInterfaceWithProperties");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}BaseInterfaceWithPropertiesProperty`,
      ),
      predicate:
        BaseInterfaceWithPropertiesStatic.$properties
          .baseInterfaceWithPropertiesProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: BaseInterfaceWithPropertiesStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("baseInterfaceWithProperties");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        {
          type: "values" as const,
          values: [
            BaseInterfaceWithPropertiesStatic.$fromRdfType,
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[
              `?${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}FromRdfType`
            ] = identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}FromRdfType`,
          ),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}BaseInterfaceWithPropertiesProperty`,
            ),
            predicate:
              BaseInterfaceWithPropertiesStatic.$properties
                .baseInterfaceWithPropertiesProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}BaseInterfaceWithPropertiesProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.baseInterfaceWithPropertiesProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithProperties")}BaseInterfaceWithPropertiesProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _baseInterfaceWithProperties: BaseInterfaceWithProperties,
  ): BaseInterfaceWithPropertiesStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _baseInterfaceWithProperties.$identifier.termType === "BlankNode"
            ? `_:${_baseInterfaceWithProperties.$identifier.value}`
            : _baseInterfaceWithProperties.$identifier.value,
        $type: _baseInterfaceWithProperties.$type,
        baseInterfaceWithPropertiesProperty:
          _baseInterfaceWithProperties.baseInterfaceWithPropertiesProperty,
      } satisfies BaseInterfaceWithPropertiesStatic.$Json),
    );
  }

  export function $toRdf(
    _baseInterfaceWithProperties: BaseInterfaceWithProperties,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _baseInterfaceWithProperties.$identifier,
      { mutateGraph },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/BaseInterfaceWithProperties",
        ),
      );
    }

    resource.add(
      BaseInterfaceWithPropertiesStatic.$properties
        .baseInterfaceWithPropertiesProperty["identifier"],
      ...[_baseInterfaceWithProperties.baseInterfaceWithPropertiesProperty],
    );
    return resource;
  }
}
/**
 * Base interface for other node shapes. Put the base interface with properties above the base interface without.
 */
export interface BaseInterfaceWithoutProperties
  extends BaseInterfaceWithProperties {
  readonly $identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier;
  readonly $type:
    | "BaseInterfaceWithoutProperties"
    | "ConcreteChildInterface"
    | "ConcreteParentInterface";
}

export namespace BaseInterfaceWithoutPropertiesStatic {
  export function $create(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & Parameters<typeof BaseInterfaceWithPropertiesStatic.$create>[0],
  ): BaseInterfaceWithoutProperties {
    let $identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "BaseInterfaceWithoutProperties" as const;
    return {
      ...BaseInterfaceWithPropertiesStatic.$create(parameters),
      $identifier,
      $type,
    };
  }

  export function $equals(
    left: BaseInterfaceWithoutProperties,
    right: BaseInterfaceWithoutProperties,
  ): $EqualsResult {
    return BaseInterfaceWithPropertiesStatic.$equals(left, right);
  }

  export function $filter(
    filter: BaseInterfaceWithoutPropertiesStatic.$Filter,
    value: BaseInterfaceWithoutProperties,
  ): boolean {
    if (!BaseInterfaceWithPropertiesStatic.$filter(filter, value)) {
      return false;
    }

    return true;
  }

  export type $Filter = BaseInterfaceWithPropertiesStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, BaseInterfaceWithoutProperties> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, BaseInterfaceWithoutProperties> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return BaseInterfaceWithoutPropertiesStatic.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/BaseInterfaceWithoutProperties",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _baseInterfaceWithoutProperties: BaseInterfaceWithoutProperties,
    _hasher: HasherT,
  ): HasherT {
    BaseInterfaceWithoutPropertiesStatic.$hashShaclProperties(
      _baseInterfaceWithoutProperties,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _baseInterfaceWithoutProperties: BaseInterfaceWithoutProperties,
    _hasher: HasherT,
  ): HasherT {
    BaseInterfaceWithPropertiesStatic.$hashShaclProperties(
      _baseInterfaceWithoutProperties,
      _hasher,
    );
    return _hasher;
  }

  export type $Identifier = BaseInterfaceWithPropertiesStatic.$Identifier;
  export const $Identifier = BaseInterfaceWithPropertiesStatic.$Identifier;
  export type $Json = BaseInterfaceWithPropertiesStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseInterfaceWithPropertiesStatic.$jsonUiSchema({ scopePrefix }),
      ],
      label: "BaseInterfaceWithoutProperties",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return BaseInterfaceWithPropertiesStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "BaseInterfaceWithoutProperties",
          "ConcreteChildInterface",
          "ConcreteParentInterface",
        ]),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    ...BaseInterfaceWithPropertiesStatic.$properties,
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type:
        | "BaseInterfaceWithoutProperties"
        | "ConcreteChildInterface"
        | "ConcreteParentInterface";
    } & $UnwrapR<
      ReturnType<typeof BaseInterfaceWithPropertiesStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      BaseInterfaceWithPropertiesStatic.$propertiesFromJson($jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "BaseInterfaceWithoutProperties" as const;
    return purify.Either.of({ ...$super0, $identifier, $type });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type:
        | "BaseInterfaceWithoutProperties"
        | "ConcreteChildInterface"
        | "ConcreteParentInterface";
    } & $UnwrapR<
      ReturnType<typeof BaseInterfaceWithPropertiesStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = BaseInterfaceWithPropertiesStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/BaseInterfaceWithoutProperties":
            case "http://example.com/ConcreteParentInterface":
            case "http://example.com/ConcreteChildInterface":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/BaseInterfaceWithoutProperties)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier =
      $parameters.resource.identifier;
    const $type = "BaseInterfaceWithoutProperties" as const;
    return purify.Either.of({ ...$super0, $identifier, $type });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: BaseInterfaceWithoutPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BaseInterfaceWithoutPropertiesStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            BaseInterfaceWithoutPropertiesStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: BaseInterfaceWithoutPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BaseInterfaceWithoutPropertiesStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("baseInterfaceWithoutProperties");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...BaseInterfaceWithPropertiesStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "baseInterfaceWithoutProperties"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithoutProperties")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithoutProperties")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithoutProperties")}RdfClass`,
          ),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: BaseInterfaceWithoutPropertiesStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("baseInterfaceWithoutProperties");
    patterns.push(
      ...BaseInterfaceWithPropertiesStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "baseInterfaceWithoutProperties"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithoutProperties")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        {
          type: "values" as const,
          values: [
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[
              `?${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithoutProperties")}FromRdfType`
            ] = identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithoutProperties")}FromRdfType`,
          ),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseInterfaceWithoutProperties")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    return patterns;
  }

  export function $toJson(
    _baseInterfaceWithoutProperties: BaseInterfaceWithoutProperties,
  ): BaseInterfaceWithoutPropertiesStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...BaseInterfaceWithPropertiesStatic.$toJson(
          _baseInterfaceWithoutProperties,
        ),
      } satisfies BaseInterfaceWithoutPropertiesStatic.$Json),
    );
  }

  export function $toRdf(
    _baseInterfaceWithoutProperties: BaseInterfaceWithoutProperties,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = BaseInterfaceWithPropertiesStatic.$toRdf(
      _baseInterfaceWithoutProperties,
      { ignoreRdfType: true, mutateGraph, resourceSet },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/BaseInterfaceWithoutProperties",
        ),
      );
    }

    return resource;
  }

  export function isBaseInterfaceWithoutProperties(
    object: BaseInterfaceWithProperties,
  ): object is BaseInterfaceWithoutProperties {
    switch (object.$type) {
      case "ConcreteChildInterface":
      case "ConcreteParentInterface":
      case "BaseInterfaceWithoutProperties":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Interface node shape that inherits the base interface and is the parent of the ConcreteChildInterface.
 */
export interface ConcreteParentInterface
  extends BaseInterfaceWithoutProperties {
  readonly $identifier: ConcreteParentInterfaceStatic.$Identifier;
  readonly $type: "ConcreteParentInterface" | "ConcreteChildInterface";
  readonly concreteParentInterfaceProperty: string;
}

export namespace ConcreteParentInterfaceStatic {
  export function $create(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly concreteParentInterfaceProperty: string;
    } & Parameters<typeof BaseInterfaceWithoutPropertiesStatic.$create>[0],
  ): ConcreteParentInterface {
    let $identifier: ConcreteParentInterfaceStatic.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "ConcreteParentInterface" as const;
    const concreteParentInterfaceProperty =
      parameters.concreteParentInterfaceProperty;
    return {
      ...BaseInterfaceWithoutPropertiesStatic.$create(parameters),
      $identifier,
      $type,
      concreteParentInterfaceProperty,
    };
  }

  export function $equals(
    left: ConcreteParentInterface,
    right: ConcreteParentInterface,
  ): $EqualsResult {
    return BaseInterfaceWithoutPropertiesStatic.$equals(left, right).chain(() =>
      $strictEquals(
        left.concreteParentInterfaceProperty,
        right.concreteParentInterfaceProperty,
      ).mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "concreteParentInterfaceProperty",
        propertyValuesUnequal,
        type: "Property" as const,
      })),
    );
  }

  export function $filter(
    filter: ConcreteParentInterfaceStatic.$Filter,
    value: ConcreteParentInterface,
  ): boolean {
    if (!BaseInterfaceWithoutPropertiesStatic.$filter(filter, value)) {
      return false;
    }

    if (
      typeof filter.concreteParentInterfaceProperty !== "undefined" &&
      !$filterString(
        filter.concreteParentInterfaceProperty,
        value.concreteParentInterfaceProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly concreteParentInterfaceProperty?: $StringFilter;
  } & BaseInterfaceWithoutPropertiesStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ConcreteParentInterface> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ConcreteParentInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ConcreteParentInterfaceStatic.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ConcreteParentInterface",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _concreteParentInterface: ConcreteParentInterface,
    _hasher: HasherT,
  ): HasherT {
    ConcreteParentInterfaceStatic.$hashShaclProperties(
      _concreteParentInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _concreteParentInterface: ConcreteParentInterface,
    _hasher: HasherT,
  ): HasherT {
    BaseInterfaceWithoutPropertiesStatic.$hashShaclProperties(
      _concreteParentInterface,
      _hasher,
    );
    _hasher.update(_concreteParentInterface.concreteParentInterfaceProperty);
    return _hasher;
  }

  export type $Identifier = BaseInterfaceWithoutPropertiesStatic.$Identifier;
  export const $Identifier = BaseInterfaceWithoutPropertiesStatic.$Identifier;
  export type $Json = {
    readonly concreteParentInterfaceProperty: string;
  } & BaseInterfaceWithoutPropertiesStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseInterfaceWithoutPropertiesStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/concreteParentInterfaceProperty`,
          type: "Control",
        },
      ],
      label: "ConcreteParentInterface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return BaseInterfaceWithoutPropertiesStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["ConcreteParentInterface", "ConcreteChildInterface"]),
        concreteParentInterfaceProperty: zod.string(),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    ...BaseInterfaceWithoutPropertiesStatic.$properties,
    concreteParentInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/concreteParentInterfaceProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "ConcreteParentInterface" | "ConcreteChildInterface";
      concreteParentInterfaceProperty: string;
    } & $UnwrapR<
      ReturnType<
        typeof BaseInterfaceWithoutPropertiesStatic.$propertiesFromJson
      >
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      BaseInterfaceWithoutPropertiesStatic.$propertiesFromJson($jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "ConcreteParentInterface" as const;
    const concreteParentInterfaceProperty =
      $jsonObject["concreteParentInterfaceProperty"];
    return purify.Either.of({
      ...$super0,
      $identifier,
      $type,
      concreteParentInterfaceProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "ConcreteParentInterface" | "ConcreteChildInterface";
      concreteParentInterfaceProperty: string;
    } & $UnwrapR<
      ReturnType<typeof BaseInterfaceWithoutPropertiesStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either =
      BaseInterfaceWithoutPropertiesStatic.$propertiesFromRdf({
        ...$parameters,
        ignoreRdfType: true,
      });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/ConcreteParentInterface":
            case "http://example.com/ConcreteChildInterface":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              ConcreteParentInterfaceStatic.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ConcreteParentInterface)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: ConcreteParentInterfaceStatic.$Identifier =
      $parameters.resource.identifier;
    const $type = "ConcreteParentInterface" as const;
    const _concreteParentInterfacePropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.concreteParentInterfaceProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              ConcreteParentInterfaceStatic.$properties
                .concreteParentInterfaceProperty["identifier"],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_concreteParentInterfacePropertyEither.isLeft()) {
      return _concreteParentInterfacePropertyEither;
    }

    const concreteParentInterfaceProperty =
      _concreteParentInterfacePropertyEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      $type,
      concreteParentInterfaceProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ConcreteParentInterfaceStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConcreteParentInterfaceStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ConcreteParentInterfaceStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ConcreteParentInterfaceStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConcreteParentInterfaceStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteParentInterface");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...BaseInterfaceWithoutPropertiesStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteParentInterface"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}ConcreteParentInterfaceProperty`,
      ),
      predicate:
        ConcreteParentInterfaceStatic.$properties
          .concreteParentInterfaceProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ConcreteParentInterfaceStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteParentInterface");
    patterns.push(
      ...BaseInterfaceWithoutPropertiesStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteParentInterface"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        {
          type: "values" as const,
          values: [
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[
              `?${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}FromRdfType`
            ] = identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}FromRdfType`,
          ),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}ConcreteParentInterfaceProperty`,
            ),
            predicate:
              ConcreteParentInterfaceStatic.$properties
                .concreteParentInterfaceProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}ConcreteParentInterfaceProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.concreteParentInterfaceProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentInterface")}ConcreteParentInterfaceProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _concreteParentInterface: ConcreteParentInterface,
  ): ConcreteParentInterfaceStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...BaseInterfaceWithoutPropertiesStatic.$toJson(
          _concreteParentInterface,
        ),
        concreteParentInterfaceProperty:
          _concreteParentInterface.concreteParentInterfaceProperty,
      } satisfies ConcreteParentInterfaceStatic.$Json),
    );
  }

  export function $toRdf(
    _concreteParentInterface: ConcreteParentInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = BaseInterfaceWithoutPropertiesStatic.$toRdf(
      _concreteParentInterface,
      { ignoreRdfType: true, mutateGraph, resourceSet },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/ConcreteParentInterface",
        ),
      );
    }

    resource.add(
      ConcreteParentInterfaceStatic.$properties.concreteParentInterfaceProperty[
        "identifier"
      ],
      ...[_concreteParentInterface.concreteParentInterfaceProperty],
    );
    return resource;
  }

  export function isConcreteParentInterface(
    object: BaseInterfaceWithProperties,
  ): object is ConcreteParentInterface {
    switch (object.$type) {
      case "ConcreteChildInterface":
      case "ConcreteParentInterface":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Child interface of ConcreteParentInterface. Should inherit properties and node kinds.
 */
export interface ConcreteChildInterface extends ConcreteParentInterface {
  readonly $identifier: ConcreteChildInterface.$Identifier;
  readonly $type: "ConcreteChildInterface";
  readonly concreteChildInterfaceProperty: string;
}

export namespace ConcreteChildInterface {
  export function $create(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly concreteChildInterfaceProperty: string;
    } & Parameters<typeof ConcreteParentInterfaceStatic.$create>[0],
  ): ConcreteChildInterface {
    let $identifier: ConcreteChildInterface.$Identifier;
    if (typeof parameters.$identifier === "object") {
      $identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters.$identifier satisfies never;
    }

    const $type = "ConcreteChildInterface" as const;
    const concreteChildInterfaceProperty =
      parameters.concreteChildInterfaceProperty;
    return {
      ...ConcreteParentInterfaceStatic.$create(parameters),
      $identifier,
      $type,
      concreteChildInterfaceProperty,
    };
  }

  export function $equals(
    left: ConcreteChildInterface,
    right: ConcreteChildInterface,
  ): $EqualsResult {
    return ConcreteParentInterfaceStatic.$equals(left, right).chain(() =>
      $strictEquals(
        left.concreteChildInterfaceProperty,
        right.concreteChildInterfaceProperty,
      ).mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "concreteChildInterfaceProperty",
        propertyValuesUnequal,
        type: "Property" as const,
      })),
    );
  }

  export function $filter(
    filter: ConcreteChildInterface.$Filter,
    value: ConcreteChildInterface,
  ): boolean {
    if (!ConcreteParentInterfaceStatic.$filter(filter, value)) {
      return false;
    }

    if (
      typeof filter.concreteChildInterfaceProperty !== "undefined" &&
      !$filterString(
        filter.concreteChildInterfaceProperty,
        value.concreteChildInterfaceProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly concreteChildInterfaceProperty?: $StringFilter;
  } & ConcreteParentInterfaceStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ConcreteChildInterface> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ConcreteChildInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ConcreteChildInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ConcreteChildInterface",
  );

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _concreteChildInterface: ConcreteChildInterface,
    _hasher: HasherT,
  ): HasherT {
    ConcreteChildInterface.$hashShaclProperties(
      _concreteChildInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _concreteChildInterface: ConcreteChildInterface,
    _hasher: HasherT,
  ): HasherT {
    ConcreteParentInterfaceStatic.$hashShaclProperties(
      _concreteChildInterface,
      _hasher,
    );
    _hasher.update(_concreteChildInterface.concreteChildInterfaceProperty);
    return _hasher;
  }

  export type $Identifier = ConcreteParentInterfaceStatic.$Identifier;
  export const $Identifier = ConcreteParentInterfaceStatic.$Identifier;
  export type $Json = {
    readonly concreteChildInterfaceProperty: string;
  } & ConcreteParentInterfaceStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ConcreteParentInterfaceStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/concreteChildInterfaceProperty`,
          type: "Control",
        },
      ],
      label: "ConcreteChildInterface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ConcreteParentInterfaceStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("ConcreteChildInterface"),
        concreteChildInterfaceProperty: zod.string(),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    ...ConcreteParentInterfaceStatic.$properties,
    concreteChildInterfaceProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/concreteChildInterfaceProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "ConcreteChildInterface";
      concreteChildInterfaceProperty: string;
    } & $UnwrapR<
      ReturnType<typeof ConcreteParentInterfaceStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      ConcreteParentInterfaceStatic.$propertiesFromJson($jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "ConcreteChildInterface" as const;
    const concreteChildInterfaceProperty =
      $jsonObject["concreteChildInterfaceProperty"];
    return purify.Either.of({
      ...$super0,
      $identifier,
      $type,
      concreteChildInterfaceProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "ConcreteChildInterface";
      concreteChildInterfaceProperty: string;
    } & $UnwrapR<
      ReturnType<typeof ConcreteParentInterfaceStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = ConcreteParentInterfaceStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/ConcreteChildInterface":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              ConcreteChildInterface.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ConcreteChildInterface)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: ConcreteChildInterface.$Identifier =
      $parameters.resource.identifier;
    const $type = "ConcreteChildInterface" as const;
    const _concreteChildInterfacePropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.concreteChildInterfaceProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              ConcreteChildInterface.$properties.concreteChildInterfaceProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_concreteChildInterfacePropertyEither.isLeft()) {
      return _concreteChildInterfacePropertyEither;
    }

    const concreteChildInterfaceProperty =
      _concreteChildInterfacePropertyEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      $type,
      concreteChildInterfaceProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ConcreteChildInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConcreteChildInterface.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ConcreteChildInterface.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ConcreteChildInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConcreteChildInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteChildInterface");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...ConcreteParentInterfaceStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteChildInterface"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildInterface")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildInterface")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildInterface")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildInterface")}ConcreteChildInterfaceProperty`,
      ),
      predicate:
        ConcreteChildInterface.$properties.concreteChildInterfaceProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ConcreteChildInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteChildInterface");
    patterns.push(
      ...ConcreteParentInterfaceStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteChildInterface"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildInterface")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ConcreteChildInterface.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildInterface")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildInterface")}ConcreteChildInterfaceProperty`,
            ),
            predicate:
              ConcreteChildInterface.$properties.concreteChildInterfaceProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildInterface")}ConcreteChildInterfaceProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.concreteChildInterfaceProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildInterface")}ConcreteChildInterfaceProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function $toJson(
    _concreteChildInterface: ConcreteChildInterface,
  ): ConcreteChildInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        ...ConcreteParentInterfaceStatic.$toJson(_concreteChildInterface),
        concreteChildInterfaceProperty:
          _concreteChildInterface.concreteChildInterfaceProperty,
      } satisfies ConcreteChildInterface.$Json),
    );
  }

  export function $toRdf(
    _concreteChildInterface: ConcreteChildInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = ConcreteParentInterfaceStatic.$toRdf(
      _concreteChildInterface,
      { ignoreRdfType: true, mutateGraph, resourceSet },
    );
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/ConcreteChildInterface",
        ),
      );
    }

    resource.add(
      ConcreteChildInterface.$properties.concreteChildInterfaceProperty[
        "identifier"
      ],
      ...[_concreteChildInterface.concreteChildInterfaceProperty],
    );
    return resource;
  }

  export function isConcreteChildInterface(
    object: BaseInterfaceWithProperties,
  ): object is ConcreteChildInterface {
    switch (object.$type) {
      case "ConcreteChildInterface":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape that serves as an abstract base class for child node shapes.
 *
 * It's marked abstract in TypeScript and not exported from the module.
 *
 * Common pattern: put the minting strategy and nodeKind on an ABC.
 */
export abstract class AbstractBaseClassWithProperties {
  protected _$identifier?: AbstractBaseClassWithPropertiesStatic.$Identifier;
  protected readonly _$identifierPrefix?: string;
  abstract readonly $type: "ConcreteChildClass" | "ConcreteParentClass";
  readonly abstractBaseClassWithPropertiesProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly $identifierPrefix?: string;
    readonly abstractBaseClassWithPropertiesProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this._$identifierPrefix = parameters.$identifierPrefix;
    this.abstractBaseClassWithPropertiesProperty =
      parameters.abstractBaseClassWithPropertiesProperty;
  }

  get $identifier(): AbstractBaseClassWithPropertiesStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }

    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  $equals(other: AbstractBaseClassWithProperties): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$identifierPrefix, other.$identifierPrefix).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$identifierPrefix",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.abstractBaseClassWithPropertiesProperty,
          other.abstractBaseClassWithPropertiesProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "abstractBaseClassWithPropertiesProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.abstractBaseClassWithPropertiesProperty);
    return _hasher;
  }

  $toJson(): AbstractBaseClassWithPropertiesStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        abstractBaseClassWithPropertiesProperty:
          this.abstractBaseClassWithPropertiesProperty,
      } satisfies AbstractBaseClassWithPropertiesStatic.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      AbstractBaseClassWithPropertiesStatic.$properties
        .abstractBaseClassWithPropertiesProperty["identifier"],
      ...[this.abstractBaseClassWithPropertiesProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace AbstractBaseClassWithPropertiesStatic {
  export function $filter(
    filter: AbstractBaseClassWithPropertiesStatic.$Filter,
    value: AbstractBaseClassWithProperties,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.abstractBaseClassWithPropertiesProperty !== "undefined" &&
      !$filterString(
        filter.abstractBaseClassWithPropertiesProperty,
        value.abstractBaseClassWithPropertiesProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly abstractBaseClassWithPropertiesProperty?: $StringFilter;
  };
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ConcreteChildClass" | "ConcreteParentClass";
    readonly abstractBaseClassWithPropertiesProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "AbstractBaseClassWithProperties" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/abstractBaseClassWithPropertiesProperty`,
          type: "Control",
        },
      ],
      label: "AbstractBaseClassWithProperties",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.enum(["ConcreteChildClass", "ConcreteParentClass"]),
      abstractBaseClassWithPropertiesProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    abstractBaseClassWithPropertiesProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/abstractBaseClassWithPropertiesProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      abstractBaseClassWithPropertiesProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const abstractBaseClassWithPropertiesProperty =
      $jsonObject["abstractBaseClassWithPropertiesProperty"];
    return purify.Either.of({
      $identifier,
      abstractBaseClassWithPropertiesProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      abstractBaseClassWithPropertiesProperty: string;
    }
  > {
    const $identifier: AbstractBaseClassWithPropertiesStatic.$Identifier =
      $parameters.resource.identifier;
    const _abstractBaseClassWithPropertiesPropertyEither: purify.Either<
      Error,
      string
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.abstractBaseClassWithPropertiesProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        $fromRdfPreferredLanguages({
          focusResource: $parameters.resource,
          predicate:
            AbstractBaseClassWithPropertiesStatic.$properties
              .abstractBaseClassWithPropertiesProperty["identifier"],
          preferredLanguages: $parameters.preferredLanguages,
          values,
        }),
      )
      .chain((values) => values.chainMap((value) => value.toString()))
      .chain((values) => values.head());
    if (_abstractBaseClassWithPropertiesPropertyEither.isLeft()) {
      return _abstractBaseClassWithPropertiesPropertyEither;
    }

    const abstractBaseClassWithPropertiesProperty =
      _abstractBaseClassWithPropertiesPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      abstractBaseClassWithPropertiesProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: AbstractBaseClassWithPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        AbstractBaseClassWithPropertiesStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            AbstractBaseClassWithPropertiesStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: AbstractBaseClassWithPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      AbstractBaseClassWithPropertiesStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassWithProperties");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "abstractBaseClassWithProperties")}AbstractBaseClassWithPropertiesProperty`,
      ),
      predicate:
        AbstractBaseClassWithPropertiesStatic.$properties
          .abstractBaseClassWithPropertiesProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: AbstractBaseClassWithPropertiesStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassWithProperties");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "abstractBaseClassWithProperties")}AbstractBaseClassWithPropertiesProperty`,
            ),
            predicate:
              AbstractBaseClassWithPropertiesStatic.$properties
                .abstractBaseClassWithPropertiesProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "abstractBaseClassWithProperties")}AbstractBaseClassWithPropertiesProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.abstractBaseClassWithPropertiesProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "abstractBaseClassWithProperties")}AbstractBaseClassWithPropertiesProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
/**
 * Abstract base for other node shapes. Put the ABC with properties above the ABC without.
 */
export abstract class AbstractBaseClassWithoutProperties extends AbstractBaseClassWithProperties {
  abstract override readonly $type:
    | "ConcreteChildClass"
    | "ConcreteParentClass";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: { readonly $identifierPrefix?: string } & ConstructorParameters<
      typeof AbstractBaseClassWithProperties
    >[0],
  ) {
    super(parameters);
  }

  override get $identifier(): AbstractBaseClassWithoutPropertiesStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }

    return this._$identifier;
  }

  protected override get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace AbstractBaseClassWithoutPropertiesStatic {
  export function $filter(
    filter: AbstractBaseClassWithoutPropertiesStatic.$Filter,
    value: AbstractBaseClassWithoutProperties,
  ): boolean {
    if (!AbstractBaseClassWithPropertiesStatic.$filter(filter, value)) {
      return false;
    }

    return true;
  }

  export type $Filter = AbstractBaseClassWithPropertiesStatic.$Filter;
  export type $Identifier = AbstractBaseClassWithPropertiesStatic.$Identifier;
  export const $Identifier = AbstractBaseClassWithPropertiesStatic.$Identifier;
  export type $Json = AbstractBaseClassWithPropertiesStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        AbstractBaseClassWithPropertiesStatic.$jsonUiSchema({ scopePrefix }),
      ],
      label: "AbstractBaseClassWithoutProperties",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return AbstractBaseClassWithPropertiesStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["ConcreteChildClass", "ConcreteParentClass"]),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    ...AbstractBaseClassWithPropertiesStatic.$properties,
  };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<
        typeof AbstractBaseClassWithPropertiesStatic.$propertiesFromJson
      >
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      AbstractBaseClassWithPropertiesStatic.$propertiesFromJson($jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<
        typeof AbstractBaseClassWithPropertiesStatic.$propertiesFromRdf
      >
    >
  > {
    const $super0Either =
      AbstractBaseClassWithPropertiesStatic.$propertiesFromRdf({
        ...$parameters,
        ignoreRdfType: true,
      });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier: AbstractBaseClassWithoutPropertiesStatic.$Identifier =
      $parameters.resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: AbstractBaseClassWithoutPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        AbstractBaseClassWithoutPropertiesStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            AbstractBaseClassWithoutPropertiesStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: AbstractBaseClassWithoutPropertiesStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      AbstractBaseClassWithoutPropertiesStatic.$sparqlConstructQuery(
        parameters,
      ),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassWithoutProperties");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...AbstractBaseClassWithPropertiesStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "abstractBaseClassWithoutProperties"),
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: AbstractBaseClassWithoutPropertiesStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassWithoutProperties");
    patterns.push(
      ...AbstractBaseClassWithPropertiesStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "abstractBaseClassWithoutProperties"),
      }),
    );
    return patterns;
  }

  export function isAbstractBaseClassWithoutProperties(
    object: AbstractBaseClassWithProperties,
  ): object is AbstractBaseClassWithoutProperties {
    switch (object.$type) {
      case "ConcreteChildClass":
      case "ConcreteParentClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Class node shape that inherits the abstract base class and is the parent of the ConcreteChildClass.
 */
export class ConcreteParentClass extends AbstractBaseClassWithoutProperties {
  override readonly $type: "ConcreteParentClass" | "ConcreteChildClass" =
    "ConcreteParentClass";
  readonly concreteParentClassProperty: string;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly $identifierPrefix?: string;
      readonly concreteParentClassProperty: string;
    } & ConstructorParameters<typeof AbstractBaseClassWithoutProperties>[0],
  ) {
    super(parameters);
    this.concreteParentClassProperty = parameters.concreteParentClassProperty;
  }

  override get $identifier(): ConcreteParentClassStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }

    return this._$identifier;
  }

  protected override get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  override $equals(other: ConcreteParentClass): $EqualsResult {
    return super.$equals(other).chain(() =>
      $strictEquals(
        this.concreteParentClassProperty,
        other.concreteParentClassProperty,
      ).mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "concreteParentClassProperty",
        propertyValuesUnequal,
        type: "Property" as const,
      })),
    );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    _hasher.update(this.concreteParentClassProperty);
    return _hasher;
  }

  override $toJson(): ConcreteParentClassStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        concreteParentClassProperty: this.concreteParentClassProperty,
      } satisfies ConcreteParentClassStatic.$Json),
    );
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/ConcreteParentClass",
        ),
      );
    }

    resource.add(
      ConcreteParentClassStatic.$properties.concreteParentClassProperty[
        "identifier"
      ],
      ...[this.concreteParentClassProperty],
    );
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ConcreteParentClassStatic {
  export function $filter(
    filter: ConcreteParentClassStatic.$Filter,
    value: ConcreteParentClass,
  ): boolean {
    if (!AbstractBaseClassWithoutPropertiesStatic.$filter(filter, value)) {
      return false;
    }

    if (
      typeof filter.concreteParentClassProperty !== "undefined" &&
      !$filterString(
        filter.concreteParentClassProperty,
        value.concreteParentClassProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly concreteParentClassProperty?: $StringFilter;
  } & AbstractBaseClassWithoutPropertiesStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ConcreteParentClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ConcreteParentClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ConcreteParentClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ConcreteParentClassStatic.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ConcreteParentClass(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ConcreteParentClass",
  );
  export type $Identifier =
    AbstractBaseClassWithoutPropertiesStatic.$Identifier;
  export const $Identifier =
    AbstractBaseClassWithoutPropertiesStatic.$Identifier;
  export type $Json = {
    readonly concreteParentClassProperty: string;
  } & AbstractBaseClassWithoutPropertiesStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        AbstractBaseClassWithoutPropertiesStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/concreteParentClassProperty`,
          type: "Control",
        },
      ],
      label: "ConcreteParentClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return AbstractBaseClassWithoutPropertiesStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["ConcreteParentClass", "ConcreteChildClass"]),
        concreteParentClassProperty: zod.string(),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    ...AbstractBaseClassWithoutPropertiesStatic.$properties,
    concreteParentClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/concreteParentClassProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      concreteParentClassProperty: string;
    } & $UnwrapR<
      ReturnType<
        typeof AbstractBaseClassWithoutPropertiesStatic.$propertiesFromJson
      >
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      AbstractBaseClassWithoutPropertiesStatic.$propertiesFromJson($jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const concreteParentClassProperty =
      $jsonObject["concreteParentClassProperty"];
    return purify.Either.of({
      ...$super0,
      $identifier,
      concreteParentClassProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      concreteParentClassProperty: string;
    } & $UnwrapR<
      ReturnType<
        typeof AbstractBaseClassWithoutPropertiesStatic.$propertiesFromRdf
      >
    >
  > {
    const $super0Either =
      AbstractBaseClassWithoutPropertiesStatic.$propertiesFromRdf({
        ...$parameters,
        ignoreRdfType: true,
      });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/ConcreteParentClass":
            case "http://example.com/ConcreteChildClass":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              ConcreteParentClassStatic.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ConcreteParentClass)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: ConcreteParentClassStatic.$Identifier =
      $parameters.resource.identifier;
    const _concreteParentClassPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.concreteParentClassProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              ConcreteParentClassStatic.$properties.concreteParentClassProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_concreteParentClassPropertyEither.isLeft()) {
      return _concreteParentClassPropertyEither;
    }

    const concreteParentClassProperty =
      _concreteParentClassPropertyEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      concreteParentClassProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ConcreteParentClassStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConcreteParentClassStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ConcreteParentClassStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ConcreteParentClassStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConcreteParentClassStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteParentClass");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...AbstractBaseClassWithoutPropertiesStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteParentClass"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}ConcreteParentClassProperty`,
      ),
      predicate:
        ConcreteParentClassStatic.$properties.concreteParentClassProperty[
          "identifier"
        ],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ConcreteParentClassStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteParentClass");
    patterns.push(
      ...AbstractBaseClassWithoutPropertiesStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteParentClass"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        {
          type: "values" as const,
          values: [
            ConcreteParentClassStatic.$fromRdfType,
            ConcreteChildClass.$fromRdfType,
          ].map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[
              `?${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}FromRdfType`
            ] = identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        },
        $sparqlInstancesOfPattern({
          rdfType: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}FromRdfType`,
          ),
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}ConcreteParentClassProperty`,
            ),
            predicate:
              ConcreteParentClassStatic.$properties.concreteParentClassProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}ConcreteParentClassProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.concreteParentClassProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteParentClass")}ConcreteParentClassProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isConcreteParentClass(
    object: AbstractBaseClassWithProperties,
  ): object is ConcreteParentClass {
    switch (object.$type) {
      case "ConcreteChildClass":
      case "ConcreteParentClass":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Child (class) of ConcreteParentClass. Should inherit properties, node kinds, and minting strategy.
 */
export class ConcreteChildClass extends ConcreteParentClass {
  override readonly $type = "ConcreteChildClass";
  readonly concreteChildClassProperty: string;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly $identifierPrefix?: string;
      readonly concreteChildClassProperty: string;
    } & ConstructorParameters<typeof ConcreteParentClass>[0],
  ) {
    super(parameters);
    this.concreteChildClassProperty = parameters.concreteChildClassProperty;
  }

  override get $identifier(): ConcreteChildClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }

    return this._$identifier;
  }

  protected override get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  override $equals(other: ConcreteChildClass): $EqualsResult {
    return super.$equals(other).chain(() =>
      $strictEquals(
        this.concreteChildClassProperty,
        other.concreteChildClassProperty,
      ).mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "concreteChildClassProperty",
        propertyValuesUnequal,
        type: "Property" as const,
      })),
    );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    _hasher.update(this.concreteChildClassProperty);
    return _hasher;
  }

  override $toJson(): ConcreteChildClass.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        concreteChildClassProperty: this.concreteChildClassProperty,
      } satisfies ConcreteChildClass.$Json),
    );
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode("http://example.com/ConcreteChildClass"),
      );
    }

    resource.add(
      ConcreteChildClass.$properties.concreteChildClassProperty["identifier"],
      ...[this.concreteChildClassProperty],
    );
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ConcreteChildClass {
  export function $filter(
    filter: ConcreteChildClass.$Filter,
    value: ConcreteChildClass,
  ): boolean {
    if (!ConcreteParentClassStatic.$filter(filter, value)) {
      return false;
    }

    if (
      typeof filter.concreteChildClassProperty !== "undefined" &&
      !$filterString(
        filter.concreteChildClassProperty,
        value.concreteChildClassProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly concreteChildClassProperty?: $StringFilter;
  } & ConcreteParentClassStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ConcreteChildClass> {
    return $propertiesFromJson(json).map(
      (properties) => new ConcreteChildClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ConcreteChildClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ConcreteChildClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ConcreteChildClass(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ConcreteChildClass",
  );
  export type $Identifier = ConcreteParentClassStatic.$Identifier;
  export const $Identifier = ConcreteParentClassStatic.$Identifier;
  export type $Json = {
    readonly concreteChildClassProperty: string;
  } & ConcreteParentClassStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ConcreteParentClassStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/concreteChildClassProperty`,
          type: "Control",
        },
      ],
      label: "ConcreteChildClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ConcreteParentClassStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("ConcreteChildClass"),
        concreteChildClassProperty: zod.string(),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    ...ConcreteParentClassStatic.$properties,
    concreteChildClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/concreteChildClassProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      concreteChildClassProperty: string;
    } & $UnwrapR<
      ReturnType<typeof ConcreteParentClassStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      ConcreteParentClassStatic.$propertiesFromJson($jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const concreteChildClassProperty =
      $jsonObject["concreteChildClassProperty"];
    return purify.Either.of({
      ...$super0,
      $identifier,
      concreteChildClassProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      concreteChildClassProperty: string;
    } & $UnwrapR<
      ReturnType<typeof ConcreteParentClassStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = ConcreteParentClassStatic.$propertiesFromRdf({
      ...$parameters,
      ignoreRdfType: true,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/ConcreteChildClass":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(ConcreteChildClass.$fromRdfType)
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ConcreteChildClass)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: ConcreteChildClass.$Identifier =
      $parameters.resource.identifier;
    const _concreteChildClassPropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.concreteChildClassProperty["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              ConcreteChildClass.$properties.concreteChildClassProperty[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_concreteChildClassPropertyEither.isLeft()) {
      return _concreteChildClassPropertyEither;
    }

    const concreteChildClassProperty =
      _concreteChildClassPropertyEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      concreteChildClassProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ConcreteChildClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConcreteChildClass.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ConcreteChildClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ConcreteChildClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConcreteChildClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteChildClass");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...ConcreteParentClassStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteChildClass"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildClass")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildClass")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildClass")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildClass")}ConcreteChildClassProperty`,
      ),
      predicate:
        ConcreteChildClass.$properties.concreteChildClassProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ConcreteChildClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("concreteChildClass");
    patterns.push(
      ...ConcreteParentClassStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "concreteChildClass"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildClass")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ConcreteChildClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildClass")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildClass")}ConcreteChildClassProperty`,
            ),
            predicate:
              ConcreteChildClass.$properties.concreteChildClassProperty[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildClass")}ConcreteChildClassProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.concreteChildClassProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "concreteChildClass")}ConcreteChildClassProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isConcreteChildClass(
    object: AbstractBaseClassWithProperties,
  ): object is ConcreteChildClass {
    switch (object.$type) {
      case "ConcreteChildClass":
        return true;
      default:
        return false;
    }
  }
}
export abstract class ClassUnionMemberCommonParent {
  protected _$identifier?: ClassUnionMemberCommonParentStatic.$Identifier;
  abstract readonly $type: "ClassUnionMember1" | "ClassUnionMember2";
  readonly classUnionMemberCommonParentProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly classUnionMemberCommonParentProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.classUnionMemberCommonParentProperty =
      parameters.classUnionMemberCommonParentProperty;
  }

  get $identifier(): ClassUnionMemberCommonParentStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: ClassUnionMemberCommonParent): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.classUnionMemberCommonParentProperty,
          other.classUnionMemberCommonParentProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "classUnionMemberCommonParentProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.classUnionMemberCommonParentProperty);
    return _hasher;
  }

  $toJson(): ClassUnionMemberCommonParentStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        classUnionMemberCommonParentProperty:
          this.classUnionMemberCommonParentProperty,
      } satisfies ClassUnionMemberCommonParentStatic.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      ClassUnionMemberCommonParentStatic.$properties
        .classUnionMemberCommonParentProperty["identifier"],
      ...[this.classUnionMemberCommonParentProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ClassUnionMemberCommonParentStatic {
  export function $filter(
    filter: ClassUnionMemberCommonParentStatic.$Filter,
    value: ClassUnionMemberCommonParent,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.classUnionMemberCommonParentProperty !== "undefined" &&
      !$filterString(
        filter.classUnionMemberCommonParentProperty,
        value.classUnionMemberCommonParentProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly classUnionMemberCommonParentProperty?: $StringFilter;
  };
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ClassUnionMember1" | "ClassUnionMember2";
    readonly classUnionMemberCommonParentProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "ClassUnionMemberCommonParent" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/classUnionMemberCommonParentProperty`,
          type: "Control",
        },
      ],
      label: "ClassUnionMemberCommonParent",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.enum(["ClassUnionMember1", "ClassUnionMember2"]),
      classUnionMemberCommonParentProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    classUnionMemberCommonParentProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/classUnionMemberCommonParentProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      classUnionMemberCommonParentProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const classUnionMemberCommonParentProperty =
      $jsonObject["classUnionMemberCommonParentProperty"];
    return purify.Either.of({
      $identifier,
      classUnionMemberCommonParentProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      classUnionMemberCommonParentProperty: string;
    }
  > {
    const $identifier: ClassUnionMemberCommonParentStatic.$Identifier =
      $parameters.resource.identifier;
    const _classUnionMemberCommonParentPropertyEither: purify.Either<
      Error,
      string
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.classUnionMemberCommonParentProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        $fromRdfPreferredLanguages({
          focusResource: $parameters.resource,
          predicate:
            ClassUnionMemberCommonParentStatic.$properties
              .classUnionMemberCommonParentProperty["identifier"],
          preferredLanguages: $parameters.preferredLanguages,
          values,
        }),
      )
      .chain((values) => values.chainMap((value) => value.toString()))
      .chain((values) => values.head());
    if (_classUnionMemberCommonParentPropertyEither.isLeft()) {
      return _classUnionMemberCommonParentPropertyEither;
    }

    const classUnionMemberCommonParentProperty =
      _classUnionMemberCommonParentPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      classUnionMemberCommonParentProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ClassUnionMemberCommonParentStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ClassUnionMemberCommonParentStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ClassUnionMemberCommonParentStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ClassUnionMemberCommonParentStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ClassUnionMemberCommonParentStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("classUnionMemberCommonParent");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMemberCommonParent")}ClassUnionMemberCommonParentProperty`,
      ),
      predicate:
        ClassUnionMemberCommonParentStatic.$properties
          .classUnionMemberCommonParentProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ClassUnionMemberCommonParentStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("classUnionMemberCommonParent");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMemberCommonParent")}ClassUnionMemberCommonParentProperty`,
            ),
            predicate:
              ClassUnionMemberCommonParentStatic.$properties
                .classUnionMemberCommonParentProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMemberCommonParent")}ClassUnionMemberCommonParentProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.classUnionMemberCommonParentProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMemberCommonParent")}ClassUnionMemberCommonParentProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
export class ClassUnionMember2 extends ClassUnionMemberCommonParent {
  override readonly $type = "ClassUnionMember2";
  readonly classUnionMember2Property: string;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly classUnionMember2Property: string;
    } & ConstructorParameters<typeof ClassUnionMemberCommonParent>[0],
  ) {
    super(parameters);
    this.classUnionMember2Property = parameters.classUnionMember2Property;
  }

  override get $identifier(): ClassUnionMember2.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  override $equals(other: ClassUnionMember2): $EqualsResult {
    return super.$equals(other).chain(() =>
      $strictEquals(
        this.classUnionMember2Property,
        other.classUnionMember2Property,
      ).mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "classUnionMember2Property",
        propertyValuesUnequal,
        type: "Property" as const,
      })),
    );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    _hasher.update(this.classUnionMember2Property);
    return _hasher;
  }

  override $toJson(): ClassUnionMember2.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        classUnionMember2Property: this.classUnionMember2Property,
      } satisfies ClassUnionMember2.$Json),
    );
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode("http://example.com/ClassUnionMember2"),
      );
    }

    resource.add(
      ClassUnionMember2.$properties.classUnionMember2Property["identifier"],
      ...[this.classUnionMember2Property],
    );
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ClassUnionMember2 {
  export function $filter(
    filter: ClassUnionMember2.$Filter,
    value: ClassUnionMember2,
  ): boolean {
    if (!ClassUnionMemberCommonParentStatic.$filter(filter, value)) {
      return false;
    }

    if (
      typeof filter.classUnionMember2Property !== "undefined" &&
      !$filterString(
        filter.classUnionMember2Property,
        value.classUnionMember2Property,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly classUnionMember2Property?: $StringFilter;
  } & ClassUnionMemberCommonParentStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ClassUnionMember2> {
    return $propertiesFromJson(json).map(
      (properties) => new ClassUnionMember2(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ClassUnionMember2> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ClassUnionMember2.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ClassUnionMember2(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ClassUnionMember2",
  );
  export type $Identifier = ClassUnionMemberCommonParentStatic.$Identifier;
  export const $Identifier = ClassUnionMemberCommonParentStatic.$Identifier;
  export type $Json = {
    readonly classUnionMember2Property: string;
  } & ClassUnionMemberCommonParentStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ClassUnionMemberCommonParentStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/classUnionMember2Property`,
          type: "Control",
        },
      ],
      label: "ClassUnionMember2",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ClassUnionMemberCommonParentStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("ClassUnionMember2"),
        classUnionMember2Property: zod.string(),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    ...ClassUnionMemberCommonParentStatic.$properties,
    classUnionMember2Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/classUnionMember2Property",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      classUnionMember2Property: string;
    } & $UnwrapR<
      ReturnType<typeof ClassUnionMemberCommonParentStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      ClassUnionMemberCommonParentStatic.$propertiesFromJson($jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const classUnionMember2Property = $jsonObject["classUnionMember2Property"];
    return purify.Either.of({
      ...$super0,
      $identifier,
      classUnionMember2Property,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      classUnionMember2Property: string;
    } & $UnwrapR<
      ReturnType<typeof ClassUnionMemberCommonParentStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = ClassUnionMemberCommonParentStatic.$propertiesFromRdf(
      { ...$parameters, ignoreRdfType: true },
    );
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/ClassUnionMember2":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(ClassUnionMember2.$fromRdfType)
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ClassUnionMember2)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: ClassUnionMember2.$Identifier =
      $parameters.resource.identifier;
    const _classUnionMember2PropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.classUnionMember2Property["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              ClassUnionMember2.$properties.classUnionMember2Property[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_classUnionMember2PropertyEither.isLeft()) {
      return _classUnionMember2PropertyEither;
    }

    const classUnionMember2Property =
      _classUnionMember2PropertyEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      classUnionMember2Property,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ClassUnionMember2.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ClassUnionMember2.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ClassUnionMember2.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ClassUnionMember2.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("classUnionMember2");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...ClassUnionMemberCommonParentStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "classUnionMember2"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember2")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember2")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember2")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember2")}ClassUnionMember2Property`,
      ),
      predicate:
        ClassUnionMember2.$properties.classUnionMember2Property["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ClassUnionMember2.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("classUnionMember2");
    patterns.push(
      ...ClassUnionMemberCommonParentStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "classUnionMember2"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember2")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ClassUnionMember2.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember2")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember2")}ClassUnionMember2Property`,
            ),
            predicate:
              ClassUnionMember2.$properties.classUnionMember2Property[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember2")}ClassUnionMember2Property`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.classUnionMember2Property,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember2")}ClassUnionMember2Property`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isClassUnionMember2(
    object: ClassUnionMemberCommonParent,
  ): object is ClassUnionMember2 {
    switch (object.$type) {
      case "ClassUnionMember2":
        return true;
      default:
        return false;
    }
  }
}
export class ClassUnionMember1 extends ClassUnionMemberCommonParent {
  override readonly $type = "ClassUnionMember1";
  readonly classUnionMember1Property: string;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly classUnionMember1Property: string;
    } & ConstructorParameters<typeof ClassUnionMemberCommonParent>[0],
  ) {
    super(parameters);
    this.classUnionMember1Property = parameters.classUnionMember1Property;
  }

  override get $identifier(): ClassUnionMember1.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  override $equals(other: ClassUnionMember1): $EqualsResult {
    return super.$equals(other).chain(() =>
      $strictEquals(
        this.classUnionMember1Property,
        other.classUnionMember1Property,
      ).mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "classUnionMember1Property",
        propertyValuesUnequal,
        type: "Property" as const,
      })),
    );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    _hasher.update(this.classUnionMember1Property);
    return _hasher;
  }

  override $toJson(): ClassUnionMember1.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        classUnionMember1Property: this.classUnionMember1Property,
      } satisfies ClassUnionMember1.$Json),
    );
  }

  override $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode("http://example.com/ClassUnionMember1"),
      );
    }

    resource.add(
      ClassUnionMember1.$properties.classUnionMember1Property["identifier"],
      ...[this.classUnionMember1Property],
    );
    return resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ClassUnionMember1 {
  export function $filter(
    filter: ClassUnionMember1.$Filter,
    value: ClassUnionMember1,
  ): boolean {
    if (!ClassUnionMemberCommonParentStatic.$filter(filter, value)) {
      return false;
    }

    if (
      typeof filter.classUnionMember1Property !== "undefined" &&
      !$filterString(
        filter.classUnionMember1Property,
        value.classUnionMember1Property,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly classUnionMember1Property?: $StringFilter;
  } & ClassUnionMemberCommonParentStatic.$Filter;

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ClassUnionMember1> {
    return $propertiesFromJson(json).map(
      (properties) => new ClassUnionMember1(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ClassUnionMember1> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return ClassUnionMember1.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new ClassUnionMember1(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/ClassUnionMember1",
  );
  export type $Identifier = ClassUnionMemberCommonParentStatic.$Identifier;
  export const $Identifier = ClassUnionMemberCommonParentStatic.$Identifier;
  export type $Json = {
    readonly classUnionMember1Property: string;
  } & ClassUnionMemberCommonParentStatic.$Json;

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ClassUnionMemberCommonParentStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/classUnionMember1Property`,
          type: "Control",
        },
      ],
      label: "ClassUnionMember1",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ClassUnionMemberCommonParentStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("ClassUnionMember1"),
        classUnionMember1Property: zod.string(),
      }),
    ) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    ...ClassUnionMemberCommonParentStatic.$properties,
    classUnionMember1Property: {
      identifier: dataFactory.namedNode(
        "http://example.com/classUnionMember1Property",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      classUnionMember1Property: string;
    } & $UnwrapR<
      ReturnType<typeof ClassUnionMemberCommonParentStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      ClassUnionMemberCommonParentStatic.$propertiesFromJson($jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const classUnionMember1Property = $jsonObject["classUnionMember1Property"];
    return purify.Either.of({
      ...$super0,
      $identifier,
      classUnionMember1Property,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      classUnionMember1Property: string;
    } & $UnwrapR<
      ReturnType<typeof ClassUnionMemberCommonParentStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = ClassUnionMemberCommonParentStatic.$propertiesFromRdf(
      { ...$parameters, ignoreRdfType: true },
    );
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/ClassUnionMember1":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(ClassUnionMember1.$fromRdfType)
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/ClassUnionMember1)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: ClassUnionMember1.$Identifier =
      $parameters.resource.identifier;
    const _classUnionMember1PropertyEither: purify.Either<Error, string> =
      purify.Either.of<
        Error,
        rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
      >(
        $parameters.resource.values(
          $properties.classUnionMember1Property["identifier"],
          { unique: true },
        ),
      )
        .chain((values) =>
          $fromRdfPreferredLanguages({
            focusResource: $parameters.resource,
            predicate:
              ClassUnionMember1.$properties.classUnionMember1Property[
                "identifier"
              ],
            preferredLanguages: $parameters.preferredLanguages,
            values,
          }),
        )
        .chain((values) => values.chainMap((value) => value.toString()))
        .chain((values) => values.head());
    if (_classUnionMember1PropertyEither.isLeft()) {
      return _classUnionMember1PropertyEither;
    }

    const classUnionMember1Property =
      _classUnionMember1PropertyEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      classUnionMember1Property,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ClassUnionMember1.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ClassUnionMember1.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ClassUnionMember1.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ClassUnionMember1.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("classUnionMember1");
    const triples: sparqljs.Triple[] = [];
    triples.push(
      ...ClassUnionMemberCommonParentStatic.$sparqlConstructTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "classUnionMember1"),
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember1")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember1")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember1")}RdfClass`,
          ),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember1")}ClassUnionMember1Property`,
      ),
      predicate:
        ClassUnionMember1.$properties.classUnionMember1Property["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ClassUnionMember1.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("classUnionMember1");
    patterns.push(
      ...ClassUnionMemberCommonParentStatic.$sparqlWherePatterns({
        filter: parameters?.filter,
        ignoreRdfType: true,
        subject,
        variablePrefix:
          parameters?.variablePrefix ??
          (subject.termType === "Variable"
            ? subject.value
            : "classUnionMember1"),
      }),
    );
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember1")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: ClassUnionMember1.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember1")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember1")}ClassUnionMember1Property`,
            ),
            predicate:
              ClassUnionMember1.$properties.classUnionMember1Property[
                "identifier"
              ],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember1")}ClassUnionMember1Property`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.classUnionMember1Property,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "classUnionMember1")}ClassUnionMember1Property`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }

  export function isClassUnionMember1(
    object: ClassUnionMemberCommonParent,
  ): object is ClassUnionMember1 {
    switch (object.$type) {
      case "ClassUnionMember1":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape that can have a blank node or IRI as an identifier
 */
export interface BlankNodeOrIriIdentifierInterface {
  readonly $identifier: BlankNodeOrIriIdentifierInterface.$Identifier;
  readonly $type: "BlankNodeOrIriIdentifierInterface";
}

export namespace BlankNodeOrIriIdentifierInterface {
  export function $create(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
  }): BlankNodeOrIriIdentifierInterface {
    let $identifier: BlankNodeOrIriIdentifierInterface.$Identifier;
    if (typeof parameters?.$identifier === "object") {
      $identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      $identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters?.$identifier satisfies never;
    }

    const $type = "BlankNodeOrIriIdentifierInterface" as const;
    return { $identifier, $type };
  }

  export function $equals(
    left: BlankNodeOrIriIdentifierInterface,
    right: BlankNodeOrIriIdentifierInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  export function $filter(
    filter: BlankNodeOrIriIdentifierInterface.$Filter,
    value: BlankNodeOrIriIdentifierInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = { readonly $identifier?: $IdentifierFilter };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, BlankNodeOrIriIdentifierInterface> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, BlankNodeOrIriIdentifierInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return BlankNodeOrIriIdentifierInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _blankNodeOrIriIdentifierInterface: BlankNodeOrIriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_blankNodeOrIriIdentifierInterface.$identifier.value);
    _hasher.update(_blankNodeOrIriIdentifierInterface.$type);
    BlankNodeOrIriIdentifierInterface.$hashShaclProperties(
      _blankNodeOrIriIdentifierInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _blankNodeOrIriIdentifierInterface: BlankNodeOrIriIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "BlankNodeOrIriIdentifierInterface";
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "BlankNodeOrIriIdentifierInterface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "BlankNodeOrIriIdentifierInterface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("BlankNodeOrIriIdentifierInterface"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {};

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "BlankNodeOrIriIdentifierInterface";
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const $type = "BlankNodeOrIriIdentifierInterface" as const;
    return purify.Either.of({ $identifier, $type });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      $type: "BlankNodeOrIriIdentifierInterface";
    }
  > {
    const $identifier: BlankNodeOrIriIdentifierInterface.$Identifier =
      $parameters.resource.identifier;
    const $type = "BlankNodeOrIriIdentifierInterface" as const;
    return purify.Either.of({ $identifier, $type });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: BlankNodeOrIriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BlankNodeOrIriIdentifierInterface.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            BlankNodeOrIriIdentifierInterface.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: BlankNodeOrIriIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BlankNodeOrIriIdentifierInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: BlankNodeOrIriIdentifierInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("blankNodeOrIriIdentifierInterface");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }

  export function $toJson(
    _blankNodeOrIriIdentifierInterface: BlankNodeOrIriIdentifierInterface,
  ): BlankNodeOrIriIdentifierInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _blankNodeOrIriIdentifierInterface.$identifier.termType ===
          "BlankNode"
            ? `_:${_blankNodeOrIriIdentifierInterface.$identifier.value}`
            : _blankNodeOrIriIdentifierInterface.$identifier.value,
        $type: _blankNodeOrIriIdentifierInterface.$type,
      } satisfies BlankNodeOrIriIdentifierInterface.$Json),
    );
  }

  export function $toRdf(
    _blankNodeOrIriIdentifierInterface: BlankNodeOrIriIdentifierInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _blankNodeOrIriIdentifierInterface.$identifier,
      { mutateGraph },
    );
    return resource;
  }
}
/**
 * Node shape that can have a blank node or IRI as an identifier
 */
export class BlankNodeOrIriIdentifierClass {
  private _$identifier?: BlankNodeOrIriIdentifierClass.$Identifier;
  readonly $type = "BlankNodeOrIriIdentifierClass";

  constructor(parameters?: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
  }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters?.$identifier);
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }
  }

  get $identifier(): BlankNodeOrIriIdentifierClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: BlankNodeOrIriIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    return _hasher;
  }

  $toJson(): BlankNodeOrIriIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
      } satisfies BlankNodeOrIriIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/BlankNodeOrIriIdentifierClass",
        ),
      );
    }

    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace BlankNodeOrIriIdentifierClass {
  export function $filter(
    filter: BlankNodeOrIriIdentifierClass.$Filter,
    value: BlankNodeOrIriIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = { readonly $identifier?: $IdentifierFilter };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, BlankNodeOrIriIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new BlankNodeOrIriIdentifierClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, BlankNodeOrIriIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return BlankNodeOrIriIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new BlankNodeOrIriIdentifierClass(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/BlankNodeOrIriIdentifierClass",
  );
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "BlankNodeOrIriIdentifierClass";
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "BlankNodeOrIriIdentifierClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "BlankNodeOrIriIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("BlankNodeOrIriIdentifierClass"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {};

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    return purify.Either.of({ $identifier });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<Error, { $identifier: rdfjs.BlankNode | rdfjs.NamedNode }> {
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/BlankNodeOrIriIdentifierClass":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              BlankNodeOrIriIdentifierClass.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/BlankNodeOrIriIdentifierClass)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    const $identifier: BlankNodeOrIriIdentifierClass.$Identifier =
      $parameters.resource.identifier;
    return purify.Either.of({ $identifier });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: BlankNodeOrIriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BlankNodeOrIriIdentifierClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            BlankNodeOrIriIdentifierClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: BlankNodeOrIriIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BlankNodeOrIriIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("blankNodeOrIriIdentifierClass");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "blankNodeOrIriIdentifierClass")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "blankNodeOrIriIdentifierClass")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "blankNodeOrIriIdentifierClass")}RdfClass`,
          ),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: BlankNodeOrIriIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("blankNodeOrIriIdentifierClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "blankNodeOrIriIdentifierClass")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: BlankNodeOrIriIdentifierClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "blankNodeOrIriIdentifierClass")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }
}
/**
 * Node shape that can only have a blank node as an identifier
 */
export interface BlankNodeIdentifierInterface {
  readonly $identifier: BlankNodeIdentifierInterface.$Identifier;
  readonly $type: "BlankNodeIdentifierInterface";
}

export namespace BlankNodeIdentifierInterface {
  export function $create(parameters?: {
    readonly $identifier?: rdfjs.BlankNode;
  }): BlankNodeIdentifierInterface {
    let $identifier: BlankNodeIdentifierInterface.$Identifier;
    if (typeof parameters?.$identifier === "object") {
      $identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "undefined") {
      $identifier = dataFactory.blankNode();
    } else {
      $identifier = parameters?.$identifier satisfies never;
    }

    const $type = "BlankNodeIdentifierInterface" as const;
    return { $identifier, $type };
  }

  export function $equals(
    left: BlankNodeIdentifierInterface,
    right: BlankNodeIdentifierInterface,
  ): $EqualsResult {
    return $booleanEquals(left.$identifier, right.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(left.$type, right.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  export function $filter(
    filter: BlankNodeIdentifierInterface.$Filter,
    value: BlankNodeIdentifierInterface,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterBlankNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = { readonly $identifier?: $BlankNodeFilter };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, BlankNodeIdentifierInterface> {
    return $propertiesFromJson(json);
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, BlankNodeIdentifierInterface> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return BlankNodeIdentifierInterface.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    });
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _blankNodeIdentifierInterface: BlankNodeIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    _hasher.update(_blankNodeIdentifierInterface.$identifier.value);
    _hasher.update(_blankNodeIdentifierInterface.$type);
    BlankNodeIdentifierInterface.$hashShaclProperties(
      _blankNodeIdentifierInterface,
      _hasher,
    );
    return _hasher;
  }

  export function $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _blankNodeIdentifierInterface: BlankNodeIdentifierInterface,
    _hasher: HasherT,
  ): HasherT {
    return _hasher;
  }

  export type $Identifier = rdfjs.BlankNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.BlankNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ) as purify.Either<Error, rdfjs.BlankNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "BlankNodeIdentifierInterface";
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "BlankNodeIdentifierInterface" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "BlankNodeIdentifierInterface",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("BlankNodeIdentifierInterface"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {};

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode; $type: "BlankNodeIdentifierInterface" }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.blankNode($jsonObject["@id"].substring(2));
    const $type = "BlankNodeIdentifierInterface" as const;
    return purify.Either.of({ $identifier, $type });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    { $identifier: rdfjs.BlankNode; $type: "BlankNodeIdentifierInterface" }
  > {
    if ($parameters.resource.identifier.termType !== "BlankNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedTermValueError({
          actualValue: $parameters.resource.identifier,
          expectedValueType: "(rdfjs.BlankNode)",
          focusResource: $parameters.resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: BlankNodeIdentifierInterface.$Identifier =
      $parameters.resource.identifier;
    const $type = "BlankNodeIdentifierInterface" as const;
    return purify.Either.of({ $identifier, $type });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: BlankNodeIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BlankNodeIdentifierInterface.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            BlankNodeIdentifierInterface.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: BlankNodeIdentifierInterface.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BlankNodeIdentifierInterface.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: BlankNodeIdentifierInterface.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("blankNodeIdentifierInterface");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $BlankNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }

  export function $toJson(
    _blankNodeIdentifierInterface: BlankNodeIdentifierInterface,
  ): BlankNodeIdentifierInterface.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": `_:${_blankNodeIdentifierInterface.$identifier.value}`,
        $type: _blankNodeIdentifierInterface.$type,
      } satisfies BlankNodeIdentifierInterface.$Json),
    );
  }

  export function $toRdf(
    _blankNodeIdentifierInterface: BlankNodeIdentifierInterface,
    options?: {
      ignoreRdfType?: boolean;
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(
      _blankNodeIdentifierInterface.$identifier,
      { mutateGraph },
    );
    return resource;
  }
}
/**
 * Node shape that can only have a blank node as an identifier
 */
export class BlankNodeIdentifierClass {
  private _$identifier?: BlankNodeIdentifierClass.$Identifier;
  readonly $type = "BlankNodeIdentifierClass";

  constructor(parameters?: { readonly $identifier?: rdfjs.BlankNode }) {
    if (typeof parameters?.$identifier === "object") {
      this._$identifier = parameters?.$identifier;
    } else if (typeof parameters?.$identifier === "undefined") {
    } else {
      this._$identifier = parameters?.$identifier satisfies never;
    }
  }

  get $identifier(): BlankNodeIdentifierClass.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    if (this._$identifier.termType !== "BlankNode") {
      throw new Error(
        `expected identifier to be BlankNode, not ${this._$identifier.termType}`,
      );
    }

    return this._$identifier;
  }

  $equals(other: BlankNodeIdentifierClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    return _hasher;
  }

  $toJson(): BlankNodeIdentifierClass.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id": `_:${this.$identifier.value}`,
        $type: this.$type,
      } satisfies BlankNodeIdentifierClass.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const ignoreRdfType = !!options?.ignoreRdfType;
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    if (!ignoreRdfType) {
      resource.add(
        $RdfVocabularies.rdf.type,
        resource.dataFactory.namedNode(
          "http://example.com/BlankNodeIdentifierClass",
        ),
      );
    }

    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace BlankNodeIdentifierClass {
  export function $filter(
    filter: BlankNodeIdentifierClass.$Filter,
    value: BlankNodeIdentifierClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterBlankNode(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = { readonly $identifier?: $BlankNodeFilter };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, BlankNodeIdentifierClass> {
    return $propertiesFromJson(json).map(
      (properties) => new BlankNodeIdentifierClass(properties),
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      context?: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, BlankNodeIdentifierClass> {
    let {
      context,
      ignoreRdfType = false,
      objectSet,
      preferredLanguages,
    } = options ?? {};
    if (!objectSet) {
      objectSet = new $RdfjsDatasetObjectSet({ dataset: resource.dataset });
    }

    return BlankNodeIdentifierClass.$propertiesFromRdf({
      context,
      ignoreRdfType,
      objectSet,
      preferredLanguages,
      resource,
    }).map((properties) => new BlankNodeIdentifierClass(properties));
  }

  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://example.com/BlankNodeIdentifierClass",
  );
  export type $Identifier = rdfjs.BlankNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjs.BlankNode> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      ) as purify.Either<Error, rdfjs.BlankNode>;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "BlankNodeIdentifierClass";
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "BlankNodeIdentifierClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "BlankNodeIdentifierClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("BlankNodeIdentifierClass"),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {};

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<zod.ZodError, { $identifier: rdfjs.BlankNode }> {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = dataFactory.blankNode($jsonObject["@id"].substring(2));
    return purify.Either.of({ $identifier });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<Error, { $identifier: rdfjs.BlankNode }> {
    if (!$parameters.ignoreRdfType) {
      const $rdfTypeCheck: purify.Either<Error, true> = $parameters.resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) => {
          // Check the expected type and its known subtypes
          switch (actualRdfType.value) {
            case "http://example.com/BlankNodeIdentifierClass":
              return purify.Either.of(true);
          }

          // Check arbitrary rdfs:subClassOf's of the expected type
          if (
            $parameters.resource.isInstanceOf(
              BlankNodeIdentifierClass.$fromRdfType,
            )
          ) {
            return purify.Either.of(true);
          }

          return purify.Left(
            new Error(
              `${rdfjsResource.Resource.Identifier.toString($parameters.resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://example.com/BlankNodeIdentifierClass)`,
            ),
          );
        });
      if ($rdfTypeCheck.isLeft()) {
        return $rdfTypeCheck;
      }
    }

    if ($parameters.resource.identifier.termType !== "BlankNode") {
      return purify.Left(
        new rdfjsResource.Resource.MistypedTermValueError({
          actualValue: $parameters.resource.identifier,
          expectedValueType: "(rdfjs.BlankNode)",
          focusResource: $parameters.resource,
          predicate: $RdfVocabularies.rdf.subject,
        }),
      );
    }

    const $identifier: BlankNodeIdentifierClass.$Identifier =
      $parameters.resource.identifier;
    return purify.Either.of({ $identifier });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: BlankNodeIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BlankNodeIdentifierClass.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            BlankNodeIdentifierClass.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: BlankNodeIdentifierClass.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BlankNodeIdentifierClass.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("blankNodeIdentifierClass");
    const triples: sparqljs.Triple[] = [];
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "blankNodeIdentifierClass")}RdfType`,
          ),
        },
        {
          subject: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "blankNodeIdentifierClass")}RdfType`,
          ),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(
            `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "blankNodeIdentifierClass")}RdfClass`,
          ),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: BlankNodeIdentifierClass.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("blankNodeIdentifierClass");
    const rdfTypeVariable = dataFactory.variable!(
      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "blankNodeIdentifierClass")}RdfType`,
    );
    if (!parameters?.ignoreRdfType) {
      patterns.push(
        $sparqlInstancesOfPattern({
          rdfType: BlankNodeIdentifierClass.$fromRdfType,
          subject,
        }),
        {
          triples: [
            {
              subject,
              predicate: $RdfVocabularies.rdf.type,
              object: rdfTypeVariable,
            },
          ],
          type: "bgp" as const,
        },
        {
          patterns: [
            {
              triples: [
                {
                  subject: rdfTypeVariable,
                  predicate: {
                    items: [$RdfVocabularies.rdfs.subClassOf],
                    pathType: "+" as const,
                    type: "path" as const,
                  },
                  object: dataFactory.variable!(
                    `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "blankNodeIdentifierClass")}RdfClass`,
                  ),
                },
              ],
              type: "bgp" as const,
            },
          ],
          type: "optional" as const,
        },
      );
    }

    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $BlankNodeFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    return patterns;
  }
}
/**
 * An abstract base class that will be inherited by the extern object type, showing how to mix generated and hand-written code.
 */
export abstract class AbstractBaseClassForExternClass {
  protected _$identifier?: AbstractBaseClassForExternClassStatic.$Identifier;
  abstract readonly $type: "ExternClass";
  readonly abstractBaseClassForExternClassProperty: string;

  constructor(parameters: {
    readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly abstractBaseClassForExternClassProperty: string;
  }) {
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    this.abstractBaseClassForExternClassProperty =
      parameters.abstractBaseClassForExternClassProperty;
  }

  get $identifier(): AbstractBaseClassForExternClassStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }

    return this._$identifier;
  }

  $equals(other: AbstractBaseClassForExternClass): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $strictEquals(
          this.abstractBaseClassForExternClassProperty,
          other.abstractBaseClassForExternClassProperty,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "abstractBaseClassForExternClassProperty",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.abstractBaseClassForExternClassProperty);
    return _hasher;
  }

  $toJson(): AbstractBaseClassForExternClassStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
        abstractBaseClassForExternClassProperty:
          this.abstractBaseClassForExternClassProperty,
      } satisfies AbstractBaseClassForExternClassStatic.$Json),
    );
  }

  $toRdf(options?: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet?: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const mutateGraph = options?.mutateGraph;
    const resourceSet =
      options?.resourceSet ??
      new rdfjsResource.MutableResourceSet({
        dataFactory,
        dataset: datasetFactory.dataset(),
      });
    const resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    resource.add(
      AbstractBaseClassForExternClassStatic.$properties
        .abstractBaseClassForExternClassProperty["identifier"],
      ...[this.abstractBaseClassForExternClassProperty],
    );
    return resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace AbstractBaseClassForExternClassStatic {
  export function $filter(
    filter: AbstractBaseClassForExternClassStatic.$Filter,
    value: AbstractBaseClassForExternClass,
  ): boolean {
    if (
      typeof filter.$identifier !== "undefined" &&
      !$filterIdentifier(filter.$identifier, value.$identifier)
    ) {
      return false;
    }

    if (
      typeof filter.abstractBaseClassForExternClassProperty !== "undefined" &&
      !$filterString(
        filter.abstractBaseClassForExternClassProperty,
        value.abstractBaseClassForExternClassProperty,
      )
    ) {
      return false;
    }

    return true;
  }

  export type $Filter = {
    readonly $identifier?: $IdentifierFilter;
    readonly abstractBaseClassForExternClassProperty?: $StringFilter;
  };
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type: "ExternClass";
    readonly abstractBaseClassForExternClassProperty: string;
  };

  export function $jsonSchema() {
    return zod.toJSONSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }): any {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "AbstractBaseClassForExternClass" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
        {
          scope: `${scopePrefix}/properties/abstractBaseClassForExternClassProperty`,
          type: "Control",
        },
      ],
      label: "AbstractBaseClassForExternClass",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.literal("ExternClass"),
      abstractBaseClassForExternClassProperty: zod.string(),
    }) satisfies zod.ZodType<$Json>;
  }

  export const $properties = {
    abstractBaseClassForExternClassProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/abstractBaseClassForExternClassProperty",
      ),
    },
  };

  export function $propertiesFromJson(_json: unknown): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      abstractBaseClassForExternClassProperty: string;
    }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const $jsonObject = $jsonSafeParseResult.data;
    const $identifier = $jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode($jsonObject["@id"].substring(2))
      : dataFactory.namedNode($jsonObject["@id"]);
    const abstractBaseClassForExternClassProperty =
      $jsonObject["abstractBaseClassForExternClassProperty"];
    return purify.Either.of({
      $identifier,
      abstractBaseClassForExternClassProperty,
    });
  }

  export function $propertiesFromRdf($parameters: {
    context?: any;
    ignoreRdfType: boolean;
    objectSet: $ObjectSet;
    preferredLanguages?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    Error,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      abstractBaseClassForExternClassProperty: string;
    }
  > {
    const $identifier: AbstractBaseClassForExternClassStatic.$Identifier =
      $parameters.resource.identifier;
    const _abstractBaseClassForExternClassPropertyEither: purify.Either<
      Error,
      string
    > = purify.Either.of<
      Error,
      rdfjsResource.Resource.Values<rdfjsResource.Resource.TermValue>
    >(
      $parameters.resource.values(
        $properties.abstractBaseClassForExternClassProperty["identifier"],
        { unique: true },
      ),
    )
      .chain((values) =>
        $fromRdfPreferredLanguages({
          focusResource: $parameters.resource,
          predicate:
            AbstractBaseClassForExternClassStatic.$properties
              .abstractBaseClassForExternClassProperty["identifier"],
          preferredLanguages: $parameters.preferredLanguages,
          values,
        }),
      )
      .chain((values) => values.chainMap((value) => value.toString()))
      .chain((values) => values.head());
    if (_abstractBaseClassForExternClassPropertyEither.isLeft()) {
      return _abstractBaseClassForExternClassPropertyEither;
    }

    const abstractBaseClassForExternClassProperty =
      _abstractBaseClassForExternClassPropertyEither.unsafeCoerce();
    return purify.Either.of({
      $identifier,
      abstractBaseClassForExternClassProperty,
    });
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: AbstractBaseClassForExternClassStatic.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        AbstractBaseClassForExternClassStatic.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            AbstractBaseClassForExternClassStatic.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: AbstractBaseClassForExternClassStatic.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      AbstractBaseClassForExternClassStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassForExternClass");
    const triples: sparqljs.Triple[] = [];
    triples.push({
      object: dataFactory.variable!(
        `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "abstractBaseClassForExternClass")}AbstractBaseClassForExternClassProperty`,
      ),
      predicate:
        AbstractBaseClassForExternClassStatic.$properties
          .abstractBaseClassForExternClassProperty["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: AbstractBaseClassForExternClassStatic.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ??
      dataFactory.variable!("abstractBaseClassForExternClass");
    if (subject.termType === "Variable") {
      patterns.push({
        patterns: $IdentifierFilter
          .$sparqlWherePatterns(parameters?.filter?.$identifier, subject)
          .concat(),
        type: "group",
      });
    }

    patterns.push(
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "abstractBaseClassForExternClass")}AbstractBaseClassForExternClassProperty`,
            ),
            predicate:
              AbstractBaseClassForExternClassStatic.$properties
                .abstractBaseClassForExternClassProperty["identifier"],
            subject: subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [parameters?.preferredLanguages ?? []]
          .filter((languages) => languages.length > 0)
          .map((languages) =>
            languages.map((language) => ({
              type: "operation" as const,
              operator: "=",
              args: [
                {
                  type: "operation" as const,
                  operator: "lang",
                  args: [
                    dataFactory.variable!(
                      `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "abstractBaseClassForExternClass")}AbstractBaseClassForExternClassProperty`,
                    ),
                  ],
                },
                dataFactory.literal(language),
              ],
            })),
          )
          .map((langEqualsExpressions) => ({
            type: "filter" as const,
            expression: langEqualsExpressions.reduce(
              (reducedExpression, langEqualsExpression) => {
                if (reducedExpression === null) {
                  return langEqualsExpression;
                }
                return {
                  type: "operation" as const,
                  operator: "||",
                  args: [reducedExpression, langEqualsExpression],
                };
              },
              null as sparqljs.Expression | null,
            ) as sparqljs.Expression,
          }))
          .concat(),
        type: "group",
      },
      {
        patterns: $StringFilter
          .$sparqlWherePatterns(
            parameters?.filter?.abstractBaseClassForExternClassProperty,
            dataFactory.variable!(
              `${parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "abstractBaseClassForExternClass")}AbstractBaseClassForExternClassProperty`,
            ),
          )
          .concat(),
        type: "group",
      },
    );
    return patterns;
  }
}
/**
 * Node shape sh:xone's other node shapes. This will usually be generated as a discriminated union.
 */
export type ClassUnion = ClassUnionMember1 | ClassUnionMember2;

export namespace ClassUnion {
  export function $equals(left: ClassUnion, right: ClassUnion): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      switch (left.$type) {
        case "ClassUnionMember1":
          return left.$equals(right as unknown as ClassUnionMember1);
        case "ClassUnionMember2":
          return left.$equals(right as unknown as ClassUnionMember2);
        default:
          left satisfies never;
          throw new Error("unrecognized type");
      }
    });
  }

  export function $filter(
    filter: ClassUnion.$Filter,
    value: ClassUnion,
  ): boolean {
    if (typeof filter.on?.ClassUnionMember1 !== "undefined") {
      switch (value.$type) {
        case "ClassUnionMember1":
          if (
            !ClassUnionMember1.$filter(
              filter.on.ClassUnionMember1,
              value as ClassUnionMember1,
            )
          ) {
            return false;
          }
          break;
      }
    }

    if (typeof filter.on?.ClassUnionMember2 !== "undefined") {
      switch (value.$type) {
        case "ClassUnionMember2":
          if (
            !ClassUnionMember2.$filter(
              filter.on.ClassUnionMember2,
              value as ClassUnionMember2,
            )
          ) {
            return false;
          }
          break;
      }
    }

    return true;
  }

  export type $Filter = {
    readonly on?: {
      readonly ClassUnionMember1?: ClassUnionMember1.$Filter;
      readonly ClassUnionMember2?: ClassUnionMember2.$Filter;
    };
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ClassUnion> {
    return (
      ClassUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        ClassUnion
      >
    ).altLazy(
      () =>
        ClassUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          ClassUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, ClassUnion> {
    return (
      ClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, ClassUnion>
    ).altLazy(
      () =>
        ClassUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, ClassUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_classUnion: ClassUnion, _hasher: HasherT): HasherT {
    switch (_classUnion.$type) {
      case "ClassUnionMember1":
        return _classUnion.$hash(_hasher);
      case "ClassUnionMember2":
        return _classUnion.$hash(_hasher);
      default:
        _classUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = ClassUnionMember1.$Json | ClassUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      ClassUnionMember1.$jsonZodSchema(),
      ClassUnionMember2.$jsonZodSchema(),
    ]);
  }

  export const $properties = {
    classUnionMemberCommonParentProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/classUnionMemberCommonParentProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: ClassUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ClassUnion.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            ClassUnion.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: ClassUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...ClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("classUnionClassUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ClassUnionMember1`
          : "classUnionClassUnionMember1",
      }).concat(),
      ...ClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("classUnionClassUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ClassUnionMember2`
          : "classUnionClassUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: ClassUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: ClassUnionMember1.$sparqlWherePatterns({
              filter: parameters?.filter?.on?.ClassUnionMember1,
              subject:
                parameters?.subject ??
                dataFactory.variable!("classUnionClassUnionMember1"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}ClassUnionMember1`
                : "classUnionClassUnionMember1",
            }).concat(),
            type: "group",
          },
          {
            patterns: ClassUnionMember2.$sparqlWherePatterns({
              filter: parameters?.filter?.on?.ClassUnionMember2,
              subject:
                parameters?.subject ??
                dataFactory.variable!("classUnionClassUnionMember2"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}ClassUnionMember2`
                : "classUnionClassUnionMember2",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function $toJson(
    _classUnion: ClassUnion,
  ): ClassUnionMember1.$Json | ClassUnionMember2.$Json {
    switch (_classUnion.$type) {
      case "ClassUnionMember1":
        return _classUnion.$toJson();
      case "ClassUnionMember2":
        return _classUnion.$toJson();
      default:
        _classUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export function $toRdf(
    _classUnion: ClassUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    switch (_classUnion.$type) {
      case "ClassUnionMember1":
        return _classUnion.$toRdf(_parameters);
      case "ClassUnionMember2":
        return _classUnion.$toRdf(_parameters);
      default:
        _classUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export function isClassUnion(
    object: ClassUnionMemberCommonParent,
  ): object is ClassUnion {
    switch (object.$type) {
      case "ClassUnionMember1":
      case "ClassUnionMember2":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape that unions a node shape and another union of node shapes. Generated code will usually flatten these.
 */
export type FlattenClassUnion =
  | ClassUnionMember1
  | ClassUnionMember2
  | FlattenClassUnionMember3;

export namespace FlattenClassUnion {
  export function $equals(
    left: FlattenClassUnion,
    right: FlattenClassUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      switch (left.$type) {
        case "ClassUnionMember1":
          return left.$equals(right as unknown as ClassUnionMember1);
        case "ClassUnionMember2":
          return left.$equals(right as unknown as ClassUnionMember2);
        case "FlattenClassUnionMember3":
          return left.$equals(right as unknown as FlattenClassUnionMember3);
        default:
          left satisfies never;
          throw new Error("unrecognized type");
      }
    });
  }

  export function $filter(
    filter: FlattenClassUnion.$Filter,
    value: FlattenClassUnion,
  ): boolean {
    if (typeof filter.on?.ClassUnionMember1 !== "undefined") {
      switch (value.$type) {
        case "ClassUnionMember1":
          if (
            !ClassUnionMember1.$filter(
              filter.on.ClassUnionMember1,
              value as ClassUnionMember1,
            )
          ) {
            return false;
          }
          break;
      }
    }

    if (typeof filter.on?.ClassUnionMember2 !== "undefined") {
      switch (value.$type) {
        case "ClassUnionMember2":
          if (
            !ClassUnionMember2.$filter(
              filter.on.ClassUnionMember2,
              value as ClassUnionMember2,
            )
          ) {
            return false;
          }
          break;
      }
    }

    if (typeof filter.on?.FlattenClassUnionMember3 !== "undefined") {
      switch (value.$type) {
        case "FlattenClassUnionMember3":
          if (
            !FlattenClassUnionMember3.$filter(
              filter.on.FlattenClassUnionMember3,
              value as FlattenClassUnionMember3,
            )
          ) {
            return false;
          }
          break;
      }
    }

    return true;
  }

  export type $Filter = {
    readonly on?: {
      readonly ClassUnionMember1?: ClassUnionMember1.$Filter;
      readonly ClassUnionMember2?: ClassUnionMember2.$Filter;
      readonly FlattenClassUnionMember3?: FlattenClassUnionMember3.$Filter;
    };
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, FlattenClassUnion> {
    return (
      ClassUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        FlattenClassUnion
      >
    )
      .altLazy(
        () =>
          ClassUnionMember2.$fromJson(json) as purify.Either<
            zod.ZodError,
            FlattenClassUnion
          >,
      )
      .altLazy(
        () =>
          FlattenClassUnionMember3.$fromJson(json) as purify.Either<
            zod.ZodError,
            FlattenClassUnion
          >,
      );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, FlattenClassUnion> {
    return (
      ClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, FlattenClassUnion>
    )
      .altLazy(
        () =>
          ClassUnionMember2.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, FlattenClassUnion>,
      )
      .altLazy(
        () =>
          FlattenClassUnionMember3.$fromRdf(resource, {
            ...options,
            ignoreRdfType: false,
          }) as purify.Either<Error, FlattenClassUnion>,
      );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_flattenClassUnion: FlattenClassUnion, _hasher: HasherT): HasherT {
    switch (_flattenClassUnion.$type) {
      case "ClassUnionMember1":
        return _flattenClassUnion.$hash(_hasher);
      case "ClassUnionMember2":
        return _flattenClassUnion.$hash(_hasher);
      case "FlattenClassUnionMember3":
        return _flattenClassUnion.$hash(_hasher);
      default:
        _flattenClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json =
    | ClassUnionMember1.$Json
    | ClassUnionMember2.$Json
    | FlattenClassUnionMember3.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      ClassUnionMember1.$jsonZodSchema(),
      ClassUnionMember2.$jsonZodSchema(),
      FlattenClassUnionMember3.$jsonZodSchema(),
    ]);
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: FlattenClassUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        FlattenClassUnion.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            FlattenClassUnion.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: FlattenClassUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      FlattenClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...ClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("flattenClassUnionClassUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ClassUnionMember1`
          : "flattenClassUnionClassUnionMember1",
      }).concat(),
      ...ClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("flattenClassUnionClassUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ClassUnionMember2`
          : "flattenClassUnionClassUnionMember2",
      }).concat(),
      ...FlattenClassUnionMember3.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("flattenClassUnionFlattenClassUnionMember3"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}FlattenClassUnionMember3`
          : "flattenClassUnionFlattenClassUnionMember3",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: FlattenClassUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: ClassUnionMember1.$sparqlWherePatterns({
              filter: parameters?.filter?.on?.ClassUnionMember1,
              subject:
                parameters?.subject ??
                dataFactory.variable!("flattenClassUnionClassUnionMember1"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}ClassUnionMember1`
                : "flattenClassUnionClassUnionMember1",
            }).concat(),
            type: "group",
          },
          {
            patterns: ClassUnionMember2.$sparqlWherePatterns({
              filter: parameters?.filter?.on?.ClassUnionMember2,
              subject:
                parameters?.subject ??
                dataFactory.variable!("flattenClassUnionClassUnionMember2"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}ClassUnionMember2`
                : "flattenClassUnionClassUnionMember2",
            }).concat(),
            type: "group",
          },
          {
            patterns: FlattenClassUnionMember3.$sparqlWherePatterns({
              filter: parameters?.filter?.on?.FlattenClassUnionMember3,
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "flattenClassUnionFlattenClassUnionMember3",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}FlattenClassUnionMember3`
                : "flattenClassUnionFlattenClassUnionMember3",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function $toJson(
    _flattenClassUnion: FlattenClassUnion,
  ):
    | ClassUnionMember1.$Json
    | ClassUnionMember2.$Json
    | FlattenClassUnionMember3.$Json {
    switch (_flattenClassUnion.$type) {
      case "ClassUnionMember1":
        return _flattenClassUnion.$toJson();
      case "ClassUnionMember2":
        return _flattenClassUnion.$toJson();
      case "FlattenClassUnionMember3":
        return _flattenClassUnion.$toJson();
      default:
        _flattenClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export function $toRdf(
    _flattenClassUnion: FlattenClassUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    switch (_flattenClassUnion.$type) {
      case "ClassUnionMember1":
        return _flattenClassUnion.$toRdf(_parameters);
      case "ClassUnionMember2":
        return _flattenClassUnion.$toRdf(_parameters);
      case "FlattenClassUnionMember3":
        return _flattenClassUnion.$toRdf(_parameters);
      default:
        _flattenClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }
}
/**
 * Node shape that sh:xone's other node shapes. This will usually be generated as a discriminated union.
 */
export type InterfaceUnion = InterfaceUnionMember1 | InterfaceUnionMember2;

export namespace InterfaceUnion {
  export function $equals(
    left: InterfaceUnion,
    right: InterfaceUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      switch (left.$type) {
        case "InterfaceUnionMember1":
          return InterfaceUnionMember1.$equals(
            left,
            right as unknown as InterfaceUnionMember1,
          );
        case "InterfaceUnionMember2":
          return InterfaceUnionMember2.$equals(
            left,
            right as unknown as InterfaceUnionMember2,
          );
        default:
          left satisfies never;
          throw new Error("unrecognized type");
      }
    });
  }

  export function $filter(
    filter: InterfaceUnion.$Filter,
    value: InterfaceUnion,
  ): boolean {
    if (typeof filter.on?.InterfaceUnionMember1 !== "undefined") {
      switch (value.$type) {
        case "InterfaceUnionMember1":
          if (
            !InterfaceUnionMember1.$filter(
              filter.on.InterfaceUnionMember1,
              value as InterfaceUnionMember1,
            )
          ) {
            return false;
          }
          break;
      }
    }

    if (typeof filter.on?.InterfaceUnionMember2 !== "undefined") {
      switch (value.$type) {
        case "InterfaceUnionMember2":
          if (
            !InterfaceUnionMember2.$filter(
              filter.on.InterfaceUnionMember2,
              value as InterfaceUnionMember2,
            )
          ) {
            return false;
          }
          break;
      }
    }

    return true;
  }

  export type $Filter = {
    readonly on?: {
      readonly InterfaceUnionMember1?: InterfaceUnionMember1.$Filter;
      readonly InterfaceUnionMember2?: InterfaceUnionMember2.$Filter;
    };
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, InterfaceUnion> {
    return (
      InterfaceUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        InterfaceUnion
      >
    ).altLazy(
      () =>
        InterfaceUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          InterfaceUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, InterfaceUnion> {
    return (
      InterfaceUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, InterfaceUnion>
    ).altLazy(
      () =>
        InterfaceUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, InterfaceUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_interfaceUnion: InterfaceUnion, _hasher: HasherT): HasherT {
    switch (_interfaceUnion.$type) {
      case "InterfaceUnionMember1":
        return InterfaceUnionMember1.$hash(_interfaceUnion, _hasher);
      case "InterfaceUnionMember2":
        return InterfaceUnionMember2.$hash(_interfaceUnion, _hasher);
      default:
        _interfaceUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = InterfaceUnionMember1.$Json | InterfaceUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      InterfaceUnionMember1.$jsonZodSchema(),
      InterfaceUnionMember2.$jsonZodSchema(),
    ]);
  }

  export const $properties = {
    interfaceUnionMemberCommonParentProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/interfaceUnionMemberCommonParentProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: InterfaceUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InterfaceUnion.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            InterfaceUnion.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: InterfaceUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InterfaceUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...InterfaceUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("interfaceUnionInterfaceUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}InterfaceUnionMember1`
          : "interfaceUnionInterfaceUnionMember1",
      }).concat(),
      ...InterfaceUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("interfaceUnionInterfaceUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}InterfaceUnionMember2`
          : "interfaceUnionInterfaceUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: InterfaceUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: InterfaceUnionMember1.$sparqlWherePatterns({
              filter: parameters?.filter?.on?.InterfaceUnionMember1,
              subject:
                parameters?.subject ??
                dataFactory.variable!("interfaceUnionInterfaceUnionMember1"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}InterfaceUnionMember1`
                : "interfaceUnionInterfaceUnionMember1",
            }).concat(),
            type: "group",
          },
          {
            patterns: InterfaceUnionMember2.$sparqlWherePatterns({
              filter: parameters?.filter?.on?.InterfaceUnionMember2,
              subject:
                parameters?.subject ??
                dataFactory.variable!("interfaceUnionInterfaceUnionMember2"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}InterfaceUnionMember2`
                : "interfaceUnionInterfaceUnionMember2",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function $toJson(
    _interfaceUnion: InterfaceUnion,
  ): InterfaceUnionMember1.$Json | InterfaceUnionMember2.$Json {
    switch (_interfaceUnion.$type) {
      case "InterfaceUnionMember1":
        return InterfaceUnionMember1.$toJson(_interfaceUnion);
      case "InterfaceUnionMember2":
        return InterfaceUnionMember2.$toJson(_interfaceUnion);
      default:
        _interfaceUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export function $toRdf(
    _interfaceUnion: InterfaceUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    switch (_interfaceUnion.$type) {
      case "InterfaceUnionMember1":
        return InterfaceUnionMember1.$toRdf(_interfaceUnion, _parameters);
      case "InterfaceUnionMember2":
        return InterfaceUnionMember2.$toRdf(_interfaceUnion, _parameters);
      default:
        _interfaceUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export function isInterfaceUnion(
    object: InterfaceUnionMemberCommonParent,
  ): object is InterfaceUnion {
    switch (object.$type) {
      case "InterfaceUnionMember1":
      case "InterfaceUnionMember2":
        return true;
      default:
        return false;
    }
  }
}
/**
 * Node shape sh:xone's other node shapes. This will usually be generated as a discriminated union.
 */
export type LazilyResolvedClassUnion =
  | LazilyResolvedClassUnionMember1
  | LazilyResolvedClassUnionMember2;

export namespace LazilyResolvedClassUnion {
  export function $equals(
    left: LazilyResolvedClassUnion,
    right: LazilyResolvedClassUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      switch (left.$type) {
        case "LazilyResolvedClassUnionMember1":
          return left.$equals(
            right as unknown as LazilyResolvedClassUnionMember1,
          );
        case "LazilyResolvedClassUnionMember2":
          return left.$equals(
            right as unknown as LazilyResolvedClassUnionMember2,
          );
        default:
          left satisfies never;
          throw new Error("unrecognized type");
      }
    });
  }

  export function $filter(
    filter: LazilyResolvedClassUnion.$Filter,
    value: LazilyResolvedClassUnion,
  ): boolean {
    if (typeof filter.on?.LazilyResolvedClassUnionMember1 !== "undefined") {
      switch (value.$type) {
        case "LazilyResolvedClassUnionMember1":
          if (
            !LazilyResolvedClassUnionMember1.$filter(
              filter.on.LazilyResolvedClassUnionMember1,
              value as LazilyResolvedClassUnionMember1,
            )
          ) {
            return false;
          }
          break;
      }
    }

    if (typeof filter.on?.LazilyResolvedClassUnionMember2 !== "undefined") {
      switch (value.$type) {
        case "LazilyResolvedClassUnionMember2":
          if (
            !LazilyResolvedClassUnionMember2.$filter(
              filter.on.LazilyResolvedClassUnionMember2,
              value as LazilyResolvedClassUnionMember2,
            )
          ) {
            return false;
          }
          break;
      }
    }

    return true;
  }

  export type $Filter = {
    readonly on?: {
      readonly LazilyResolvedClassUnionMember1?: LazilyResolvedClassUnionMember1.$Filter;
      readonly LazilyResolvedClassUnionMember2?: LazilyResolvedClassUnionMember2.$Filter;
    };
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedClassUnion> {
    return (
      LazilyResolvedClassUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        LazilyResolvedClassUnion
      >
    ).altLazy(
      () =>
        LazilyResolvedClassUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          LazilyResolvedClassUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedClassUnion> {
    return (
      LazilyResolvedClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, LazilyResolvedClassUnion>
    ).altLazy(
      () =>
        LazilyResolvedClassUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, LazilyResolvedClassUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedClassUnion: LazilyResolvedClassUnion,
    _hasher: HasherT,
  ): HasherT {
    switch (_lazilyResolvedClassUnion.$type) {
      case "LazilyResolvedClassUnionMember1":
        return _lazilyResolvedClassUnion.$hash(_hasher);
      case "LazilyResolvedClassUnionMember2":
        return _lazilyResolvedClassUnion.$hash(_hasher);
      default:
        _lazilyResolvedClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json =
    | LazilyResolvedClassUnionMember1.$Json
    | LazilyResolvedClassUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      LazilyResolvedClassUnionMember1.$jsonZodSchema(),
      LazilyResolvedClassUnionMember2.$jsonZodSchema(),
    ]);
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedClassUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedClassUnion.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazilyResolvedClassUnion.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedClassUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...LazilyResolvedClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "lazilyResolvedClassUnionLazilyResolvedClassUnionMember1",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember1`
          : "lazilyResolvedClassUnionLazilyResolvedClassUnionMember1",
      }).concat(),
      ...LazilyResolvedClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "lazilyResolvedClassUnionLazilyResolvedClassUnionMember2",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember2`
          : "lazilyResolvedClassUnionLazilyResolvedClassUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedClassUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: LazilyResolvedClassUnionMember1.$sparqlWherePatterns({
              filter: parameters?.filter?.on?.LazilyResolvedClassUnionMember1,
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "lazilyResolvedClassUnionLazilyResolvedClassUnionMember1",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember1`
                : "lazilyResolvedClassUnionLazilyResolvedClassUnionMember1",
            }).concat(),
            type: "group",
          },
          {
            patterns: LazilyResolvedClassUnionMember2.$sparqlWherePatterns({
              filter: parameters?.filter?.on?.LazilyResolvedClassUnionMember2,
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "lazilyResolvedClassUnionLazilyResolvedClassUnionMember2",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}LazilyResolvedClassUnionMember2`
                : "lazilyResolvedClassUnionLazilyResolvedClassUnionMember2",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function $toJson(
    _lazilyResolvedClassUnion: LazilyResolvedClassUnion,
  ):
    | LazilyResolvedClassUnionMember1.$Json
    | LazilyResolvedClassUnionMember2.$Json {
    switch (_lazilyResolvedClassUnion.$type) {
      case "LazilyResolvedClassUnionMember1":
        return _lazilyResolvedClassUnion.$toJson();
      case "LazilyResolvedClassUnionMember2":
        return _lazilyResolvedClassUnion.$toJson();
      default:
        _lazilyResolvedClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export function $toRdf(
    _lazilyResolvedClassUnion: LazilyResolvedClassUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    switch (_lazilyResolvedClassUnion.$type) {
      case "LazilyResolvedClassUnionMember1":
        return _lazilyResolvedClassUnion.$toRdf(_parameters);
      case "LazilyResolvedClassUnionMember2":
        return _lazilyResolvedClassUnion.$toRdf(_parameters);
      default:
        _lazilyResolvedClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }
}
/**
 * Node shape sh:xone's other node shapes. This will usually be generated as a discriminated union.
 */
export type LazilyResolvedInterfaceUnion =
  | LazilyResolvedInterfaceUnionMember1
  | LazilyResolvedInterfaceUnionMember2;

export namespace LazilyResolvedInterfaceUnion {
  export function $equals(
    left: LazilyResolvedInterfaceUnion,
    right: LazilyResolvedInterfaceUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      switch (left.$type) {
        case "LazilyResolvedInterfaceUnionMember1":
          return LazilyResolvedInterfaceUnionMember1.$equals(
            left,
            right as unknown as LazilyResolvedInterfaceUnionMember1,
          );
        case "LazilyResolvedInterfaceUnionMember2":
          return LazilyResolvedInterfaceUnionMember2.$equals(
            left,
            right as unknown as LazilyResolvedInterfaceUnionMember2,
          );
        default:
          left satisfies never;
          throw new Error("unrecognized type");
      }
    });
  }

  export function $filter(
    filter: LazilyResolvedInterfaceUnion.$Filter,
    value: LazilyResolvedInterfaceUnion,
  ): boolean {
    if (typeof filter.on?.LazilyResolvedInterfaceUnionMember1 !== "undefined") {
      switch (value.$type) {
        case "LazilyResolvedInterfaceUnionMember1":
          if (
            !LazilyResolvedInterfaceUnionMember1.$filter(
              filter.on.LazilyResolvedInterfaceUnionMember1,
              value as LazilyResolvedInterfaceUnionMember1,
            )
          ) {
            return false;
          }
          break;
      }
    }

    if (typeof filter.on?.LazilyResolvedInterfaceUnionMember2 !== "undefined") {
      switch (value.$type) {
        case "LazilyResolvedInterfaceUnionMember2":
          if (
            !LazilyResolvedInterfaceUnionMember2.$filter(
              filter.on.LazilyResolvedInterfaceUnionMember2,
              value as LazilyResolvedInterfaceUnionMember2,
            )
          ) {
            return false;
          }
          break;
      }
    }

    return true;
  }

  export type $Filter = {
    readonly on?: {
      readonly LazilyResolvedInterfaceUnionMember1?: LazilyResolvedInterfaceUnionMember1.$Filter;
      readonly LazilyResolvedInterfaceUnionMember2?: LazilyResolvedInterfaceUnionMember2.$Filter;
    };
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LazilyResolvedInterfaceUnion> {
    return (
      LazilyResolvedInterfaceUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        LazilyResolvedInterfaceUnion
      >
    ).altLazy(
      () =>
        LazilyResolvedInterfaceUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          LazilyResolvedInterfaceUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, LazilyResolvedInterfaceUnion> {
    return (
      LazilyResolvedInterfaceUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, LazilyResolvedInterfaceUnion>
    ).altLazy(
      () =>
        LazilyResolvedInterfaceUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, LazilyResolvedInterfaceUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _lazilyResolvedInterfaceUnion: LazilyResolvedInterfaceUnion,
    _hasher: HasherT,
  ): HasherT {
    switch (_lazilyResolvedInterfaceUnion.$type) {
      case "LazilyResolvedInterfaceUnionMember1":
        return LazilyResolvedInterfaceUnionMember1.$hash(
          _lazilyResolvedInterfaceUnion,
          _hasher,
        );
      case "LazilyResolvedInterfaceUnionMember2":
        return LazilyResolvedInterfaceUnionMember2.$hash(
          _lazilyResolvedInterfaceUnion,
          _hasher,
        );
      default:
        _lazilyResolvedInterfaceUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json =
    | LazilyResolvedInterfaceUnionMember1.$Json
    | LazilyResolvedInterfaceUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      LazilyResolvedInterfaceUnionMember1.$jsonZodSchema(),
      LazilyResolvedInterfaceUnionMember2.$jsonZodSchema(),
    ]);
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: LazilyResolvedInterfaceUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LazilyResolvedInterfaceUnion.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            LazilyResolvedInterfaceUnion.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: LazilyResolvedInterfaceUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LazilyResolvedInterfaceUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...LazilyResolvedInterfaceUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember1",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember1`
          : "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember1",
      }).concat(),
      ...LazilyResolvedInterfaceUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember2",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember2`
          : "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: LazilyResolvedInterfaceUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: LazilyResolvedInterfaceUnionMember1.$sparqlWherePatterns({
              filter:
                parameters?.filter?.on?.LazilyResolvedInterfaceUnionMember1,
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember1",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember1`
                : "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember1",
            }).concat(),
            type: "group",
          },
          {
            patterns: LazilyResolvedInterfaceUnionMember2.$sparqlWherePatterns({
              filter:
                parameters?.filter?.on?.LazilyResolvedInterfaceUnionMember2,
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember2",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}LazilyResolvedInterfaceUnionMember2`
                : "lazilyResolvedInterfaceUnionLazilyResolvedInterfaceUnionMember2",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function $toJson(
    _lazilyResolvedInterfaceUnion: LazilyResolvedInterfaceUnion,
  ):
    | LazilyResolvedInterfaceUnionMember1.$Json
    | LazilyResolvedInterfaceUnionMember2.$Json {
    switch (_lazilyResolvedInterfaceUnion.$type) {
      case "LazilyResolvedInterfaceUnionMember1":
        return LazilyResolvedInterfaceUnionMember1.$toJson(
          _lazilyResolvedInterfaceUnion,
        );
      case "LazilyResolvedInterfaceUnionMember2":
        return LazilyResolvedInterfaceUnionMember2.$toJson(
          _lazilyResolvedInterfaceUnion,
        );
      default:
        _lazilyResolvedInterfaceUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export function $toRdf(
    _lazilyResolvedInterfaceUnion: LazilyResolvedInterfaceUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    switch (_lazilyResolvedInterfaceUnion.$type) {
      case "LazilyResolvedInterfaceUnionMember1":
        return LazilyResolvedInterfaceUnionMember1.$toRdf(
          _lazilyResolvedInterfaceUnion,
          _parameters,
        );
      case "LazilyResolvedInterfaceUnionMember2":
        return LazilyResolvedInterfaceUnionMember2.$toRdf(
          _lazilyResolvedInterfaceUnion,
          _parameters,
        );
      default:
        _lazilyResolvedInterfaceUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }
}
/**
 * Counterpart of ClassUnion for lazy resolution. The partial union must have the same number of members, in the corresponding order, as the 'full' union.
 */
export type PartialClassUnion =
  | PartialClassUnionMember1
  | PartialClassUnionMember2;

export namespace PartialClassUnion {
  export function $equals(
    left: PartialClassUnion,
    right: PartialClassUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      switch (left.$type) {
        case "PartialClassUnionMember1":
          return left.$equals(right as unknown as PartialClassUnionMember1);
        case "PartialClassUnionMember2":
          return left.$equals(right as unknown as PartialClassUnionMember2);
        default:
          left satisfies never;
          throw new Error("unrecognized type");
      }
    });
  }

  export function $filter(
    filter: PartialClassUnion.$Filter,
    value: PartialClassUnion,
  ): boolean {
    if (typeof filter.on?.PartialClassUnionMember1 !== "undefined") {
      switch (value.$type) {
        case "PartialClassUnionMember1":
          if (
            !PartialClassUnionMember1.$filter(
              filter.on.PartialClassUnionMember1,
              value as PartialClassUnionMember1,
            )
          ) {
            return false;
          }
          break;
      }
    }

    if (typeof filter.on?.PartialClassUnionMember2 !== "undefined") {
      switch (value.$type) {
        case "PartialClassUnionMember2":
          if (
            !PartialClassUnionMember2.$filter(
              filter.on.PartialClassUnionMember2,
              value as PartialClassUnionMember2,
            )
          ) {
            return false;
          }
          break;
      }
    }

    return true;
  }

  export type $Filter = {
    readonly on?: {
      readonly PartialClassUnionMember1?: PartialClassUnionMember1.$Filter;
      readonly PartialClassUnionMember2?: PartialClassUnionMember2.$Filter;
    };
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialClassUnion> {
    return (
      PartialClassUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        PartialClassUnion
      >
    ).altLazy(
      () =>
        PartialClassUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          PartialClassUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialClassUnion> {
    return (
      PartialClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, PartialClassUnion>
    ).altLazy(
      () =>
        PartialClassUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, PartialClassUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_partialClassUnion: PartialClassUnion, _hasher: HasherT): HasherT {
    switch (_partialClassUnion.$type) {
      case "PartialClassUnionMember1":
        return _partialClassUnion.$hash(_hasher);
      case "PartialClassUnionMember2":
        return _partialClassUnion.$hash(_hasher);
      default:
        _partialClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json =
    | PartialClassUnionMember1.$Json
    | PartialClassUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      PartialClassUnionMember1.$jsonZodSchema(),
      PartialClassUnionMember2.$jsonZodSchema(),
    ]);
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialClassUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialClassUnion.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            PartialClassUnion.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialClassUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...PartialClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("partialClassUnionPartialClassUnionMember1"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialClassUnionMember1`
          : "partialClassUnionPartialClassUnionMember1",
      }).concat(),
      ...PartialClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("partialClassUnionPartialClassUnionMember2"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialClassUnionMember2`
          : "partialClassUnionPartialClassUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialClassUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: PartialClassUnionMember1.$sparqlWherePatterns({
              filter: parameters?.filter?.on?.PartialClassUnionMember1,
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "partialClassUnionPartialClassUnionMember1",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}PartialClassUnionMember1`
                : "partialClassUnionPartialClassUnionMember1",
            }).concat(),
            type: "group",
          },
          {
            patterns: PartialClassUnionMember2.$sparqlWherePatterns({
              filter: parameters?.filter?.on?.PartialClassUnionMember2,
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "partialClassUnionPartialClassUnionMember2",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}PartialClassUnionMember2`
                : "partialClassUnionPartialClassUnionMember2",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function $toJson(
    _partialClassUnion: PartialClassUnion,
  ): PartialClassUnionMember1.$Json | PartialClassUnionMember2.$Json {
    switch (_partialClassUnion.$type) {
      case "PartialClassUnionMember1":
        return _partialClassUnion.$toJson();
      case "PartialClassUnionMember2":
        return _partialClassUnion.$toJson();
      default:
        _partialClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export function $toRdf(
    _partialClassUnion: PartialClassUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    switch (_partialClassUnion.$type) {
      case "PartialClassUnionMember1":
        return _partialClassUnion.$toRdf(_parameters);
      case "PartialClassUnionMember2":
        return _partialClassUnion.$toRdf(_parameters);
      default:
        _partialClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }
}
/**
 * Counterpart of InterfaceUnion for lazy resolution. The partial union must have the same number of members, in the corresponding order, as the 'full' union.
 */
export type PartialInterfaceUnion =
  | PartialInterfaceUnionMember1
  | PartialInterfaceUnionMember2;

export namespace PartialInterfaceUnion {
  export function $equals(
    left: PartialInterfaceUnion,
    right: PartialInterfaceUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      switch (left.$type) {
        case "PartialInterfaceUnionMember1":
          return PartialInterfaceUnionMember1.$equals(
            left,
            right as unknown as PartialInterfaceUnionMember1,
          );
        case "PartialInterfaceUnionMember2":
          return PartialInterfaceUnionMember2.$equals(
            left,
            right as unknown as PartialInterfaceUnionMember2,
          );
        default:
          left satisfies never;
          throw new Error("unrecognized type");
      }
    });
  }

  export function $filter(
    filter: PartialInterfaceUnion.$Filter,
    value: PartialInterfaceUnion,
  ): boolean {
    if (typeof filter.on?.PartialInterfaceUnionMember1 !== "undefined") {
      switch (value.$type) {
        case "PartialInterfaceUnionMember1":
          if (
            !PartialInterfaceUnionMember1.$filter(
              filter.on.PartialInterfaceUnionMember1,
              value as PartialInterfaceUnionMember1,
            )
          ) {
            return false;
          }
          break;
      }
    }

    if (typeof filter.on?.PartialInterfaceUnionMember2 !== "undefined") {
      switch (value.$type) {
        case "PartialInterfaceUnionMember2":
          if (
            !PartialInterfaceUnionMember2.$filter(
              filter.on.PartialInterfaceUnionMember2,
              value as PartialInterfaceUnionMember2,
            )
          ) {
            return false;
          }
          break;
      }
    }

    return true;
  }

  export type $Filter = {
    readonly on?: {
      readonly PartialInterfaceUnionMember1?: PartialInterfaceUnionMember1.$Filter;
      readonly PartialInterfaceUnionMember2?: PartialInterfaceUnionMember2.$Filter;
    };
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PartialInterfaceUnion> {
    return (
      PartialInterfaceUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        PartialInterfaceUnion
      >
    ).altLazy(
      () =>
        PartialInterfaceUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          PartialInterfaceUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, PartialInterfaceUnion> {
    return (
      PartialInterfaceUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, PartialInterfaceUnion>
    ).altLazy(
      () =>
        PartialInterfaceUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, PartialInterfaceUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_partialInterfaceUnion: PartialInterfaceUnion, _hasher: HasherT): HasherT {
    switch (_partialInterfaceUnion.$type) {
      case "PartialInterfaceUnionMember1":
        return PartialInterfaceUnionMember1.$hash(
          _partialInterfaceUnion,
          _hasher,
        );
      case "PartialInterfaceUnionMember2":
        return PartialInterfaceUnionMember2.$hash(
          _partialInterfaceUnion,
          _hasher,
        );
      default:
        _partialInterfaceUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json =
    | PartialInterfaceUnionMember1.$Json
    | PartialInterfaceUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      PartialInterfaceUnionMember1.$jsonZodSchema(),
      PartialInterfaceUnionMember2.$jsonZodSchema(),
    ]);
  }

  export const $properties = {
    lazilyResolvedStringProperty: {
      identifier: dataFactory.namedNode(
        "http://example.com/lazilyResolvedStringProperty",
      ),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: PartialInterfaceUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PartialInterfaceUnion.$sparqlConstructTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            PartialInterfaceUnion.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: PartialInterfaceUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PartialInterfaceUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...PartialInterfaceUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "partialInterfaceUnionPartialInterfaceUnionMember1",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialInterfaceUnionMember1`
          : "partialInterfaceUnionPartialInterfaceUnionMember1",
      }).concat(),
      ...PartialInterfaceUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "partialInterfaceUnionPartialInterfaceUnionMember2",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PartialInterfaceUnionMember2`
          : "partialInterfaceUnionPartialInterfaceUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: PartialInterfaceUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: PartialInterfaceUnionMember1.$sparqlWherePatterns({
              filter: parameters?.filter?.on?.PartialInterfaceUnionMember1,
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "partialInterfaceUnionPartialInterfaceUnionMember1",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}PartialInterfaceUnionMember1`
                : "partialInterfaceUnionPartialInterfaceUnionMember1",
            }).concat(),
            type: "group",
          },
          {
            patterns: PartialInterfaceUnionMember2.$sparqlWherePatterns({
              filter: parameters?.filter?.on?.PartialInterfaceUnionMember2,
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "partialInterfaceUnionPartialInterfaceUnionMember2",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}PartialInterfaceUnionMember2`
                : "partialInterfaceUnionPartialInterfaceUnionMember2",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function $toJson(
    _partialInterfaceUnion: PartialInterfaceUnion,
  ): PartialInterfaceUnionMember1.$Json | PartialInterfaceUnionMember2.$Json {
    switch (_partialInterfaceUnion.$type) {
      case "PartialInterfaceUnionMember1":
        return PartialInterfaceUnionMember1.$toJson(_partialInterfaceUnion);
      case "PartialInterfaceUnionMember2":
        return PartialInterfaceUnionMember2.$toJson(_partialInterfaceUnion);
      default:
        _partialInterfaceUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export function $toRdf(
    _partialInterfaceUnion: PartialInterfaceUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    switch (_partialInterfaceUnion.$type) {
      case "PartialInterfaceUnionMember1":
        return PartialInterfaceUnionMember1.$toRdf(
          _partialInterfaceUnion,
          _parameters,
        );
      case "PartialInterfaceUnionMember2":
        return PartialInterfaceUnionMember2.$toRdf(
          _partialInterfaceUnion,
          _parameters,
        );
      default:
        _partialInterfaceUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }
}
/**
 * Node shape sh:xone's other node shapes. These don't have RDF types since they're not owl:Class's
 */
export type NoRdfTypeClassUnion =
  | NoRdfTypeClassUnionMember1
  | NoRdfTypeClassUnionMember2;

export namespace NoRdfTypeClassUnion {
  export function $equals(
    left: NoRdfTypeClassUnion,
    right: NoRdfTypeClassUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      switch (left.$type) {
        case "NoRdfTypeClassUnionMember1":
          return left.$equals(right as unknown as NoRdfTypeClassUnionMember1);
        case "NoRdfTypeClassUnionMember2":
          return left.$equals(right as unknown as NoRdfTypeClassUnionMember2);
        default:
          left satisfies never;
          throw new Error("unrecognized type");
      }
    });
  }

  export function $filter(
    filter: NoRdfTypeClassUnion.$Filter,
    value: NoRdfTypeClassUnion,
  ): boolean {
    if (typeof filter.on?.NoRdfTypeClassUnionMember1 !== "undefined") {
      switch (value.$type) {
        case "NoRdfTypeClassUnionMember1":
          if (
            !NoRdfTypeClassUnionMember1.$filter(
              filter.on.NoRdfTypeClassUnionMember1,
              value as NoRdfTypeClassUnionMember1,
            )
          ) {
            return false;
          }
          break;
      }
    }

    if (typeof filter.on?.NoRdfTypeClassUnionMember2 !== "undefined") {
      switch (value.$type) {
        case "NoRdfTypeClassUnionMember2":
          if (
            !NoRdfTypeClassUnionMember2.$filter(
              filter.on.NoRdfTypeClassUnionMember2,
              value as NoRdfTypeClassUnionMember2,
            )
          ) {
            return false;
          }
          break;
      }
    }

    return true;
  }

  export type $Filter = {
    readonly on?: {
      readonly NoRdfTypeClassUnionMember1?: NoRdfTypeClassUnionMember1.$Filter;
      readonly NoRdfTypeClassUnionMember2?: NoRdfTypeClassUnionMember2.$Filter;
    };
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, NoRdfTypeClassUnion> {
    return (
      NoRdfTypeClassUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        NoRdfTypeClassUnion
      >
    ).altLazy(
      () =>
        NoRdfTypeClassUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          NoRdfTypeClassUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, NoRdfTypeClassUnion> {
    return (
      NoRdfTypeClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, NoRdfTypeClassUnion>
    ).altLazy(
      () =>
        NoRdfTypeClassUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, NoRdfTypeClassUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_noRdfTypeClassUnion: NoRdfTypeClassUnion, _hasher: HasherT): HasherT {
    switch (_noRdfTypeClassUnion.$type) {
      case "NoRdfTypeClassUnionMember1":
        return _noRdfTypeClassUnion.$hash(_hasher);
      case "NoRdfTypeClassUnionMember2":
        return _noRdfTypeClassUnion.$hash(_hasher);
      default:
        _noRdfTypeClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json =
    | NoRdfTypeClassUnionMember1.$Json
    | NoRdfTypeClassUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      NoRdfTypeClassUnionMember1.$jsonZodSchema(),
      NoRdfTypeClassUnionMember2.$jsonZodSchema(),
    ]);
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: NoRdfTypeClassUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        NoRdfTypeClassUnion.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            NoRdfTypeClassUnion.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: NoRdfTypeClassUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      NoRdfTypeClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...NoRdfTypeClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "noRdfTypeClassUnionNoRdfTypeClassUnionMember1",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}NoRdfTypeClassUnionMember1`
          : "noRdfTypeClassUnionNoRdfTypeClassUnionMember1",
      }).concat(),
      ...NoRdfTypeClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "noRdfTypeClassUnionNoRdfTypeClassUnionMember2",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}NoRdfTypeClassUnionMember2`
          : "noRdfTypeClassUnionNoRdfTypeClassUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: NoRdfTypeClassUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: NoRdfTypeClassUnionMember1.$sparqlWherePatterns({
              filter: parameters?.filter?.on?.NoRdfTypeClassUnionMember1,
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "noRdfTypeClassUnionNoRdfTypeClassUnionMember1",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}NoRdfTypeClassUnionMember1`
                : "noRdfTypeClassUnionNoRdfTypeClassUnionMember1",
            }).concat(),
            type: "group",
          },
          {
            patterns: NoRdfTypeClassUnionMember2.$sparqlWherePatterns({
              filter: parameters?.filter?.on?.NoRdfTypeClassUnionMember2,
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "noRdfTypeClassUnionNoRdfTypeClassUnionMember2",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}NoRdfTypeClassUnionMember2`
                : "noRdfTypeClassUnionNoRdfTypeClassUnionMember2",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function $toJson(
    _noRdfTypeClassUnion: NoRdfTypeClassUnion,
  ): NoRdfTypeClassUnionMember1.$Json | NoRdfTypeClassUnionMember2.$Json {
    switch (_noRdfTypeClassUnion.$type) {
      case "NoRdfTypeClassUnionMember1":
        return _noRdfTypeClassUnion.$toJson();
      case "NoRdfTypeClassUnionMember2":
        return _noRdfTypeClassUnion.$toJson();
      default:
        _noRdfTypeClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export function $toRdf(
    _noRdfTypeClassUnion: NoRdfTypeClassUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    switch (_noRdfTypeClassUnion.$type) {
      case "NoRdfTypeClassUnionMember1":
        return _noRdfTypeClassUnion.$toRdf(_parameters);
      case "NoRdfTypeClassUnionMember2":
        return _noRdfTypeClassUnion.$toRdf(_parameters);
      default:
        _noRdfTypeClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }
}
/**
 * Node shape sh:xone's node shapes that have properties with the union's type
 */
export type RecursiveClassUnion =
  | RecursiveClassUnionMember1
  | RecursiveClassUnionMember2;

export namespace RecursiveClassUnion {
  export function $equals(
    left: RecursiveClassUnion,
    right: RecursiveClassUnion,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      switch (left.$type) {
        case "RecursiveClassUnionMember1":
          return left.$equals(right as unknown as RecursiveClassUnionMember1);
        case "RecursiveClassUnionMember2":
          return left.$equals(right as unknown as RecursiveClassUnionMember2);
        default:
          left satisfies never;
          throw new Error("unrecognized type");
      }
    });
  }

  export function $filter(
    filter: RecursiveClassUnion.$Filter,
    value: RecursiveClassUnion,
  ): boolean {
    if (typeof filter.on?.RecursiveClassUnionMember1 !== "undefined") {
      switch (value.$type) {
        case "RecursiveClassUnionMember1":
          if (
            !RecursiveClassUnionMember1.$filter(
              filter.on.RecursiveClassUnionMember1,
              value as RecursiveClassUnionMember1,
            )
          ) {
            return false;
          }
          break;
      }
    }

    if (typeof filter.on?.RecursiveClassUnionMember2 !== "undefined") {
      switch (value.$type) {
        case "RecursiveClassUnionMember2":
          if (
            !RecursiveClassUnionMember2.$filter(
              filter.on.RecursiveClassUnionMember2,
              value as RecursiveClassUnionMember2,
            )
          ) {
            return false;
          }
          break;
      }
    }

    return true;
  }

  export type $Filter = {
    readonly on?: {
      readonly RecursiveClassUnionMember1?: RecursiveClassUnionMember1.$Filter;
      readonly RecursiveClassUnionMember2?: RecursiveClassUnionMember2.$Filter;
    };
  };

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, RecursiveClassUnion> {
    return (
      RecursiveClassUnionMember1.$fromJson(json) as purify.Either<
        zod.ZodError,
        RecursiveClassUnion
      >
    ).altLazy(
      () =>
        RecursiveClassUnionMember2.$fromJson(json) as purify.Either<
          zod.ZodError,
          RecursiveClassUnion
        >,
    );
  }

  export function $fromRdf(
    resource: rdfjsResource.Resource,
    options?: {
      [_index: string]: any;
      ignoreRdfType?: boolean;
      objectSet?: $ObjectSet;
      preferredLanguages?: readonly string[];
    },
  ): purify.Either<Error, RecursiveClassUnion> {
    return (
      RecursiveClassUnionMember1.$fromRdf(resource, {
        ...options,
        ignoreRdfType: false,
      }) as purify.Either<Error, RecursiveClassUnion>
    ).altLazy(
      () =>
        RecursiveClassUnionMember2.$fromRdf(resource, {
          ...options,
          ignoreRdfType: false,
        }) as purify.Either<Error, RecursiveClassUnion>,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_recursiveClassUnion: RecursiveClassUnion, _hasher: HasherT): HasherT {
    switch (_recursiveClassUnion.$type) {
      case "RecursiveClassUnionMember1":
        return _recursiveClassUnion.$hash(_hasher);
      case "RecursiveClassUnionMember2":
        return _recursiveClassUnion.$hash(_hasher);
      default:
        _recursiveClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames: allow toString
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json =
    | RecursiveClassUnionMember1.$Json
    | RecursiveClassUnionMember2.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      RecursiveClassUnionMember1.$jsonZodSchema(),
      RecursiveClassUnionMember2.$jsonZodSchema(),
    ]);
  }

  export function $sparqlConstructQuery(
    parameters?: {
      filter?: RecursiveClassUnion.$Filter;
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const {
      filter,
      ignoreRdfType,
      preferredLanguages,
      subject,
      ...queryParameters
    } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        RecursiveClassUnion.$sparqlConstructTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        $insertSeedSparqlWherePattern(
          $optimizeSparqlWherePatterns(
            RecursiveClassUnion.$sparqlWherePatterns({
              filter,
              ignoreRdfType,
              preferredLanguages,
              subject,
            }),
          ),
        ),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      filter?: RecursiveClassUnion.$Filter;
      ignoreRdfType?: boolean;
      preferredLanguages?: readonly string[];
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      RecursiveClassUnion.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...RecursiveClassUnionMember1.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "recursiveClassUnionRecursiveClassUnionMember1",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}RecursiveClassUnionMember1`
          : "recursiveClassUnionRecursiveClassUnionMember1",
      }).concat(),
      ...RecursiveClassUnionMember2.$sparqlConstructTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!(
            "recursiveClassUnionRecursiveClassUnionMember2",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}RecursiveClassUnionMember2`
          : "recursiveClassUnionRecursiveClassUnionMember2",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    filter?: RecursiveClassUnion.$Filter;
    ignoreRdfType?: boolean;
    preferredLanguages?: readonly string[];
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: RecursiveClassUnionMember1.$sparqlWherePatterns({
              filter: parameters?.filter?.on?.RecursiveClassUnionMember1,
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "recursiveClassUnionRecursiveClassUnionMember1",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}RecursiveClassUnionMember1`
                : "recursiveClassUnionRecursiveClassUnionMember1",
            }).concat(),
            type: "group",
          },
          {
            patterns: RecursiveClassUnionMember2.$sparqlWherePatterns({
              filter: parameters?.filter?.on?.RecursiveClassUnionMember2,
              subject:
                parameters?.subject ??
                dataFactory.variable!(
                  "recursiveClassUnionRecursiveClassUnionMember2",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}RecursiveClassUnionMember2`
                : "recursiveClassUnionRecursiveClassUnionMember2",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function $toJson(
    _recursiveClassUnion: RecursiveClassUnion,
  ): RecursiveClassUnionMember1.$Json | RecursiveClassUnionMember2.$Json {
    switch (_recursiveClassUnion.$type) {
      case "RecursiveClassUnionMember1":
        return _recursiveClassUnion.$toJson();
      case "RecursiveClassUnionMember2":
        return _recursiveClassUnion.$toJson();
      default:
        _recursiveClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export function $toRdf(
    _recursiveClassUnion: RecursiveClassUnion,
    _parameters?: {
      mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
      resourceSet?: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    switch (_recursiveClassUnion.$type) {
      case "RecursiveClassUnionMember1":
        return _recursiveClassUnion.$toRdf(_parameters);
      case "RecursiveClassUnionMember2":
        return _recursiveClassUnion.$toRdf(_parameters);
      default:
        _recursiveClassUnion satisfies never;
        throw new Error("unrecognized type");
    }
  }
}
export interface $ObjectSet {
  baseInterfaceWithoutProperties(
    identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithoutProperties>>;
  baseInterfaceWithoutPropertiesIdentifiers(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithoutPropertiesStatic.$Identifier[]
    >
  >;
  baseInterfaceWithoutPropertieses(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithoutProperties[]>>;
  baseInterfaceWithoutPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  baseInterfaceWithProperties(
    identifier: BaseInterfaceWithPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithProperties>>;
  baseInterfaceWithPropertiesIdentifiers(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithPropertiesStatic.$Identifier[]
    >
  >;
  baseInterfaceWithPropertieses(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithProperties[]>>;
  baseInterfaceWithPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  blankNodeIdentifierClass(
    identifier: BlankNodeIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeIdentifierClass>>;
  blankNodeIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<BlankNodeIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeIdentifierClass.$Identifier[]>
  >;
  blankNodeIdentifierClasses(
    query?: $ObjectSet.Query<BlankNodeIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankNodeIdentifierClass[]>>;
  blankNodeIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<BlankNodeIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  blankNodeIdentifierInterface(
    identifier: BlankNodeIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeIdentifierInterface>>;
  blankNodeIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<BlankNodeIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeIdentifierInterface.$Identifier[]>
  >;
  blankNodeIdentifierInterfaces(
    query?: $ObjectSet.Query<BlankNodeIdentifierInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankNodeIdentifierInterface[]>>;
  blankNodeIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<BlankNodeIdentifierInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  blankNodeOrIriIdentifierClass(
    identifier: BlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeOrIriIdentifierClass>>;
  blankNodeOrIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeOrIriIdentifierClass.$Identifier[]>
  >;
  blankNodeOrIriIdentifierClasses(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankNodeOrIriIdentifierClass[]>>;
  blankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  blankNodeOrIriIdentifierInterface(
    identifier: BlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeOrIriIdentifierInterface>>;
  blankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly BlankNodeOrIriIdentifierInterface.$Identifier[]
    >
  >;
  blankNodeOrIriIdentifierInterfaces(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeOrIriIdentifierInterface[]>
  >;
  blankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  classUnionMember1(
    identifier: ClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember1>>;
  classUnionMember1Identifiers(
    query?: $ObjectSet.Query<ClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1.$Identifier[]>>;
  classUnionMember1s(
    query?: $ObjectSet.Query<ClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1[]>>;
  classUnionMember1sCount(
    query?: Pick<$ObjectSet.Query<ClassUnionMember1.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  classUnionMember2(
    identifier: ClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember2>>;
  classUnionMember2Identifiers(
    query?: $ObjectSet.Query<ClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2.$Identifier[]>>;
  classUnionMember2s(
    query?: $ObjectSet.Query<ClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2[]>>;
  classUnionMember2sCount(
    query?: Pick<$ObjectSet.Query<ClassUnionMember2.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  concreteChildClass(
    identifier: ConcreteChildClass.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildClass>>;
  concreteChildClassIdentifiers(
    query?: $ObjectSet.Query<ConcreteChildClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass.$Identifier[]>>;
  concreteChildClasses(
    query?: $ObjectSet.Query<ConcreteChildClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass[]>>;
  concreteChildClassesCount(
    query?: Pick<$ObjectSet.Query<ConcreteChildClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  concreteChildInterface(
    identifier: ConcreteChildInterface.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildInterface>>;
  concreteChildInterfaceIdentifiers(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteChildInterface.$Identifier[]>
  >;
  concreteChildInterfaces(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildInterface[]>>;
  concreteChildInterfacesCount(
    query?: Pick<$ObjectSet.Query<ConcreteChildInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  concreteParentClass(
    identifier: ConcreteParentClassStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentClass>>;
  concreteParentClassIdentifiers(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentClassStatic.$Identifier[]>
  >;
  concreteParentClasses(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteParentClass[]>>;
  concreteParentClassesCount(
    query?: Pick<
      $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  concreteParentInterface(
    identifier: ConcreteParentInterfaceStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentInterface>>;
  concreteParentInterfaceIdentifiers(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentInterfaceStatic.$Identifier[]>
  >;
  concreteParentInterfaces(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteParentInterface[]>>;
  concreteParentInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  convertibleTypePropertiesClass(
    identifier: ConvertibleTypePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ConvertibleTypePropertiesClass>>;
  convertibleTypePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConvertibleTypePropertiesClass.$Identifier[]>
  >;
  convertibleTypePropertiesClasses(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConvertibleTypePropertiesClass[]>>;
  convertibleTypePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  dateUnionPropertiesClass(
    identifier: DateUnionPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, DateUnionPropertiesClass>>;
  dateUnionPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<DateUnionPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly DateUnionPropertiesClass.$Identifier[]>
  >;
  dateUnionPropertiesClasses(
    query?: $ObjectSet.Query<DateUnionPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DateUnionPropertiesClass[]>>;
  dateUnionPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<DateUnionPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  defaultValuePropertiesClass(
    identifier: DefaultValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, DefaultValuePropertiesClass>>;
  defaultValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly DefaultValuePropertiesClass.$Identifier[]>
  >;
  defaultValuePropertiesClasses(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DefaultValuePropertiesClass[]>>;
  defaultValuePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  directRecursiveClass(
    identifier: DirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, DirectRecursiveClass>>;
  directRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DirectRecursiveClass.$Identifier[]>>;
  directRecursiveClasses(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DirectRecursiveClass[]>>;
  directRecursiveClassesCount(
    query?: Pick<$ObjectSet.Query<DirectRecursiveClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  explicitFromToRdfTypesClass(
    identifier: ExplicitFromToRdfTypesClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitFromToRdfTypesClass>>;
  explicitFromToRdfTypesClassIdentifiers(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExplicitFromToRdfTypesClass.$Identifier[]>
  >;
  explicitFromToRdfTypesClasses(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExplicitFromToRdfTypesClass[]>>;
  explicitFromToRdfTypesClassesCount(
    query?: Pick<
      $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  explicitRdfTypeClass(
    identifier: ExplicitRdfTypeClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitRdfTypeClass>>;
  explicitRdfTypeClassIdentifiers(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExplicitRdfTypeClass.$Identifier[]>>;
  explicitRdfTypeClasses(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExplicitRdfTypeClass[]>>;
  explicitRdfTypeClassesCount(
    query?: Pick<$ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  externClassPropertyClass(
    identifier: ExternClassPropertyClass.$Identifier,
  ): Promise<purify.Either<Error, ExternClassPropertyClass>>;
  externClassPropertyClassIdentifiers(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExternClassPropertyClass.$Identifier[]>
  >;
  externClassPropertyClasses(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExternClassPropertyClass[]>>;
  externClassPropertyClassesCount(
    query?: Pick<
      $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  flattenClassUnionMember3(
    identifier: FlattenClassUnionMember3.$Identifier,
  ): Promise<purify.Either<Error, FlattenClassUnionMember3>>;
  flattenClassUnionMember3Identifiers(
    query?: $ObjectSet.Query<FlattenClassUnionMember3.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly FlattenClassUnionMember3.$Identifier[]>
  >;
  flattenClassUnionMember3s(
    query?: $ObjectSet.Query<FlattenClassUnionMember3.$Identifier>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnionMember3[]>>;
  flattenClassUnionMember3sCount(
    query?: Pick<
      $ObjectSet.Query<FlattenClassUnionMember3.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  hasValuePropertiesClass(
    identifier: HasValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, HasValuePropertiesClass>>;
  hasValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly HasValuePropertiesClass.$Identifier[]>
  >;
  hasValuePropertiesClasses(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly HasValuePropertiesClass[]>>;
  hasValuePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  identifierOverride3Class(
    identifier: IdentifierOverride3ClassStatic.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride3Class>>;
  identifierOverride3ClassIdentifiers(
    query?: $ObjectSet.Query<IdentifierOverride3ClassStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride3ClassStatic.$Identifier[]>
  >;
  identifierOverride3Classes(
    query?: $ObjectSet.Query<IdentifierOverride3ClassStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride3Class[]>>;
  identifierOverride3ClassesCount(
    query?: Pick<
      $ObjectSet.Query<IdentifierOverride3ClassStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  identifierOverride4Class(
    identifier: IdentifierOverride4ClassStatic.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride4Class>>;
  identifierOverride4ClassIdentifiers(
    query?: $ObjectSet.Query<IdentifierOverride4ClassStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride4ClassStatic.$Identifier[]>
  >;
  identifierOverride4Classes(
    query?: $ObjectSet.Query<IdentifierOverride4ClassStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride4Class[]>>;
  identifierOverride4ClassesCount(
    query?: Pick<
      $ObjectSet.Query<IdentifierOverride4ClassStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  identifierOverride5Class(
    identifier: IdentifierOverride5Class.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride5Class>>;
  identifierOverride5ClassIdentifiers(
    query?: $ObjectSet.Query<IdentifierOverride5Class.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride5Class.$Identifier[]>
  >;
  identifierOverride5Classes(
    query?: $ObjectSet.Query<IdentifierOverride5Class.$Identifier>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride5Class[]>>;
  identifierOverride5ClassesCount(
    query?: Pick<
      $ObjectSet.Query<IdentifierOverride5Class.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  indirectRecursiveClass(
    identifier: IndirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveClass>>;
  indirectRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveClass.$Identifier[]>
  >;
  indirectRecursiveClasses(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveClass[]>>;
  indirectRecursiveClassesCount(
    query?: Pick<$ObjectSet.Query<IndirectRecursiveClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  indirectRecursiveHelperClass(
    identifier: IndirectRecursiveHelperClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveHelperClass>>;
  indirectRecursiveHelperClassIdentifiers(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveHelperClass.$Identifier[]>
  >;
  indirectRecursiveHelperClasses(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveHelperClass[]>>;
  indirectRecursiveHelperClassesCount(
    query?: Pick<
      $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  inIdentifierClass(
    identifier: InIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, InIdentifierClass>>;
  inIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<InIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass.$Identifier[]>>;
  inIdentifierClasses(
    query?: $ObjectSet.Query<InIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass[]>>;
  inIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<InIdentifierClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  inPropertiesClass(
    identifier: InPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, InPropertiesClass>>;
  inPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<InPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass.$Identifier[]>>;
  inPropertiesClasses(
    query?: $ObjectSet.Query<InPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass[]>>;
  inPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<InPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  interface(
    identifier: Interface.$Identifier,
  ): Promise<purify.Either<Error, Interface>>;
  interfaceIdentifiers(
    query?: $ObjectSet.Query<Interface.$Identifier>,
  ): Promise<purify.Either<Error, readonly Interface.$Identifier[]>>;
  interfaces(
    query?: $ObjectSet.Query<Interface.$Identifier>,
  ): Promise<purify.Either<Error, readonly Interface[]>>;
  interfacesCount(
    query?: Pick<$ObjectSet.Query<Interface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  interfaceUnionMember1(
    identifier: InterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember1>>;
  interfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember1.$Identifier[]>
  >;
  interfaceUnionMember1s(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember1[]>>;
  interfaceUnionMember1sCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember1.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  interfaceUnionMember2(
    identifier: InterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember2>>;
  interfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember2.$Identifier[]>
  >;
  interfaceUnionMember2s(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember2[]>>;
  interfaceUnionMember2sCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember2.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  iriIdentifierClass(
    identifier: IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, IriIdentifierClass>>;
  iriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<IriIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IriIdentifierClass.$Identifier[]>>;
  iriIdentifierClasses(
    query?: $ObjectSet.Query<IriIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IriIdentifierClass[]>>;
  iriIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<IriIdentifierClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  iriIdentifierInterface(
    identifier: IriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, IriIdentifierInterface>>;
  iriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<IriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IriIdentifierInterface.$Identifier[]>
  >;
  iriIdentifierInterfaces(
    query?: $ObjectSet.Query<IriIdentifierInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly IriIdentifierInterface[]>>;
  iriIdentifierInterfacesCount(
    query?: Pick<$ObjectSet.Query<IriIdentifierInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  jsPrimitiveUnionPropertyClass(
    identifier: JsPrimitiveUnionPropertyClass.$Identifier,
  ): Promise<purify.Either<Error, JsPrimitiveUnionPropertyClass>>;
  jsPrimitiveUnionPropertyClassIdentifiers(
    query?: $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly JsPrimitiveUnionPropertyClass.$Identifier[]>
  >;
  jsPrimitiveUnionPropertyClasses(
    query?: $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly JsPrimitiveUnionPropertyClass[]>>;
  jsPrimitiveUnionPropertyClassesCount(
    query?: Pick<
      $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  languageInPropertiesClass(
    identifier: LanguageInPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LanguageInPropertiesClass>>;
  languageInPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LanguageInPropertiesClass.$Identifier[]>
  >;
  languageInPropertiesClasses(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LanguageInPropertiesClass[]>>;
  languageInPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedBlankNodeOrIriIdentifierClass(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierClass>>;
  lazilyResolvedBlankNodeOrIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier[]
    >
  >;
  lazilyResolvedBlankNodeOrIriIdentifierClasses(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedBlankNodeOrIriIdentifierClass[]>
  >;
  lazilyResolvedBlankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedBlankNodeOrIriIdentifierInterface(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<
    purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierInterface>
  >;
  lazilyResolvedBlankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier[]
    >
  >;
  lazilyResolvedBlankNodeOrIriIdentifierInterfaces(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[]
    >
  >;
  lazilyResolvedBlankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedClassUnionMember1(
    identifier: LazilyResolvedClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember1>>;
  lazilyResolvedClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember1.$Identifier[]>
  >;
  lazilyResolvedClassUnionMember1s(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember1[]>>;
  lazilyResolvedClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedClassUnionMember2(
    identifier: LazilyResolvedClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember2>>;
  lazilyResolvedClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember2.$Identifier[]>
  >;
  lazilyResolvedClassUnionMember2s(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember2[]>>;
  lazilyResolvedClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedInterfaceUnionMember1(
    identifier: LazilyResolvedInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember1>>;
  lazilyResolvedInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember1.$Identifier[]
    >
  >;
  lazilyResolvedInterfaceUnionMember1s(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember1[]>
  >;
  lazilyResolvedInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedInterfaceUnionMember2(
    identifier: LazilyResolvedInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember2>>;
  lazilyResolvedInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember2.$Identifier[]
    >
  >;
  lazilyResolvedInterfaceUnionMember2s(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember2[]>
  >;
  lazilyResolvedInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedIriIdentifierClass(
    identifier: LazilyResolvedIriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriIdentifierClass>>;
  lazilyResolvedIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedIriIdentifierClass.$Identifier[]
    >
  >;
  lazilyResolvedIriIdentifierClasses(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedIriIdentifierClass[]>>;
  lazilyResolvedIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedIriIdentifierInterface(
    identifier: LazilyResolvedIriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriIdentifierInterface>>;
  lazilyResolvedIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedIriIdentifierInterface.$Identifier[]
    >
  >;
  lazilyResolvedIriIdentifierInterfaces(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriIdentifierInterface[]>
  >;
  lazilyResolvedIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazyPropertiesClass(
    identifier: LazyPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesClass>>;
  lazyPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass.$Identifier[]>>;
  lazyPropertiesClasses(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass[]>>;
  lazyPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<LazyPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  lazyPropertiesInterface(
    identifier: LazyPropertiesInterface.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesInterface>>;
  lazyPropertiesInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazyPropertiesInterface.$Identifier[]>
  >;
  lazyPropertiesInterfaces(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesInterface[]>>;
  lazyPropertiesInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  listPropertiesClass(
    identifier: ListPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ListPropertiesClass>>;
  listPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<ListPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass.$Identifier[]>>;
  listPropertiesClasses(
    query?: $ObjectSet.Query<ListPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass[]>>;
  listPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<ListPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  mutablePropertiesClass(
    identifier: MutablePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, MutablePropertiesClass>>;
  mutablePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly MutablePropertiesClass.$Identifier[]>
  >;
  mutablePropertiesClasses(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly MutablePropertiesClass[]>>;
  mutablePropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<MutablePropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  nonClass(
    identifier: NonClass.$Identifier,
  ): Promise<purify.Either<Error, NonClass>>;
  nonClassIdentifiers(
    query?: $ObjectSet.Query<NonClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly NonClass.$Identifier[]>>;
  nonClasses(
    query?: $ObjectSet.Query<NonClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly NonClass[]>>;
  nonClassesCount(
    query?: Pick<$ObjectSet.Query<NonClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  noRdfTypeClassUnionMember1(
    identifier: NoRdfTypeClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnionMember1>>;
  noRdfTypeClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly NoRdfTypeClassUnionMember1.$Identifier[]>
  >;
  noRdfTypeClassUnionMember1s(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnionMember1[]>>;
  noRdfTypeClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  noRdfTypeClassUnionMember2(
    identifier: NoRdfTypeClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnionMember2>>;
  noRdfTypeClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly NoRdfTypeClassUnionMember2.$Identifier[]>
  >;
  noRdfTypeClassUnionMember2s(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnionMember2[]>>;
  noRdfTypeClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  orderedPropertiesClass(
    identifier: OrderedPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, OrderedPropertiesClass>>;
  orderedPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly OrderedPropertiesClass.$Identifier[]>
  >;
  orderedPropertiesClasses(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly OrderedPropertiesClass[]>>;
  orderedPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<OrderedPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  partialClass(
    identifier: PartialClass.$Identifier,
  ): Promise<purify.Either<Error, PartialClass>>;
  partialClassIdentifiers(
    query?: $ObjectSet.Query<PartialClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClass.$Identifier[]>>;
  partialClasses(
    query?: $ObjectSet.Query<PartialClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClass[]>>;
  partialClassesCount(
    query?: Pick<$ObjectSet.Query<PartialClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  partialClassUnionMember1(
    identifier: PartialClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember1>>;
  partialClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember1.$Identifier[]>
  >;
  partialClassUnionMember1s(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember1[]>>;
  partialClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  partialClassUnionMember2(
    identifier: PartialClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember2>>;
  partialClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember2.$Identifier[]>
  >;
  partialClassUnionMember2s(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember2[]>>;
  partialClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  partialInterface(
    identifier: PartialInterface.$Identifier,
  ): Promise<purify.Either<Error, PartialInterface>>;
  partialInterfaceIdentifiers(
    query?: $ObjectSet.Query<PartialInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterface.$Identifier[]>>;
  partialInterfaces(
    query?: $ObjectSet.Query<PartialInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterface[]>>;
  partialInterfacesCount(
    query?: Pick<$ObjectSet.Query<PartialInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  partialInterfaceUnionMember1(
    identifier: PartialInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember1>>;
  partialInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember1.$Identifier[]>
  >;
  partialInterfaceUnionMember1s(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember1[]>>;
  partialInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  partialInterfaceUnionMember2(
    identifier: PartialInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember2>>;
  partialInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember2.$Identifier[]>
  >;
  partialInterfaceUnionMember2s(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember2[]>>;
  partialInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  propertyCardinalitiesClass(
    identifier: PropertyCardinalitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyCardinalitiesClass>>;
  propertyCardinalitiesClassIdentifiers(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PropertyCardinalitiesClass.$Identifier[]>
  >;
  propertyCardinalitiesClasses(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PropertyCardinalitiesClass[]>>;
  propertyCardinalitiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  propertyVisibilitiesClass(
    identifier: PropertyVisibilitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyVisibilitiesClass>>;
  propertyVisibilitiesClassIdentifiers(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PropertyVisibilitiesClass.$Identifier[]>
  >;
  propertyVisibilitiesClasses(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PropertyVisibilitiesClass[]>>;
  propertyVisibilitiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  recursiveClassUnionMember1(
    identifier: RecursiveClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember1>>;
  recursiveClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember1.$Identifier[]>
  >;
  recursiveClassUnionMember1s(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember1[]>>;
  recursiveClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  recursiveClassUnionMember2(
    identifier: RecursiveClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember2>>;
  recursiveClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember2.$Identifier[]>
  >;
  recursiveClassUnionMember2s(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember2[]>>;
  recursiveClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  sha256IriIdentifierClass(
    identifier: Sha256IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, Sha256IriIdentifierClass>>;
  sha256IriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<Sha256IriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly Sha256IriIdentifierClass.$Identifier[]>
  >;
  sha256IriIdentifierClasses(
    query?: $ObjectSet.Query<Sha256IriIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly Sha256IriIdentifierClass[]>>;
  sha256IriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<Sha256IriIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  termPropertiesClass(
    identifier: TermPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, TermPropertiesClass>>;
  termPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<TermPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass.$Identifier[]>>;
  termPropertiesClasses(
    query?: $ObjectSet.Query<TermPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass[]>>;
  termPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<TermPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  unionDiscriminantsClass(
    identifier: UnionDiscriminantsClass.$Identifier,
  ): Promise<purify.Either<Error, UnionDiscriminantsClass>>;
  unionDiscriminantsClassIdentifiers(
    query?: $ObjectSet.Query<UnionDiscriminantsClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly UnionDiscriminantsClass.$Identifier[]>
  >;
  unionDiscriminantsClasses(
    query?: $ObjectSet.Query<UnionDiscriminantsClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly UnionDiscriminantsClass[]>>;
  unionDiscriminantsClassesCount(
    query?: Pick<
      $ObjectSet.Query<UnionDiscriminantsClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  uuidV4IriIdentifierClass(
    identifier: UuidV4IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriIdentifierClass>>;
  uuidV4IriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<UuidV4IriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly UuidV4IriIdentifierClass.$Identifier[]>
  >;
  uuidV4IriIdentifierClasses(
    query?: $ObjectSet.Query<UuidV4IriIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriIdentifierClass[]>>;
  uuidV4IriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<UuidV4IriIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  uuidV4IriIdentifierInterface(
    identifier: UuidV4IriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriIdentifierInterface>>;
  uuidV4IriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<UuidV4IriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly UuidV4IriIdentifierInterface.$Identifier[]>
  >;
  uuidV4IriIdentifierInterfaces(
    query?: $ObjectSet.Query<UuidV4IriIdentifierInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriIdentifierInterface[]>>;
  uuidV4IriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<UuidV4IriIdentifierInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  classUnion(
    identifier: ClassUnion.$Identifier,
  ): Promise<purify.Either<Error, ClassUnion>>;
  classUnionIdentifiers(
    query?: $ObjectSet.Query<ClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnion.$Identifier[]>>;
  classUnions(
    query?: $ObjectSet.Query<ClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnion[]>>;
  classUnionsCount(
    query?: Pick<$ObjectSet.Query<ClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  flattenClassUnion(
    identifier: FlattenClassUnion.$Identifier,
  ): Promise<purify.Either<Error, FlattenClassUnion>>;
  flattenClassUnionIdentifiers(
    query?: $ObjectSet.Query<FlattenClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnion.$Identifier[]>>;
  flattenClassUnions(
    query?: $ObjectSet.Query<FlattenClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnion[]>>;
  flattenClassUnionsCount(
    query?: Pick<$ObjectSet.Query<FlattenClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  interfaceUnion(
    identifier: InterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnion>>;
  interfaceUnionIdentifiers(
    query?: $ObjectSet.Query<InterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion.$Identifier[]>>;
  interfaceUnions(
    query?: $ObjectSet.Query<InterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion[]>>;
  interfaceUnionsCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedClassUnion(
    identifier: LazilyResolvedClassUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnion>>;
  lazilyResolvedClassUnionIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnion.$Identifier[]>
  >;
  lazilyResolvedClassUnions(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnion[]>>;
  lazilyResolvedClassUnionsCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  lazilyResolvedInterfaceUnion(
    identifier: LazilyResolvedInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnion>>;
  lazilyResolvedInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnion.$Identifier[]>
  >;
  lazilyResolvedInterfaceUnions(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedInterfaceUnion[]>>;
  lazilyResolvedInterfaceUnionsCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  noRdfTypeClassUnion(
    identifier: NoRdfTypeClassUnion.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnion>>;
  noRdfTypeClassUnionIdentifiers(
    query?: $ObjectSet.Query<NoRdfTypeClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnion.$Identifier[]>>;
  noRdfTypeClassUnions(
    query?: $ObjectSet.Query<NoRdfTypeClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnion[]>>;
  noRdfTypeClassUnionsCount(
    query?: Pick<$ObjectSet.Query<NoRdfTypeClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  partialClassUnion(
    identifier: PartialClassUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnion>>;
  partialClassUnionIdentifiers(
    query?: $ObjectSet.Query<PartialClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion.$Identifier[]>>;
  partialClassUnions(
    query?: $ObjectSet.Query<PartialClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion[]>>;
  partialClassUnionsCount(
    query?: Pick<$ObjectSet.Query<PartialClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  partialInterfaceUnion(
    identifier: PartialInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnion>>;
  partialInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnion.$Identifier[]>
  >;
  partialInterfaceUnions(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnion[]>>;
  partialInterfaceUnionsCount(
    query?: Pick<$ObjectSet.Query<PartialInterfaceUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  recursiveClassUnion(
    identifier: RecursiveClassUnion.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnion>>;
  recursiveClassUnionIdentifiers(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion.$Identifier[]>>;
  recursiveClassUnions(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion[]>>;
  recursiveClassUnionsCount(
    query?: Pick<$ObjectSet.Query<RecursiveClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
}

export namespace $ObjectSet {
  export type Query<
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  > = {
    readonly limit?: number;
    readonly offset?: number;
    readonly where?: Where<ObjectIdentifierT>;
  };
  export type Where<
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  > =
    | {
        readonly identifiers: readonly ObjectIdentifierT[];
        readonly type: "identifiers";
      }
    | {
        readonly objectTermType?: "NamedNode";
        readonly predicate: rdfjs.NamedNode;
        readonly subject?: rdfjs.BlankNode | rdfjs.NamedNode;
        readonly type: "triple-objects";
      }
    | {
        readonly object?: rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode;
        readonly predicate: rdfjs.NamedNode;
        readonly subjectTermType?: "NamedNode";
        readonly type: "triple-subjects";
      }
    | { readonly identifierType?: "NamedNode"; readonly type: "type" };
}

export abstract class $ForwardingObjectSet implements $ObjectSet {
  protected abstract get $delegate(): $ObjectSet;

  baseInterfaceWithoutProperties(
    identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithoutProperties>> {
    return this.$delegate.baseInterfaceWithoutProperties(identifier);
  }

  baseInterfaceWithoutPropertiesIdentifiers(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithoutPropertiesStatic.$Identifier[]
    >
  > {
    return this.$delegate.baseInterfaceWithoutPropertiesIdentifiers(query);
  }

  baseInterfaceWithoutPropertieses(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithoutProperties[]>> {
    return this.$delegate.baseInterfaceWithoutPropertieses(query);
  }

  baseInterfaceWithoutPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.baseInterfaceWithoutPropertiesesCount(query);
  }

  baseInterfaceWithProperties(
    identifier: BaseInterfaceWithPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithProperties>> {
    return this.$delegate.baseInterfaceWithProperties(identifier);
  }

  baseInterfaceWithPropertiesIdentifiers(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithPropertiesStatic.$Identifier[]
    >
  > {
    return this.$delegate.baseInterfaceWithPropertiesIdentifiers(query);
  }

  baseInterfaceWithPropertieses(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithProperties[]>> {
    return this.$delegate.baseInterfaceWithPropertieses(query);
  }

  baseInterfaceWithPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.baseInterfaceWithPropertiesesCount(query);
  }

  blankNodeIdentifierClass(
    identifier: BlankNodeIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeIdentifierClass>> {
    return this.$delegate.blankNodeIdentifierClass(identifier);
  }

  blankNodeIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<BlankNodeIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeIdentifierClass.$Identifier[]>
  > {
    return this.$delegate.blankNodeIdentifierClassIdentifiers(query);
  }

  blankNodeIdentifierClasses(
    query?: $ObjectSet.Query<BlankNodeIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankNodeIdentifierClass[]>> {
    return this.$delegate.blankNodeIdentifierClasses(query);
  }

  blankNodeIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<BlankNodeIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.blankNodeIdentifierClassesCount(query);
  }

  blankNodeIdentifierInterface(
    identifier: BlankNodeIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeIdentifierInterface>> {
    return this.$delegate.blankNodeIdentifierInterface(identifier);
  }

  blankNodeIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<BlankNodeIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeIdentifierInterface.$Identifier[]>
  > {
    return this.$delegate.blankNodeIdentifierInterfaceIdentifiers(query);
  }

  blankNodeIdentifierInterfaces(
    query?: $ObjectSet.Query<BlankNodeIdentifierInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankNodeIdentifierInterface[]>> {
    return this.$delegate.blankNodeIdentifierInterfaces(query);
  }

  blankNodeIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<BlankNodeIdentifierInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.blankNodeIdentifierInterfacesCount(query);
  }

  blankNodeOrIriIdentifierClass(
    identifier: BlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeOrIriIdentifierClass>> {
    return this.$delegate.blankNodeOrIriIdentifierClass(identifier);
  }

  blankNodeOrIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeOrIriIdentifierClass.$Identifier[]>
  > {
    return this.$delegate.blankNodeOrIriIdentifierClassIdentifiers(query);
  }

  blankNodeOrIriIdentifierClasses(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankNodeOrIriIdentifierClass[]>> {
    return this.$delegate.blankNodeOrIriIdentifierClasses(query);
  }

  blankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.blankNodeOrIriIdentifierClassesCount(query);
  }

  blankNodeOrIriIdentifierInterface(
    identifier: BlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeOrIriIdentifierInterface>> {
    return this.$delegate.blankNodeOrIriIdentifierInterface(identifier);
  }

  blankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly BlankNodeOrIriIdentifierInterface.$Identifier[]
    >
  > {
    return this.$delegate.blankNodeOrIriIdentifierInterfaceIdentifiers(query);
  }

  blankNodeOrIriIdentifierInterfaces(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeOrIriIdentifierInterface[]>
  > {
    return this.$delegate.blankNodeOrIriIdentifierInterfaces(query);
  }

  blankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.blankNodeOrIriIdentifierInterfacesCount(query);
  }

  classUnionMember1(
    identifier: ClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember1>> {
    return this.$delegate.classUnionMember1(identifier);
  }

  classUnionMember1Identifiers(
    query?: $ObjectSet.Query<ClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1.$Identifier[]>> {
    return this.$delegate.classUnionMember1Identifiers(query);
  }

  classUnionMember1s(
    query?: $ObjectSet.Query<ClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1[]>> {
    return this.$delegate.classUnionMember1s(query);
  }

  classUnionMember1sCount(
    query?: Pick<$ObjectSet.Query<ClassUnionMember1.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.classUnionMember1sCount(query);
  }

  classUnionMember2(
    identifier: ClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember2>> {
    return this.$delegate.classUnionMember2(identifier);
  }

  classUnionMember2Identifiers(
    query?: $ObjectSet.Query<ClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2.$Identifier[]>> {
    return this.$delegate.classUnionMember2Identifiers(query);
  }

  classUnionMember2s(
    query?: $ObjectSet.Query<ClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2[]>> {
    return this.$delegate.classUnionMember2s(query);
  }

  classUnionMember2sCount(
    query?: Pick<$ObjectSet.Query<ClassUnionMember2.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.classUnionMember2sCount(query);
  }

  concreteChildClass(
    identifier: ConcreteChildClass.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildClass>> {
    return this.$delegate.concreteChildClass(identifier);
  }

  concreteChildClassIdentifiers(
    query?: $ObjectSet.Query<ConcreteChildClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass.$Identifier[]>> {
    return this.$delegate.concreteChildClassIdentifiers(query);
  }

  concreteChildClasses(
    query?: $ObjectSet.Query<ConcreteChildClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass[]>> {
    return this.$delegate.concreteChildClasses(query);
  }

  concreteChildClassesCount(
    query?: Pick<$ObjectSet.Query<ConcreteChildClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.concreteChildClassesCount(query);
  }

  concreteChildInterface(
    identifier: ConcreteChildInterface.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildInterface>> {
    return this.$delegate.concreteChildInterface(identifier);
  }

  concreteChildInterfaceIdentifiers(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteChildInterface.$Identifier[]>
  > {
    return this.$delegate.concreteChildInterfaceIdentifiers(query);
  }

  concreteChildInterfaces(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildInterface[]>> {
    return this.$delegate.concreteChildInterfaces(query);
  }

  concreteChildInterfacesCount(
    query?: Pick<$ObjectSet.Query<ConcreteChildInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.concreteChildInterfacesCount(query);
  }

  concreteParentClass(
    identifier: ConcreteParentClassStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentClass>> {
    return this.$delegate.concreteParentClass(identifier);
  }

  concreteParentClassIdentifiers(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentClassStatic.$Identifier[]>
  > {
    return this.$delegate.concreteParentClassIdentifiers(query);
  }

  concreteParentClasses(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteParentClass[]>> {
    return this.$delegate.concreteParentClasses(query);
  }

  concreteParentClassesCount(
    query?: Pick<
      $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.concreteParentClassesCount(query);
  }

  concreteParentInterface(
    identifier: ConcreteParentInterfaceStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentInterface>> {
    return this.$delegate.concreteParentInterface(identifier);
  }

  concreteParentInterfaceIdentifiers(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentInterfaceStatic.$Identifier[]>
  > {
    return this.$delegate.concreteParentInterfaceIdentifiers(query);
  }

  concreteParentInterfaces(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteParentInterface[]>> {
    return this.$delegate.concreteParentInterfaces(query);
  }

  concreteParentInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.concreteParentInterfacesCount(query);
  }

  convertibleTypePropertiesClass(
    identifier: ConvertibleTypePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ConvertibleTypePropertiesClass>> {
    return this.$delegate.convertibleTypePropertiesClass(identifier);
  }

  convertibleTypePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConvertibleTypePropertiesClass.$Identifier[]>
  > {
    return this.$delegate.convertibleTypePropertiesClassIdentifiers(query);
  }

  convertibleTypePropertiesClasses(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConvertibleTypePropertiesClass[]>> {
    return this.$delegate.convertibleTypePropertiesClasses(query);
  }

  convertibleTypePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.convertibleTypePropertiesClassesCount(query);
  }

  dateUnionPropertiesClass(
    identifier: DateUnionPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, DateUnionPropertiesClass>> {
    return this.$delegate.dateUnionPropertiesClass(identifier);
  }

  dateUnionPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<DateUnionPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly DateUnionPropertiesClass.$Identifier[]>
  > {
    return this.$delegate.dateUnionPropertiesClassIdentifiers(query);
  }

  dateUnionPropertiesClasses(
    query?: $ObjectSet.Query<DateUnionPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DateUnionPropertiesClass[]>> {
    return this.$delegate.dateUnionPropertiesClasses(query);
  }

  dateUnionPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<DateUnionPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.dateUnionPropertiesClassesCount(query);
  }

  defaultValuePropertiesClass(
    identifier: DefaultValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, DefaultValuePropertiesClass>> {
    return this.$delegate.defaultValuePropertiesClass(identifier);
  }

  defaultValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly DefaultValuePropertiesClass.$Identifier[]>
  > {
    return this.$delegate.defaultValuePropertiesClassIdentifiers(query);
  }

  defaultValuePropertiesClasses(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DefaultValuePropertiesClass[]>> {
    return this.$delegate.defaultValuePropertiesClasses(query);
  }

  defaultValuePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.defaultValuePropertiesClassesCount(query);
  }

  directRecursiveClass(
    identifier: DirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, DirectRecursiveClass>> {
    return this.$delegate.directRecursiveClass(identifier);
  }

  directRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly DirectRecursiveClass.$Identifier[]>
  > {
    return this.$delegate.directRecursiveClassIdentifiers(query);
  }

  directRecursiveClasses(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DirectRecursiveClass[]>> {
    return this.$delegate.directRecursiveClasses(query);
  }

  directRecursiveClassesCount(
    query?: Pick<$ObjectSet.Query<DirectRecursiveClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.directRecursiveClassesCount(query);
  }

  explicitFromToRdfTypesClass(
    identifier: ExplicitFromToRdfTypesClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitFromToRdfTypesClass>> {
    return this.$delegate.explicitFromToRdfTypesClass(identifier);
  }

  explicitFromToRdfTypesClassIdentifiers(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExplicitFromToRdfTypesClass.$Identifier[]>
  > {
    return this.$delegate.explicitFromToRdfTypesClassIdentifiers(query);
  }

  explicitFromToRdfTypesClasses(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExplicitFromToRdfTypesClass[]>> {
    return this.$delegate.explicitFromToRdfTypesClasses(query);
  }

  explicitFromToRdfTypesClassesCount(
    query?: Pick<
      $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.explicitFromToRdfTypesClassesCount(query);
  }

  explicitRdfTypeClass(
    identifier: ExplicitRdfTypeClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitRdfTypeClass>> {
    return this.$delegate.explicitRdfTypeClass(identifier);
  }

  explicitRdfTypeClassIdentifiers(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExplicitRdfTypeClass.$Identifier[]>
  > {
    return this.$delegate.explicitRdfTypeClassIdentifiers(query);
  }

  explicitRdfTypeClasses(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExplicitRdfTypeClass[]>> {
    return this.$delegate.explicitRdfTypeClasses(query);
  }

  explicitRdfTypeClassesCount(
    query?: Pick<$ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.explicitRdfTypeClassesCount(query);
  }

  externClassPropertyClass(
    identifier: ExternClassPropertyClass.$Identifier,
  ): Promise<purify.Either<Error, ExternClassPropertyClass>> {
    return this.$delegate.externClassPropertyClass(identifier);
  }

  externClassPropertyClassIdentifiers(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExternClassPropertyClass.$Identifier[]>
  > {
    return this.$delegate.externClassPropertyClassIdentifiers(query);
  }

  externClassPropertyClasses(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExternClassPropertyClass[]>> {
    return this.$delegate.externClassPropertyClasses(query);
  }

  externClassPropertyClassesCount(
    query?: Pick<
      $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.externClassPropertyClassesCount(query);
  }

  flattenClassUnionMember3(
    identifier: FlattenClassUnionMember3.$Identifier,
  ): Promise<purify.Either<Error, FlattenClassUnionMember3>> {
    return this.$delegate.flattenClassUnionMember3(identifier);
  }

  flattenClassUnionMember3Identifiers(
    query?: $ObjectSet.Query<FlattenClassUnionMember3.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly FlattenClassUnionMember3.$Identifier[]>
  > {
    return this.$delegate.flattenClassUnionMember3Identifiers(query);
  }

  flattenClassUnionMember3s(
    query?: $ObjectSet.Query<FlattenClassUnionMember3.$Identifier>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnionMember3[]>> {
    return this.$delegate.flattenClassUnionMember3s(query);
  }

  flattenClassUnionMember3sCount(
    query?: Pick<
      $ObjectSet.Query<FlattenClassUnionMember3.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.flattenClassUnionMember3sCount(query);
  }

  hasValuePropertiesClass(
    identifier: HasValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, HasValuePropertiesClass>> {
    return this.$delegate.hasValuePropertiesClass(identifier);
  }

  hasValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly HasValuePropertiesClass.$Identifier[]>
  > {
    return this.$delegate.hasValuePropertiesClassIdentifiers(query);
  }

  hasValuePropertiesClasses(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly HasValuePropertiesClass[]>> {
    return this.$delegate.hasValuePropertiesClasses(query);
  }

  hasValuePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.hasValuePropertiesClassesCount(query);
  }

  identifierOverride3Class(
    identifier: IdentifierOverride3ClassStatic.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride3Class>> {
    return this.$delegate.identifierOverride3Class(identifier);
  }

  identifierOverride3ClassIdentifiers(
    query?: $ObjectSet.Query<IdentifierOverride3ClassStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride3ClassStatic.$Identifier[]>
  > {
    return this.$delegate.identifierOverride3ClassIdentifiers(query);
  }

  identifierOverride3Classes(
    query?: $ObjectSet.Query<IdentifierOverride3ClassStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride3Class[]>> {
    return this.$delegate.identifierOverride3Classes(query);
  }

  identifierOverride3ClassesCount(
    query?: Pick<
      $ObjectSet.Query<IdentifierOverride3ClassStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.identifierOverride3ClassesCount(query);
  }

  identifierOverride4Class(
    identifier: IdentifierOverride4ClassStatic.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride4Class>> {
    return this.$delegate.identifierOverride4Class(identifier);
  }

  identifierOverride4ClassIdentifiers(
    query?: $ObjectSet.Query<IdentifierOverride4ClassStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride4ClassStatic.$Identifier[]>
  > {
    return this.$delegate.identifierOverride4ClassIdentifiers(query);
  }

  identifierOverride4Classes(
    query?: $ObjectSet.Query<IdentifierOverride4ClassStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride4Class[]>> {
    return this.$delegate.identifierOverride4Classes(query);
  }

  identifierOverride4ClassesCount(
    query?: Pick<
      $ObjectSet.Query<IdentifierOverride4ClassStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.identifierOverride4ClassesCount(query);
  }

  identifierOverride5Class(
    identifier: IdentifierOverride5Class.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride5Class>> {
    return this.$delegate.identifierOverride5Class(identifier);
  }

  identifierOverride5ClassIdentifiers(
    query?: $ObjectSet.Query<IdentifierOverride5Class.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride5Class.$Identifier[]>
  > {
    return this.$delegate.identifierOverride5ClassIdentifiers(query);
  }

  identifierOverride5Classes(
    query?: $ObjectSet.Query<IdentifierOverride5Class.$Identifier>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride5Class[]>> {
    return this.$delegate.identifierOverride5Classes(query);
  }

  identifierOverride5ClassesCount(
    query?: Pick<
      $ObjectSet.Query<IdentifierOverride5Class.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.identifierOverride5ClassesCount(query);
  }

  indirectRecursiveClass(
    identifier: IndirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveClass>> {
    return this.$delegate.indirectRecursiveClass(identifier);
  }

  indirectRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveClass.$Identifier[]>
  > {
    return this.$delegate.indirectRecursiveClassIdentifiers(query);
  }

  indirectRecursiveClasses(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveClass[]>> {
    return this.$delegate.indirectRecursiveClasses(query);
  }

  indirectRecursiveClassesCount(
    query?: Pick<$ObjectSet.Query<IndirectRecursiveClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.indirectRecursiveClassesCount(query);
  }

  indirectRecursiveHelperClass(
    identifier: IndirectRecursiveHelperClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveHelperClass>> {
    return this.$delegate.indirectRecursiveHelperClass(identifier);
  }

  indirectRecursiveHelperClassIdentifiers(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveHelperClass.$Identifier[]>
  > {
    return this.$delegate.indirectRecursiveHelperClassIdentifiers(query);
  }

  indirectRecursiveHelperClasses(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveHelperClass[]>> {
    return this.$delegate.indirectRecursiveHelperClasses(query);
  }

  indirectRecursiveHelperClassesCount(
    query?: Pick<
      $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.indirectRecursiveHelperClassesCount(query);
  }

  inIdentifierClass(
    identifier: InIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, InIdentifierClass>> {
    return this.$delegate.inIdentifierClass(identifier);
  }

  inIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<InIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass.$Identifier[]>> {
    return this.$delegate.inIdentifierClassIdentifiers(query);
  }

  inIdentifierClasses(
    query?: $ObjectSet.Query<InIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass[]>> {
    return this.$delegate.inIdentifierClasses(query);
  }

  inIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<InIdentifierClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.inIdentifierClassesCount(query);
  }

  inPropertiesClass(
    identifier: InPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, InPropertiesClass>> {
    return this.$delegate.inPropertiesClass(identifier);
  }

  inPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<InPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass.$Identifier[]>> {
    return this.$delegate.inPropertiesClassIdentifiers(query);
  }

  inPropertiesClasses(
    query?: $ObjectSet.Query<InPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass[]>> {
    return this.$delegate.inPropertiesClasses(query);
  }

  inPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<InPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.inPropertiesClassesCount(query);
  }

  interface(
    identifier: Interface.$Identifier,
  ): Promise<purify.Either<Error, Interface>> {
    return this.$delegate.interface(identifier);
  }

  interfaceIdentifiers(
    query?: $ObjectSet.Query<Interface.$Identifier>,
  ): Promise<purify.Either<Error, readonly Interface.$Identifier[]>> {
    return this.$delegate.interfaceIdentifiers(query);
  }

  interfaces(
    query?: $ObjectSet.Query<Interface.$Identifier>,
  ): Promise<purify.Either<Error, readonly Interface[]>> {
    return this.$delegate.interfaces(query);
  }

  interfacesCount(
    query?: Pick<$ObjectSet.Query<Interface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.interfacesCount(query);
  }

  interfaceUnionMember1(
    identifier: InterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember1>> {
    return this.$delegate.interfaceUnionMember1(identifier);
  }

  interfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember1.$Identifier[]>
  > {
    return this.$delegate.interfaceUnionMember1Identifiers(query);
  }

  interfaceUnionMember1s(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember1[]>> {
    return this.$delegate.interfaceUnionMember1s(query);
  }

  interfaceUnionMember1sCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember1.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.interfaceUnionMember1sCount(query);
  }

  interfaceUnionMember2(
    identifier: InterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember2>> {
    return this.$delegate.interfaceUnionMember2(identifier);
  }

  interfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember2.$Identifier[]>
  > {
    return this.$delegate.interfaceUnionMember2Identifiers(query);
  }

  interfaceUnionMember2s(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember2[]>> {
    return this.$delegate.interfaceUnionMember2s(query);
  }

  interfaceUnionMember2sCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember2.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.interfaceUnionMember2sCount(query);
  }

  iriIdentifierClass(
    identifier: IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, IriIdentifierClass>> {
    return this.$delegate.iriIdentifierClass(identifier);
  }

  iriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<IriIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IriIdentifierClass.$Identifier[]>> {
    return this.$delegate.iriIdentifierClassIdentifiers(query);
  }

  iriIdentifierClasses(
    query?: $ObjectSet.Query<IriIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IriIdentifierClass[]>> {
    return this.$delegate.iriIdentifierClasses(query);
  }

  iriIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<IriIdentifierClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.iriIdentifierClassesCount(query);
  }

  iriIdentifierInterface(
    identifier: IriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, IriIdentifierInterface>> {
    return this.$delegate.iriIdentifierInterface(identifier);
  }

  iriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<IriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IriIdentifierInterface.$Identifier[]>
  > {
    return this.$delegate.iriIdentifierInterfaceIdentifiers(query);
  }

  iriIdentifierInterfaces(
    query?: $ObjectSet.Query<IriIdentifierInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly IriIdentifierInterface[]>> {
    return this.$delegate.iriIdentifierInterfaces(query);
  }

  iriIdentifierInterfacesCount(
    query?: Pick<$ObjectSet.Query<IriIdentifierInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.iriIdentifierInterfacesCount(query);
  }

  jsPrimitiveUnionPropertyClass(
    identifier: JsPrimitiveUnionPropertyClass.$Identifier,
  ): Promise<purify.Either<Error, JsPrimitiveUnionPropertyClass>> {
    return this.$delegate.jsPrimitiveUnionPropertyClass(identifier);
  }

  jsPrimitiveUnionPropertyClassIdentifiers(
    query?: $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly JsPrimitiveUnionPropertyClass.$Identifier[]>
  > {
    return this.$delegate.jsPrimitiveUnionPropertyClassIdentifiers(query);
  }

  jsPrimitiveUnionPropertyClasses(
    query?: $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly JsPrimitiveUnionPropertyClass[]>> {
    return this.$delegate.jsPrimitiveUnionPropertyClasses(query);
  }

  jsPrimitiveUnionPropertyClassesCount(
    query?: Pick<
      $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.jsPrimitiveUnionPropertyClassesCount(query);
  }

  languageInPropertiesClass(
    identifier: LanguageInPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LanguageInPropertiesClass>> {
    return this.$delegate.languageInPropertiesClass(identifier);
  }

  languageInPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LanguageInPropertiesClass.$Identifier[]>
  > {
    return this.$delegate.languageInPropertiesClassIdentifiers(query);
  }

  languageInPropertiesClasses(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LanguageInPropertiesClass[]>> {
    return this.$delegate.languageInPropertiesClasses(query);
  }

  languageInPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.languageInPropertiesClassesCount(query);
  }

  lazilyResolvedBlankNodeOrIriIdentifierClass(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<
    purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierClass>
  > {
    return this.$delegate.lazilyResolvedBlankNodeOrIriIdentifierClass(
      identifier,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier[]
    >
  > {
    return this.$delegate.lazilyResolvedBlankNodeOrIriIdentifierClassIdentifiers(
      query,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierClasses(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedBlankNodeOrIriIdentifierClass[]>
  > {
    return this.$delegate.lazilyResolvedBlankNodeOrIriIdentifierClasses(query);
  }

  lazilyResolvedBlankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedBlankNodeOrIriIdentifierClassesCount(
      query,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierInterface(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<
    purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierInterface>
  > {
    return this.$delegate.lazilyResolvedBlankNodeOrIriIdentifierInterface(
      identifier,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier[]
    >
  > {
    return this.$delegate.lazilyResolvedBlankNodeOrIriIdentifierInterfaceIdentifiers(
      query,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierInterfaces(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[]
    >
  > {
    return this.$delegate.lazilyResolvedBlankNodeOrIriIdentifierInterfaces(
      query,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedBlankNodeOrIriIdentifierInterfacesCount(
      query,
    );
  }

  lazilyResolvedClassUnionMember1(
    identifier: LazilyResolvedClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember1>> {
    return this.$delegate.lazilyResolvedClassUnionMember1(identifier);
  }

  lazilyResolvedClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember1.$Identifier[]>
  > {
    return this.$delegate.lazilyResolvedClassUnionMember1Identifiers(query);
  }

  lazilyResolvedClassUnionMember1s(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember1[]>> {
    return this.$delegate.lazilyResolvedClassUnionMember1s(query);
  }

  lazilyResolvedClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedClassUnionMember1sCount(query);
  }

  lazilyResolvedClassUnionMember2(
    identifier: LazilyResolvedClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember2>> {
    return this.$delegate.lazilyResolvedClassUnionMember2(identifier);
  }

  lazilyResolvedClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember2.$Identifier[]>
  > {
    return this.$delegate.lazilyResolvedClassUnionMember2Identifiers(query);
  }

  lazilyResolvedClassUnionMember2s(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember2[]>> {
    return this.$delegate.lazilyResolvedClassUnionMember2s(query);
  }

  lazilyResolvedClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedClassUnionMember2sCount(query);
  }

  lazilyResolvedInterfaceUnionMember1(
    identifier: LazilyResolvedInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember1>> {
    return this.$delegate.lazilyResolvedInterfaceUnionMember1(identifier);
  }

  lazilyResolvedInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember1.$Identifier[]
    >
  > {
    return this.$delegate.lazilyResolvedInterfaceUnionMember1Identifiers(query);
  }

  lazilyResolvedInterfaceUnionMember1s(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember1[]>
  > {
    return this.$delegate.lazilyResolvedInterfaceUnionMember1s(query);
  }

  lazilyResolvedInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedInterfaceUnionMember1sCount(query);
  }

  lazilyResolvedInterfaceUnionMember2(
    identifier: LazilyResolvedInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember2>> {
    return this.$delegate.lazilyResolvedInterfaceUnionMember2(identifier);
  }

  lazilyResolvedInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember2.$Identifier[]
    >
  > {
    return this.$delegate.lazilyResolvedInterfaceUnionMember2Identifiers(query);
  }

  lazilyResolvedInterfaceUnionMember2s(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember2[]>
  > {
    return this.$delegate.lazilyResolvedInterfaceUnionMember2s(query);
  }

  lazilyResolvedInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedInterfaceUnionMember2sCount(query);
  }

  lazilyResolvedIriIdentifierClass(
    identifier: LazilyResolvedIriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriIdentifierClass>> {
    return this.$delegate.lazilyResolvedIriIdentifierClass(identifier);
  }

  lazilyResolvedIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedIriIdentifierClass.$Identifier[]
    >
  > {
    return this.$delegate.lazilyResolvedIriIdentifierClassIdentifiers(query);
  }

  lazilyResolvedIriIdentifierClasses(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriIdentifierClass[]>
  > {
    return this.$delegate.lazilyResolvedIriIdentifierClasses(query);
  }

  lazilyResolvedIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedIriIdentifierClassesCount(query);
  }

  lazilyResolvedIriIdentifierInterface(
    identifier: LazilyResolvedIriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriIdentifierInterface>> {
    return this.$delegate.lazilyResolvedIriIdentifierInterface(identifier);
  }

  lazilyResolvedIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedIriIdentifierInterface.$Identifier[]
    >
  > {
    return this.$delegate.lazilyResolvedIriIdentifierInterfaceIdentifiers(
      query,
    );
  }

  lazilyResolvedIriIdentifierInterfaces(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriIdentifierInterface[]>
  > {
    return this.$delegate.lazilyResolvedIriIdentifierInterfaces(query);
  }

  lazilyResolvedIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedIriIdentifierInterfacesCount(query);
  }

  lazyPropertiesClass(
    identifier: LazyPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesClass>> {
    return this.$delegate.lazyPropertiesClass(identifier);
  }

  lazyPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass.$Identifier[]>> {
    return this.$delegate.lazyPropertiesClassIdentifiers(query);
  }

  lazyPropertiesClasses(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass[]>> {
    return this.$delegate.lazyPropertiesClasses(query);
  }

  lazyPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<LazyPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazyPropertiesClassesCount(query);
  }

  lazyPropertiesInterface(
    identifier: LazyPropertiesInterface.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesInterface>> {
    return this.$delegate.lazyPropertiesInterface(identifier);
  }

  lazyPropertiesInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazyPropertiesInterface.$Identifier[]>
  > {
    return this.$delegate.lazyPropertiesInterfaceIdentifiers(query);
  }

  lazyPropertiesInterfaces(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesInterface[]>> {
    return this.$delegate.lazyPropertiesInterfaces(query);
  }

  lazyPropertiesInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazyPropertiesInterfacesCount(query);
  }

  listPropertiesClass(
    identifier: ListPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ListPropertiesClass>> {
    return this.$delegate.listPropertiesClass(identifier);
  }

  listPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<ListPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass.$Identifier[]>> {
    return this.$delegate.listPropertiesClassIdentifiers(query);
  }

  listPropertiesClasses(
    query?: $ObjectSet.Query<ListPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass[]>> {
    return this.$delegate.listPropertiesClasses(query);
  }

  listPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<ListPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.listPropertiesClassesCount(query);
  }

  mutablePropertiesClass(
    identifier: MutablePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, MutablePropertiesClass>> {
    return this.$delegate.mutablePropertiesClass(identifier);
  }

  mutablePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly MutablePropertiesClass.$Identifier[]>
  > {
    return this.$delegate.mutablePropertiesClassIdentifiers(query);
  }

  mutablePropertiesClasses(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly MutablePropertiesClass[]>> {
    return this.$delegate.mutablePropertiesClasses(query);
  }

  mutablePropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<MutablePropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.mutablePropertiesClassesCount(query);
  }

  nonClass(
    identifier: NonClass.$Identifier,
  ): Promise<purify.Either<Error, NonClass>> {
    return this.$delegate.nonClass(identifier);
  }

  nonClassIdentifiers(
    query?: $ObjectSet.Query<NonClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly NonClass.$Identifier[]>> {
    return this.$delegate.nonClassIdentifiers(query);
  }

  nonClasses(
    query?: $ObjectSet.Query<NonClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly NonClass[]>> {
    return this.$delegate.nonClasses(query);
  }

  nonClassesCount(
    query?: Pick<$ObjectSet.Query<NonClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.nonClassesCount(query);
  }

  noRdfTypeClassUnionMember1(
    identifier: NoRdfTypeClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnionMember1>> {
    return this.$delegate.noRdfTypeClassUnionMember1(identifier);
  }

  noRdfTypeClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly NoRdfTypeClassUnionMember1.$Identifier[]>
  > {
    return this.$delegate.noRdfTypeClassUnionMember1Identifiers(query);
  }

  noRdfTypeClassUnionMember1s(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnionMember1[]>> {
    return this.$delegate.noRdfTypeClassUnionMember1s(query);
  }

  noRdfTypeClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.noRdfTypeClassUnionMember1sCount(query);
  }

  noRdfTypeClassUnionMember2(
    identifier: NoRdfTypeClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnionMember2>> {
    return this.$delegate.noRdfTypeClassUnionMember2(identifier);
  }

  noRdfTypeClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly NoRdfTypeClassUnionMember2.$Identifier[]>
  > {
    return this.$delegate.noRdfTypeClassUnionMember2Identifiers(query);
  }

  noRdfTypeClassUnionMember2s(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnionMember2[]>> {
    return this.$delegate.noRdfTypeClassUnionMember2s(query);
  }

  noRdfTypeClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.noRdfTypeClassUnionMember2sCount(query);
  }

  orderedPropertiesClass(
    identifier: OrderedPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, OrderedPropertiesClass>> {
    return this.$delegate.orderedPropertiesClass(identifier);
  }

  orderedPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly OrderedPropertiesClass.$Identifier[]>
  > {
    return this.$delegate.orderedPropertiesClassIdentifiers(query);
  }

  orderedPropertiesClasses(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly OrderedPropertiesClass[]>> {
    return this.$delegate.orderedPropertiesClasses(query);
  }

  orderedPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<OrderedPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.orderedPropertiesClassesCount(query);
  }

  partialClass(
    identifier: PartialClass.$Identifier,
  ): Promise<purify.Either<Error, PartialClass>> {
    return this.$delegate.partialClass(identifier);
  }

  partialClassIdentifiers(
    query?: $ObjectSet.Query<PartialClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClass.$Identifier[]>> {
    return this.$delegate.partialClassIdentifiers(query);
  }

  partialClasses(
    query?: $ObjectSet.Query<PartialClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClass[]>> {
    return this.$delegate.partialClasses(query);
  }

  partialClassesCount(
    query?: Pick<$ObjectSet.Query<PartialClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialClassesCount(query);
  }

  partialClassUnionMember1(
    identifier: PartialClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember1>> {
    return this.$delegate.partialClassUnionMember1(identifier);
  }

  partialClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember1.$Identifier[]>
  > {
    return this.$delegate.partialClassUnionMember1Identifiers(query);
  }

  partialClassUnionMember1s(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember1[]>> {
    return this.$delegate.partialClassUnionMember1s(query);
  }

  partialClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialClassUnionMember1sCount(query);
  }

  partialClassUnionMember2(
    identifier: PartialClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember2>> {
    return this.$delegate.partialClassUnionMember2(identifier);
  }

  partialClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember2.$Identifier[]>
  > {
    return this.$delegate.partialClassUnionMember2Identifiers(query);
  }

  partialClassUnionMember2s(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember2[]>> {
    return this.$delegate.partialClassUnionMember2s(query);
  }

  partialClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialClassUnionMember2sCount(query);
  }

  partialInterface(
    identifier: PartialInterface.$Identifier,
  ): Promise<purify.Either<Error, PartialInterface>> {
    return this.$delegate.partialInterface(identifier);
  }

  partialInterfaceIdentifiers(
    query?: $ObjectSet.Query<PartialInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterface.$Identifier[]>> {
    return this.$delegate.partialInterfaceIdentifiers(query);
  }

  partialInterfaces(
    query?: $ObjectSet.Query<PartialInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterface[]>> {
    return this.$delegate.partialInterfaces(query);
  }

  partialInterfacesCount(
    query?: Pick<$ObjectSet.Query<PartialInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialInterfacesCount(query);
  }

  partialInterfaceUnionMember1(
    identifier: PartialInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember1>> {
    return this.$delegate.partialInterfaceUnionMember1(identifier);
  }

  partialInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember1.$Identifier[]>
  > {
    return this.$delegate.partialInterfaceUnionMember1Identifiers(query);
  }

  partialInterfaceUnionMember1s(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember1[]>> {
    return this.$delegate.partialInterfaceUnionMember1s(query);
  }

  partialInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialInterfaceUnionMember1sCount(query);
  }

  partialInterfaceUnionMember2(
    identifier: PartialInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember2>> {
    return this.$delegate.partialInterfaceUnionMember2(identifier);
  }

  partialInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember2.$Identifier[]>
  > {
    return this.$delegate.partialInterfaceUnionMember2Identifiers(query);
  }

  partialInterfaceUnionMember2s(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember2[]>> {
    return this.$delegate.partialInterfaceUnionMember2s(query);
  }

  partialInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialInterfaceUnionMember2sCount(query);
  }

  propertyCardinalitiesClass(
    identifier: PropertyCardinalitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyCardinalitiesClass>> {
    return this.$delegate.propertyCardinalitiesClass(identifier);
  }

  propertyCardinalitiesClassIdentifiers(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PropertyCardinalitiesClass.$Identifier[]>
  > {
    return this.$delegate.propertyCardinalitiesClassIdentifiers(query);
  }

  propertyCardinalitiesClasses(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PropertyCardinalitiesClass[]>> {
    return this.$delegate.propertyCardinalitiesClasses(query);
  }

  propertyCardinalitiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.propertyCardinalitiesClassesCount(query);
  }

  propertyVisibilitiesClass(
    identifier: PropertyVisibilitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyVisibilitiesClass>> {
    return this.$delegate.propertyVisibilitiesClass(identifier);
  }

  propertyVisibilitiesClassIdentifiers(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PropertyVisibilitiesClass.$Identifier[]>
  > {
    return this.$delegate.propertyVisibilitiesClassIdentifiers(query);
  }

  propertyVisibilitiesClasses(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PropertyVisibilitiesClass[]>> {
    return this.$delegate.propertyVisibilitiesClasses(query);
  }

  propertyVisibilitiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.propertyVisibilitiesClassesCount(query);
  }

  recursiveClassUnionMember1(
    identifier: RecursiveClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember1>> {
    return this.$delegate.recursiveClassUnionMember1(identifier);
  }

  recursiveClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember1.$Identifier[]>
  > {
    return this.$delegate.recursiveClassUnionMember1Identifiers(query);
  }

  recursiveClassUnionMember1s(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember1[]>> {
    return this.$delegate.recursiveClassUnionMember1s(query);
  }

  recursiveClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.recursiveClassUnionMember1sCount(query);
  }

  recursiveClassUnionMember2(
    identifier: RecursiveClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember2>> {
    return this.$delegate.recursiveClassUnionMember2(identifier);
  }

  recursiveClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember2.$Identifier[]>
  > {
    return this.$delegate.recursiveClassUnionMember2Identifiers(query);
  }

  recursiveClassUnionMember2s(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember2[]>> {
    return this.$delegate.recursiveClassUnionMember2s(query);
  }

  recursiveClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.recursiveClassUnionMember2sCount(query);
  }

  sha256IriIdentifierClass(
    identifier: Sha256IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, Sha256IriIdentifierClass>> {
    return this.$delegate.sha256IriIdentifierClass(identifier);
  }

  sha256IriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<Sha256IriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly Sha256IriIdentifierClass.$Identifier[]>
  > {
    return this.$delegate.sha256IriIdentifierClassIdentifiers(query);
  }

  sha256IriIdentifierClasses(
    query?: $ObjectSet.Query<Sha256IriIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly Sha256IriIdentifierClass[]>> {
    return this.$delegate.sha256IriIdentifierClasses(query);
  }

  sha256IriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<Sha256IriIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.sha256IriIdentifierClassesCount(query);
  }

  termPropertiesClass(
    identifier: TermPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, TermPropertiesClass>> {
    return this.$delegate.termPropertiesClass(identifier);
  }

  termPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<TermPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass.$Identifier[]>> {
    return this.$delegate.termPropertiesClassIdentifiers(query);
  }

  termPropertiesClasses(
    query?: $ObjectSet.Query<TermPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass[]>> {
    return this.$delegate.termPropertiesClasses(query);
  }

  termPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<TermPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.termPropertiesClassesCount(query);
  }

  unionDiscriminantsClass(
    identifier: UnionDiscriminantsClass.$Identifier,
  ): Promise<purify.Either<Error, UnionDiscriminantsClass>> {
    return this.$delegate.unionDiscriminantsClass(identifier);
  }

  unionDiscriminantsClassIdentifiers(
    query?: $ObjectSet.Query<UnionDiscriminantsClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly UnionDiscriminantsClass.$Identifier[]>
  > {
    return this.$delegate.unionDiscriminantsClassIdentifiers(query);
  }

  unionDiscriminantsClasses(
    query?: $ObjectSet.Query<UnionDiscriminantsClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly UnionDiscriminantsClass[]>> {
    return this.$delegate.unionDiscriminantsClasses(query);
  }

  unionDiscriminantsClassesCount(
    query?: Pick<
      $ObjectSet.Query<UnionDiscriminantsClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.unionDiscriminantsClassesCount(query);
  }

  uuidV4IriIdentifierClass(
    identifier: UuidV4IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriIdentifierClass>> {
    return this.$delegate.uuidV4IriIdentifierClass(identifier);
  }

  uuidV4IriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<UuidV4IriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly UuidV4IriIdentifierClass.$Identifier[]>
  > {
    return this.$delegate.uuidV4IriIdentifierClassIdentifiers(query);
  }

  uuidV4IriIdentifierClasses(
    query?: $ObjectSet.Query<UuidV4IriIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriIdentifierClass[]>> {
    return this.$delegate.uuidV4IriIdentifierClasses(query);
  }

  uuidV4IriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<UuidV4IriIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.uuidV4IriIdentifierClassesCount(query);
  }

  uuidV4IriIdentifierInterface(
    identifier: UuidV4IriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriIdentifierInterface>> {
    return this.$delegate.uuidV4IriIdentifierInterface(identifier);
  }

  uuidV4IriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<UuidV4IriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly UuidV4IriIdentifierInterface.$Identifier[]>
  > {
    return this.$delegate.uuidV4IriIdentifierInterfaceIdentifiers(query);
  }

  uuidV4IriIdentifierInterfaces(
    query?: $ObjectSet.Query<UuidV4IriIdentifierInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriIdentifierInterface[]>> {
    return this.$delegate.uuidV4IriIdentifierInterfaces(query);
  }

  uuidV4IriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<UuidV4IriIdentifierInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.uuidV4IriIdentifierInterfacesCount(query);
  }

  classUnion(
    identifier: ClassUnion.$Identifier,
  ): Promise<purify.Either<Error, ClassUnion>> {
    return this.$delegate.classUnion(identifier);
  }

  classUnionIdentifiers(
    query?: $ObjectSet.Query<ClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnion.$Identifier[]>> {
    return this.$delegate.classUnionIdentifiers(query);
  }

  classUnions(
    query?: $ObjectSet.Query<ClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnion[]>> {
    return this.$delegate.classUnions(query);
  }

  classUnionsCount(
    query?: Pick<$ObjectSet.Query<ClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.classUnionsCount(query);
  }

  flattenClassUnion(
    identifier: FlattenClassUnion.$Identifier,
  ): Promise<purify.Either<Error, FlattenClassUnion>> {
    return this.$delegate.flattenClassUnion(identifier);
  }

  flattenClassUnionIdentifiers(
    query?: $ObjectSet.Query<FlattenClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnion.$Identifier[]>> {
    return this.$delegate.flattenClassUnionIdentifiers(query);
  }

  flattenClassUnions(
    query?: $ObjectSet.Query<FlattenClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnion[]>> {
    return this.$delegate.flattenClassUnions(query);
  }

  flattenClassUnionsCount(
    query?: Pick<$ObjectSet.Query<FlattenClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.flattenClassUnionsCount(query);
  }

  interfaceUnion(
    identifier: InterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnion>> {
    return this.$delegate.interfaceUnion(identifier);
  }

  interfaceUnionIdentifiers(
    query?: $ObjectSet.Query<InterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion.$Identifier[]>> {
    return this.$delegate.interfaceUnionIdentifiers(query);
  }

  interfaceUnions(
    query?: $ObjectSet.Query<InterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion[]>> {
    return this.$delegate.interfaceUnions(query);
  }

  interfaceUnionsCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.interfaceUnionsCount(query);
  }

  lazilyResolvedClassUnion(
    identifier: LazilyResolvedClassUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnion>> {
    return this.$delegate.lazilyResolvedClassUnion(identifier);
  }

  lazilyResolvedClassUnionIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnion.$Identifier[]>
  > {
    return this.$delegate.lazilyResolvedClassUnionIdentifiers(query);
  }

  lazilyResolvedClassUnions(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnion[]>> {
    return this.$delegate.lazilyResolvedClassUnions(query);
  }

  lazilyResolvedClassUnionsCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedClassUnionsCount(query);
  }

  lazilyResolvedInterfaceUnion(
    identifier: LazilyResolvedInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnion>> {
    return this.$delegate.lazilyResolvedInterfaceUnion(identifier);
  }

  lazilyResolvedInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnion.$Identifier[]>
  > {
    return this.$delegate.lazilyResolvedInterfaceUnionIdentifiers(query);
  }

  lazilyResolvedInterfaceUnions(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedInterfaceUnion[]>> {
    return this.$delegate.lazilyResolvedInterfaceUnions(query);
  }

  lazilyResolvedInterfaceUnionsCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.lazilyResolvedInterfaceUnionsCount(query);
  }

  noRdfTypeClassUnion(
    identifier: NoRdfTypeClassUnion.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnion>> {
    return this.$delegate.noRdfTypeClassUnion(identifier);
  }

  noRdfTypeClassUnionIdentifiers(
    query?: $ObjectSet.Query<NoRdfTypeClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnion.$Identifier[]>> {
    return this.$delegate.noRdfTypeClassUnionIdentifiers(query);
  }

  noRdfTypeClassUnions(
    query?: $ObjectSet.Query<NoRdfTypeClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnion[]>> {
    return this.$delegate.noRdfTypeClassUnions(query);
  }

  noRdfTypeClassUnionsCount(
    query?: Pick<$ObjectSet.Query<NoRdfTypeClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.noRdfTypeClassUnionsCount(query);
  }

  partialClassUnion(
    identifier: PartialClassUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnion>> {
    return this.$delegate.partialClassUnion(identifier);
  }

  partialClassUnionIdentifiers(
    query?: $ObjectSet.Query<PartialClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion.$Identifier[]>> {
    return this.$delegate.partialClassUnionIdentifiers(query);
  }

  partialClassUnions(
    query?: $ObjectSet.Query<PartialClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion[]>> {
    return this.$delegate.partialClassUnions(query);
  }

  partialClassUnionsCount(
    query?: Pick<$ObjectSet.Query<PartialClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialClassUnionsCount(query);
  }

  partialInterfaceUnion(
    identifier: PartialInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnion>> {
    return this.$delegate.partialInterfaceUnion(identifier);
  }

  partialInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnion.$Identifier[]>
  > {
    return this.$delegate.partialInterfaceUnionIdentifiers(query);
  }

  partialInterfaceUnions(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnion[]>> {
    return this.$delegate.partialInterfaceUnions(query);
  }

  partialInterfaceUnionsCount(
    query?: Pick<$ObjectSet.Query<PartialInterfaceUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.partialInterfaceUnionsCount(query);
  }

  recursiveClassUnion(
    identifier: RecursiveClassUnion.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnion>> {
    return this.$delegate.recursiveClassUnion(identifier);
  }

  recursiveClassUnionIdentifiers(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion.$Identifier[]>> {
    return this.$delegate.recursiveClassUnionIdentifiers(query);
  }

  recursiveClassUnions(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion[]>> {
    return this.$delegate.recursiveClassUnions(query);
  }

  recursiveClassUnionsCount(
    query?: Pick<$ObjectSet.Query<RecursiveClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$delegate.recursiveClassUnionsCount(query);
  }
}

export class $RdfjsDatasetObjectSet implements $ObjectSet {
  readonly resourceSet: rdfjsResource.ResourceSet;

  constructor({ dataset }: { dataset: rdfjs.DatasetCore }) {
    this.resourceSet = new rdfjsResource.ResourceSet({ dataset });
  }

  async baseInterfaceWithoutProperties(
    identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithoutProperties>> {
    return this.baseInterfaceWithoutPropertiesSync(identifier);
  }

  baseInterfaceWithoutPropertiesSync(
    identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier,
  ): purify.Either<Error, BaseInterfaceWithoutProperties> {
    return this.baseInterfaceWithoutPropertiesesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async baseInterfaceWithoutPropertiesIdentifiers(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithoutPropertiesStatic.$Identifier[]
    >
  > {
    return this.baseInterfaceWithoutPropertiesIdentifiersSync(query);
  }

  baseInterfaceWithoutPropertiesIdentifiersSync(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
  ): purify.Either<
    Error,
    readonly BaseInterfaceWithoutPropertiesStatic.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      BaseInterfaceWithoutProperties,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >(
      [
        {
          $fromRdf: BaseInterfaceWithoutPropertiesStatic.$fromRdf,
          $fromRdfTypes: [
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async baseInterfaceWithoutPropertieses(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithoutProperties[]>> {
    return this.baseInterfaceWithoutPropertiesesSync(query);
  }

  baseInterfaceWithoutPropertiesesSync(
    query?: $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
  ): purify.Either<Error, readonly BaseInterfaceWithoutProperties[]> {
    return this.$objectsSync<
      BaseInterfaceWithoutProperties,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >(
      [
        {
          $fromRdf: BaseInterfaceWithoutPropertiesStatic.$fromRdf,
          $fromRdfTypes: [
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async baseInterfaceWithoutPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.baseInterfaceWithoutPropertiesesCountSync(query);
  }

  baseInterfaceWithoutPropertiesesCountSync(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      BaseInterfaceWithoutProperties,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >(
      [
        {
          $fromRdf: BaseInterfaceWithoutPropertiesStatic.$fromRdf,
          $fromRdfTypes: [
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async baseInterfaceWithProperties(
    identifier: BaseInterfaceWithPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithProperties>> {
    return this.baseInterfaceWithPropertiesSync(identifier);
  }

  baseInterfaceWithPropertiesSync(
    identifier: BaseInterfaceWithPropertiesStatic.$Identifier,
  ): purify.Either<Error, BaseInterfaceWithProperties> {
    return this.baseInterfaceWithPropertiesesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async baseInterfaceWithPropertiesIdentifiers(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithPropertiesStatic.$Identifier[]
    >
  > {
    return this.baseInterfaceWithPropertiesIdentifiersSync(query);
  }

  baseInterfaceWithPropertiesIdentifiersSync(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
  ): purify.Either<
    Error,
    readonly BaseInterfaceWithPropertiesStatic.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      BaseInterfaceWithProperties,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >(
      [
        {
          $fromRdf: BaseInterfaceWithPropertiesStatic.$fromRdf,
          $fromRdfTypes: [
            BaseInterfaceWithPropertiesStatic.$fromRdfType,
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async baseInterfaceWithPropertieses(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithProperties[]>> {
    return this.baseInterfaceWithPropertiesesSync(query);
  }

  baseInterfaceWithPropertiesesSync(
    query?: $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
  ): purify.Either<Error, readonly BaseInterfaceWithProperties[]> {
    return this.$objectsSync<
      BaseInterfaceWithProperties,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >(
      [
        {
          $fromRdf: BaseInterfaceWithPropertiesStatic.$fromRdf,
          $fromRdfTypes: [
            BaseInterfaceWithPropertiesStatic.$fromRdfType,
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async baseInterfaceWithPropertiesesCount(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.baseInterfaceWithPropertiesesCountSync(query);
  }

  baseInterfaceWithPropertiesesCountSync(
    query?: Pick<
      $ObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      BaseInterfaceWithProperties,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >(
      [
        {
          $fromRdf: BaseInterfaceWithPropertiesStatic.$fromRdf,
          $fromRdfTypes: [
            BaseInterfaceWithPropertiesStatic.$fromRdfType,
            BaseInterfaceWithoutPropertiesStatic.$fromRdfType,
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async blankNodeIdentifierClass(
    identifier: BlankNodeIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeIdentifierClass>> {
    return this.blankNodeIdentifierClassSync(identifier);
  }

  blankNodeIdentifierClassSync(
    identifier: BlankNodeIdentifierClass.$Identifier,
  ): purify.Either<Error, BlankNodeIdentifierClass> {
    return this.blankNodeIdentifierClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async blankNodeIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<BlankNodeIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeIdentifierClass.$Identifier[]>
  > {
    return this.blankNodeIdentifierClassIdentifiersSync(query);
  }

  blankNodeIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<BlankNodeIdentifierClass.$Identifier>,
  ): purify.Either<Error, readonly BlankNodeIdentifierClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      BlankNodeIdentifierClass,
      BlankNodeIdentifierClass.$Identifier
    >(
      [
        {
          $fromRdf: BlankNodeIdentifierClass.$fromRdf,
          $fromRdfTypes: [BlankNodeIdentifierClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async blankNodeIdentifierClasses(
    query?: $ObjectSet.Query<BlankNodeIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankNodeIdentifierClass[]>> {
    return this.blankNodeIdentifierClassesSync(query);
  }

  blankNodeIdentifierClassesSync(
    query?: $ObjectSet.Query<BlankNodeIdentifierClass.$Identifier>,
  ): purify.Either<Error, readonly BlankNodeIdentifierClass[]> {
    return this.$objectsSync<
      BlankNodeIdentifierClass,
      BlankNodeIdentifierClass.$Identifier
    >(
      [
        {
          $fromRdf: BlankNodeIdentifierClass.$fromRdf,
          $fromRdfTypes: [BlankNodeIdentifierClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async blankNodeIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<BlankNodeIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.blankNodeIdentifierClassesCountSync(query);
  }

  blankNodeIdentifierClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<BlankNodeIdentifierClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      BlankNodeIdentifierClass,
      BlankNodeIdentifierClass.$Identifier
    >(
      [
        {
          $fromRdf: BlankNodeIdentifierClass.$fromRdf,
          $fromRdfTypes: [BlankNodeIdentifierClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async blankNodeIdentifierInterface(
    identifier: BlankNodeIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeIdentifierInterface>> {
    return this.blankNodeIdentifierInterfaceSync(identifier);
  }

  blankNodeIdentifierInterfaceSync(
    identifier: BlankNodeIdentifierInterface.$Identifier,
  ): purify.Either<Error, BlankNodeIdentifierInterface> {
    return this.blankNodeIdentifierInterfacesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async blankNodeIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<BlankNodeIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeIdentifierInterface.$Identifier[]>
  > {
    return this.blankNodeIdentifierInterfaceIdentifiersSync(query);
  }

  blankNodeIdentifierInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<BlankNodeIdentifierInterface.$Identifier>,
  ): purify.Either<Error, readonly BlankNodeIdentifierInterface.$Identifier[]> {
    return this.$objectIdentifiersSync<
      BlankNodeIdentifierInterface,
      BlankNodeIdentifierInterface.$Identifier
    >(
      [{ $fromRdf: BlankNodeIdentifierInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async blankNodeIdentifierInterfaces(
    query?: $ObjectSet.Query<BlankNodeIdentifierInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankNodeIdentifierInterface[]>> {
    return this.blankNodeIdentifierInterfacesSync(query);
  }

  blankNodeIdentifierInterfacesSync(
    query?: $ObjectSet.Query<BlankNodeIdentifierInterface.$Identifier>,
  ): purify.Either<Error, readonly BlankNodeIdentifierInterface[]> {
    return this.$objectsSync<
      BlankNodeIdentifierInterface,
      BlankNodeIdentifierInterface.$Identifier
    >(
      [{ $fromRdf: BlankNodeIdentifierInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async blankNodeIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<BlankNodeIdentifierInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.blankNodeIdentifierInterfacesCountSync(query);
  }

  blankNodeIdentifierInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<BlankNodeIdentifierInterface.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      BlankNodeIdentifierInterface,
      BlankNodeIdentifierInterface.$Identifier
    >(
      [{ $fromRdf: BlankNodeIdentifierInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async blankNodeOrIriIdentifierClass(
    identifier: BlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeOrIriIdentifierClass>> {
    return this.blankNodeOrIriIdentifierClassSync(identifier);
  }

  blankNodeOrIriIdentifierClassSync(
    identifier: BlankNodeOrIriIdentifierClass.$Identifier,
  ): purify.Either<Error, BlankNodeOrIriIdentifierClass> {
    return this.blankNodeOrIriIdentifierClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async blankNodeOrIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeOrIriIdentifierClass.$Identifier[]>
  > {
    return this.blankNodeOrIriIdentifierClassIdentifiersSync(query);
  }

  blankNodeOrIriIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Identifier>,
  ): purify.Either<
    Error,
    readonly BlankNodeOrIriIdentifierClass.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      BlankNodeOrIriIdentifierClass,
      BlankNodeOrIriIdentifierClass.$Identifier
    >(
      [
        {
          $fromRdf: BlankNodeOrIriIdentifierClass.$fromRdf,
          $fromRdfTypes: [BlankNodeOrIriIdentifierClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async blankNodeOrIriIdentifierClasses(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankNodeOrIriIdentifierClass[]>> {
    return this.blankNodeOrIriIdentifierClassesSync(query);
  }

  blankNodeOrIriIdentifierClassesSync(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Identifier>,
  ): purify.Either<Error, readonly BlankNodeOrIriIdentifierClass[]> {
    return this.$objectsSync<
      BlankNodeOrIriIdentifierClass,
      BlankNodeOrIriIdentifierClass.$Identifier
    >(
      [
        {
          $fromRdf: BlankNodeOrIriIdentifierClass.$fromRdf,
          $fromRdfTypes: [BlankNodeOrIriIdentifierClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async blankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.blankNodeOrIriIdentifierClassesCountSync(query);
  }

  blankNodeOrIriIdentifierClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<BlankNodeOrIriIdentifierClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      BlankNodeOrIriIdentifierClass,
      BlankNodeOrIriIdentifierClass.$Identifier
    >(
      [
        {
          $fromRdf: BlankNodeOrIriIdentifierClass.$fromRdf,
          $fromRdfTypes: [BlankNodeOrIriIdentifierClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async blankNodeOrIriIdentifierInterface(
    identifier: BlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeOrIriIdentifierInterface>> {
    return this.blankNodeOrIriIdentifierInterfaceSync(identifier);
  }

  blankNodeOrIriIdentifierInterfaceSync(
    identifier: BlankNodeOrIriIdentifierInterface.$Identifier,
  ): purify.Either<Error, BlankNodeOrIriIdentifierInterface> {
    return this.blankNodeOrIriIdentifierInterfacesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async blankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly BlankNodeOrIriIdentifierInterface.$Identifier[]
    >
  > {
    return this.blankNodeOrIriIdentifierInterfaceIdentifiersSync(query);
  }

  blankNodeOrIriIdentifierInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Identifier>,
  ): purify.Either<
    Error,
    readonly BlankNodeOrIriIdentifierInterface.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      BlankNodeOrIriIdentifierInterface,
      BlankNodeOrIriIdentifierInterface.$Identifier
    >(
      [
        {
          $fromRdf: BlankNodeOrIriIdentifierInterface.$fromRdf,
          $fromRdfTypes: [],
        },
      ],
      query,
    );
  }

  async blankNodeOrIriIdentifierInterfaces(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeOrIriIdentifierInterface[]>
  > {
    return this.blankNodeOrIriIdentifierInterfacesSync(query);
  }

  blankNodeOrIriIdentifierInterfacesSync(
    query?: $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Identifier>,
  ): purify.Either<Error, readonly BlankNodeOrIriIdentifierInterface[]> {
    return this.$objectsSync<
      BlankNodeOrIriIdentifierInterface,
      BlankNodeOrIriIdentifierInterface.$Identifier
    >(
      [
        {
          $fromRdf: BlankNodeOrIriIdentifierInterface.$fromRdf,
          $fromRdfTypes: [],
        },
      ],
      query,
    );
  }

  async blankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.blankNodeOrIriIdentifierInterfacesCountSync(query);
  }

  blankNodeOrIriIdentifierInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      BlankNodeOrIriIdentifierInterface,
      BlankNodeOrIriIdentifierInterface.$Identifier
    >(
      [
        {
          $fromRdf: BlankNodeOrIriIdentifierInterface.$fromRdf,
          $fromRdfTypes: [],
        },
      ],
      query,
    );
  }

  async classUnionMember1(
    identifier: ClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember1>> {
    return this.classUnionMember1Sync(identifier);
  }

  classUnionMember1Sync(
    identifier: ClassUnionMember1.$Identifier,
  ): purify.Either<Error, ClassUnionMember1> {
    return this.classUnionMember1sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async classUnionMember1Identifiers(
    query?: $ObjectSet.Query<ClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1.$Identifier[]>> {
    return this.classUnionMember1IdentifiersSync(query);
  }

  classUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<ClassUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly ClassUnionMember1.$Identifier[]> {
    return this.$objectIdentifiersSync<
      ClassUnionMember1,
      ClassUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: ClassUnionMember1.$fromRdf,
          $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async classUnionMember1s(
    query?: $ObjectSet.Query<ClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1[]>> {
    return this.classUnionMember1sSync(query);
  }

  classUnionMember1sSync(
    query?: $ObjectSet.Query<ClassUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly ClassUnionMember1[]> {
    return this.$objectsSync<ClassUnionMember1, ClassUnionMember1.$Identifier>(
      [
        {
          $fromRdf: ClassUnionMember1.$fromRdf,
          $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async classUnionMember1sCount(
    query?: Pick<$ObjectSet.Query<ClassUnionMember1.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.classUnionMember1sCountSync(query);
  }

  classUnionMember1sCountSync(
    query?: Pick<$ObjectSet.Query<ClassUnionMember1.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ClassUnionMember1,
      ClassUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: ClassUnionMember1.$fromRdf,
          $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async classUnionMember2(
    identifier: ClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember2>> {
    return this.classUnionMember2Sync(identifier);
  }

  classUnionMember2Sync(
    identifier: ClassUnionMember2.$Identifier,
  ): purify.Either<Error, ClassUnionMember2> {
    return this.classUnionMember2sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async classUnionMember2Identifiers(
    query?: $ObjectSet.Query<ClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2.$Identifier[]>> {
    return this.classUnionMember2IdentifiersSync(query);
  }

  classUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<ClassUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly ClassUnionMember2.$Identifier[]> {
    return this.$objectIdentifiersSync<
      ClassUnionMember2,
      ClassUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: ClassUnionMember2.$fromRdf,
          $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async classUnionMember2s(
    query?: $ObjectSet.Query<ClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2[]>> {
    return this.classUnionMember2sSync(query);
  }

  classUnionMember2sSync(
    query?: $ObjectSet.Query<ClassUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly ClassUnionMember2[]> {
    return this.$objectsSync<ClassUnionMember2, ClassUnionMember2.$Identifier>(
      [
        {
          $fromRdf: ClassUnionMember2.$fromRdf,
          $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async classUnionMember2sCount(
    query?: Pick<$ObjectSet.Query<ClassUnionMember2.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.classUnionMember2sCountSync(query);
  }

  classUnionMember2sCountSync(
    query?: Pick<$ObjectSet.Query<ClassUnionMember2.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ClassUnionMember2,
      ClassUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: ClassUnionMember2.$fromRdf,
          $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async concreteChildClass(
    identifier: ConcreteChildClass.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildClass>> {
    return this.concreteChildClassSync(identifier);
  }

  concreteChildClassSync(
    identifier: ConcreteChildClass.$Identifier,
  ): purify.Either<Error, ConcreteChildClass> {
    return this.concreteChildClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async concreteChildClassIdentifiers(
    query?: $ObjectSet.Query<ConcreteChildClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass.$Identifier[]>> {
    return this.concreteChildClassIdentifiersSync(query);
  }

  concreteChildClassIdentifiersSync(
    query?: $ObjectSet.Query<ConcreteChildClass.$Identifier>,
  ): purify.Either<Error, readonly ConcreteChildClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      ConcreteChildClass,
      ConcreteChildClass.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteChildClass.$fromRdf,
          $fromRdfTypes: [ConcreteChildClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async concreteChildClasses(
    query?: $ObjectSet.Query<ConcreteChildClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass[]>> {
    return this.concreteChildClassesSync(query);
  }

  concreteChildClassesSync(
    query?: $ObjectSet.Query<ConcreteChildClass.$Identifier>,
  ): purify.Either<Error, readonly ConcreteChildClass[]> {
    return this.$objectsSync<
      ConcreteChildClass,
      ConcreteChildClass.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteChildClass.$fromRdf,
          $fromRdfTypes: [ConcreteChildClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async concreteChildClassesCount(
    query?: Pick<$ObjectSet.Query<ConcreteChildClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.concreteChildClassesCountSync(query);
  }

  concreteChildClassesCountSync(
    query?: Pick<$ObjectSet.Query<ConcreteChildClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ConcreteChildClass,
      ConcreteChildClass.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteChildClass.$fromRdf,
          $fromRdfTypes: [ConcreteChildClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async concreteChildInterface(
    identifier: ConcreteChildInterface.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildInterface>> {
    return this.concreteChildInterfaceSync(identifier);
  }

  concreteChildInterfaceSync(
    identifier: ConcreteChildInterface.$Identifier,
  ): purify.Either<Error, ConcreteChildInterface> {
    return this.concreteChildInterfacesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async concreteChildInterfaceIdentifiers(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteChildInterface.$Identifier[]>
  > {
    return this.concreteChildInterfaceIdentifiersSync(query);
  }

  concreteChildInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Identifier>,
  ): purify.Either<Error, readonly ConcreteChildInterface.$Identifier[]> {
    return this.$objectIdentifiersSync<
      ConcreteChildInterface,
      ConcreteChildInterface.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteChildInterface.$fromRdf,
          $fromRdfTypes: [ConcreteChildInterface.$fromRdfType],
        },
      ],
      query,
    );
  }

  async concreteChildInterfaces(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildInterface[]>> {
    return this.concreteChildInterfacesSync(query);
  }

  concreteChildInterfacesSync(
    query?: $ObjectSet.Query<ConcreteChildInterface.$Identifier>,
  ): purify.Either<Error, readonly ConcreteChildInterface[]> {
    return this.$objectsSync<
      ConcreteChildInterface,
      ConcreteChildInterface.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteChildInterface.$fromRdf,
          $fromRdfTypes: [ConcreteChildInterface.$fromRdfType],
        },
      ],
      query,
    );
  }

  async concreteChildInterfacesCount(
    query?: Pick<$ObjectSet.Query<ConcreteChildInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.concreteChildInterfacesCountSync(query);
  }

  concreteChildInterfacesCountSync(
    query?: Pick<$ObjectSet.Query<ConcreteChildInterface.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ConcreteChildInterface,
      ConcreteChildInterface.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteChildInterface.$fromRdf,
          $fromRdfTypes: [ConcreteChildInterface.$fromRdfType],
        },
      ],
      query,
    );
  }

  async concreteParentClass(
    identifier: ConcreteParentClassStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentClass>> {
    return this.concreteParentClassSync(identifier);
  }

  concreteParentClassSync(
    identifier: ConcreteParentClassStatic.$Identifier,
  ): purify.Either<Error, ConcreteParentClass> {
    return this.concreteParentClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async concreteParentClassIdentifiers(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentClassStatic.$Identifier[]>
  > {
    return this.concreteParentClassIdentifiersSync(query);
  }

  concreteParentClassIdentifiersSync(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
  ): purify.Either<Error, readonly ConcreteParentClassStatic.$Identifier[]> {
    return this.$objectIdentifiersSync<
      ConcreteParentClass,
      ConcreteParentClassStatic.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteParentClassStatic.$fromRdf,
          $fromRdfTypes: [
            ConcreteParentClassStatic.$fromRdfType,
            ConcreteChildClass.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async concreteParentClasses(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteParentClass[]>> {
    return this.concreteParentClassesSync(query);
  }

  concreteParentClassesSync(
    query?: $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
  ): purify.Either<Error, readonly ConcreteParentClass[]> {
    return this.$objectsSync<
      ConcreteParentClass,
      ConcreteParentClassStatic.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteParentClassStatic.$fromRdf,
          $fromRdfTypes: [
            ConcreteParentClassStatic.$fromRdfType,
            ConcreteChildClass.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async concreteParentClassesCount(
    query?: Pick<
      $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.concreteParentClassesCountSync(query);
  }

  concreteParentClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ConcreteParentClass,
      ConcreteParentClassStatic.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteParentClassStatic.$fromRdf,
          $fromRdfTypes: [
            ConcreteParentClassStatic.$fromRdfType,
            ConcreteChildClass.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async concreteParentInterface(
    identifier: ConcreteParentInterfaceStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentInterface>> {
    return this.concreteParentInterfaceSync(identifier);
  }

  concreteParentInterfaceSync(
    identifier: ConcreteParentInterfaceStatic.$Identifier,
  ): purify.Either<Error, ConcreteParentInterface> {
    return this.concreteParentInterfacesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async concreteParentInterfaceIdentifiers(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentInterfaceStatic.$Identifier[]>
  > {
    return this.concreteParentInterfaceIdentifiersSync(query);
  }

  concreteParentInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
  ): purify.Either<
    Error,
    readonly ConcreteParentInterfaceStatic.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      ConcreteParentInterface,
      ConcreteParentInterfaceStatic.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteParentInterfaceStatic.$fromRdf,
          $fromRdfTypes: [
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async concreteParentInterfaces(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteParentInterface[]>> {
    return this.concreteParentInterfacesSync(query);
  }

  concreteParentInterfacesSync(
    query?: $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
  ): purify.Either<Error, readonly ConcreteParentInterface[]> {
    return this.$objectsSync<
      ConcreteParentInterface,
      ConcreteParentInterfaceStatic.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteParentInterfaceStatic.$fromRdf,
          $fromRdfTypes: [
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async concreteParentInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.concreteParentInterfacesCountSync(query);
  }

  concreteParentInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ConcreteParentInterface,
      ConcreteParentInterfaceStatic.$Identifier
    >(
      [
        {
          $fromRdf: ConcreteParentInterfaceStatic.$fromRdf,
          $fromRdfTypes: [
            ConcreteParentInterfaceStatic.$fromRdfType,
            ConcreteChildInterface.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async convertibleTypePropertiesClass(
    identifier: ConvertibleTypePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ConvertibleTypePropertiesClass>> {
    return this.convertibleTypePropertiesClassSync(identifier);
  }

  convertibleTypePropertiesClassSync(
    identifier: ConvertibleTypePropertiesClass.$Identifier,
  ): purify.Either<Error, ConvertibleTypePropertiesClass> {
    return this.convertibleTypePropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async convertibleTypePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConvertibleTypePropertiesClass.$Identifier[]>
  > {
    return this.convertibleTypePropertiesClassIdentifiersSync(query);
  }

  convertibleTypePropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
  ): purify.Either<
    Error,
    readonly ConvertibleTypePropertiesClass.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      ConvertibleTypePropertiesClass,
      ConvertibleTypePropertiesClass.$Identifier
    >(
      [
        {
          $fromRdf: ConvertibleTypePropertiesClass.$fromRdf,
          $fromRdfTypes: [ConvertibleTypePropertiesClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async convertibleTypePropertiesClasses(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConvertibleTypePropertiesClass[]>> {
    return this.convertibleTypePropertiesClassesSync(query);
  }

  convertibleTypePropertiesClassesSync(
    query?: $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly ConvertibleTypePropertiesClass[]> {
    return this.$objectsSync<
      ConvertibleTypePropertiesClass,
      ConvertibleTypePropertiesClass.$Identifier
    >(
      [
        {
          $fromRdf: ConvertibleTypePropertiesClass.$fromRdf,
          $fromRdfTypes: [ConvertibleTypePropertiesClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async convertibleTypePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.convertibleTypePropertiesClassesCountSync(query);
  }

  convertibleTypePropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ConvertibleTypePropertiesClass,
      ConvertibleTypePropertiesClass.$Identifier
    >(
      [
        {
          $fromRdf: ConvertibleTypePropertiesClass.$fromRdf,
          $fromRdfTypes: [ConvertibleTypePropertiesClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async dateUnionPropertiesClass(
    identifier: DateUnionPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, DateUnionPropertiesClass>> {
    return this.dateUnionPropertiesClassSync(identifier);
  }

  dateUnionPropertiesClassSync(
    identifier: DateUnionPropertiesClass.$Identifier,
  ): purify.Either<Error, DateUnionPropertiesClass> {
    return this.dateUnionPropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async dateUnionPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<DateUnionPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly DateUnionPropertiesClass.$Identifier[]>
  > {
    return this.dateUnionPropertiesClassIdentifiersSync(query);
  }

  dateUnionPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<DateUnionPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly DateUnionPropertiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      DateUnionPropertiesClass,
      DateUnionPropertiesClass.$Identifier
    >(
      [{ $fromRdf: DateUnionPropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async dateUnionPropertiesClasses(
    query?: $ObjectSet.Query<DateUnionPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DateUnionPropertiesClass[]>> {
    return this.dateUnionPropertiesClassesSync(query);
  }

  dateUnionPropertiesClassesSync(
    query?: $ObjectSet.Query<DateUnionPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly DateUnionPropertiesClass[]> {
    return this.$objectsSync<
      DateUnionPropertiesClass,
      DateUnionPropertiesClass.$Identifier
    >(
      [{ $fromRdf: DateUnionPropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async dateUnionPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<DateUnionPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.dateUnionPropertiesClassesCountSync(query);
  }

  dateUnionPropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<DateUnionPropertiesClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      DateUnionPropertiesClass,
      DateUnionPropertiesClass.$Identifier
    >(
      [{ $fromRdf: DateUnionPropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async defaultValuePropertiesClass(
    identifier: DefaultValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, DefaultValuePropertiesClass>> {
    return this.defaultValuePropertiesClassSync(identifier);
  }

  defaultValuePropertiesClassSync(
    identifier: DefaultValuePropertiesClass.$Identifier,
  ): purify.Either<Error, DefaultValuePropertiesClass> {
    return this.defaultValuePropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async defaultValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly DefaultValuePropertiesClass.$Identifier[]>
  > {
    return this.defaultValuePropertiesClassIdentifiersSync(query);
  }

  defaultValuePropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly DefaultValuePropertiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      DefaultValuePropertiesClass,
      DefaultValuePropertiesClass.$Identifier
    >(
      [{ $fromRdf: DefaultValuePropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async defaultValuePropertiesClasses(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DefaultValuePropertiesClass[]>> {
    return this.defaultValuePropertiesClassesSync(query);
  }

  defaultValuePropertiesClassesSync(
    query?: $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly DefaultValuePropertiesClass[]> {
    return this.$objectsSync<
      DefaultValuePropertiesClass,
      DefaultValuePropertiesClass.$Identifier
    >(
      [{ $fromRdf: DefaultValuePropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async defaultValuePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.defaultValuePropertiesClassesCountSync(query);
  }

  defaultValuePropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      DefaultValuePropertiesClass,
      DefaultValuePropertiesClass.$Identifier
    >(
      [{ $fromRdf: DefaultValuePropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async directRecursiveClass(
    identifier: DirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, DirectRecursiveClass>> {
    return this.directRecursiveClassSync(identifier);
  }

  directRecursiveClassSync(
    identifier: DirectRecursiveClass.$Identifier,
  ): purify.Either<Error, DirectRecursiveClass> {
    return this.directRecursiveClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async directRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly DirectRecursiveClass.$Identifier[]>
  > {
    return this.directRecursiveClassIdentifiersSync(query);
  }

  directRecursiveClassIdentifiersSync(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Identifier>,
  ): purify.Either<Error, readonly DirectRecursiveClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      DirectRecursiveClass,
      DirectRecursiveClass.$Identifier
    >([{ $fromRdf: DirectRecursiveClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async directRecursiveClasses(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DirectRecursiveClass[]>> {
    return this.directRecursiveClassesSync(query);
  }

  directRecursiveClassesSync(
    query?: $ObjectSet.Query<DirectRecursiveClass.$Identifier>,
  ): purify.Either<Error, readonly DirectRecursiveClass[]> {
    return this.$objectsSync<
      DirectRecursiveClass,
      DirectRecursiveClass.$Identifier
    >([{ $fromRdf: DirectRecursiveClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async directRecursiveClassesCount(
    query?: Pick<$ObjectSet.Query<DirectRecursiveClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.directRecursiveClassesCountSync(query);
  }

  directRecursiveClassesCountSync(
    query?: Pick<$ObjectSet.Query<DirectRecursiveClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      DirectRecursiveClass,
      DirectRecursiveClass.$Identifier
    >([{ $fromRdf: DirectRecursiveClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async explicitFromToRdfTypesClass(
    identifier: ExplicitFromToRdfTypesClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitFromToRdfTypesClass>> {
    return this.explicitFromToRdfTypesClassSync(identifier);
  }

  explicitFromToRdfTypesClassSync(
    identifier: ExplicitFromToRdfTypesClass.$Identifier,
  ): purify.Either<Error, ExplicitFromToRdfTypesClass> {
    return this.explicitFromToRdfTypesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async explicitFromToRdfTypesClassIdentifiers(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExplicitFromToRdfTypesClass.$Identifier[]>
  > {
    return this.explicitFromToRdfTypesClassIdentifiersSync(query);
  }

  explicitFromToRdfTypesClassIdentifiersSync(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
  ): purify.Either<Error, readonly ExplicitFromToRdfTypesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      ExplicitFromToRdfTypesClass,
      ExplicitFromToRdfTypesClass.$Identifier
    >(
      [
        {
          $fromRdf: ExplicitFromToRdfTypesClass.$fromRdf,
          $fromRdfTypes: [ExplicitFromToRdfTypesClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async explicitFromToRdfTypesClasses(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExplicitFromToRdfTypesClass[]>> {
    return this.explicitFromToRdfTypesClassesSync(query);
  }

  explicitFromToRdfTypesClassesSync(
    query?: $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
  ): purify.Either<Error, readonly ExplicitFromToRdfTypesClass[]> {
    return this.$objectsSync<
      ExplicitFromToRdfTypesClass,
      ExplicitFromToRdfTypesClass.$Identifier
    >(
      [
        {
          $fromRdf: ExplicitFromToRdfTypesClass.$fromRdf,
          $fromRdfTypes: [ExplicitFromToRdfTypesClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async explicitFromToRdfTypesClassesCount(
    query?: Pick<
      $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.explicitFromToRdfTypesClassesCountSync(query);
  }

  explicitFromToRdfTypesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ExplicitFromToRdfTypesClass,
      ExplicitFromToRdfTypesClass.$Identifier
    >(
      [
        {
          $fromRdf: ExplicitFromToRdfTypesClass.$fromRdf,
          $fromRdfTypes: [ExplicitFromToRdfTypesClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async explicitRdfTypeClass(
    identifier: ExplicitRdfTypeClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitRdfTypeClass>> {
    return this.explicitRdfTypeClassSync(identifier);
  }

  explicitRdfTypeClassSync(
    identifier: ExplicitRdfTypeClass.$Identifier,
  ): purify.Either<Error, ExplicitRdfTypeClass> {
    return this.explicitRdfTypeClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async explicitRdfTypeClassIdentifiers(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExplicitRdfTypeClass.$Identifier[]>
  > {
    return this.explicitRdfTypeClassIdentifiersSync(query);
  }

  explicitRdfTypeClassIdentifiersSync(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
  ): purify.Either<Error, readonly ExplicitRdfTypeClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      ExplicitRdfTypeClass,
      ExplicitRdfTypeClass.$Identifier
    >(
      [
        {
          $fromRdf: ExplicitRdfTypeClass.$fromRdf,
          $fromRdfTypes: [ExplicitRdfTypeClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async explicitRdfTypeClasses(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExplicitRdfTypeClass[]>> {
    return this.explicitRdfTypeClassesSync(query);
  }

  explicitRdfTypeClassesSync(
    query?: $ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
  ): purify.Either<Error, readonly ExplicitRdfTypeClass[]> {
    return this.$objectsSync<
      ExplicitRdfTypeClass,
      ExplicitRdfTypeClass.$Identifier
    >(
      [
        {
          $fromRdf: ExplicitRdfTypeClass.$fromRdf,
          $fromRdfTypes: [ExplicitRdfTypeClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async explicitRdfTypeClassesCount(
    query?: Pick<$ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.explicitRdfTypeClassesCountSync(query);
  }

  explicitRdfTypeClassesCountSync(
    query?: Pick<$ObjectSet.Query<ExplicitRdfTypeClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ExplicitRdfTypeClass,
      ExplicitRdfTypeClass.$Identifier
    >(
      [
        {
          $fromRdf: ExplicitRdfTypeClass.$fromRdf,
          $fromRdfTypes: [ExplicitRdfTypeClass.$fromRdfType],
        },
      ],
      query,
    );
  }

  async externClassPropertyClass(
    identifier: ExternClassPropertyClass.$Identifier,
  ): Promise<purify.Either<Error, ExternClassPropertyClass>> {
    return this.externClassPropertyClassSync(identifier);
  }

  externClassPropertyClassSync(
    identifier: ExternClassPropertyClass.$Identifier,
  ): purify.Either<Error, ExternClassPropertyClass> {
    return this.externClassPropertyClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async externClassPropertyClassIdentifiers(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExternClassPropertyClass.$Identifier[]>
  > {
    return this.externClassPropertyClassIdentifiersSync(query);
  }

  externClassPropertyClassIdentifiersSync(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
  ): purify.Either<Error, readonly ExternClassPropertyClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      ExternClassPropertyClass,
      ExternClassPropertyClass.$Identifier
    >(
      [{ $fromRdf: ExternClassPropertyClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async externClassPropertyClasses(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExternClassPropertyClass[]>> {
    return this.externClassPropertyClassesSync(query);
  }

  externClassPropertyClassesSync(
    query?: $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
  ): purify.Either<Error, readonly ExternClassPropertyClass[]> {
    return this.$objectsSync<
      ExternClassPropertyClass,
      ExternClassPropertyClass.$Identifier
    >(
      [{ $fromRdf: ExternClassPropertyClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async externClassPropertyClassesCount(
    query?: Pick<
      $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.externClassPropertyClassesCountSync(query);
  }

  externClassPropertyClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<ExternClassPropertyClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ExternClassPropertyClass,
      ExternClassPropertyClass.$Identifier
    >(
      [{ $fromRdf: ExternClassPropertyClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async flattenClassUnionMember3(
    identifier: FlattenClassUnionMember3.$Identifier,
  ): Promise<purify.Either<Error, FlattenClassUnionMember3>> {
    return this.flattenClassUnionMember3Sync(identifier);
  }

  flattenClassUnionMember3Sync(
    identifier: FlattenClassUnionMember3.$Identifier,
  ): purify.Either<Error, FlattenClassUnionMember3> {
    return this.flattenClassUnionMember3sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async flattenClassUnionMember3Identifiers(
    query?: $ObjectSet.Query<FlattenClassUnionMember3.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly FlattenClassUnionMember3.$Identifier[]>
  > {
    return this.flattenClassUnionMember3IdentifiersSync(query);
  }

  flattenClassUnionMember3IdentifiersSync(
    query?: $ObjectSet.Query<FlattenClassUnionMember3.$Identifier>,
  ): purify.Either<Error, readonly FlattenClassUnionMember3.$Identifier[]> {
    return this.$objectIdentifiersSync<
      FlattenClassUnionMember3,
      FlattenClassUnionMember3.$Identifier
    >(
      [
        {
          $fromRdf: FlattenClassUnionMember3.$fromRdf,
          $fromRdfTypes: [FlattenClassUnionMember3.$fromRdfType],
        },
      ],
      query,
    );
  }

  async flattenClassUnionMember3s(
    query?: $ObjectSet.Query<FlattenClassUnionMember3.$Identifier>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnionMember3[]>> {
    return this.flattenClassUnionMember3sSync(query);
  }

  flattenClassUnionMember3sSync(
    query?: $ObjectSet.Query<FlattenClassUnionMember3.$Identifier>,
  ): purify.Either<Error, readonly FlattenClassUnionMember3[]> {
    return this.$objectsSync<
      FlattenClassUnionMember3,
      FlattenClassUnionMember3.$Identifier
    >(
      [
        {
          $fromRdf: FlattenClassUnionMember3.$fromRdf,
          $fromRdfTypes: [FlattenClassUnionMember3.$fromRdfType],
        },
      ],
      query,
    );
  }

  async flattenClassUnionMember3sCount(
    query?: Pick<
      $ObjectSet.Query<FlattenClassUnionMember3.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.flattenClassUnionMember3sCountSync(query);
  }

  flattenClassUnionMember3sCountSync(
    query?: Pick<
      $ObjectSet.Query<FlattenClassUnionMember3.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      FlattenClassUnionMember3,
      FlattenClassUnionMember3.$Identifier
    >(
      [
        {
          $fromRdf: FlattenClassUnionMember3.$fromRdf,
          $fromRdfTypes: [FlattenClassUnionMember3.$fromRdfType],
        },
      ],
      query,
    );
  }

  async hasValuePropertiesClass(
    identifier: HasValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, HasValuePropertiesClass>> {
    return this.hasValuePropertiesClassSync(identifier);
  }

  hasValuePropertiesClassSync(
    identifier: HasValuePropertiesClass.$Identifier,
  ): purify.Either<Error, HasValuePropertiesClass> {
    return this.hasValuePropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async hasValuePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly HasValuePropertiesClass.$Identifier[]>
  > {
    return this.hasValuePropertiesClassIdentifiersSync(query);
  }

  hasValuePropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly HasValuePropertiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      HasValuePropertiesClass,
      HasValuePropertiesClass.$Identifier
    >(
      [{ $fromRdf: HasValuePropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async hasValuePropertiesClasses(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly HasValuePropertiesClass[]>> {
    return this.hasValuePropertiesClassesSync(query);
  }

  hasValuePropertiesClassesSync(
    query?: $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly HasValuePropertiesClass[]> {
    return this.$objectsSync<
      HasValuePropertiesClass,
      HasValuePropertiesClass.$Identifier
    >(
      [{ $fromRdf: HasValuePropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async hasValuePropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.hasValuePropertiesClassesCountSync(query);
  }

  hasValuePropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<HasValuePropertiesClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      HasValuePropertiesClass,
      HasValuePropertiesClass.$Identifier
    >(
      [{ $fromRdf: HasValuePropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async identifierOverride3Class(
    identifier: IdentifierOverride3ClassStatic.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride3Class>> {
    return this.identifierOverride3ClassSync(identifier);
  }

  identifierOverride3ClassSync(
    identifier: IdentifierOverride3ClassStatic.$Identifier,
  ): purify.Either<Error, IdentifierOverride3Class> {
    return this.identifierOverride3ClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async identifierOverride3ClassIdentifiers(
    query?: $ObjectSet.Query<IdentifierOverride3ClassStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride3ClassStatic.$Identifier[]>
  > {
    return this.identifierOverride3ClassIdentifiersSync(query);
  }

  identifierOverride3ClassIdentifiersSync(
    query?: $ObjectSet.Query<IdentifierOverride3ClassStatic.$Identifier>,
  ): purify.Either<
    Error,
    readonly IdentifierOverride3ClassStatic.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      IdentifierOverride3Class,
      IdentifierOverride3ClassStatic.$Identifier
    >(
      [
        {
          $fromRdf: IdentifierOverride3ClassStatic.$fromRdf,
          $fromRdfTypes: [
            IdentifierOverride3ClassStatic.$fromRdfType,
            IdentifierOverride4ClassStatic.$fromRdfType,
            IdentifierOverride5Class.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async identifierOverride3Classes(
    query?: $ObjectSet.Query<IdentifierOverride3ClassStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride3Class[]>> {
    return this.identifierOverride3ClassesSync(query);
  }

  identifierOverride3ClassesSync(
    query?: $ObjectSet.Query<IdentifierOverride3ClassStatic.$Identifier>,
  ): purify.Either<Error, readonly IdentifierOverride3Class[]> {
    return this.$objectsSync<
      IdentifierOverride3Class,
      IdentifierOverride3ClassStatic.$Identifier
    >(
      [
        {
          $fromRdf: IdentifierOverride3ClassStatic.$fromRdf,
          $fromRdfTypes: [
            IdentifierOverride3ClassStatic.$fromRdfType,
            IdentifierOverride4ClassStatic.$fromRdfType,
            IdentifierOverride5Class.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async identifierOverride3ClassesCount(
    query?: Pick<
      $ObjectSet.Query<IdentifierOverride3ClassStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.identifierOverride3ClassesCountSync(query);
  }

  identifierOverride3ClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<IdentifierOverride3ClassStatic.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      IdentifierOverride3Class,
      IdentifierOverride3ClassStatic.$Identifier
    >(
      [
        {
          $fromRdf: IdentifierOverride3ClassStatic.$fromRdf,
          $fromRdfTypes: [
            IdentifierOverride3ClassStatic.$fromRdfType,
            IdentifierOverride4ClassStatic.$fromRdfType,
            IdentifierOverride5Class.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async identifierOverride4Class(
    identifier: IdentifierOverride4ClassStatic.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride4Class>> {
    return this.identifierOverride4ClassSync(identifier);
  }

  identifierOverride4ClassSync(
    identifier: IdentifierOverride4ClassStatic.$Identifier,
  ): purify.Either<Error, IdentifierOverride4Class> {
    return this.identifierOverride4ClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async identifierOverride4ClassIdentifiers(
    query?: $ObjectSet.Query<IdentifierOverride4ClassStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride4ClassStatic.$Identifier[]>
  > {
    return this.identifierOverride4ClassIdentifiersSync(query);
  }

  identifierOverride4ClassIdentifiersSync(
    query?: $ObjectSet.Query<IdentifierOverride4ClassStatic.$Identifier>,
  ): purify.Either<
    Error,
    readonly IdentifierOverride4ClassStatic.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      IdentifierOverride4Class,
      IdentifierOverride4ClassStatic.$Identifier
    >(
      [
        {
          $fromRdf: IdentifierOverride4ClassStatic.$fromRdf,
          $fromRdfTypes: [
            IdentifierOverride4ClassStatic.$fromRdfType,
            IdentifierOverride5Class.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async identifierOverride4Classes(
    query?: $ObjectSet.Query<IdentifierOverride4ClassStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride4Class[]>> {
    return this.identifierOverride4ClassesSync(query);
  }

  identifierOverride4ClassesSync(
    query?: $ObjectSet.Query<IdentifierOverride4ClassStatic.$Identifier>,
  ): purify.Either<Error, readonly IdentifierOverride4Class[]> {
    return this.$objectsSync<
      IdentifierOverride4Class,
      IdentifierOverride4ClassStatic.$Identifier
    >(
      [
        {
          $fromRdf: IdentifierOverride4ClassStatic.$fromRdf,
          $fromRdfTypes: [
            IdentifierOverride4ClassStatic.$fromRdfType,
            IdentifierOverride5Class.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async identifierOverride4ClassesCount(
    query?: Pick<
      $ObjectSet.Query<IdentifierOverride4ClassStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.identifierOverride4ClassesCountSync(query);
  }

  identifierOverride4ClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<IdentifierOverride4ClassStatic.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      IdentifierOverride4Class,
      IdentifierOverride4ClassStatic.$Identifier
    >(
      [
        {
          $fromRdf: IdentifierOverride4ClassStatic.$fromRdf,
          $fromRdfTypes: [
            IdentifierOverride4ClassStatic.$fromRdfType,
            IdentifierOverride5Class.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async identifierOverride5Class(
    identifier: IdentifierOverride5Class.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride5Class>> {
    return this.identifierOverride5ClassSync(identifier);
  }

  identifierOverride5ClassSync(
    identifier: IdentifierOverride5Class.$Identifier,
  ): purify.Either<Error, IdentifierOverride5Class> {
    return this.identifierOverride5ClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async identifierOverride5ClassIdentifiers(
    query?: $ObjectSet.Query<IdentifierOverride5Class.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride5Class.$Identifier[]>
  > {
    return this.identifierOverride5ClassIdentifiersSync(query);
  }

  identifierOverride5ClassIdentifiersSync(
    query?: $ObjectSet.Query<IdentifierOverride5Class.$Identifier>,
  ): purify.Either<Error, readonly IdentifierOverride5Class.$Identifier[]> {
    return this.$objectIdentifiersSync<
      IdentifierOverride5Class,
      IdentifierOverride5Class.$Identifier
    >(
      [
        {
          $fromRdf: IdentifierOverride5Class.$fromRdf,
          $fromRdfTypes: [IdentifierOverride5Class.$fromRdfType],
        },
      ],
      query,
    );
  }

  async identifierOverride5Classes(
    query?: $ObjectSet.Query<IdentifierOverride5Class.$Identifier>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride5Class[]>> {
    return this.identifierOverride5ClassesSync(query);
  }

  identifierOverride5ClassesSync(
    query?: $ObjectSet.Query<IdentifierOverride5Class.$Identifier>,
  ): purify.Either<Error, readonly IdentifierOverride5Class[]> {
    return this.$objectsSync<
      IdentifierOverride5Class,
      IdentifierOverride5Class.$Identifier
    >(
      [
        {
          $fromRdf: IdentifierOverride5Class.$fromRdf,
          $fromRdfTypes: [IdentifierOverride5Class.$fromRdfType],
        },
      ],
      query,
    );
  }

  async identifierOverride5ClassesCount(
    query?: Pick<
      $ObjectSet.Query<IdentifierOverride5Class.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.identifierOverride5ClassesCountSync(query);
  }

  identifierOverride5ClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<IdentifierOverride5Class.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      IdentifierOverride5Class,
      IdentifierOverride5Class.$Identifier
    >(
      [
        {
          $fromRdf: IdentifierOverride5Class.$fromRdf,
          $fromRdfTypes: [IdentifierOverride5Class.$fromRdfType],
        },
      ],
      query,
    );
  }

  async indirectRecursiveClass(
    identifier: IndirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveClass>> {
    return this.indirectRecursiveClassSync(identifier);
  }

  indirectRecursiveClassSync(
    identifier: IndirectRecursiveClass.$Identifier,
  ): purify.Either<Error, IndirectRecursiveClass> {
    return this.indirectRecursiveClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async indirectRecursiveClassIdentifiers(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveClass.$Identifier[]>
  > {
    return this.indirectRecursiveClassIdentifiersSync(query);
  }

  indirectRecursiveClassIdentifiersSync(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Identifier>,
  ): purify.Either<Error, readonly IndirectRecursiveClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      IndirectRecursiveClass,
      IndirectRecursiveClass.$Identifier
    >(
      [{ $fromRdf: IndirectRecursiveClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async indirectRecursiveClasses(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveClass[]>> {
    return this.indirectRecursiveClassesSync(query);
  }

  indirectRecursiveClassesSync(
    query?: $ObjectSet.Query<IndirectRecursiveClass.$Identifier>,
  ): purify.Either<Error, readonly IndirectRecursiveClass[]> {
    return this.$objectsSync<
      IndirectRecursiveClass,
      IndirectRecursiveClass.$Identifier
    >(
      [{ $fromRdf: IndirectRecursiveClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async indirectRecursiveClassesCount(
    query?: Pick<$ObjectSet.Query<IndirectRecursiveClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.indirectRecursiveClassesCountSync(query);
  }

  indirectRecursiveClassesCountSync(
    query?: Pick<$ObjectSet.Query<IndirectRecursiveClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      IndirectRecursiveClass,
      IndirectRecursiveClass.$Identifier
    >(
      [{ $fromRdf: IndirectRecursiveClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async indirectRecursiveHelperClass(
    identifier: IndirectRecursiveHelperClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveHelperClass>> {
    return this.indirectRecursiveHelperClassSync(identifier);
  }

  indirectRecursiveHelperClassSync(
    identifier: IndirectRecursiveHelperClass.$Identifier,
  ): purify.Either<Error, IndirectRecursiveHelperClass> {
    return this.indirectRecursiveHelperClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async indirectRecursiveHelperClassIdentifiers(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveHelperClass.$Identifier[]>
  > {
    return this.indirectRecursiveHelperClassIdentifiersSync(query);
  }

  indirectRecursiveHelperClassIdentifiersSync(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
  ): purify.Either<Error, readonly IndirectRecursiveHelperClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      IndirectRecursiveHelperClass,
      IndirectRecursiveHelperClass.$Identifier
    >(
      [{ $fromRdf: IndirectRecursiveHelperClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async indirectRecursiveHelperClasses(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveHelperClass[]>> {
    return this.indirectRecursiveHelperClassesSync(query);
  }

  indirectRecursiveHelperClassesSync(
    query?: $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
  ): purify.Either<Error, readonly IndirectRecursiveHelperClass[]> {
    return this.$objectsSync<
      IndirectRecursiveHelperClass,
      IndirectRecursiveHelperClass.$Identifier
    >(
      [{ $fromRdf: IndirectRecursiveHelperClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async indirectRecursiveHelperClassesCount(
    query?: Pick<
      $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.indirectRecursiveHelperClassesCountSync(query);
  }

  indirectRecursiveHelperClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      IndirectRecursiveHelperClass,
      IndirectRecursiveHelperClass.$Identifier
    >(
      [{ $fromRdf: IndirectRecursiveHelperClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async inIdentifierClass(
    identifier: InIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, InIdentifierClass>> {
    return this.inIdentifierClassSync(identifier);
  }

  inIdentifierClassSync(
    identifier: InIdentifierClass.$Identifier,
  ): purify.Either<Error, InIdentifierClass> {
    return this.inIdentifierClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async inIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<InIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass.$Identifier[]>> {
    return this.inIdentifierClassIdentifiersSync(query);
  }

  inIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<InIdentifierClass.$Identifier>,
  ): purify.Either<Error, readonly InIdentifierClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      InIdentifierClass,
      InIdentifierClass.$Identifier
    >([{ $fromRdf: InIdentifierClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async inIdentifierClasses(
    query?: $ObjectSet.Query<InIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass[]>> {
    return this.inIdentifierClassesSync(query);
  }

  inIdentifierClassesSync(
    query?: $ObjectSet.Query<InIdentifierClass.$Identifier>,
  ): purify.Either<Error, readonly InIdentifierClass[]> {
    return this.$objectsSync<InIdentifierClass, InIdentifierClass.$Identifier>(
      [{ $fromRdf: InIdentifierClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async inIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<InIdentifierClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.inIdentifierClassesCountSync(query);
  }

  inIdentifierClassesCountSync(
    query?: Pick<$ObjectSet.Query<InIdentifierClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      InIdentifierClass,
      InIdentifierClass.$Identifier
    >([{ $fromRdf: InIdentifierClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async inPropertiesClass(
    identifier: InPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, InPropertiesClass>> {
    return this.inPropertiesClassSync(identifier);
  }

  inPropertiesClassSync(
    identifier: InPropertiesClass.$Identifier,
  ): purify.Either<Error, InPropertiesClass> {
    return this.inPropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async inPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<InPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass.$Identifier[]>> {
    return this.inPropertiesClassIdentifiersSync(query);
  }

  inPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<InPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly InPropertiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      InPropertiesClass,
      InPropertiesClass.$Identifier
    >([{ $fromRdf: InPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async inPropertiesClasses(
    query?: $ObjectSet.Query<InPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass[]>> {
    return this.inPropertiesClassesSync(query);
  }

  inPropertiesClassesSync(
    query?: $ObjectSet.Query<InPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly InPropertiesClass[]> {
    return this.$objectsSync<InPropertiesClass, InPropertiesClass.$Identifier>(
      [{ $fromRdf: InPropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async inPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<InPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.inPropertiesClassesCountSync(query);
  }

  inPropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<InPropertiesClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      InPropertiesClass,
      InPropertiesClass.$Identifier
    >([{ $fromRdf: InPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async interface(
    identifier: Interface.$Identifier,
  ): Promise<purify.Either<Error, Interface>> {
    return this.interfaceSync(identifier);
  }

  interfaceSync(
    identifier: Interface.$Identifier,
  ): purify.Either<Error, Interface> {
    return this.interfacesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async interfaceIdentifiers(
    query?: $ObjectSet.Query<Interface.$Identifier>,
  ): Promise<purify.Either<Error, readonly Interface.$Identifier[]>> {
    return this.interfaceIdentifiersSync(query);
  }

  interfaceIdentifiersSync(
    query?: $ObjectSet.Query<Interface.$Identifier>,
  ): purify.Either<Error, readonly Interface.$Identifier[]> {
    return this.$objectIdentifiersSync<Interface, Interface.$Identifier>(
      [{ $fromRdf: Interface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async interfaces(
    query?: $ObjectSet.Query<Interface.$Identifier>,
  ): Promise<purify.Either<Error, readonly Interface[]>> {
    return this.interfacesSync(query);
  }

  interfacesSync(
    query?: $ObjectSet.Query<Interface.$Identifier>,
  ): purify.Either<Error, readonly Interface[]> {
    return this.$objectsSync<Interface, Interface.$Identifier>(
      [{ $fromRdf: Interface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async interfacesCount(
    query?: Pick<$ObjectSet.Query<Interface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.interfacesCountSync(query);
  }

  interfacesCountSync(
    query?: Pick<$ObjectSet.Query<Interface.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<Interface, Interface.$Identifier>(
      [{ $fromRdf: Interface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async interfaceUnionMember1(
    identifier: InterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember1>> {
    return this.interfaceUnionMember1Sync(identifier);
  }

  interfaceUnionMember1Sync(
    identifier: InterfaceUnionMember1.$Identifier,
  ): purify.Either<Error, InterfaceUnionMember1> {
    return this.interfaceUnionMember1sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async interfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember1.$Identifier[]>
  > {
    return this.interfaceUnionMember1IdentifiersSync(query);
  }

  interfaceUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly InterfaceUnionMember1.$Identifier[]> {
    return this.$objectIdentifiersSync<
      InterfaceUnionMember1,
      InterfaceUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: InterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [InterfaceUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async interfaceUnionMember1s(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember1[]>> {
    return this.interfaceUnionMember1sSync(query);
  }

  interfaceUnionMember1sSync(
    query?: $ObjectSet.Query<InterfaceUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly InterfaceUnionMember1[]> {
    return this.$objectsSync<
      InterfaceUnionMember1,
      InterfaceUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: InterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [InterfaceUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async interfaceUnionMember1sCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember1.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.interfaceUnionMember1sCountSync(query);
  }

  interfaceUnionMember1sCountSync(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember1.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      InterfaceUnionMember1,
      InterfaceUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: InterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [InterfaceUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async interfaceUnionMember2(
    identifier: InterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember2>> {
    return this.interfaceUnionMember2Sync(identifier);
  }

  interfaceUnionMember2Sync(
    identifier: InterfaceUnionMember2.$Identifier,
  ): purify.Either<Error, InterfaceUnionMember2> {
    return this.interfaceUnionMember2sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async interfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember2.$Identifier[]>
  > {
    return this.interfaceUnionMember2IdentifiersSync(query);
  }

  interfaceUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly InterfaceUnionMember2.$Identifier[]> {
    return this.$objectIdentifiersSync<
      InterfaceUnionMember2,
      InterfaceUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: InterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [InterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async interfaceUnionMember2s(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember2[]>> {
    return this.interfaceUnionMember2sSync(query);
  }

  interfaceUnionMember2sSync(
    query?: $ObjectSet.Query<InterfaceUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly InterfaceUnionMember2[]> {
    return this.$objectsSync<
      InterfaceUnionMember2,
      InterfaceUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: InterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [InterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async interfaceUnionMember2sCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember2.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.interfaceUnionMember2sCountSync(query);
  }

  interfaceUnionMember2sCountSync(
    query?: Pick<$ObjectSet.Query<InterfaceUnionMember2.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      InterfaceUnionMember2,
      InterfaceUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: InterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [InterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async iriIdentifierClass(
    identifier: IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, IriIdentifierClass>> {
    return this.iriIdentifierClassSync(identifier);
  }

  iriIdentifierClassSync(
    identifier: IriIdentifierClass.$Identifier,
  ): purify.Either<Error, IriIdentifierClass> {
    return this.iriIdentifierClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async iriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<IriIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IriIdentifierClass.$Identifier[]>> {
    return this.iriIdentifierClassIdentifiersSync(query);
  }

  iriIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<IriIdentifierClass.$Identifier>,
  ): purify.Either<Error, readonly IriIdentifierClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      IriIdentifierClass,
      IriIdentifierClass.$Identifier
    >([{ $fromRdf: IriIdentifierClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async iriIdentifierClasses(
    query?: $ObjectSet.Query<IriIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IriIdentifierClass[]>> {
    return this.iriIdentifierClassesSync(query);
  }

  iriIdentifierClassesSync(
    query?: $ObjectSet.Query<IriIdentifierClass.$Identifier>,
  ): purify.Either<Error, readonly IriIdentifierClass[]> {
    return this.$objectsSync<
      IriIdentifierClass,
      IriIdentifierClass.$Identifier
    >([{ $fromRdf: IriIdentifierClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async iriIdentifierClassesCount(
    query?: Pick<$ObjectSet.Query<IriIdentifierClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.iriIdentifierClassesCountSync(query);
  }

  iriIdentifierClassesCountSync(
    query?: Pick<$ObjectSet.Query<IriIdentifierClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      IriIdentifierClass,
      IriIdentifierClass.$Identifier
    >([{ $fromRdf: IriIdentifierClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async iriIdentifierInterface(
    identifier: IriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, IriIdentifierInterface>> {
    return this.iriIdentifierInterfaceSync(identifier);
  }

  iriIdentifierInterfaceSync(
    identifier: IriIdentifierInterface.$Identifier,
  ): purify.Either<Error, IriIdentifierInterface> {
    return this.iriIdentifierInterfacesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async iriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<IriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IriIdentifierInterface.$Identifier[]>
  > {
    return this.iriIdentifierInterfaceIdentifiersSync(query);
  }

  iriIdentifierInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<IriIdentifierInterface.$Identifier>,
  ): purify.Either<Error, readonly IriIdentifierInterface.$Identifier[]> {
    return this.$objectIdentifiersSync<
      IriIdentifierInterface,
      IriIdentifierInterface.$Identifier
    >(
      [{ $fromRdf: IriIdentifierInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async iriIdentifierInterfaces(
    query?: $ObjectSet.Query<IriIdentifierInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly IriIdentifierInterface[]>> {
    return this.iriIdentifierInterfacesSync(query);
  }

  iriIdentifierInterfacesSync(
    query?: $ObjectSet.Query<IriIdentifierInterface.$Identifier>,
  ): purify.Either<Error, readonly IriIdentifierInterface[]> {
    return this.$objectsSync<
      IriIdentifierInterface,
      IriIdentifierInterface.$Identifier
    >(
      [{ $fromRdf: IriIdentifierInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async iriIdentifierInterfacesCount(
    query?: Pick<$ObjectSet.Query<IriIdentifierInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.iriIdentifierInterfacesCountSync(query);
  }

  iriIdentifierInterfacesCountSync(
    query?: Pick<$ObjectSet.Query<IriIdentifierInterface.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      IriIdentifierInterface,
      IriIdentifierInterface.$Identifier
    >(
      [{ $fromRdf: IriIdentifierInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async jsPrimitiveUnionPropertyClass(
    identifier: JsPrimitiveUnionPropertyClass.$Identifier,
  ): Promise<purify.Either<Error, JsPrimitiveUnionPropertyClass>> {
    return this.jsPrimitiveUnionPropertyClassSync(identifier);
  }

  jsPrimitiveUnionPropertyClassSync(
    identifier: JsPrimitiveUnionPropertyClass.$Identifier,
  ): purify.Either<Error, JsPrimitiveUnionPropertyClass> {
    return this.jsPrimitiveUnionPropertyClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async jsPrimitiveUnionPropertyClassIdentifiers(
    query?: $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly JsPrimitiveUnionPropertyClass.$Identifier[]>
  > {
    return this.jsPrimitiveUnionPropertyClassIdentifiersSync(query);
  }

  jsPrimitiveUnionPropertyClassIdentifiersSync(
    query?: $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Identifier>,
  ): purify.Either<
    Error,
    readonly JsPrimitiveUnionPropertyClass.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      JsPrimitiveUnionPropertyClass,
      JsPrimitiveUnionPropertyClass.$Identifier
    >(
      [{ $fromRdf: JsPrimitiveUnionPropertyClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async jsPrimitiveUnionPropertyClasses(
    query?: $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly JsPrimitiveUnionPropertyClass[]>> {
    return this.jsPrimitiveUnionPropertyClassesSync(query);
  }

  jsPrimitiveUnionPropertyClassesSync(
    query?: $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Identifier>,
  ): purify.Either<Error, readonly JsPrimitiveUnionPropertyClass[]> {
    return this.$objectsSync<
      JsPrimitiveUnionPropertyClass,
      JsPrimitiveUnionPropertyClass.$Identifier
    >(
      [{ $fromRdf: JsPrimitiveUnionPropertyClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async jsPrimitiveUnionPropertyClassesCount(
    query?: Pick<
      $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.jsPrimitiveUnionPropertyClassesCountSync(query);
  }

  jsPrimitiveUnionPropertyClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<JsPrimitiveUnionPropertyClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      JsPrimitiveUnionPropertyClass,
      JsPrimitiveUnionPropertyClass.$Identifier
    >(
      [{ $fromRdf: JsPrimitiveUnionPropertyClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async languageInPropertiesClass(
    identifier: LanguageInPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LanguageInPropertiesClass>> {
    return this.languageInPropertiesClassSync(identifier);
  }

  languageInPropertiesClassSync(
    identifier: LanguageInPropertiesClass.$Identifier,
  ): purify.Either<Error, LanguageInPropertiesClass> {
    return this.languageInPropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async languageInPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LanguageInPropertiesClass.$Identifier[]>
  > {
    return this.languageInPropertiesClassIdentifiersSync(query);
  }

  languageInPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly LanguageInPropertiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      LanguageInPropertiesClass,
      LanguageInPropertiesClass.$Identifier
    >(
      [{ $fromRdf: LanguageInPropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async languageInPropertiesClasses(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LanguageInPropertiesClass[]>> {
    return this.languageInPropertiesClassesSync(query);
  }

  languageInPropertiesClassesSync(
    query?: $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly LanguageInPropertiesClass[]> {
    return this.$objectsSync<
      LanguageInPropertiesClass,
      LanguageInPropertiesClass.$Identifier
    >(
      [{ $fromRdf: LanguageInPropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async languageInPropertiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.languageInPropertiesClassesCountSync(query);
  }

  languageInPropertiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LanguageInPropertiesClass,
      LanguageInPropertiesClass.$Identifier
    >(
      [{ $fromRdf: LanguageInPropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClass(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<
    purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierClass>
  > {
    return this.lazilyResolvedBlankNodeOrIriIdentifierClassSync(identifier);
  }

  lazilyResolvedBlankNodeOrIriIdentifierClassSync(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
  ): purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierClass> {
    return this.lazilyResolvedBlankNodeOrIriIdentifierClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier[]
    >
  > {
    return this.lazilyResolvedBlankNodeOrIriIdentifierClassIdentifiersSync(
      query,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      LazilyResolvedBlankNodeOrIriIdentifierClass,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdf,
          $fromRdfTypes: [
            LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClasses(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedBlankNodeOrIriIdentifierClass[]>
  > {
    return this.lazilyResolvedBlankNodeOrIriIdentifierClassesSync(query);
  }

  lazilyResolvedBlankNodeOrIriIdentifierClassesSync(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedBlankNodeOrIriIdentifierClass[]
  > {
    return this.$objectsSync<
      LazilyResolvedBlankNodeOrIriIdentifierClass,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdf,
          $fromRdfTypes: [
            LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedBlankNodeOrIriIdentifierClassesCountSync(query);
  }

  lazilyResolvedBlankNodeOrIriIdentifierClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazilyResolvedBlankNodeOrIriIdentifierClass,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdf,
          $fromRdfTypes: [
            LazilyResolvedBlankNodeOrIriIdentifierClass.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterface(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<
    purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierInterface>
  > {
    return this.lazilyResolvedBlankNodeOrIriIdentifierInterfaceSync(identifier);
  }

  lazilyResolvedBlankNodeOrIriIdentifierInterfaceSync(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
  ): purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierInterface> {
    return this.lazilyResolvedBlankNodeOrIriIdentifierInterfacesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier[]
    >
  > {
    return this.lazilyResolvedBlankNodeOrIriIdentifierInterfaceIdentifiersSync(
      query,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      LazilyResolvedBlankNodeOrIriIdentifierInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdf,
          $fromRdfTypes: [
            LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterfaces(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[]
    >
  > {
    return this.lazilyResolvedBlankNodeOrIriIdentifierInterfacesSync(query);
  }

  lazilyResolvedBlankNodeOrIriIdentifierInterfacesSync(
    query?: $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[]
  > {
    return this.$objectsSync<
      LazilyResolvedBlankNodeOrIriIdentifierInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdf,
          $fromRdfTypes: [
            LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedBlankNodeOrIriIdentifierInterfacesCountSync(
      query,
    );
  }

  lazilyResolvedBlankNodeOrIriIdentifierInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazilyResolvedBlankNodeOrIriIdentifierInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdf,
          $fromRdfTypes: [
            LazilyResolvedBlankNodeOrIriIdentifierInterface.$fromRdfType,
          ],
        },
      ],
      query,
    );
  }

  async lazilyResolvedClassUnionMember1(
    identifier: LazilyResolvedClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember1>> {
    return this.lazilyResolvedClassUnionMember1Sync(identifier);
  }

  lazilyResolvedClassUnionMember1Sync(
    identifier: LazilyResolvedClassUnionMember1.$Identifier,
  ): purify.Either<Error, LazilyResolvedClassUnionMember1> {
    return this.lazilyResolvedClassUnionMember1sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember1.$Identifier[]>
  > {
    return this.lazilyResolvedClassUnionMember1IdentifiersSync(query);
  }

  lazilyResolvedClassUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedClassUnionMember1.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      LazilyResolvedClassUnionMember1,
      LazilyResolvedClassUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedClassUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedClassUnionMember1s(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember1[]>> {
    return this.lazilyResolvedClassUnionMember1sSync(query);
  }

  lazilyResolvedClassUnionMember1sSync(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedClassUnionMember1[]> {
    return this.$objectsSync<
      LazilyResolvedClassUnionMember1,
      LazilyResolvedClassUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedClassUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedClassUnionMember1sCountSync(query);
  }

  lazilyResolvedClassUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazilyResolvedClassUnionMember1,
      LazilyResolvedClassUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedClassUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedClassUnionMember2(
    identifier: LazilyResolvedClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember2>> {
    return this.lazilyResolvedClassUnionMember2Sync(identifier);
  }

  lazilyResolvedClassUnionMember2Sync(
    identifier: LazilyResolvedClassUnionMember2.$Identifier,
  ): purify.Either<Error, LazilyResolvedClassUnionMember2> {
    return this.lazilyResolvedClassUnionMember2sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember2.$Identifier[]>
  > {
    return this.lazilyResolvedClassUnionMember2IdentifiersSync(query);
  }

  lazilyResolvedClassUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedClassUnionMember2.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      LazilyResolvedClassUnionMember2,
      LazilyResolvedClassUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedClassUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedClassUnionMember2s(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember2[]>> {
    return this.lazilyResolvedClassUnionMember2sSync(query);
  }

  lazilyResolvedClassUnionMember2sSync(
    query?: $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedClassUnionMember2[]> {
    return this.$objectsSync<
      LazilyResolvedClassUnionMember2,
      LazilyResolvedClassUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedClassUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedClassUnionMember2sCountSync(query);
  }

  lazilyResolvedClassUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazilyResolvedClassUnionMember2,
      LazilyResolvedClassUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedClassUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember1(
    identifier: LazilyResolvedInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember1>> {
    return this.lazilyResolvedInterfaceUnionMember1Sync(identifier);
  }

  lazilyResolvedInterfaceUnionMember1Sync(
    identifier: LazilyResolvedInterfaceUnionMember1.$Identifier,
  ): purify.Either<Error, LazilyResolvedInterfaceUnionMember1> {
    return this.lazilyResolvedInterfaceUnionMember1sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember1.$Identifier[]
    >
  > {
    return this.lazilyResolvedInterfaceUnionMember1IdentifiersSync(query);
  }

  lazilyResolvedInterfaceUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedInterfaceUnionMember1.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      LazilyResolvedInterfaceUnionMember1,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember1s(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember1[]>
  > {
    return this.lazilyResolvedInterfaceUnionMember1sSync(query);
  }

  lazilyResolvedInterfaceUnionMember1sSync(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember1[]> {
    return this.$objectsSync<
      LazilyResolvedInterfaceUnionMember1,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedInterfaceUnionMember1sCountSync(query);
  }

  lazilyResolvedInterfaceUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazilyResolvedInterfaceUnionMember1,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember2(
    identifier: LazilyResolvedInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember2>> {
    return this.lazilyResolvedInterfaceUnionMember2Sync(identifier);
  }

  lazilyResolvedInterfaceUnionMember2Sync(
    identifier: LazilyResolvedInterfaceUnionMember2.$Identifier,
  ): purify.Either<Error, LazilyResolvedInterfaceUnionMember2> {
    return this.lazilyResolvedInterfaceUnionMember2sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember2.$Identifier[]
    >
  > {
    return this.lazilyResolvedInterfaceUnionMember2IdentifiersSync(query);
  }

  lazilyResolvedInterfaceUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedInterfaceUnionMember2.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      LazilyResolvedInterfaceUnionMember2,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember2s(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember2[]>
  > {
    return this.lazilyResolvedInterfaceUnionMember2sSync(query);
  }

  lazilyResolvedInterfaceUnionMember2sSync(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember2[]> {
    return this.$objectsSync<
      LazilyResolvedInterfaceUnionMember2,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedInterfaceUnionMember2sCountSync(query);
  }

  lazilyResolvedInterfaceUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazilyResolvedInterfaceUnionMember2,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedIriIdentifierClass(
    identifier: LazilyResolvedIriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriIdentifierClass>> {
    return this.lazilyResolvedIriIdentifierClassSync(identifier);
  }

  lazilyResolvedIriIdentifierClassSync(
    identifier: LazilyResolvedIriIdentifierClass.$Identifier,
  ): purify.Either<Error, LazilyResolvedIriIdentifierClass> {
    return this.lazilyResolvedIriIdentifierClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedIriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedIriIdentifierClass.$Identifier[]
    >
  > {
    return this.lazilyResolvedIriIdentifierClassIdentifiersSync(query);
  }

  lazilyResolvedIriIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Identifier>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedIriIdentifierClass.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      LazilyResolvedIriIdentifierClass,
      LazilyResolvedIriIdentifierClass.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedIriIdentifierClass.$fromRdf,
          $fromRdfTypes: [],
        },
      ],
      query,
    );
  }

  async lazilyResolvedIriIdentifierClasses(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriIdentifierClass[]>
  > {
    return this.lazilyResolvedIriIdentifierClassesSync(query);
  }

  lazilyResolvedIriIdentifierClassesSync(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedIriIdentifierClass[]> {
    return this.$objectsSync<
      LazilyResolvedIriIdentifierClass,
      LazilyResolvedIriIdentifierClass.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedIriIdentifierClass.$fromRdf,
          $fromRdfTypes: [],
        },
      ],
      query,
    );
  }

  async lazilyResolvedIriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedIriIdentifierClassesCountSync(query);
  }

  lazilyResolvedIriIdentifierClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedIriIdentifierClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazilyResolvedIriIdentifierClass,
      LazilyResolvedIriIdentifierClass.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedIriIdentifierClass.$fromRdf,
          $fromRdfTypes: [],
        },
      ],
      query,
    );
  }

  async lazilyResolvedIriIdentifierInterface(
    identifier: LazilyResolvedIriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriIdentifierInterface>> {
    return this.lazilyResolvedIriIdentifierInterfaceSync(identifier);
  }

  lazilyResolvedIriIdentifierInterfaceSync(
    identifier: LazilyResolvedIriIdentifierInterface.$Identifier,
  ): purify.Either<Error, LazilyResolvedIriIdentifierInterface> {
    return this.lazilyResolvedIriIdentifierInterfacesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedIriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedIriIdentifierInterface.$Identifier[]
    >
  > {
    return this.lazilyResolvedIriIdentifierInterfaceIdentifiersSync(query);
  }

  lazilyResolvedIriIdentifierInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Identifier>,
  ): purify.Either<
    Error,
    readonly LazilyResolvedIriIdentifierInterface.$Identifier[]
  > {
    return this.$objectIdentifiersSync<
      LazilyResolvedIriIdentifierInterface,
      LazilyResolvedIriIdentifierInterface.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedIriIdentifierInterface.$fromRdf,
          $fromRdfTypes: [],
        },
      ],
      query,
    );
  }

  async lazilyResolvedIriIdentifierInterfaces(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriIdentifierInterface[]>
  > {
    return this.lazilyResolvedIriIdentifierInterfacesSync(query);
  }

  lazilyResolvedIriIdentifierInterfacesSync(
    query?: $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedIriIdentifierInterface[]> {
    return this.$objectsSync<
      LazilyResolvedIriIdentifierInterface,
      LazilyResolvedIriIdentifierInterface.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedIriIdentifierInterface.$fromRdf,
          $fromRdfTypes: [],
        },
      ],
      query,
    );
  }

  async lazilyResolvedIriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedIriIdentifierInterfacesCountSync(query);
  }

  lazilyResolvedIriIdentifierInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazilyResolvedIriIdentifierInterface,
      LazilyResolvedIriIdentifierInterface.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedIriIdentifierInterface.$fromRdf,
          $fromRdfTypes: [],
        },
      ],
      query,
    );
  }

  async lazyPropertiesClass(
    identifier: LazyPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesClass>> {
    return this.lazyPropertiesClassSync(identifier);
  }

  lazyPropertiesClassSync(
    identifier: LazyPropertiesClass.$Identifier,
  ): purify.Either<Error, LazyPropertiesClass> {
    return this.lazyPropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazyPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass.$Identifier[]>> {
    return this.lazyPropertiesClassIdentifiersSync(query);
  }

  lazyPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly LazyPropertiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      LazyPropertiesClass,
      LazyPropertiesClass.$Identifier
    >([{ $fromRdf: LazyPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async lazyPropertiesClasses(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass[]>> {
    return this.lazyPropertiesClassesSync(query);
  }

  lazyPropertiesClassesSync(
    query?: $ObjectSet.Query<LazyPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly LazyPropertiesClass[]> {
    return this.$objectsSync<
      LazyPropertiesClass,
      LazyPropertiesClass.$Identifier
    >([{ $fromRdf: LazyPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async lazyPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<LazyPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.lazyPropertiesClassesCountSync(query);
  }

  lazyPropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<LazyPropertiesClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazyPropertiesClass,
      LazyPropertiesClass.$Identifier
    >([{ $fromRdf: LazyPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async lazyPropertiesInterface(
    identifier: LazyPropertiesInterface.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesInterface>> {
    return this.lazyPropertiesInterfaceSync(identifier);
  }

  lazyPropertiesInterfaceSync(
    identifier: LazyPropertiesInterface.$Identifier,
  ): purify.Either<Error, LazyPropertiesInterface> {
    return this.lazyPropertiesInterfacesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazyPropertiesInterfaceIdentifiers(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazyPropertiesInterface.$Identifier[]>
  > {
    return this.lazyPropertiesInterfaceIdentifiersSync(query);
  }

  lazyPropertiesInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
  ): purify.Either<Error, readonly LazyPropertiesInterface.$Identifier[]> {
    return this.$objectIdentifiersSync<
      LazyPropertiesInterface,
      LazyPropertiesInterface.$Identifier
    >(
      [{ $fromRdf: LazyPropertiesInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async lazyPropertiesInterfaces(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesInterface[]>> {
    return this.lazyPropertiesInterfacesSync(query);
  }

  lazyPropertiesInterfacesSync(
    query?: $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
  ): purify.Either<Error, readonly LazyPropertiesInterface[]> {
    return this.$objectsSync<
      LazyPropertiesInterface,
      LazyPropertiesInterface.$Identifier
    >(
      [{ $fromRdf: LazyPropertiesInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async lazyPropertiesInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazyPropertiesInterfacesCountSync(query);
  }

  lazyPropertiesInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<LazyPropertiesInterface.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazyPropertiesInterface,
      LazyPropertiesInterface.$Identifier
    >(
      [{ $fromRdf: LazyPropertiesInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async listPropertiesClass(
    identifier: ListPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ListPropertiesClass>> {
    return this.listPropertiesClassSync(identifier);
  }

  listPropertiesClassSync(
    identifier: ListPropertiesClass.$Identifier,
  ): purify.Either<Error, ListPropertiesClass> {
    return this.listPropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async listPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<ListPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass.$Identifier[]>> {
    return this.listPropertiesClassIdentifiersSync(query);
  }

  listPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<ListPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly ListPropertiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      ListPropertiesClass,
      ListPropertiesClass.$Identifier
    >([{ $fromRdf: ListPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async listPropertiesClasses(
    query?: $ObjectSet.Query<ListPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass[]>> {
    return this.listPropertiesClassesSync(query);
  }

  listPropertiesClassesSync(
    query?: $ObjectSet.Query<ListPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly ListPropertiesClass[]> {
    return this.$objectsSync<
      ListPropertiesClass,
      ListPropertiesClass.$Identifier
    >([{ $fromRdf: ListPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async listPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<ListPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.listPropertiesClassesCountSync(query);
  }

  listPropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<ListPropertiesClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ListPropertiesClass,
      ListPropertiesClass.$Identifier
    >([{ $fromRdf: ListPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async mutablePropertiesClass(
    identifier: MutablePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, MutablePropertiesClass>> {
    return this.mutablePropertiesClassSync(identifier);
  }

  mutablePropertiesClassSync(
    identifier: MutablePropertiesClass.$Identifier,
  ): purify.Either<Error, MutablePropertiesClass> {
    return this.mutablePropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async mutablePropertiesClassIdentifiers(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly MutablePropertiesClass.$Identifier[]>
  > {
    return this.mutablePropertiesClassIdentifiersSync(query);
  }

  mutablePropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly MutablePropertiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      MutablePropertiesClass,
      MutablePropertiesClass.$Identifier
    >(
      [{ $fromRdf: MutablePropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async mutablePropertiesClasses(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly MutablePropertiesClass[]>> {
    return this.mutablePropertiesClassesSync(query);
  }

  mutablePropertiesClassesSync(
    query?: $ObjectSet.Query<MutablePropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly MutablePropertiesClass[]> {
    return this.$objectsSync<
      MutablePropertiesClass,
      MutablePropertiesClass.$Identifier
    >(
      [{ $fromRdf: MutablePropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async mutablePropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<MutablePropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.mutablePropertiesClassesCountSync(query);
  }

  mutablePropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<MutablePropertiesClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      MutablePropertiesClass,
      MutablePropertiesClass.$Identifier
    >(
      [{ $fromRdf: MutablePropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async nonClass(
    identifier: NonClass.$Identifier,
  ): Promise<purify.Either<Error, NonClass>> {
    return this.nonClassSync(identifier);
  }

  nonClassSync(
    identifier: NonClass.$Identifier,
  ): purify.Either<Error, NonClass> {
    return this.nonClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async nonClassIdentifiers(
    query?: $ObjectSet.Query<NonClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly NonClass.$Identifier[]>> {
    return this.nonClassIdentifiersSync(query);
  }

  nonClassIdentifiersSync(
    query?: $ObjectSet.Query<NonClass.$Identifier>,
  ): purify.Either<Error, readonly NonClass.$Identifier[]> {
    return this.$objectIdentifiersSync<NonClass, NonClass.$Identifier>(
      [{ $fromRdf: NonClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async nonClasses(
    query?: $ObjectSet.Query<NonClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly NonClass[]>> {
    return this.nonClassesSync(query);
  }

  nonClassesSync(
    query?: $ObjectSet.Query<NonClass.$Identifier>,
  ): purify.Either<Error, readonly NonClass[]> {
    return this.$objectsSync<NonClass, NonClass.$Identifier>(
      [{ $fromRdf: NonClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async nonClassesCount(
    query?: Pick<$ObjectSet.Query<NonClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.nonClassesCountSync(query);
  }

  nonClassesCountSync(
    query?: Pick<$ObjectSet.Query<NonClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<NonClass, NonClass.$Identifier>(
      [{ $fromRdf: NonClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async noRdfTypeClassUnionMember1(
    identifier: NoRdfTypeClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnionMember1>> {
    return this.noRdfTypeClassUnionMember1Sync(identifier);
  }

  noRdfTypeClassUnionMember1Sync(
    identifier: NoRdfTypeClassUnionMember1.$Identifier,
  ): purify.Either<Error, NoRdfTypeClassUnionMember1> {
    return this.noRdfTypeClassUnionMember1sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async noRdfTypeClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly NoRdfTypeClassUnionMember1.$Identifier[]>
  > {
    return this.noRdfTypeClassUnionMember1IdentifiersSync(query);
  }

  noRdfTypeClassUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly NoRdfTypeClassUnionMember1.$Identifier[]> {
    return this.$objectIdentifiersSync<
      NoRdfTypeClassUnionMember1,
      NoRdfTypeClassUnionMember1.$Identifier
    >(
      [{ $fromRdf: NoRdfTypeClassUnionMember1.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async noRdfTypeClassUnionMember1s(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnionMember1[]>> {
    return this.noRdfTypeClassUnionMember1sSync(query);
  }

  noRdfTypeClassUnionMember1sSync(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly NoRdfTypeClassUnionMember1[]> {
    return this.$objectsSync<
      NoRdfTypeClassUnionMember1,
      NoRdfTypeClassUnionMember1.$Identifier
    >(
      [{ $fromRdf: NoRdfTypeClassUnionMember1.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async noRdfTypeClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.noRdfTypeClassUnionMember1sCountSync(query);
  }

  noRdfTypeClassUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<NoRdfTypeClassUnionMember1.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      NoRdfTypeClassUnionMember1,
      NoRdfTypeClassUnionMember1.$Identifier
    >(
      [{ $fromRdf: NoRdfTypeClassUnionMember1.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async noRdfTypeClassUnionMember2(
    identifier: NoRdfTypeClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnionMember2>> {
    return this.noRdfTypeClassUnionMember2Sync(identifier);
  }

  noRdfTypeClassUnionMember2Sync(
    identifier: NoRdfTypeClassUnionMember2.$Identifier,
  ): purify.Either<Error, NoRdfTypeClassUnionMember2> {
    return this.noRdfTypeClassUnionMember2sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async noRdfTypeClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly NoRdfTypeClassUnionMember2.$Identifier[]>
  > {
    return this.noRdfTypeClassUnionMember2IdentifiersSync(query);
  }

  noRdfTypeClassUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly NoRdfTypeClassUnionMember2.$Identifier[]> {
    return this.$objectIdentifiersSync<
      NoRdfTypeClassUnionMember2,
      NoRdfTypeClassUnionMember2.$Identifier
    >(
      [{ $fromRdf: NoRdfTypeClassUnionMember2.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async noRdfTypeClassUnionMember2s(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnionMember2[]>> {
    return this.noRdfTypeClassUnionMember2sSync(query);
  }

  noRdfTypeClassUnionMember2sSync(
    query?: $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly NoRdfTypeClassUnionMember2[]> {
    return this.$objectsSync<
      NoRdfTypeClassUnionMember2,
      NoRdfTypeClassUnionMember2.$Identifier
    >(
      [{ $fromRdf: NoRdfTypeClassUnionMember2.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async noRdfTypeClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.noRdfTypeClassUnionMember2sCountSync(query);
  }

  noRdfTypeClassUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<NoRdfTypeClassUnionMember2.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      NoRdfTypeClassUnionMember2,
      NoRdfTypeClassUnionMember2.$Identifier
    >(
      [{ $fromRdf: NoRdfTypeClassUnionMember2.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async orderedPropertiesClass(
    identifier: OrderedPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, OrderedPropertiesClass>> {
    return this.orderedPropertiesClassSync(identifier);
  }

  orderedPropertiesClassSync(
    identifier: OrderedPropertiesClass.$Identifier,
  ): purify.Either<Error, OrderedPropertiesClass> {
    return this.orderedPropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async orderedPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly OrderedPropertiesClass.$Identifier[]>
  > {
    return this.orderedPropertiesClassIdentifiersSync(query);
  }

  orderedPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly OrderedPropertiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      OrderedPropertiesClass,
      OrderedPropertiesClass.$Identifier
    >(
      [{ $fromRdf: OrderedPropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async orderedPropertiesClasses(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly OrderedPropertiesClass[]>> {
    return this.orderedPropertiesClassesSync(query);
  }

  orderedPropertiesClassesSync(
    query?: $ObjectSet.Query<OrderedPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly OrderedPropertiesClass[]> {
    return this.$objectsSync<
      OrderedPropertiesClass,
      OrderedPropertiesClass.$Identifier
    >(
      [{ $fromRdf: OrderedPropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async orderedPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<OrderedPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.orderedPropertiesClassesCountSync(query);
  }

  orderedPropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<OrderedPropertiesClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      OrderedPropertiesClass,
      OrderedPropertiesClass.$Identifier
    >(
      [{ $fromRdf: OrderedPropertiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async partialClass(
    identifier: PartialClass.$Identifier,
  ): Promise<purify.Either<Error, PartialClass>> {
    return this.partialClassSync(identifier);
  }

  partialClassSync(
    identifier: PartialClass.$Identifier,
  ): purify.Either<Error, PartialClass> {
    return this.partialClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async partialClassIdentifiers(
    query?: $ObjectSet.Query<PartialClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClass.$Identifier[]>> {
    return this.partialClassIdentifiersSync(query);
  }

  partialClassIdentifiersSync(
    query?: $ObjectSet.Query<PartialClass.$Identifier>,
  ): purify.Either<Error, readonly PartialClass.$Identifier[]> {
    return this.$objectIdentifiersSync<PartialClass, PartialClass.$Identifier>(
      [{ $fromRdf: PartialClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async partialClasses(
    query?: $ObjectSet.Query<PartialClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClass[]>> {
    return this.partialClassesSync(query);
  }

  partialClassesSync(
    query?: $ObjectSet.Query<PartialClass.$Identifier>,
  ): purify.Either<Error, readonly PartialClass[]> {
    return this.$objectsSync<PartialClass, PartialClass.$Identifier>(
      [{ $fromRdf: PartialClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async partialClassesCount(
    query?: Pick<$ObjectSet.Query<PartialClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.partialClassesCountSync(query);
  }

  partialClassesCountSync(
    query?: Pick<$ObjectSet.Query<PartialClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<PartialClass, PartialClass.$Identifier>(
      [{ $fromRdf: PartialClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async partialClassUnionMember1(
    identifier: PartialClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember1>> {
    return this.partialClassUnionMember1Sync(identifier);
  }

  partialClassUnionMember1Sync(
    identifier: PartialClassUnionMember1.$Identifier,
  ): purify.Either<Error, PartialClassUnionMember1> {
    return this.partialClassUnionMember1sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async partialClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember1.$Identifier[]>
  > {
    return this.partialClassUnionMember1IdentifiersSync(query);
  }

  partialClassUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly PartialClassUnionMember1.$Identifier[]> {
    return this.$objectIdentifiersSync<
      PartialClassUnionMember1,
      PartialClassUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: PartialClassUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialClassUnionMember1s(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember1[]>> {
    return this.partialClassUnionMember1sSync(query);
  }

  partialClassUnionMember1sSync(
    query?: $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly PartialClassUnionMember1[]> {
    return this.$objectsSync<
      PartialClassUnionMember1,
      PartialClassUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: PartialClassUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.partialClassUnionMember1sCountSync(query);
  }

  partialClassUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<PartialClassUnionMember1.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PartialClassUnionMember1,
      PartialClassUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: PartialClassUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialClassUnionMember2(
    identifier: PartialClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember2>> {
    return this.partialClassUnionMember2Sync(identifier);
  }

  partialClassUnionMember2Sync(
    identifier: PartialClassUnionMember2.$Identifier,
  ): purify.Either<Error, PartialClassUnionMember2> {
    return this.partialClassUnionMember2sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async partialClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember2.$Identifier[]>
  > {
    return this.partialClassUnionMember2IdentifiersSync(query);
  }

  partialClassUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly PartialClassUnionMember2.$Identifier[]> {
    return this.$objectIdentifiersSync<
      PartialClassUnionMember2,
      PartialClassUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: PartialClassUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialClassUnionMember2s(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember2[]>> {
    return this.partialClassUnionMember2sSync(query);
  }

  partialClassUnionMember2sSync(
    query?: $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly PartialClassUnionMember2[]> {
    return this.$objectsSync<
      PartialClassUnionMember2,
      PartialClassUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: PartialClassUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.partialClassUnionMember2sCountSync(query);
  }

  partialClassUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<PartialClassUnionMember2.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PartialClassUnionMember2,
      PartialClassUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: PartialClassUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialInterface(
    identifier: PartialInterface.$Identifier,
  ): Promise<purify.Either<Error, PartialInterface>> {
    return this.partialInterfaceSync(identifier);
  }

  partialInterfaceSync(
    identifier: PartialInterface.$Identifier,
  ): purify.Either<Error, PartialInterface> {
    return this.partialInterfacesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async partialInterfaceIdentifiers(
    query?: $ObjectSet.Query<PartialInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterface.$Identifier[]>> {
    return this.partialInterfaceIdentifiersSync(query);
  }

  partialInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<PartialInterface.$Identifier>,
  ): purify.Either<Error, readonly PartialInterface.$Identifier[]> {
    return this.$objectIdentifiersSync<
      PartialInterface,
      PartialInterface.$Identifier
    >([{ $fromRdf: PartialInterface.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async partialInterfaces(
    query?: $ObjectSet.Query<PartialInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterface[]>> {
    return this.partialInterfacesSync(query);
  }

  partialInterfacesSync(
    query?: $ObjectSet.Query<PartialInterface.$Identifier>,
  ): purify.Either<Error, readonly PartialInterface[]> {
    return this.$objectsSync<PartialInterface, PartialInterface.$Identifier>(
      [{ $fromRdf: PartialInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async partialInterfacesCount(
    query?: Pick<$ObjectSet.Query<PartialInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.partialInterfacesCountSync(query);
  }

  partialInterfacesCountSync(
    query?: Pick<$ObjectSet.Query<PartialInterface.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PartialInterface,
      PartialInterface.$Identifier
    >([{ $fromRdf: PartialInterface.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async partialInterfaceUnionMember1(
    identifier: PartialInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember1>> {
    return this.partialInterfaceUnionMember1Sync(identifier);
  }

  partialInterfaceUnionMember1Sync(
    identifier: PartialInterfaceUnionMember1.$Identifier,
  ): purify.Either<Error, PartialInterfaceUnionMember1> {
    return this.partialInterfaceUnionMember1sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async partialInterfaceUnionMember1Identifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember1.$Identifier[]>
  > {
    return this.partialInterfaceUnionMember1IdentifiersSync(query);
  }

  partialInterfaceUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly PartialInterfaceUnionMember1.$Identifier[]> {
    return this.$objectIdentifiersSync<
      PartialInterfaceUnionMember1,
      PartialInterfaceUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: PartialInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialInterfaceUnionMember1s(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember1[]>> {
    return this.partialInterfaceUnionMember1sSync(query);
  }

  partialInterfaceUnionMember1sSync(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly PartialInterfaceUnionMember1[]> {
    return this.$objectsSync<
      PartialInterfaceUnionMember1,
      PartialInterfaceUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: PartialInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialInterfaceUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.partialInterfaceUnionMember1sCountSync(query);
  }

  partialInterfaceUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PartialInterfaceUnionMember1,
      PartialInterfaceUnionMember1.$Identifier
    >(
      [
        {
          $fromRdf: PartialInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember1.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialInterfaceUnionMember2(
    identifier: PartialInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember2>> {
    return this.partialInterfaceUnionMember2Sync(identifier);
  }

  partialInterfaceUnionMember2Sync(
    identifier: PartialInterfaceUnionMember2.$Identifier,
  ): purify.Either<Error, PartialInterfaceUnionMember2> {
    return this.partialInterfaceUnionMember2sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async partialInterfaceUnionMember2Identifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember2.$Identifier[]>
  > {
    return this.partialInterfaceUnionMember2IdentifiersSync(query);
  }

  partialInterfaceUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly PartialInterfaceUnionMember2.$Identifier[]> {
    return this.$objectIdentifiersSync<
      PartialInterfaceUnionMember2,
      PartialInterfaceUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: PartialInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialInterfaceUnionMember2s(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember2[]>> {
    return this.partialInterfaceUnionMember2sSync(query);
  }

  partialInterfaceUnionMember2sSync(
    query?: $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly PartialInterfaceUnionMember2[]> {
    return this.$objectsSync<
      PartialInterfaceUnionMember2,
      PartialInterfaceUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: PartialInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialInterfaceUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.partialInterfaceUnionMember2sCountSync(query);
  }

  partialInterfaceUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PartialInterfaceUnionMember2,
      PartialInterfaceUnionMember2.$Identifier
    >(
      [
        {
          $fromRdf: PartialInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async propertyCardinalitiesClass(
    identifier: PropertyCardinalitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyCardinalitiesClass>> {
    return this.propertyCardinalitiesClassSync(identifier);
  }

  propertyCardinalitiesClassSync(
    identifier: PropertyCardinalitiesClass.$Identifier,
  ): purify.Either<Error, PropertyCardinalitiesClass> {
    return this.propertyCardinalitiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async propertyCardinalitiesClassIdentifiers(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PropertyCardinalitiesClass.$Identifier[]>
  > {
    return this.propertyCardinalitiesClassIdentifiersSync(query);
  }

  propertyCardinalitiesClassIdentifiersSync(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
  ): purify.Either<Error, readonly PropertyCardinalitiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      PropertyCardinalitiesClass,
      PropertyCardinalitiesClass.$Identifier
    >(
      [{ $fromRdf: PropertyCardinalitiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async propertyCardinalitiesClasses(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PropertyCardinalitiesClass[]>> {
    return this.propertyCardinalitiesClassesSync(query);
  }

  propertyCardinalitiesClassesSync(
    query?: $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
  ): purify.Either<Error, readonly PropertyCardinalitiesClass[]> {
    return this.$objectsSync<
      PropertyCardinalitiesClass,
      PropertyCardinalitiesClass.$Identifier
    >(
      [{ $fromRdf: PropertyCardinalitiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async propertyCardinalitiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.propertyCardinalitiesClassesCountSync(query);
  }

  propertyCardinalitiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PropertyCardinalitiesClass,
      PropertyCardinalitiesClass.$Identifier
    >(
      [{ $fromRdf: PropertyCardinalitiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async propertyVisibilitiesClass(
    identifier: PropertyVisibilitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyVisibilitiesClass>> {
    return this.propertyVisibilitiesClassSync(identifier);
  }

  propertyVisibilitiesClassSync(
    identifier: PropertyVisibilitiesClass.$Identifier,
  ): purify.Either<Error, PropertyVisibilitiesClass> {
    return this.propertyVisibilitiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async propertyVisibilitiesClassIdentifiers(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PropertyVisibilitiesClass.$Identifier[]>
  > {
    return this.propertyVisibilitiesClassIdentifiersSync(query);
  }

  propertyVisibilitiesClassIdentifiersSync(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
  ): purify.Either<Error, readonly PropertyVisibilitiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      PropertyVisibilitiesClass,
      PropertyVisibilitiesClass.$Identifier
    >(
      [{ $fromRdf: PropertyVisibilitiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async propertyVisibilitiesClasses(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PropertyVisibilitiesClass[]>> {
    return this.propertyVisibilitiesClassesSync(query);
  }

  propertyVisibilitiesClassesSync(
    query?: $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
  ): purify.Either<Error, readonly PropertyVisibilitiesClass[]> {
    return this.$objectsSync<
      PropertyVisibilitiesClass,
      PropertyVisibilitiesClass.$Identifier
    >(
      [{ $fromRdf: PropertyVisibilitiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async propertyVisibilitiesClassesCount(
    query?: Pick<
      $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.propertyVisibilitiesClassesCountSync(query);
  }

  propertyVisibilitiesClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PropertyVisibilitiesClass,
      PropertyVisibilitiesClass.$Identifier
    >(
      [{ $fromRdf: PropertyVisibilitiesClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async recursiveClassUnionMember1(
    identifier: RecursiveClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember1>> {
    return this.recursiveClassUnionMember1Sync(identifier);
  }

  recursiveClassUnionMember1Sync(
    identifier: RecursiveClassUnionMember1.$Identifier,
  ): purify.Either<Error, RecursiveClassUnionMember1> {
    return this.recursiveClassUnionMember1sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async recursiveClassUnionMember1Identifiers(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember1.$Identifier[]>
  > {
    return this.recursiveClassUnionMember1IdentifiersSync(query);
  }

  recursiveClassUnionMember1IdentifiersSync(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly RecursiveClassUnionMember1.$Identifier[]> {
    return this.$objectIdentifiersSync<
      RecursiveClassUnionMember1,
      RecursiveClassUnionMember1.$Identifier
    >(
      [{ $fromRdf: RecursiveClassUnionMember1.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async recursiveClassUnionMember1s(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember1[]>> {
    return this.recursiveClassUnionMember1sSync(query);
  }

  recursiveClassUnionMember1sSync(
    query?: $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
  ): purify.Either<Error, readonly RecursiveClassUnionMember1[]> {
    return this.$objectsSync<
      RecursiveClassUnionMember1,
      RecursiveClassUnionMember1.$Identifier
    >(
      [{ $fromRdf: RecursiveClassUnionMember1.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async recursiveClassUnionMember1sCount(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.recursiveClassUnionMember1sCountSync(query);
  }

  recursiveClassUnionMember1sCountSync(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      RecursiveClassUnionMember1,
      RecursiveClassUnionMember1.$Identifier
    >(
      [{ $fromRdf: RecursiveClassUnionMember1.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async recursiveClassUnionMember2(
    identifier: RecursiveClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember2>> {
    return this.recursiveClassUnionMember2Sync(identifier);
  }

  recursiveClassUnionMember2Sync(
    identifier: RecursiveClassUnionMember2.$Identifier,
  ): purify.Either<Error, RecursiveClassUnionMember2> {
    return this.recursiveClassUnionMember2sSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async recursiveClassUnionMember2Identifiers(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember2.$Identifier[]>
  > {
    return this.recursiveClassUnionMember2IdentifiersSync(query);
  }

  recursiveClassUnionMember2IdentifiersSync(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly RecursiveClassUnionMember2.$Identifier[]> {
    return this.$objectIdentifiersSync<
      RecursiveClassUnionMember2,
      RecursiveClassUnionMember2.$Identifier
    >(
      [{ $fromRdf: RecursiveClassUnionMember2.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async recursiveClassUnionMember2s(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember2[]>> {
    return this.recursiveClassUnionMember2sSync(query);
  }

  recursiveClassUnionMember2sSync(
    query?: $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
  ): purify.Either<Error, readonly RecursiveClassUnionMember2[]> {
    return this.$objectsSync<
      RecursiveClassUnionMember2,
      RecursiveClassUnionMember2.$Identifier
    >(
      [{ $fromRdf: RecursiveClassUnionMember2.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async recursiveClassUnionMember2sCount(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.recursiveClassUnionMember2sCountSync(query);
  }

  recursiveClassUnionMember2sCountSync(
    query?: Pick<
      $ObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      RecursiveClassUnionMember2,
      RecursiveClassUnionMember2.$Identifier
    >(
      [{ $fromRdf: RecursiveClassUnionMember2.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async sha256IriIdentifierClass(
    identifier: Sha256IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, Sha256IriIdentifierClass>> {
    return this.sha256IriIdentifierClassSync(identifier);
  }

  sha256IriIdentifierClassSync(
    identifier: Sha256IriIdentifierClass.$Identifier,
  ): purify.Either<Error, Sha256IriIdentifierClass> {
    return this.sha256IriIdentifierClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async sha256IriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<Sha256IriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly Sha256IriIdentifierClass.$Identifier[]>
  > {
    return this.sha256IriIdentifierClassIdentifiersSync(query);
  }

  sha256IriIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<Sha256IriIdentifierClass.$Identifier>,
  ): purify.Either<Error, readonly Sha256IriIdentifierClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      Sha256IriIdentifierClass,
      Sha256IriIdentifierClass.$Identifier
    >(
      [{ $fromRdf: Sha256IriIdentifierClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async sha256IriIdentifierClasses(
    query?: $ObjectSet.Query<Sha256IriIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly Sha256IriIdentifierClass[]>> {
    return this.sha256IriIdentifierClassesSync(query);
  }

  sha256IriIdentifierClassesSync(
    query?: $ObjectSet.Query<Sha256IriIdentifierClass.$Identifier>,
  ): purify.Either<Error, readonly Sha256IriIdentifierClass[]> {
    return this.$objectsSync<
      Sha256IriIdentifierClass,
      Sha256IriIdentifierClass.$Identifier
    >(
      [{ $fromRdf: Sha256IriIdentifierClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async sha256IriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<Sha256IriIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.sha256IriIdentifierClassesCountSync(query);
  }

  sha256IriIdentifierClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<Sha256IriIdentifierClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      Sha256IriIdentifierClass,
      Sha256IriIdentifierClass.$Identifier
    >(
      [{ $fromRdf: Sha256IriIdentifierClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async termPropertiesClass(
    identifier: TermPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, TermPropertiesClass>> {
    return this.termPropertiesClassSync(identifier);
  }

  termPropertiesClassSync(
    identifier: TermPropertiesClass.$Identifier,
  ): purify.Either<Error, TermPropertiesClass> {
    return this.termPropertiesClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async termPropertiesClassIdentifiers(
    query?: $ObjectSet.Query<TermPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass.$Identifier[]>> {
    return this.termPropertiesClassIdentifiersSync(query);
  }

  termPropertiesClassIdentifiersSync(
    query?: $ObjectSet.Query<TermPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly TermPropertiesClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      TermPropertiesClass,
      TermPropertiesClass.$Identifier
    >([{ $fromRdf: TermPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async termPropertiesClasses(
    query?: $ObjectSet.Query<TermPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass[]>> {
    return this.termPropertiesClassesSync(query);
  }

  termPropertiesClassesSync(
    query?: $ObjectSet.Query<TermPropertiesClass.$Identifier>,
  ): purify.Either<Error, readonly TermPropertiesClass[]> {
    return this.$objectsSync<
      TermPropertiesClass,
      TermPropertiesClass.$Identifier
    >([{ $fromRdf: TermPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async termPropertiesClassesCount(
    query?: Pick<$ObjectSet.Query<TermPropertiesClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.termPropertiesClassesCountSync(query);
  }

  termPropertiesClassesCountSync(
    query?: Pick<$ObjectSet.Query<TermPropertiesClass.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      TermPropertiesClass,
      TermPropertiesClass.$Identifier
    >([{ $fromRdf: TermPropertiesClass.$fromRdf, $fromRdfTypes: [] }], query);
  }

  async unionDiscriminantsClass(
    identifier: UnionDiscriminantsClass.$Identifier,
  ): Promise<purify.Either<Error, UnionDiscriminantsClass>> {
    return this.unionDiscriminantsClassSync(identifier);
  }

  unionDiscriminantsClassSync(
    identifier: UnionDiscriminantsClass.$Identifier,
  ): purify.Either<Error, UnionDiscriminantsClass> {
    return this.unionDiscriminantsClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async unionDiscriminantsClassIdentifiers(
    query?: $ObjectSet.Query<UnionDiscriminantsClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly UnionDiscriminantsClass.$Identifier[]>
  > {
    return this.unionDiscriminantsClassIdentifiersSync(query);
  }

  unionDiscriminantsClassIdentifiersSync(
    query?: $ObjectSet.Query<UnionDiscriminantsClass.$Identifier>,
  ): purify.Either<Error, readonly UnionDiscriminantsClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      UnionDiscriminantsClass,
      UnionDiscriminantsClass.$Identifier
    >(
      [{ $fromRdf: UnionDiscriminantsClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async unionDiscriminantsClasses(
    query?: $ObjectSet.Query<UnionDiscriminantsClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly UnionDiscriminantsClass[]>> {
    return this.unionDiscriminantsClassesSync(query);
  }

  unionDiscriminantsClassesSync(
    query?: $ObjectSet.Query<UnionDiscriminantsClass.$Identifier>,
  ): purify.Either<Error, readonly UnionDiscriminantsClass[]> {
    return this.$objectsSync<
      UnionDiscriminantsClass,
      UnionDiscriminantsClass.$Identifier
    >(
      [{ $fromRdf: UnionDiscriminantsClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async unionDiscriminantsClassesCount(
    query?: Pick<
      $ObjectSet.Query<UnionDiscriminantsClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.unionDiscriminantsClassesCountSync(query);
  }

  unionDiscriminantsClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<UnionDiscriminantsClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      UnionDiscriminantsClass,
      UnionDiscriminantsClass.$Identifier
    >(
      [{ $fromRdf: UnionDiscriminantsClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async uuidV4IriIdentifierClass(
    identifier: UuidV4IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriIdentifierClass>> {
    return this.uuidV4IriIdentifierClassSync(identifier);
  }

  uuidV4IriIdentifierClassSync(
    identifier: UuidV4IriIdentifierClass.$Identifier,
  ): purify.Either<Error, UuidV4IriIdentifierClass> {
    return this.uuidV4IriIdentifierClassesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async uuidV4IriIdentifierClassIdentifiers(
    query?: $ObjectSet.Query<UuidV4IriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly UuidV4IriIdentifierClass.$Identifier[]>
  > {
    return this.uuidV4IriIdentifierClassIdentifiersSync(query);
  }

  uuidV4IriIdentifierClassIdentifiersSync(
    query?: $ObjectSet.Query<UuidV4IriIdentifierClass.$Identifier>,
  ): purify.Either<Error, readonly UuidV4IriIdentifierClass.$Identifier[]> {
    return this.$objectIdentifiersSync<
      UuidV4IriIdentifierClass,
      UuidV4IriIdentifierClass.$Identifier
    >(
      [{ $fromRdf: UuidV4IriIdentifierClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async uuidV4IriIdentifierClasses(
    query?: $ObjectSet.Query<UuidV4IriIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriIdentifierClass[]>> {
    return this.uuidV4IriIdentifierClassesSync(query);
  }

  uuidV4IriIdentifierClassesSync(
    query?: $ObjectSet.Query<UuidV4IriIdentifierClass.$Identifier>,
  ): purify.Either<Error, readonly UuidV4IriIdentifierClass[]> {
    return this.$objectsSync<
      UuidV4IriIdentifierClass,
      UuidV4IriIdentifierClass.$Identifier
    >(
      [{ $fromRdf: UuidV4IriIdentifierClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async uuidV4IriIdentifierClassesCount(
    query?: Pick<
      $ObjectSet.Query<UuidV4IriIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.uuidV4IriIdentifierClassesCountSync(query);
  }

  uuidV4IriIdentifierClassesCountSync(
    query?: Pick<
      $ObjectSet.Query<UuidV4IriIdentifierClass.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      UuidV4IriIdentifierClass,
      UuidV4IriIdentifierClass.$Identifier
    >(
      [{ $fromRdf: UuidV4IriIdentifierClass.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async uuidV4IriIdentifierInterface(
    identifier: UuidV4IriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriIdentifierInterface>> {
    return this.uuidV4IriIdentifierInterfaceSync(identifier);
  }

  uuidV4IriIdentifierInterfaceSync(
    identifier: UuidV4IriIdentifierInterface.$Identifier,
  ): purify.Either<Error, UuidV4IriIdentifierInterface> {
    return this.uuidV4IriIdentifierInterfacesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async uuidV4IriIdentifierInterfaceIdentifiers(
    query?: $ObjectSet.Query<UuidV4IriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly UuidV4IriIdentifierInterface.$Identifier[]>
  > {
    return this.uuidV4IriIdentifierInterfaceIdentifiersSync(query);
  }

  uuidV4IriIdentifierInterfaceIdentifiersSync(
    query?: $ObjectSet.Query<UuidV4IriIdentifierInterface.$Identifier>,
  ): purify.Either<Error, readonly UuidV4IriIdentifierInterface.$Identifier[]> {
    return this.$objectIdentifiersSync<
      UuidV4IriIdentifierInterface,
      UuidV4IriIdentifierInterface.$Identifier
    >(
      [{ $fromRdf: UuidV4IriIdentifierInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async uuidV4IriIdentifierInterfaces(
    query?: $ObjectSet.Query<UuidV4IriIdentifierInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriIdentifierInterface[]>> {
    return this.uuidV4IriIdentifierInterfacesSync(query);
  }

  uuidV4IriIdentifierInterfacesSync(
    query?: $ObjectSet.Query<UuidV4IriIdentifierInterface.$Identifier>,
  ): purify.Either<Error, readonly UuidV4IriIdentifierInterface[]> {
    return this.$objectsSync<
      UuidV4IriIdentifierInterface,
      UuidV4IriIdentifierInterface.$Identifier
    >(
      [{ $fromRdf: UuidV4IriIdentifierInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async uuidV4IriIdentifierInterfacesCount(
    query?: Pick<
      $ObjectSet.Query<UuidV4IriIdentifierInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.uuidV4IriIdentifierInterfacesCountSync(query);
  }

  uuidV4IriIdentifierInterfacesCountSync(
    query?: Pick<
      $ObjectSet.Query<UuidV4IriIdentifierInterface.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      UuidV4IriIdentifierInterface,
      UuidV4IriIdentifierInterface.$Identifier
    >(
      [{ $fromRdf: UuidV4IriIdentifierInterface.$fromRdf, $fromRdfTypes: [] }],
      query,
    );
  }

  async classUnion(
    identifier: ClassUnion.$Identifier,
  ): Promise<purify.Either<Error, ClassUnion>> {
    return this.classUnionSync(identifier);
  }

  classUnionSync(
    identifier: ClassUnion.$Identifier,
  ): purify.Either<Error, ClassUnion> {
    return this.classUnionsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async classUnionIdentifiers(
    query?: $ObjectSet.Query<ClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnion.$Identifier[]>> {
    return this.classUnionIdentifiersSync(query);
  }

  classUnionIdentifiersSync(
    query?: $ObjectSet.Query<ClassUnion.$Identifier>,
  ): purify.Either<Error, readonly ClassUnion.$Identifier[]> {
    return this.$objectIdentifiersSync<ClassUnion, ClassUnion.$Identifier>(
      [
        {
          $fromRdf: ClassUnionMember1.$fromRdf,
          $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: ClassUnionMember2.$fromRdf,
          $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async classUnions(
    query?: $ObjectSet.Query<ClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnion[]>> {
    return this.classUnionsSync(query);
  }

  classUnionsSync(
    query?: $ObjectSet.Query<ClassUnion.$Identifier>,
  ): purify.Either<Error, readonly ClassUnion[]> {
    return this.$objectsSync<ClassUnion, ClassUnion.$Identifier>(
      [
        {
          $fromRdf: ClassUnionMember1.$fromRdf,
          $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: ClassUnionMember2.$fromRdf,
          $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async classUnionsCount(
    query?: Pick<$ObjectSet.Query<ClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.classUnionsCountSync(query);
  }

  classUnionsCountSync(
    query?: Pick<$ObjectSet.Query<ClassUnion.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<ClassUnion, ClassUnion.$Identifier>(
      [
        {
          $fromRdf: ClassUnionMember1.$fromRdf,
          $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: ClassUnionMember2.$fromRdf,
          $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async flattenClassUnion(
    identifier: FlattenClassUnion.$Identifier,
  ): Promise<purify.Either<Error, FlattenClassUnion>> {
    return this.flattenClassUnionSync(identifier);
  }

  flattenClassUnionSync(
    identifier: FlattenClassUnion.$Identifier,
  ): purify.Either<Error, FlattenClassUnion> {
    return this.flattenClassUnionsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async flattenClassUnionIdentifiers(
    query?: $ObjectSet.Query<FlattenClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnion.$Identifier[]>> {
    return this.flattenClassUnionIdentifiersSync(query);
  }

  flattenClassUnionIdentifiersSync(
    query?: $ObjectSet.Query<FlattenClassUnion.$Identifier>,
  ): purify.Either<Error, readonly FlattenClassUnion.$Identifier[]> {
    return this.$objectIdentifiersSync<
      FlattenClassUnion,
      FlattenClassUnion.$Identifier
    >(
      [
        {
          $fromRdf: ClassUnionMember1.$fromRdf,
          $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: ClassUnionMember2.$fromRdf,
          $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
        },
        {
          $fromRdf: FlattenClassUnionMember3.$fromRdf,
          $fromRdfTypes: [FlattenClassUnionMember3.$fromRdfType],
        },
      ],
      query,
    );
  }

  async flattenClassUnions(
    query?: $ObjectSet.Query<FlattenClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnion[]>> {
    return this.flattenClassUnionsSync(query);
  }

  flattenClassUnionsSync(
    query?: $ObjectSet.Query<FlattenClassUnion.$Identifier>,
  ): purify.Either<Error, readonly FlattenClassUnion[]> {
    return this.$objectsSync<FlattenClassUnion, FlattenClassUnion.$Identifier>(
      [
        {
          $fromRdf: ClassUnionMember1.$fromRdf,
          $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: ClassUnionMember2.$fromRdf,
          $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
        },
        {
          $fromRdf: FlattenClassUnionMember3.$fromRdf,
          $fromRdfTypes: [FlattenClassUnionMember3.$fromRdfType],
        },
      ],
      query,
    );
  }

  async flattenClassUnionsCount(
    query?: Pick<$ObjectSet.Query<FlattenClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.flattenClassUnionsCountSync(query);
  }

  flattenClassUnionsCountSync(
    query?: Pick<$ObjectSet.Query<FlattenClassUnion.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      FlattenClassUnion,
      FlattenClassUnion.$Identifier
    >(
      [
        {
          $fromRdf: ClassUnionMember1.$fromRdf,
          $fromRdfTypes: [ClassUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: ClassUnionMember2.$fromRdf,
          $fromRdfTypes: [ClassUnionMember2.$fromRdfType],
        },
        {
          $fromRdf: FlattenClassUnionMember3.$fromRdf,
          $fromRdfTypes: [FlattenClassUnionMember3.$fromRdfType],
        },
      ],
      query,
    );
  }

  async interfaceUnion(
    identifier: InterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnion>> {
    return this.interfaceUnionSync(identifier);
  }

  interfaceUnionSync(
    identifier: InterfaceUnion.$Identifier,
  ): purify.Either<Error, InterfaceUnion> {
    return this.interfaceUnionsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async interfaceUnionIdentifiers(
    query?: $ObjectSet.Query<InterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion.$Identifier[]>> {
    return this.interfaceUnionIdentifiersSync(query);
  }

  interfaceUnionIdentifiersSync(
    query?: $ObjectSet.Query<InterfaceUnion.$Identifier>,
  ): purify.Either<Error, readonly InterfaceUnion.$Identifier[]> {
    return this.$objectIdentifiersSync<
      InterfaceUnion,
      InterfaceUnion.$Identifier
    >(
      [
        {
          $fromRdf: InterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [InterfaceUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: InterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [InterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async interfaceUnions(
    query?: $ObjectSet.Query<InterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion[]>> {
    return this.interfaceUnionsSync(query);
  }

  interfaceUnionsSync(
    query?: $ObjectSet.Query<InterfaceUnion.$Identifier>,
  ): purify.Either<Error, readonly InterfaceUnion[]> {
    return this.$objectsSync<InterfaceUnion, InterfaceUnion.$Identifier>(
      [
        {
          $fromRdf: InterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [InterfaceUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: InterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [InterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async interfaceUnionsCount(
    query?: Pick<$ObjectSet.Query<InterfaceUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.interfaceUnionsCountSync(query);
  }

  interfaceUnionsCountSync(
    query?: Pick<$ObjectSet.Query<InterfaceUnion.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<InterfaceUnion, InterfaceUnion.$Identifier>(
      [
        {
          $fromRdf: InterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [InterfaceUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: InterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [InterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedClassUnion(
    identifier: LazilyResolvedClassUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnion>> {
    return this.lazilyResolvedClassUnionSync(identifier);
  }

  lazilyResolvedClassUnionSync(
    identifier: LazilyResolvedClassUnion.$Identifier,
  ): purify.Either<Error, LazilyResolvedClassUnion> {
    return this.lazilyResolvedClassUnionsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnion.$Identifier[]>
  > {
    return this.lazilyResolvedClassUnionIdentifiersSync(query);
  }

  lazilyResolvedClassUnionIdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedClassUnion.$Identifier[]> {
    return this.$objectIdentifiersSync<
      LazilyResolvedClassUnion,
      LazilyResolvedClassUnion.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedClassUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: LazilyResolvedClassUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedClassUnions(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnion[]>> {
    return this.lazilyResolvedClassUnionsSync(query);
  }

  lazilyResolvedClassUnionsSync(
    query?: $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedClassUnion[]> {
    return this.$objectsSync<
      LazilyResolvedClassUnion,
      LazilyResolvedClassUnion.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedClassUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: LazilyResolvedClassUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedClassUnionsCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedClassUnionsCountSync(query);
  }

  lazilyResolvedClassUnionsCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazilyResolvedClassUnion,
      LazilyResolvedClassUnion.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedClassUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: LazilyResolvedClassUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedInterfaceUnion(
    identifier: LazilyResolvedInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnion>> {
    return this.lazilyResolvedInterfaceUnionSync(identifier);
  }

  lazilyResolvedInterfaceUnionSync(
    identifier: LazilyResolvedInterfaceUnion.$Identifier,
  ): purify.Either<Error, LazilyResolvedInterfaceUnion> {
    return this.lazilyResolvedInterfaceUnionsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnion.$Identifier[]>
  > {
    return this.lazilyResolvedInterfaceUnionIdentifiersSync(query);
  }

  lazilyResolvedInterfaceUnionIdentifiersSync(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedInterfaceUnion.$Identifier[]> {
    return this.$objectIdentifiersSync<
      LazilyResolvedInterfaceUnion,
      LazilyResolvedInterfaceUnion.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedInterfaceUnions(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedInterfaceUnion[]>> {
    return this.lazilyResolvedInterfaceUnionsSync(query);
  }

  lazilyResolvedInterfaceUnionsSync(
    query?: $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
  ): purify.Either<Error, readonly LazilyResolvedInterfaceUnion[]> {
    return this.$objectsSync<
      LazilyResolvedInterfaceUnion,
      LazilyResolvedInterfaceUnion.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async lazilyResolvedInterfaceUnionsCount(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.lazilyResolvedInterfaceUnionsCountSync(query);
  }

  lazilyResolvedInterfaceUnionsCountSync(
    query?: Pick<
      $ObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      LazilyResolvedInterfaceUnion,
      LazilyResolvedInterfaceUnion.$Identifier
    >(
      [
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: LazilyResolvedInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [LazilyResolvedInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async noRdfTypeClassUnion(
    identifier: NoRdfTypeClassUnion.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnion>> {
    return this.noRdfTypeClassUnionSync(identifier);
  }

  noRdfTypeClassUnionSync(
    identifier: NoRdfTypeClassUnion.$Identifier,
  ): purify.Either<Error, NoRdfTypeClassUnion> {
    return this.noRdfTypeClassUnionsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async noRdfTypeClassUnionIdentifiers(
    query?: $ObjectSet.Query<NoRdfTypeClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnion.$Identifier[]>> {
    return this.noRdfTypeClassUnionIdentifiersSync(query);
  }

  noRdfTypeClassUnionIdentifiersSync(
    query?: $ObjectSet.Query<NoRdfTypeClassUnion.$Identifier>,
  ): purify.Either<Error, readonly NoRdfTypeClassUnion.$Identifier[]> {
    return this.$objectIdentifiersSync<
      NoRdfTypeClassUnion,
      NoRdfTypeClassUnion.$Identifier
    >(
      [
        { $fromRdf: NoRdfTypeClassUnionMember1.$fromRdf, $fromRdfTypes: [] },
        { $fromRdf: NoRdfTypeClassUnionMember2.$fromRdf, $fromRdfTypes: [] },
      ],
      query,
    );
  }

  async noRdfTypeClassUnions(
    query?: $ObjectSet.Query<NoRdfTypeClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnion[]>> {
    return this.noRdfTypeClassUnionsSync(query);
  }

  noRdfTypeClassUnionsSync(
    query?: $ObjectSet.Query<NoRdfTypeClassUnion.$Identifier>,
  ): purify.Either<Error, readonly NoRdfTypeClassUnion[]> {
    return this.$objectsSync<
      NoRdfTypeClassUnion,
      NoRdfTypeClassUnion.$Identifier
    >(
      [
        { $fromRdf: NoRdfTypeClassUnionMember1.$fromRdf, $fromRdfTypes: [] },
        { $fromRdf: NoRdfTypeClassUnionMember2.$fromRdf, $fromRdfTypes: [] },
      ],
      query,
    );
  }

  async noRdfTypeClassUnionsCount(
    query?: Pick<$ObjectSet.Query<NoRdfTypeClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.noRdfTypeClassUnionsCountSync(query);
  }

  noRdfTypeClassUnionsCountSync(
    query?: Pick<$ObjectSet.Query<NoRdfTypeClassUnion.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      NoRdfTypeClassUnion,
      NoRdfTypeClassUnion.$Identifier
    >(
      [
        { $fromRdf: NoRdfTypeClassUnionMember1.$fromRdf, $fromRdfTypes: [] },
        { $fromRdf: NoRdfTypeClassUnionMember2.$fromRdf, $fromRdfTypes: [] },
      ],
      query,
    );
  }

  async partialClassUnion(
    identifier: PartialClassUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnion>> {
    return this.partialClassUnionSync(identifier);
  }

  partialClassUnionSync(
    identifier: PartialClassUnion.$Identifier,
  ): purify.Either<Error, PartialClassUnion> {
    return this.partialClassUnionsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async partialClassUnionIdentifiers(
    query?: $ObjectSet.Query<PartialClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion.$Identifier[]>> {
    return this.partialClassUnionIdentifiersSync(query);
  }

  partialClassUnionIdentifiersSync(
    query?: $ObjectSet.Query<PartialClassUnion.$Identifier>,
  ): purify.Either<Error, readonly PartialClassUnion.$Identifier[]> {
    return this.$objectIdentifiersSync<
      PartialClassUnion,
      PartialClassUnion.$Identifier
    >(
      [
        {
          $fromRdf: PartialClassUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: PartialClassUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialClassUnions(
    query?: $ObjectSet.Query<PartialClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion[]>> {
    return this.partialClassUnionsSync(query);
  }

  partialClassUnionsSync(
    query?: $ObjectSet.Query<PartialClassUnion.$Identifier>,
  ): purify.Either<Error, readonly PartialClassUnion[]> {
    return this.$objectsSync<PartialClassUnion, PartialClassUnion.$Identifier>(
      [
        {
          $fromRdf: PartialClassUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: PartialClassUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialClassUnionsCount(
    query?: Pick<$ObjectSet.Query<PartialClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.partialClassUnionsCountSync(query);
  }

  partialClassUnionsCountSync(
    query?: Pick<$ObjectSet.Query<PartialClassUnion.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PartialClassUnion,
      PartialClassUnion.$Identifier
    >(
      [
        {
          $fromRdf: PartialClassUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: PartialClassUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialClassUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialInterfaceUnion(
    identifier: PartialInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnion>> {
    return this.partialInterfaceUnionSync(identifier);
  }

  partialInterfaceUnionSync(
    identifier: PartialInterfaceUnion.$Identifier,
  ): purify.Either<Error, PartialInterfaceUnion> {
    return this.partialInterfaceUnionsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async partialInterfaceUnionIdentifiers(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnion.$Identifier[]>
  > {
    return this.partialInterfaceUnionIdentifiersSync(query);
  }

  partialInterfaceUnionIdentifiersSync(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Identifier>,
  ): purify.Either<Error, readonly PartialInterfaceUnion.$Identifier[]> {
    return this.$objectIdentifiersSync<
      PartialInterfaceUnion,
      PartialInterfaceUnion.$Identifier
    >(
      [
        {
          $fromRdf: PartialInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: PartialInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialInterfaceUnions(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnion[]>> {
    return this.partialInterfaceUnionsSync(query);
  }

  partialInterfaceUnionsSync(
    query?: $ObjectSet.Query<PartialInterfaceUnion.$Identifier>,
  ): purify.Either<Error, readonly PartialInterfaceUnion[]> {
    return this.$objectsSync<
      PartialInterfaceUnion,
      PartialInterfaceUnion.$Identifier
    >(
      [
        {
          $fromRdf: PartialInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: PartialInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async partialInterfaceUnionsCount(
    query?: Pick<$ObjectSet.Query<PartialInterfaceUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.partialInterfaceUnionsCountSync(query);
  }

  partialInterfaceUnionsCountSync(
    query?: Pick<$ObjectSet.Query<PartialInterfaceUnion.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PartialInterfaceUnion,
      PartialInterfaceUnion.$Identifier
    >(
      [
        {
          $fromRdf: PartialInterfaceUnionMember1.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember1.$fromRdfType],
        },
        {
          $fromRdf: PartialInterfaceUnionMember2.$fromRdf,
          $fromRdfTypes: [PartialInterfaceUnionMember2.$fromRdfType],
        },
      ],
      query,
    );
  }

  async recursiveClassUnion(
    identifier: RecursiveClassUnion.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnion>> {
    return this.recursiveClassUnionSync(identifier);
  }

  recursiveClassUnionSync(
    identifier: RecursiveClassUnion.$Identifier,
  ): purify.Either<Error, RecursiveClassUnion> {
    return this.recursiveClassUnionsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    }).map((objects) => objects[0]);
  }

  async recursiveClassUnionIdentifiers(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion.$Identifier[]>> {
    return this.recursiveClassUnionIdentifiersSync(query);
  }

  recursiveClassUnionIdentifiersSync(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Identifier>,
  ): purify.Either<Error, readonly RecursiveClassUnion.$Identifier[]> {
    return this.$objectIdentifiersSync<
      RecursiveClassUnion,
      RecursiveClassUnion.$Identifier
    >(
      [
        { $fromRdf: RecursiveClassUnionMember1.$fromRdf, $fromRdfTypes: [] },
        { $fromRdf: RecursiveClassUnionMember2.$fromRdf, $fromRdfTypes: [] },
      ],
      query,
    );
  }

  async recursiveClassUnions(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion[]>> {
    return this.recursiveClassUnionsSync(query);
  }

  recursiveClassUnionsSync(
    query?: $ObjectSet.Query<RecursiveClassUnion.$Identifier>,
  ): purify.Either<Error, readonly RecursiveClassUnion[]> {
    return this.$objectsSync<
      RecursiveClassUnion,
      RecursiveClassUnion.$Identifier
    >(
      [
        { $fromRdf: RecursiveClassUnionMember1.$fromRdf, $fromRdfTypes: [] },
        { $fromRdf: RecursiveClassUnionMember2.$fromRdf, $fromRdfTypes: [] },
      ],
      query,
    );
  }

  async recursiveClassUnionsCount(
    query?: Pick<$ObjectSet.Query<RecursiveClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.recursiveClassUnionsCountSync(query);
  }

  recursiveClassUnionsCountSync(
    query?: Pick<$ObjectSet.Query<RecursiveClassUnion.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      RecursiveClassUnion,
      RecursiveClassUnion.$Identifier
    >(
      [
        { $fromRdf: RecursiveClassUnionMember1.$fromRdf, $fromRdfTypes: [] },
        { $fromRdf: RecursiveClassUnionMember2.$fromRdf, $fromRdfTypes: [] },
      ],
      query,
    );
  }

  protected $objectIdentifiersSync<
    ObjectT extends { readonly $identifier: ObjectIdentifierT },
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectTypes: readonly {
      $fromRdf: (
        resource: rdfjsResource.Resource,
        options: { objectSet: $ObjectSet },
      ) => purify.Either<Error, ObjectT>;
      $fromRdfTypes: readonly rdfjs.NamedNode[];
    }[],
    query?: $ObjectSet.Query<ObjectIdentifierT>,
  ): purify.Either<Error, readonly ObjectIdentifierT[]> {
    return this.$objectsSync<ObjectT, ObjectIdentifierT>(
      objectTypes,
      query,
    ).map((objects) => objects.map((object) => object.$identifier));
  }

  protected $objectsSync<
    ObjectT extends { readonly $identifier: ObjectIdentifierT },
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectTypes: readonly {
      $fromRdf: (
        resource: rdfjsResource.Resource,
        options: { objectSet: $ObjectSet },
      ) => purify.Either<Error, ObjectT>;
      $fromRdfTypes: readonly rdfjs.NamedNode[];
    }[],
    query?: $ObjectSet.Query<ObjectIdentifierT>,
  ): purify.Either<Error, readonly ObjectT[]> {
    const limit = query?.limit ?? Number.MAX_SAFE_INTEGER;
    if (limit <= 0) {
      return purify.Either.of([]);
    }

    let offset = query?.offset ?? 0;
    if (offset < 0) {
      offset = 0;
    }

    // First pass: gather all resources that meet the where filters.
    // We don't limit + offset here because the resources aren't sorted and limit + offset should be deterministic.
    const resources: {
      object?: ObjectT;
      objectType?: {
        $fromRdf: (
          resource: rdfjsResource.Resource,
          options: { objectSet: $ObjectSet },
        ) => purify.Either<Error, ObjectT>;
        $fromRdfTypes: readonly rdfjs.NamedNode[];
      };
      resource: rdfjsResource.Resource;
    }[] = [];
    const where = query?.where ?? { type: "type" };
    switch (where.type) {
      case "identifiers": {
        for (const identifier of where.identifiers) {
          // Don't deduplicate
          resources.push({ resource: this.resourceSet.resource(identifier) });
        }
        break;
      }

      case "triple-objects": {
        for (const quad of this.resourceSet.dataset.match(
          where.subject,
          where.predicate,
          null,
        )) {
          if (
            where.objectTermType &&
            quad.object.termType !== where.objectTermType
          ) {
            continue;
          }

          switch (quad.object.termType) {
            case "BlankNode":
            case "NamedNode":
              break;
            default:
              return purify.Left(
                new Error(
                  `subject=${where.subject?.value} predicate=${where.predicate.value} pattern matches non-identifier (${quad.object.termType}) object`,
                ),
              );
          }

          const resource = this.resourceSet.resource(quad.object);
          if (
            !resources.some(({ resource: existingResource }) =>
              existingResource.identifier.equals(resource.identifier),
            )
          ) {
            resources.push({ resource });
          }
        }
        break;
      }

      case "triple-subjects": {
        for (const quad of this.resourceSet.dataset.match(
          null,
          where.predicate,
          where.object,
        )) {
          if (
            where.subjectTermType &&
            quad.subject.termType !== where.subjectTermType
          ) {
            continue;
          }

          switch (quad.subject.termType) {
            case "BlankNode":
            case "NamedNode":
              break;
            default:
              return purify.Left(
                new Error(
                  `predicate=${where.predicate.value} object=${where.object?.value} pattern matches non-identifier (${quad.subject.termType}) subject`,
                ),
              );
          }

          const resource = this.resourceSet.resource(quad.subject);
          if (
            !resources.some(({ resource: existingResource }) =>
              existingResource.identifier.equals(resource.identifier),
            )
          ) {
            resources.push({ resource });
          }
        }
        break;
      }

      case "type": {
        for (const objectType of objectTypes) {
          if (objectType.$fromRdfTypes.length > 0) {
            for (const fromRdfType of objectType.$fromRdfTypes) {
              for (const resource of where.identifierType === "NamedNode"
                ? this.resourceSet.namedInstancesOf(fromRdfType)
                : this.resourceSet.instancesOf(fromRdfType)) {
                if (
                  !resources.some(({ resource: existingResource }) =>
                    existingResource.identifier.equals(resource.identifier),
                  )
                ) {
                  resources.push({ objectType, resource });
                }
              }
            }
          } else {
            // The objectType has no fromRdfType
            // Try to deserialize every resource in the dataset
            const blankNodeSubjects = new Set<string>();
            const namedNodeSubjects = new Set<string>();
            for (const quad of this.resourceSet.dataset) {
              let resource: rdfjsResource.Resource;
              switch (quad.subject.termType) {
                case "BlankNode": {
                  if (blankNodeSubjects.has(quad.subject.value)) {
                    continue;
                  }
                  resource = this.resourceSet.resource(quad.subject);
                  blankNodeSubjects.add(quad.subject.value);
                  break;
                }
                case "NamedNode": {
                  if (namedNodeSubjects.has(quad.subject.value)) {
                    continue;
                  }
                  resource = this.resourceSet.namedResource(quad.subject);
                  namedNodeSubjects.add(quad.subject.value);
                  break;
                }
                default:
                  continue;
              }
              objectType
                .$fromRdf(resource, { objectSet: this })
                .ifRight((object) => {
                  resources.push({ object, objectType, resource });
                });
            }
          }
        }

        break;
      }
    }

    // Sort resources by identifier so limit and offset are deterministic
    resources.sort((left, right) =>
      left.resource.identifier.value.localeCompare(
        right.resource.identifier.value,
      ),
    );

    let objectI = 0;
    const objects: ObjectT[] = [];
    for (let { object, objectType, resource } of resources) {
      if (object) {
        objects.push(object);
        continue;
      }

      let objectEither: purify.Either<Error, ObjectT>;
      if (objectType) {
        objectEither = objectType.$fromRdf(resource, { objectSet: this });
      } else {
        for (const tryObjectType of objectTypes) {
          objectEither = tryObjectType.$fromRdf(resource, { objectSet: this });
          if (objectEither.isRight()) {
            objectType = tryObjectType;
            break;
          }
        }
      }

      if (objectEither!.isLeft()) {
        // Doesn't appear to belong to any of the known object types, just assume the first
        return objectEither as unknown as purify.Either<
          Error,
          readonly ObjectT[]
        >;
      }
      object = objectEither!.unsafeCoerce();
      if (objectI++ >= offset) {
        objects.push(object);
        if (objects.length === limit) {
          return purify.Either.of(objects);
        }
      }
    }

    return purify.Either.of(objects);
  }

  protected $objectsCountSync<
    ObjectT extends { readonly $identifier: ObjectIdentifierT },
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectTypes: readonly {
      $fromRdf: (
        resource: rdfjsResource.Resource,
        options: { objectSet: $ObjectSet },
      ) => purify.Either<Error, ObjectT>;
      $fromRdfTypes: readonly rdfjs.NamedNode[];
    }[],
    query?: $ObjectSet.Query<ObjectIdentifierT>,
  ): purify.Either<Error, number> {
    return this.$objectsSync<ObjectT, ObjectIdentifierT>(
      objectTypes,
      query,
    ).map((objects) => objects.length);
  }
}

export class $SparqlObjectSet implements $ObjectSet {
  protected readonly $countVariable = dataFactory.variable!("count");
  protected readonly $objectVariable = dataFactory.variable!("object");
  protected readonly $sparqlClient: {
    queryBindings: (
      query: string,
    ) => Promise<
      readonly Record<
        string,
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
      >[]
    >;
    queryQuads: (query: string) => Promise<readonly rdfjs.Quad[]>;
  };
  protected readonly $sparqlGenerator = new sparqljs.Generator();

  constructor({
    sparqlClient,
  }: { sparqlClient: $SparqlObjectSet["$sparqlClient"] }) {
    this.$sparqlClient = sparqlClient;
  }

  async baseInterfaceWithoutProperties(
    identifier: BaseInterfaceWithoutPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithoutProperties>> {
    return (
      await this.baseInterfaceWithoutPropertieses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async baseInterfaceWithoutPropertiesIdentifiers(
    query?: $SparqlObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithoutPropertiesStatic.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<BaseInterfaceWithoutPropertiesStatic.$Identifier>(
      BaseInterfaceWithoutPropertiesStatic,
      query,
    );
  }

  async baseInterfaceWithoutPropertieses(
    query?: $SparqlObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithoutProperties[]>> {
    return this.$objects<
      BaseInterfaceWithoutProperties,
      BaseInterfaceWithoutPropertiesStatic.$Identifier
    >(BaseInterfaceWithoutPropertiesStatic, query);
  }

  async baseInterfaceWithoutPropertiesesCount(
    query?: Pick<
      $SparqlObjectSet.Query<BaseInterfaceWithoutPropertiesStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<BaseInterfaceWithoutPropertiesStatic.$Identifier>(
      BaseInterfaceWithoutPropertiesStatic,
      query,
    );
  }

  async baseInterfaceWithProperties(
    identifier: BaseInterfaceWithPropertiesStatic.$Identifier,
  ): Promise<purify.Either<Error, BaseInterfaceWithProperties>> {
    return (
      await this.baseInterfaceWithPropertieses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async baseInterfaceWithPropertiesIdentifiers(
    query?: $SparqlObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly BaseInterfaceWithPropertiesStatic.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<BaseInterfaceWithPropertiesStatic.$Identifier>(
      BaseInterfaceWithPropertiesStatic,
      query,
    );
  }

  async baseInterfaceWithPropertieses(
    query?: $SparqlObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly BaseInterfaceWithProperties[]>> {
    return this.$objects<
      BaseInterfaceWithProperties,
      BaseInterfaceWithPropertiesStatic.$Identifier
    >(BaseInterfaceWithPropertiesStatic, query);
  }

  async baseInterfaceWithPropertiesesCount(
    query?: Pick<
      $SparqlObjectSet.Query<BaseInterfaceWithPropertiesStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<BaseInterfaceWithPropertiesStatic.$Identifier>(
      BaseInterfaceWithPropertiesStatic,
      query,
    );
  }

  async blankNodeIdentifierClass(
    identifier: BlankNodeIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeIdentifierClass>> {
    return (
      await this.blankNodeIdentifierClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async blankNodeIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<BlankNodeIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeIdentifierClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<BlankNodeIdentifierClass.$Identifier>(
      BlankNodeIdentifierClass,
      query,
    );
  }

  async blankNodeIdentifierClasses(
    query?: $SparqlObjectSet.Query<BlankNodeIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankNodeIdentifierClass[]>> {
    return this.$objects<
      BlankNodeIdentifierClass,
      BlankNodeIdentifierClass.$Identifier
    >(BlankNodeIdentifierClass, query);
  }

  async blankNodeIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<BlankNodeIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<BlankNodeIdentifierClass.$Identifier>(
      BlankNodeIdentifierClass,
      query,
    );
  }

  async blankNodeIdentifierInterface(
    identifier: BlankNodeIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeIdentifierInterface>> {
    return (
      await this.blankNodeIdentifierInterfaces({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async blankNodeIdentifierInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<BlankNodeIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeIdentifierInterface.$Identifier[]>
  > {
    return this.$objectIdentifiers<BlankNodeIdentifierInterface.$Identifier>(
      BlankNodeIdentifierInterface,
      query,
    );
  }

  async blankNodeIdentifierInterfaces(
    query?: $SparqlObjectSet.Query<BlankNodeIdentifierInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankNodeIdentifierInterface[]>> {
    return this.$objects<
      BlankNodeIdentifierInterface,
      BlankNodeIdentifierInterface.$Identifier
    >(BlankNodeIdentifierInterface, query);
  }

  async blankNodeIdentifierInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<BlankNodeIdentifierInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<BlankNodeIdentifierInterface.$Identifier>(
      BlankNodeIdentifierInterface,
      query,
    );
  }

  async blankNodeOrIriIdentifierClass(
    identifier: BlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeOrIriIdentifierClass>> {
    return (
      await this.blankNodeOrIriIdentifierClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async blankNodeOrIriIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<BlankNodeOrIriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeOrIriIdentifierClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<BlankNodeOrIriIdentifierClass.$Identifier>(
      BlankNodeOrIriIdentifierClass,
      query,
    );
  }

  async blankNodeOrIriIdentifierClasses(
    query?: $SparqlObjectSet.Query<BlankNodeOrIriIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly BlankNodeOrIriIdentifierClass[]>> {
    return this.$objects<
      BlankNodeOrIriIdentifierClass,
      BlankNodeOrIriIdentifierClass.$Identifier
    >(BlankNodeOrIriIdentifierClass, query);
  }

  async blankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<BlankNodeOrIriIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<BlankNodeOrIriIdentifierClass.$Identifier>(
      BlankNodeOrIriIdentifierClass,
      query,
    );
  }

  async blankNodeOrIriIdentifierInterface(
    identifier: BlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, BlankNodeOrIriIdentifierInterface>> {
    return (
      await this.blankNodeOrIriIdentifierInterfaces({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async blankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly BlankNodeOrIriIdentifierInterface.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<BlankNodeOrIriIdentifierInterface.$Identifier>(
      BlankNodeOrIriIdentifierInterface,
      query,
    );
  }

  async blankNodeOrIriIdentifierInterfaces(
    query?: $SparqlObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BlankNodeOrIriIdentifierInterface[]>
  > {
    return this.$objects<
      BlankNodeOrIriIdentifierInterface,
      BlankNodeOrIriIdentifierInterface.$Identifier
    >(BlankNodeOrIriIdentifierInterface, query);
  }

  async blankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<BlankNodeOrIriIdentifierInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<BlankNodeOrIriIdentifierInterface.$Identifier>(
      BlankNodeOrIriIdentifierInterface,
      query,
    );
  }

  async classUnionMember1(
    identifier: ClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember1>> {
    return (
      await this.classUnionMember1s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async classUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<ClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1.$Identifier[]>> {
    return this.$objectIdentifiers<ClassUnionMember1.$Identifier>(
      ClassUnionMember1,
      query,
    );
  }

  async classUnionMember1s(
    query?: $SparqlObjectSet.Query<ClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember1[]>> {
    return this.$objects<ClassUnionMember1, ClassUnionMember1.$Identifier>(
      ClassUnionMember1,
      query,
    );
  }

  async classUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<ClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ClassUnionMember1.$Identifier>(
      ClassUnionMember1,
      query,
    );
  }

  async classUnionMember2(
    identifier: ClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, ClassUnionMember2>> {
    return (
      await this.classUnionMember2s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async classUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<ClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2.$Identifier[]>> {
    return this.$objectIdentifiers<ClassUnionMember2.$Identifier>(
      ClassUnionMember2,
      query,
    );
  }

  async classUnionMember2s(
    query?: $SparqlObjectSet.Query<ClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnionMember2[]>> {
    return this.$objects<ClassUnionMember2, ClassUnionMember2.$Identifier>(
      ClassUnionMember2,
      query,
    );
  }

  async classUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<ClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ClassUnionMember2.$Identifier>(
      ClassUnionMember2,
      query,
    );
  }

  async concreteChildClass(
    identifier: ConcreteChildClass.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildClass>> {
    return (
      await this.concreteChildClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async concreteChildClassIdentifiers(
    query?: $SparqlObjectSet.Query<ConcreteChildClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass.$Identifier[]>> {
    return this.$objectIdentifiers<ConcreteChildClass.$Identifier>(
      ConcreteChildClass,
      query,
    );
  }

  async concreteChildClasses(
    query?: $SparqlObjectSet.Query<ConcreteChildClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildClass[]>> {
    return this.$objects<ConcreteChildClass, ConcreteChildClass.$Identifier>(
      ConcreteChildClass,
      query,
    );
  }

  async concreteChildClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ConcreteChildClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ConcreteChildClass.$Identifier>(
      ConcreteChildClass,
      query,
    );
  }

  async concreteChildInterface(
    identifier: ConcreteChildInterface.$Identifier,
  ): Promise<purify.Either<Error, ConcreteChildInterface>> {
    return (
      await this.concreteChildInterfaces({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async concreteChildInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<ConcreteChildInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteChildInterface.$Identifier[]>
  > {
    return this.$objectIdentifiers<ConcreteChildInterface.$Identifier>(
      ConcreteChildInterface,
      query,
    );
  }

  async concreteChildInterfaces(
    query?: $SparqlObjectSet.Query<ConcreteChildInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteChildInterface[]>> {
    return this.$objects<
      ConcreteChildInterface,
      ConcreteChildInterface.$Identifier
    >(ConcreteChildInterface, query);
  }

  async concreteChildInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ConcreteChildInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ConcreteChildInterface.$Identifier>(
      ConcreteChildInterface,
      query,
    );
  }

  async concreteParentClass(
    identifier: ConcreteParentClassStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentClass>> {
    return (
      await this.concreteParentClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async concreteParentClassIdentifiers(
    query?: $SparqlObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentClassStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<ConcreteParentClassStatic.$Identifier>(
      ConcreteParentClassStatic,
      query,
    );
  }

  async concreteParentClasses(
    query?: $SparqlObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteParentClass[]>> {
    return this.$objects<
      ConcreteParentClass,
      ConcreteParentClassStatic.$Identifier
    >(ConcreteParentClassStatic, query);
  }

  async concreteParentClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ConcreteParentClassStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ConcreteParentClassStatic.$Identifier>(
      ConcreteParentClassStatic,
      query,
    );
  }

  async concreteParentInterface(
    identifier: ConcreteParentInterfaceStatic.$Identifier,
  ): Promise<purify.Either<Error, ConcreteParentInterface>> {
    return (
      await this.concreteParentInterfaces({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async concreteParentInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConcreteParentInterfaceStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<ConcreteParentInterfaceStatic.$Identifier>(
      ConcreteParentInterfaceStatic,
      query,
    );
  }

  async concreteParentInterfaces(
    query?: $SparqlObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConcreteParentInterface[]>> {
    return this.$objects<
      ConcreteParentInterface,
      ConcreteParentInterfaceStatic.$Identifier
    >(ConcreteParentInterfaceStatic, query);
  }

  async concreteParentInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ConcreteParentInterfaceStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ConcreteParentInterfaceStatic.$Identifier>(
      ConcreteParentInterfaceStatic,
      query,
    );
  }

  async convertibleTypePropertiesClass(
    identifier: ConvertibleTypePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ConvertibleTypePropertiesClass>> {
    return (
      await this.convertibleTypePropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async convertibleTypePropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ConvertibleTypePropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<ConvertibleTypePropertiesClass.$Identifier>(
      ConvertibleTypePropertiesClass,
      query,
    );
  }

  async convertibleTypePropertiesClasses(
    query?: $SparqlObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ConvertibleTypePropertiesClass[]>> {
    return this.$objects<
      ConvertibleTypePropertiesClass,
      ConvertibleTypePropertiesClass.$Identifier
    >(ConvertibleTypePropertiesClass, query);
  }

  async convertibleTypePropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ConvertibleTypePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ConvertibleTypePropertiesClass.$Identifier>(
      ConvertibleTypePropertiesClass,
      query,
    );
  }

  async dateUnionPropertiesClass(
    identifier: DateUnionPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, DateUnionPropertiesClass>> {
    return (
      await this.dateUnionPropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async dateUnionPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<DateUnionPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly DateUnionPropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<DateUnionPropertiesClass.$Identifier>(
      DateUnionPropertiesClass,
      query,
    );
  }

  async dateUnionPropertiesClasses(
    query?: $SparqlObjectSet.Query<DateUnionPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DateUnionPropertiesClass[]>> {
    return this.$objects<
      DateUnionPropertiesClass,
      DateUnionPropertiesClass.$Identifier
    >(DateUnionPropertiesClass, query);
  }

  async dateUnionPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<DateUnionPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<DateUnionPropertiesClass.$Identifier>(
      DateUnionPropertiesClass,
      query,
    );
  }

  async defaultValuePropertiesClass(
    identifier: DefaultValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, DefaultValuePropertiesClass>> {
    return (
      await this.defaultValuePropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async defaultValuePropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly DefaultValuePropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<DefaultValuePropertiesClass.$Identifier>(
      DefaultValuePropertiesClass,
      query,
    );
  }

  async defaultValuePropertiesClasses(
    query?: $SparqlObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DefaultValuePropertiesClass[]>> {
    return this.$objects<
      DefaultValuePropertiesClass,
      DefaultValuePropertiesClass.$Identifier
    >(DefaultValuePropertiesClass, query);
  }

  async defaultValuePropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<DefaultValuePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<DefaultValuePropertiesClass.$Identifier>(
      DefaultValuePropertiesClass,
      query,
    );
  }

  async directRecursiveClass(
    identifier: DirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, DirectRecursiveClass>> {
    return (
      await this.directRecursiveClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async directRecursiveClassIdentifiers(
    query?: $SparqlObjectSet.Query<DirectRecursiveClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly DirectRecursiveClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<DirectRecursiveClass.$Identifier>(
      DirectRecursiveClass,
      query,
    );
  }

  async directRecursiveClasses(
    query?: $SparqlObjectSet.Query<DirectRecursiveClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly DirectRecursiveClass[]>> {
    return this.$objects<
      DirectRecursiveClass,
      DirectRecursiveClass.$Identifier
    >(DirectRecursiveClass, query);
  }

  async directRecursiveClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<DirectRecursiveClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<DirectRecursiveClass.$Identifier>(
      DirectRecursiveClass,
      query,
    );
  }

  async explicitFromToRdfTypesClass(
    identifier: ExplicitFromToRdfTypesClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitFromToRdfTypesClass>> {
    return (
      await this.explicitFromToRdfTypesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async explicitFromToRdfTypesClassIdentifiers(
    query?: $SparqlObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExplicitFromToRdfTypesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<ExplicitFromToRdfTypesClass.$Identifier>(
      ExplicitFromToRdfTypesClass,
      query,
    );
  }

  async explicitFromToRdfTypesClasses(
    query?: $SparqlObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExplicitFromToRdfTypesClass[]>> {
    return this.$objects<
      ExplicitFromToRdfTypesClass,
      ExplicitFromToRdfTypesClass.$Identifier
    >(ExplicitFromToRdfTypesClass, query);
  }

  async explicitFromToRdfTypesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ExplicitFromToRdfTypesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ExplicitFromToRdfTypesClass.$Identifier>(
      ExplicitFromToRdfTypesClass,
      query,
    );
  }

  async explicitRdfTypeClass(
    identifier: ExplicitRdfTypeClass.$Identifier,
  ): Promise<purify.Either<Error, ExplicitRdfTypeClass>> {
    return (
      await this.explicitRdfTypeClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async explicitRdfTypeClassIdentifiers(
    query?: $SparqlObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExplicitRdfTypeClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<ExplicitRdfTypeClass.$Identifier>(
      ExplicitRdfTypeClass,
      query,
    );
  }

  async explicitRdfTypeClasses(
    query?: $SparqlObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExplicitRdfTypeClass[]>> {
    return this.$objects<
      ExplicitRdfTypeClass,
      ExplicitRdfTypeClass.$Identifier
    >(ExplicitRdfTypeClass, query);
  }

  async explicitRdfTypeClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ExplicitRdfTypeClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ExplicitRdfTypeClass.$Identifier>(
      ExplicitRdfTypeClass,
      query,
    );
  }

  async externClassPropertyClass(
    identifier: ExternClassPropertyClass.$Identifier,
  ): Promise<purify.Either<Error, ExternClassPropertyClass>> {
    return (
      await this.externClassPropertyClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async externClassPropertyClassIdentifiers(
    query?: $SparqlObjectSet.Query<ExternClassPropertyClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ExternClassPropertyClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<ExternClassPropertyClass.$Identifier>(
      ExternClassPropertyClass,
      query,
    );
  }

  async externClassPropertyClasses(
    query?: $SparqlObjectSet.Query<ExternClassPropertyClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ExternClassPropertyClass[]>> {
    return this.$objects<
      ExternClassPropertyClass,
      ExternClassPropertyClass.$Identifier
    >(ExternClassPropertyClass, query);
  }

  async externClassPropertyClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ExternClassPropertyClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ExternClassPropertyClass.$Identifier>(
      ExternClassPropertyClass,
      query,
    );
  }

  async flattenClassUnionMember3(
    identifier: FlattenClassUnionMember3.$Identifier,
  ): Promise<purify.Either<Error, FlattenClassUnionMember3>> {
    return (
      await this.flattenClassUnionMember3s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async flattenClassUnionMember3Identifiers(
    query?: $SparqlObjectSet.Query<FlattenClassUnionMember3.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly FlattenClassUnionMember3.$Identifier[]>
  > {
    return this.$objectIdentifiers<FlattenClassUnionMember3.$Identifier>(
      FlattenClassUnionMember3,
      query,
    );
  }

  async flattenClassUnionMember3s(
    query?: $SparqlObjectSet.Query<FlattenClassUnionMember3.$Identifier>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnionMember3[]>> {
    return this.$objects<
      FlattenClassUnionMember3,
      FlattenClassUnionMember3.$Identifier
    >(FlattenClassUnionMember3, query);
  }

  async flattenClassUnionMember3sCount(
    query?: Pick<
      $SparqlObjectSet.Query<FlattenClassUnionMember3.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<FlattenClassUnionMember3.$Identifier>(
      FlattenClassUnionMember3,
      query,
    );
  }

  async hasValuePropertiesClass(
    identifier: HasValuePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, HasValuePropertiesClass>> {
    return (
      await this.hasValuePropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async hasValuePropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<HasValuePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly HasValuePropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<HasValuePropertiesClass.$Identifier>(
      HasValuePropertiesClass,
      query,
    );
  }

  async hasValuePropertiesClasses(
    query?: $SparqlObjectSet.Query<HasValuePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly HasValuePropertiesClass[]>> {
    return this.$objects<
      HasValuePropertiesClass,
      HasValuePropertiesClass.$Identifier
    >(HasValuePropertiesClass, query);
  }

  async hasValuePropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<HasValuePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<HasValuePropertiesClass.$Identifier>(
      HasValuePropertiesClass,
      query,
    );
  }

  async identifierOverride3Class(
    identifier: IdentifierOverride3ClassStatic.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride3Class>> {
    return (
      await this.identifierOverride3Classes({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async identifierOverride3ClassIdentifiers(
    query?: $SparqlObjectSet.Query<IdentifierOverride3ClassStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride3ClassStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<IdentifierOverride3ClassStatic.$Identifier>(
      IdentifierOverride3ClassStatic,
      query,
    );
  }

  async identifierOverride3Classes(
    query?: $SparqlObjectSet.Query<IdentifierOverride3ClassStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride3Class[]>> {
    return this.$objects<
      IdentifierOverride3Class,
      IdentifierOverride3ClassStatic.$Identifier
    >(IdentifierOverride3ClassStatic, query);
  }

  async identifierOverride3ClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<IdentifierOverride3ClassStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<IdentifierOverride3ClassStatic.$Identifier>(
      IdentifierOverride3ClassStatic,
      query,
    );
  }

  async identifierOverride4Class(
    identifier: IdentifierOverride4ClassStatic.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride4Class>> {
    return (
      await this.identifierOverride4Classes({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async identifierOverride4ClassIdentifiers(
    query?: $SparqlObjectSet.Query<IdentifierOverride4ClassStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride4ClassStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<IdentifierOverride4ClassStatic.$Identifier>(
      IdentifierOverride4ClassStatic,
      query,
    );
  }

  async identifierOverride4Classes(
    query?: $SparqlObjectSet.Query<IdentifierOverride4ClassStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride4Class[]>> {
    return this.$objects<
      IdentifierOverride4Class,
      IdentifierOverride4ClassStatic.$Identifier
    >(IdentifierOverride4ClassStatic, query);
  }

  async identifierOverride4ClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<IdentifierOverride4ClassStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<IdentifierOverride4ClassStatic.$Identifier>(
      IdentifierOverride4ClassStatic,
      query,
    );
  }

  async identifierOverride5Class(
    identifier: IdentifierOverride5Class.$Identifier,
  ): Promise<purify.Either<Error, IdentifierOverride5Class>> {
    return (
      await this.identifierOverride5Classes({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async identifierOverride5ClassIdentifiers(
    query?: $SparqlObjectSet.Query<IdentifierOverride5Class.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IdentifierOverride5Class.$Identifier[]>
  > {
    return this.$objectIdentifiers<IdentifierOverride5Class.$Identifier>(
      IdentifierOverride5Class,
      query,
    );
  }

  async identifierOverride5Classes(
    query?: $SparqlObjectSet.Query<IdentifierOverride5Class.$Identifier>,
  ): Promise<purify.Either<Error, readonly IdentifierOverride5Class[]>> {
    return this.$objects<
      IdentifierOverride5Class,
      IdentifierOverride5Class.$Identifier
    >(IdentifierOverride5Class, query);
  }

  async identifierOverride5ClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<IdentifierOverride5Class.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<IdentifierOverride5Class.$Identifier>(
      IdentifierOverride5Class,
      query,
    );
  }

  async indirectRecursiveClass(
    identifier: IndirectRecursiveClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveClass>> {
    return (
      await this.indirectRecursiveClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async indirectRecursiveClassIdentifiers(
    query?: $SparqlObjectSet.Query<IndirectRecursiveClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<IndirectRecursiveClass.$Identifier>(
      IndirectRecursiveClass,
      query,
    );
  }

  async indirectRecursiveClasses(
    query?: $SparqlObjectSet.Query<IndirectRecursiveClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveClass[]>> {
    return this.$objects<
      IndirectRecursiveClass,
      IndirectRecursiveClass.$Identifier
    >(IndirectRecursiveClass, query);
  }

  async indirectRecursiveClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<IndirectRecursiveClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<IndirectRecursiveClass.$Identifier>(
      IndirectRecursiveClass,
      query,
    );
  }

  async indirectRecursiveHelperClass(
    identifier: IndirectRecursiveHelperClass.$Identifier,
  ): Promise<purify.Either<Error, IndirectRecursiveHelperClass>> {
    return (
      await this.indirectRecursiveHelperClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async indirectRecursiveHelperClassIdentifiers(
    query?: $SparqlObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IndirectRecursiveHelperClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<IndirectRecursiveHelperClass.$Identifier>(
      IndirectRecursiveHelperClass,
      query,
    );
  }

  async indirectRecursiveHelperClasses(
    query?: $SparqlObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IndirectRecursiveHelperClass[]>> {
    return this.$objects<
      IndirectRecursiveHelperClass,
      IndirectRecursiveHelperClass.$Identifier
    >(IndirectRecursiveHelperClass, query);
  }

  async indirectRecursiveHelperClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<IndirectRecursiveHelperClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<IndirectRecursiveHelperClass.$Identifier>(
      IndirectRecursiveHelperClass,
      query,
    );
  }

  async inIdentifierClass(
    identifier: InIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, InIdentifierClass>> {
    return (
      await this.inIdentifierClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async inIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<InIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass.$Identifier[]>> {
    return this.$objectIdentifiers<InIdentifierClass.$Identifier>(
      InIdentifierClass,
      query,
    );
  }

  async inIdentifierClasses(
    query?: $SparqlObjectSet.Query<InIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InIdentifierClass[]>> {
    return this.$objects<InIdentifierClass, InIdentifierClass.$Identifier>(
      InIdentifierClass,
      query,
    );
  }

  async inIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<InIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<InIdentifierClass.$Identifier>(
      InIdentifierClass,
      query,
    );
  }

  async inPropertiesClass(
    identifier: InPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, InPropertiesClass>> {
    return (
      await this.inPropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async inPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<InPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<InPropertiesClass.$Identifier>(
      InPropertiesClass,
      query,
    );
  }

  async inPropertiesClasses(
    query?: $SparqlObjectSet.Query<InPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly InPropertiesClass[]>> {
    return this.$objects<InPropertiesClass, InPropertiesClass.$Identifier>(
      InPropertiesClass,
      query,
    );
  }

  async inPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<InPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<InPropertiesClass.$Identifier>(
      InPropertiesClass,
      query,
    );
  }

  async interface(
    identifier: Interface.$Identifier,
  ): Promise<purify.Either<Error, Interface>> {
    return (
      await this.interfaces({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async interfaceIdentifiers(
    query?: $SparqlObjectSet.Query<Interface.$Identifier>,
  ): Promise<purify.Either<Error, readonly Interface.$Identifier[]>> {
    return this.$objectIdentifiers<Interface.$Identifier>(Interface, query);
  }

  async interfaces(
    query?: $SparqlObjectSet.Query<Interface.$Identifier>,
  ): Promise<purify.Either<Error, readonly Interface[]>> {
    return this.$objects<Interface, Interface.$Identifier>(Interface, query);
  }

  async interfacesCount(
    query?: Pick<$SparqlObjectSet.Query<Interface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<Interface.$Identifier>(Interface, query);
  }

  async interfaceUnionMember1(
    identifier: InterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember1>> {
    return (
      await this.interfaceUnionMember1s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async interfaceUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<InterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember1.$Identifier[]>
  > {
    return this.$objectIdentifiers<InterfaceUnionMember1.$Identifier>(
      InterfaceUnionMember1,
      query,
    );
  }

  async interfaceUnionMember1s(
    query?: $SparqlObjectSet.Query<InterfaceUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember1[]>> {
    return this.$objects<
      InterfaceUnionMember1,
      InterfaceUnionMember1.$Identifier
    >(InterfaceUnionMember1, query);
  }

  async interfaceUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<InterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<InterfaceUnionMember1.$Identifier>(
      InterfaceUnionMember1,
      query,
    );
  }

  async interfaceUnionMember2(
    identifier: InterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnionMember2>> {
    return (
      await this.interfaceUnionMember2s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async interfaceUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<InterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly InterfaceUnionMember2.$Identifier[]>
  > {
    return this.$objectIdentifiers<InterfaceUnionMember2.$Identifier>(
      InterfaceUnionMember2,
      query,
    );
  }

  async interfaceUnionMember2s(
    query?: $SparqlObjectSet.Query<InterfaceUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnionMember2[]>> {
    return this.$objects<
      InterfaceUnionMember2,
      InterfaceUnionMember2.$Identifier
    >(InterfaceUnionMember2, query);
  }

  async interfaceUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<InterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<InterfaceUnionMember2.$Identifier>(
      InterfaceUnionMember2,
      query,
    );
  }

  async iriIdentifierClass(
    identifier: IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, IriIdentifierClass>> {
    return (
      await this.iriIdentifierClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async iriIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<IriIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IriIdentifierClass.$Identifier[]>> {
    return this.$objectIdentifiers<IriIdentifierClass.$Identifier>(
      IriIdentifierClass,
      query,
    );
  }

  async iriIdentifierClasses(
    query?: $SparqlObjectSet.Query<IriIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly IriIdentifierClass[]>> {
    return this.$objects<IriIdentifierClass, IriIdentifierClass.$Identifier>(
      IriIdentifierClass,
      query,
    );
  }

  async iriIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<IriIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<IriIdentifierClass.$Identifier>(
      IriIdentifierClass,
      query,
    );
  }

  async iriIdentifierInterface(
    identifier: IriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, IriIdentifierInterface>> {
    return (
      await this.iriIdentifierInterfaces({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async iriIdentifierInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<IriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IriIdentifierInterface.$Identifier[]>
  > {
    return this.$objectIdentifiers<IriIdentifierInterface.$Identifier>(
      IriIdentifierInterface,
      query,
    );
  }

  async iriIdentifierInterfaces(
    query?: $SparqlObjectSet.Query<IriIdentifierInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly IriIdentifierInterface[]>> {
    return this.$objects<
      IriIdentifierInterface,
      IriIdentifierInterface.$Identifier
    >(IriIdentifierInterface, query);
  }

  async iriIdentifierInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<IriIdentifierInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<IriIdentifierInterface.$Identifier>(
      IriIdentifierInterface,
      query,
    );
  }

  async jsPrimitiveUnionPropertyClass(
    identifier: JsPrimitiveUnionPropertyClass.$Identifier,
  ): Promise<purify.Either<Error, JsPrimitiveUnionPropertyClass>> {
    return (
      await this.jsPrimitiveUnionPropertyClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async jsPrimitiveUnionPropertyClassIdentifiers(
    query?: $SparqlObjectSet.Query<JsPrimitiveUnionPropertyClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly JsPrimitiveUnionPropertyClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<JsPrimitiveUnionPropertyClass.$Identifier>(
      JsPrimitiveUnionPropertyClass,
      query,
    );
  }

  async jsPrimitiveUnionPropertyClasses(
    query?: $SparqlObjectSet.Query<JsPrimitiveUnionPropertyClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly JsPrimitiveUnionPropertyClass[]>> {
    return this.$objects<
      JsPrimitiveUnionPropertyClass,
      JsPrimitiveUnionPropertyClass.$Identifier
    >(JsPrimitiveUnionPropertyClass, query);
  }

  async jsPrimitiveUnionPropertyClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<JsPrimitiveUnionPropertyClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<JsPrimitiveUnionPropertyClass.$Identifier>(
      JsPrimitiveUnionPropertyClass,
      query,
    );
  }

  async languageInPropertiesClass(
    identifier: LanguageInPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LanguageInPropertiesClass>> {
    return (
      await this.languageInPropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async languageInPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LanguageInPropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<LanguageInPropertiesClass.$Identifier>(
      LanguageInPropertiesClass,
      query,
    );
  }

  async languageInPropertiesClasses(
    query?: $SparqlObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LanguageInPropertiesClass[]>> {
    return this.$objects<
      LanguageInPropertiesClass,
      LanguageInPropertiesClass.$Identifier
    >(LanguageInPropertiesClass, query);
  }

  async languageInPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<LanguageInPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LanguageInPropertiesClass.$Identifier>(
      LanguageInPropertiesClass,
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClass(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier,
  ): Promise<
    purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierClass>
  > {
    return (
      await this.lazilyResolvedBlankNodeOrIriIdentifierClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier>(
      LazilyResolvedBlankNodeOrIriIdentifierClass,
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClasses(
    query?: $SparqlObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedBlankNodeOrIriIdentifierClass[]>
  > {
    return this.$objects<
      LazilyResolvedBlankNodeOrIriIdentifierClass,
      LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier
    >(LazilyResolvedBlankNodeOrIriIdentifierClass, query);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedBlankNodeOrIriIdentifierClass.$Identifier>(
      LazilyResolvedBlankNodeOrIriIdentifierClass,
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterface(
    identifier: LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier,
  ): Promise<
    purify.Either<Error, LazilyResolvedBlankNodeOrIriIdentifierInterface>
  > {
    return (
      await this.lazilyResolvedBlankNodeOrIriIdentifierInterfaces({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier>(
      LazilyResolvedBlankNodeOrIriIdentifierInterface,
      query,
    );
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterfaces(
    query?: $SparqlObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedBlankNodeOrIriIdentifierInterface[]
    >
  > {
    return this.$objects<
      LazilyResolvedBlankNodeOrIriIdentifierInterface,
      LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier
    >(LazilyResolvedBlankNodeOrIriIdentifierInterface, query);
  }

  async lazilyResolvedBlankNodeOrIriIdentifierInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedBlankNodeOrIriIdentifierInterface.$Identifier>(
      LazilyResolvedBlankNodeOrIriIdentifierInterface,
      query,
    );
  }

  async lazilyResolvedClassUnionMember1(
    identifier: LazilyResolvedClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember1>> {
    return (
      await this.lazilyResolvedClassUnionMember1s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember1.$Identifier[]>
  > {
    return this.$objectIdentifiers<LazilyResolvedClassUnionMember1.$Identifier>(
      LazilyResolvedClassUnionMember1,
      query,
    );
  }

  async lazilyResolvedClassUnionMember1s(
    query?: $SparqlObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember1[]>> {
    return this.$objects<
      LazilyResolvedClassUnionMember1,
      LazilyResolvedClassUnionMember1.$Identifier
    >(LazilyResolvedClassUnionMember1, query);
  }

  async lazilyResolvedClassUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedClassUnionMember1.$Identifier>(
      LazilyResolvedClassUnionMember1,
      query,
    );
  }

  async lazilyResolvedClassUnionMember2(
    identifier: LazilyResolvedClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnionMember2>> {
    return (
      await this.lazilyResolvedClassUnionMember2s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnionMember2.$Identifier[]>
  > {
    return this.$objectIdentifiers<LazilyResolvedClassUnionMember2.$Identifier>(
      LazilyResolvedClassUnionMember2,
      query,
    );
  }

  async lazilyResolvedClassUnionMember2s(
    query?: $SparqlObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnionMember2[]>> {
    return this.$objects<
      LazilyResolvedClassUnionMember2,
      LazilyResolvedClassUnionMember2.$Identifier
    >(LazilyResolvedClassUnionMember2, query);
  }

  async lazilyResolvedClassUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedClassUnionMember2.$Identifier>(
      LazilyResolvedClassUnionMember2,
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember1(
    identifier: LazilyResolvedInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember1>> {
    return (
      await this.lazilyResolvedInterfaceUnionMember1s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember1.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<LazilyResolvedInterfaceUnionMember1.$Identifier>(
      LazilyResolvedInterfaceUnionMember1,
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember1s(
    query?: $SparqlObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember1[]>
  > {
    return this.$objects<
      LazilyResolvedInterfaceUnionMember1,
      LazilyResolvedInterfaceUnionMember1.$Identifier
    >(LazilyResolvedInterfaceUnionMember1, query);
  }

  async lazilyResolvedInterfaceUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedInterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedInterfaceUnionMember1.$Identifier>(
      LazilyResolvedInterfaceUnionMember1,
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember2(
    identifier: LazilyResolvedInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnionMember2>> {
    return (
      await this.lazilyResolvedInterfaceUnionMember2s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedInterfaceUnionMember2.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<LazilyResolvedInterfaceUnionMember2.$Identifier>(
      LazilyResolvedInterfaceUnionMember2,
      query,
    );
  }

  async lazilyResolvedInterfaceUnionMember2s(
    query?: $SparqlObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnionMember2[]>
  > {
    return this.$objects<
      LazilyResolvedInterfaceUnionMember2,
      LazilyResolvedInterfaceUnionMember2.$Identifier
    >(LazilyResolvedInterfaceUnionMember2, query);
  }

  async lazilyResolvedInterfaceUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedInterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedInterfaceUnionMember2.$Identifier>(
      LazilyResolvedInterfaceUnionMember2,
      query,
    );
  }

  async lazilyResolvedIriIdentifierClass(
    identifier: LazilyResolvedIriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriIdentifierClass>> {
    return (
      await this.lazilyResolvedIriIdentifierClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedIriIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedIriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedIriIdentifierClass.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<LazilyResolvedIriIdentifierClass.$Identifier>(
      LazilyResolvedIriIdentifierClass,
      query,
    );
  }

  async lazilyResolvedIriIdentifierClasses(
    query?: $SparqlObjectSet.Query<LazilyResolvedIriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriIdentifierClass[]>
  > {
    return this.$objects<
      LazilyResolvedIriIdentifierClass,
      LazilyResolvedIriIdentifierClass.$Identifier
    >(LazilyResolvedIriIdentifierClass, query);
  }

  async lazilyResolvedIriIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedIriIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedIriIdentifierClass.$Identifier>(
      LazilyResolvedIriIdentifierClass,
      query,
    );
  }

  async lazilyResolvedIriIdentifierInterface(
    identifier: LazilyResolvedIriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedIriIdentifierInterface>> {
    return (
      await this.lazilyResolvedIriIdentifierInterfaces({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedIriIdentifierInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<
      Error,
      readonly LazilyResolvedIriIdentifierInterface.$Identifier[]
    >
  > {
    return this.$objectIdentifiers<LazilyResolvedIriIdentifierInterface.$Identifier>(
      LazilyResolvedIriIdentifierInterface,
      query,
    );
  }

  async lazilyResolvedIriIdentifierInterfaces(
    query?: $SparqlObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedIriIdentifierInterface[]>
  > {
    return this.$objects<
      LazilyResolvedIriIdentifierInterface,
      LazilyResolvedIriIdentifierInterface.$Identifier
    >(LazilyResolvedIriIdentifierInterface, query);
  }

  async lazilyResolvedIriIdentifierInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedIriIdentifierInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedIriIdentifierInterface.$Identifier>(
      LazilyResolvedIriIdentifierInterface,
      query,
    );
  }

  async lazyPropertiesClass(
    identifier: LazyPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesClass>> {
    return (
      await this.lazyPropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazyPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<LazyPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<LazyPropertiesClass.$Identifier>(
      LazyPropertiesClass,
      query,
    );
  }

  async lazyPropertiesClasses(
    query?: $SparqlObjectSet.Query<LazyPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesClass[]>> {
    return this.$objects<LazyPropertiesClass, LazyPropertiesClass.$Identifier>(
      LazyPropertiesClass,
      query,
    );
  }

  async lazyPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazyPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazyPropertiesClass.$Identifier>(
      LazyPropertiesClass,
      query,
    );
  }

  async lazyPropertiesInterface(
    identifier: LazyPropertiesInterface.$Identifier,
  ): Promise<purify.Either<Error, LazyPropertiesInterface>> {
    return (
      await this.lazyPropertiesInterfaces({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazyPropertiesInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<LazyPropertiesInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazyPropertiesInterface.$Identifier[]>
  > {
    return this.$objectIdentifiers<LazyPropertiesInterface.$Identifier>(
      LazyPropertiesInterface,
      query,
    );
  }

  async lazyPropertiesInterfaces(
    query?: $SparqlObjectSet.Query<LazyPropertiesInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazyPropertiesInterface[]>> {
    return this.$objects<
      LazyPropertiesInterface,
      LazyPropertiesInterface.$Identifier
    >(LazyPropertiesInterface, query);
  }

  async lazyPropertiesInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazyPropertiesInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazyPropertiesInterface.$Identifier>(
      LazyPropertiesInterface,
      query,
    );
  }

  async listPropertiesClass(
    identifier: ListPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, ListPropertiesClass>> {
    return (
      await this.listPropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async listPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<ListPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<ListPropertiesClass.$Identifier>(
      ListPropertiesClass,
      query,
    );
  }

  async listPropertiesClasses(
    query?: $SparqlObjectSet.Query<ListPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListPropertiesClass[]>> {
    return this.$objects<ListPropertiesClass, ListPropertiesClass.$Identifier>(
      ListPropertiesClass,
      query,
    );
  }

  async listPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<ListPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ListPropertiesClass.$Identifier>(
      ListPropertiesClass,
      query,
    );
  }

  async mutablePropertiesClass(
    identifier: MutablePropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, MutablePropertiesClass>> {
    return (
      await this.mutablePropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async mutablePropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<MutablePropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly MutablePropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<MutablePropertiesClass.$Identifier>(
      MutablePropertiesClass,
      query,
    );
  }

  async mutablePropertiesClasses(
    query?: $SparqlObjectSet.Query<MutablePropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly MutablePropertiesClass[]>> {
    return this.$objects<
      MutablePropertiesClass,
      MutablePropertiesClass.$Identifier
    >(MutablePropertiesClass, query);
  }

  async mutablePropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<MutablePropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<MutablePropertiesClass.$Identifier>(
      MutablePropertiesClass,
      query,
    );
  }

  async nonClass(
    identifier: NonClass.$Identifier,
  ): Promise<purify.Either<Error, NonClass>> {
    return (
      await this.nonClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async nonClassIdentifiers(
    query?: $SparqlObjectSet.Query<NonClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly NonClass.$Identifier[]>> {
    return this.$objectIdentifiers<NonClass.$Identifier>(NonClass, query);
  }

  async nonClasses(
    query?: $SparqlObjectSet.Query<NonClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly NonClass[]>> {
    return this.$objects<NonClass, NonClass.$Identifier>(NonClass, query);
  }

  async nonClassesCount(
    query?: Pick<$SparqlObjectSet.Query<NonClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<NonClass.$Identifier>(NonClass, query);
  }

  async noRdfTypeClassUnionMember1(
    identifier: NoRdfTypeClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnionMember1>> {
    return (
      await this.noRdfTypeClassUnionMember1s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async noRdfTypeClassUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<NoRdfTypeClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly NoRdfTypeClassUnionMember1.$Identifier[]>
  > {
    return this.$objectIdentifiers<NoRdfTypeClassUnionMember1.$Identifier>(
      NoRdfTypeClassUnionMember1,
      query,
    );
  }

  async noRdfTypeClassUnionMember1s(
    query?: $SparqlObjectSet.Query<NoRdfTypeClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnionMember1[]>> {
    return this.$objects<
      NoRdfTypeClassUnionMember1,
      NoRdfTypeClassUnionMember1.$Identifier
    >(NoRdfTypeClassUnionMember1, query);
  }

  async noRdfTypeClassUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<NoRdfTypeClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<NoRdfTypeClassUnionMember1.$Identifier>(
      NoRdfTypeClassUnionMember1,
      query,
    );
  }

  async noRdfTypeClassUnionMember2(
    identifier: NoRdfTypeClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnionMember2>> {
    return (
      await this.noRdfTypeClassUnionMember2s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async noRdfTypeClassUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<NoRdfTypeClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly NoRdfTypeClassUnionMember2.$Identifier[]>
  > {
    return this.$objectIdentifiers<NoRdfTypeClassUnionMember2.$Identifier>(
      NoRdfTypeClassUnionMember2,
      query,
    );
  }

  async noRdfTypeClassUnionMember2s(
    query?: $SparqlObjectSet.Query<NoRdfTypeClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnionMember2[]>> {
    return this.$objects<
      NoRdfTypeClassUnionMember2,
      NoRdfTypeClassUnionMember2.$Identifier
    >(NoRdfTypeClassUnionMember2, query);
  }

  async noRdfTypeClassUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<NoRdfTypeClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<NoRdfTypeClassUnionMember2.$Identifier>(
      NoRdfTypeClassUnionMember2,
      query,
    );
  }

  async orderedPropertiesClass(
    identifier: OrderedPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, OrderedPropertiesClass>> {
    return (
      await this.orderedPropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async orderedPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<OrderedPropertiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly OrderedPropertiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<OrderedPropertiesClass.$Identifier>(
      OrderedPropertiesClass,
      query,
    );
  }

  async orderedPropertiesClasses(
    query?: $SparqlObjectSet.Query<OrderedPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly OrderedPropertiesClass[]>> {
    return this.$objects<
      OrderedPropertiesClass,
      OrderedPropertiesClass.$Identifier
    >(OrderedPropertiesClass, query);
  }

  async orderedPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<OrderedPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<OrderedPropertiesClass.$Identifier>(
      OrderedPropertiesClass,
      query,
    );
  }

  async partialClass(
    identifier: PartialClass.$Identifier,
  ): Promise<purify.Either<Error, PartialClass>> {
    return (
      await this.partialClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async partialClassIdentifiers(
    query?: $SparqlObjectSet.Query<PartialClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClass.$Identifier[]>> {
    return this.$objectIdentifiers<PartialClass.$Identifier>(
      PartialClass,
      query,
    );
  }

  async partialClasses(
    query?: $SparqlObjectSet.Query<PartialClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClass[]>> {
    return this.$objects<PartialClass, PartialClass.$Identifier>(
      PartialClass,
      query,
    );
  }

  async partialClassesCount(
    query?: Pick<$SparqlObjectSet.Query<PartialClass.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialClass.$Identifier>(PartialClass, query);
  }

  async partialClassUnionMember1(
    identifier: PartialClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember1>> {
    return (
      await this.partialClassUnionMember1s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async partialClassUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<PartialClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember1.$Identifier[]>
  > {
    return this.$objectIdentifiers<PartialClassUnionMember1.$Identifier>(
      PartialClassUnionMember1,
      query,
    );
  }

  async partialClassUnionMember1s(
    query?: $SparqlObjectSet.Query<PartialClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember1[]>> {
    return this.$objects<
      PartialClassUnionMember1,
      PartialClassUnionMember1.$Identifier
    >(PartialClassUnionMember1, query);
  }

  async partialClassUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<PartialClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialClassUnionMember1.$Identifier>(
      PartialClassUnionMember1,
      query,
    );
  }

  async partialClassUnionMember2(
    identifier: PartialClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnionMember2>> {
    return (
      await this.partialClassUnionMember2s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async partialClassUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<PartialClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialClassUnionMember2.$Identifier[]>
  > {
    return this.$objectIdentifiers<PartialClassUnionMember2.$Identifier>(
      PartialClassUnionMember2,
      query,
    );
  }

  async partialClassUnionMember2s(
    query?: $SparqlObjectSet.Query<PartialClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnionMember2[]>> {
    return this.$objects<
      PartialClassUnionMember2,
      PartialClassUnionMember2.$Identifier
    >(PartialClassUnionMember2, query);
  }

  async partialClassUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<PartialClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialClassUnionMember2.$Identifier>(
      PartialClassUnionMember2,
      query,
    );
  }

  async partialInterface(
    identifier: PartialInterface.$Identifier,
  ): Promise<purify.Either<Error, PartialInterface>> {
    return (
      await this.partialInterfaces({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async partialInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<PartialInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterface.$Identifier[]>> {
    return this.$objectIdentifiers<PartialInterface.$Identifier>(
      PartialInterface,
      query,
    );
  }

  async partialInterfaces(
    query?: $SparqlObjectSet.Query<PartialInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterface[]>> {
    return this.$objects<PartialInterface, PartialInterface.$Identifier>(
      PartialInterface,
      query,
    );
  }

  async partialInterfacesCount(
    query?: Pick<$SparqlObjectSet.Query<PartialInterface.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialInterface.$Identifier>(
      PartialInterface,
      query,
    );
  }

  async partialInterfaceUnionMember1(
    identifier: PartialInterfaceUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember1>> {
    return (
      await this.partialInterfaceUnionMember1s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async partialInterfaceUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember1.$Identifier[]>
  > {
    return this.$objectIdentifiers<PartialInterfaceUnionMember1.$Identifier>(
      PartialInterfaceUnionMember1,
      query,
    );
  }

  async partialInterfaceUnionMember1s(
    query?: $SparqlObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember1[]>> {
    return this.$objects<
      PartialInterfaceUnionMember1,
      PartialInterfaceUnionMember1.$Identifier
    >(PartialInterfaceUnionMember1, query);
  }

  async partialInterfaceUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<PartialInterfaceUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialInterfaceUnionMember1.$Identifier>(
      PartialInterfaceUnionMember1,
      query,
    );
  }

  async partialInterfaceUnionMember2(
    identifier: PartialInterfaceUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnionMember2>> {
    return (
      await this.partialInterfaceUnionMember2s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async partialInterfaceUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnionMember2.$Identifier[]>
  > {
    return this.$objectIdentifiers<PartialInterfaceUnionMember2.$Identifier>(
      PartialInterfaceUnionMember2,
      query,
    );
  }

  async partialInterfaceUnionMember2s(
    query?: $SparqlObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnionMember2[]>> {
    return this.$objects<
      PartialInterfaceUnionMember2,
      PartialInterfaceUnionMember2.$Identifier
    >(PartialInterfaceUnionMember2, query);
  }

  async partialInterfaceUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<PartialInterfaceUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialInterfaceUnionMember2.$Identifier>(
      PartialInterfaceUnionMember2,
      query,
    );
  }

  async propertyCardinalitiesClass(
    identifier: PropertyCardinalitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyCardinalitiesClass>> {
    return (
      await this.propertyCardinalitiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async propertyCardinalitiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PropertyCardinalitiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<PropertyCardinalitiesClass.$Identifier>(
      PropertyCardinalitiesClass,
      query,
    );
  }

  async propertyCardinalitiesClasses(
    query?: $SparqlObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PropertyCardinalitiesClass[]>> {
    return this.$objects<
      PropertyCardinalitiesClass,
      PropertyCardinalitiesClass.$Identifier
    >(PropertyCardinalitiesClass, query);
  }

  async propertyCardinalitiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<PropertyCardinalitiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PropertyCardinalitiesClass.$Identifier>(
      PropertyCardinalitiesClass,
      query,
    );
  }

  async propertyVisibilitiesClass(
    identifier: PropertyVisibilitiesClass.$Identifier,
  ): Promise<purify.Either<Error, PropertyVisibilitiesClass>> {
    return (
      await this.propertyVisibilitiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async propertyVisibilitiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PropertyVisibilitiesClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<PropertyVisibilitiesClass.$Identifier>(
      PropertyVisibilitiesClass,
      query,
    );
  }

  async propertyVisibilitiesClasses(
    query?: $SparqlObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly PropertyVisibilitiesClass[]>> {
    return this.$objects<
      PropertyVisibilitiesClass,
      PropertyVisibilitiesClass.$Identifier
    >(PropertyVisibilitiesClass, query);
  }

  async propertyVisibilitiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<PropertyVisibilitiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PropertyVisibilitiesClass.$Identifier>(
      PropertyVisibilitiesClass,
      query,
    );
  }

  async recursiveClassUnionMember1(
    identifier: RecursiveClassUnionMember1.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember1>> {
    return (
      await this.recursiveClassUnionMember1s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async recursiveClassUnionMember1Identifiers(
    query?: $SparqlObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember1.$Identifier[]>
  > {
    return this.$objectIdentifiers<RecursiveClassUnionMember1.$Identifier>(
      RecursiveClassUnionMember1,
      query,
    );
  }

  async recursiveClassUnionMember1s(
    query?: $SparqlObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember1[]>> {
    return this.$objects<
      RecursiveClassUnionMember1,
      RecursiveClassUnionMember1.$Identifier
    >(RecursiveClassUnionMember1, query);
  }

  async recursiveClassUnionMember1sCount(
    query?: Pick<
      $SparqlObjectSet.Query<RecursiveClassUnionMember1.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<RecursiveClassUnionMember1.$Identifier>(
      RecursiveClassUnionMember1,
      query,
    );
  }

  async recursiveClassUnionMember2(
    identifier: RecursiveClassUnionMember2.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnionMember2>> {
    return (
      await this.recursiveClassUnionMember2s({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async recursiveClassUnionMember2Identifiers(
    query?: $SparqlObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RecursiveClassUnionMember2.$Identifier[]>
  > {
    return this.$objectIdentifiers<RecursiveClassUnionMember2.$Identifier>(
      RecursiveClassUnionMember2,
      query,
    );
  }

  async recursiveClassUnionMember2s(
    query?: $SparqlObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnionMember2[]>> {
    return this.$objects<
      RecursiveClassUnionMember2,
      RecursiveClassUnionMember2.$Identifier
    >(RecursiveClassUnionMember2, query);
  }

  async recursiveClassUnionMember2sCount(
    query?: Pick<
      $SparqlObjectSet.Query<RecursiveClassUnionMember2.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<RecursiveClassUnionMember2.$Identifier>(
      RecursiveClassUnionMember2,
      query,
    );
  }

  async sha256IriIdentifierClass(
    identifier: Sha256IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, Sha256IriIdentifierClass>> {
    return (
      await this.sha256IriIdentifierClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async sha256IriIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<Sha256IriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly Sha256IriIdentifierClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<Sha256IriIdentifierClass.$Identifier>(
      Sha256IriIdentifierClass,
      query,
    );
  }

  async sha256IriIdentifierClasses(
    query?: $SparqlObjectSet.Query<Sha256IriIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly Sha256IriIdentifierClass[]>> {
    return this.$objects<
      Sha256IriIdentifierClass,
      Sha256IriIdentifierClass.$Identifier
    >(Sha256IriIdentifierClass, query);
  }

  async sha256IriIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<Sha256IriIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<Sha256IriIdentifierClass.$Identifier>(
      Sha256IriIdentifierClass,
      query,
    );
  }

  async termPropertiesClass(
    identifier: TermPropertiesClass.$Identifier,
  ): Promise<purify.Either<Error, TermPropertiesClass>> {
    return (
      await this.termPropertiesClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async termPropertiesClassIdentifiers(
    query?: $SparqlObjectSet.Query<TermPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass.$Identifier[]>> {
    return this.$objectIdentifiers<TermPropertiesClass.$Identifier>(
      TermPropertiesClass,
      query,
    );
  }

  async termPropertiesClasses(
    query?: $SparqlObjectSet.Query<TermPropertiesClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly TermPropertiesClass[]>> {
    return this.$objects<TermPropertiesClass, TermPropertiesClass.$Identifier>(
      TermPropertiesClass,
      query,
    );
  }

  async termPropertiesClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<TermPropertiesClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<TermPropertiesClass.$Identifier>(
      TermPropertiesClass,
      query,
    );
  }

  async unionDiscriminantsClass(
    identifier: UnionDiscriminantsClass.$Identifier,
  ): Promise<purify.Either<Error, UnionDiscriminantsClass>> {
    return (
      await this.unionDiscriminantsClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async unionDiscriminantsClassIdentifiers(
    query?: $SparqlObjectSet.Query<UnionDiscriminantsClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly UnionDiscriminantsClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<UnionDiscriminantsClass.$Identifier>(
      UnionDiscriminantsClass,
      query,
    );
  }

  async unionDiscriminantsClasses(
    query?: $SparqlObjectSet.Query<UnionDiscriminantsClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly UnionDiscriminantsClass[]>> {
    return this.$objects<
      UnionDiscriminantsClass,
      UnionDiscriminantsClass.$Identifier
    >(UnionDiscriminantsClass, query);
  }

  async unionDiscriminantsClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<UnionDiscriminantsClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<UnionDiscriminantsClass.$Identifier>(
      UnionDiscriminantsClass,
      query,
    );
  }

  async uuidV4IriIdentifierClass(
    identifier: UuidV4IriIdentifierClass.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriIdentifierClass>> {
    return (
      await this.uuidV4IriIdentifierClasses({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async uuidV4IriIdentifierClassIdentifiers(
    query?: $SparqlObjectSet.Query<UuidV4IriIdentifierClass.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly UuidV4IriIdentifierClass.$Identifier[]>
  > {
    return this.$objectIdentifiers<UuidV4IriIdentifierClass.$Identifier>(
      UuidV4IriIdentifierClass,
      query,
    );
  }

  async uuidV4IriIdentifierClasses(
    query?: $SparqlObjectSet.Query<UuidV4IriIdentifierClass.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriIdentifierClass[]>> {
    return this.$objects<
      UuidV4IriIdentifierClass,
      UuidV4IriIdentifierClass.$Identifier
    >(UuidV4IriIdentifierClass, query);
  }

  async uuidV4IriIdentifierClassesCount(
    query?: Pick<
      $SparqlObjectSet.Query<UuidV4IriIdentifierClass.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<UuidV4IriIdentifierClass.$Identifier>(
      UuidV4IriIdentifierClass,
      query,
    );
  }

  async uuidV4IriIdentifierInterface(
    identifier: UuidV4IriIdentifierInterface.$Identifier,
  ): Promise<purify.Either<Error, UuidV4IriIdentifierInterface>> {
    return (
      await this.uuidV4IriIdentifierInterfaces({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async uuidV4IriIdentifierInterfaceIdentifiers(
    query?: $SparqlObjectSet.Query<UuidV4IriIdentifierInterface.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly UuidV4IriIdentifierInterface.$Identifier[]>
  > {
    return this.$objectIdentifiers<UuidV4IriIdentifierInterface.$Identifier>(
      UuidV4IriIdentifierInterface,
      query,
    );
  }

  async uuidV4IriIdentifierInterfaces(
    query?: $SparqlObjectSet.Query<UuidV4IriIdentifierInterface.$Identifier>,
  ): Promise<purify.Either<Error, readonly UuidV4IriIdentifierInterface[]>> {
    return this.$objects<
      UuidV4IriIdentifierInterface,
      UuidV4IriIdentifierInterface.$Identifier
    >(UuidV4IriIdentifierInterface, query);
  }

  async uuidV4IriIdentifierInterfacesCount(
    query?: Pick<
      $SparqlObjectSet.Query<UuidV4IriIdentifierInterface.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<UuidV4IriIdentifierInterface.$Identifier>(
      UuidV4IriIdentifierInterface,
      query,
    );
  }

  async classUnion(
    identifier: ClassUnion.$Identifier,
  ): Promise<purify.Either<Error, ClassUnion>> {
    return (
      await this.classUnions({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async classUnionIdentifiers(
    query?: $SparqlObjectSet.Query<ClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnion.$Identifier[]>> {
    return this.$objectIdentifiers<ClassUnion.$Identifier>(ClassUnion, query);
  }

  async classUnions(
    query?: $SparqlObjectSet.Query<ClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly ClassUnion[]>> {
    return this.$objects<ClassUnion, ClassUnion.$Identifier>(ClassUnion, query);
  }

  async classUnionsCount(
    query?: Pick<$SparqlObjectSet.Query<ClassUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ClassUnion.$Identifier>(ClassUnion, query);
  }

  async flattenClassUnion(
    identifier: FlattenClassUnion.$Identifier,
  ): Promise<purify.Either<Error, FlattenClassUnion>> {
    return (
      await this.flattenClassUnions({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async flattenClassUnionIdentifiers(
    query?: $SparqlObjectSet.Query<FlattenClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnion.$Identifier[]>> {
    return this.$objectIdentifiers<FlattenClassUnion.$Identifier>(
      FlattenClassUnion,
      query,
    );
  }

  async flattenClassUnions(
    query?: $SparqlObjectSet.Query<FlattenClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly FlattenClassUnion[]>> {
    return this.$objects<FlattenClassUnion, FlattenClassUnion.$Identifier>(
      FlattenClassUnion,
      query,
    );
  }

  async flattenClassUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<FlattenClassUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<FlattenClassUnion.$Identifier>(
      FlattenClassUnion,
      query,
    );
  }

  async interfaceUnion(
    identifier: InterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, InterfaceUnion>> {
    return (
      await this.interfaceUnions({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async interfaceUnionIdentifiers(
    query?: $SparqlObjectSet.Query<InterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion.$Identifier[]>> {
    return this.$objectIdentifiers<InterfaceUnion.$Identifier>(
      InterfaceUnion,
      query,
    );
  }

  async interfaceUnions(
    query?: $SparqlObjectSet.Query<InterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly InterfaceUnion[]>> {
    return this.$objects<InterfaceUnion, InterfaceUnion.$Identifier>(
      InterfaceUnion,
      query,
    );
  }

  async interfaceUnionsCount(
    query?: Pick<$SparqlObjectSet.Query<InterfaceUnion.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<InterfaceUnion.$Identifier>(
      InterfaceUnion,
      query,
    );
  }

  async lazilyResolvedClassUnion(
    identifier: LazilyResolvedClassUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedClassUnion>> {
    return (
      await this.lazilyResolvedClassUnions({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedClassUnionIdentifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedClassUnion.$Identifier[]>
  > {
    return this.$objectIdentifiers<LazilyResolvedClassUnion.$Identifier>(
      LazilyResolvedClassUnion,
      query,
    );
  }

  async lazilyResolvedClassUnions(
    query?: $SparqlObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedClassUnion[]>> {
    return this.$objects<
      LazilyResolvedClassUnion,
      LazilyResolvedClassUnion.$Identifier
    >(LazilyResolvedClassUnion, query);
  }

  async lazilyResolvedClassUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedClassUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedClassUnion.$Identifier>(
      LazilyResolvedClassUnion,
      query,
    );
  }

  async lazilyResolvedInterfaceUnion(
    identifier: LazilyResolvedInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, LazilyResolvedInterfaceUnion>> {
    return (
      await this.lazilyResolvedInterfaceUnions({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async lazilyResolvedInterfaceUnionIdentifiers(
    query?: $SparqlObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly LazilyResolvedInterfaceUnion.$Identifier[]>
  > {
    return this.$objectIdentifiers<LazilyResolvedInterfaceUnion.$Identifier>(
      LazilyResolvedInterfaceUnion,
      query,
    );
  }

  async lazilyResolvedInterfaceUnions(
    query?: $SparqlObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly LazilyResolvedInterfaceUnion[]>> {
    return this.$objects<
      LazilyResolvedInterfaceUnion,
      LazilyResolvedInterfaceUnion.$Identifier
    >(LazilyResolvedInterfaceUnion, query);
  }

  async lazilyResolvedInterfaceUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<LazilyResolvedInterfaceUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<LazilyResolvedInterfaceUnion.$Identifier>(
      LazilyResolvedInterfaceUnion,
      query,
    );
  }

  async noRdfTypeClassUnion(
    identifier: NoRdfTypeClassUnion.$Identifier,
  ): Promise<purify.Either<Error, NoRdfTypeClassUnion>> {
    return (
      await this.noRdfTypeClassUnions({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async noRdfTypeClassUnionIdentifiers(
    query?: $SparqlObjectSet.Query<NoRdfTypeClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnion.$Identifier[]>> {
    return this.$objectIdentifiers<NoRdfTypeClassUnion.$Identifier>(
      NoRdfTypeClassUnion,
      query,
    );
  }

  async noRdfTypeClassUnions(
    query?: $SparqlObjectSet.Query<NoRdfTypeClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly NoRdfTypeClassUnion[]>> {
    return this.$objects<NoRdfTypeClassUnion, NoRdfTypeClassUnion.$Identifier>(
      NoRdfTypeClassUnion,
      query,
    );
  }

  async noRdfTypeClassUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<NoRdfTypeClassUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<NoRdfTypeClassUnion.$Identifier>(
      NoRdfTypeClassUnion,
      query,
    );
  }

  async partialClassUnion(
    identifier: PartialClassUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialClassUnion>> {
    return (
      await this.partialClassUnions({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async partialClassUnionIdentifiers(
    query?: $SparqlObjectSet.Query<PartialClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion.$Identifier[]>> {
    return this.$objectIdentifiers<PartialClassUnion.$Identifier>(
      PartialClassUnion,
      query,
    );
  }

  async partialClassUnions(
    query?: $SparqlObjectSet.Query<PartialClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialClassUnion[]>> {
    return this.$objects<PartialClassUnion, PartialClassUnion.$Identifier>(
      PartialClassUnion,
      query,
    );
  }

  async partialClassUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<PartialClassUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialClassUnion.$Identifier>(
      PartialClassUnion,
      query,
    );
  }

  async partialInterfaceUnion(
    identifier: PartialInterfaceUnion.$Identifier,
  ): Promise<purify.Either<Error, PartialInterfaceUnion>> {
    return (
      await this.partialInterfaceUnions({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async partialInterfaceUnionIdentifiers(
    query?: $SparqlObjectSet.Query<PartialInterfaceUnion.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PartialInterfaceUnion.$Identifier[]>
  > {
    return this.$objectIdentifiers<PartialInterfaceUnion.$Identifier>(
      PartialInterfaceUnion,
      query,
    );
  }

  async partialInterfaceUnions(
    query?: $SparqlObjectSet.Query<PartialInterfaceUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly PartialInterfaceUnion[]>> {
    return this.$objects<
      PartialInterfaceUnion,
      PartialInterfaceUnion.$Identifier
    >(PartialInterfaceUnion, query);
  }

  async partialInterfaceUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<PartialInterfaceUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PartialInterfaceUnion.$Identifier>(
      PartialInterfaceUnion,
      query,
    );
  }

  async recursiveClassUnion(
    identifier: RecursiveClassUnion.$Identifier,
  ): Promise<purify.Either<Error, RecursiveClassUnion>> {
    return (
      await this.recursiveClassUnions({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    ).map((objects) => objects[0]);
  }

  async recursiveClassUnionIdentifiers(
    query?: $SparqlObjectSet.Query<RecursiveClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion.$Identifier[]>> {
    return this.$objectIdentifiers<RecursiveClassUnion.$Identifier>(
      RecursiveClassUnion,
      query,
    );
  }

  async recursiveClassUnions(
    query?: $SparqlObjectSet.Query<RecursiveClassUnion.$Identifier>,
  ): Promise<purify.Either<Error, readonly RecursiveClassUnion[]>> {
    return this.$objects<RecursiveClassUnion, RecursiveClassUnion.$Identifier>(
      RecursiveClassUnion,
      query,
    );
  }

  async recursiveClassUnionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<RecursiveClassUnion.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<RecursiveClassUnion.$Identifier>(
      RecursiveClassUnion,
      query,
    );
  }

  protected $mapBindingsToCount(
    bindings: readonly Record<
      string,
      rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
    >[],
    variable: string,
  ): purify.Either<Error, number> {
    if (bindings.length === 0) {
      return purify.Left(new Error("empty result rows"));
    }
    if (bindings.length > 1) {
      return purify.Left(new Error("more than one result row"));
    }
    const count = bindings[0][variable];
    if (typeof count === "undefined") {
      return purify.Left(new Error("no 'count' variable in result row"));
    }
    if (count.termType !== "Literal") {
      return purify.Left(new Error("'count' variable is not a Literal"));
    }
    const parsedCount = Number.parseInt(count.value, 10);
    if (Number.isNaN(parsedCount)) {
      return purify.Left(new Error("'count' variable is NaN"));
    }
    return purify.Either.of(parsedCount);
  }

  protected $mapBindingsToIdentifiers(
    bindings: readonly Record<
      string,
      rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
    >[],
    variable: string,
  ): readonly rdfjs.NamedNode[] {
    const identifiers: rdfjs.NamedNode[] = [];
    for (const bindings_ of bindings) {
      const identifier = bindings_[variable];
      if (
        typeof identifier !== "undefined" &&
        identifier.termType === "NamedNode"
      ) {
        identifiers.push(identifier);
      }
    }
    return identifiers;
  }

  protected async $objectIdentifiers<
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectType: {
      $sparqlWherePatterns: (parameters?: {
        subject?: sparqljs.Triple["subject"];
      }) => readonly sparqljs.Pattern[];
    },
    query?: $SparqlObjectSet.Query<ObjectIdentifierT>,
  ): Promise<purify.Either<Error, readonly ObjectIdentifierT[]>> {
    const limit = query?.limit ?? Number.MAX_SAFE_INTEGER;
    if (limit <= 0) {
      return purify.Either.of([]);
    }

    let offset = query?.offset ?? 0;
    if (offset < 0) {
      offset = 0;
    }

    const wherePatterns = this.$wherePatterns(objectType, query?.where).filter(
      (pattern) => pattern.type !== "optional",
    );
    if (wherePatterns.length === 0) {
      return purify.Left(
        new Error("no required SPARQL WHERE patterns for identifiers"),
      );
    }

    const selectQueryString = this.$sparqlGenerator.stringify({
      distinct: true,
      limit: limit < Number.MAX_SAFE_INTEGER ? limit : undefined,
      offset,
      order: query?.order
        ? query.order(this.$objectVariable).concat()
        : [{ expression: this.$objectVariable }],
      prefixes: {},
      queryType: "SELECT",
      type: "query",
      variables: [this.$objectVariable],
      where: wherePatterns.concat(),
    });

    return purify.EitherAsync(
      async () =>
        this.$mapBindingsToIdentifiers(
          await this.$sparqlClient.queryBindings(selectQueryString),
          this.$objectVariable.value,
        ) as readonly ObjectIdentifierT[],
    );
  }

  async $objects<
    ObjectT,
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectType: {
      $fromRdf: (
        resource: rdfjsResource.Resource,
        options: { objectSet: $ObjectSet },
      ) => purify.Either<Error, ObjectT>;
      $sparqlConstructQueryString: (
        parameters?: { subject?: sparqljs.Triple["subject"] } & Omit<
          sparqljs.ConstructQuery,
          "prefixes" | "queryType" | "type"
        > &
          sparqljs.GeneratorOptions,
      ) => string;
      $sparqlWherePatterns: (parameters?: {
        subject?: sparqljs.Triple["subject"];
      }) => readonly sparqljs.Pattern[];
    },
    query?: $SparqlObjectSet.Query<ObjectIdentifierT>,
  ): Promise<purify.Either<Error, readonly ObjectT[]>> {
    const identifiersEither = await this.$objectIdentifiers<ObjectIdentifierT>(
      objectType,
      query,
    );
    if (identifiersEither.isLeft()) {
      return identifiersEither;
    }
    const identifiers = identifiersEither.unsafeCoerce();
    if (identifiers.length === 0) {
      return purify.Either.of([]);
    }

    const constructQueryString = objectType.$sparqlConstructQueryString({
      subject: this.$objectVariable,
      where: [
        {
          type: "values" as const,
          values: identifiers.map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow["?object"] = identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        },
      ],
    });

    let quads: readonly rdfjs.Quad[];
    try {
      quads = await this.$sparqlClient.queryQuads(constructQueryString);
    } catch (e) {
      return purify.Left(e as Error);
    }

    const dataset = datasetFactory.dataset(quads.concat());
    const objects: ObjectT[] = [];
    for (const identifier of identifiers) {
      const objectEither = objectType.$fromRdf(
        new rdfjsResource.Resource<rdfjs.NamedNode>({
          dataset,
          identifier: identifier as rdfjs.NamedNode,
        }),
        { objectSet: this },
      );
      if (objectEither.isLeft()) {
        return objectEither;
      }
      objects.push(objectEither.unsafeCoerce());
    }
    return purify.Either.of(objects);
  }

  protected async $objectsCount<
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectType: {
      $sparqlWherePatterns: (parameters?: {
        subject?: sparqljs.Triple["subject"];
      }) => readonly sparqljs.Pattern[];
    },
    query?: $SparqlObjectSet.Query<ObjectIdentifierT>,
  ): Promise<purify.Either<Error, number>> {
    const wherePatterns = this.$wherePatterns(objectType, query?.where).filter(
      (pattern) => pattern.type !== "optional",
    );
    if (wherePatterns.length === 0) {
      return purify.Left(
        new Error("no required SPARQL WHERE patterns for count"),
      );
    }

    const selectQueryString = this.$sparqlGenerator.stringify({
      prefixes: {},
      queryType: "SELECT",
      type: "query",
      variables: [
        {
          expression: {
            aggregation: "COUNT",
            distinct: true,
            expression: this.$objectVariable,
            type: "aggregate",
          },
          variable: this.$countVariable,
        },
      ],
      where: wherePatterns,
    });

    return purify.EitherAsync(async ({ liftEither }) =>
      liftEither(
        this.$mapBindingsToCount(
          await this.$sparqlClient.queryBindings(selectQueryString),
          this.$countVariable.value,
        ),
      ),
    );
  }

  protected $wherePatterns<
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectType: {
      $sparqlWherePatterns: (parameters?: {
        subject?: sparqljs.Triple["subject"];
      }) => readonly sparqljs.Pattern[];
    },
    where?: $SparqlObjectSet.Where<ObjectIdentifierT>,
  ): readonly sparqljs.Pattern[] {
    // Patterns should be most to least specific.
    const patterns: sparqljs.Pattern[] = [];

    const where_ = where ?? { type: "type" };
    switch (where_.type) {
      case "identifiers": {
        const valuePatternRowKey = `?${this.$objectVariable.value}`;
        patterns.push({
          type: "values" as const,
          values: where_.identifiers.map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow[valuePatternRowKey] = identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        });
        break;
      }

      case "sparql-patterns": {
        patterns.push(...where_.sparqlPatterns(this.$objectVariable));
        break;
      }

      case "triple-objects": {
        patterns.push({
          triples: [
            {
              subject: where_.subject ?? dataFactory.blankNode(),
              predicate: where_.predicate,
              object: this.$objectVariable,
            },
          ],
          type: "bgp",
        });

        if (where_.objectTermType === "NamedNode") {
          patterns.push({
            type: "filter" as const,
            expression: {
              type: "operation" as const,
              operator: "isIRI",
              args: [this.$objectVariable],
            },
          });
        }

        break;
      }

      case "triple-subjects": {
        patterns.push({
          triples: [
            {
              subject: this.$objectVariable,
              predicate: where_.predicate,
              object: where_.object ?? dataFactory.blankNode(),
            },
          ],
          type: "bgp",
        });

        if (where_.subjectTermType === "NamedNode") {
          patterns.push({
            type: "filter" as const,
            expression: {
              type: "operation" as const,
              operator: "isIRI",
              args: [this.$objectVariable],
            },
          });
        }

        break;
      }

      case "type": {
        // The type patterns are always added below.

        if (where_.identifierType === "NamedNode") {
          patterns.push({
            type: "filter" as const,
            expression: {
              type: "operation" as const,
              operator: "isIRI",
              args: [this.$objectVariable],
            },
          });
        }
        break;
      }
    }

    patterns.push(
      ...objectType.$sparqlWherePatterns({ subject: this.$objectVariable }),
    );

    return $insertSeedSparqlWherePattern(
      $optimizeSparqlWherePatterns(patterns),
    );
  }
}

export namespace $SparqlObjectSet {
  export type Query<
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  > = Omit<$ObjectSet.Query<ObjectIdentifierT>, "where"> & {
    readonly order?: (
      objectVariable: rdfjs.Variable,
    ) => readonly sparqljs.Ordering[];
    readonly where?: Where<ObjectIdentifierT>;
  };
  export type Where<
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  > =
    | $ObjectSet.Where<ObjectIdentifierT>
    | {
        readonly sparqlPatterns: (
          objectVariable: rdfjs.Variable,
        ) => readonly sparqljs.Pattern[];
        readonly type: "sparql-patterns";
      };
}
